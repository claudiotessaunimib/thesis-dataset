/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.spinner;
/**
 * Basic implementation of {@link SpinnerModel} simplifying event handling for custom models.
 * @author Kotcrab
 * @see SpinnerModel
 * @see IntSpinnerModel
 * @see FloatSpinnerModel
 * @see SimpleFloatSpinnerModel
 * @see ArraySpinnerModel
 * @since 1.0.2
 */
public abstract class AbstractSpinnerModel implements SpinnerModel {
	protected Spinner spinner;
	private boolean allowRebind;
	private boolean wrap;
	public AbstractSpinnerModel (boolean allowRebind) {
		this.allowRebind = allowRebind;
	}
	@Override
	public void bind (Spinner spinner) {
		if (this.spinner != null && allowRebind == false)
			throw new IllegalStateException("this spinner model can't be reused");
		this.spinner = spinner;
	}
	/**
	 * Step model up by one. Event and spinner update will be handled by {@link AbstractSpinnerModel}.
	 * @return true if value was changed, false otherwise.
	 */
	protected abstract boolean incrementModel ();
	/**
	 * Step model down by one. Event and spinner update will be handled by {@link AbstractSpinnerModel}.
	 * @return true if value was changed, false otherwise.
	 */
	protected abstract boolean decrementModel ();
	@Override
	public final boolean increment () {
		return increment(spinner.isProgrammaticChangeEvents());
	}
	@Override
	public final boolean increment (boolean fireEvent) {
		boolean valueChanged = incrementModel();
		if (valueChanged) spinner.notifyValueChanged(fireEvent);
		return valueChanged;
	}
	@Override
	public final boolean decrement () {
		return decrement(spinner.isProgrammaticChangeEvents());
	}
	@Override
	public final boolean decrement (boolean fireEvent) {
		boolean valueChanged = decrementModel();
		if (valueChanged) spinner.notifyValueChanged(fireEvent);
		return valueChanged;
	}
	@Override
	public boolean isWrap () {
		return wrap;
	}
	@Override
	public void setWrap (boolean wrap) {
		this.wrap = wrap;
	}
	/** @return true if this model can be reused with different spinner, false otherwise */
	public boolean isAllowRebind () {
		return allowRebind;
	}
	protected void setAllowRebind (boolean allowRebind) {
		this.allowRebind = allowRebind;
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.spinner;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.ui.Cell;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.Disableable;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.FocusListener;
import com.badlogic.gdx.utils.Pools;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.Timer.Task;
import com.kotcrab.vis.ui.Sizes;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.widget.*;
/**
 * Spinner can be used to select number or object using up and down buttons or by entering value into text field.
 * Supports custom models that allows selecting either int, floats or even custom objects.
 * <p>
 * Fires {@link ChangeListener.ChangeEvent} when value has changed however unlike some other widgets canceling the event
 * won't undo value change.
 * @author Kotcrab
 * @see SimpleFloatSpinnerModel
 * @see FloatSpinnerModel
 * @see IntSpinnerModel
 * @see ArraySpinnerModel
 * @since 1.0.2
 */
public class Spinner extends VisTable implements Disableable {
	private final Sizes sizes;
	private SpinnerModel model;
	//task is shared between two buttons
	private ButtonRepeatTask buttonRepeatTask = new ButtonRepeatTask();
	private VisImageButton upButton;
	private VisImageButton downButton;
	private Cell<VisValidatableTextField> textFieldCell;
	private Cell<VisLabel> labelCell;
	private TextFieldEventPolicy textFieldEventPolicy = TextFieldEventPolicy.ON_FOCUS_LOST;
	private boolean programmaticChangeEvents = true;
	private boolean disabled;
	public Spinner (String name, SpinnerModel model) {
		this("default", name, model);
	}
	public Spinner (String styleName, String name, SpinnerModel model) {
		this(VisUI.getSkin().get(styleName, SpinnerStyle.class), VisUI.getSizes(), name, model);
	}
	public Spinner (SpinnerStyle style, Sizes sizes, String name, SpinnerModel model) {
		this.sizes = sizes;
		this.model = model;
		VisTable buttonsTable = new VisTable();
		VisValidatableTextField textField = createTextField();
		upButton = new VisImageButton(style.up);
		downButton = new VisImageButton(style.down);
		buttonsTable.add(upButton).height(sizes.spinnerButtonHeight).row();
		buttonsTable.add(downButton).height(sizes.spinnerButtonHeight);
		labelCell = add(new VisLabel(""));
		setSelectorName(name);
		textFieldCell = add(textField).height(sizes.spinnerButtonHeight * 2).growX();
		add(buttonsTable);
		addButtonsListeners(upButton, downButton);
		model.bind(this);
	}
	private VisValidatableTextField createTextField () {
		VisValidatableTextField textField = new VisValidatableTextField() {
			@Override
			public float getPrefWidth () {
				return sizes.spinnerFieldSize;
			}
		};
		textField.setRestoreLastValid(true);
		textField.setProgrammaticChangeEvents(false);
		addTextFieldListeners(textField);
		return textField;
	}
	public void setModel (SpinnerModel model) {
		this.model = model;
		textFieldCell.setActor(createTextField());
		model.bind(this);
	}
	private void addButtonsListeners (VisImageButton upButton, VisImageButton downButton) {
		upButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				event.stop();
				getStage().setScrollFocus(getTextField());
				increment(true);
			}
		});
		downButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				event.stop();
				getStage().setScrollFocus(getTextField());
				decrement(true);
			}
		});
		upButton.addListener(new ButtonInputListener(true));
		downButton.addListener(new ButtonInputListener(false));
	}
	private void addTextFieldListeners (final VisTextField textField) {
		textField.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				event.stop();
				model.textChanged();
				if (textField.isInputValid() && textFieldEventPolicy == TextFieldEventPolicy.ON_KEY_TYPED) {
					notifyValueChanged(true);
				}
			}
		});
		textField.addListener(new FocusListener() {
			@Override
			public void keyboardFocusChanged (FocusEvent event, Actor actor, boolean focused) {
				if (focused == false) {
					getStage().setScrollFocus(null);
					if (textFieldEventPolicy == TextFieldEventPolicy.ON_FOCUS_LOST) {
						notifyValueChanged(true);
					}
				}
			}
		});
		textField.addListener(new InputListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				getStage().setScrollFocus(getTextField());
				return true;
			}
			@Override
			public boolean scrolled (InputEvent event, float x, float y, float amountX, float amountY) {
				if (disabled) {
					return false;
				}
				if (amountY >= 1) {
					decrement(true);
				} else if (amountY <= -1) {
					increment(true);
				}
				return true;
			}
			@Override
			public boolean keyDown (InputEvent event, int keycode) {
				if (keycode == Keys.ENTER) {
					notifyValueChanged(true);
					return true;
				}
				return false;
			}
		});
	}
	@Override
	public void setDisabled (boolean disabled) {
		this.disabled = disabled;
		upButton.setDisabled(disabled);
		downButton.setDisabled(disabled);
		getTextField().setDisabled(disabled);
	}
	@Override
	public boolean isDisabled () {
		return disabled;
	}
	public void setSelectorName (String name) {
		labelCell.getActor().setText(name);
		if (name == null || name.length() == 0) {
			labelCell.padRight(0);
		} else {
			labelCell.padRight(6);
		}
	}
	public String getSelectorName () {
		return labelCell.getActor().getText().toString();
	}
	public void increment () {
		model.increment(programmaticChangeEvents);
	}
	private void increment (boolean fireEvent) {
		model.increment(fireEvent);
	}
	public void decrement () {
		model.decrement(programmaticChangeEvents);
	}
	private void decrement (boolean fireEvent) {
		model.decrement(fireEvent);
	}
	/** If false, methods changing spinner value form code won't trigger change event, it will be fired only when user has changed value. */
	public void setProgrammaticChangeEvents (boolean programmaticChangeEvents) {
		this.programmaticChangeEvents = programmaticChangeEvents;
	}
	public boolean isProgrammaticChangeEvents () {
		return programmaticChangeEvents;
	}
	public void setTextFieldEventPolicy (TextFieldEventPolicy textFieldEventPolicy) {
		this.textFieldEventPolicy = textFieldEventPolicy;
	}
	public TextFieldEventPolicy getTextFieldEventPolicy () {
		return textFieldEventPolicy;
	}
	public int getMaxLength () {
		return getTextField().getMaxLength();
	}
	public void setMaxLength (int maxLength) {
		getTextField().setMaxLength(maxLength);
	}
	public SpinnerModel getModel () {
		return model;
	}
	/**
	 * Called by {@link SpinnerModel}. Notifies when underlying model value has changed and spinner text field must updated.
	 * Typically there is no need to call this method manually.
	 * @param fireEvent if true then {@link ChangeListener.ChangeEvent} will be fired
	 */
	public void notifyValueChanged (boolean fireEvent) {
		VisValidatableTextField textField = getTextField();
		int cursor = textField.getCursorPosition();
		textField.setCursorPosition(0);
		textField.setText(model.getText());
		textField.setCursorPosition(cursor);
		if (fireEvent) {
			ChangeListener.ChangeEvent changeEvent = Pools.obtain(ChangeListener.ChangeEvent.class);
			fire(changeEvent);
			Pools.free(changeEvent);
		}
	}
	public VisValidatableTextField getTextField () {
		return textFieldCell.getActor();
	}
	public static class SpinnerStyle {
		public Drawable up;
		public Drawable down;
		public SpinnerStyle () {
		}
		public SpinnerStyle (SpinnerStyle style) {
			this.up = style.up;
			this.down = style.down;
		}
		public SpinnerStyle (Drawable up, Drawable down) {
			this.up = up;
			this.down = down;
		}
	}
	private class ButtonRepeatTask extends Task {
		boolean advance;
		@Override
		public void run () {
			if (advance) {
				increment(true);
			} else {
				decrement(true);
			}
		}
	}
	/**
	 * Allows to configure how {@link Spinner} will fire {@link ChangeListener.ChangeEvent} after user interaction with
	 * Spinner text field.
	 * @since 1.1.6
	 */
	public enum TextFieldEventPolicy {
		/**
		 * Spinner change event will be only fired after user has pressed enter in text field. This mode is the default
		 * one prior to VisUI 1.1.6
		 */
		ON_ENTER_ONLY,
		/**
		 * Spinner change event will be always fired after text field has lost focus and entered value is valid. Note
		 * that event will be fired even if user has not changed actual value of spinner. Event won't be fired
		 * if current model determined that entered value is invalid. This mode is the default one.
		 */
		ON_FOCUS_LOST,
		/**
		 * Spinner change event will be fired right after user has typed something in the text field and model has
		 * determined that entered value is valid. Event won't be fired if entered value is invalid.
		 */
		ON_KEY_TYPED
	}
	private class ButtonInputListener extends InputListener {
		private float buttonRepeatInitialTime = 0.4f;
		private float buttonRepeatTime = 0.08f;
		private boolean advance;
		public ButtonInputListener (boolean advance) {
			this.advance = advance;
		}
		@Override
		public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
			if (buttonRepeatTask.isScheduled() == false) {
				buttonRepeatTask.advance = advance;
				buttonRepeatTask.cancel();
				Timer.schedule(buttonRepeatTask, buttonRepeatInitialTime, buttonRepeatTime);
			}
			return true;
		}
		@Override
		public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
			buttonRepeatTask.cancel();
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.spinner;
/**
 * Classes implementing this interface represent model that can be used with {@link Spinner}. Model defines what is scrolled
 * in spinner (eg. int numbers, floats or some arbitrary strings), set-ups input validation and updates it's value if user
 * changed text in spinner value text field.
 * <p>
 * Classes wanting to implement this interface should inherit from {@link AbstractSpinnerModel} to simplify event handling.
 * @author Kotcrab
 * @see AbstractSpinnerModel
 * @see IntSpinnerModel
 * @see FloatSpinnerModel
 * @see SimpleFloatSpinnerModel
 * @see ArraySpinnerModel
 * @since 1.0.2
 */
public interface SpinnerModel {
	/**
	 * Called when model is assigned to {@link Spinner}. When this is called Spinner has been initialised so it's safe to
	 * do operation on it such as adding custom validators to text field.
	 * <p>
	 * If this model can't be reused then in this function it should verify that it is not being bound for the second time.
	 * <p>
	 * After model has finished it's setup it should call {@link Spinner#notifyValueChanged(boolean)} with true to perform
	 * first update and set initial spinner value.
	 * @param spinner that this model was assigned to
	 */
	void bind (Spinner spinner);
	/**
	 * Called when spinner text has changed. Usually this is the moment when model has to update it's current value variable.
	 * If input is invalid when this it called then it should simply be ignored. If field loses focus while it is in
	 * invalid state then last valid value will be automatically restored. This should NOT call {@link Spinner#notifyValueChanged(boolean)}.
	 */
	void textChanged ();
	/**
	 * Steps model up by one. Depending of the implementation this could move model to next item or increment it's value by
	 * arbitrary amount. Implementation class MUST call {@link Spinner#notifyValueChanged(boolean)} with fireEvent param set to
	 * {@link Spinner#isProgrammaticChangeEvents()}
	 * <p>
	 * @return true when value was changed, false otherwise
	 */
	boolean increment ();
	/**
	 * Steps model up by one. Depending of the implementation this could move model to next item or increment it's value by
	 * arbitrary amount. Implementation class MUST call {@link Spinner#notifyValueChanged(boolean)} using fireEvent param as argument.
	 * <p>
	 * @return true when value was changed, false otherwise
	 */
	boolean increment (boolean fireEvent);
	/**
	 * Steps model down by one. Depending of the implementation this could move model to previous item or decrement it's value by
	 * arbitrary amount. Implementation class MUST call {@link Spinner#notifyValueChanged(boolean)} with fireEvent param set to
	 * {@link Spinner#isProgrammaticChangeEvents()}
	 * <p>
	 * @return true when value was changed, false otherwise
	 */
	boolean decrement ();
	/**
	 * Steps model down by one. Depending of the implementation this could move model to previous item or decrement it's value by
	 * arbitrary amount. Implementation class MUST call {@link Spinner#notifyValueChanged(boolean)} using fireEvent param as argument.
	 * <p>
	 * @return true when value was changed, false otherwise
	 */
	boolean decrement (boolean fireEvent);
	/**
	 * Allows to enable model wrapping: if last element of model is reached and {@link #decrement()} was called then it
	 * will be looped to first element. Same applies for last element and {@link #increment()}
	 * @param wrap whether to wrap this model or not
	 */
	void setWrap (boolean wrap);
	/** @return true if model wrapping is enabled, false otherwise. See {@link #setWrap(boolean)} */
	boolean isWrap ();
	/** @return text representation of current model value */
	String getText ();
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.spinner;
import com.kotcrab.vis.ui.util.*;
import com.kotcrab.vis.ui.widget.VisValidatableTextField;
import java.math.BigDecimal;
/**
 * Spinner model allowing to select float values. Uses {@link BigDecimal} to support high precession and support large numbers.
 * Consider using {@link SimpleFloatSpinnerModel} when such high precision is not needed as it will be faster and simpler to use.
 * @author Kotcrab
 * @see FloatSpinnerModel
 * @see IntSpinnerModel
 * @since 1.0.2
 */
public class FloatSpinnerModel extends AbstractSpinnerModel {
	private InputValidator boundsValidator = new BoundsValidator();
	private NumberDigitsTextFieldFilter textFieldFilter;
	private BigDecimal max;
	private BigDecimal min;
	private BigDecimal step;
	private BigDecimal current;
	private int scale = 0;
	public FloatSpinnerModel (String initialValue, String min, String max) {
		this(initialValue, min, max, "1", 1);
	}
	public FloatSpinnerModel (String initialValue, String min, String max, String step) {
		this(initialValue, min, max, step, 1);
	}
	public FloatSpinnerModel (String initialValue, String min, String max, String step, int scale) {
		this(new BigDecimal(initialValue), new BigDecimal(min), new BigDecimal(max), new BigDecimal(step), scale);
	}
	public FloatSpinnerModel (BigDecimal initialValue, BigDecimal min, BigDecimal max, BigDecimal step, int scale) {
		super(false);
		this.current = initialValue;
		this.max = max;
		this.min = min;
		this.step = step;
		this.scale = scale;
		if (this.min.compareTo(this.max) > 0) throw new IllegalArgumentException("min can't be > max");
		if (this.step.compareTo(BigDecimal.ZERO) <= 0) throw new IllegalArgumentException("step must be > 0");
		if (scale < 0) throw new IllegalArgumentException("scale must be >= 0");
	}
	@Override
	public void bind (Spinner spinner) {
		super.bind(spinner);
		setScale(scale, false);
		spinner.notifyValueChanged(true);
	}
	@Override
	public void textChanged () {
		String text = spinner.getTextField().getText();
		if (text.equals("")) {
			current = min.setScale(scale, BigDecimal.ROUND_HALF_UP);
		} else if (checkInputBounds(text)) {
			current = new BigDecimal(text);
		}
	}
	@Override
	public boolean incrementModel () {
		if (current.add(step).compareTo(max) > 0) {
			if (current.compareTo(max) == 0) {
				if (isWrap()) {
					current = min.setScale(scale, BigDecimal.ROUND_HALF_UP);
					return true;
				}
				return false;
			}
			current = max.setScale(scale, BigDecimal.ROUND_HALF_UP);
		} else {
			current = current.add(step);
		}
		return true;
	}
	@Override
	public boolean decrementModel () {
		if (current.subtract(step).compareTo(min) < 0) {
			if (current.compareTo(min) == 0) {
				if (isWrap()) {
					current = max.setScale(scale, BigDecimal.ROUND_HALF_UP);
					return true;
				}
				return false;
			}
			current = min.setScale(scale, BigDecimal.ROUND_HALF_UP);
		} else {
			current = current.subtract(step);
		}
		return true;
	}
	@Override
	public String getText () {
		return current.toPlainString();
	}
	public int getScale () {
		return scale;
	}
	/**
	 * Sets scale of this selector. Scale defines how many digits after decimal point can be entered. By default
	 * this is set to 0, meaning that only integers are allowed. Setting scale to 1 would allow 0.0, scale = 2 would
	 * allow 0.00 and etc.
	 */
	public void setScale (final int scale) {
		setScale(scale, true);
	}
	private void setScale (final int scale, boolean notifySpinner) {
		if (scale < 0) throw new IllegalStateException("Scale can't be < 0");
		this.scale = scale;
		current = current.setScale(scale, BigDecimal.ROUND_HALF_UP);
		VisValidatableTextField valueText = spinner.getTextField();
		valueText.getValidators().clear();
		valueText.addValidator(boundsValidator); //Both need the bounds check
		if (scale == 0) {
			valueText.addValidator(Validators.INTEGERS);
			valueText.setTextFieldFilter(textFieldFilter = new IntDigitsOnlyFilter(true));
		} else {
			valueText.addValidator(Validators.FLOATS);
			valueText.addValidator(new InputValidator() {
				@Override
				public boolean validateInput (String input) {
					int dotIndex = input.indexOf('.');
					if (dotIndex == -1) return true;
					return input.length() - input.indexOf('.') - 1 <= scale;
				}
			});
			valueText.setTextFieldFilter(textFieldFilter = new FloatDigitsOnlyFilter(true));
		}
		textFieldFilter.setUseFieldCursorPosition(true);
		if (min.compareTo(BigDecimal.ZERO) >= 0) {
			textFieldFilter.setAcceptNegativeValues(false);
		} else {
			textFieldFilter.setAcceptNegativeValues(true);
		}
		if (notifySpinner) {
			spinner.notifyValueChanged(spinner.isProgrammaticChangeEvents());
		}
	}
	public void setValue (BigDecimal newValue) {
		setValue(newValue, spinner.isProgrammaticChangeEvents());
	}
	public void setValue (BigDecimal newValue, boolean fireEvent) {
		if (newValue.compareTo(max) > 0) {
			current = max.setScale(scale, BigDecimal.ROUND_HALF_UP);
		} else if (newValue.compareTo(min) < 0) {
			current = min.setScale(scale, BigDecimal.ROUND_HALF_UP);
		} else {
			current = newValue.setScale(scale, BigDecimal.ROUND_HALF_UP);
		}
		spinner.notifyValueChanged(fireEvent);
	}
	public BigDecimal getValue () {
		return current;
	}
	public BigDecimal getMin () {
		return min;
	}
	/** Sets min value. If current is lesser than min, the current value is set to min value */
	public void setMin (BigDecimal min) {
		if (min.compareTo(max) > 0) throw new IllegalArgumentException("min can't be > max");
		this.min = min;
		if (min.compareTo(BigDecimal.ZERO) >= 0) {
			textFieldFilter.setAcceptNegativeValues(false);
		} else {
			textFieldFilter.setAcceptNegativeValues(true);
		}
		if (current.compareTo(min) < 0) {
			current = min.setScale(scale, BigDecimal.ROUND_HALF_UP);
			spinner.notifyValueChanged(spinner.isProgrammaticChangeEvents());
		}
	}
	public BigDecimal getMax () {
		return max;
	}
	/** Sets max value. If current is greater than max, the current value is set to max value. */
	public void setMax (BigDecimal max) {
		if (min.compareTo(max) > 0) throw new IllegalArgumentException("min can't be > max");
		this.max = max;
		if (current.compareTo(max) > 0) {
			current = max.setScale(scale, BigDecimal.ROUND_HALF_UP);
			spinner.notifyValueChanged(spinner.isProgrammaticChangeEvents());
		}
	}
	public BigDecimal getStep () {
		return step;
	}
	public void setStep (BigDecimal step) {
		if (step.compareTo(BigDecimal.ZERO) <= 0) throw new IllegalArgumentException("step must be > 0");
		this.step = step;
	}
	private boolean checkInputBounds (String input) {
		try {
			BigDecimal x = new BigDecimal(input);
			return x.compareTo(min) >= 0 && x.compareTo(max) <= 0;
		} catch (NumberFormatException e) {
			return false;
		}
	}
	private class BoundsValidator implements InputValidator {
		@Override
		public boolean validateInput (String input) {
			return checkInputBounds(input);
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.utils.FocusListener;
import com.badlogic.gdx.utils.Array;
import com.kotcrab.vis.ui.util.InputValidator;
import com.kotcrab.vis.ui.util.Validators;
/**
 * Text field that input can be validated by custom input validators.
 * @author Kotcrab
 * @see InputValidator
 * @see Validators
 */
public class VisValidatableTextField extends VisTextField {
	private Array<InputValidator> validators = new Array<InputValidator>();
	private boolean validationEnabled = true;
	private LastValidFocusListener restoreFocusListener;
	private boolean restoreLastValid = false;
	private String lastValid;
	public VisValidatableTextField () {
		super();
		init();
	}
	public VisValidatableTextField (String text) {
		super(text);
		init();
	}
	public VisValidatableTextField (String text, String styleName) {
		super(text, styleName);
		init();
	}
	public VisValidatableTextField (String text, VisTextFieldStyle style) {
		super(text, style);
		init();
	}
	public VisValidatableTextField (InputValidator validator) {
		super();
		addValidator(validator);
		init();
	}
	public VisValidatableTextField (InputValidator... validators) {
		super();
		for (InputValidator validator : validators)
			addValidator(validator);
		init();
	}
	public VisValidatableTextField (boolean restoreLastValid, InputValidator validator) {
		super();
		addValidator(validator);
		init();
		setRestoreLastValid(restoreLastValid);
	}
	public VisValidatableTextField (boolean restoreLastValid, InputValidator... validators) {
		super();
		for (InputValidator validator : validators)
			addValidator(validator);
		init();
		setRestoreLastValid(restoreLastValid);
	}
	private void init () {
		setProgrammaticChangeEvents(true);
		setIgnoreEqualsTextChange(false);
	}
	@Override
	void beforeChangeEventFired () {
		validateInput();
	}
	@Override
	public void setText (String str) {
		super.setText(str);
		validateInput();
	}
	public void validateInput () {
		if (validationEnabled) {
			for (InputValidator validator : validators) {
				if (validator.validateInput(getText()) == false) {
					setInputValid(false);
					return;
				}
			}
		}
		// validation not enabled or validators does not returned false (input was valid)
		setInputValid(true);
	}
	public void addValidator (InputValidator validator) {
		validators.add(validator);
		validateInput();
	}
	public Array<InputValidator> getValidators () {
		return validators;
	}
	public boolean isValidationEnabled () {
		return validationEnabled;
	}
	/**
	 * Enables or disables validation, after changing this setting validateInput() is called, if validationEnabled == false then
	 * field is marked as valid otherwise standard validation is performed
	 * @param validationEnabled enable or disable validation
	 */
	public void setValidationEnabled (boolean validationEnabled) {
		this.validationEnabled = validationEnabled;
		validateInput();
	}
	public boolean isRestoreLastValid () {
		return restoreLastValid;
	}
	/**
	 * If true this field will automatically restore last valid text if it loses keyboard focus during text edition.
	 * This can't be called while field is selected, doing so will result in IllegalStateException. Default is false.
	 */
	public void setRestoreLastValid (boolean restoreLastValid) {
		if (hasSelection)
			throw new IllegalStateException("Last valid text restore can't be changed while filed has selection");
		this.restoreLastValid = restoreLastValid;
		if (restoreLastValid) {
			if (restoreFocusListener == null) restoreFocusListener = new LastValidFocusListener();
			addListener(restoreFocusListener);
		} else {
			removeListener(restoreFocusListener);
		}
	}
	public void restoreLastValidText () {
		if (restoreLastValid == false)
			throw new IllegalStateException("Restore last valid is not enabled, see #setRestoreLastValid(boolean)");
		//use super.setText to skip input validation and do not fire programmatic change event
		VisValidatableTextField.super.setText(lastValid);
		setInputValid(true);
	}
	private class LastValidFocusListener extends FocusListener {
		@Override
		public void keyboardFocusChanged (FocusEvent event, Actor actor, boolean focused) {
			if (focused && restoreLastValid) {
				lastValid = getText();
			}
			if (focused == false && isInputValid() == false && restoreLastValid) {
				restoreLastValidText();
			}
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.spinner;
import com.kotcrab.vis.ui.util.InputValidator;
import com.kotcrab.vis.ui.util.IntDigitsOnlyFilter;
import com.kotcrab.vis.ui.util.Validators;
import com.kotcrab.vis.ui.widget.VisValidatableTextField;
/**
 * Spinner models allowing to select int values.
 * @author Kotcrab
 * @see SimpleFloatSpinnerModel
 * @see FloatSpinnerModel
 * @since 1.0.2
 */
public class IntSpinnerModel extends AbstractSpinnerModel {
	private BoundsValidator boundsValidator = new BoundsValidator();
	private IntDigitsOnlyFilter textFieldFilter;
	private int max;
	private int min;
	private int step;
	private int current;
	public IntSpinnerModel (int initialValue, int min, int max) {
		this(initialValue, min, max, 1);
	}
	public IntSpinnerModel (int initialValue, int min, int max, int step) {
		super(false);
		if (min > max) throw new IllegalArgumentException("min can't be > max");
		if (step <= 0) throw new IllegalArgumentException("step must be > 0");
		this.current = initialValue;
		this.max = max;
		this.min = min;
		this.step = step;
	}
	@Override
	public void bind (Spinner spinner) {
		super.bind(spinner);
		VisValidatableTextField valueText = spinner.getTextField();
		valueText.getValidators().clear();
		valueText.addValidator(boundsValidator);
		valueText.addValidator(Validators.INTEGERS);
		valueText.setTextFieldFilter(textFieldFilter = new IntDigitsOnlyFilter(true));
		textFieldFilter.setUseFieldCursorPosition(true);
		if (min >= 0) {
			textFieldFilter.setAcceptNegativeValues(false);
		} else {
			textFieldFilter.setAcceptNegativeValues(true);
		}
		spinner.notifyValueChanged(true);
	}
	@Override
	public void textChanged () {
		String text = spinner.getTextField().getText();
		if (text.equals("")) {
			current = min;
		} else if (checkInputBounds(text)) {
			current = Integer.parseInt(text);
		}
	}
	@Override
	public boolean incrementModel () {
		if (current + step > max) {
			if (current == max) {
				if (isWrap()) {
					current = min;
					return true;
				}
				return false;
			}
			current = max;
		} else {
			current += step;
		}
		return true;
	}
	@Override
	public boolean decrementModel () {
		if (current - step < min) {
			if (current == min) {
				if (isWrap()) {
					current = max;
					return true;
				}
				return false;
			}
			current = min;
		} else {
			current -= step;
		}
		return true;
	}
	@Override
	public String getText () {
		return String.valueOf(current);
	}
	public void setValue (int newValue) {
		setValue(newValue, spinner.isProgrammaticChangeEvents());
	}
	public void setValue (int newValue, boolean fireEvent) {
		if (newValue > max) {
			current = max;
		} else if (newValue < min) {
			current = min;
		} else {
			current = newValue;
		}
		spinner.notifyValueChanged(fireEvent);
	}
	public int getValue () {
		return current;
	}
	public int getMin () {
		return min;
	}
	/** Sets min value. If current is lesser than min, the current value is set to min value. */
	public void setMin (int min) {
		if (min > max) throw new IllegalArgumentException("min can't be > max");
		this.min = min;
		if (min >= 0) {
			textFieldFilter.setAcceptNegativeValues(false);
		} else {
			textFieldFilter.setAcceptNegativeValues(true);
		}
		if (current < min) {
			current = min;
			spinner.notifyValueChanged(spinner.isProgrammaticChangeEvents());
		}
	}
	public int getMax () {
		return max;
	}
	/** Sets max value. If current is greater than max, the current value is set to max value. */
	public void setMax (int max) {
		if (min > max) throw new IllegalArgumentException("min can't be > max");
		this.max = max;
		if (current > max) {
			current = max;
			spinner.notifyValueChanged(spinner.isProgrammaticChangeEvents());
		}
	}
	public int getStep () {
		return step;
	}
	public void setStep (int step) {
		if (step <= 0) throw new IllegalArgumentException("step must be > 0");
		this.step = step;
	}
	private boolean checkInputBounds (String input) {
		try {
			float x = Integer.parseInt(input);
			return x >= min && x <= max;
		} catch (NumberFormatException e) {
			return false;
		}
	}
	private class BoundsValidator implements InputValidator {
		@Override
		public boolean validateInput (String input) {
			return checkInputBounds(input);
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.ui.Button;
import com.badlogic.gdx.scenes.scene2d.ui.Cell;
import com.badlogic.gdx.scenes.scene2d.ui.Image;
import com.badlogic.gdx.scenes.scene2d.ui.ImageButton;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.utils.Scaling;
import com.kotcrab.vis.ui.FocusManager;
import com.kotcrab.vis.ui.Focusable;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.util.BorderOwner;
/**
 * Due to scope of changes made this widget is not compatible with standard {@link ImageButton}.
 * <p>
 * When listening for button press {@link ChangeListener} should be always preferred (instead of {@link ClickListener}).
 * {@link ClickListener} does not support disabling button and will still report button presses.
 * @author Kotcrab
 * @see ImageButton
 */
public class VisImageButton extends Button implements Focusable, BorderOwner {
	private Image image;
	private VisImageButtonStyle style;
	private boolean drawBorder;
	private boolean focusBorderEnabled = true;
	private boolean generateDisabledImage = false;
	public VisImageButton (Drawable imageUp) {
		this(imageUp, null, null);
	}
	public VisImageButton (Drawable imageUp, String tooltipText) {
		this(imageUp, null, null);
		if (tooltipText != null) new Tooltip.Builder(tooltipText).target(this).build();
	}
	public VisImageButton (Drawable imageUp, Drawable imageDown) {
		this(imageUp, imageDown, null);
	}
	public VisImageButton (Drawable imageUp, Drawable imageDown, Drawable imageChecked) {
		this(imageUp, imageDown, imageChecked, "default");
	}
	public VisImageButton (Drawable imageUp, Drawable imageDown, Drawable imageChecked, String styleName) {
		super(new VisImageButtonStyle(VisUI.getSkin().get(styleName, VisImageButtonStyle.class)));
		style.imageUp = imageUp;
		style.imageDown = imageDown;
		style.imageChecked = imageChecked;
		init();
	}
	public VisImageButton (String styleName) {
		super(new VisImageButtonStyle(VisUI.getSkin().get(styleName, VisImageButtonStyle.class)));
		init();
	}
	public VisImageButton (VisImageButtonStyle style) {
		super(style);
		init();
	}
	private void init () {
		image = new Image();
		image.setScaling(Scaling.fit);
		add(image);
		setSize(getPrefWidth(), getPrefHeight());
		addListener(new InputListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				if (isDisabled() == false) FocusManager.switchFocus(getStage(), VisImageButton.this);
				return false;
			}
		});
		updateImage();
	}
	@Override
	public VisImageButtonStyle getStyle () {
		return style;
	}
	@Override
	public void setStyle (ButtonStyle style) {
		if (!(style instanceof VisImageButtonStyle))
			throw new IllegalArgumentException("style must be an ImageButtonStyle.");
		super.setStyle(style);
		this.style = (VisImageButtonStyle) style;
		if (image != null) updateImage();
	}
	private void updateImage () {
		Drawable drawable = null;
		if (isDisabled() && style.imageDisabled != null)
			drawable = style.imageDisabled;
		else if (isPressed() && style.imageDown != null)
			drawable = style.imageDown;
		else if (isChecked() && style.imageChecked != null)
			drawable = (style.imageCheckedOver != null && isOver()) ? style.imageCheckedOver : style.imageChecked;
		else if (isOver() && style.imageOver != null)
			drawable = style.imageOver;
		else if (style.imageUp != null)
			drawable = style.imageUp;
		image.setDrawable(drawable);
		if (generateDisabledImage && style.imageDisabled == null) {
			if (isDisabled()) {
				image.setColor(Color.GRAY);
			} else {
				image.setColor(Color.WHITE);
			}
		}
	}
	@Override
	public void draw (Batch batch, float parentAlpha) {
		updateImage();
		super.draw(batch, parentAlpha);
		if (focusBorderEnabled && drawBorder && style.focusBorder != null)
			style.focusBorder.draw(batch, getX(), getY(), getWidth(), getHeight());
	}
	public Image getImage () {
		return image;
	}
	public Cell<?> getImageCell () {
		return getCell(image);
	}
	@Override
	public void setDisabled (boolean disabled) {
		super.setDisabled(disabled);
		if (disabled) FocusManager.resetFocus(getStage(), this);
	}
	@Override
	public void focusLost () {
		drawBorder = false;
	}
	@Override
	public void focusGained () {
		drawBorder = true;
	}
	@Override
	public boolean isFocusBorderEnabled () {
		return focusBorderEnabled;
	}
	@Override
	public void setFocusBorderEnabled (boolean focusBorderEnabled) {
		this.focusBorderEnabled = focusBorderEnabled;
	}
	public boolean isGenerateDisabledImage () {
		return generateDisabledImage;
	}
	/**
	 * @param generate when set to true and button state is set to disabled then button image will be tinted with gray
	 * color to better symbolize that button is disabled. This works best for white images.
	 */
	public void setGenerateDisabledImage (boolean generate) {
		generateDisabledImage = generate;
	}
	/**
	 * The style for an image button, see {@link ImageButton}.
	 * @author Nathan Sweet
	 */
	static public class VisImageButtonStyle extends ButtonStyle {
		/** Optional. */
		public Drawable imageUp, imageDown, imageOver, imageChecked, imageCheckedOver, imageDisabled;
		public Drawable focusBorder;
		public VisImageButtonStyle () {
		}
		public VisImageButtonStyle (Drawable up, Drawable down, Drawable checked, Drawable imageUp, Drawable imageDown,
									Drawable imageChecked) {
			super(up, down, checked);
			this.imageUp = imageUp;
			this.imageDown = imageDown;
			this.imageChecked = imageChecked;
		}
		public VisImageButtonStyle (VisImageButtonStyle style) {
			super(style);
			this.imageUp = style.imageUp;
			this.imageDown = style.imageDown;
			this.imageOver = style.imageOver;
			this.imageChecked = style.imageChecked;
			this.imageCheckedOver = style.imageCheckedOver;
			this.imageDisabled = style.imageDisabled;
			this.focusBorder = style.focusBorder;
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Version;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.GdxRuntimeException;
/**
 * Allows to easily load VisUI skin and change default title alignment and I18N bundles.
 * Contains static field with VisUI version.
 * @author Kotcrab
 */
public class VisUI {
	private static final String TARGET_GDX_VERSION = "1.13.1";
	private static boolean skipGdxVersionCheck = false;
	private static int defaultTitleAlign = Align.left;
	private static SkinScale scale;
	private static Skin skin;
	/** Defines possible built-in skin scales. */
	public enum SkinScale {
		/** Standard VisUI skin */
		X1("com/kotcrab/vis/ui/skin/x1/uiskin.json", "default"),
		/** VisUI skin 2x upscaled */
		X2("com/kotcrab/vis/ui/skin/x2/uiskin.json", "x2");
		private final String classpath;
		private final String sizesName;
		SkinScale (String classpath, String sizesName) {
			this.classpath = classpath;
			this.sizesName = sizesName;
		}
		public FileHandle getSkinFile () {
			return Gdx.files.classpath(classpath);
		}
		public String getSizesName () {
			return sizesName;
		}
	}
	/** Loads default VisUI skin with {@link SkinScale#X1}. */
	public static void load () {
		load(SkinScale.X1);
	}
	/** Loads default VisUI skin for given {@link SkinScale}. */
	public static void load (SkinScale scale) {
		VisUI.scale = scale;
		load(scale.getSkinFile());
	}
	/** Loads skin from provided internal file path. Skin must be compatible with default VisUI skin. */
	public static void load (String internalVisSkinPath) {
		load(Gdx.files.internal(internalVisSkinPath));
	}
	/** Loads skin from provided file. Skin must be compatible with default VisUI skin. */
	public static void load (FileHandle visSkinFile) {
		checkBeforeLoad();
		VisUI.skin = new Skin(visSkinFile);
	}
	/**
	 * Sets provided skin as default for every VisUI widget. Skin must be compatible with default VisUI skin. This
	 * can be used if you prefer to load skin manually for example by using {@link AssetManager}.
	 */
	public static void load (Skin skin) {
		checkBeforeLoad();
		VisUI.skin = skin;
	}
	private static void checkBeforeLoad () {
		if (skin != null) throw new GdxRuntimeException("VisUI cannot be loaded twice");
		if (!skipGdxVersionCheck && !Version.VERSION.equals(TARGET_GDX_VERSION)) {
			Gdx.app.log("VisUI", "Warning, using invalid libGDX version.\n" +
					"You are using libGDX " + Version.VERSION + " but you need " + TARGET_GDX_VERSION + ". This may cause " +
					"unexpected problems and runtime exceptions.");
		}
	}
	/** Unloads VisUI. */
	public static void dispose () {
		dispose(true);
	}
	/**
	 * Unloads VisUI.
	 * @param disposeSkin if true then internal skin instance will be disposed
	 */
	public static void dispose (boolean disposeSkin) {
		if (skin != null) {
			if (disposeSkin) skin.dispose();
			skin = null;
		}
	}
	public static Skin getSkin () {
		if (skin == null) throw new IllegalStateException("VisUI is not loaded!");
		return skin;
	}
	public static boolean isLoaded () {
		return skin != null;
	}
	public static Sizes getSizes () {
		if (scale == null)
			return getSkin().get(Sizes.class);
		else
			return getSkin().get(scale.getSizesName(), Sizes.class);
	}
	/** @return int value from {@link Align} */
	public static int getDefaultTitleAlign () {
		return defaultTitleAlign;
	}
	/**
	 * Sets default title align user for VisWindow and VisDialog
	 * @param defaultTitleAlign int value from {@link Align}
	 */
	public static void setDefaultTitleAlign (int defaultTitleAlign) {
		VisUI.defaultTitleAlign = defaultTitleAlign;
	}
	/**
	 * @param setSkipGdxVersionCheck if true VisUI won't check if provided libGDX version is compatible for current version of VisUI.
	 * If false, before loading VisUI, a libGDX version check will be performed, in case of version mismatch warning
	 * will be printed to console
	 * @see <a href="https://github.com/kotcrab/vis-ui#libgdx-compatibility">Version compatiblity table (online)</a>
	 */
	public static void setSkipGdxVersionCheck (boolean setSkipGdxVersionCheck) {
		VisUI.skipGdxVersionCheck = setSkipGdxVersionCheck;
	}
}/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Cursor.SystemCursor;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.BitmapFont.BitmapFontData;
import com.badlogic.gdx.graphics.g2d.GlyphLayout;
import com.badlogic.gdx.graphics.g2d.GlyphLayout.GlyphRun;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.TextField;
import com.badlogic.gdx.scenes.scene2d.ui.TextField.DefaultOnscreenKeyboard;
import com.badlogic.gdx.scenes.scene2d.ui.TextField.OnscreenKeyboard;
import com.badlogic.gdx.scenes.scene2d.ui.TextField.TextFieldStyle;
import com.badlogic.gdx.scenes.scene2d.ui.Widget;
import com.badlogic.gdx.scenes.scene2d.ui.Window;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener.ChangeEvent;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.Disableable;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.UIUtils;
import com.badlogic.gdx.utils.*;
import com.badlogic.gdx.utils.Timer.Task;
import com.kotcrab.vis.ui.FocusManager;
import com.kotcrab.vis.ui.Focusable;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.util.BorderOwner;
import com.kotcrab.vis.ui.util.CursorManager;
import java.lang.StringBuilder;
/**
 * Extends functionality of standard {@link TextField}. Style supports over, and focus border. Improved text input.
 * Due to scope of changes made this widget is not compatible with {@link TextField}.
 * @author mzechner
 * @author Nathan Sweet
 * @author Kotcrab
 * @see TextField
 */
public class VisTextField extends Widget implements Disableable, Focusable, BorderOwner {
	static private final char BACKSPACE = 8;
	static protected final char ENTER_DESKTOP = '\r';
	static protected final char ENTER_ANDROID = '\n';
	static private final char TAB = '\t';
	static private final char DELETE = 127;
	static private final char BULLET = 8226;
	static private final Vector2 tmp1 = new Vector2();
	static private final Vector2 tmp2 = new Vector2();
	static private final Vector2 tmp3 = new Vector2();
	static public float keyRepeatInitialTime = 0.4f;
	/** Repeat times for keys handled by {@link InputListener#keyDown(InputEvent, int)} such as navigation arrows */
	static public float keyRepeatTime = 0.04f;
	protected String text;
	protected int cursor, selectionStart;
	protected boolean hasSelection;
	protected boolean writeEnters;
	protected final GlyphLayout layout = new GlyphLayout();
	protected final FloatArray glyphPositions = new FloatArray();
	private String messageText;
	protected CharSequence displayText;
	Clipboard clipboard;
	InputListener inputListener;
	TextFieldListener listener;
	TextFieldFilter filter;
	OnscreenKeyboard keyboard = new DefaultOnscreenKeyboard();
	boolean focusTraversal = true, onlyFontChars = true, disabled;
	boolean enterKeyFocusTraversal = false;
	private int textHAlign = Align.left;
	private float selectionX, selectionWidth;
	String undoText = "";
	int undoCursorPos = 0;
	long lastChangeTime;
	boolean passwordMode;
	private StringBuilder passwordBuffer;
	private char passwordCharacter = BULLET;
	protected float fontOffset, textHeight, textOffset;
	float renderOffset;
	private int visibleTextStart, visibleTextEnd;
	private int maxLength = 0;
	private float blinkTime = 0.45f;
	boolean cursorOn = true;
	long lastBlink;
	KeyRepeatTask keyRepeatTask = new KeyRepeatTask();
	boolean programmaticChangeEvents;
	// vis fields
	VisTextFieldStyle style;
	private ClickListener clickListener;
	private boolean drawBorder;
	private boolean focusBorderEnabled = true;
	private boolean inputValid = true;
	private boolean ignoreEqualsTextChange = true;
	private boolean readOnly = false;
	private float cursorPercentHeight = 0.8f;
	public VisTextField () {
		this("", VisUI.getSkin().get(VisTextFieldStyle.class));
	}
	public VisTextField (String text) {
		this(text, VisUI.getSkin().get(VisTextFieldStyle.class));
	}
	public VisTextField (String text, String styleName) {
		this(text, VisUI.getSkin().get(styleName, VisTextFieldStyle.class));
	}
	public VisTextField (String text, VisTextFieldStyle style) {
		setStyle(style);
		clipboard = Gdx.app.getClipboard();
		initialize();
		setText(text);
		setSize(getPrefWidth(), getPrefHeight());
	}
	protected void initialize () {
		addListener(inputListener = createInputListener());
		addListener(clickListener = new ClickListener() {
			@Override
			public void enter (InputEvent event, float x, float y, int pointer, Actor fromActor) {
				super.enter(event, x, y, pointer, fromActor);
				if (pointer == -1 && isDisabled() == false) {
					Gdx.graphics.setSystemCursor(SystemCursor.Ibeam);
				}
			}
			@Override
			public void exit (InputEvent event, float x, float y, int pointer, Actor toActor) {
				super.exit(event, x, y, pointer, toActor);
				if (pointer == -1) {
					CursorManager.restoreDefaultCursor();
				}
			}
		});
	}
	protected InputListener createInputListener () {
		return new TextFieldClickListener();
	}
	protected int letterUnderCursor (float x) {
		x -= textOffset + fontOffset - style.font.getData().cursorX - glyphPositions.get(visibleTextStart);
		int n = this.glyphPositions.size;
		float[] glyphPositions = this.glyphPositions.items;
		for (int i = 1; i < n; i++) {
			if (glyphPositions[i] > x) {
				if (glyphPositions[i] - x <= x - glyphPositions[i - 1]) return i;
				return i - 1;
			}
		}
		return n - 1;
	}
	protected boolean isWordCharacter (char c) {
		return Character.isLetterOrDigit(c);
	}
	protected int[] wordUnderCursor (int at) {
		String text = this.text;
		int start = Math.min(text.length(), at), right = text.length(), left = 0, index = start;
		for (; index < right; index++) {
			if (!isWordCharacter(text.charAt(index))) {
				right = index;
				break;
			}
		}
		for (index = start - 1; index > -1; index--) {
			if (!isWordCharacter(text.charAt(index))) {
				left = index + 1;
				break;
			}
		}
		return new int[]{left, right};
	}
	int[] wordUnderCursor (float x) {
		return wordUnderCursor(letterUnderCursor(x));
	}
	boolean withinMaxLength (int size) {
		return maxLength <= 0 || size < maxLength;
	}
	public int getMaxLength () {
		return this.maxLength;
	}
	public void setMaxLength (int maxLength) {
		this.maxLength = maxLength;
	}
	/**
	 * When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.
	 * When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
	 * when typed or pasted.
	 */
	public void setOnlyFontChars (boolean onlyFontChars) {
		this.onlyFontChars = onlyFontChars;
	}
	/**
	 * Returns the text field's style. Modifying the returned style may not have an effect until
	 * {@link #setStyle(VisTextFieldStyle)} is called.
	 */
	public VisTextFieldStyle getStyle () {
		return style;
	}
	public void setStyle (VisTextFieldStyle style) {
		if (style == null) throw new IllegalArgumentException("style cannot be null.");
		this.style = style;
		textHeight = style.font.getCapHeight() - style.font.getDescent() * 2;
		invalidateHierarchy();
	}
	@Override
	public String toString () {
		return getText();
	}
	protected void calculateOffsets () {
		float visibleWidth = getWidth();
		if (style.background != null)
			visibleWidth -= style.background.getLeftWidth() + style.background.getRightWidth();
		int glyphCount = glyphPositions.size;
		float[] glyphPositions = this.glyphPositions.items;
		// Check if the cursor has gone out the left or right side of the visible area and adjust renderOffset.
		float distance = glyphPositions[Math.max(0, cursor - 1)] + renderOffset;
		if (distance <= 0)
			renderOffset -= distance;
		else {
			int index = Math.min(glyphCount - 1, cursor + 1);
			float minX = glyphPositions[index] - visibleWidth;
			if (-renderOffset < minX) renderOffset = -minX;
		}
		// Prevent renderOffset from starting too close to the end, eg after text was deleted.
		float maxOffset = 0;
		float width = glyphPositions[glyphCount - 1];
		for (int i = glyphCount - 2; i >= 0; i--) {
			float x = glyphPositions[i];
			if (width - x > visibleWidth) break;
			maxOffset = x;
		}
		if (-renderOffset > maxOffset) renderOffset = -maxOffset;
		// calculate first visible char based on render offset
		visibleTextStart = 0;
		float startX = 0;
		for (int i = 0; i < glyphCount; i++) {
			if (glyphPositions[i] >= -renderOffset) {
				visibleTextStart = Math.max(0, i);
				startX = glyphPositions[i];
				break;
			}
		}
		// calculate last visible char based on visible width and render offset
		int length = Math.min(displayText.length(), glyphPositions.length - 1);
		visibleTextEnd = Math.min(length, cursor + 1);
		for (; visibleTextEnd <= length; visibleTextEnd++)
			if (glyphPositions[visibleTextEnd] > startX + visibleWidth) break;
		visibleTextEnd = Math.max(0, visibleTextEnd - 1);
		if ((textHAlign & Align.left) == 0) {
			textOffset = visibleWidth - (glyphPositions[visibleTextEnd] - startX);
			if ((textHAlign & Align.center) != 0) textOffset = Math.round(textOffset * 0.5f);
		} else
			textOffset = startX + renderOffset;
		// calculate selection x position and width
		if (hasSelection) {
			int minIndex = Math.min(cursor, selectionStart);
			int maxIndex = Math.max(cursor, selectionStart);
			float minX = Math.max(glyphPositions[minIndex] - glyphPositions[visibleTextStart], -textOffset);
			float maxX = Math.min(glyphPositions[maxIndex] - glyphPositions[visibleTextStart], visibleWidth - textOffset);
			selectionX = minX;
			selectionWidth = maxX - minX - style.font.getData().cursorX;
		}
	}
	@Override
	public void draw (Batch batch, float parentAlpha) {
		Stage stage = getStage();
		boolean focused = stage != null && stage.getKeyboardFocus() == this;
		if (!focused) keyRepeatTask.cancel();
		final BitmapFont font = style.font;
		final Color fontColor = (disabled && style.disabledFontColor != null) ? style.disabledFontColor
				: ((focused && style.focusedFontColor != null) ? style.focusedFontColor : style.fontColor);
		final Drawable selection = style.selection;
		final Drawable cursorPatch = style.cursor;
		Drawable background = (disabled && style.disabledBackground != null) ? style.disabledBackground
				: ((focused && style.focusedBackground != null) ? style.focusedBackground : style.background);
		// vis
		if (!disabled && style.backgroundOver != null && (clickListener.isOver() || focused)) {
			background = style.backgroundOver;
		}
		Color color = getColor();
		float x = getX();
		float y = getY();
		float width = getWidth();
		float height = getHeight();
		batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);
		float bgLeftWidth = 0, bgRightWidth = 0;
		if (background != null) {
			background.draw(batch, x, y, width, height);
			bgLeftWidth = background.getLeftWidth();
			bgRightWidth = background.getRightWidth();
		}
		float textY = getTextY(font, background);
		calculateOffsets();
		if (focused && hasSelection && selection != null) {
			drawSelection(selection, batch, font, x + bgLeftWidth, y + textY);
		}
		float yOffset = font.isFlipped() ? -textHeight : 0;
		if (displayText.length() == 0) {
			if (!focused && messageText != null) {
				if (style.messageFontColor != null) {
					font.setColor(style.messageFontColor.r, style.messageFontColor.g, style.messageFontColor.b,
							style.messageFontColor.a * color.a * parentAlpha);
				} else
					font.setColor(0.7f, 0.7f, 0.7f, color.a * parentAlpha);
				BitmapFont messageFont = style.messageFont != null ? style.messageFont : font;
				messageFont.draw(batch, messageText, x + bgLeftWidth, y + textY + yOffset, 0, messageText.length(),
						width - bgLeftWidth - bgRightWidth, textHAlign, false, "...");
			}
		} else {
			font.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * color.a * parentAlpha);
			drawText(batch, font, x + bgLeftWidth, y + textY + yOffset);
		}
		if (drawBorder && focused && !disabled) {
			blink();
			if (cursorOn && cursorPatch != null) {
				drawCursor(cursorPatch, batch, font, x + bgLeftWidth, y + textY);
			}
		}
		// vis
		if (isDisabled() == false && inputValid == false && style.errorBorder != null)
			style.errorBorder.draw(batch, getX(), getY(), getWidth(), getHeight());
		else if (focusBorderEnabled && drawBorder && style.focusBorder != null)
			style.focusBorder.draw(batch, getX(), getY(), getWidth(), getHeight());
	}
	protected float getTextY (BitmapFont font, Drawable background) {
		float height = getHeight();
		float textY = textHeight / 2 + font.getDescent();
		if (background != null) {
			float bottom = background.getBottomHeight();
			textY = textY + (height - background.getTopHeight() - bottom) / 2 + bottom;
		} else {
			textY = textY + height / 2;
		}
		if (font.usesIntegerPositions()) textY = (int) textY;
		return textY;
	}
	/** Draws selection rectangle **/
	protected void drawSelection (Drawable selection, Batch batch, BitmapFont font, float x, float y) {
		selection.draw(batch, x + selectionX + textOffset + fontOffset, y - textHeight - font.getDescent(), selectionWidth,
				textHeight);
	}
	protected void drawText (Batch batch, BitmapFont font, float x, float y) {
		font.draw(batch, displayText, x + textOffset, y, visibleTextStart, visibleTextEnd, 0, Align.left, false);
	}
	protected void drawCursor (Drawable cursorPatch, Batch batch, BitmapFont font, float x, float y) {
		float cursorHeight = textHeight * cursorPercentHeight;
		float cursorYPadding = (textHeight - cursorHeight) / 2;
		cursorPatch.draw(batch,
				x + textOffset + glyphPositions.get(cursor) - glyphPositions.get(visibleTextStart) + fontOffset + font.getData().cursorX,
				y - textHeight - font.getDescent() + cursorYPadding, cursorPatch.getMinWidth(), cursorHeight);
	}
	void updateDisplayText () {
		BitmapFont font = style.font;
		BitmapFontData data = font.getData();
		String text = this.text;
		int textLength = text.length();
		StringBuilder buffer = new StringBuilder();
		for (int i = 0; i < textLength; i++) {
			char c = text.charAt(i);
			buffer.append(data.hasGlyph(c) ? c : ' ');
		}
		String newDisplayText = buffer.toString();
		if (passwordMode && data.hasGlyph(passwordCharacter)) {
			if (passwordBuffer == null) passwordBuffer = new StringBuilder(newDisplayText.length());
			if (passwordBuffer.length() > textLength)
				passwordBuffer.setLength(textLength);
			else {
				for (int i = passwordBuffer.length(); i < textLength; i++)
					passwordBuffer.append(passwordCharacter);
			}
			displayText = passwordBuffer;
		} else
			displayText = newDisplayText;
		layout.setText(font, displayText.toString().replace('\r', ' ').replace('\n', ' '));
		glyphPositions.clear();
		float x = 0;
		if (layout.runs.size > 0) {
			GlyphRun run = layout.runs.first();
			fontOffset = run.xAdvances.first();
			for (GlyphRun glyphRun : layout.runs) {
				FloatArray xAdvances = glyphRun.xAdvances;
				for (int i = 1, n = xAdvances.size; i < n; i++) {
					glyphPositions.add(x);
					x += xAdvances.get(i);
				}
				glyphPositions.add(x);
			}
		} else {
			fontOffset = 0;
		}
		glyphPositions.add(x);
		visibleTextStart = Math.min(visibleTextStart, glyphPositions.size);
		visibleTextEnd = MathUtils.clamp(visibleTextEnd, visibleTextStart, glyphPositions.size);
		if (selectionStart > newDisplayText.length()) selectionStart = textLength;
	}
	private void blink () {
		if (!Gdx.graphics.isContinuousRendering()) {
			cursorOn = true;
			return;
		}
		long time = TimeUtils.nanoTime();
		if ((time - lastBlink) / 1000000000.0f > blinkTime) {
			cursorOn = !cursorOn;
			lastBlink = time;
		}
	}
	/** Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField. */
	public void copy () {
		if (hasSelection && !passwordMode) {
			int beginIndex = Math.min(cursor, selectionStart);
			int endIndex = Math.max(cursor, selectionStart);
			clipboard.setContents(text.substring(Math.max(0, beginIndex), Math.min(text.length(), endIndex)));
		}
	}
	/**
	 * Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes
	 * it.
	 */
	public void cut () {
		cut(programmaticChangeEvents);
	}
	void cut (boolean fireChangeEvent) {
		if (hasSelection && !passwordMode) {
			copy();
			cursor = delete(fireChangeEvent);
			updateDisplayText();
		}
	}
	void paste (String content, boolean fireChangeEvent) {
		if (content == null) return;
		StringBuilder buffer = new StringBuilder();
		int textLength = text.length();
		if (hasSelection) textLength -= Math.abs(cursor - selectionStart);
		BitmapFontData data = style.font.getData();
		for (int i = 0, n = content.length(); i < n; i++) {
			if (!withinMaxLength(textLength + buffer.length())) break;
			char c = content.charAt(i);
			if (!(writeEnters && (c == ENTER_ANDROID || c == ENTER_DESKTOP))) {
				if (c == '\r' || c == '\n') continue;
				if (onlyFontChars && !data.hasGlyph(c)) continue;
				if (filter != null && !filter.acceptChar(this, c)) continue;
			}
			buffer.append(c);
		}
		content = buffer.toString();
		if (hasSelection) cursor = delete(fireChangeEvent);
		if (fireChangeEvent)
			changeText(text, insert(cursor, content, text));
		else
			text = insert(cursor, content, text);
		updateDisplayText();
		cursor += content.length();
	}
	String insert (int position, CharSequence text, String to) {
		if (to.length() == 0) return text.toString();
		return to.substring(0, position) + text + to.substring(position, to.length());
	}
	int delete (boolean fireChangeEvent) {
		int from = selectionStart;
		int to = cursor;
		int minIndex = Math.min(from, to);
		int maxIndex = Math.max(from, to);
		String newText = (minIndex > 0 ? text.substring(0, minIndex) : "")
				+ (maxIndex < text.length() ? text.substring(maxIndex, text.length()) : "");
		if (fireChangeEvent)
			changeText(text, newText);
		else
			text = newText;
		clearSelection();
		return minIndex;
	}
	/**
	 * Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.
	 * @param up If true, the TextField with the same or next smallest y coordinate is found, else the next highest.
	 */
	public void next (boolean up) {
		Stage stage = getStage();
		if (stage == null) return;
		getParent().localToStageCoordinates(tmp1.set(getX(), getY()));
		VisTextField textField = findNextTextField(stage.getActors(), null, tmp2, tmp1, up);
		if (textField == null) { // Try to wrap around.
			if (up)
				tmp1.set(Float.MIN_VALUE, Float.MIN_VALUE);
			else
				tmp1.set(Float.MAX_VALUE, Float.MAX_VALUE);
			textField = findNextTextField(getStage().getActors(), null, tmp2, tmp1, up);
		}
		if (textField != null) {
			textField.focusField();
			textField.setCursorPosition(textField.getText().length());
		} else
			keyboard.show(false);
	}
	private VisTextField findNextTextField (Array<Actor> actors, VisTextField best, Vector2 bestCoords, Vector2 currentCoords, boolean up) {
		Window modalWindow = findModalWindow(this);
		for (int i = 0, n = actors.size; i < n; i++) {
			Actor actor = actors.get(i);
			if (actor == this) continue;
			if (actor instanceof VisTextField) {
				VisTextField textField = (VisTextField) actor;
				if (modalWindow != null) {
					Window nextFieldModalWindow = findModalWindow(textField);
					if (nextFieldModalWindow != modalWindow) continue;
				}
				if (textField.isDisabled() || !textField.focusTraversal || isActorVisibleInStage(textField) == false)
					continue;
				Vector2 actorCoords = actor.getParent().localToStageCoordinates(tmp3.set(actor.getX(), actor.getY()));
				if ((actorCoords.y < currentCoords.y || (actorCoords.y == currentCoords.y && actorCoords.x > currentCoords.x)) ^ up) {
					if (best == null
							|| (actorCoords.y > bestCoords.y || (actorCoords.y == bestCoords.y && actorCoords.x < bestCoords.x)) ^ up) {
						best = (VisTextField) actor;
						bestCoords.set(actorCoords);
					}
				}
			} else if (actor instanceof Group)
				best = findNextTextField(((Group) actor).getChildren(), best, bestCoords, currentCoords, up);
		}
		return best;
	}
	/**
	 * Checks if actor is visible in stage acknowledging parent visibility.
	 * If any parent returns false from isVisible then this method return false.
	 * True is returned when this actor and all its parent are visible.
	 */
	private boolean isActorVisibleInStage (Actor actor) {
		if (actor == null) return true;
		if (actor.isVisible() == false) return false;
		return isActorVisibleInStage(actor.getParent());
	}
	private Window findModalWindow (Actor actor) {
		if (actor == null) return null;
		if (actor instanceof Window && ((Window) actor).isModal()) return (Window) actor;
		return findModalWindow(actor.getParent());
	}
	public InputListener getDefaultInputListener () {
		return inputListener;
	}
	/** @param listener May be null. */
	public void setTextFieldListener (TextFieldListener listener) {
		this.listener = listener;
	}
	/** @param filter May be null. */
	public void setTextFieldFilter (TextFieldFilter filter) {
		this.filter = filter;
	}
	public TextFieldFilter getTextFieldFilter () {
		return filter;
	}
	/** If true (the default), tab/shift+tab will move to the next text field. */
	public void setFocusTraversal (boolean focusTraversal) {
		this.focusTraversal = focusTraversal;
	}
	/**
	 * If true, enter will move to the next text field with has focus traversal enabled.
	 * False by default. Note that to enable or disable focus traversal completely you must
	 * use {@link #setFocusTraversal(boolean)}
	 */
	public void setEnterKeyFocusTraversal (boolean enterKeyFocusTraversal) {
		this.enterKeyFocusTraversal = enterKeyFocusTraversal;
	}
	/** @return May be null. */
	public String getMessageText () {
		return messageText;
	}
	/**
	 * Sets the text that will be drawn in the text field if no text has been entered.
	 * @param messageText may be null.
	 */
	public void setMessageText (String messageText) {
		this.messageText = messageText;
	}
	/** @param str If null, "" is used. */
	public void appendText (String str) {
		if (str == null) str = "";
		clearSelection();
		cursor = text.length();
		paste(str, programmaticChangeEvents);
	}
	/** @param str If null, "" is used. */
	public void setText (String str) {
		if (str == null) str = "";
		if (ignoreEqualsTextChange && str.equals(text)) return;
		clearSelection();
		String oldText = text;
		text = "";
		paste(str, false);
		if (programmaticChangeEvents) changeText(oldText, text);
		cursor = 0;
	}
	/** @return Never null, might be an empty string. */
	public String getText () {
		return text;
	}
	/**
	 * @param oldText May be null.
	 * @return True if the text was changed.
	 */
	boolean changeText (String oldText, String newText) {
		if (ignoreEqualsTextChange && newText.equals(oldText)) return false;
		text = newText;
		beforeChangeEventFired();
		ChangeEvent changeEvent = Pools.obtain(ChangeEvent.class);
		boolean cancelled = fire(changeEvent);
		text = cancelled ? oldText : newText;
		Pools.free(changeEvent);
		return !cancelled;
	}
	void beforeChangeEventFired () {
	}
	public boolean getProgrammaticChangeEvents () {
		return programmaticChangeEvents;
	}
	/**
	 * If false, methods that change the text will not fire {@link ChangeEvent}, the event will be fired only when user changes
	 * the text.
	 */
	public void setProgrammaticChangeEvents (boolean programmaticChangeEvents) {
		this.programmaticChangeEvents = programmaticChangeEvents;
	}
	public int getSelectionStart () {
		return selectionStart;
	}
	public String getSelection () {
		return hasSelection ? text.substring(Math.min(selectionStart, cursor), Math.max(selectionStart, cursor)) : "";
	}
	public boolean isTextSelected () {
		return hasSelection;
	}
	/** Sets the selected text. */
	public void setSelection (int selectionStart, int selectionEnd) {
		if (selectionStart < 0) throw new IllegalArgumentException("selectionStart must be >= 0");
		if (selectionEnd < 0) throw new IllegalArgumentException("selectionEnd must be >= 0");
		selectionStart = Math.min(text.length(), selectionStart);
		selectionEnd = Math.min(text.length(), selectionEnd);
		if (selectionEnd == selectionStart) {
			clearSelection();
			return;
		}
		if (selectionEnd < selectionStart) {
			int temp = selectionEnd;
			selectionEnd = selectionStart;
			selectionStart = temp;
		}
		hasSelection = true;
		this.selectionStart = selectionStart;
		cursor = selectionEnd;
	}
	public void selectAll () {
		setSelection(0, text.length());
	}
	public void clearSelection () {
		hasSelection = false;
	}
	/** Clears VisTextField text. If programmatic change events are disabled then this will not fire change event. */
	public void clearText () {
		setText("");
	}
	/** Sets the cursor position and clears any selection. */
	public void setCursorPosition (int cursorPosition) {
		if (cursorPosition < 0) throw new IllegalArgumentException("cursorPosition must be >= 0");
		clearSelection();
		cursor = Math.min(cursorPosition, text.length());
	}
	public int getCursorPosition () {
		return cursor;
	}
	public void setCursorAtTextEnd () {
		setCursorPosition(0);
		calculateOffsets();
		setCursorPosition(getText().length());
	}
	/** @param cursorPercentHeight cursor size, value from 0..1 range */
	public void setCursorPercentHeight (float cursorPercentHeight) {
		if (cursorPercentHeight < 0 || cursorPercentHeight > 1)
			throw new IllegalArgumentException("cursorPercentHeight must be >= 0 and <= 1");
		this.cursorPercentHeight = cursorPercentHeight;
	}
	/** Default is an instance of {@link DefaultOnscreenKeyboard}. */
	public OnscreenKeyboard getOnscreenKeyboard () {
		return keyboard;
	}
	public void setOnscreenKeyboard (OnscreenKeyboard keyboard) {
		this.keyboard = keyboard;
	}
	public void setClipboard (Clipboard clipboard) {
		this.clipboard = clipboard;
	}
	@Override
	public float getPrefWidth () {
		return 150;
	}
	@Override
	public float getPrefHeight () {
		float prefHeight = textHeight;
		if (style.background != null) {
			prefHeight = Math.max(prefHeight + style.background.getBottomHeight() + style.background.getTopHeight(),
					style.background.getMinHeight());
		}
		return prefHeight;
	}
	/**
	 * Sets text horizontal alignment (left, center or right).
	 * @see Align
	 */
	public void setAlignment (int alignment) {
		this.textHAlign = alignment;
	}
	/**
	 * If true, the text in this text field will be shown as bullet characters.
	 * @see #setPasswordCharacter(char)
	 */
	public void setPasswordMode (boolean passwordMode) {
		this.passwordMode = passwordMode;
		updateDisplayText();
	}
	public boolean isPasswordMode () {
		return passwordMode;
	}
	/**
	 * Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149
	 * (bullet).
	 */
	public void setPasswordCharacter (char passwordCharacter) {
		this.passwordCharacter = passwordCharacter;
		if (passwordMode) updateDisplayText();
	}
	public void setBlinkTime (float blinkTime) {
		this.blinkTime = blinkTime;
	}
	public boolean isDisabled () {
		return disabled;
	}
	@Override
	public void setDisabled (boolean disabled) {
		this.disabled = disabled;
		if (disabled) {
			FocusManager.resetFocus(getStage(), this);
			keyRepeatTask.cancel();
		}
	}
	public boolean isReadOnly () {
		return readOnly;
	}
	public void setReadOnly (boolean readOnly) {
		this.readOnly = readOnly;
	}
	protected void moveCursor (boolean forward, boolean jump) {
		int limit = forward ? text.length() : 0;
		int charOffset = forward ? 0 : -1;
		while ((forward ? ++cursor < limit : --cursor > limit) && jump) {
			if (!continueCursor(cursor, charOffset)) break;
		}
	}
	protected boolean continueCursor (int index, int offset) {
		char c = text.charAt(index + offset);
		return isWordCharacter(c);
	}
	/** Focuses this field, field must be added to stage before this method can be called */
	public void focusField () {
		if (disabled) return;
		Stage stage = getStage();
		FocusManager.switchFocus(stage, VisTextField.this);
		setCursorPosition(0);
		selectionStart = 0;
		//make sure textOffset was updated, prevent issue when there was long text selected and it was changed to short text
		//and field was focused. Without it textOffset would stay at max value and only one last letter will be visible in field
		calculateOffsets();
		if (stage != null) stage.setKeyboardFocus(VisTextField.this);
		keyboard.show(true);
		hasSelection = true;
	}
	@Override
	public void focusLost () {
		drawBorder = false;
	}
	@Override
	public void focusGained () {
		drawBorder = true;
	}
	public boolean isEmpty () {
		return text.length() == 0;
	}
	public boolean isInputValid () {
		return inputValid;
	}
	public void setInputValid (boolean inputValid) {
		this.inputValid = inputValid;
	}
	@Override
	public boolean isFocusBorderEnabled () {
		return focusBorderEnabled;
	}
	@Override
	public void setFocusBorderEnabled (boolean focusBorderEnabled) {
		this.focusBorderEnabled = focusBorderEnabled;
	}
	/** @see #setIgnoreEqualsTextChange(boolean) */
	public boolean isIgnoreEqualsTextChange () {
		return ignoreEqualsTextChange;
	}
	/**
	 * Allows to control whether change event is sent when text field's text is changed to same same as was it before.
	 * Eg. current text field is 'abc' and {@link #setText(String)} is called it with 'abc' again.
	 * @param ignoreEqualsTextChange if true then setting text to the same as it was before will NOT fire change event.
	 * Default is true however it is false default {@link VisValidatableTextField} to prevent form refreshment issues -
	 * see issue VisEditor#165
	 */
	public void setIgnoreEqualsTextChange (boolean ignoreEqualsTextChange) {
		this.ignoreEqualsTextChange = ignoreEqualsTextChange;
	}
	static public class VisTextFieldStyle extends TextFieldStyle {
		public Drawable focusBorder;
		public Drawable errorBorder;
		public Drawable backgroundOver;
		public VisTextFieldStyle () {
		}
		public VisTextFieldStyle (BitmapFont font, Color fontColor, Drawable cursor, Drawable selection, Drawable background) {
			super(font, fontColor, cursor, selection, background);
		}
		public VisTextFieldStyle (VisTextFieldStyle style) {
			super(style);
			this.focusBorder = style.focusBorder;
			this.errorBorder = style.errorBorder;
			this.backgroundOver = style.backgroundOver;
		}
	}
	/**
	 * Interface for listening to typed characters.
	 * @author mzechner
	 */
	static public interface TextFieldListener {
		public void keyTyped (VisTextField textField, char c);
	}
	/**
	 * Interface for filtering characters entered into the text field.
	 * @author mzechner
	 */
	static public interface TextFieldFilter {
		public boolean acceptChar (VisTextField textField, char c);
		static public class DigitsOnlyFilter implements TextFieldFilter {
			@Override
			public boolean acceptChar (VisTextField textField, char c) {
				return Character.isDigit(c);
			}
		}
	}
	class KeyRepeatTask extends Task {
		int keycode;
		@Override
		public void run () {
			inputListener.keyDown(null, keycode);
		}
	}
	/** Basic input listener for the text field */
	public class TextFieldClickListener extends ClickListener {
		@Override
		public void clicked (InputEvent event, float x, float y) {
			int count = getTapCount() % 4;
			if (count == 0) clearSelection();
			if (count == 2) {
				int[] array = wordUnderCursor(x);
				setSelection(array[0], array[1]);
			}
			if (count == 3) selectAll();
		}
		@Override
		public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
			if (!super.touchDown(event, x, y, pointer, button)) return false;
			if (pointer == 0 && button != 0) return false;
			if (disabled) return true;
			Stage stage = getStage();
			FocusManager.switchFocus(stage, VisTextField.this);
			setCursorPosition(x, y);
			selectionStart = cursor;
			if (stage != null) stage.setKeyboardFocus(VisTextField.this);
			if (readOnly == false) keyboard.show(true);
			hasSelection = true;
			return true;
		}
		@Override
		public void touchDragged (InputEvent event, float x, float y, int pointer) {
			super.touchDragged(event, x, y, pointer);
			setCursorPosition(x, y);
		}
		@Override
		public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
			if (selectionStart == cursor) hasSelection = false;
			super.touchUp(event, x, y, pointer, button);
		}
		protected void setCursorPosition (float x, float y) {
			lastBlink = 0;
			cursorOn = false;
			cursor = Math.min(letterUnderCursor(x), text.length());
		}
		protected void goHome (boolean jump) {
			cursor = 0;
		}
		protected void goEnd (boolean jump) {
			cursor = text.length();
		}
		@Override
		public boolean keyDown (InputEvent event, int keycode) {
			if (disabled) return false;
			lastBlink = 0;
			cursorOn = false;
			Stage stage = getStage();
			if (stage == null || stage.getKeyboardFocus() != VisTextField.this) return false;
			if (drawBorder == false) return false;
			boolean repeat = false;
			boolean ctrl = UIUtils.ctrl();
			boolean jump = ctrl && !passwordMode;
			if (ctrl) {
				if (keycode == Keys.V && readOnly == false) {
					paste(clipboard.getContents(), true);
					repeat = true;
				}
				if (keycode == Keys.C || keycode == Keys.INSERT) {
					copy();
					return true;
				}
				if (keycode == Keys.X && readOnly == false) {
					cut(true);
					return true;
				}
				if (keycode == Keys.A) {
					selectAll();
					return true;
				}
				if (keycode == Keys.Z && readOnly == false) {
					String oldText = text;
					int oldCursorPos = getCursorPosition();
					setText(undoText);
					VisTextField.this.setCursorPosition(MathUtils.clamp(cursor, 0, undoText.length()));
					undoText = oldText;
					undoCursorPos = oldCursorPos;
					updateDisplayText();
					return true;
				}
			}
			if (UIUtils.shift()) {
				if (keycode == Keys.INSERT && readOnly == false) paste(clipboard.getContents(), true);
				if (keycode == Keys.FORWARD_DEL && readOnly == false) cut(true);
				selection:
				{
					int temp = cursor;
					keys:
					{
						if (keycode == Keys.LEFT) {
							moveCursor(false, jump);
							repeat = true;
							break keys;
						}
						if (keycode == Keys.RIGHT) {
							moveCursor(true, jump);
							repeat = true;
							break keys;
						}
						if (keycode == Keys.HOME) {
							goHome(jump);
							break keys;
						}
						if (keycode == Keys.END) {
							goEnd(jump);
							break keys;
						}
						break selection;
					}
					if (!hasSelection) {
						selectionStart = temp;
						hasSelection = true;
					}
				}
			} else {
				// Cursor movement or other keys (kills selection).
				if (keycode == Keys.LEFT) {
					moveCursor(false, jump);
					clearSelection();
					repeat = true;
				}
				if (keycode == Keys.RIGHT) {
					moveCursor(true, jump);
					clearSelection();
					repeat = true;
				}
				if (keycode == Keys.HOME) {
					goHome(jump);
					clearSelection();
				}
				if (keycode == Keys.END) {
					goEnd(jump);
					clearSelection();
				}
			}
			cursor = MathUtils.clamp(cursor, 0, text.length());
			if (repeat) {
				scheduleKeyRepeatTask(keycode);
			}
			return true;
		}
		protected void scheduleKeyRepeatTask (int keycode) {
			if (!keyRepeatTask.isScheduled() || keyRepeatTask.keycode != keycode) {
				keyRepeatTask.keycode = keycode;
				keyRepeatTask.cancel();
				if (Gdx.input.isKeyPressed(keyRepeatTask.keycode)) { //issue #179
					Timer.schedule(keyRepeatTask, keyRepeatInitialTime, keyRepeatTime);
				}
			}
		}
		@Override
		public boolean keyUp (InputEvent event, int keycode) {
			if (disabled) return false;
			keyRepeatTask.cancel();
			return true;
		}
		@Override
		public boolean keyTyped (InputEvent event, char character) {
			if (disabled || readOnly) return false;
			// Disallow "typing" most ASCII control characters, which would show up as a space when onlyFontChars is true.
			switch (character) {
				case BACKSPACE:
				case TAB:
				case ENTER_ANDROID:
				case ENTER_DESKTOP:
					break;
				default:
					if (character < 32) return false;
			}
			Stage stage = getStage();
			if (stage == null || stage.getKeyboardFocus() != VisTextField.this) return false;
			if (UIUtils.isMac && Gdx.input.isKeyPressed(Keys.SYM)) return true;
			if (focusTraversal && (character == TAB || (character == ENTER_ANDROID && enterKeyFocusTraversal))) {
				next(UIUtils.shift());
			} else {
				boolean delete = character == DELETE;
				boolean backspace = character == BACKSPACE;
				boolean enter = character == ENTER_DESKTOP || character == ENTER_ANDROID;
				boolean add = enter ? writeEnters : (!onlyFontChars || style.font.getData().hasGlyph(character));
				boolean remove = backspace || delete;
				if (add || remove) {
					String oldText = text;
					int oldCursor = cursor;
					if (hasSelection)
						cursor = delete(false);
					else {
						if (backspace && cursor > 0) {
							text = text.substring(0, cursor - 1) + text.substring(cursor--);
							renderOffset = 0;
						}
						if (delete && cursor < text.length()) {
							text = text.substring(0, cursor) + text.substring(cursor + 1);
						}
					}
					if (add && !remove) {
						// Character may be added to the text.
						if (!enter && filter != null && !filter.acceptChar(VisTextField.this, character)) return true;
						if (!withinMaxLength(text.length())) return true;
						String insertion = enter ? "\n" : String.valueOf(character);
						text = insert(cursor++, insertion, text);
					}
					if (changeText(oldText, text)) {
						long time = System.currentTimeMillis();
						if (time - 750 > lastChangeTime) {
							undoText = oldText;
							undoCursorPos = getCursorPosition() - 1;
						}
						lastChangeTime = time;
					} else
						cursor = oldCursor;
					updateDisplayText();
				}
			}
			if (listener != null) listener.keyTyped(VisTextField.this, character);
			return true;
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.kotcrab.vis.ui.VisUI;
/**
 * Compatible with {@link Label}. Does not provide additional features.
 * @author Kotcrab
 * @see Label
 */
public class VisLabel extends Label {
	public VisLabel () {
		super("", VisUI.getSkin());
	}
	public VisLabel (CharSequence text, Color textColor) {
		super(text, VisUI.getSkin());
		setColor(textColor);
	}
	public VisLabel (CharSequence text, int alignment) {
		this(text);
		setAlignment(alignment);
	}
	public VisLabel (CharSequence text) {
		super(text, VisUI.getSkin());
	}
	public VisLabel (CharSequence text, LabelStyle style) {
		super(text, style);
	}
	public VisLabel (CharSequence text, String styleName) {
		super(text, VisUI.getSkin(), styleName);
	}
	public VisLabel (CharSequence text, String fontName, Color color) {
		super(text, VisUI.getSkin(), fontName, color);
	}
	public VisLabel (CharSequence text, String fontName, String colorName) {
		super(text, VisUI.getSkin(), fontName, colorName);
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.spinner;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.utils.Array;
import com.kotcrab.vis.ui.util.InputValidator;
import com.kotcrab.vis.ui.widget.VisValidatableTextField;
/**
 * {@link Spinner} model allowing to browse through items from object {@link Array}.
 * <p>
 * Note that this (by default) uses item's toString() method to get string representation of objects used to validate
 * that user has entered valid value which due to {@link VisValidatableTextField} nature has to be done for every
 * entered letter. Item's toString() should cache it's result internally to optimize this check. To customize how string
 * representation is obtained override {@link #itemToString(Object)}.
 * @author Kotcrab
 * @since 1.0.2
 */
public class ArraySpinnerModel<T> extends AbstractSpinnerModel {
	private Array<T> items = new Array<T>();
	private T current;
	private int currentIndex;
	/**
	 * Creates empty instance with no items set. Note that spinner with empty array model will be always treated as in
	 * invalid state.
	 */
	public ArraySpinnerModel () {
		super(false);
	}
	/**
	 * Creates new instance of {@link ArraySpinnerModel} using provided items.
	 * @param items array containing items for the model. It is copied to new array in order to prevent accidental
	 * modification. Array may be empty however in such case spinner will be always in invalid input state.
	 */
	public ArraySpinnerModel (Array<T> items) {
		super(false);
		this.items.addAll(items);
	}
	@Override
	public void bind (Spinner spinner) {
		super.bind(spinner);
		updateCurrentItem(0);
		spinner.getTextField().addValidator(new InputValidator() {
			@Override
			public boolean validateInput (String input) {
				return getItemIndexForText(input) != -1;
			}
		});
		spinner.notifyValueChanged(true);
	}
	/**
	 * Creates string representation displayed in {@link Spinner} for given object. By default toString() is used.
	 * @param item that string representation should be created. It is necessary to check if item is null!
	 * @return string representation of item
	 */
	protected String itemToString (T item) {
		if (item == null) return "";
		return item.toString();
	}
	private int getItemIndexForText (String text) {
		for (int i = 0; i < items.size; i++) {
			T item = items.get(i);
			if (itemToString(item).equals(text)) return i;
		}
		return -1;
	}
	@Override
	public void textChanged () {
		String text = spinner.getTextField().getText();
		int index = getItemIndexForText(text);
		if (index == -1) return;
		updateCurrentItem(index);
	}
	@Override
	public boolean incrementModel () {
		if (currentIndex + 1 >= items.size) {
			if (isWrap()) {
				updateCurrentItem(0);
				return true;
			}
			return false;
		}
		updateCurrentItem(currentIndex + 1);
		return true;
	}
	@Override
	public boolean decrementModel () {
		if (currentIndex - 1 < 0) {
			if (isWrap()) {
				updateCurrentItem(items.size - 1);
				return true;
			}
			return false;
		}
		updateCurrentItem(currentIndex - 1);
		return true;
	}
	@Override
	public String getText () {
		return itemToString(current);
	}
	/** Notifies model that items has changed and view must be refreshed. This will trigger a change event. */
	public void invalidateDataSet () {
		updateCurrentItem(MathUtils.clamp(currentIndex, 0, items.size - 1));
		spinner.notifyValueChanged(true);
	}
	/** @return array containing model items. If you modify returned array you must call {@link #invalidateDataSet()}. */
	public Array<T> getItems () {
		return items;
	}
	/** Changes items of this model. Current index is not preserved. This will trigger a change event. */
	public void setItems (Array<T> newItems) {
		items.clear();
		items.addAll(newItems);
		currentIndex = 0;
		invalidateDataSet();
	}
	/** @return current item index or -1 if items array is empty */
	public int getCurrentIndex () {
		return currentIndex;
	}
	/** @return current item or null if items array is empty */
	public T getCurrent () {
		return current;
	}
	/** Sets current item. If array is empty then current value will be set to null. */
	public void setCurrent (int newIndex) {
		setCurrent(newIndex, spinner.isProgrammaticChangeEvents());
	}
	/** Sets current item. If array is empty then current value will be set to null. */
	public void setCurrent (int newIndex, boolean fireEvent) {
		updateCurrentItem(newIndex);
		spinner.notifyValueChanged(fireEvent);
	}
	/** @param item if does not exist in items array, model item will be set to first item. */
	public void setCurrent (T item) {
		setCurrent(item, spinner.isProgrammaticChangeEvents());
	}
	/** @param item if does not exist in items array, model item will be set to first item. */
	public void setCurrent (T item, boolean fireEvent) {
		int index = items.indexOf(item, true);
		if (index == -1) {
			setCurrent(0, fireEvent);
		} else {
			setCurrent(index, fireEvent);
		}
	}
	private void updateCurrentItem (int newIndex) {
		if (items.size == 0) {
			current = null;
			currentIndex = -1;
		} else {
			currentIndex = newIndex;
			current = items.get(newIndex);
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget;
import com.badlogic.gdx.scenes.scene2d.ui.Cell;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.util.TableUtils;
/**
 * Extends functionality of standard {@link Table}, supports setting default VisUI spacing and has utilities method for adding
 * separators. Compatible with {@link Table}.
 * @author Kotcrab
 * @see Table
 */
public class VisTable extends Table {
	public VisTable () {
		super(VisUI.getSkin());
	}
	/** @param setVisDefaults if true default vis spacing defaults will be set */
	public VisTable (boolean setVisDefaults) {
		super(VisUI.getSkin());
		if (setVisDefaults) TableUtils.setSpacingDefaults(this);
	}
	/**
	 * Adds vertical or horizontal {@link Separator} widget to table with padding top, bottom 2px with fill and expand properties.
	 * If vertical == false then inserts new row after separator (not before!)
	 */
	public Cell<Separator> addSeparator (boolean vertical) {
		Cell<Separator> cell = add(new Separator(vertical ? "vertical" : "default")).padTop(2).padBottom(2);
		if (vertical)
			cell.fillY().expandY();
		else {
			cell.fillX().expandX();
			row();
		}
		return cell;
	}
	/**
	 * Adds horizontal {@link Separator} widget to table with padding top, bottom 2px with fillX and expandX properties and inserts new row
	 * after separator (not before!)
	 */
	public Cell<Separator> addSeparator () {
		return addSeparator(false);
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.spinner;
import com.kotcrab.vis.ui.util.*;
import com.kotcrab.vis.ui.widget.VisValidatableTextField;
import java.math.BigDecimal;
/**
 * Spinner models allowing to select float values. Uses float to store values, good for small numbers
 * with low precession. If high precession is required or very big numbers are used then {@link FloatSpinnerModel} should be used.
 * If only ints are needed then {@link IntSpinnerModel} should be used.
 * @author Kotcrab
 * @see FloatSpinnerModel
 * @see IntSpinnerModel
 * @since 1.0.2
 */
public class SimpleFloatSpinnerModel extends AbstractSpinnerModel {
	private InputValidator boundsValidator = new BoundsValidator();
	private NumberDigitsTextFieldFilter textFieldFilter;
	private float max;
	private float min;
	private float step;
	private float current;
	private int precision = 0;
	public SimpleFloatSpinnerModel (float initialValue, float min, float max) {
		this(initialValue, min, max, 1, 1);
	}
	public SimpleFloatSpinnerModel (float initialValue, float min, float max, float step) {
		this(initialValue, min, max, step, 1);
	}
	public SimpleFloatSpinnerModel (float initialValue, float min, float max, float step, int precision) {
		super(false);
		if (min > max) throw new IllegalArgumentException("min can't be > max");
		if (step <= 0) throw new IllegalArgumentException("step must be > 0");
		if (precision < 0) throw new IllegalArgumentException("precision must be >= 0");
		this.current = initialValue;
		this.max = max;
		this.min = min;
		this.step = step;
		this.precision = precision;
	}
	@Override
	public void bind (Spinner spinner) {
		super.bind(spinner);
		setPrecision(precision, false);
		spinner.notifyValueChanged(true);
	}
	@Override
	public void textChanged () {
		String text = spinner.getTextField().getText();
		if (text.equals("")) {
			current = min;
		} else if (checkInputBounds(text)) {
			current = Float.parseFloat(text);
		}
	}
	@Override
	public boolean incrementModel () {
		if (current + step > max) {
			if (current == max) {
				if (isWrap()) {
					current = min;
					return true;
				}
				return false;
			}
			current = max;
		} else {
			current += step;
		}
		return true;
	}
	@Override
	public boolean decrementModel () {
		if (current - step < min) {
			if (current == min) {
				if (isWrap()) {
					current = max;
					return true;
				}
				return false;
			}
			current = min;
		} else {
			this.current -= step;
		}
		return true;
	}
	@Override
	public String getText () {
		if (precision >= 1) {
			//dealing with float rounding errors
			BigDecimal bd = new BigDecimal(String.valueOf(current));
			bd = bd.setScale(precision, BigDecimal.ROUND_HALF_UP);
			return String.valueOf(bd.floatValue());
		} else {
			return String.valueOf((int) current);
		}
	}
	public int getPrecision () {
		return precision;
	}
	/**
	 * Sets precision of this selector. Precision defines how many digits after decimal point can be entered. By default
	 * this is set to 0, meaning that only integers are allowed. Setting precision to 1 would allow 0.0, precision = 2 would
	 * allow 0.00 and etc.
	 */
	public void setPrecision (final int precision) {
		setPrecision(precision, true);
	}
	private void setPrecision (final int precision, boolean notifySpinner) {
		if (precision < 0) throw new IllegalStateException("Precision can't be < 0");
		this.precision = precision;
		VisValidatableTextField valueText = spinner.getTextField();
		valueText.getValidators().clear();
		valueText.addValidator(boundsValidator); //Both need the bounds check
		if (precision == 0) {
			valueText.addValidator(Validators.INTEGERS);
			valueText.setTextFieldFilter(textFieldFilter = new IntDigitsOnlyFilter(true));
		} else {
			valueText.addValidator(Validators.FLOATS);
			valueText.addValidator(new InputValidator() {
				@Override
				public boolean validateInput (String input) {
					int dotIndex = input.indexOf('.');
					if (dotIndex == -1) return true;
					return input.length() - input.indexOf('.') - 1 <= precision;
				}
			});
			valueText.setTextFieldFilter(textFieldFilter = new FloatDigitsOnlyFilter(true));
		}
		textFieldFilter.setUseFieldCursorPosition(true);
		if (min >= 0) {
			textFieldFilter.setAcceptNegativeValues(false);
		} else {
			textFieldFilter.setAcceptNegativeValues(true);
		}
		if (notifySpinner) {
			spinner.notifyValueChanged(spinner.isProgrammaticChangeEvents());
		}
	}
	public void setValue (float newValue) {
		setValue(newValue, spinner.isProgrammaticChangeEvents());
	}
	public void setValue (float newValue, boolean fireEvent) {
		if (newValue > max) {
			current = max;
		} else if (newValue < min) {
			current = min;
		} else {
			current = newValue;
		}
		spinner.notifyValueChanged(fireEvent);
	}
	public float getValue () {
		return current;
	}
	public float getMin () {
		return min;
	}
	/** Sets min value, if current is lesser than min, the current value is set to min value */
	public void setMin (float min) {
		if (min > max) throw new IllegalArgumentException("min can't be > max");
		this.min = min;
		if (min >= 0) {
			textFieldFilter.setAcceptNegativeValues(false);
		} else {
			textFieldFilter.setAcceptNegativeValues(true);
		}
		if (current < min) {
			current = min;
			spinner.notifyValueChanged(spinner.isProgrammaticChangeEvents());
		}
	}
	public float getMax () {
		return max;
	}
	/** Sets max value. If current is greater than max, the current value is set to max value. */
	public void setMax (float max) {
		if (min > max) throw new IllegalArgumentException("min can't be > max");
		this.max = max;
		if (current > max) {
			current = max;
			spinner.notifyValueChanged(spinner.isProgrammaticChangeEvents());
		}
	}
	public float getStep () {
		return step;
	}
	public void setStep (float step) {
		if (step <= 0) throw new IllegalArgumentException("step must be > 0");
		this.step = step;
	}
	private boolean checkInputBounds (String input) {
		try {
			float x = Float.parseFloat(input);
			return x >= min && x <= max;
		} catch (NumberFormatException e) {
			return false;
		}
	}
	private class BoundsValidator implements InputValidator {
		@Override
		public boolean validateInput (String input) {
			return checkInputBounds(input);
		}
	}
}