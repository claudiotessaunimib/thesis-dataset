/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.Application;
import android.content.ComponentCallbacks;
import android.content.Context;
import android.content.res.Configuration;
import android.os.Bundle;
import androidx.annotation.NonNull;
import androidx.lifecycle.Lifecycle;
import androidx.lifecycle.ProcessLifecycleOwner;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
/**
 * This class is the public API for the Countly Android SDK.
 * Get more details <a href="https://github.com/Countly/countly-sdk-android">here</a>.
 */
public class Countly {
    private final String DEFAULT_COUNTLY_SDK_VERSION_STRING = "24.7.8";
    /**
     * Used as request meta data on every request
     */
    private final String DEFAULT_COUNTLY_SDK_NAME = "java-native-android";
    /**
     * Current version of the Count.ly Android SDK as a displayable string.
     */
    public String COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;
    /**
     * Used as request meta data on every request
     */
    public String COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;
    /**
     * Default string used in the begin session metrics if the
     * app version cannot be found.
     */
    protected static final String DEFAULT_APP_VERSION = "1.0";
    /**
     * Tag used in all logging in the Count.ly SDK.
     */
    public static final String TAG = "Countly";
    /**
     * Countly internal logger
     * Should not be used outside of the SDK
     * No guarantees of not breaking functionality
     * Exposed only for the SDK push implementation
     */
    public ModuleLog L = new ModuleLog();
    /**
     * Broadcast sent when consent set is changed
     */
    public static final String CONSENT_BROADCAST = "ly.count.android.sdk.Countly.CONSENT_BROADCAST";
    /**
     * Determines how many custom events can be queued locally before
     * an attempt is made to submit them to a Count.ly server.
     */
    int EVENT_QUEUE_SIZE_THRESHOLD = 100;
    /**
     * How often onTimer() is called. This is the default value.
     */
    private static final long TIMER_DELAY_IN_SECONDS = 60;
    protected static String[] publicKeyPinCertificates;
    protected static String[] certificatePinCertificates;
    interface LifecycleObserver {
        boolean LifeCycleAtleastStarted();
    }
    /**
     * Enum used in Countly.initMessaging() method which controls what kind of
     * app installation it is. Later (in Countly Dashboard or when calling Countly API method),
     * you'll be able to choose whether you want to send a message to test devices,
     * or to production ones.
     */
    public enum CountlyMessagingMode {
        TEST,
        PRODUCTION,
    }
    /**
     * Enum used in Countly.initMessaging() method which controls what kind of
     * messaging provider is in use in current app installation.
     */
    public enum CountlyMessagingProvider {
        FCM,    // Firebase
        HMS,    // Huawei
    }
    //SDK limit defaults
    final int maxKeyLengthDefault = 128;
    final int maxValueSizeDefault = 256;
    final int maxSegmentationValuesDefault = 100;
    final int maxBreadcrumbCountDefault = 100;
    final int maxStackTraceLinesPerThreadDefault = 30;
    final int maxStackTraceLineLengthDefault = 200;
    final int maxStackTraceThreadCountDefault = 50;
    // see http://stackoverflow.com/questions/7048198/thread-safe-singletons-in-java
    private static class SingletonHolder {
        @SuppressLint("StaticFieldLeak")
        static final Countly instance = new Countly();
    }
    ConnectionQueue connectionQueue_;
    private ScheduledExecutorService timerService_;
    private ScheduledFuture<?> timerFuture = null;
    private int activityCount_;
    boolean disableUpdateSessionRequests_ = false;//todo, move to module after 'setDisableUpdateSessionRequests' is removed
    boolean sdkIsInitialised = false;
    BaseInfoProvider baseInfoProvider;
    RequestQueueProvider requestQueueProvider;
    //w - warnings
    //e - errors
    //i - user accessible calls and important SDK internals
    //d - regular SDK internals
    //v - spammy SDK internals
    private boolean enableLogging_;
    Context context_;
    //Internal modules for functionality grouping
    List<ModuleBase> modules = new ArrayList<>();
    ModuleCrash moduleCrash = null;
    ModuleEvents moduleEvents = null;
    ModuleViews moduleViews = null;
    ModuleRatings moduleRatings = null;
    ModuleSessions moduleSessions = null;
    ModuleRemoteConfig moduleRemoteConfig = null;
    ModuleAPM moduleAPM = null;
    ModuleConsent moduleConsent = null;
    ModuleDeviceId moduleDeviceId = null;
    ModuleLocation moduleLocation = null;
    ModuleFeedback moduleFeedback = null;
    ModuleRequestQueue moduleRequestQueue = null;
    ModuleAttribution moduleAttribution = null;
    ModuleUserProfile moduleUserProfile = null;
    ModuleConfiguration moduleConfiguration = null;
    ModuleHealthCheck moduleHealthCheck = null;
    ModuleContent moduleContent = null;
    //reference to countly store
    CountlyStore countlyStore;
    //overrides
    boolean isHttpPostForced = false;//when true, all data sent to the server will be sent using HTTP POST
    //push related
    private boolean addMetadataToPushIntents = false;// a flag that indicates if metadata should be added to push notification intents
    //internal flags
    private boolean calledAtLeastOnceOnStart = false;//flag for if the onStart function has been called at least once
    protected boolean isBeginSessionSent = false;
    //custom request header fields
    Map<String, String> requestHeaderCustomValues;
    static long applicationStart = System.currentTimeMillis();
    String[] locationFallback;//temporary used until location can't be set before init
    protected CountlyConfig config_ = null;
    //fields for tracking push token debounce
    final static long lastRegistrationCallDebounceDuration = 60 * 1000;//60seconds
    long lastRegistrationCallTs = 0;
    String lastRegistrationCallID = null;
    CountlyMessagingProvider lastRegistrationCallProvider = null;
    boolean applicationClassProvided = false;
    public static class CountlyFeatureNames {
        public static final String sessions = "sessions";
        public static final String events = "events";
        public static final String views = "views";
        public static final String scrolls = "scrolls";
        public static final String clicks = "clicks";
        //public static final String forms = "forms";
        public static final String location = "location";
        public static final String crashes = "crashes";
        public static final String attribution = "attribution";
        public static final String users = "users";
        public static final String push = "push";
        public static final String starRating = "star-rating";
        public static final String apm = "apm";
        public static final String feedback = "feedback";
        public static final String remoteConfig = "remote-config";
        public static final String content = "content";
        //public static final String accessoryDevices = "accessory-devices";
    }
    /**
     * Returns the Countly singleton.
     */
    public static Countly sharedInstance() {
        return SingletonHolder.instance;
    }
    /**
     * Constructs a Countly object.
     * Creates a new ConnectionQueue and initializes the session timer.
     */
    Countly() {
        connectionQueue_ = new ConnectionQueue();
        timerService_ = Executors.newSingleThreadScheduledExecutor();
    }
    private void startTimerService(ScheduledExecutorService service, ScheduledFuture<?> previousTimer, long timerDelay) {
        if (previousTimer != null && !previousTimer.isCancelled()) {
            previousTimer.cancel(false);
        }
        //minimum delay of 1 second
        if (timerDelay < 1) {
            timerDelay = 1;
        }
        timerFuture = service.scheduleWithFixedDelay(this::onTimer, timerDelay, timerDelay, TimeUnit.SECONDS);
    }
    /**
     * Must be called before other SDK methods can be used.
     * To initialise the SDK, you must pass a CountlyConfig object that contains
     * all the necessary information for setting up the SDK
     * Please prefer to use this on Application's onCreate method
     *
     * @param config contains all needed information to init SDK
     */
    public synchronized Countly init(CountlyConfig config) {
        if (config == null) {
            throw new IllegalArgumentException("Can't init SDK with 'null' config");
        }
        //enable logging
        if (config.loggingEnabled) {
            //enable logging before any potential logging calls
            setLoggingEnabled(true);
        }
        L.SetListener(config.providedLogCallback);
        if (COUNTLY_SDK_NAME.equals(DEFAULT_COUNTLY_SDK_NAME) && COUNTLY_SDK_VERSION_STRING.equals(DEFAULT_COUNTLY_SDK_VERSION_STRING)) {
            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "]");
        } else {
            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "] default name[" + DEFAULT_COUNTLY_SDK_NAME + "] default version[" + DEFAULT_COUNTLY_SDK_VERSION_STRING + "]");
        }
        if (config.context == null) {
            if (config.application != null) {
                L.d("[Init] No explicit context provided. Using context from the provided application class");
                config.context = config.application;
            } else {
                throw new IllegalArgumentException("valid context is required in Countly init, but was provided 'null'");
            }
        } else {
            L.d("[Init] Using explicitly provided context");
        }
        if (!UtilsNetworking.isValidURL(config.serverURL)) {
            throw new IllegalArgumentException("valid serverURL is required");
        }
        if (config.serverURL.charAt(config.serverURL.length() - 1) == '/') {
            L.v("[Init] Removing trailing '/' from provided server url");
            config.serverURL = config.serverURL.substring(0, config.serverURL.length() - 1);//removing trailing '/' from server url
        }
        if (config.appKey == null || config.appKey.isEmpty()) {
            throw new IllegalArgumentException("valid appKey is required, but was provided either 'null' or empty String");
        }
        if (config.application == null) {
            L.w("[Init] Initialising the SDK without providing the application class. Some functionality will not work.");
        }
        applicationClassProvided = config.application != null;
        if (config.deviceID != null && config.deviceID.isEmpty()) {
            //device ID is provided but it's a empty string
            L.w("[Countly] init, Provided device ID is an empty string. It will be ignored. And a new one will be generated by the SDK.");
            // setting device id as null to trigger SDK device id generation
            config.setDeviceId(null);
        }
        L.d("[Init] SDK initialised with the URL:[" + config.serverURL + "] and the appKey:[" + config.appKey + "]");
        if (L.logEnabled()) {
            L.i("[Init] Checking init parameters");
            // Context class hierarchy
            // Context
            //|- ContextWrapper
            //|- - Application
            //|- - ContextThemeWrapper
            //|- - - - Activity
            //|- - Service
            //|- - - IntentService
            Class contextClass = config.context.getClass();
            Class contextSuperClass = contextClass.getSuperclass();
            String contextText = "[Init] Provided Context [" + config.context.getClass().getSimpleName() + "]";
            if (contextSuperClass != null) {
                contextText += ", it's superclass: [" + contextSuperClass.getSimpleName() + "]";
            }
            L.i(contextText);
        }
        //set internal context, it's allowed to be changed on the second init call
        context_ = config.context.getApplicationContext();
        // if we get here and eventQueue_ != null, init is being called again with the same values,
        // so there is nothing to do, because we are already initialized with those values
        if (!sdkIsInitialised) {
            L.d("[Init] About to init internal systems");
            config_ = config;
            // Have a look at the SDK limit values
            if (config.sdkInternalLimits.maxKeyLength != null) {
                if (config.sdkInternalLimits.maxKeyLength < 1) {
                    config.sdkInternalLimits.maxKeyLength = 1;
                    L.w("[Init] provided 'maxKeyLength' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxKeyLength' override:[" + config.sdkInternalLimits.maxKeyLength + "]");
            } else {
                config.sdkInternalLimits.maxKeyLength = maxKeyLengthDefault;
            }
            if (config.sdkInternalLimits.maxValueSize != null) {
                if (config.sdkInternalLimits.maxValueSize < 1) {
                    config.sdkInternalLimits.maxValueSize = 1;
                    L.w("[Init] provided 'maxValueSize' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxValueSize' override:[" + config.sdkInternalLimits.maxValueSize + "]");
            } else {
                config.sdkInternalLimits.maxValueSize = maxValueSizeDefault;
            }
            if (config.sdkInternalLimits.maxSegmentationValues != null) {
                if (config.sdkInternalLimits.maxSegmentationValues < 1) {
                    config.sdkInternalLimits.maxSegmentationValues = 1;
                    L.w("[Init] provided 'maxSegmentationValues' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxSegmentationValues' override:[" + config.sdkInternalLimits.maxSegmentationValues + "]");
            } else {
                config.sdkInternalLimits.maxSegmentationValues = maxSegmentationValuesDefault;
            }
            if (config.sdkInternalLimits.maxBreadcrumbCount != null) {
                if (config.sdkInternalLimits.maxBreadcrumbCount < 1) {
                    config.sdkInternalLimits.maxBreadcrumbCount = 1;
                    L.w("[Init] provided 'maxBreadcrumbCount' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxBreadcrumbCount' override:[" + config.sdkInternalLimits.maxBreadcrumbCount + "]");
            } else {
                config.sdkInternalLimits.maxBreadcrumbCount = maxBreadcrumbCountDefault;
            }
            if (config.sdkInternalLimits.maxStackTraceLinesPerThread != null) {
                if (config.sdkInternalLimits.maxStackTraceLinesPerThread < 1) {
                    config.sdkInternalLimits.maxStackTraceLinesPerThread = 1;
                    L.w("[Init] provided 'maxStackTraceLinesPerThread' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxStackTraceLinesPerThread' override:[" + config.sdkInternalLimits.maxStackTraceLinesPerThread + "]");
            } else {
                config.sdkInternalLimits.maxStackTraceLinesPerThread = maxStackTraceLinesPerThreadDefault;
            }
            if (config.sdkInternalLimits.maxStackTraceLineLength != null) {
                if (config.sdkInternalLimits.maxStackTraceLineLength < 1) {
                    config.sdkInternalLimits.maxStackTraceLineLength = 1;
                    L.w("[Init] provided 'maxStackTraceLineLength' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxStackTraceLineLength' override:[" + config.sdkInternalLimits.maxStackTraceLineLength + "]");
            } else {
                config.sdkInternalLimits.maxStackTraceLineLength = maxStackTraceLineLengthDefault;
            }
            long timerDelay = TIMER_DELAY_IN_SECONDS;
            if (config.sessionUpdateTimerDelay != null) {
                //if we need to change the timer delay, do that first
                L.d("[Init] Setting custom session update timer delay, [" + config.sessionUpdateTimerDelay + "]");
                timerDelay = config.sessionUpdateTimerDelay;
            }
            startTimerService(timerService_, timerFuture, timerDelay);
            if (config.explicitStorageModeEnabled) {
                L.i("[Init] Explicit storage mode is being enabled");
            }
            //set or create the CountlyStore
            if (config.countlyStore != null) {
                //we are running a test and using a mock object
                countlyStore = config.countlyStore;
            } else {
                countlyStore = new CountlyStore(config.context, L, config.explicitStorageModeEnabled);
                config.setCountlyStore(countlyStore);
            }
            if (config.pcc != null) {
                L.i("[Init] Attaching a performance counter collector");
                countlyStore.pcc = config.pcc;
            }
            if (config.maxRequestQueueSize < 1) {
                L.e("[Init] provided request queue size is less than 1. Replacing it with 1.");
                config.maxRequestQueueSize = 1;
            }
            L.d("[Init] request queue size set to [" + config.maxRequestQueueSize + "]");
            countlyStore.setLimits(config.maxRequestQueueSize);
            if (config.storageProvider == null) {
                // outside of tests this should be null
                config.storageProvider = config.countlyStore;
            } else {
                L.d("[Init] Custom event storage provider was provided");
            }
            if (config.eventQueueProvider == null) {
                config.eventQueueProvider = countlyStore;
            } else {
                L.d("[Init] Custom event queue provider was provided");
            }
            if (config.requestQueueProvider == null) {
                config.requestQueueProvider = connectionQueue_;
            } else {
                L.d("[Init] Custom request queue provider was provided");
            }
            if (config.safeViewIDGenerator == null) {
                //if we didn't override this for a test
                config.safeViewIDGenerator = new SafeIDGenerator() {
                    @NonNull @Override public String GenerateValue() {
                        return Utils.safeRandomVal();
                    }
                };
            }
            if (config.safeEventIDGenerator == null) {
                //if we didn't override this for a test
                config.safeEventIDGenerator = new SafeIDGenerator() {
                    @NonNull @Override public String GenerateValue() {
                        return Utils.safeRandomVal();
                    }
                };
            }
            if (config.immediateRequestGenerator == null) {
                config.immediateRequestGenerator = new ImmediateRequestGenerator() {
                    @Override public ImmediateRequestI CreateImmediateRequestMaker() {
                        return (new ImmediateRequestMaker());
                    }
                };
            }
            if (config.lifecycleObserver == null) {
                config.lifecycleObserver = new LifecycleObserver() {
                    @Override public boolean LifeCycleAtleastStarted() {
                        return lifecycleStateAtLeastStartedInternal();
                    }
                };
            }
            if (config.metricProviderOverride != null) {
                L.d("[Init] Custom metric provider was provided");
            }
            config.deviceInfo = new DeviceInfo(config.metricProviderOverride);
            if (config.tamperingProtectionSalt != null) {
                L.d("[Init] Parameter tampering protection salt set");
            }
            if (config.dropAgeHours < 0) {
                config.dropAgeHours = 0;
                L.d("[Init] Drop older requests threshold can not be negative. No threshold will be set.");
            }
            if (config.dropAgeHours > 0) {
                L.d("[Init] Drop older requests threshold set to:[" + config.dropAgeHours + "] hours");
            }
            if (connectionQueue_ == null) {
                L.e("[Init] SDK failed to initialize because the connection queue failed to be created");
                return this;
            }
            //check legacy access methods
            if (locationFallback != null && config.locationCountyCode == null && config.locationCity == null && config.locationLocation == null && config.locationIpAddress == null) {
                //if the fallback was set and config did not contain any location, use the fallback info
                // { country_code, city, gpsCoordinates, ipAddress };
                config.locationCountyCode = locationFallback[0];
                config.locationCity = locationFallback[1];
                config.locationLocation = locationFallback[2];
                config.locationIpAddress = locationFallback[3];
            }
            //perform data migration if needed
            try {
                Map<String, Object> migrationParams = new HashMap<>();
                migrationParams.put(MigrationHelper.key_from_0_to_1_custom_id_set, config.deviceID != null);
                MigrationHelper mHelper = new MigrationHelper(config.storageProvider, L, context_);
                mHelper.doWork(migrationParams);
            } catch (Exception ex) {
                L.e("[Init] SDK failed while performing data migration. SDK is not capable to initialize.");
                return this;
            }
            //initialise modules
            moduleHealthCheck = new ModuleHealthCheck(this, config);
            moduleConfiguration = new ModuleConfiguration(this, config);
            moduleRequestQueue = new ModuleRequestQueue(this, config);
            moduleConsent = new ModuleConsent(this, config);
            moduleDeviceId = new ModuleDeviceId(this, config);
            moduleCrash = new ModuleCrash(this, config);
            moduleEvents = new ModuleEvents(this, config);
            moduleUserProfile = new ModuleUserProfile(this, config);//this has to be set before the session module so that we can update remote config before sending anything session related
            moduleViews = new ModuleViews(this, config);
            moduleRatings = new ModuleRatings(this, config);
            moduleSessions = new ModuleSessions(this, config);
            moduleRemoteConfig = new ModuleRemoteConfig(this, config);
            moduleAPM = new ModuleAPM(this, config);
            moduleLocation = new ModuleLocation(this, config);
            moduleFeedback = new ModuleFeedback(this, config);
            moduleAttribution = new ModuleAttribution(this, config);
            moduleContent = new ModuleContent(this, config);
            modules.clear();
            modules.add(moduleConfiguration);
            modules.add(moduleRequestQueue);
            modules.add(moduleConsent);
            modules.add(moduleDeviceId);
            modules.add(moduleCrash);
            modules.add(moduleEvents);
            modules.add(moduleUserProfile);//this has to be set before the session module so that we can update remote config before sending anything session related
            modules.add(moduleViews);
            modules.add(moduleRatings);
            modules.add(moduleSessions);
            modules.add(moduleRemoteConfig);
            modules.add(moduleAPM);
            modules.add(moduleLocation);
            modules.add(moduleFeedback);
            modules.add(moduleAttribution);
            modules.add(moduleContent);
            modules.add(moduleHealthCheck);//set this at the end to detect any health issues with other modules before sending the report
            if (config.testModuleListener != null) {
                modules.add(config.testModuleListener);
            }
            //add missing providers
            moduleConfiguration.consentProvider = config.consentProvider;
            moduleRequestQueue.consentProvider = config.consentProvider;
            moduleHealthCheck.consentProvider = config.consentProvider;
            moduleRequestQueue.deviceIdProvider = config.deviceIdProvider;
            moduleConsent.eventProvider = config.eventProvider;
            moduleConsent.deviceIdProvider = config.deviceIdProvider;
            moduleDeviceId.eventProvider = config.eventProvider;
            moduleCrash.eventProvider = config.eventProvider;
            moduleEvents.viewIdProvider = config.viewIdProvider;
            baseInfoProvider = config.baseInfoProvider;
            requestQueueProvider = config.requestQueueProvider;
            L.setHealthChecker(config.healthTracker);
            L.i("[Init] Finished initialising modules");
            if (config.customNetworkRequestHeaders != null) {
                L.i("[Countly] Calling addCustomNetworkRequestHeaders");
                requestHeaderCustomValues = config.customNetworkRequestHeaders;
                connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);
            }
            if (config.httpPostForced) {
                L.d("[Init] Setting HTTP POST to be forced");
                isHttpPostForced = config.httpPostForced;
            }
            if (config.tamperingProtectionSalt != null) {
                L.d("[Init] Enabling tamper protection");
            }
            if (config.dropAgeHours > 0) {
                L.d("[Init] Enabling drop older request threshold");
                countlyStore.setRequestAgeLimit(config.dropAgeHours);
            }
            if (config.pushIntentAddMetadata) {
                L.d("[Init] Enabling push intent metadata");
                addMetadataToPushIntents = config.pushIntentAddMetadata;
            }
            if (config.eventQueueSizeThreshold != null) {
                L.d("[Init] Setting event queue size: [" + config.eventQueueSizeThreshold + "]");
                if (config.eventQueueSizeThreshold < 1) {
                    L.d("[Init] queue size can't be less than zero");
                    config.eventQueueSizeThreshold = 1;
                }
                EVENT_QUEUE_SIZE_THRESHOLD = config.eventQueueSizeThreshold;
            }
            if (config.publicKeyPinningCertificates != null) {
                sharedInstance().L.i("[Init] Enabling public key pinning");
                publicKeyPinCertificates = config.publicKeyPinningCertificates;
            }
            if (config.certificatePinningCertificates != null) {
                Countly.sharedInstance().L.i("[Init] Enabling certificate pinning");
                certificatePinCertificates = config.certificatePinningCertificates;
            }
            //initialize networking queues
            connectionQueue_.L = L;
            connectionQueue_.healthTracker = config.healthTracker;
            connectionQueue_.configProvider = config.configProvider;
            connectionQueue_.consentProvider = moduleConsent;
            connectionQueue_.moduleRequestQueue = moduleRequestQueue;
            connectionQueue_.deviceInfo = config.deviceInfo;
            connectionQueue_.pcc = config.pcc;
            connectionQueue_.setStorageProvider(config.storageProvider);
            connectionQueue_.setupSSLContext();
            connectionQueue_.setBaseInfoProvider(config.baseInfoProvider);
            connectionQueue_.setDeviceId(config.deviceIdProvider);
            connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);
            connectionQueue_.setMetricOverride(config.metricOverride);
            connectionQueue_.setContext(context_);
            connectionQueue_.requestInfoProvider = new RequestInfoProvider() {
                @Override public boolean isHttpPostForced() {
                    return requestQueue().isHttpPostForced();
                }
                @Override public boolean isDeviceAppCrawler() {
                    return requestQueue().isDeviceAppCrawler();
                }
                @Override public boolean ifShouldIgnoreCrawlers() {
                    return requestQueue().ifShouldIgnoreCrawlers();
                }
                @Override public int getRequestDropAgeHours() {
                    return config.dropAgeHours;
                }
                @Override public String getRequestSalt() {
                    return config.tamperingProtectionSalt;
                }
            };
            sdkIsInitialised = true;
            //AFTER THIS POINT THE SDK IS COUNTED AS INITIALISED
            //set global application listeners
            if (config.application != null) {
                L.d("[Countly] Calling registerActivityLifecycleCallbacks");
                config.application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() {
                    @Override
                    public void onActivityCreated(Activity activity, Bundle bundle) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityCreated, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityCreated(activity);
                        //}
                    }
                    @Override
                    public void onActivityStarted(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityStarted, " + activity.getClass().getSimpleName());
                        }
                        onStartInternal(activity);
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityStarted(activity);
                        //}
                    }
                    @Override
                    public void onActivityResumed(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityResumed, " + activity.getClass().getSimpleName());
                        }
                        //for star rating
                        for (ModuleBase module : modules) {
                            module.callbackOnActivityResumed(activity);
                        }
                    }
                    @Override
                    public void onActivityPaused(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityPaused, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityPaused(activity);
                        //}
                    }
                    @Override
                    public void onActivityStopped(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityStopped, " + activity.getClass().getSimpleName());
                        }
                        onStopInternal();
                        //for APM
                        for (ModuleBase module : modules) {
                            module.callbackOnActivityStopped(activity);
                        }
                    }
                    @Override
                    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivitySaveInstanceState, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivitySaveInstanceState(activity);
                        //}
                    }
                    @Override
                    public void onActivityDestroyed(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityDestroyed, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityDestroyed(activity);
                        //}
                    }
                });
                config.application.registerComponentCallbacks(new ComponentCallbacks() {
                    @Override
                    public void onConfigurationChanged(Configuration configuration) {
                        L.d("[Countly] ComponentCallbacks, onConfigurationChanged");
                        onConfigurationChangedInternal(configuration);
                    }
                    @Override
                    public void onLowMemory() {
                        L.d("[Countly] ComponentCallbacks, onLowMemory");
                    }
                });
            } else {
                L.d("[Countly] Global activity listeners not registred due to no Application class");
            }
            if (config_.lifecycleObserver.LifeCycleAtleastStarted()) {
                L.d("[Countly] SDK detects that the app is in the foreground. Increasing the activity counter and setting the foreground state.");
                activityCount_++;
                config.deviceInfo.inForeground();
            }
            L.i("[Init] About to call module 'initFinished'");
            for (ModuleBase module : modules) {
                module.initFinished(config);
            }
            L.i("[Init] Finished initialising SDK");
        } else {
            //if this is not the first time we are calling init
            L.i("[Init] Getting in the 'else' block");
            // context is allowed to be changed on the second init call
            connectionQueue_.setContext(context_);
        }
        return this;
    }
    /**
     * Checks whether Countly.init has been already called.
     *
     * @return true if Countly is ready to use
     */
    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    public boolean isInitialized() {
        return sdkIsInitialised;
    }
    boolean lifecycleStateAtLeastStartedInternal() {
        return ProcessLifecycleOwner.get().getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED);
    }
    private void stopTimer() {
        L.i("[Countly] stopTimer, Stopping global timer");
        if (timerService_ != null) {
            try {
                timerService_.shutdown();
                if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {
                    timerService_.shutdownNow();
                    if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {
                        L.e("[Countly] stopTimer, Global timer must be locked");
                    }
                }
            } catch (Throwable t) {
                L.e("[Countly] stopTimer, Error while stopping global timer " + t);
            }
        }
    }
    /**
     * Immediately disables session and event tracking and clears any stored session and event data.
     * Testing Purposes Only!
     *
     * This will destroy all stored data
     */
    public synchronized void halt() {
        L.i("Halting Countly!");
        sdkIsInitialised = false;
        L.SetListener(null);
        stopTimer();
        if (connectionQueue_ != null) {
            if (countlyStore != null) {
                countlyStore.clear();
            }
            connectionQueue_.setContext(null);
            connectionQueue_ = null;
        }
        activityCount_ = 0;
        for (ModuleBase module : modules) {
            module.halt();
        }
        modules.clear();
        moduleCrash = null;
        moduleViews = null;
        moduleEvents = null;
        moduleRatings = null;
        moduleSessions = null;
        moduleRemoteConfig = null;
        moduleConsent = null;
        moduleAPM = null;
        moduleDeviceId = null;
        moduleLocation = null;
        moduleFeedback = null;
        moduleRequestQueue = null;
        moduleConfiguration = null;
        moduleHealthCheck = null;
        moduleContent = null;
        COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;
        COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;
        connectionQueue_ = new ConnectionQueue();
        timerService_ = Executors.newSingleThreadScheduledExecutor();
    }
    synchronized void notifyDeviceIdChange(boolean withoutMerge) {
        L.d("Notifying modules that device ID changed");
        for (ModuleBase module : modules) {
            module.deviceIdChanged(withoutMerge);
        }
    }
    void onStartInternal(Activity activity) {
        if (L.logEnabled()) {
            String activityName = "NULL ACTIVITY PROVIDED";
            if (activity != null) {
                activityName = activity.getClass().getSimpleName();
            }
            L.d("Countly onStartInternal called, name:[" + activityName + "], [" + activityCount_ + "] -> [" + (activityCount_ + 1) + "] activities now open");
        }
        ++activityCount_;
        if (activityCount_ == 1 && !moduleSessions.manualSessionControlEnabled) {
            //if we open the first activity
            //and we are not using manual session control,
            //begin a session
            moduleSessions.beginSessionInternal();
        }
        config_.deviceInfo.inForeground();
        for (ModuleBase module : modules) {
            module.onActivityStarted(activity, activityCount_);
        }
        calledAtLeastOnceOnStart = true;
    }
    void onStopInternal() {
        L.d("Countly onStopInternal called, [" + activityCount_ + "] -> [" + (activityCount_ - 1) + "] activities now open");
        if (activityCount_ == 0) {
            L.e("must call onStart before onStop");
            return;
        }
        --activityCount_;
        if (activityCount_ == 0 && !moduleSessions.manualSessionControlEnabled) {
            // if we don't use manual session control
            // Called when final Activity is stopped.
            // Sends an end session event to the server, also sends any unsent custom events.
            moduleSessions.endSessionInternal();
        }
        config_.deviceInfo.inBackground();
        for (ModuleBase module : modules) {
            module.onActivityStopped(activityCount_);
        }
    }
    public synchronized void onConfigurationChangedInternal(Configuration newConfig) {
        L.i("Calling [onConfigurationChangedInternal]");
        for (ModuleBase module : modules) {
            module.onConfigurationChanged(newConfig);
        }
    }
    /**
     * Tells the Countly SDK that an Activity has started. Since Android does not have an
     * easy way to determine when an application instance starts and stops, you must call this
     * method from every one of your Activity's onStart methods for accurate application
     * session tracking.
     */
    public synchronized void onStart(Activity activity) {
        if (!isInitialized()) {
            L.e("init must be called before onStart");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onStartInternal(activity);
    }
    /**
     * Tells the Countly SDK that an Activity has stopped. Since Android does not have an
     * easy way to determine when an application instance starts and stops, you must call this
     * method from every one of your Activity's onStop methods for accurate application
     * session tracking.
     * unbalanced calls to onStart/onStop are detected
     */
    public synchronized void onStop() {
        if (!isInitialized()) {
            L.e("init must be called before onStop");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onStopInternal();
    }
    public synchronized void onConfigurationChanged(Configuration newConfig) {
        if (!isInitialized()) {
            L.e("init must be called before onConfigurationChanged");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onConfigurationChanged' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onConfigurationChangedInternal(newConfig);
    }
    /**
     * Called every 60 seconds to send a session heartbeat to the server. Does nothing if there
     * is not an active application session.
     */
    synchronized void onTimer() {
        L.v("[onTimer] Calling heartbeat, Activity count:[" + activityCount_ + "]");
        if (isInitialized()) {
            final boolean appIsInForeground = activityCount_ > 0;
            if (appIsInForeground && !moduleSessions.manualSessionControlEnabled) {
                //if we have automatic session control and we are in the foreground, record an update
                moduleSessions.updateSessionInternal();
            } else if (moduleSessions.manualSessionControlEnabled && moduleSessions.manualSessionControlHybridModeEnabled && moduleSessions.sessionIsRunning()) {
                // if we are in manual session control mode with hybrid sessions enabled (SDK takes care of update requests) and there is a session running,
                // let's create the update request
                moduleSessions.updateSessionInternal();
            }
            //on every timer tick we collect all events and attempt to send requests
            moduleRequestQueue.sendEventsIfNeeded(true);
            //on every timer tick we save the user profile if it was changed
            moduleUserProfile.saveInternal();
            requestQueueProvider.tick();
        }
    }
    /**
     * DON'T USE THIS!!!!
     */
    public void onRegistrationId(String registrationId, CountlyMessagingProvider provider) {
        //if this call is done by CountlyPush, it is assumed that the SDK is already initialised
        if (!config_.consentProvider.getConsent(CountlyFeatureNames.push)) {
            return;
        }
        if (!isInitialized()) {
            L.w("[onRegistrationId] Calling this before the SDK is initialized.");
        }
        //debouncing the call
        long currentTs = UtilsTime.currentTimestampMs();
        long timeDelta = currentTs - lastRegistrationCallTs;
        if (lastRegistrationCallID != null && lastRegistrationCallID.equals(registrationId) &&
            lastRegistrationCallProvider != null && lastRegistrationCallProvider == provider &&
            timeDelta < lastRegistrationCallDebounceDuration) {
            // if the values match and we are trying to resend them withing the debounce duration, ignore them
            L.w("[onRegistrationId] Calling this with the same values within the debounce interval. elapsedT:[" + timeDelta + "] ms");
            return;
        }
        lastRegistrationCallTs = currentTs;
        lastRegistrationCallID = registrationId;
        lastRegistrationCallProvider = provider;
        connectionQueue_.tokenSession(registrationId, provider);
    }
    public void setLoggingEnabled(final boolean enableLogging) {
        enableLogging_ = enableLogging;
        L.d("Enabling logging");
    }
    /**
     * Check if logging has been enabled internally in the SDK
     *
     * @return true means "yes"
     */
    public boolean isLoggingEnabled() {
        return enableLogging_;
    }
    /**
     * Returns if the countly sdk onStart function has been called at least once
     *
     * @return true - yes, it has, false - no it has not
     * @deprecated This will be removed
     */
    public boolean hasBeenCalledOnStart() {
        return calledAtLeastOnceOnStart;
    }
    public ModuleCrash.Crashes crashes() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing crashes");
            return null;
        }
        return moduleCrash.crashesInterface;
    }
    public ModuleEvents.Events events() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing events");
            return null;
        }
        return moduleEvents.eventsInterface;
    }
    public ModuleViews.Views views() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing views");
            return null;
        }
        return moduleViews.viewsInterface;
    }
    public ModuleRatings.Ratings ratings() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing ratings");
            return null;
        }
        return moduleRatings.ratingsInterface;
    }
    public ModuleSessions.Sessions sessions() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing sessions");
            return null;
        }
        return moduleSessions.sessionInterface;
    }
    public ModuleRemoteConfig.RemoteConfig remoteConfig() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing remote config");
            return null;
        }
        return moduleRemoteConfig.remoteConfigInterface;
    }
    public ModuleAPM.Apm apm() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing apm");
            return null;
        }
        return moduleAPM.apmInterface;
    }
    public ModuleConsent.Consent consent() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing consent");
            return null;
        }
        return moduleConsent.consentInterface;
    }
    public ModuleLocation.Location location() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing location");
            return null;
        }
        return moduleLocation.locationInterface;
    }
    public ModuleFeedback.Feedback feedback() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing feedback");
            return null;
        }
        return moduleFeedback.feedbackInterface;
    }
    public ModuleRequestQueue.RequestQueue requestQueue() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing request queue");
            return null;
        }
        return moduleRequestQueue.requestQueueInterface;
    }
    public ModuleAttribution.Attribution attribution() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing attribution");
            return null;
        }
        return moduleAttribution.attributionInterface;
    }
    public ModuleDeviceId.DeviceId deviceId() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing deviceId");
            return null;
        }
        return moduleDeviceId.deviceIdInterface;
    }
    public ModuleUserProfile.UserProfile userProfile() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing user profile");
            return null;
        }
        return moduleUserProfile.userProfileInterface;
    }
    /**
     * Content feature interface
     *
     * @return content module
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public ModuleContent.Content contents() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing content");
            return null;
        }
        return moduleContent.contentInterface;
    }
    public static void applicationOnCreate() {
    }
    // for unit testing
    ConnectionQueue getConnectionQueue() {
        return connectionQueue_;
    }
    ExecutorService getTimerService() {
        return timerService_;
    }
    long getPrevSessionDurationStartTime() {
        return moduleSessions.prevSessionDurationStartTime_;
    }
    void setPrevSessionDurationStartTime(final long prevSessionDurationStartTime) {
        moduleSessions.prevSessionDurationStartTime_ = prevSessionDurationStartTime;
    }
    int getActivityCount() {
        return activityCount_;
    }
    synchronized boolean getDisableUpdateSessionRequests() {
        return disableUpdateSessionRequests_;
    }
}
package ly.count.android.sdk;
interface ImmediateRequestI {
    void doWork(String requestData, String customEndpoint, ConnectionProcessor cp, boolean requestShouldBeDelayed, boolean networkingIsEnabled, ImmediateRequestMaker.InternalImmediateRequestCallback callback, ModuleLog log);
}
package ly.count.android.sdk;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.view.LayoutInflater;
import android.view.View;
import android.webkit.WebResourceRequest;
import android.webkit.WebResourceResponse;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.RatingBar;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleRatings extends ModuleBase {
    //star rating
    StarRatingCallback starRatingCallback_;// saved callback that is used for automatic star rating
    boolean showStarRatingDialogOnFirstActivity = false;
    final Ratings ratingsInterface;
    ModuleRatings(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleRatings] Initialising");
        starRatingCallback_ = config.starRatingCallback;
        setStarRatingInitConfig(config.starRatingSessionLimit, config.starRatingTextTitle, config.starRatingTextMessage, config.starRatingTextDismiss);
        setIfRatingDialogIsCancellableInternal(config.starRatingDialogIsCancellable);
        setShowDialogAutomatically(config.starRatingShownAutomatically);
        setStarRatingDisableAskingForEachAppVersion(config.starRatingDisableAskingForEachAppVersion);
        ratingsInterface = new Ratings();
    }
    void recordManualRatingInternal(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
        L.d("[ModuleRatings] Calling recordManualRatingInternal");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            return;
        }
        if (widgetId == null) {
            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is null, returning");
            return;
        }
        if (widgetId.isEmpty()) {
            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is empty, returning");
            return;
        }
        if (rating < 1) {
            rating = 1;
            L.d("[ModuleRatings] recordManualRatingInternal, given rating too low, defaulting to 1");
        }
        if (rating > 5) {
            rating = 5;
            L.d("[ModuleRatings] recordManualRatingInternal, given rating too high, defaulting to 5");
        }
        String truncatedEmail = UtilsInternalLimits.truncateValueSize(email, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");
        String truncatedComment = UtilsInternalLimits.truncateValueSize(comment, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");
        Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", deviceInfo.mp.getAppVersion(_cly.context_));
        segm.put("rating", "" + rating);
        segm.put("widget_id", widgetId);
        segm.put("contactMe", userCanBeContacted);
        if (truncatedEmail != null && !truncatedEmail.isEmpty()) {
            segm.put("email", truncatedEmail);
        }
        if (truncatedComment != null && !truncatedComment.isEmpty()) {
            segm.put("comment", truncatedComment);
        }
        eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    /**
     * Save the star rating preferences object
     *
     * @param srp
     */
    private void saveStarRatingPreferences(final StarRatingPreferences srp) {
        storageProvider.setStarRatingPreferences(srp.toJSON().toString());
    }
    /**
     * Setting things that would be provided during initial config
     *
     * @param limit limit for automatic rating
     * @param starRatingTextTitle provided title
     * @param starRatingTextMessage provided message
     * @param starRatingTextDismiss provided dismiss text
     */
    void setStarRatingInitConfig(final int limit, final String starRatingTextTitle, final String starRatingTextMessage, final String starRatingTextDismiss) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        if (limit >= 0) {
            srp.sessionLimit = limit;
        }
        if (starRatingTextTitle != null) {
            srp.dialogTextTitle = starRatingTextTitle;
        }
        if (starRatingTextMessage != null) {
            srp.dialogTextMessage = starRatingTextMessage;
        }
        if (starRatingTextDismiss != null) {
            srp.dialogTextDismiss = starRatingTextDismiss;
        }
        saveStarRatingPreferences(srp);
    }
    /**
     * Set if the star rating dialog should be shown automatically
     *
     * @param shouldShow
     */
    void setShowDialogAutomatically(final boolean shouldShow) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.automaticRatingShouldBeShown = shouldShow;
        saveStarRatingPreferences(srp);
    }
    boolean getIfStarRatingShouldBeShownAutomatically() {
        StarRatingPreferences srp = loadStarRatingPreferences(_cly.countlyStore);
        return srp.automaticRatingShouldBeShown;
    }
    /**
     * Set if automatic star rating should be disabled for each new version.
     * By default automatic star rating will be shown for every new app version.
     * If this is set to true, star rating will be shown only once over apps lifetime
     *
     * @param disableAsking if set true, will not show star rating for every new app version
     */
    void setStarRatingDisableAskingForEachAppVersion(final boolean disableAsking) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.disabledAutomaticForNewVersions = disableAsking;
        saveStarRatingPreferences(srp);
    }
    /**
     * Register that a apps session has transpired. Will increase session counter and show automatic star rating if needed.
     *
     * @param context android context
     * @param starRatingCallback
     */
    void registerAppSession(final Context context, final StarRatingCallback starRatingCallback) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        String currentAppVersion = deviceInfo.mp.getAppVersion(context);
        //a new app version is released, reset all counters
        //if we show the rating once per apps lifetime, don't reset the counters
        if (currentAppVersion != null && !currentAppVersion.equals(srp.appVersion) && !srp.disabledAutomaticForNewVersions) {
            srp.appVersion = currentAppVersion;
            srp.isShownForCurrentVersion = false;
            srp.sessionAmount = 0;
        }
        srp.sessionAmount++;
        if (srp.sessionAmount >= srp.sessionLimit && !srp.isShownForCurrentVersion && srp.automaticRatingShouldBeShown && !(srp.disabledAutomaticForNewVersions && srp.automaticHasBeenShown)) {
            showStarRatingDialogOnFirstActivity = true;
        }
        saveStarRatingPreferences(srp);
    }
    /**
     * Returns the session limit set for automatic star rating
     */
    static int getAutomaticStarRatingSessionLimitInternal(final StorageProvider sp) {
        StarRatingPreferences srp = loadStarRatingPreferences(sp);
        return srp.sessionLimit;
    }
    /**
     * Returns how many sessions has star rating counted internally
     *
     * @return
     */
    int getCurrentVersionsSessionCountInternal(final StorageProvider sp) {
        StarRatingPreferences srp = loadStarRatingPreferences(sp);
        return srp.sessionAmount;
    }
    /**
     * Set the automatic star rating session count back to 0
     */
    void clearAutomaticStarRatingSessionCountInternal() {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.sessionAmount = 0;
        saveStarRatingPreferences(srp);
    }
    /**
     * Set if the star rating dialog is cancellable
     *
     * @param isCancellable
     */
    void setIfRatingDialogIsCancellableInternal(final boolean isCancellable) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.isDialogCancellable = isCancellable;
        saveStarRatingPreferences(srp);
    }
    /**
     * Class that handles star rating internal state
     */
    static class StarRatingPreferences {
        String appVersion = ""; //the name of the current version that we keep track of
        int sessionLimit = 5; //session limit for the automatic star rating
        int sessionAmount = 0; //session amount for the current version
        boolean isShownForCurrentVersion = false; //if automatic star rating has been shown for the current version
        boolean automaticRatingShouldBeShown = false; //if the automatic star rating should be shown
        boolean disabledAutomaticForNewVersions = false; //if the automatic star star should not be shown for every new apps version
        boolean automaticHasBeenShown = false; //if automatic star rating has been shown for any app's version
        boolean isDialogCancellable = true; //if star rating dialog is cancellable
        String dialogTextTitle = "App rating";
        String dialogTextMessage = "Please rate this app";
        String dialogTextDismiss = "Cancel";
        private static final String KEY_APP_VERSION = "sr_app_version";
        private static final String KEY_SESSION_LIMIT = "sr_session_limit";
        private static final String KEY_SESSION_AMOUNT = "sr_session_amount";
        private static final String KEY_IS_SHOWN_FOR_CURRENT = "sr_is_shown";
        private static final String KEY_AUTOMATIC_RATING_IS_SHOWN = "sr_is_automatic_shown";
        private static final String KEY_DISABLE_AUTOMATIC_NEW_VERSIONS = "sr_is_disable_automatic_new";
        private static final String KEY_AUTOMATIC_HAS_BEEN_SHOWN = "sr_automatic_has_been_shown";
        private static final String KEY_DIALOG_IS_CANCELLABLE = "sr_automatic_dialog_is_cancellable";
        private static final String KEY_DIALOG_TEXT_TITLE = "sr_text_title";
        private static final String KEY_DIALOG_TEXT_MESSAGE = "sr_text_message";
        private static final String KEY_DIALOG_TEXT_DISMISS = "sr_text_dismiss";
        /**
         * Create a JSONObject from the current state
         *
         * @return
         */
        JSONObject toJSON() {
            final JSONObject json = new JSONObject();
            try {
                json.put(KEY_APP_VERSION, appVersion);
                json.put(KEY_SESSION_LIMIT, sessionLimit);
                json.put(KEY_SESSION_AMOUNT, sessionAmount);
                json.put(KEY_IS_SHOWN_FOR_CURRENT, isShownForCurrentVersion);
                json.put(KEY_AUTOMATIC_RATING_IS_SHOWN, automaticRatingShouldBeShown);
                json.put(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, disabledAutomaticForNewVersions);
                json.put(KEY_AUTOMATIC_HAS_BEEN_SHOWN, automaticHasBeenShown);
                json.put(KEY_DIALOG_IS_CANCELLABLE, isDialogCancellable);
                json.put(KEY_DIALOG_TEXT_TITLE, dialogTextTitle);
                json.put(KEY_DIALOG_TEXT_MESSAGE, dialogTextMessage);
                json.put(KEY_DIALOG_TEXT_DISMISS, dialogTextDismiss);
            } catch (JSONException e) {
                Countly.sharedInstance().L.w("Got exception converting an StarRatingPreferences to JSON", e);
            }
            return json;
        }
        /**
         * Load the preference state from a JSONObject
         *
         * @param json
         * @return
         */
        static StarRatingPreferences fromJSON(final JSONObject json) {
            StarRatingPreferences srp = new StarRatingPreferences();
            if (json != null) {
                try {
                    srp.appVersion = json.getString(KEY_APP_VERSION);
                    srp.sessionLimit = json.optInt(KEY_SESSION_LIMIT, 5);
                    srp.sessionAmount = json.optInt(KEY_SESSION_AMOUNT, 0);
                    srp.isShownForCurrentVersion = json.optBoolean(KEY_IS_SHOWN_FOR_CURRENT, false);
                    srp.automaticRatingShouldBeShown = json.optBoolean(KEY_AUTOMATIC_RATING_IS_SHOWN, true);
                    srp.disabledAutomaticForNewVersions = json.optBoolean(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, false);
                    srp.automaticHasBeenShown = json.optBoolean(KEY_AUTOMATIC_HAS_BEEN_SHOWN, false);
                    srp.isDialogCancellable = json.optBoolean(KEY_DIALOG_IS_CANCELLABLE, true);
                    if (!json.isNull(KEY_DIALOG_TEXT_TITLE)) {
                        srp.dialogTextTitle = json.getString(KEY_DIALOG_TEXT_TITLE);
                    }
                    if (!json.isNull(KEY_DIALOG_TEXT_MESSAGE)) {
                        srp.dialogTextMessage = json.getString(KEY_DIALOG_TEXT_MESSAGE);
                    }
                    if (!json.isNull(KEY_DIALOG_TEXT_DISMISS)) {
                        srp.dialogTextDismiss = json.getString(KEY_DIALOG_TEXT_DISMISS);
                    }
                } catch (JSONException e) {
                    Countly.sharedInstance().L.w("Got exception converting JSON to a StarRatingPreferences", e);
                }
            }
            return srp;
        }
    }
    /**
     * Call to manually show star rating dialog
     *
     * @param context android context
     * @param callback
     */
    void showStarRatingInternal(final Context context, final StarRatingCallback callback) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        showStarRatingCustom(context, srp.dialogTextTitle, srp.dialogTextMessage, srp.dialogTextDismiss, srp.isDialogCancellable, callback);
    }
    /**
     * Returns a object with the loaded preferences
     * TODO make this non static
     *
     * @return
     */
    static StarRatingPreferences loadStarRatingPreferences(final StorageProvider sp) {
        String srpString = sp.getStarRatingPreferences();
        StarRatingPreferences srp;
        if (!srpString.equals("")) {
            JSONObject srJSON;
            try {
                srJSON = new JSONObject(srpString);
                srp = StarRatingPreferences.fromJSON(srJSON);
            } catch (JSONException e) {
                e.printStackTrace();
                srp = new StarRatingPreferences();
            }
        } else {
            srp = new StarRatingPreferences();
        }
        return srp;
    }
    /**
     * Method that created the star rating dialog
     *
     * @param context android context
     * @param title
     * @param message
     * @param cancelText
     * @param isCancellable
     * @param callback
     */
    void showStarRatingCustom(@NonNull final Context context, final String title, final String message, final String cancelText, final boolean isCancellable, @Nullable final StarRatingCallback callback) {
        if (!(context instanceof Activity)) {
            L.e("[ModuleRatings] Can't show star rating dialog, the provided context is not based off a activity");
            return;
        }
        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        View dialogLayout = inflater.inflate(R.layout.star_rating_layout, null);
        RatingBar ratingBar = dialogLayout.findViewById(R.id.ratingBar);
        final AlertDialog.Builder builder = new AlertDialog.Builder(context)
            .setTitle(title)
            .setMessage(message)
            .setCancelable(isCancellable)
            .setView(dialogLayout)
            .setOnCancelListener(new DialogInterface.OnCancelListener() {
                @Override
                public void onCancel(DialogInterface dialogInterface) {
                    if (callback != null) {
                        //call the dismiss callback ir the user clicks the back button or clicks outside the dialog
                        callback.onDismiss();
                    }
                }
            })
            .setPositiveButton(cancelText, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialogInterface, int i) {
                    if (callback != null) {
                        //call the dismiss callback if the user clicks the "dismiss" button
                        callback.onDismiss();
                    }
                }
            });
        final AlertDialog dialog = builder.show();
        ratingBar.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener() {
            @Override
            public void onRatingChanged(RatingBar ratingBar, float v, boolean b) {
                int rating = (int) v;
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
                    Map<String, Object> segm = new HashMap<>();
                    segm.put("platform", "android");
                    segm.put("app_version", deviceInfo.mp.getAppVersion(context));
                    segm.put("rating", "" + rating);
                    eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
                }
                dialog.dismiss();
                if (callback != null) {
                    callback.onRate(rating);
                }
            }
        });
    }
    /// Countly webDialog user rating
    synchronized void showFeedbackPopupInternal(@Nullable final String widgetId, @Nullable final String closeButtonText, @Nullable final Activity activity, @Nullable final FeedbackRatingCallback devCallback) {
        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");
        if (widgetId == null || widgetId.isEmpty()) {
            if (devCallback != null) {
                devCallback.callback("Countly widgetId cannot be null or empty");
            }
            L.e("[ModuleRatings] Countly widgetId cannot be null or empty");
            return;
        }
        if (activity == null) {
            if (devCallback != null) {
                devCallback.callback("When showing feedback popup, Activity can't be null");
            }
            L.e("[ModuleRatings] When showing feedback popup, Activity can't be null");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            if (devCallback != null) {
                devCallback.callback("Consent is not granted");
            }
            return;
        }
        //check the device type
        final boolean deviceIsPhone;
        final boolean deviceIsTablet;
        final boolean deviceIsTv;
        deviceIsTv = Utils.isDeviceTv(activity);
        if (!deviceIsTv) {
            deviceIsPhone = !Utils.isDeviceTablet(activity);
            deviceIsTablet = Utils.isDeviceTablet(activity);
        } else {
            deviceIsTablet = false;
            deviceIsPhone = false;
        }
        String requestData = requestQueueProvider.prepareRatingWidgetRequest(widgetId);
        final String ratingWidgetUrl = baseInfoProvider.getServerURL() + "/feedback?widget_id=" + widgetId +
            "&device_id=" + UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()) +
            "&app_key=" + UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey());
        L.d("[ModuleRatings] rating widget url :[" + ratingWidgetUrl + "]");
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        (new ImmediateRequestMaker()).doWork(requestData, "/o/feedback/widget", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override
            public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably a lack of connection to the server");
                    if (devCallback != null) {
                        devCallback.callback("Not possible to show Rating popup, probably no internet connection or wrong widget id");
                    }
                    return;
                }
                if (!checkResponse.has("target_devices")) {
                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably using a widget_id not intended for the rating widget");
                    if (devCallback != null) {
                        devCallback.callback("Not possible to show Rating popup, probably using a widget_id not intended for the rating widget");
                    }
                    return;
                }
                try {
                    JSONObject jDevices = checkResponse.getJSONObject("target_devices");
                    boolean showOnTv = jDevices.optBoolean("desktop", false);
                    boolean showOnPhone = jDevices.optBoolean("phone", false);
                    boolean showOnTablet = jDevices.optBoolean("tablet", false);
                    if ((deviceIsPhone && showOnPhone) || (deviceIsTablet && showOnTablet) || (deviceIsTv && showOnTv)) {
                        //it's possible to show the rating window on this device
                        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");
                        Handler handler = new Handler(Looper.getMainLooper());
                        handler.post(new Runnable() {
                            public void run() {
                                L.d("[ModuleRatings] Calling on main thread");
                                RatingDialogWebView webView = new RatingDialogWebView(activity);
                                webView.clearCache(true);
                                webView.clearHistory();
                                webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
                                webView.getSettings().setJavaScriptEnabled(true);
                                webView.loadUrl(ratingWidgetUrl);
                                AlertDialog.Builder builder = new AlertDialog.Builder(activity);
                                builder.setView(webView);
                                if (closeButtonText != null && !closeButtonText.isEmpty()) {
                                    builder.setNeutralButton(closeButtonText, new DialogInterface.OnClickListener() {
                                        @Override public void onClick(DialogInterface dialog, int which) {
                                            L.d("[ModuleRatings] Calling callback from 'close' button");
                                            if (devCallback != null) {
                                                devCallback.callback(null);
                                            }
                                        }
                                    });
                                }
                                builder.show();
                            }
                        });
                    } else {
                        if (devCallback != null) {
                            devCallback.callback("Rating dialog is not meant for this form factor");
                        }
                    }
                } catch (JSONException e) {
                    L.e("[ModuleRatings] Encountered a issue while trying to parse the results of the widget config", e);
                }
            }
        }, L);
    }
    static class RatingDialogWebView extends WebView {
        public RatingDialogWebView(Context context) {
            super(context);
        }
        /**
         * Without this override, the keyboard is not showing
         */
        @Override
        public boolean onCheckIsTextEditor() {
            return true;
        }
    }
    static class FeedbackDialogWebViewClient extends WebViewClient {
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
            String url = request.getUrl().toString();
            // Filter out outgoing calls
            if (url.endsWith("cly_x_int=1")) {
                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
                view.getContext().startActivity(intent);
                return true;
            }
            return false;
        }
        @Override
        public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
            // Countly.sharedInstance().L.i("attempting to load resource: " + url);
            return null;
        }
        @Override
        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
            // Countly.sharedInstance().L.i("attempting to load resource: " + request.getUrl());
            return null;
        }
    }
    @Override
    void callbackOnActivityResumed(Activity activity) {
        if (showStarRatingDialogOnFirstActivity) {
            StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
            srp.isShownForCurrentVersion = true;
            srp.automaticHasBeenShown = true;
            showStarRatingInternal(activity, starRatingCallback_);
            saveStarRatingPreferences(srp);
            showStarRatingDialogOnFirstActivity = false;
        }
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        //do star rating related things
        if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            registerAppSession(config.context, starRatingCallback_);
        }
    }
    @Override
    void halt() {
    }
    public class Ratings {
        /**
         * Record user rating widget manually without showing any message dialog.
         *
         * @param widgetId widget ID to which this rating will be tied. You get it from the dashboard
         * @param rating value from 1 to 5 that will be set as the rating value
         * @param email email of the user
         * @param comment comment set by the user
         * @param userCanBeContacted set true if the user wants you to contact him
         * @deprecated use 'recordRatingWidgetWithID' in place of this call
         */
        public void recordManualRating(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
            L.i("[Ratings] Calling recordManualRating");
            recordRatingWidgetWithID(widgetId, rating, email, comment, userCanBeContacted);
        }
        /**
         * Record user rating widget manually without showing any message dialog.
         *
         * @param widgetId widget ID to which this rating will be tied. You get it from the dashboard
         * @param rating value from 1 to 5 that will be set as the rating value
         * @param email email of the user
         * @param comment comment set by the user
         * @param userCanBeContacted set true if the user wants you to contact him
         */
        public void recordRatingWidgetWithID(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
            synchronized (_cly) {
                L.i("[Ratings] Calling recordRatingWidgetWithID");
                if (widgetId == null || widgetId.isEmpty()) {
                    throw new IllegalStateException("A valid widgetID must be provided. The current one is either null or empty");
                }
                recordManualRatingInternal(widgetId, rating, email, comment, userCanBeContacted);
            }
        }
        /**
         * Show the rating dialog to the user
         *
         * @param widgetId ID that identifies this dialog
         * @deprecated use 'presentRatingWidgetWithID' in place of this call
         */
        public void showFeedbackPopup(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {
            L.i("[Ratings] Calling showFeedbackPopup");
            presentRatingWidgetWithID(widgetId, closeButtonText, activity, callback);
        }
        /**
         * Show the rating widget dialog to the user
         *
         * @param widgetId ID that identifies this dialog
         */
        public void presentRatingWidgetWithID(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {
            synchronized (_cly) {
                L.i("[Ratings] Calling presentRatingWidgetWithID");
                showFeedbackPopupInternal(widgetId, closeButtonText, activity, callback);
            }
        }
        /**
         * Shows the star rating dialog
         *
         * @param activity the activity that will own the dialog
         * @param callback callback for the star rating dialog "rate" and "dismiss" events
         */
        public void showStarRating(Activity activity, StarRatingCallback callback) {
            synchronized (_cly) {
                L.i("[Ratings] Calling showStarRating");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
                    return;
                }
                showStarRatingInternal(activity, callback);
            }
        }
        /**
         * Returns how many sessions has star rating counted internally for the current apps version
         *
         * @return
         */
        public int getCurrentVersionsSessionCount() {
            synchronized (_cly) {
                int sessionCount = getCurrentVersionsSessionCountInternal(_cly.countlyStore);
                L.i("[Ratings] Getting star rating current version session count: [" + sessionCount + "]");
                return sessionCount;
            }
        }
        /**
         * Set the automatic star rating session count back to 0
         */
        public void clearAutomaticStarRatingSessionCount() {
            synchronized (_cly) {
                L.i("[Ratings] Clearing star rating session count");
                clearAutomaticStarRatingSessionCountInternal();
            }
        }
        /**
         * Returns the session limit set for automatic star rating
         */
        public int getAutomaticStarRatingSessionLimit() {
            synchronized (_cly) {
                int sessionLimit = ModuleRatings.getAutomaticStarRatingSessionLimitInternal(_cly.countlyStore);
                L.i("[Ratings] Getting automatic star rating session limit: [" + sessionLimit + "]");
                return sessionLimit;
            }
        }
    }
}
package ly.count.android.sdk;
import android.util.Log;
public class ModuleLog {
    public interface LogCallback {
        void LogHappened(String logMessage, ModuleLog.LogLevel logLevel);
    }
    public enum LogLevel {Verbose, Debug, Info, Warning, Error}
    LogCallback logListener = null;
    HealthTracker healthTracker;
    int countWarnings = 0;
    int countErrors = 0;
    void SetListener(LogCallback logListener) {
        this.logListener = logListener;
    }
    void trackWarning() {
        if (healthTracker == null) {
            countWarnings++;
        } else {
            healthTracker.logWarning();
        }
    }
    void trackError() {
        if (healthTracker == null) {
            countErrors++;
        } else {
            healthTracker.logError();
        }
    }
    void setHealthChecker(HealthTracker healthTracker) {
        v("[ModuleLog] Setting healthTracker W:" + countWarnings + " E:" + countErrors);
        this.healthTracker = healthTracker;
        if (healthTracker == null) {
            return;
        }
        for (int a = 0; a < countErrors; a++) {
            healthTracker.logError();
        }
        for (int a = 0; a < countWarnings; a++) {
            healthTracker.logWarning();
        }
        countWarnings = 0;
        countErrors = 0;
    }
    public void v(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.v(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Verbose);
    }
    public void d(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.d(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Debug);
    }
    public void i(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.i(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Info);
    }
    public void w(String msg) {
        w(msg, null);
    }
    public void w(String msg, Throwable t) {
        trackWarning();
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.w(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Warning);
    }
    public void e(String msg) {
        e(msg, null);
    }
    public void e(String msg, Throwable t) {
        trackError();
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.e(Countly.TAG, msg, t);
        }
        informListener(msg, t, LogLevel.Error);
    }
    public boolean logEnabled() {
        return logListener != null || Countly.sharedInstance().isLoggingEnabled();
    }
    private void informListener(String msg, final Throwable t, final LogLevel level) {
        try {
            if (msg == null) {
                msg = "";
            }
            if (t != null) {
                msg += Log.getStackTraceString(t);
            }
            if (logListener != null) {
                logListener.LogHappened(msg, level);
            }
        } catch (Exception ex) {
            Log.e(Countly.TAG, "[ModuleLog] Failed to inform listener [" + ex.toString() + "]");
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Map;
interface RequestQueueProvider {
    void beginSession(boolean locationDisabled, @Nullable String locationCountryCode, @Nullable String locationCity, @Nullable String locationGpsCoordinates, @Nullable String locationIpAddress, @NonNull String preparedMetrics);
    void updateSession(final int duration);
    void changeDeviceId(String deviceId, String oldDeviceId);
    void tokenSession(String token, Countly.CountlyMessagingProvider provider);
    void endSession(final int duration);
    void sendLocation(boolean locationDisabled, String locationCountryCode, String locationCity, String locationGpsCoordinates, String locationIpAddress);
    void sendUserData(String userdata);
    void sendIndirectAttribution(@NonNull String attributionObj);
    void sendDirectAttributionLegacy(@NonNull String campaignID, @Nullable String userID);
    void sendDirectAttributionTest(@NonNull String attributionData);
    void sendCrashReport(@NonNull final String crashData, final boolean nonFatalCrash);
    void recordEvents(final String events);
    void sendConsentChanges(String formattedConsentChanges);
    void sendAPMCustomTrace(String key, Long durationMs, Long startMs, Long endMs, String customMetrics);
    void sendAPMNetworkTrace(String networkTraceKey, Long responseTimeMs, int responseCode, int requestPayloadSize, int responsePayloadSize, Long startMs, Long endMs);
    void sendAPMAppStart(long durationMs, Long startMs, Long endMs);
    void sendAPMScreenTime(boolean recordForegroundTime, long durationMs, Long startMs, Long endMs);
    void sendDirectRequest(@NonNull final Map<String, String> requestData);
    void enrollToKeys(@NonNull String[] keys);
    void exitForKeys(@NonNull String[] keys);
    //todo these should be moved or replaced in the future
    boolean queueContainsTemporaryIdItems();
    void tick();
    ConnectionProcessor createConnectionProcessor();
    String prepareRemoteConfigRequestLegacy(@Nullable String keysInclude, @Nullable String keysExclude, @NonNull String preparedMetrics);
    String prepareRemoteConfigRequest(@Nullable String keysInclude, @Nullable String keysExclude, @NonNull String preparedMetrics, boolean autoEnroll);
    String prepareFetchAllVariants(); // for fetching all A/B test variants
    String prepareFetchAllExperiments(); // for fetching all A/B test information (like with exp ID, definition etc, including variants)
    String prepareEnrollVariant(String key, String Variant); // for enrolling to an A/B test variant
    String prepareRatingWidgetRequest(String widgetId);
    String prepareFeedbackListRequest();
    String prepareServerConfigRequest();
    String prepareHealthCheckRequest(String preparedMetrics);
    String prepareFetchContents(int portraitWidth, int portraitHeight, int landscapeWidth, int landscapeHeight, String[] categories, String language);
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
public class UtilsNetworking {
    // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
    final private static char[] hexArray = "0123456789ABCDEF".toCharArray();
    protected static @NonNull String urlEncodeString(@NonNull String givenValue) {
        assert Utils.isNotNullOrEmpty(givenValue);
        String result = "";
        try {
            result = java.net.URLEncoder.encode(givenValue, "UTF-8");
        } catch (UnsupportedEncodingException ignored) {
            // should never happen because Android guarantees UTF-8 support
        }
        return result;
    }
    protected static @NonNull String encodedArrayBuilder(@NonNull String[] args) {
        assert args != null && args.length > 0;
        StringBuilder encodedUrlBuilder = new StringBuilder();
        encodedUrlBuilder.append("[");
        for (int i = 0; i < args.length; i++) {
            encodedUrlBuilder.append('"').append(args[i]).append('"');
            if (i < args.length - 1) {
                encodedUrlBuilder.append(", ");
            }
        }
        encodedUrlBuilder.append("]");
        return encodedUrlBuilder.toString();
    }
    protected static @NonNull String urlDecodeString(@NonNull String givenValue) {
        assert givenValue != null;
        String decodedResult = "";
        try {
            decodedResult = java.net.URLDecoder.decode(givenValue, "UTF-8");
        } catch (UnsupportedEncodingException ignored) {
            // should never happen because Android guarantees UTF-8 support
        }
        return decodedResult;
    }
    protected static @NonNull String sha256Hash(@NonNull String toHash) {
        assert toHash != null;
        String hash;
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] bytes = toHash.getBytes("UTF-8");
            digest.update(bytes, 0, bytes.length);
            bytes = digest.digest();
            // This is ~55x faster than looping and String.formating()
            hash = bytesToHex(bytes);
        } catch (Throwable e) {
            hash = "";
            Countly.sharedInstance().L.e("Cannot tamper-protect params", e);
        }
        return hash;
    }
    /**
     * Get hexadecimal string representation of a byte array
     *
     * @param bytes array of bytes to convert
     * @return hex string of the byte array in lower case
     */
    public static @NonNull String bytesToHex(@NonNull byte[] bytes) {
        assert bytes != null && bytes.length > 0;
        char[] hexChars = new char[bytes.length * 2];
        for (int j = 0; j < bytes.length; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = hexArray[v >>> 4];
            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
        }
        return new String(hexChars).toLowerCase();
    }
    /**
     * Utility method for testing validity of a URL.
     */
    @SuppressWarnings("ConstantConditions")
    static boolean isValidURL(@Nullable final String urlStr) {
        boolean validURL = false;
        if (urlStr != null && urlStr.length() > 0) {
            try {
                new URL(urlStr);
                validURL = true;
            } catch (MalformedURLException e) {
                validURL = false;
            }
        }
        return validURL;
    }
}
package ly.count.android.sdk;
import android.text.TextUtils;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import ly.count.android.sdk.internal.RemoteConfigHelper;
import ly.count.android.sdk.internal.RemoteConfigValueStore;
import org.json.JSONException;
import org.json.JSONObject;
import static ly.count.android.sdk.ModuleConsent.ConsentChangeSource.ChangeConsentCall;
public class ModuleRemoteConfig extends ModuleBase {
    ImmediateRequestGenerator iRGenerator;
    boolean updateRemoteConfigAfterIdChange = false;
    Map<String, String[]> variantContainer = new HashMap<>(); // Stores the fetched A/B test variants
    Map<String, ExperimentInformation> experimentContainer = new HashMap<>(); // Stores the fetched A/B test information (includes exp ID, description etc.)
    RemoteConfig remoteConfigInterface = null;
    //if set to true, it will automatically download remote configs on module startup
    boolean automaticDownloadTriggersEnabled;
    // if set to true we should add 'oi=1' to our RC download call
    boolean autoEnrollEnabled;
    boolean remoteConfigValuesShouldBeCached = false;
    List<RCDownloadCallback> downloadCallbacks = new ArrayList<>(2);
    public final static String variantObjectNameKey = "name";
    @Nullable
    Map<String, String> metricOverride = null;
    ModuleRemoteConfig(Countly cly, final CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleRemoteConfig] Initialising");
        metricOverride = config.metricOverride;
        iRGenerator = config.immediateRequestGenerator;
        L.d("[ModuleRemoteConfig] Setting if remote config Automatic triggers enabled, " + config.enableRemoteConfigAutomaticDownloadTriggers + ", caching enabled: " + config.enableRemoteConfigValueCaching + ", auto enroll enabled: " + config.enableAutoEnrollFlag);
        automaticDownloadTriggersEnabled = config.enableRemoteConfigAutomaticDownloadTriggers;
        remoteConfigValuesShouldBeCached = config.enableRemoteConfigValueCaching;
        autoEnrollEnabled = config.enableAutoEnrollFlag;
        downloadCallbacks.addAll(config.remoteConfigGlobalCallbackList);
        if (config.remoteConfigCallbackLegacy != null) {
            downloadCallbacks.add((downloadResult, error, fullValueUpdate, downloadedValues) -> config.remoteConfigCallbackLegacy.callback(error));
        }
        remoteConfigInterface = new RemoteConfig();
    }
    /**
     * Internal call for updating remote config keys
     *
     * @param keysOnly set if these are the only keys to update
     * @param keysExcept set if these keys should be ignored from the update
     * @param devProvidedCallback dev provided callback that is called after the update is done
     */
    void updateRemoteConfigValues(@Nullable final String[] keysOnly, @Nullable final String[] keysExcept, final boolean useLegacyAPI, @Nullable final RCDownloadCallback devProvidedCallback) {
        L.d("[ModuleRemoteConfig] Updating remote config values, legacyAPI:[" + useLegacyAPI + "]");
        String[] preparedKeys = RemoteConfigHelper.prepareKeysIncludeExclude(keysOnly, keysExcept, L);
        boolean fullUpdate = (preparedKeys[0] == null || preparedKeys[0].length() == 0) && (preparedKeys[1] == null || preparedKeys[1].length() == 0);
        try {
            // checks
            if (deviceIdProvider.getDeviceId() == null) {
                //device ID is null, abort
                L.d("[ModuleRemoteConfig] RemoteConfig value update was aborted, deviceID is null");
                NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Can't complete call, device ID is null", fullUpdate, null);
                return;
            }
            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems()) {
                //temporary id mode enabled, abort
                L.d("[ModuleRemoteConfig] RemoteConfig value update was aborted, temporary device ID mode is set");
                NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Can't complete call, temporary device ID is set", fullUpdate, null);
                return;
            }
            //prepare metrics and request data
            String preparedMetrics = deviceInfo.getMetrics(_cly.context_, metricOverride, L);
            String requestData;
            if (useLegacyAPI) {
                requestData = requestQueueProvider.prepareRemoteConfigRequestLegacy(preparedKeys[0], preparedKeys[1], preparedMetrics);
            } else {
                requestData = requestQueueProvider.prepareRemoteConfigRequest(preparedKeys[0], preparedKeys[1], preparedMetrics, autoEnrollEnabled);
            }
            L.d("[ModuleRemoteConfig] RemoteConfig requestData:[" + requestData + "]");
            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, checkResponse -> {
                L.d("[ModuleRemoteConfig] Processing remote config received response, received response is null:[" + (checkResponse == null) + "]");
                if (checkResponse == null) {
                    NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Encountered problem while trying to reach the server, possibly no internet connection", fullUpdate, null);
                    return;
                }
                String error = null;
                Map<String, RCData> newRC = RemoteConfigHelper.DownloadedValuesIntoMap(checkResponse);
                try {
                    boolean clearOldValues = keysExcept == null && keysOnly == null;
                    mergeCheckResponseIntoCurrentValues(clearOldValues, newRC);
                } catch (Exception ex) {
                    L.e("[ModuleRemoteConfig] updateRemoteConfigValues - execute, Encountered internal issue while trying to download remote config information from the server, [" + ex.toString() + "]");
                    error = "Encountered internal issue while trying to download remote config information from the server, [" + ex.toString() + "]";
                }
                NotifyDownloadCallbacks(devProvidedCallback, error == null ? RequestResult.Success : RequestResult.Error, error, fullUpdate, newRC);
            }, L);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] Encountered internal error while trying to perform a remote config update. " + ex.toString());
            NotifyDownloadCallbacks(devProvidedCallback, RequestResult.Error, "Encountered internal error while trying to perform a remote config update", fullUpdate, null);
        }
    }
    /**
     * Internal function to form and send a request to enroll user for given keys
     *
     * @param keys
     */
    void enrollIntoABTestsForKeysInternal(@NonNull String[] keys) {
        L.d("[ModuleRemoteConfig] Enrolling user for the given keys:" + keys);
        if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {
            L.d("[ModuleRemoteConfig] Enrolling user was aborted, temporary device ID mode is set or device ID is null.");
            return;
        }
        requestQueueProvider.enrollToKeys(keys);
    }
    /**
     * Internal function to form and send the request to remove user from A/B testes for given keys
     *
     * @param keys
     */
    void exitABTestsForKeysInternal(@NonNull String[] keys) {
        L.d("[ModuleRemoteConfig] Removing user for the tests with given keys:" + keys);
        if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {
            L.d("[ModuleRemoteConfig] Removing user from tests was aborted, temporary device ID mode is set or device ID is null.");
            return;
        }
        requestQueueProvider.exitForKeys(keys);
    }
    /**
     * Internal call for fetching all variants of A/B test experiments
     * There are 2 endpoints that can be used:
     *
     * @param callback called after the fetch is done
     * @param shouldFetchExperimentInfo if true this call would fetch experiment information including the variants
     */
    void testingFetchVariantInformationInternal(@NonNull final RCVariantCallback callback, final boolean shouldFetchExperimentInfo) {
        try {
            L.d("[ModuleRemoteConfig] Fetching all A/B test variants/info");
            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {
                L.d("[ModuleRemoteConfig] Fetching all A/B test variants was aborted, temporary device ID mode is set or device ID is null.");
                callback.callback(RequestResult.Error, "Temporary device ID mode is set or device ID is null.");
                return;
            }
            // prepare request data
            String requestData = shouldFetchExperimentInfo ? requestQueueProvider.prepareFetchAllExperiments() : requestQueueProvider.prepareFetchAllVariants();
            L.d("[ModuleRemoteConfig] Fetching all A/B test variants/info requestData:[" + requestData + "]");
            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, checkResponse -> {
                L.d("[ModuleRemoteConfig] Processing Fetching all A/B test variants/info received response, received response is null:[" + (checkResponse == null) + "]");
                if (checkResponse == null) {
                    callback.callback(RequestResult.NetworkIssue, "Encountered problem while trying to reach the server, possibly no internet connection");
                    return;
                }
                if (shouldFetchExperimentInfo) {
                    experimentContainer = RemoteConfigHelper.convertExperimentInfoJsonToMap(checkResponse, L);
                } else {
                    variantContainer = RemoteConfigHelper.convertVariantsJsonToMap(checkResponse, L);
                }
                callback.callback(RequestResult.Success, null);
            }, L);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] Encountered internal error while trying to fetch all A/B test variants/info. " + ex.toString());
            callback.callback(RequestResult.Error, "Encountered internal error while trying to fetch all A/B test variants/info.");
        }
    }
    void testingEnrollIntoVariantInternal(@NonNull final String key, @NonNull final String variant, @NonNull final RCVariantCallback callback) {
        try {
            L.d("[ModuleRemoteConfig] Enrolling A/B test variants, Key/Variant pairs:[" + key + "][" + variant + "]");
            if (deviceIdProvider.isTemporaryIdEnabled() || requestQueueProvider.queueContainsTemporaryIdItems() || deviceIdProvider.getDeviceId() == null) {
                L.d("[ModuleRemoteConfig] Enrolling A/B test variants was aborted, temporary device ID mode is set or device ID is null.");
                callback.callback(RequestResult.Error, "Temporary device ID mode is set or device ID is null.");
                return;
            }
            // check Key and Variant
            if (TextUtils.isEmpty(key) || TextUtils.isEmpty(variant)) {
                L.w("[ModuleRemoteConfig] Enrolling A/B test variants, Key/Variant pair is invalid. Aborting.");
                callback.callback(RequestResult.Error, "Provided key/variant pair is invalid.");
                return;
            }
            // prepare request data
            String requestData = requestQueueProvider.prepareEnrollVariant(key, variant);
            L.d("[ModuleRemoteConfig] Enrolling A/B test variants requestData:[" + requestData + "]");
            ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
            final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
            iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/i", cp, false, networkingIsEnabled, checkResponse -> {
                L.d("[ModuleRemoteConfig] Processing Fetching all A/B test variants received response, received response is null:[" + (checkResponse == null) + "]");
                if (checkResponse == null) {
                    callback.callback(RequestResult.NetworkIssue, "Encountered problem while trying to reach the server, possibly no internet connection");
                    return;
                }
                try {
                    if (!isResponseValid(checkResponse)) {
                        callback.callback(RequestResult.NetworkIssue, "Bad response from the server:" + checkResponse.toString());
                        return;
                    }
                    RCAutomaticDownloadTrigger(true);//todo afterwards cache only that one key
                    callback.callback(RequestResult.Success, null);
                } catch (Exception ex) {
                    L.e("[ModuleRemoteConfig] testingEnrollIntoVariantInternal - execute, Encountered internal issue while trying to enroll to the variant, [" + ex.toString() + "]");
                    callback.callback(RequestResult.Error, "Encountered internal error while trying to take care of the A/B test variant enrolment.");
                }
            }, L);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] Encountered internal error while trying to enroll A/B test variants. " + ex.toString());
            callback.callback(RequestResult.Error, "Encountered internal error while trying to enroll A/B test variants.");
        }
    }
    /**
     * Merge the values acquired from the server into the current values.
     * Clear if needed.
     *
     * @throws Exception it throws an exception so that it is escalated upwards
     */
    void mergeCheckResponseIntoCurrentValues(boolean clearOldValues, @NonNull Map<String, RCData> newRC) {
        //todo iterate over all response values and print a summary of the returned keys + ideally a summary of their payload.
        //merge the new values into the current ones
        RemoteConfigValueStore rcvs = loadConfig();
        rcvs.mergeValues(newRC, clearOldValues);
        L.d("[ModuleRemoteConfig] Finished remote config processing, starting saving");
        saveConfig(rcvs);
        L.d("[ModuleRemoteConfig] Finished remote config saving");
    }
    /**
     * Checks and evaluates the response from the server
     *
     * @param responseJson - JSONObject response
     * @return
     */
    boolean isResponseValid(@NonNull JSONObject responseJson) {
        boolean result = false;
        try {
            if (responseJson.get("result").equals("Success")) {
                result = true;
            }
        } catch (JSONException e) {
            L.e("[ModuleRemoteConfig] isResponseValid, encountered issue, " + e);
            return false;
        }
        return result;
    }
    RCData getRCValue(@NonNull String key) {
        try {
            RemoteConfigValueStore rcvs = loadConfig();
            return rcvs.getValue(key);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] getValue, Call failed:[" + ex.toString() + "]");
            return new RCData(null, true);
        }
    }
    Object getRCValueLegacy(@NonNull String key) {
        try {
            RemoteConfigValueStore rcvs = loadConfig();
            return rcvs.getValueLegacy(key);
        } catch (Exception ex) {
            L.e("[ModuleRemoteConfig] getValueLegacy, Call failed:[" + ex.toString() + "]");
            return null;
        }
    }
    void saveConfig(@NonNull RemoteConfigValueStore rcvs) {
        storageProvider.setRemoteConfigValues(rcvs.dataToString());
    }
    /**
     * @return
     * @throws Exception For some reason this might be throwing an exception
     */
    @NonNull RemoteConfigValueStore loadConfig() {
        String rcvsString = storageProvider.getRemoteConfigValues();
        //noinspection UnnecessaryLocalVariable
        RemoteConfigValueStore rcvs = RemoteConfigValueStore.dataFromString(rcvsString, remoteConfigValuesShouldBeCached);
        return rcvs;
    }
    void clearValueStoreInternal() {
        storageProvider.setRemoteConfigValues("");
    }
    @NonNull Map<String, Object> getAllRemoteConfigValuesInternalLegacy() {
        try {
            RemoteConfigValueStore rcvs = loadConfig();
            return rcvs.getAllValuesLegacy();
        } catch (Exception ex) {
            Countly.sharedInstance().L.e("[ModuleRemoteConfig] getAllRemoteConfigValuesInternal, Call failed:[" + ex.toString() + "]");
            return new HashMap<>();
        }
    }
    @NonNull Map<String, RCData> getAllRemoteConfigValuesInternal() {
        try {
            RemoteConfigValueStore rcvs = loadConfig();
            return rcvs.getAllValues();
        } catch (Exception ex) {
            Countly.sharedInstance().L.e("[ModuleRemoteConfig] getAllRemoteConfigValuesInternal, Call failed:[" + ex.toString() + "]");
            return new HashMap<>();
        }
    }
    /**
     * Gets all AB testing variants stored in the memory
     *
     * @return
     */
    @NonNull Map<String, String[]> testingGetAllVariantsInternal() {
        return variantContainer;
    }
    /**
     * Get all variants for a given key if exists. Else returns an empty array.
     *
     * @param key
     * @return
     */
    @Nullable String[] testingGetVariantsForKeyInternal(@NonNull String key) {
        String[] variantResponse = null;
        if (variantContainer.containsKey(key)) {
            variantResponse = variantContainer.get(key);
        }
        return variantResponse;
    }
    void clearAndDownloadAfterIdChange() {
        L.v("[RemoteConfig] Clearing remote config values and preparing to download after ID update");
        CacheOrClearRCValuesIfNeeded();
        if (automaticDownloadTriggersEnabled && consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
            updateRemoteConfigAfterIdChange = true;
        }
    }
    void CacheOrClearRCValuesIfNeeded() {
        L.v("[RemoteConfig] CacheOrClearRCValuesIfNeeded, cacheclearing values");
        RemoteConfigValueStore rc = loadConfig();
        rc.cacheClearValues();
        saveConfig(rc);
    }
    void NotifyDownloadCallbacks(RCDownloadCallback devProvidedCallback, RequestResult requestResult, String message, boolean fullUpdate, Map<String, RCData> downloadedValues) {
        for (RCDownloadCallback callback : downloadCallbacks) {
            callback.callback(requestResult, message, fullUpdate, downloadedValues);
        }
        if (devProvidedCallback != null) {
            devProvidedCallback.callback(requestResult, message, fullUpdate, downloadedValues);
        }
    }
    void RCAutomaticDownloadTrigger(boolean cacheClearOldValues) {
        if (cacheClearOldValues) {
            CacheOrClearRCValuesIfNeeded();
        }
        if (automaticDownloadTriggersEnabled && consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
            L.d("[RemoteConfig] Automatically updating remote config values");
            updateRemoteConfigValues(null, null, false, null);
        } else {
            L.v("[RemoteConfig] Automatic RC update trigger skipped");
        }
    }
    @Override
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.remoteConfig) && changeSource == ChangeConsentCall) {
            if (newConsent) {
                L.d("[RemoteConfig] onConsentChanged, Consent given, will update RC values");
                //if consent was just given trigger automatic RC download if needed
                RCAutomaticDownloadTrigger(false);
            }
        }
    }
    @Override
    void deviceIdChanged(boolean withoutMerge) {
        L.v("[RemoteConfig] Device ID changed will update values: [" + updateRemoteConfigAfterIdChange + "]");
        if (updateRemoteConfigAfterIdChange) {
            updateRemoteConfigAfterIdChange = false;
            RCAutomaticDownloadTrigger(true);
        }
    }
    @Override
    public void initFinished(@NonNull CountlyConfig config) {
        //update remote config_ values if automatic update is enabled and we are not in temporary id mode
        if (!deviceIdProvider.isTemporaryIdEnabled()) {
            RCAutomaticDownloadTrigger(false);
        }
    }
    @Override
    public void halt() {
        remoteConfigInterface = null;
    }
    // ==================================================================
    // ==================================================================
    // INTERFACE
    // ==================================================================
    // ==================================================================
    public class RemoteConfig {
        /**
         * Clear all stored remote config_ values
         *
         * @deprecated Use "clearAll"
         */
        public void clearStoredValues() {
            synchronized (_cly) {
                L.i("[RemoteConfig] clearStoredValues");
                clearValueStoreInternal();
            }
        }
        /**
         * @return
         * @deprecated You should use "getValues"
         */
        public Map<String, Object> getAllValues() {
            synchronized (_cly) {
                L.i("[RemoteConfig] getAllValues");
                return getAllRemoteConfigValuesInternalLegacy();
            }
        }
        /**
         * Get the stored value for the provided remote config_ key
         *
         * @param key
         * @return
         * @deprecated You should use "getValue"
         */
        public Object getValueForKey(String key) {
            synchronized (_cly) {
                L.i("[RemoteConfig] remoteConfigValueForKey, " + key);
                return getRCValueLegacy(key);
            }
        }
        /**
         * Manual remote config update call. Will update all keys except the ones provided
         *
         * @param keysToExclude
         * @param callback
         * @deprecated You should use "downloadOmittingKeys"
         */
        public void updateExceptKeys(String[] keysToExclude, RemoteConfigCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] updateExceptKeys");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback("No consent given");
                    }
                    return;
                }
                if (keysToExclude == null) {
                    L.w("[RemoteConfig] updateExceptKeys passed 'keys to ignore' array is null");
                }
                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    if (callback != null) {
                        callback.callback(error);
                    }
                };
                updateRemoteConfigValues(null, keysToExclude, true, innerCall);
            }
        }
        /**
         * Manual remote config update call. Will only update the keys provided.
         *
         * @param keysToInclude
         * @param callback
         * @deprecated You should use "downloadSpecificKeys"
         */
        public void updateForKeysOnly(String[] keysToInclude, RemoteConfigCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] updateForKeysOnly");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback("No consent given");
                    }
                    return;
                }
                if (keysToInclude == null) {
                    L.w("[RemoteConfig] updateForKeysOnly passed 'keys to include' array is null");
                }
                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    if (callback != null) {
                        callback.callback(error);
                    }
                };
                updateRemoteConfigValues(keysToInclude, null, true, innerCall);
            }
        }
        /**
         * Manually update remote config values
         *
         * @param callback
         * @deprecated You should use "downloadAllKeys"
         */
        public void update(RemoteConfigCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] update");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback("No consent given");
                    }
                    return;
                }
                RCDownloadCallback innerCall = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    if (callback != null) {
                        callback.callback(error);
                    }
                };
                updateRemoteConfigValues(null, null, true, innerCall);
            }
        }
        /**
         * Manual remote config call that will initiate a download of all except the given remote config keys.
         * If no keys are provided then it will download all available RC values
         *
         * @param keysToOmit A list of keys that need to be downloaded
         * @param callback This is called when the operation concludes
         */
        public void downloadOmittingKeys(@Nullable String[] keysToOmit, @Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] downloadOmittingKeys");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback(RequestResult.Error, null, false, null);
                    }
                    return;
                }
                if (keysToOmit == null) {
                    L.w("[RemoteConfig] downloadOmittingKeys passed 'keys to ignore' array is null");
                }
                if (callback == null) {
                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    };
                }
                updateRemoteConfigValues(null, keysToOmit, false, callback);
            }
        }
        /**
         * Manual remote config call that will initiate a download of only the given remote config keys.
         * If no keys are provided then it will download all available RC values
         *
         * @param keysToInclude Keys for which the RC should be initialized
         * @param callback This is called when the operation concludes
         */
        public void downloadSpecificKeys(@Nullable String[] keysToInclude, @Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] downloadSpecificKeys");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback(RequestResult.Error, null, false, null);
                    }
                    return;
                }
                if (keysToInclude == null) {
                    L.w("[RemoteConfig] downloadSpecificKeys passed 'keys to include' array is null");
                }
                if (callback == null) {
                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    };
                }
                updateRemoteConfigValues(keysToInclude, null, false, callback);
            }
        }
        /**
         * Manual remote config call that will initiate a download of all available remote config keys.
         *
         * @param callback This is called when the operation concludes
         */
        public void downloadAllKeys(@Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] downloadAllKeys");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    if (callback != null) {
                        callback.callback(RequestResult.Error, null, true, null);
                    }
                    return;
                }
                if (callback == null) {
                    callback = (downloadResult, error, fullValueUpdate, downloadedValues) -> {
                    };
                }
                updateRemoteConfigValues(null, null, false, callback);
            }
        }
        /**
         * Returns all available remote config values
         *
         * @return The available RC values
         */
        public @NonNull Map<String, RCData> getValues() {
            synchronized (_cly) {
                L.i("[RemoteConfig] getValues");
                return getAllRemoteConfigValuesInternal();
            }
        }
        /**
         * Returns all available remote config values and enrolls to A/B tests for those values
         *
         * @return The available RC values
         */
        public @NonNull Map<String, RCData> getAllValuesAndEnroll() {
            synchronized (_cly) {
                L.i("[RemoteConfig] getAllValuesAndEnroll");
                Map<String, RCData> values = getAllRemoteConfigValuesInternal();
                if (values.isEmpty()) {
                    L.i("[RemoteConfig] getAllValuesAndEnroll, No value to enroll");
                } else {
                    // assuming the values is not empty enroll for the keys
                    Set<String> setOfKeys = values.keySet();
                    String[] arrayOfKeys = new String[setOfKeys.size()];
                    // set to array
                    int i = 0;
                    for (String key : setOfKeys) {
                        arrayOfKeys[i++] = key;
                    }
                    // enroll
                    enrollIntoABTestsForKeys(arrayOfKeys);
                }
                return values;
            }
        }
        /**
         * Return the remote config value for a specific key
         *
         * @param key Key for which the remote config value needs to be returned
         * @return The returned value. If no value existed for the key then the inner object (value) will be returned as "null"
         */
        public @NonNull RCData getValue(final @Nullable String key) {
            synchronized (_cly) {
                L.i("[RemoteConfig] getValue, key:[" + key + "]");
                if (key == null || key.equals("")) {
                    L.i("[RemoteConfig] getValue, A valid key should be provided to get its value.");
                    return new RCData(null, true);
                }
                return getRCValue(key);
            }
        }
        /**
         * Returns the remote config value for a specific key and enrolls to A/B tests for it
         *
         * @param key Key for which the remote config value needs to be returned
         * @return The returned value. If no value existed for the key then the inner object will be returned as "null"
         */
        public @NonNull RCData getValueAndEnroll(@Nullable String key) {
            synchronized (_cly) {
                L.i("[RemoteConfig] getValueAndEnroll, key:[" + key + "]");
                if (key == null || key.equals("")) {
                    L.i("[RemoteConfig] getValueAndEnroll, A valid key should be provided to get its value.");
                    return new RCData(null, true);
                }
                RCData data = getRCValue(key);
                if (data.value == null) {
                    L.i("[RemoteConfig] getValueAndEnroll, No value to enroll");
                } else {
                    // assuming value is not null enroll to key
                    String[] arrayOfKeys = { key };
                    enrollIntoABTestsForKeys(arrayOfKeys);
                }
                return data;
            }
        }
        /**
         * Enrolls user to AB tests of the given keys.
         *
         * @param keys - String array of keys (parameters)
         */
        public void enrollIntoABTestsForKeys(@Nullable String[] keys) {
            synchronized (_cly) {
                L.i("[RemoteConfig] enrollIntoABTestsForKeys");
                if (keys == null || keys.length == 0) {
                    L.w("[RemoteConfig] enrollIntoABTestsForKeys, A key should be provided to enroll the user.");
                    return;
                }
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                enrollIntoABTestsForKeysInternal(keys);
            }
        }
        /**
         * Removes user from A/B tests for the given keys. If no key provided would remove the user from all tests.
         *
         * @param keys - String array of keys (parameters)
         */
        public void exitABTestsForKeys(@Nullable String[] keys) {
            synchronized (_cly) {
                L.i("[RemoteConfig] exitABTestsForKeys");
                if (keys == null) {
                    keys = new String[0];
                }
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                exitABTestsForKeysInternal(keys);
            }
        }
        /**
         * Register a global callback for when download operations have finished
         *
         * @param callback The callback that should be added
         */
        public void registerDownloadCallback(@Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] registerDownloadCallback");
                downloadCallbacks.add(callback);
            }
        }
        /**
         * Unregister a global download callback
         *
         * @param callback The callback that should be removed
         */
        public void removeDownloadCallback(@Nullable RCDownloadCallback callback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] removeDownloadCallback");
                downloadCallbacks.remove(callback);
            }
        }
        /**
         * Clear all stored remote config values.
         */
        public void clearAll() {
            synchronized (_cly) {
                L.i("[RemoteConfig] clearAll");
                clearStoredValues();
            }
        }
        /**
         * Returns all variant information as a Map<String, String[]>
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @return Return the information of all available variants
         */
        public @NonNull Map<String, String[]> testingGetAllVariants() {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingGetAllVariants");
                return testingGetAllVariantsInternal();
            }
        }
        /**
         * Returns all experiment information as a Map<String, ExperimentInformation>
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @return Return the information of all available variants
         */
        public @NonNull Map<String, ExperimentInformation> testingGetAllExperimentInfo() {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingGetAllExperimentInfo");
                return experimentContainer;
            }
        }
        /**
         * Returns variant information for a key as a String[]
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @param key - key value to get variant information for
         * @return If returns the stored variants for the given key. Returns "null" if there are no variants for that key.
         */
        public @Nullable String[] testingGetVariantsForKey(@Nullable String key) {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingGetVariantsForKey");
                if (key == null) {
                    L.i("[RemoteConfig] testingGetVariantsForKey, provided variant key can not be null");
                    return null;
                }
                return testingGetVariantsForKeyInternal(key);
            }
        }
        /**
         * Download all variants of A/B testing experiments
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @param completionCallback this callback will be called when the network request finished
         */
        public void testingDownloadVariantInformation(@Nullable RCVariantCallback completionCallback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingFetchVariantInformation");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                if (completionCallback == null) {
                    completionCallback = (result, error) -> {
                    };
                }
                testingFetchVariantInformationInternal(completionCallback, false);
            }
        }
        /**
         * Download all A/B testing experiments information
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @param completionCallback this callback will be called when the network request finished
         */
        public void testingDownloadExperimentInformation(@Nullable RCVariantCallback completionCallback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingDownloadExperimentInformation");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                if (completionCallback == null) {
                    completionCallback = (result, error) -> {
                    };
                }
                testingFetchVariantInformationInternal(completionCallback, true);
            }
        }
        /**
         * Enrolls user for a specific variant of A/B testing experiment
         *
         * This call is not meant for production. It should only be used to facilitate testing of A/B test experiments.
         *
         * @param keyName - key value retrieved from the fetched variants
         * @param variantName - name of the variant for the key to enroll
         * @param completionCallback
         */
        public void testingEnrollIntoVariant(@Nullable String keyName, String variantName, @Nullable RCVariantCallback completionCallback) {
            synchronized (_cly) {
                L.i("[RemoteConfig] testingEnrollIntoVariant");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
                    return;
                }
                if (keyName == null || variantName == null) {
                    L.w("[RemoteConfig] testEnrollIntoVariant, passed key or variant is null. Aborting.");
                    return;
                }
                if (completionCallback == null) {
                    completionCallback = (result, error) -> {
                    };
                }
                testingEnrollIntoVariantInternal(keyName, variantName, completionCallback);
            }
        }
    }
}
package ly.count.android.sdk;
import android.app.UiModeManager;
import android.content.Context;
import android.content.res.Configuration;
import android.os.Build;
import android.util.Base64;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.SecureRandom;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import static android.content.Context.UI_MODE_SERVICE;
public class Utils {
    private static final ExecutorService bg = Executors.newSingleThreadExecutor();
    public static Future<?> runInBackground(Runnable runnable) {
        return bg.submit(runnable);
    }
    public static <T> Future<T> runInBackground(Callable<T> runnable) {
        return bg.submit(runnable);
    }
    /**
     * Joins all the strings in the specified collection into a single string with the specified delimiter.
     * Used in countlyStore
     */
    static String joinCountlyStore(@NonNull final List<String> collection, @NonNull final String delimiter) {
        int targetCapacity = collection.size() == 0 ? 0 : collection.size() * collection.get(0).length();
        final StringBuilder builder = new StringBuilder(targetCapacity);
        int i = 0;
        for (String s : collection) {
            builder.append(s);
            if (++i < collection.size()) {
                builder.append(delimiter);
            }
        }
        return builder.toString();
    }
    static String joinCountlyStore_reworked(@NonNull final List<String> collection, @NonNull final String delimiter) {
        return joinCountlyStore_reworked(collection, delimiter, 0);
    }
    /**
     * Joins all the strings in the specified collection into a single string with the specified delimiter.
     * Used in countlyStore
     * todo: Add tests for this
     */
    static String joinCountlyStore_reworked(@NonNull final List<String> collection, @NonNull final String delimiter, int startingEntry) {
        int cSize = collection.size();
        int targetCapacity;
        if (cSize == 0) {
            targetCapacity = 0;
        } else if (cSize == 1) {
            targetCapacity = cSize * collection.get(0).length();
        } else {
            targetCapacity = cSize * collection.get(0).length() + (cSize * delimiter.length());
        }
        final StringBuilder builder = new StringBuilder(targetCapacity);
        int i = startingEntry;
        for (int a = startingEntry; a < cSize; a++) {
            builder.append(collection.get(a));
            if (++i < cSize) {
                builder.append(delimiter);
            }
        }
        return builder.toString();
    }
    static String joinCountlyStoreArray_reworked(@NonNull final String[] collection, @NonNull final String delimiter) {
        return joinCountlyStoreArray_reworked(collection, delimiter, 0);
    }
    /**
     * todo: Add tests for this
     *
     * @param collection
     * @param delimiter
     * @param startingEntry
     * @return
     */
    static String joinCountlyStoreArray_reworked(@NonNull final String[] collection, @NonNull final String delimiter, int startingEntry) {
        int cSize = collection.length;
        int targetCapacity;
        if (cSize == 0) {
            targetCapacity = 0;
        } else if (cSize == 1) {
            targetCapacity = cSize * collection[0].length();
        } else {
            targetCapacity = cSize * collection[0].length() + (cSize * delimiter.length());
        }
        final StringBuilder builder = new StringBuilder(targetCapacity);
        int i = startingEntry;
        for (int a = startingEntry; a < cSize; a++) {
            builder.append(collection[a]);
            if (++i < cSize) {
                builder.append(delimiter);
            }
        }
        return builder.toString();
    }
    /**
     * StringUtils.isEmpty replacement.
     *
     * @param str string to check
     * @return true if null or empty string, false otherwise
     */
    public static boolean isNullOrEmpty(String str) {
        return str == null || "".equals(str);
    }
    /**
     * StringUtils.isNotEmpty replacement.
     *
     * @param str string to check
     * @return false if null or empty string, true otherwise
     */
    public static boolean isNotNullOrEmpty(String str) {
        return !isNullOrEmpty(str);
    }
    /**
     * Returns true if the version you are checking is at or below the build version
     *
     * @param version version to check
     * @return true if the version you are checking is at or below the build version
     * @deprecated This method is deprecated and will be removed in the future
     */
    @androidx.annotation.ChecksSdkIntAtLeast(parameter = 0)
    public static boolean API(int version) {
        return Build.VERSION.SDK_INT >= version;
    }
    /**
     * Read stream into a byte array
     *
     * @param stream input to read
     * @return stream contents or {@code null} in case of error
     */
    public static byte[] readStream(InputStream stream) {
        if (stream == null) {
            return null;
        }
        ByteArrayOutputStream bytes = new ByteArrayOutputStream();
        try {
            byte[] buffer = new byte[1024];
            int len = 0;
            while ((len = stream.read(buffer)) != -1) {
                bytes.write(buffer, 0, len);
            }
            return bytes.toByteArray();
        } catch (IOException e) {
            Countly.sharedInstance().L.e("Couldn't read stream: " + e);
            return null;
        } finally {
            try {
                bytes.close();
                stream.close();
            } catch (Throwable ignored) {
            }
        }
    }
    static String inputStreamToString(InputStream stream) {
        BufferedReader br = new BufferedReader(new InputStreamReader(stream));
        StringBuilder sbRes = new StringBuilder();
        while (true) {
            String streamLine;
            try {
                streamLine = br.readLine();
            } catch (IOException e) {
                Countly.sharedInstance().L.e("", e);
                break;
            }
            if (streamLine == null) {
                break;
            }
            if (sbRes.length() > 0) {
                //if it's not empty then there has been a previous line
                sbRes.append("\n");
            }
            sbRes.append(streamLine);
        }
        return sbRes.toString();
    }
    /**
     * Creates a crypto-safe SHA-256 hashed random value
     *
     * @return returns a random string value
     */
    public static String safeRandomVal() {
        long timestamp = System.currentTimeMillis();
        SecureRandom random = new SecureRandom();
        byte[] value = new byte[6];
        random.nextBytes(value);
        String b64Value = Base64.encodeToString(value, Base64.NO_WRAP);
        return b64Value + timestamp;
    }
    //https://stackoverflow.com/a/40310535
    /**
     * Used for detecting if current device is a tablet of phone
     */
    static boolean isDeviceTablet(Context context) {
        if (context == null) {
            return false;
        }
        return (context.getResources().getConfiguration().screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) >= Configuration.SCREENLAYOUT_SIZE_LARGE;
    }
    /**
     * Used for detecting if device is a tv
     *
     * @return
     */
    @SuppressWarnings("RedundantIfStatement")
    static boolean isDeviceTv(Context context) {
        if (context == null) {
            return false;
        }
        UiModeManager uiModeManager = (UiModeManager) context.getSystemService(UI_MODE_SERVICE);
        if (uiModeManager == null) {
            return false;
        }
        if (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) {
            return true;
        } else {
            return false;
        }
    }
    /**
     * This function checks if a request is older than an accepted duration.
     * As the expected duration you should use the developer provided 'dropAgeHours'
     *
     * @param request request string to check
     * @param dropAgeHours oldness threshold (in hours)
     * @return true if old, false if not
     */
    public static boolean isRequestTooOld(@NonNull final String request, final int dropAgeHours, @NonNull final String messagePrefix, final @NonNull ModuleLog L) {
        if (dropAgeHours <= 0) {
            L.v(messagePrefix + " isRequestTooOld, No request drop age set. Request will bypass age checks");
            return false;
        }
        // starting index
        int timestampStartIndex = request.indexOf("&timestamp=");
        if (timestampStartIndex == -1) {
            L.w(messagePrefix + " isRequestTooOld, No timestamp in request");
            return false;
        }
        try {
            // starting index +11 gets to the end of the tag and then +13 to get timestamp
            long requestTimestampMs = Long.parseLong(request.substring(timestampStartIndex + 11, timestampStartIndex + 24));
            // calculate the threshold timestamp by subtracting dropAgeHours from the current time
            long thresholdTimestampMs = UtilsTime.currentTimestampMs() - (dropAgeHours * 3_600_000L); // 1 hour = 3600000 milliseconds
            // check if the request's timestamp is older than the threshold
            boolean result = requestTimestampMs < thresholdTimestampMs;
            if (result) {
                long timeGapMs = thresholdTimestampMs - requestTimestampMs;
                String message = formatTimeDifference(timeGapMs);
                L.v(messagePrefix + " isRequestTooOld, This request is " + message + " older than acceptable time frame");
            }
            return result;
        } catch (NumberFormatException e) {
            L.w(messagePrefix + " isRequestTooOld, Timestamp is not long");
            return false;
        }
    }
    /**
     * For a given milliseconds this returns a String message that gives the closest coherent timeframe back
     *
     * @param differenceMs - long milliseconds
     * @return String message
     */
    public static String formatTimeDifference(final long differenceMs) {
        long seconds = differenceMs / 1000;
        long minutes = seconds / 60;
        long hours = minutes / 60;
        long days = hours / 24;
        long months = days / 30;
        if (months > 0) {
            long remainingDays = days % 30;
            return months + " month(s) and " + remainingDays + " day(s)";
        } else if (days > 0) {
            long remainingHours = hours % 24;
            return days + " day(s) and " + remainingHours + " hour(s)";
        } else if (hours > 0) {
            return hours + " hour(s)";
        } else if (minutes > 0) {
            return minutes + " minute(s)";
        } else if (seconds > 0) {
            return seconds + " second(s)";
        } else {
            return differenceMs + " millisecond(s)";
        }
    }
    /**
     * Given a String value, it would return a part of it and the given string without that part
     * Ex. extractValueFromString("hey&a=b&c", "a=", "&") would return ["hey&c","b"]
     *
     * @param data - string value to be precessed
     * @param startStr - the string that comes just before the thing you want to extract
     * @param endStr - the string that where you would like to en your extraction
     * @return - returns a  [data, null] if no extraction. Else String[] with the (data - startStr - extractedStr) and extracted str as second item.
     */
    static String[] extractValueFromString(@NonNull String data, @NonNull String startStr, @NonNull String endStr) {
        int startingIndex = data.indexOf(startStr);
        if (startingIndex != -1) {
            // capture first part without starting str
            String initialPart = data.substring(0, startingIndex);
            // end of starting string
            startingIndex += startStr.length();
            // check if ending string exists
            int endingStrIndex = data.indexOf(endStr, startingIndex);
            // the string we are looking for is at the end
            if (endingStrIndex == -1) {
                return new String[] { initialPart, data.substring(startingIndex) };
            }
            // if ending str exists
            return new String[] { initialPart + data.substring(endingStrIndex), data.substring(startingIndex, endingStrIndex) };
        }
        // if startStr does not exist just return empty string[]
        return new String[] { data, null };
    }
    /**
     * Splits a given request into key-value pairs
     *
     * @param request - request string to be split
     * @return - returns a map of key-value pairs
     */
    public static @NonNull Map<String, String> splitIntoParams(@Nullable String request, @NonNull ModuleLog L) {
        assert L != null;
        Map<String, String> params = new HashMap<>();
        if (request == null || request.isEmpty()) {
            return params;
        }
        String[] entries = request.split("&");
        for (String entry : entries) {
            String[] parts = entry.split("=");
            if (parts.length != 2) {
                L.w("splitIntoParams, Param entry can't be split: [" + entry + "]");
                continue;
            }
            params.put(parts[0], parts[1]);
        }
        return params;
    }
    /**
     * Combines a map of key-value pairs into a request string
     * reversed version of {@link #splitIntoParams}
     *
     * @param params - map of key-value pairs
     * @return - returns a request string
     */
    public static @NonNull String combineParamsIntoRequest(@NonNull Map<String, String> params) {
        assert params != null;
        StringBuilder sb = new StringBuilder(100);
        for (Map.Entry<String, String> pair : params.entrySet()) {
            if (sb.length() > 0) {
                sb.append('&');
            }
            sb.append(pair.getKey());
            sb.append('=');
            sb.append(pair.getValue());
        }
        return sb.toString();
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
class ModuleHealthCheck extends ModuleBase {
    ImmediateRequestGenerator immediateRequestGenerator;
    HealthCheckCounter hCounter;
    boolean healthCheckEnabled = true;
    boolean healthCheckSent = false;
    ModuleHealthCheck(@NonNull Countly cly, @NonNull CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleHealthCheck] Initialising, enabled: " + healthCheckEnabled);
        hCounter = new HealthCheckCounter(config.storageProvider, L);
        config.healthTracker = hCounter;
        immediateRequestGenerator = config.immediateRequestGenerator;
        healthCheckEnabled = config.healthCheckEnabled;
    }
    @Override
    void initFinished(@NonNull final CountlyConfig config) {
        if (healthCheckEnabled) {
            sendHealthCheck();
        }
    }
    @Override
    void halt() {
        hCounter = null;
        immediateRequestGenerator = null;
    }
    @Override
    void onActivityStopped(int updatedActivityCount) {
        hCounter.saveState();
    }
    void sendHealthCheck() {
        L.v("[ModuleHealthCheck] sendHealthCheck, attempting to send health information");
        if (!healthCheckEnabled) {
            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, health check is disabled");
            return;
        }
        // why _cly? because module health is created last. So device id provider
        // call order to module device id is before module health check and device id provider is module device id
        if (_cly.config_.deviceIdProvider.isTemporaryIdEnabled()) {
            //temporary id mode enabled, abort
            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, temporary device ID mode is set");
            return;
        }
        if (healthCheckSent) {
            L.d("[ModuleHealthCheck] sendHealthCheck, sending health info of the SDK to server is aborted, health check already sent");
            return;
        }
        healthCheckSent = true;
        String preparedMetrics = deviceInfo.getMetricsHealthCheck(_cly.context_, _cly.config_.metricOverride);
        StringBuilder requestData = new StringBuilder(requestQueueProvider.prepareHealthCheckRequest(preparedMetrics));
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        requestData.append(hCounter.createRequestParam());
        immediateRequestGenerator.CreateImmediateRequestMaker().doWork(requestData.toString(), "/i", cp, false, networkingIsEnabled, checkResponse -> {
            if (checkResponse == null) {
                L.w("[ModuleHealthCheck] No response for sending health check Probably due to lack of connection to the server");
                //sending failed, keep counters
                return;
            }
            L.d("[ModuleHealthCheck] Retrieved request response: [" + checkResponse.toString() + "]");
            if (!checkResponse.has("result")) {
                L.d("[ModuleHealthCheck] Retrieved request response does not match expected pattern");
                return;
            }
            //at this point we can expect that the request succeed and we can clear the counters
            L.d("[ModuleHealthCheck] sendHealthCheck, SDK health information sent successfully");
            hCounter.clearAndSave();
        }, L);
    }
}
package ly.count.android.sdk;
import android.os.AsyncTask;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import org.json.JSONObject;
/**
 * Async task for making immediate server requests
 */
class ImmediateRequestMaker extends AsyncTask<Object, Void, JSONObject> implements ImmediateRequestI {
    /**
     * Used for callback from async task
     */
    protected interface InternalImmediateRequestCallback {
        void callback(JSONObject checkResponse);
    }
    InternalImmediateRequestCallback callback;
    ModuleLog L;
    @Override
    public void doWork(@NonNull String requestData, @Nullable String customEndpoint, @NonNull ConnectionProcessor cp, boolean requestShouldBeDelayed, boolean networkingIsEnabled, @NonNull InternalImmediateRequestCallback callback, @NonNull ModuleLog log) {
        assert Utils.isNotNullOrEmpty(requestData);
        assert cp != null;
        assert log != null;
        assert callback != null;
        this.execute(requestData, customEndpoint, cp, requestShouldBeDelayed, networkingIsEnabled, callback, log);
    }
    /**
     * params fields:
     * 0 - requestData
     * 1 - custom endpoint
     * 2 - connection processor
     * 3 - requestShouldBeDelayed
     * 4 - networkingIsEnabled
     * 5 - callback
     * 6 - log module
     */
    protected JSONObject doInBackground(Object... params) {
        final String requestData = (String) params[0];
        final String customEndpoint = (String) params[1];
        final ConnectionProcessor cp = (ConnectionProcessor) params[2];
        final boolean requestShouldBeDelayed = (boolean) params[3];
        final boolean networkingIsEnabled = (boolean) params[4];
        callback = (InternalImmediateRequestCallback) params[5];
        L = (ModuleLog) params[6];
        if (!networkingIsEnabled) {
            L.w("[ImmediateRequestMaker] ImmediateRequestMaker, Networking config is disabled, request cancelled. Endpoint[" + customEndpoint + "] request[" + requestData + "]");
            return null;
        }
        L.v("[ImmediateRequestMaker] Starting request");
        HttpURLConnection connection = null;
        BufferedReader reader = null;
        boolean wasSuccess = true;
        try {
            L.d("[ImmediateRequestMaker] delayed[" + requestShouldBeDelayed + "] hasCallback[" + (callback != null) + "] endpoint[" + customEndpoint + "] request[" + requestData + "] url[" + cp.getServerURL() + "]");
            if (requestShouldBeDelayed) {
                //used in cases after something has to be done after a device id change
                L.v("[ImmediateRequestMaker] request should be delayed, waiting for 0.5 seconds");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    L.w("[ImmediateRequestMaker] While waiting for 0.5 seconds in ImmediateRequestMaker, sleep was interrupted");
                }
            }
            //getting connection ready
            try {
                connection = (HttpURLConnection) cp.urlConnectionForServerRequest(requestData, customEndpoint);
            } catch (IOException e) {
                L.e("[ImmediateRequestMaker] IOException while preparing remote config update request :[" + e.toString() + "]");
                return null;
            }
            //connecting
            connection.connect();
            InputStream stream;
            //todo check response code
            try {
                //assume there will be no error
                stream = connection.getInputStream();
            } catch (Exception ex) {
                //in case of exception, assume there was a error in the request
                //and change streams
                stream = connection.getErrorStream();
                wasSuccess = false;
            }
            if (stream == null) {
                L.e("[ImmediateRequestMaker] Encountered problem while making a immediate server request, received stream was null");
                return null;
            }
            //getting result
            reader = new BufferedReader(new InputStreamReader(stream));
            StringBuilder buffer = new StringBuilder();
            String line = "";
            while ((line = reader.readLine()) != null) {
                buffer.append(line).append("\n");
            }
            final String receivedBuffer = buffer.toString();
            if (wasSuccess) {
                L.d("[ImmediateRequestMaker] Received the following response, :[" + receivedBuffer + "]");
                // we check if the result was a json array or json object and convert the array into an object if necessary
                char firstChar = receivedBuffer.trim().charAt(0);
                if (firstChar == '[') {
                    return new JSONObject("{\"jsonArray\":" + receivedBuffer + "}");
                }
                return new JSONObject(receivedBuffer);
            } else {
                L.e("[ImmediateRequestMaker] Encountered problem while making a immediate server request, :[" + receivedBuffer + "]");
                return null;
            }
        } catch (Exception e) {
            L.e("[ImmediateRequestMaker] Received exception while making a immediate server request", e);
        } finally {
            if (connection != null) {
                connection.disconnect();
            }
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException e) {
                L.e("[ImmediateRequestMaker] ", e);
            }
        }
        L.v("[ImmediateRequestMaker] Finished request");
        return null;
    }
    @Override
    protected void onPostExecute(JSONObject result) {
        super.onPostExecute(result);
        L.v("[ImmediateRequestMaker] onPostExecute");
        if (callback != null) {
            callback.callback(result);
        }
    }
}
/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.Map;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import org.json.JSONException;
import org.json.JSONObject;
/**
 * ConnectionProcessor is a Runnable that is executed on a background
 * thread to submit session &amp; event data to a Count.ly server.
 *
 * NOTE: This class is only public to facilitate unit testing, because
 * of this bug in dexmaker: https://code.google.com/p/dexmaker/issues/detail?id=34
 */
public class ConnectionProcessor implements Runnable {
    private static final int CONNECT_TIMEOUT_IN_MILLISECONDS = 30_000;
    private static final int READ_TIMEOUT_IN_MILLISECONDS = 30_000;
    private static final String CRLF = "\r\n";
    private static final String charset = "UTF-8";
    private final StorageProvider storageProvider_;
    private final DeviceIdProvider deviceIdProvider_;
    final ConfigurationProvider configProvider_;
    HealthTracker healthTracker;
    final RequestInfoProvider requestInfoProvider_;
    private final String serverURL_;
    private final SSLContext sslContext_;
    private final Map<String, String> requestHeaderCustomValues_;
    static String endPointOverrideTag = "&new_end_point=";
    ModuleLog L;
    public PerformanceCounterCollector pcc;
    private enum RequestResult {
        OK,         // success
        RETRY       // retry MAX_RETRIES_BEFORE_SLEEP before switching to SLEEP
    }
    ConnectionProcessor(final String serverURL, final StorageProvider storageProvider, final DeviceIdProvider deviceIdProvider, final ConfigurationProvider configProvider,
        final RequestInfoProvider requestInfoProvider, final SSLContext sslContext, final Map<String, String> requestHeaderCustomValues, ModuleLog logModule,
        HealthTracker healthTracker) {
        serverURL_ = serverURL;
        storageProvider_ = storageProvider;
        deviceIdProvider_ = deviceIdProvider;
        configProvider_ = configProvider;
        sslContext_ = sslContext;
        requestHeaderCustomValues_ = requestHeaderCustomValues;
        requestInfoProvider_ = requestInfoProvider;
        L = logModule;
        this.healthTracker = healthTracker;
    }
    synchronized public @NonNull URLConnection urlConnectionForServerRequest(@NonNull String requestData, @Nullable final String customEndpoint) throws IOException {
        String urlEndpoint = "/i";
        if (customEndpoint != null) {
            urlEndpoint = customEndpoint;
        }
        // determine whether or not request has a binary image file, if it has request will be sent as POST request
        boolean hasPicturePath = requestData.contains(ModuleUserProfile.PICTURE_PATH_KEY);
        boolean usingHttpPost = requestData.contains("&crash=") || requestData.length() >= 2048 || requestInfoProvider_.isHttpPostForced() || hasPicturePath;
        long approximateDateSize = 0L;
        String urlStr = serverURL_ + urlEndpoint;
        if (usingHttpPost) {
            // for binary images, checksum will be calculated without url encoded value of the requestData
            // because they sent as form-data and server calculates it that way
            if (!hasPicturePath) {
                String checksum = UtilsNetworking.sha256Hash(requestData + requestInfoProvider_.getRequestSalt());
                requestData += "&checksum256=" + checksum;
                L.v("[ConnectionProcessor] The following checksum was added:[" + checksum + "]");
                approximateDateSize += requestData.length(); // add request data to the estimated data size
            }
        } else {
            urlStr += "?" + requestData;
            String checksum = UtilsNetworking.sha256Hash(requestData + requestInfoProvider_.getRequestSalt());
            urlStr += "&checksum256=" + checksum;
            L.v("[ConnectionProcessor] The following checksum was added:[" + checksum + "]");
        }
        approximateDateSize += urlStr.length();
        final URL url = new URL(urlStr);
        final HttpURLConnection conn;
        long pccTsOpenURLConnection = 0L;
        long pccTsConfigureConnection = 0L;
        long pccTsStartHeaderFieldSize = 0L;
        if (pcc != null) {
            pccTsOpenURLConnection = UtilsTime.getNanoTime();
        }
        if (Countly.publicKeyPinCertificates == null && Countly.certificatePinCertificates == null) {
            conn = (HttpURLConnection) url.openConnection();
        } else {
            HttpsURLConnection c = (HttpsURLConnection) url.openConnection();
            c.setSSLSocketFactory(sslContext_.getSocketFactory());
            conn = c;
        }
        if (pcc != null) {
            long openUrlConnectionTime = UtilsTime.getNanoTime() - pccTsOpenURLConnection;
            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_01_OpenURLConnection", openUrlConnectionTime);
            pccTsConfigureConnection = UtilsTime.getNanoTime();
        }
        conn.setConnectTimeout(CONNECT_TIMEOUT_IN_MILLISECONDS);
        conn.setReadTimeout(READ_TIMEOUT_IN_MILLISECONDS);
        conn.setUseCaches(false);
        conn.setDoInput(true);
        conn.setRequestMethod("GET");
        if (requestHeaderCustomValues_ != null) {
            //if there are custom header values, add them
            L.v("[ConnectionProcessor] Adding [" + requestHeaderCustomValues_.size() + "] custom header fields");
            for (Map.Entry<String, String> entry : requestHeaderCustomValues_.entrySet()) {
                String key = entry.getKey();
                String value = entry.getValue();
                if (key != null && value != null && !key.isEmpty()) {
                    conn.addRequestProperty(key, value);
                }
            }
        }
        L.v("[ConnectionProcessor] Has picturePath [" + hasPicturePath + "]");
        if (hasPicturePath) {
            String boundary = Long.toHexString(System.currentTimeMillis());// Just generate some unique random value as the boundary
            conn.setDoOutput(true);
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + boundary);// Line separator required by multipart/form-data.
            OutputStream output = conn.getOutputStream(); // setup streams for form-data writing
            PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, charset), true);
            String[] params = requestData.split("&"); // split request data by key value pairs
            for (String key : params) {
                String[] kv = key.split("=");
                approximateDateSize += 4 + boundary.length(); // 4 is the length of the static parts of the entry
                String param = kv[0];
                String value = UtilsNetworking.urlDecodeString(kv[1]);
                if (param.equals(ModuleUserProfile.PICTURE_PATH_KEY)) {
                    approximateDateSize += addFileMultipart(output, writer, value, boundary);
                }
                approximateDateSize += addTextMultipart(writer, param, value, boundary);
            }
            approximateDateSize += 4 + boundary.length(); // 4 is the length of the static parts of the entry
            approximateDateSize += addTextMultipart(writer, "checksum256", UtilsNetworking.sha256Hash(UtilsNetworking.urlDecodeString(requestData) + requestInfoProvider_.getRequestSalt()), boundary);
            // End of multipart/form-data.
            writer.append("--").append(boundary).append("--").append(CRLF).flush();
            approximateDateSize += 6 + boundary.length(); // 6 is the length of the static parts of the entry
        } else {
            if (usingHttpPost) {
                conn.setDoOutput(true);
                conn.setRequestMethod("POST");
                conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                OutputStream os = conn.getOutputStream();
                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, charset));
                writer.write(requestData);
                writer.flush();
                writer.close();
                os.close();
            } else {
                L.v("[ConnectionProcessor] Using HTTP GET");
                conn.setDoOutput(false);
            }
        }
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_02_ConfigureConnection", UtilsTime.getNanoTime() - pccTsConfigureConnection);
            pccTsStartHeaderFieldSize = UtilsTime.getNanoTime();
        }
        //calculating header field size
        try {
            //just after init, because of background operations, this might fail
            // HttpUrl::Builder of okhttp might give null pointer error because it may not be initialized yet
            int headerIndex = 0;
            while (true) {
                String key = conn.getHeaderFieldKey(headerIndex);
                if (key == null) {
                    break;
                }
                String value = conn.getHeaderField(headerIndex++);
                approximateDateSize += key.getBytes("US-ASCII").length + value.getBytes("US-ASCII").length + 2L;
            }
        } catch (Exception e) {
            L.e("[Connection Processor] urlConnectionForServerRequest, exception while calculating header field size: " + e);
        }
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_03_HeaderFieldSize", UtilsTime.getNanoTime() - pccTsStartHeaderFieldSize);
        }
        L.v("[ConnectionProcessor] Using HTTP POST: [" + usingHttpPost + "] forced:[" + requestInfoProvider_.isHttpPostForced()
            + "] length:[" + (requestData.length() >= 2048) + "] crash:[" + requestData.contains("&crash=") + "] | Approx data size: [" + approximateDateSize + " B]");
        return conn;
    }
    /**
     * Return the size of the text multipart entry
     *
     * @param writer to write to
     * @param name of the entry
     * @param value of the entry
     * @return size of the entry
     */
    int addTextMultipart(PrintWriter writer, final String name, final String value, final String boundary) {
        writer.append("--").append(boundary).append(CRLF);
        writer.append("Content-Disposition: form-data; name=\"").append(name).append("\"").append(CRLF);
        writer.append(CRLF).append(value).append(CRLF).flush();
        return 49 + boundary.length() + name.length() + value.length(); // 45 is the length of the static parts of the entry
    }
    /**
     * Return the size of the file multipart entry
     *
     * @param output stream to write to
     * @param writer to write to
     * @param filePath of the file
     * @return size of the entry
     * @throws IOException if there is an error while reading the file
     */
    int addFileMultipart(OutputStream output, PrintWriter writer, final String filePath, final String boundary) throws IOException {
        if (Utils.isNullOrEmpty(filePath)) {
            return 0;
        }
        writer.append("--").append(boundary).append(CRLF);
        File file = new File(filePath);
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        int approximateDataSize = 0;
        writer.append("Content-Disposition: form-data; name=\"file\"; filename=\"").append(file.getName()).append("\"").append(CRLF);
        writer.append("Content-Type: ").append(contentType).append(CRLF);
        writer.append(CRLF).flush();
        try (FileInputStream fileInputStream = new FileInputStream(file)) {
            // write file to the buffer and stream
            byte[] buffer = new byte[1024];
            int len;
            try {
                while ((len = fileInputStream.read(buffer)) != -1) {
                    output.write(buffer, 0, len);
                    approximateDataSize += len;
                }
            } catch (IOException ex) {
                for (StackTraceElement e : ex.getStackTrace()) {
                    L.e("[ConnectionProcessor] addMultipart, error: " + e);
                }
            }
        }
        output.flush();
        writer.append(CRLF).flush();
        return 82 + boundary.length() + approximateDataSize + file.getName().length() + contentType.length(); // 78 is the length of the static parts of the entry
    }
    @Override
    public void run() {
        long wholeQueueStart = UtilsTime.getNanoTime();
        while (true) {
            long pccTsStartWholeQueue = 0L;
            long pccTsStartOnlyInternet = 0L;
            long pccTsStartTempIdCheck = 0L;
            long pccTsStartEndpointCheck = 0L;
            long pccTsStartOldRCheck = 0L;
            long pccTsStartGetURLConnection;
            long pccTsStartRemainingRequests = 0L;
            long pccTsReadingStream;
            long pccTsStartHandlingResponse;
            if (!configProvider_.getNetworkingEnabled()) {
                L.w("[ConnectionProcessor] run, Networking config is disabled, request queue skipped");
                break;
            }
            //------------------------
            // get stored requests
            final String[] storedRequests = storageProvider_.getRequests();
            int storedRequestCount = storedRequests == null ? 0 : storedRequests.length;
            String msg = "[Connection Processor] Starting to run, there are [" + storedRequestCount + "] requests stored";
            if (storedRequestCount == 0) {
                L.v(msg);
            } else {
                L.i(msg);
            }
            if (storedRequests == null || storedRequestCount == 0) {
                L.i("[ConnectionProcessor] No requests in the queue, request queue skipped");
                // currently no data to send, we are done for now
                break;
            }
            if (deviceIdProvider_.getDeviceId() == null) {
                // When device ID is supplied by OpenUDID or by Google Advertising ID.
                // In some cases it might take time for them to initialize. So, just wait for it.
                L.i("[ConnectionProcessor] No Device ID available yet, skipping request " + storedRequests[0]);
                break;
            }
            // get first request in a separate variable to modify and keep the original intact
            final String originalRequest = storedRequests[0];
            String requestData = originalRequest;//todo rework to another param approach
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_01_GetRequest", UtilsTime.getNanoTime() - pccTsStartWholeQueue);
            }
            //------------------------
            if (pcc != null) {
                pccTsStartOldRCheck = UtilsTime.getNanoTime();
            }
            L.i("[ConnectionProcessor] Checking if the request is older than:[" + requestInfoProvider_.getRequestDropAgeHours() + "] hours");
            boolean isRequestOld = Utils.isRequestTooOld(requestData, requestInfoProvider_.getRequestDropAgeHours(), "[ConnectionProcessor]", L);
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_02_NetworkOldReq", UtilsTime.getNanoTime() - pccTsStartOldRCheck);
            }
            //------------------------
            if (pcc != null) {
                pccTsStartTempIdCheck = UtilsTime.getNanoTime();
            }
            // temp ID checks
            String temporaryIdTag = "&device_id=" + DeviceId.temporaryCountlyDeviceId;
            boolean containsTemporaryId = requestData.contains(temporaryIdTag);
            if (containsTemporaryId || deviceIdProvider_.isTemporaryIdEnabled()) {
                //we are about to change ID to the temporary one or
                //the internally set id is the temporary one
                //abort and wait for exiting temporary mode
                L.i("[ConnectionProcessor] Temporary ID detected, stalling requests. tmp id tag:[" + containsTemporaryId + "], temp ID set:[" + deviceIdProvider_.isTemporaryIdEnabled() + "]");
                break;
            }
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_03_NetworkTempID", UtilsTime.getNanoTime() - pccTsStartTempIdCheck);
            }
            //------------------------
            if (pcc != null) {
                pccTsStartEndpointCheck = UtilsTime.getNanoTime();
            }
            String customEndpoint = null;
            // checks if endPointOverrideTag exists in the eventData, and if so, extracts the endpoint and removes the tag from the evenData
            String[] extractionResult = Utils.extractValueFromString(requestData, endPointOverrideTag, "&");
            if (extractionResult[1] != null) {
                requestData = extractionResult[0];
                if (!extractionResult[1].isEmpty()) {
                    customEndpoint = extractionResult[1];
                }
                L.v("[ConnectionProcessor] Custom end point detected for the request:[" + customEndpoint + "]");
            }
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_04_NetworkCustomEndpoint", UtilsTime.getNanoTime() - pccTsStartEndpointCheck);
            }
            //------------------------
            if (pcc != null) {
                pccTsStartRemainingRequests = UtilsTime.getNanoTime();
            }
            // add the remaining request count
            requestData = requestData + "&rr=" + (storedRequestCount - 1);
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_06_remainingRequests", UtilsTime.getNanoTime() - pccTsStartRemainingRequests);
            }
            //------------------------
            if (!(requestInfoProvider_.isDeviceAppCrawler() && requestInfoProvider_.ifShouldIgnoreCrawlers()) && !isRequestOld) {
                //continue with sending the request to the server
                URLConnection conn = null;
                InputStream connInputStream = null;
                try {
                    pccTsStartGetURLConnection = UtilsTime.getNanoTime();
                    // initialize and open connection
                    conn = urlConnectionForServerRequest(requestData, customEndpoint);
                    long setupServerRequestTime = UtilsTime.getNanoTime() - pccTsStartGetURLConnection;
                    L.d("[ConnectionProcessor] run, TIMING Setup server request took:[" + setupServerRequestTime / 1000000.0d + "] ms");
                    if (pcc != null) {
                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_07_SetupServerRequest", setupServerRequestTime);
                        pccTsStartOnlyInternet = UtilsTime.getNanoTime();
                    }
                    conn.connect();
                    if (pcc != null) {
                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_08_NetworkOnlyInternet", UtilsTime.getNanoTime() - pccTsStartOnlyInternet);
                    }
                    pccTsStartHandlingResponse = UtilsTime.getNanoTime();
                    pccTsReadingStream = UtilsTime.getNanoTime();
                    int responseCode = 0;
                    String responseString = "";
                    if (conn instanceof HttpURLConnection) {
                        final HttpURLConnection httpConn = (HttpURLConnection) conn;
                        try {
                            //assume there will be no error
                            connInputStream = httpConn.getInputStream();
                        } catch (Exception ex) {
                            //in case of exception, assume there was a error in the request and change streams
                            connInputStream = httpConn.getErrorStream();
                        }
                        responseCode = httpConn.getResponseCode();
                        responseString = Utils.inputStreamToString(connInputStream);
                    }
                    long readingStreamTime = UtilsTime.getNanoTime() - pccTsReadingStream;
                    L.d("[Connection Processor] code:[" + responseCode + "], response:[" + responseString + "], response size:[" + responseString.length() + " B], request: " + requestData + ", url: " + serverURL_ + ", Reading stream took:[" + readingStreamTime / 1000000.0d + "] ms");
                    if (pcc != null) {
                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_13_ReadingStream", readingStreamTime);
                    }
                    final RequestResult rRes;
        
                    if (responseCode >= 200 && responseCode < 300) {
                        if (responseString.isEmpty()) {
                            L.v("[ConnectionProcessor] Response was empty, will retry");
                            rRes = RequestResult.RETRY;
                        } else {
                            JSONObject jsonObject;
                            try {
                                jsonObject = new JSONObject(responseString);
                            } catch (JSONException ex) {
                                //failed to parse, so not a valid json
                                jsonObject = null;
                                L.e("[ConnectionProcessor] Failed to parse response [" + responseString + "].");
                            }
                            if (jsonObject == null) {
                                //received unparseable response, retrying
                                L.v("[ConnectionProcessor] Response was a unknown, will retry");
                                rRes = RequestResult.RETRY;
                            } else {
                                if (jsonObject.has("result")) {
                                    //contains result entry
                                    L.v("[ConnectionProcessor] Response was a success");
                                    rRes = RequestResult.OK;
                                } else {
                                    L.v("[ConnectionProcessor] Response does not contain 'result', will retry");
                                    rRes = RequestResult.RETRY;
                                }
                            }
                        }
                    } else if (responseCode >= 300 && responseCode < 400) {
                        //assume redirect
                        L.d("[ConnectionProcessor] Encountered redirect, will retry");
                        rRes = RequestResult.RETRY;
                    } else if (responseCode == 400 || responseCode == 404) {
                        L.w("[ConnectionProcessor] Bad request, will still retry");
                        rRes = RequestResult.RETRY;
                    } else if (responseCode > 400) {
                        //server down, try again later
                        L.d("[ConnectionProcessor] Server is down, will retry");
                        rRes = RequestResult.RETRY;
                    } else {
                        L.d("[ConnectionProcessor] Bad response code, will retry");
                        rRes = RequestResult.RETRY;
                    }
                    // an 'if' needs to be used here so that a 'switch' statement does not 'eat' the 'break' call
                    // that is used to get out of the request loop
                    if (rRes == RequestResult.OK) {
                        // successfully submitted event data to Count.ly server, so remove
                        // this one from the stored events collection
                        storageProvider_.removeRequest(originalRequest);
                    } else {
                        // will retry later
                        // warning was logged above, stop processing, let next tick take care of retrying
                        healthTracker.logFailedNetworkRequest(responseCode, responseString);//notify the health tracker of the issue
                        healthTracker.saveState();
                        if (pcc != null) {
                            pcc.TrackCounterTimeNs("ConnectionProcessorRun_12_FailedRequest", UtilsTime.getNanoTime() - pccTsStartWholeQueue);
                        }
                        break;
                    }
                } catch (Exception e) {
                    L.d("[ConnectionProcessor] Got exception while trying to submit request data: [" + requestData + "] [" + e + "]");
                    // if exception occurred, stop processing, let next tick take care of retrying
                    if (pcc != null) {
                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_11_NetworkWholeQueueException", UtilsTime.getNanoTime() - pccTsStartWholeQueue);
                    }
                    break;
                } finally {
                    // free connection resources
                    if (conn instanceof HttpURLConnection) {
                        try {
                            if (connInputStream != null) {
                                connInputStream.close();
                            }
                        } catch (Throwable ignored) {
                        }
                        ((HttpURLConnection) conn).disconnect();
                    }
                }
                long handlingResponseTime = UtilsTime.getNanoTime() - pccTsStartHandlingResponse;
                L.d("[ConnectionProcessor] run, TIMING Handling response took:[" + handlingResponseTime / 1000000.0d + "] ms");
                if (pcc != null) {
                    pcc.TrackCounterTimeNs("ConnectionProcessorRun_09_HandlingResponse", handlingResponseTime);
                }
            } else {
                //device is identified as a app crawler and nothing is sent to the server
                if (isRequestOld) {
                    L.i("[ConnectionProcessor] request is too old, removing request " + originalRequest);
                } else {
                    L.i("[ConnectionProcessor] Device identified as an app crawler, removing request " + originalRequest);
                }
                //remove stored data
                storageProvider_.removeRequest(originalRequest);
            }
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_10_NetworkWholeQueue", UtilsTime.getNanoTime() - pccTsStartWholeQueue);
            }
        }
        long wholeQueueTime = UtilsTime.getNanoTime() - wholeQueueStart;
        L.v("[ConnectionProcessor] run, TIMING Whole queue took:[" + wholeQueueTime / 1000000.0d + "] ms");
    }
    String getServerURL() {
        return serverURL_;
    }
    // for unit testing
    StorageProvider getCountlyStore() {
        return storageProvider_;
    }
}
package ly.count.android.sdk;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.Map;
import ly.count.android.sdk.internal.RemoteConfigHelper;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.Mockito.mock;
@RunWith(AndroidJUnit4.class)
public class RemoteConfigVariantControlTests {
    CountlyStore countlyStore;
    @Before
    public void setUp() {
        Countly.sharedInstance().setLoggingEnabled(true);
        countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
    }
    @Test
    public void testConvertVariantsJsonToMap_ValidInput_Multi() throws JSONException {
        // Create a sample JSON object with variants
        JSONObject variantsObj = new JSONObject();
        JSONArray variantArray1 = new JSONArray();
        variantArray1.put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 1"));
        variantArray1.put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 2"));
        JSONArray variantArray2 = new JSONArray();
        variantArray2.put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 3"));
        variantArray2.put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 4"));
        variantsObj.put("key1", variantArray1);
        variantsObj.put("key2", variantArray2);
        // Call the function to convert variants JSON to a map
        Map<String, String[]> resultMap = RemoteConfigHelper.convertVariantsJsonToMap(variantsObj, mock(ModuleLog.class));
        // Assert the expected map values
        Assert.assertEquals(2, resultMap.size());
        // Assert the values for key1
        String[] key1Variants = resultMap.get("key1");
        Assert.assertEquals(2, key1Variants.length);
        Assert.assertEquals("Variant 1", key1Variants[0]);
        Assert.assertEquals("Variant 2", key1Variants[1]);
        // Assert the values for key2
        String[] key2Variants = resultMap.get("key2");
        Assert.assertEquals(2, key2Variants.length);
        Assert.assertEquals("Variant 3", key2Variants[0]);
        Assert.assertEquals("Variant 4", key2Variants[1]);
    }
    @Test
    public void testConvertVariantsJsonToMap_ValidInput_Single() throws JSONException {
        // Create a sample JSON object with valid variants
        JSONObject variantsObj = new JSONObject();
        variantsObj.put("key1", new JSONArray().put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 1")));
        variantsObj.put("key2", new JSONArray().put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 2")));
        // Call the function to convert variants JSON to a map
        Map<String, String[]> resultMap = RemoteConfigHelper.convertVariantsJsonToMap(variantsObj, mock(ModuleLog.class));
        // Assert the expected map values
        Assert.assertEquals(2, resultMap.size());
        // Assert the values for key1
        String[] key1Variants = resultMap.get("key1");
        Assert.assertEquals(1, key1Variants.length);
        Assert.assertEquals("Variant 1", key1Variants[0]);
        // Assert the values for key2
        String[] key2Variants = resultMap.get("key2");
        Assert.assertEquals(1, key2Variants.length);
        Assert.assertEquals("Variant 2", key2Variants[0]);
    }
    @Test
    public void testConvertVariantsJsonToMap_InvalidInput() throws JSONException {
        // Create a sample JSON object with invalid variants (missing "name" field)
        JSONObject variantsObj = new JSONObject();
        variantsObj.put("key1", new JSONArray().put(new JSONObject().put("invalid_key", "Invalid Value")));
        // Call the function to convert variants JSON to a map
        Map<String, String[]> resultMap = RemoteConfigHelper.convertVariantsJsonToMap(variantsObj, mock(ModuleLog.class));
        Assert.assertEquals(1, resultMap.size());
        // Assert the values for key1
        String[] key1Variants = resultMap.get("key1");
        Assert.assertEquals(0, key1Variants.length);
    }
    @Test
    public void testConvertVariantsJsonToMap_InvalidJson() throws JSONException {
        // Test with invalid JSON object
        JSONObject variantsObj = new JSONObject();
        variantsObj.put("key1", "Invalid JSON");
        // Call the function to convert variants JSON to a map (expecting JSONException)
        RemoteConfigHelper.convertVariantsJsonToMap(variantsObj, mock(ModuleLog.class));
        // Call the function to convert variants JSON to a map
        Map<String, String[]> resultMap = RemoteConfigHelper.convertVariantsJsonToMap(variantsObj, mock(ModuleLog.class));
        Assert.assertEquals(0, resultMap.size());
    }
    /**
     * Empty JSON should produce an empty map
     */
    @Test
    public void testConvertVariantsJsonToMap_NoValues() {
        // Create an empty JSON object
        JSONObject variantsObj = new JSONObject();
        // Call the function to convert variants JSON to a map
        Map<String, String[]> resultMap = RemoteConfigHelper.convertVariantsJsonToMap(variantsObj, mock(ModuleLog.class));
        // Assert that the map is empty
        Assert.assertTrue(resultMap.isEmpty());
    }
    @Test
    public void testConvertVariantsJsonToMap_DifferentStructures() throws JSONException {
        // Test with JSON object having different structures
        JSONObject variantsObj = new JSONObject();
        // Structure 1: Empty JSON array
        variantsObj.put("key1", new JSONArray());
        // Structure 2: Single variant as JSON object
        variantsObj.put("key2", new JSONArray().put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 1")));
        // Structure 3: Multiple variants as JSON objects
        variantsObj.put("key3", new JSONArray().put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 2")).put(new JSONObject().put(ModuleRemoteConfig.variantObjectNameKey, "Variant 3")));
        // Call the function to convert variants JSON to a map
        Map<String, String[]> resultMap = RemoteConfigHelper.convertVariantsJsonToMap(variantsObj, mock(ModuleLog.class));
        // Assert the expected map values
        Assert.assertEquals(3, resultMap.size());
        // Assert the values for key1 (empty array)
        String[] key1Variants = resultMap.get("key1");
        Assert.assertEquals(0, key1Variants.length);
        // Assert the values for key2 (single variant)
        String[] key2Variants = resultMap.get("key2");
        Assert.assertEquals(1, key2Variants.length);
        Assert.assertEquals("Variant 1", key2Variants[0]);
        // Assert the values for key3 (multiple variants)
        String[] key3Variants = resultMap.get("key3");
        Assert.assertEquals(2, key3Variants.length);
        Assert.assertEquals("Variant 2", key3Variants[0]);
        Assert.assertEquals("Variant 3", key3Variants[1]);
    }
    /**
     * variant with a string test name "null" and a string variant name "null" should be let through
     *
     * @throws JSONException
     */
    @Test
    public void testConvertVariantsJsonToMap_NullJsonKey() throws JSONException {
        // Test with a null JSON key string
        String variantsObj = "{\"null\":[{\"name\":\"null\"}]}";
        // Call the function to convert variants JSON to a map (expecting JSONException)
        Map<String, String[]> resultMap = RemoteConfigHelper.convertVariantsJsonToMap(new JSONObject(variantsObj), mock(ModuleLog.class));
        // Assert the values for key1
        String[] key1Variants = resultMap.get("null");
        Assert.assertEquals(1, key1Variants.length);
        Assert.assertEquals("null", key1Variants[0]);
    }
    @Test
    public void testNormalFlow() {
        CountlyConfig config = TestUtils.createVariantConfig(createIRGForSpecificResponse("{\"key\":[{\"name\":\"variant\"}]}"));
        Countly countly = new Countly().init(config);
        // Developer did not provide a callback
        countly.moduleRemoteConfig.remoteConfigInterface.testingDownloadVariantInformation(null);
        Map<String, String[]> values = countly.moduleRemoteConfig.remoteConfigInterface.testingGetAllVariants();
        String[] variantArray = countly.moduleRemoteConfig.remoteConfigInterface.testingGetVariantsForKey("key");
        String[] variantArrayFalse = countly.moduleRemoteConfig.remoteConfigInterface.testingGetVariantsForKey("key2");
        //Assert the values
        String[] key1Variants = values.get("key");
        Assert.assertEquals(1, key1Variants.length);
        Assert.assertEquals("variant", key1Variants[0]);
        Assert.assertEquals(1, variantArray.length);
        Assert.assertEquals("variant", variantArray[0]);
        Assert.assertNull(variantArrayFalse);
    }
    /**
     * Reject a variant if it's name is a null json value
     */
    @Test
    public void testNullVariant() {
        CountlyConfig config = TestUtils.createVariantConfig(createIRGForSpecificResponse("{\"key\":[{\"name\":null}]}"));
        Countly countly = new Countly().init(config);
        // Developer did not provide a callback
        countly.moduleRemoteConfig.remoteConfigInterface.testingDownloadVariantInformation(null);
        Map<String, String[]> values = countly.moduleRemoteConfig.remoteConfigInterface.testingGetAllVariants();
        // Assert the values
        String[] key1Variants = values.get("key");
        Assert.assertEquals(0, key1Variants.length);
    }
    /**
     * Reject variant entries where the object has no entry with the "name" key
     */
    @Test
    public void testFilteringWrongKeys() {
        CountlyConfig config = TestUtils.createVariantConfig(createIRGForSpecificResponse("{\"key\":[{\"noname\":\"variant1\"},{\"name\":\"variant2\"}]}"));
        Countly countly = new Countly().init(config);
        // Developer did not provide a callback
        countly.moduleRemoteConfig.remoteConfigInterface.testingDownloadVariantInformation(null);
        Map<String, String[]> values = countly.moduleRemoteConfig.remoteConfigInterface.testingGetAllVariants();
        //Assert the values
        String[] key1Variants = values.get("key");
        Assert.assertEquals(1, key1Variants.length);
        Assert.assertEquals("variant2", key1Variants[0]);
    }
    ImmediateRequestGenerator createIRGForSpecificResponse(final String targetResponse) {
        return () -> (requestData, customEndpoint, cp, requestShouldBeDelayed, networkingIsEnabled, callback, log) -> {
            if (targetResponse == null) {
                callback.callback(null);
                return;
            }
            JSONObject jobj = null;
            try {
                jobj = new JSONObject(targetResponse);
            } catch (JSONException e) {
                e.printStackTrace();
            }
            callback.callback(jobj);
        };
    }
    @Test
    public void variantGetters_preDownload() {
        CountlyConfig config = TestUtils.createVariantConfig(null);
        Countly countly = new Countly().init(config);
        //should return empty map of values
        Map<String, String[]> vals = countly.remoteConfig().testingGetAllVariants();
        Assert.assertEquals(0, vals.size());
        //single getters should also not fail on requesting values
        Assert.assertNull(countly.remoteConfig().testingGetVariantsForKey("a"));
        Assert.assertNull(countly.remoteConfig().testingGetVariantsForKey(""));
        Assert.assertNull(countly.remoteConfig().testingGetVariantsForKey(null));
    }
}
package ly.count.android.sdk;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Handler;
import android.os.Looper;
import android.webkit.WebSettings;
import android.webkit.WebView;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleFeedback extends ModuleBase {
    public enum FeedbackWidgetType {survey, nps, rating}
    public static class CountlyFeedbackWidget {
        public String widgetId;
        public FeedbackWidgetType type;
        public String name;
        public String[] tags;
    }
    final static String NPS_EVENT_KEY = "[CLY]_nps";
    final static String SURVEY_EVENT_KEY = "[CLY]_survey";
    final static String RATING_EVENT_KEY = "[CLY]_star_rating";
    final String cachedAppVersion;
    Feedback feedbackInterface = null;
    ModuleFeedback(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleFeedback] Initialising");
        cachedAppVersion = deviceInfo.mp.getAppVersion(config.context);
        feedbackInterface = new Feedback();
    }
    public interface RetrieveFeedbackWidgets {
        void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error);
    }
    public interface RetrieveFeedbackWidgetData {
        void onFinished(JSONObject retrievedWidgetData, String error);
    }
    public interface FeedbackCallback {
        void onClosed();
        void onFinished(String error);
    }
    void getAvailableFeedbackWidgetsInternal(final RetrieveFeedbackWidgets devCallback) {
        L.d("[ModuleFeedback] calling 'getAvailableFeedbackWidgetsInternal', callback set:[" + (devCallback != null) + "]");
        if (devCallback == null) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved without a callback");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            devCallback.onFinished(null, "Consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            devCallback.onFinished(null, "[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            return;
        }
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        String requestData = requestQueueProvider.prepareFeedbackListRequest();
        (new ImmediateRequestMaker()).doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleFeedback] Not possible to retrieve widget list. Probably due to lack of connection to the server");
                    devCallback.onFinished(null, "Not possible to retrieve widget list. Probably due to lack of connection to the server");
                    return;
                }
                L.d("[ModuleFeedback] Retrieved request: [" + checkResponse.toString() + "]");
                List<CountlyFeedbackWidget> feedbackEntries = parseFeedbackList(checkResponse);
                devCallback.onFinished(feedbackEntries, null);
            }
        }, L);
    }
    static List<CountlyFeedbackWidget> parseFeedbackList(JSONObject requestResponse) {
        Countly.sharedInstance().L.d("[ModuleFeedback] calling 'parseFeedbackList'");
        List<CountlyFeedbackWidget> parsedRes = new ArrayList<>();
        try {
            if (requestResponse != null) {
                JSONArray jArray = requestResponse.optJSONArray("result");
                if (jArray == null) {
                    Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, response does not have a valid 'result' entry. No widgets retrieved.");
                    return parsedRes;
                }
                for (int a = 0; a < jArray.length(); a++) {
                    try {
                        JSONObject jObj = jArray.getJSONObject(a);
                        String valId = jObj.optString("_id", "");
                        String valType = jObj.optString("type", "");
                        String valName = jObj.optString("name", "");
                        List<String> valTagsArr = new ArrayList<String>();
                        JSONArray jTagArr = jObj.optJSONArray("tg");
                        if (jTagArr == null) {
                            Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, no tags received");
                        } else {
                            for (int in = 0; in < jTagArr.length(); in++) {
                                valTagsArr.add(jTagArr.getString(in));
                            }
                        }
                        if (valId.isEmpty()) {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget id, dropping");
                            continue;
                        }
                        if (valType.isEmpty()) {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget type, dropping");
                            continue;
                        }
                        FeedbackWidgetType plannedType;
                        if (valType.equals("survey")) {
                            plannedType = FeedbackWidgetType.survey;
                        } else if (valType.equals("nps")) {
                            plannedType = FeedbackWidgetType.nps;
                        } else if (valType.equals("rating")) {
                            plannedType = FeedbackWidgetType.rating;
                        } else {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved unknown widget type, dropping");
                            continue;
                        }
                        CountlyFeedbackWidget se = new CountlyFeedbackWidget();
                        se.type = plannedType;
                        se.widgetId = valId;
                        se.name = valName;
                        se.tags = valTagsArr.toArray(new String[0]);
                        parsedRes.add(se);
                    } catch (Exception ex) {
                        Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, failed to parse json, [" + ex.toString() + "]");
                    }
                }
            }
        } catch (Exception ex) {
            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, Encountered exception while parsing feedback list, [" + ex.toString() + "]");
        }
        return parsedRes;
    }
    void presentFeedbackWidgetInternal(@Nullable final CountlyFeedbackWidget widgetInfo, @Nullable final Context context, @Nullable final String closeButtonText, @Nullable final FeedbackCallback devCallback) {
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Can't present widget with null widget info");
            if (devCallback != null) {
                devCallback.onFinished("Can't present widget with null widget info");
            }
            return;
        }
        L.d("[ModuleFeedback] presentFeedbackWidgetInternal, callback set:[" + (devCallback != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "]");
        if (context == null) {
            L.e("[ModuleFeedback] Can't show feedback, provided context is null");
            if (devCallback != null) {
                devCallback.onFinished("Can't show feedback, provided context is null");
            }
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            if (devCallback != null) {
                devCallback.onFinished("Consent is not granted");
            }
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            if (devCallback != null) {
                devCallback.onFinished("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            }
            return;
        }
        StringBuilder widgetListUrl = new StringBuilder();
        switch (widgetInfo.type) {
            case survey:
                //'/o/feedback/nps/widget?widget_ids=' + nps[0]._id
                //https://xxxx.count.ly/feedback/nps?widget_id=5f8445c4eecf2a6de4dcb53e
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/survey?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
            case nps:
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/nps?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
            case rating:
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/rating?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
        }
        widgetListUrl.append("&device_id=");
        widgetListUrl.append(UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()));
        widgetListUrl.append("&app_key=");
        widgetListUrl.append(UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey()));
        widgetListUrl.append("&sdk_version=");
        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);
        widgetListUrl.append("&sdk_name=");
        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_NAME);
        widgetListUrl.append("&platform=android");
        // TODO: this will be the base for the custom segmentation users can send while presenting a widget
        JSONObject customObjectToSendWithTheWidget = new JSONObject();
        try {
            customObjectToSendWithTheWidget.put("tc", 1);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        widgetListUrl.append("&custom=");
        widgetListUrl.append(customObjectToSendWithTheWidget.toString());
        final String preparedWidgetUrl = widgetListUrl.toString();
        L.d("[ModuleFeedback] Using following url for widget:[" + widgetListUrl + "]");
        //enable for chrome debugging
        //WebView.setWebContentsDebuggingEnabled(true);
        final boolean useAlertDialog = true;
        Handler handler = new Handler(Looper.getMainLooper());
        handler.post(new Runnable() {
            public void run() {
                L.d("[ModuleFeedback] Calling on main thread");
                try {
                    ModuleRatings.RatingDialogWebView webView = new ModuleRatings.RatingDialogWebView(context);
                    webView.getSettings().setJavaScriptEnabled(true);
                    webView.clearCache(true);
                    webView.clearHistory();
                    webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
                    webView.setWebViewClient(new ModuleRatings.FeedbackDialogWebViewClient());
                    webView.loadUrl(preparedWidgetUrl);
                    webView.requestFocus();
                    AlertDialog.Builder builder = prepareAlertDialog(context, webView, closeButtonText, widgetInfo, devCallback);
                    if (useAlertDialog) {
                        // use alert dialog to host the webView
                        L.d("[ModuleFeedback] Creating standalone Alert dialog");
                        builder.show();
                    } else {
                        // use dialog fragment to host the webView
                        L.d("[ModuleFeedback] Creating Alert dialog in dialogFragment");
                        //CountlyDialogFragment newFragment = CountlyDialogFragment.newInstance(builder);
                        //newFragment.show(fragmentManager, "CountlyFragmentDialog");
                    }
                    if (devCallback != null) {
                        devCallback.onFinished(null);
                    }
                } catch (Exception ex) {
                    L.e("[ModuleFeedback] Failed at displaying feedback widget dialog, [" + ex.toString() + "]");
                    if (devCallback != null) {
                        devCallback.onFinished("Failed at displaying feedback widget dialog, [" + ex.toString() + "]");
                    }
                }
            }
        });
    }
    AlertDialog.Builder prepareAlertDialog(@NonNull final Context context, @NonNull WebView webView, @Nullable String closeButtonText, @NonNull final CountlyFeedbackWidget widgetInfo, @Nullable final FeedbackCallback devCallback) {
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        builder.setView(webView);
        builder.setCancelable(false);
        String usedCloseButtonText = closeButtonText;
        if (closeButtonText == null || closeButtonText.isEmpty()) {
            usedCloseButtonText = "Close";
        }
        builder.setNeutralButton(usedCloseButtonText, new DialogInterface.OnClickListener() {
            @Override public void onClick(DialogInterface dialogInterface, int i) {
                L.d("[ModuleFeedback] Cancel button clicked for the feedback widget");
                reportFeedbackWidgetCancelButton(widgetInfo, deviceInfo.mp.getAppVersion(context));
                if (devCallback != null) {
                    devCallback.onClosed();
                }
            }
        });
        return builder;
    }
    void reportFeedbackWidgetCancelButton(@NonNull CountlyFeedbackWidget widgetInfo, @NonNull String appVersion) {
        L.d("[reportFeedbackWidgetCancelButton] Cancel button event");
        if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            final Map<String, Object> segm = new HashMap<>();
            segm.put("platform", "android");
            segm.put("app_version", appVersion);
            segm.put("widget_id", "" + widgetInfo.widgetId);
            segm.put("closed", "1");
            final String key;
            if (widgetInfo.type == FeedbackWidgetType.survey) {
                key = SURVEY_EVENT_KEY;
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                key = RATING_EVENT_KEY;
            } else {
                key = NPS_EVENT_KEY;
            }
            eventProvider.recordEventInternal(key, segm, 1, 0, 0, null, null);
        }
    }
    /**
     * Downloads widget info and returns it to the callback
     *
     * @param widgetInfo identifies the specific widget for which you want to download widget data
     * @param devCallback mandatory callback in which the downloaded data will be returned
     */
    void getFeedbackWidgetDataInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable final RetrieveFeedbackWidgetData devCallback) {
        L.d("[ModuleFeedback] calling 'getFeedbackWidgetDataInternal', callback set:[" + (devCallback != null) + "]");
        if (devCallback == null) {
            L.e("[ModuleFeedback] Feedback widget data can't be retrieved without a callback");
            return;
        }
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Feedback widget data if provided widget is 'null'");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            devCallback.onFinished(null, "Consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");
            devCallback.onFinished(null, "[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");
            return;
        }
        StringBuilder requestData = new StringBuilder();
        String widgetDataEndpoint = "";
        switch (widgetInfo.type) {
            case survey:
                //https://xxxx.count.ly/o/surveys/survey/widget?widget_id=601345cf5e313f74&shown=1platform=Android&app_version=7
                widgetDataEndpoint = "/o/surveys/survey/widget";
                break;
            case nps:
                //https://xxxx.count.ly/o/surveys/nps/widget?widget_id=601345cf5e313f74&shown=1platform=Android&app_version=7
                widgetDataEndpoint = "/o/surveys/nps/widget";
                break;
            case rating:
                widgetDataEndpoint = "/o/surveys/rating/widget";
                break;
        }
        requestData.append("widget_id=");
        requestData.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
        requestData.append("&shown=1");
        requestData.append("&sdk_version=");
        requestData.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);
        requestData.append("&sdk_name=");
        requestData.append(Countly.sharedInstance().COUNTLY_SDK_NAME);
        requestData.append("&platform=android");
        requestData.append("&app_version=");
        requestData.append(cachedAppVersion);
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        String requestDataStr = requestData.toString();
        L.d("[ModuleFeedback] Using following request params for retrieving widget data:[" + requestDataStr + "]");
        (new ImmediateRequestMaker()).doWork(requestDataStr, widgetDataEndpoint, cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleFeedback] Not possible to retrieve widget data. Probably due to lack of connection to the server");
                    devCallback.onFinished(null, "Not possible to retrieve widget data. Probably due to lack of connection to the server");
                    return;
                }
                L.d("[ModuleFeedback] Retrieved widget data request: [" + checkResponse.toString() + "]");
                devCallback.onFinished(checkResponse, null);
            }
        }, L);
    }
    /**
     * Report widget info and do data validation
     *
     * @param widgetInfo identifies the specific widget for which the feedback is filled out
     * @param widgetData widget data for this specific widget
     * @param widgetResult segmentation of the filled out feedback. If this segmentation is null, it will be assumed that the survey was closed before completion and mark it appropriately
     */
    void reportFeedbackWidgetManuallyInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Can't report feedback widget data manually with 'null' widget info");
            return;
        }
        L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetData set:[" + (widgetData != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "], widget result set:[" + (widgetResult != null) + "]");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            L.w("[ModuleFeedback] Can't report feedback widget data, consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] feedback widget result can't be reported when in temporary device ID mode");
            return;
        }
        if (widgetResult != null) {
            //removing broken values first
            UtilsInternalLimits.removeUnsupportedDataTypes(widgetResult, L);
            Iterator<Map.Entry<String, Object>> iter = widgetResult.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<String, Object> entry = iter.next();
                if (entry.getKey() == null) {
                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' key, it will be removed, value[" + entry.getValue() + "]");
                    iter.remove();
                } else if (entry.getKey().isEmpty()) {
                    L.w("[ModuleFeedback] provided feedback widget result contains an empty string key, it will be removed, value[" + entry.getValue() + "]");
                    iter.remove();
                } else if (entry.getValue() == null) {
                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' value, it will be removed, key[" + entry.getKey() + "]");
                    iter.remove();
                }
                if (entry.getValue() instanceof String) {
                    // TODO, if applicable think about applying key and segmentation count limit for the widget result
                    String truncatedValue = UtilsInternalLimits.truncateValueSize(entry.getValue().toString(), _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleFeedback] reportFeedbackWidgetManuallyInternal");
                    if (!truncatedValue.equals(entry.getValue())) {
                        entry.setValue(truncatedValue);
                    }
                }
            }
            if (widgetInfo.type == FeedbackWidgetType.nps) {
                //in case a nps widget was completed
                if (!widgetResult.containsKey("rating")) {
                    L.e("Provided NPS widget result does not have a 'rating' field, result can't be reported");
                    return;
                }
                //check rating data type
                Object ratingValue = widgetResult.get("rating");
                if (!(ratingValue instanceof Integer)) {
                    L.e("Provided NPS widget 'rating' field is not an integer, result can't be reported");
                    return;
                }
                //check rating value range
                int ratingValI = (int) ratingValue;
                if (ratingValI < 0 || ratingValI > 10) {
                    L.e("Provided NPS widget 'rating' value is out of bounds of the required value '[0;10]', it is probably an error");
                }
                if (!widgetResult.containsKey("comment")) {
                    L.w("Provided NPS widget result does not have a 'comment' field");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.survey) {
                //in case a survey widget was completed
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                //in case a rating widget was completed
                if (!widgetResult.containsKey("rating")) {
                    L.e("Provided Rating widget result does not have a 'rating' field, result can't be reported");
                    return;
                }
                //check rating data type
                Object ratingValue = widgetResult.get("rating");
                if (!(ratingValue instanceof Integer)) {
                    L.e("Provided Rating widget 'rating' field is not an integer, result can't be reported");
                    return;
                }
                //check rating value range
                int ratingValI = (int) ratingValue;
                if (ratingValI < 1 || ratingValI > 5) {
                    L.e("Provided Rating widget 'rating' value is out of bounds of the required value '[1;5]', it is probably an error");
                }
            }
        }
        if (widgetData == null) {
            L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetInfo is 'null', no validation will be done");
        } else {
            //perform data validation
            String idInData = widgetData.optString("_id");
            if (!widgetInfo.widgetId.equals(idInData)) {
                L.w("[ModuleFeedback] id in widget info does not match the id in widget data");
            }
            String typeInData = widgetData.optString("type");
            if (widgetInfo.type == FeedbackWidgetType.nps) {
                if (!"nps".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [nps]");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.survey) {
                if (!"survey".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [survey]");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                if (!"rating".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [rating]");
                }
            }
        }
        final String usedEventKey;
        if (widgetInfo.type == FeedbackWidgetType.nps) {
            usedEventKey = NPS_EVENT_KEY;
            //event when closed
            //{"key":"[CLY]_nps","segmentation":{"widget_id":"600e9d2e563e892016316339","platform":"android","app_version":"0.0","closed":1},"timestamp":1611570486021,"hour":15,"dow":1}
            //event when answered
            //{"key":"[CLY]_nps","segmentation":{"widget_id":"600e9b24563e89201631631f","platform":"android","app_version":"0.0","rating":10,"comment":"Thanks"},"timestamp":1611570182023,"hour":15,"dow":1}
        } else if (widgetInfo.type == FeedbackWidgetType.survey) {
            usedEventKey = SURVEY_EVENT_KEY;
            //event when closed
            //{"key":"[CLY]_survey","segmentation":{"widget_id":"600e9e0b563e89201631633e","platform":"android","app_version":"0.0","closed":1},"timestamp":1611570709449,"hour":16,"dow":1}
            //event when answered
            //{"key":"[CLY]_survey","segmentation":{"widget_id":"600e9e0b563e89201631633e","platform":"android","app_version":"0.0","answ-1611570700-0":"ch1611570700-0"},"timestamp":1611570895465,"hour":16,"dow":1}
        } else if (widgetInfo.type == FeedbackWidgetType.rating) {
            usedEventKey = RATING_EVENT_KEY;
            //event when closed
            // {"key":"[CLY]_star_rating","count":1,"timestamp":1671783040088,"hour":11,"dow":5,"segmentation":{"app_version":"1.0","widget_id":"614871419f030e44be07d82f","closed":"1","platform":"android"}
            //event when answered
            //{"key":"[CLY]_star_rating","count":1,"segmentation":{"widget_id":"614871419f030e44be07d82f","contactMe":false,"platform":"android","app_version":"1","platform_version_rate":"","rating":4,"email":"","comment":""}
        } else {
            usedEventKey = "";
        }
        Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", cachedAppVersion);
        segm.put("widget_id", widgetInfo.widgetId);
        if (widgetResult == null) {
            //mark as closed
            segm.put("closed", "1");
        } else {
            //widget was filled out
            //merge given segmentation
            segm.putAll(widgetResult);
        }
        eventProvider.recordEventInternal(usedEventKey, segm, 1, 0, 0, null, null);
    }
    /**
     * Present a feedback widget based on the provided nameIDorTag, internal function to use
     *
     * @param type the type of the feedback widget to present
     * @param nameIDorTag the widget id, widget name or widget tag of the feedback widget to present
     */
    private void presentFeedbackWidgetNameIDorTag(@NonNull Context context, @NonNull FeedbackWidgetType type, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
        getAvailableFeedbackWidgetsInternal(new RetrieveFeedbackWidgets() {
            @Override public void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error) {
                if (error != null) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, Failed to retrieve feedback widget list, [" + error + "]");
                    return;
                }
                if (retrievedWidgets.isEmpty()) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widgets available");
                    return;
                }
                CountlyFeedbackWidget selectedWidget = null;
                for (CountlyFeedbackWidget widget : retrievedWidgets) {
                    if (widget.type == type) {
                        if (!nameIDorTag.isEmpty()) {
                            if (widget.widgetId.equals(nameIDorTag) || widget.name.equals(nameIDorTag)) {
                                selectedWidget = widget;
                                break;
                            }
                            for (String tag : widget.tags) {
                                if (tag.equals(nameIDorTag)) {
                                    selectedWidget = widget;
                                    break;
                                }
                            }
                        } else {
                            selectedWidget = widget;
                            break;
                        }
                    }
                }
                if (selectedWidget == null) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widget found with the provided nameIDorTag or type");
                    return;
                }
                presentFeedbackWidgetInternal(selectedWidget, context, null, devCallback);
            }
        });
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
    }
    @Override
    void halt() {
        feedbackInterface = null;
    }
    public class Feedback {
        /**
         * Get a list of available feedback widgets for this device ID
         *
         * @param callback
         */
        public void getAvailableFeedbackWidgets(@Nullable RetrieveFeedbackWidgets callback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to retrieve feedback widget list");
                getAvailableFeedbackWidgetsInternal(callback);
            }
        }
        /**
         * Present a chosen feedback widget in an alert dialog
         *
         * @param widgetInfo
         * @param context
         * @param closeButtonText if this is null, no "close" button will be shown
         * @param devCallback
         */
        public void presentFeedbackWidget(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable Context context, @Nullable String closeButtonText, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to present feedback widget in an alert dialog");
                presentFeedbackWidgetInternal(widgetInfo, context, closeButtonText, devCallback);
            }
        }
        /**
         * Download data for a specific widget so that it can be displayed with a custom UI
         * When requesting this data, it will count as a shown widget (will increment that "shown" count in the dashboard)
         *
         * @param widgetInfo
         * @param callback
         */
        public void getFeedbackWidgetData(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable RetrieveFeedbackWidgetData callback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to retrieve feedback widget data");
                getFeedbackWidgetDataInternal(widgetInfo, callback);
            }
        }
        /**
         * Manually report a feedback widget in case a custom interface was used
         * In case widgetResult is passed as "null", it would be assumed that the widget was cancelled
         *
         * @param widgetInfo
         * @param widgetData
         * @param widgetResult
         */
        public void reportFeedbackWidgetManually(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to report feedback widget manually");
                reportFeedbackWidgetManuallyInternal(widgetInfo, widgetData, widgetResult);
            }
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the NPS feedback widget to present, if empty, the top widget will be presented
         */
        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag) {
            presentNPS(context, nameIDorTag, null);
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentNPS(@NonNull Context context) {
            presentNPS(context, "");
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Survey feedback widget to present, if empty, the top widget will be presented
         */
        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag) {
            presentSurvey(context, nameIDorTag, null);
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentSurvey(@NonNull Context context) {
            presentSurvey(context, "");
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Rating feedback widget to present, if empty, the top widget will be presented
         */
        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag) {
            presentRating(context, nameIDorTag, null);
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentRating(@NonNull Context context) {
            presentRating(context, "");
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the NPS feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentNPS, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.nps, nameIDorTag, devCallback);
            }
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Survey feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentSurvey, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.survey, nameIDorTag, devCallback);
            }
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Rating feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentRating, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.rating, nameIDorTag, devCallback);
            }
        }
    }
}
package ly.count.android.sdk;
interface DeviceIdProvider {
    String getDeviceId();
    DeviceId getDeviceIdInstance();
    boolean isTemporaryIdEnabled();
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
public class DeviceId {
    protected final static String temporaryCountlyDeviceId = "CLYTemporaryDeviceID";
    @Nullable
    private String id;
    @Nullable
    private DeviceIdType type;
    ModuleLog L;
    @NonNull
    StorageProvider storageProvider;
    @NonNull
    OpenUDIDProvider openUDIDProvider;
    protected DeviceId(@Nullable String providedId, @NonNull StorageProvider givenStorageProvider, @NonNull ModuleLog moduleLog, @NonNull OpenUDIDProvider openUDIDProvider) {
        assert givenStorageProvider != null;
        assert moduleLog != null;
        assert openUDIDProvider != null;
        if ("".equals(providedId)) {
            throw new IllegalStateException("Empty device ID is not a valid value, [" + providedId + "]");
        }
        storageProvider = givenStorageProvider;
        this.openUDIDProvider = openUDIDProvider;
        L = moduleLog;
        L.d("[DeviceId-int] initialising with values, device ID:[" + providedId + "]");
        //check if there wasn't a value set before. Read if from storage
        String storedId = storageProvider.getDeviceID();
        DeviceIdType storedType = retrieveStoredType();
        L.d("[DeviceId-int] The following values were stored, device ID:[" + storedId + "] type:[" + storedType + "]");
        if (storedId != null && storedType != null) {
            //values are set, just use them and ignore the provided ones
            id = storedId;
            type = storedType;
        } else {
            //if either the type or value are 'null'
            if (storedType == null && storedId != null) {
                // if we know that only the type is 'null'
                // that would mean that either there is no value or a old type is stored
                // In that case fallback to OPEN_UDID
                L.e("[DeviceId-int] init, device id type currently is 'null', falling back to OPEN_UDID");
                setAndStoreId(DeviceIdType.OPEN_UDID, storedId);
            }
            if (storedId == null) {
                // if we reach here then that means that either the value is 'null' or both value and type were 'null'
                // In this case we will regenerate the value and set the type accordingly
                if (providedId == null) {
                    //if the provided ID is 'null' then that means that a new ID must be generated
                    L.i("[DeviceId-int] Using OpenUDID");
                    setAndStoreId(DeviceIdType.OPEN_UDID, openUDIDProvider.getOpenUDID());
                } else if (providedId.equals(temporaryCountlyDeviceId)) {
                    L.i("[DeviceId-int] Entering temp ID mode");
                    setAndStoreId(DeviceIdType.TEMPORARY_ID, providedId);
                } else {
                    //it's a non null value that is not empty string
                    // use it as the developer provided device ID value
                    L.i("[DeviceId-int] Using dev provided ID");
                    setAndStoreId(DeviceIdType.DEVELOPER_SUPPLIED, providedId);
                }
            }
        }
    }
    /**
     * Retrieved stored device ID type
     *
     * @return The currently stored data type
     */
    @Nullable private DeviceIdType retrieveStoredType() {
        // Using strings is safer when it comes to extending Enum values list
        String typeString = storageProvider.getDeviceIDType();
        if (typeString == null) {
            return null;
        } else if (typeString.equals(DeviceIdType.DEVELOPER_SUPPLIED.toString())) {
            return DeviceIdType.DEVELOPER_SUPPLIED;
        } else if (typeString.equals(DeviceIdType.OPEN_UDID.toString())) {
            return DeviceIdType.OPEN_UDID;
        } else if (typeString.equals(DeviceIdType.TEMPORARY_ID.toString())) {
            return DeviceIdType.TEMPORARY_ID;
        } else {
            L.e("[DeviceId-int] device ID type can't be determined, [" + typeString + "]");
            return null;
        }
    }
    protected String getCurrentId() {
        assert id != null;
        assert type != null;
        if (id == null && type == DeviceIdType.OPEN_UDID) {
            //using openUDID as a fallback
            id = openUDIDProvider.getOpenUDID();
        }
        return id;
    }
    /**
     * Used only for tests
     *
     * @param setType
     * @param setId
     */
    @SuppressWarnings("SameParameterValue")
    protected void setId(@NonNull DeviceIdType setType, @NonNull String setId) {
        assert setId != null;
        assert setType != null;
        L.v("[DeviceId-int] setId, Device ID is " + setId + " (type " + setType + ")");
        this.type = setType;
        this.id = setId;
    }
    /**
     * If a value is provided, it will take precedence and will not matter what the type is
     *
     * @param deviceId
     */
    protected void changeToCustomId(@NonNull String deviceId) {
        assert deviceId != null;
        L.v("[DeviceId-int] changeToCustomId, current Device ID is [" + id + "] new ID is[" + deviceId + "]");
        setAndStoreId(DeviceIdType.DEVELOPER_SUPPLIED, deviceId);
    }
    protected void enterTempIDMode() {
        L.v("[DeviceId-int] enterTempIDMode");
        setAndStoreId(DeviceIdType.TEMPORARY_ID, ly.count.android.sdk.DeviceId.temporaryCountlyDeviceId);
    }
    void setAndStoreId(@NonNull DeviceIdType setType, @NonNull String setDeviceId) {
        assert setType != null;
        assert setDeviceId != null;
        this.id = setDeviceId;
        this.type = setType;
        storageProvider.setDeviceID(setDeviceId);
        storageProvider.setDeviceIDType(setType.toString());
    }
    /**
     * Returns the current type which would be returned to the developer
     *
     * @return Currently used device ID type
     */
    protected DeviceIdType getType() {
        assert type != null;
        return type;
    }
    /**
     * Checks if temporary device ID mode is enabled by checking the currently set ID
     *
     * @return
     */
    protected boolean isTemporaryIdModeEnabled() {
        String id = getCurrentId();
        if (id == null) {
            return false;
        }
        return id.equals(temporaryCountlyDeviceId);
    }
}
package ly.count.android.sdk;
import android.content.Intent;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.util.DisplayMetrics;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.json.JSONArray;
import org.json.JSONObject;
public class ModuleContent extends ModuleBase {
    private final ImmediateRequestGenerator iRGenerator;
    Content contentInterface;
    CountlyTimer countlyTimer;
    private boolean shouldFetchContents = false;
    private final int zoneTimerInterval;
    private final ContentCallback globalContentCallback;
    static int waitForDelay = 0;
    ModuleContent(@NonNull Countly cly, @NonNull CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleContent] Initialising");
        iRGenerator = config.immediateRequestGenerator;
        contentInterface = new Content();
        countlyTimer = new CountlyTimer();
        zoneTimerInterval = config.content.zoneTimerInterval;
        globalContentCallback = config.content.globalContentCallback;
    }
    void fetchContentsInternal(@NonNull String[] categories) {
        L.d("[ModuleContent] fetchContentsInternal, shouldFetchContents: [" + shouldFetchContents + "], categories: [" + Arrays.toString(categories) + "]");
        DisplayMetrics displayMetrics = deviceInfo.mp.getDisplayMetrics(_cly.context_);
        String requestData = prepareContentFetchRequest(displayMetrics, categories);
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        iRGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk/content", cp, false, networkingIsEnabled, checkResponse -> {
            L.d("[ModuleContent] fetchContentsInternal, processing fetched contents, received response is :[" + checkResponse + "]");
            if (checkResponse == null) {
                return;
            }
            try {
                if (validateResponse(checkResponse)) {
                    L.d("[ModuleContent] fetchContentsInternal, got new content data, showing it");
                    Map<Integer, TransparentActivityConfig> placementCoordinates = parseContent(checkResponse, displayMetrics);
                    if (placementCoordinates.isEmpty()) {
                        L.d("[ModuleContent] fetchContentsInternal, placement coordinates are empty, skipping");
                        return;
                    }
                    Intent intent = new Intent(_cly.context_, TransparentActivity.class);
                    intent.putExtra(TransparentActivity.CONFIGURATION_LANDSCAPE, placementCoordinates.get(Configuration.ORIENTATION_LANDSCAPE));
                    intent.putExtra(TransparentActivity.CONFIGURATION_PORTRAIT, placementCoordinates.get(Configuration.ORIENTATION_PORTRAIT));
                    intent.putExtra(TransparentActivity.ORIENTATION, _cly.context_.getResources().getConfiguration().orientation);
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    _cly.context_.startActivity(intent);
                    shouldFetchContents = false; // disable fetching contents until the next time, this will disable the timer fetching
                } else {
                    L.w("[ModuleContent] fetchContentsInternal, response is not valid, skipping");
                }
            } catch (Exception ex) {
                L.e("[ModuleContent] fetchContentsInternal, Encountered internal issue while trying to fetch contents, [" + ex + "]");
            }
        }, L);
    }
    void registerForContentUpdates(@Nullable String[] categories) {
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.w("[ModuleContent] registerForContentUpdates, temporary device ID is enabled, skipping");
            return;
        }
        String[] validCategories;
        if (categories == null) {
            L.w("[ModuleContent] registerForContentUpdates, categories is null, providing empty array");
            validCategories = new String[] {};
        } else {
            validCategories = categories;
        }
        countlyTimer.startTimer(zoneTimerInterval, () -> {
            L.d("[ModuleContent] registerForContentUpdates, waitForDelay: [" + waitForDelay + "], shouldFetchContents: [" + shouldFetchContents + "], categories: [" + Arrays.toString(validCategories) + "]");
            if (waitForDelay > 0) {
                waitForDelay--;
                return;
            }
            if (!shouldFetchContents) {
                L.w("[ModuleContent] registerForContentUpdates, shouldFetchContents is false, skipping");
                return;
            }
            fetchContentsInternal(validCategories);
        }, L);
    }
    @NonNull
    private String prepareContentFetchRequest(@NonNull DisplayMetrics displayMetrics, @NonNull String[] categories) {
        Resources resources = _cly.context_.getResources();
        int currentOrientation = resources.getConfiguration().orientation;
        boolean portrait = currentOrientation == Configuration.ORIENTATION_PORTRAIT;
        int scaledWidth = (int) Math.ceil(displayMetrics.widthPixels / displayMetrics.density);
        int scaledHeight = (int) Math.ceil(displayMetrics.heightPixels / displayMetrics.density);
        // this calculation needs improvement for status bar and navigation bar
        int portraitWidth = portrait ? scaledWidth : scaledHeight;
        int portraitHeight = portrait ? scaledHeight : scaledWidth;
        int landscapeWidth = portrait ? scaledHeight : scaledWidth;
        int landscapeHeight = portrait ? scaledWidth : scaledHeight;
        String language = Locale.getDefault().getLanguage().toLowerCase();
        return requestQueueProvider.prepareFetchContents(portraitWidth, portraitHeight, landscapeWidth, landscapeHeight, categories, language);
    }
    boolean validateResponse(@NonNull JSONObject response) {
        return response.has("geo");
        //boolean success = response.optString("result", "error").equals("success");
        //JSONArray content = response.optJSONArray("content");
        //return success && content != null && content.length() > 0;
    }
    @NonNull
    Map<Integer, TransparentActivityConfig> parseContent(@NonNull JSONObject response, @NonNull DisplayMetrics displayMetrics) {
        Map<Integer, TransparentActivityConfig> placementCoordinates = new ConcurrentHashMap<>();
        JSONArray contents = response.optJSONArray("content");
        //assert contents != null; TODO enable later
        JSONObject contentObj = response; //contents.optJSONObject(0); TODO this will be changed
        assert contentObj != null;
        String content = contentObj.optString("html");
        JSONObject coordinates = contentObj.optJSONObject("geo");
        assert coordinates != null;
        placementCoordinates.put(Configuration.ORIENTATION_PORTRAIT, extractOrientationPlacements(coordinates, displayMetrics.density, "p", content));
        placementCoordinates.put(Configuration.ORIENTATION_LANDSCAPE, extractOrientationPlacements(coordinates, displayMetrics.density, "l", content));
        return placementCoordinates;
    }
    private TransparentActivityConfig extractOrientationPlacements(@NonNull JSONObject placements, float density, @NonNull String orientation, @NonNull String content) {
        if (placements.has(orientation)) {
            JSONObject orientationPlacements = placements.optJSONObject(orientation);
            assert orientationPlacements != null;
            int x = orientationPlacements.optInt("x");
            int y = orientationPlacements.optInt("y");
            int w = orientationPlacements.optInt("w");
            int h = orientationPlacements.optInt("h");
            L.d("[ModuleContent] extractOrientationPlacements, orientation: [" + orientation + "], x: [" + x + "], y: [" + y + "], w: [" + w + "], h: [" + h + "]");
            TransparentActivityConfig config = new TransparentActivityConfig((int) Math.ceil(x * density), (int) Math.ceil(y * density), (int) Math.ceil(w * density), (int) Math.ceil(h * density));
            config.url = content;
            // TODO, passing callback with an intent is impossible, need to find a way to pass it
            // Currently, the callback is set as a static variable in TransparentActivity
            TransparentActivity.globalContentCallback = globalContentCallback;
            return config;
        }
        return null;
    }
    @Override
    void halt() {
        contentInterface = null;
        countlyTimer.stopTimer(L);
        countlyTimer = null;
    }
    private void optOutFromContent() {
        exitContentZoneInternal();
        shouldFetchContents = false;
    }
    @Override
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
        L.d("[ModuleContent] onConsentChanged, consentChangeDelta: [" + consentChangeDelta + "], newConsent: [" + newConsent + "], changeSource: [" + changeSource + "]");
        if (consentChangeDelta.contains(Countly.CountlyFeatureNames.content) && !newConsent) {
            optOutFromContent();
        }
    }
    @Override
    void deviceIdChanged(boolean withoutMerge) {
        L.d("[ModuleContent] deviceIdChanged, withoutMerge: [" + withoutMerge + "]");
        if (withoutMerge) {
            optOutFromContent();
        }
    }
    protected void exitContentZoneInternal() {
        shouldFetchContents = false;
        countlyTimer.stopTimer(L);
    }
    public class Content {
        /**
         * Opt in user for the content fetching and updates
         *
         * @param categories categories for the content
         * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
         */
        private void enterContentZone(@Nullable String... categories) {
            L.d("[ModuleContent] openForContent, categories: [" + Arrays.toString(categories) + "]");
            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {
                L.w("[ModuleContent] openForContent, Consent is not granted, skipping");
                return;
            }
            shouldFetchContents = true;
            registerForContentUpdates(categories);
        }
        /**
         * Opt in user for the content fetching and updates
         *
         * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
         */
        public void enterContentZone() {
            enterContentZone(new String[] {});
        }
        /**
         * Opt out user from the content fetching and updates
         *
         * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
         */
        public void exitContentZone() {
            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {
                L.w("[ModuleContent] exitFromContent, Consent is not granted, skipping");
                return;
            }
            exitContentZoneInternal();
        }
        /**
         * Change the content that is being shown
         *
         * @param categories categories for the content
         * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
         */
        private void changeContent(@Nullable String... categories) {
            L.d("[ModuleContent] changeContent, categories: [" + Arrays.toString(categories) + "]");
            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.content)) {
                L.w("[ModuleContent] changeContent, Consent is not granted, skipping");
                return;
            }
            registerForContentUpdates(categories);
        }
    }
}
package ly.count.android.sdk;
import android.annotation.SuppressLint;
import android.os.Build;
import android.util.Log;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class PerformanceCounterCollector {
    HashMap<String, Double> perfCounter = new HashMap<String, Double>();
    public void Clear() {
        perfCounter.clear();
    }
    public void TrackCounterTimeNs(String key, long valueNs) {
        TrackCounter(key, valueNs / 1_000_000_000.0);
    }
    public void TrackCounter(String key, double value) {
        assert Utils.isNotNullOrEmpty(key);
        if (value < 0) {
            Log.w("Countly", "Problem, we should only log positive values");
        }
        Double retrievedValue = perfCounter.get(key);
        if (retrievedValue == null) {
            retrievedValue = 0.0;
        }
        retrievedValue += value;
        perfCounter.put(key, retrievedValue);
    }
    public String ReturnResults() {
        List<String> entries = new ArrayList<>(perfCounter.size());
        //create all string entries
        for (Map.Entry<String, Double> entry : perfCounter.entrySet()) {
            String key = entry.getKey();
            Double value = entry.getValue();
            @SuppressLint("DefaultLocale")
            String strValue = String.format("%.6f", value);
            entries.add(key + " - " + strValue + "\n");
        }
        //sort if possible
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            entries.sort(String::compareTo);
        }
        //combine into printable String
        StringBuilder res = new StringBuilder();
        for (String s : entries) {
            res.append(s);
        }
        return res.toString();
    }
}
package ly.count.android.sdk;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.HashMap;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.Mockito.mock;
@RunWith(AndroidJUnit4.class)
public class ModuleConfigurationTests {
    CountlyStore countlyStore;
    @Before
    public void setUp() {
        countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
    }
    @After
    public void tearDown() {
    }
    /**
     * Default values when server config is disabled and storage is empty
     * No server connection
     */
    @Test
    public void init_disabled_storageEmpty() {
        countlyStore.clear();
        CountlyConfig config = TestUtils.createConfigurationConfig(false, null);
        Countly countly = (new Countly()).init(config);
        Assert.assertFalse(countly.moduleConfiguration.serverConfigEnabled);
        Assert.assertNull(countlyStore.getServerConfig());
        assertConfigDefault(countly);
    }
    /**
     * Default values when server config is enabled and storage is empty
     * No server connection
     */
    @Test
    public void init_enabled_storageEmpty() {
        CountlyConfig config = TestUtils.createConfigurationConfig(true, null);
        Countly countly = (new Countly()).init(config);
        Assert.assertTrue(countly.moduleConfiguration.serverConfigEnabled);
        Assert.assertNull(countlyStore.getServerConfig());
        assertConfigDefault(countly);
    }
    /**
     * Server config enabled
     * All config properties are default/allowing
     * No server connection
     *
     * @throws JSONException
     */
    @Test
    public void init_enabled_storageAllowing() throws JSONException {
        countlyStore.setServerConfig(getStorageString(true, true));
        CountlyConfig config = TestUtils.createConfigurationConfig(true, null);
        Countly countly = (new Countly()).init(config);
        Assert.assertTrue(countly.moduleConfiguration.serverConfigEnabled);
        Assert.assertNotNull(countlyStore.getServerConfig());
        assertConfigDefault(countly);
    }
    /**
     * Server config enabled
     * All config properties are off default/disabling
     * No server connection
     *
     * @throws JSONException
     */
    @Test
    public void init_enabled_storageForbidding() throws JSONException {
        countlyStore.setServerConfig(getStorageString(false, false));
        CountlyConfig config = TestUtils.createConfigurationConfig(true, null);
        Countly countly = (new Countly()).init(config);
        Assert.assertTrue(countly.moduleConfiguration.serverConfigEnabled);
        Assert.assertNotNull(countlyStore.getServerConfig());
        Assert.assertFalse(countly.moduleConfiguration.getNetworkingEnabled());
        Assert.assertFalse(countly.moduleConfiguration.getTrackingEnabled());
    }
    /**
     * Server config disabled
     * All config properties are default/allowing
     * No server connection
     *
     * @throws JSONException
     */
    @Test
    public void init_disabled_storageAllowing() throws JSONException {
        countlyStore.setServerConfig(getStorageString(true, true));
        CountlyConfig config = TestUtils.createConfigurationConfig(false, null);
        Countly countly = Countly.sharedInstance().init(config);
        Assert.assertFalse(countly.moduleConfiguration.serverConfigEnabled);
        Assert.assertNotNull(countlyStore.getServerConfig());
        assertConfigDefault(countly);
    }
    /**
     * Server config disabled
     * All config properties are off default/disabling
     * No server connection
     *
     * @throws JSONException
     */
    @Test
    public void init_disabled_storageForbidding() throws JSONException {
        countlyStore.setServerConfig(getStorageString(false, false));
        CountlyConfig config = TestUtils.createConfigurationConfig(false, null);
        Countly countly = (new Countly()).init(config);
        Assert.assertFalse(countly.moduleConfiguration.serverConfigEnabled);
        Assert.assertNotNull(countlyStore.getServerConfig());
        assertConfigDefault(countly);
    }
    /**
     * Making sure that a downloaded configuration is persistently stored across init's
     */
    @Test
    public void scenario_1() {
        //initial state is fresh
        Assert.assertNull(countlyStore.getServerConfig());
        //first init fails receiving config, config getters return defaults, store is empty
        initAndValidateConfigParsingResult(null, false);
        //second init succeeds receiving config
        Countly countly = initAndValidateConfigParsingResult("{'v':1,'t':2,'c':{'tracking':false,'networking':false}}", true);
        Assert.assertFalse(countly.moduleConfiguration.getNetworkingEnabled());
        Assert.assertFalse(countly.moduleConfiguration.getTrackingEnabled());
        //third init is lacking a connection but still has the previously saved values
        CountlyConfig config = TestUtils.createConfigurationConfig(true, null);
        countly = new Countly().init(config);
        Assert.assertFalse(countly.moduleConfiguration.getNetworkingEnabled());
        Assert.assertFalse(countly.moduleConfiguration.getTrackingEnabled());
        //fourth init updates config values
        countly = initAndValidateConfigParsingResult("{'v':1,'t':2,'c':{'tracking':true,'networking':false}}", true);
        Assert.assertFalse(countly.moduleConfiguration.getNetworkingEnabled());
        Assert.assertTrue(countly.moduleConfiguration.getTrackingEnabled());
    }
    /**
     * With tracking disabled, nothing should be written to the request and event queues
     */
    @Test
    public void validatingTrackingConfig() throws JSONException {
        //nothing in queues initially
        Assert.assertEquals("", countlyStore.getRequestQueueRaw());
        Assert.assertEquals(0, countlyStore.getEvents().length);
        countlyStore.setServerConfig(getStorageString(false, false));
        CountlyConfig config = TestUtils.createConfigurationConfig(true, null);
        Countly countly = (new Countly()).init(config);
        Assert.assertFalse(countly.moduleConfiguration.getNetworkingEnabled());
        Assert.assertFalse(countly.moduleConfiguration.getTrackingEnabled());
        //try events
        countly.events().recordEvent("d");
        countly.events().recordEvent("1");
        //try a non event recording
        countly.crashes().recordHandledException(new Exception());
        //try a direct request
        countly.requestQueue().addDirectRequest(new HashMap<>());
        countly.requestQueue().attemptToSendStoredRequests();
        Assert.assertEquals("", countlyStore.getRequestQueueRaw());
        Assert.assertEquals(0, countlyStore.getEvents().length);
    }
    /**
     * Making sure that bad config responses are rejected
     */
    @Test
    public void init_enabled_rejectingRequests() {
        //{"v":1,"t":2,"c":{"aa":"bb"}}
        Assert.assertNull(countlyStore.getServerConfig());
        //return null object
        initAndValidateConfigParsingResult(null, false);
        //return empty object
        initAndValidateConfigParsingResult("{}", false);
        //returns all except 'v'
        initAndValidateConfigParsingResult("{'t':2,'c':{'aa':'bb'}}", false);
        //returns all except 't'
        initAndValidateConfigParsingResult("{'v':1,'c':{'aa':'bb'}}", false);
        //returns all except 'c'
        initAndValidateConfigParsingResult("{'v':1,'t':2}", false);
        //returns all except 'c' wrong type (number)
        initAndValidateConfigParsingResult("{'v':1,'t':2,'c':123}", false);
        //returns all except 'c' wrong type (bool)
        initAndValidateConfigParsingResult("{'v':1,'t':2,'c':false}", false);
        //returns all except 'c' wrong type (string)
        initAndValidateConfigParsingResult("{'v':1,'t':2,'c':'fdf'}", false);
    }
    Countly initAndValidateConfigParsingResult(String targetResponse, boolean responseAccepted) {
        CountlyConfig config = TestUtils.createConfigurationConfig(true, createIRGForSpecificResponse(targetResponse));
        Countly countly = (new Countly()).init(config);
        if (!responseAccepted) {
            Assert.assertNull(countlyStore.getServerConfig());
            assertConfigDefault(countly);
        } else {
            Assert.assertNotNull(countlyStore.getServerConfig());
        }
        return countly;
    }
    void assertConfigDefault(Countly countly) {
        Assert.assertTrue(countly.moduleConfiguration.getNetworkingEnabled());
        Assert.assertTrue(countly.moduleConfiguration.getTrackingEnabled());
    }
    ImmediateRequestGenerator createIRGForSpecificResponse(final String targetResponse) {
        return new ImmediateRequestGenerator() {
            @Override public ImmediateRequestI CreateImmediateRequestMaker() {
                return new ImmediateRequestI() {
                    @Override public void doWork(String requestData, String customEndpoint, ConnectionProcessor cp, boolean requestShouldBeDelayed, boolean networkingIsEnabled, ImmediateRequestMaker.InternalImmediateRequestCallback callback, ModuleLog log) {
                        if (targetResponse == null) {
                            callback.callback(null);
                            return;
                        }
                        JSONObject jobj = null;
                        try {
                            jobj = new JSONObject(targetResponse);
                        } catch (JSONException e) {
                            e.printStackTrace();
                        }
                        callback.callback(jobj);
                    }
                };
            }
        };
    }
    //creates the stringified storage object with all the required properties
    String getStorageString(boolean tracking, boolean networking) throws JSONException {
        JSONObject jsonObject = new JSONObject();
        JSONObject jsonObjectConfig = new JSONObject();
        jsonObjectConfig.put("tracking", tracking);
        jsonObjectConfig.put("networking", networking);
        jsonObject.put("v", 1);
        jsonObject.put("t", 1_681_808_287_464L);
        jsonObject.put("c", jsonObjectConfig);
        return jsonObject.toString();
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import org.json.JSONException;
import org.json.JSONObject;
class ModuleConfiguration extends ModuleBase implements ConfigurationProvider {
    ImmediateRequestGenerator immediateRequestGenerator;
    boolean serverConfigEnabled = false;
    JSONObject latestRetrievedConfigurationFull = null;
    JSONObject latestRetrievedConfiguration = null;
    //config keys
    final static String keyTracking = "tracking";
    final static String keyNetworking = "networking";
    //request keys
    final static String keyRTimestamp = "t";
    final static String keyRVersion = "v";
    final static String keyRConfig = "c";
    final static boolean defaultVTracking = true;
    final static boolean defaultVNetworking = true;
    boolean currentVTracking = true;
    boolean currentVNetworking = true;
    boolean configurationFetched = false;
    ModuleConfiguration(@NonNull Countly cly, @NonNull CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleConfiguration] Initialising");
        config.configProvider = this;
        configProvider = this;
        serverConfigEnabled = config.serverConfigurationEnabled;
        immediateRequestGenerator = config.immediateRequestGenerator;
        config.countlyStore.setConfigurationProvider(this);
        if (serverConfigEnabled) {
            //load the previously saved configuration
            loadConfigFromStorage();
            //update the config variables according to the new state
            updateConfigVariables();
        }
    }
    @Override
    void initFinished(@NonNull final CountlyConfig config) {
        if (serverConfigEnabled) {
            //once the SDK has loaded, init fetching the server config
            fetchConfigFromServer();
        }
    }
    @Override
    void halt() {
    }
    /**
     * Reads from storage to local json objects
     */
    void loadConfigFromStorage() {
        String sConfig = storageProvider.getServerConfig();
        L.v("[ModuleConfiguration] loadConfigFromStorage, [" + sConfig + "]");
        if (sConfig == null || sConfig.isEmpty()) {
            L.d("[ModuleConfiguration] loadStoredConfig, no configs persistently stored");
            return;
        }
        try {
            latestRetrievedConfigurationFull = new JSONObject(sConfig);
            latestRetrievedConfiguration = latestRetrievedConfigurationFull.getJSONObject(keyRConfig);
            L.d("[ModuleConfiguration] loadStoredConfig, stored config loaded [" + sConfig + "]");
        } catch (JSONException e) {
            L.w("[ModuleConfiguration] loadStoredConfig, failed to parse, " + e);
            latestRetrievedConfigurationFull = null;
            latestRetrievedConfiguration = null;
        }
    }
    //update the config variables according to the current config obj state
    void updateConfigVariables() {
        L.v("[ModuleConfiguration] updateConfigVariables");
        //set all to defaults
        currentVNetworking = defaultVNetworking;
        currentVTracking = defaultVTracking;
        if (latestRetrievedConfiguration == null) {
            //no config, don't continue
            return;
        }
        //networking
        if (latestRetrievedConfiguration.has(keyNetworking)) {
            try {
                currentVNetworking = latestRetrievedConfiguration.getBoolean(keyNetworking);
            } catch (JSONException e) {
                L.w("[ModuleConfiguration] updateConfigs, failed to load 'networking', " + e);
            }
        }
        //tracking
        if (latestRetrievedConfiguration.has(keyTracking)) {
            try {
                currentVTracking = latestRetrievedConfiguration.getBoolean(keyTracking);
            } catch (JSONException e) {
                L.w("[ModuleConfiguration] updateConfigs, failed to load 'tracking', " + e);
            }
        }
    }
    void saveAndStoreDownloadedConfig(@NonNull JSONObject config) {
        L.v("[ModuleConfiguration] saveAndStoreDownloadedConfig");
        if (!config.has(keyRVersion)) {
            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'version' field. Config will be ignored.");
            return;
        }
        if (!config.has(keyRTimestamp)) {
            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'timestamp' field. Config will be ignored.");
            return;
        }
        if (!config.has(keyRConfig)) {
            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Retrieved configuration does not has a 'configuration' field. Config will be ignored.");
            return;
        }
        //at this point it is a valid response
        latestRetrievedConfigurationFull = config;
        String configAsString = null;
        try {
            latestRetrievedConfiguration = config.getJSONObject(keyRConfig);
            configAsString = config.toString();
        } catch (JSONException e) {
            latestRetrievedConfigurationFull = null;
            latestRetrievedConfiguration = null;
            L.w("[ModuleConfiguration] saveAndStoreDownloadedConfig, Failed retrieving internal config, " + e);
            return;
        }
        //save to storage
        storageProvider.setServerConfig(configAsString);
        //update config variables
        updateConfigVariables();
    }
    /**
     * Perform network request for retrieving latest config
     * If valid config is downloaded, save it, and update the values
     *
     * Example response:
     * {
     * "v":1,
     * "t":1681808287464,
     * "c":{
     * "tracking":false,
     * "networking":false,
     * "crashes":false,
     * "views":false,
     * "heartbeat":61,
     * "event_queue":11,
     * "request_queue":1001
     * }
     * }
     */
    void fetchConfigFromServer() {
        L.v("[ModuleConfiguration] fetchConfigFromServer");
        if (!serverConfigEnabled) {
            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, server config is disabled");
            return;
        }
        // why _cly? because module configuration is created before module device id, so we need to access it like this
        // call order to module device id is after module configuration and device id provider is module device id
        if (_cly.config_.deviceIdProvider.isTemporaryIdEnabled()) {
            //temporary id mode enabled, abort
            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, temporary device ID mode is set");
            return;
        }
        if (configurationFetched) {
            L.d("[ModuleConfiguration] fetchConfigFromServer, fetch config from the server is aborted, config already fetched");
            return;
        }
        configurationFetched = true;
        String requestData = requestQueueProvider.prepareServerConfigRequest();
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        immediateRequestGenerator.CreateImmediateRequestMaker().doWork(requestData, "/o/sdk", cp, false, true, checkResponse -> {
            if (checkResponse == null) {
                L.w("[ModuleConfiguration] Not possible to retrieve configuration data. Probably due to lack of connection to the server");
                return;
            }
            L.d("[ModuleConfiguration] Retrieved configuration response: [" + checkResponse.toString() + "]");
            saveAndStoreDownloadedConfig(checkResponse);
        }, L);
    }
    // configuration getters
    @Override
    public boolean getNetworkingEnabled() {
        if (!serverConfigEnabled) {
            return defaultVNetworking;
        }
        return currentVNetworking;
    }
    @Override
    public boolean getTrackingEnabled() {
        if (!serverConfigEnabled) {
            return defaultVTracking;
        }
        return currentVTracking;
    }
}
package ly.count.android.sdk;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.Map;
import ly.count.android.sdk.internal.RemoteConfigHelper;
import ly.count.android.sdk.internal.RemoteConfigValueStore;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static ly.count.android.sdk.RemoteConfigValueStoreTests.rcArrIntoJSON;
import static ly.count.android.sdk.RemoteConfigValueStoreTests.rcEStr;
import static org.mockito.Mockito.mock;
@RunWith(AndroidJUnit4.class)
public class ModuleRemoteConfigTests {
    CountlyStore countlyStore;
    @Before
    public void setUp() {
        Countly.sharedInstance().setLoggingEnabled(true);
        countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
        countlyStore.setDataSchemaVersion(MigrationHelper.DATA_SCHEMA_VERSIONS);
    }
    /**
     * Consent removal shouldn't clear stored remote config values
     */
    @Test
    public void valuesClearedOnConsentRemoval() {
        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting();
        config.setRequiresConsent(true);
        config.setConsentEnabled(new String[] { Countly.CountlyFeatureNames.remoteConfig });
        config.enableRemoteConfigValueCaching();
        config.enableRemoteConfigAutomaticTriggers();
        Countly countly = new Countly().init(config);
        //set RC
        String[] rcArr = { rcEStr("a", 123), rcEStr("b", "fg") };
        countlyStore.setRemoteConfigValues(RemoteConfigValueStore.dataFromString(rcArrIntoJSON(rcArr), false).dataToString());
        Assert.assertEquals(123, countly.remoteConfig().getValue("a").value);
        Assert.assertEquals("fg", countly.remoteConfig().getValue("b").value);
        countly.consent().removeConsentAll();
        Assert.assertEquals(2, countly.remoteConfig().getValues().size()); // values are cache cleared
        for (Map.Entry<String, RCData> kv : countly.remoteConfig().getValues().entrySet()) {
            Assert.assertTrue(kv.getValue().isCurrentUsersData);
        }
    }
    /**
     * Making sure that automatic RC is triggered on the right requests
     * Some differences apply depending on if consent is required or isn't
     */
    @Test
    public void automaticRCTriggers() {
        for (int a = 0; a < 2; a++) {
            countlyStore.clear();
            final int[] triggerCounter = { 0 };
            int intendedCount = 0;
            CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting().disableHealthCheck();
            config.disableHealthCheck();//mocked tests fail without disabling this
            config.enableRemoteConfigAutomaticTriggers();
            if (a == 0) {
                config.setRequiresConsent(true);
                config.setConsentEnabled(new String[] { Countly.CountlyFeatureNames.remoteConfig });
            }
            config.immediateRequestGenerator = () -> (ImmediateRequestI) (requestData, customEndpoint, cp, requestShouldBeDelayed, networkingIsEnabled, callback, log) -> {
                triggerCounter[0]++;
            };
            Countly countly = (new Countly()).init(config);
            Assert.assertEquals(++intendedCount, triggerCounter[0]);//init should create a request
            countly.consent().removeConsentAll();
            Assert.assertEquals(intendedCount, triggerCounter[0]);//consent removal does nothing
            countly.consent().giveConsent(new String[] { Countly.CountlyFeatureNames.remoteConfig });
            if (a == 0) {
                Assert.assertEquals(++intendedCount, triggerCounter[0]);//giving consent should create a request
            } else {
                Assert.assertEquals(intendedCount, triggerCounter[0]);//giving consent would not create a request if no consent is required
            }
            countly.deviceId().changeWithMerge("dd");
            Assert.assertEquals(++intendedCount, triggerCounter[0]);//changing device ID with merging should create a request
            countly.deviceId().changeWithoutMerge("dd11");
            if (a == 0) {
                Assert.assertEquals(intendedCount, triggerCounter[0]);//changing device ID without merging won't create a request because all consents are revoked
            } else {
                Assert.assertEquals(++intendedCount, triggerCounter[0]);//changing device ID without merging would create a request because consent is not required
            }
            countly.deviceId().enableTemporaryIdMode();
            Assert.assertEquals(intendedCount, triggerCounter[0]);//entering tempID mode should not create a request
            countly.deviceId().changeWithMerge("dd");
            if (a == 0) {
                Assert.assertEquals(intendedCount, triggerCounter[0]);//exiting temp ID mode with "withMerge" should create a request, but would not since there is no consent
            } else {
                Assert.assertEquals(++intendedCount, triggerCounter[0]);//exiting temp ID mode with "withMerge" should create a request since consent mode is not prohibiting it
            }
            countly.deviceId().enableTemporaryIdMode();
            Assert.assertEquals(intendedCount, triggerCounter[0]);//entering tempID mode should not create a request
            countly.deviceId().changeWithoutMerge("dd");
            if (a == 0) {
                Assert.assertEquals(intendedCount, triggerCounter[0]);//exiting temp ID mode with "withoutMerge" should create a request, but would not since there is no consent
            } else {
                Assert.assertEquals(++intendedCount, triggerCounter[0]);//exiting temp ID mode with "withoutMerge" should create a request since consent mode is not prohibiting it
            }
        }
    }
    /**
     * Making sure that caching occurs on the required actions and with the required config options
     * Creating a "matrix" that goes over combinations of RC config flags and consent
     */
    @Test
    public void rcValueCaching() {
        boolean valuesAreCached = false;
        for (int a = 0; a < 4; a++) {
            countlyStore.clear();
            CountlyConfig config = TestUtils.createBaseConfig();
            config.enableRemoteConfigAutomaticTriggers();
            if (a == 0 || a == 1) {
                config.setRequiresConsent(true);
                config.setConsentEnabled(new String[] { Countly.CountlyFeatureNames.remoteConfig });
            }
            if (a == 0 || a == 2) {
                config.enableRemoteConfigValueCaching();
                valuesAreCached = true;
            }
            Countly countly = new Countly().init(config);
            Assert.assertEquals(0, countly.remoteConfig().getValues().size());
            String[] rcArr = new String[] { rcEStr("a", 123), rcEStr("b", "fg") };
            countlyStore.setRemoteConfigValues(RemoteConfigValueStore.dataFromString(rcArrIntoJSON(rcArr), false).dataToString());
            Assert.assertEquals(2, countly.remoteConfig().getValues().size());
            assertCValueCachedState(countly.remoteConfig().getValues(), false);
            //changing with merging should trigger caching
            countly.deviceId().changeWithMerge("dd");
            assertCValueCachedState(countly.remoteConfig().getValues(), valuesAreCached);
            //changing without merging should trigger caching. Lack of consent should leave no impact on this
            assertCValueCachedState(countly.remoteConfig().getValues(), valuesAreCached);
            countly.deviceId().changeWithoutMerge("dd11");
            for (int b = 0; b < 2; b++) {
                if (b == 1) {
                    countly.consent().giveConsent(new String[] { Countly.CountlyFeatureNames.remoteConfig });
                }
                if (a == 0 || a == 2) {
                    //we preserve
                    Assert.assertEquals(2, countly.remoteConfig().getValues().size());
                    assertCValueCachedState(countly.remoteConfig().getValues(), true);
                    Assert.assertEquals(123, countly.remoteConfig().getValue("a").value);
                    Assert.assertEquals("fg", countly.remoteConfig().getValue("b").value);
                } else {
                    Assert.assertEquals(0, countly.remoteConfig().getValues().size());
                }
            }
            //entering temp ID mode should trigger caching. Lack of consent should leave no impact on this
            countlyStore.setRemoteConfigValues(RemoteConfigValueStore.dataFromString(rcArrIntoJSON(rcArr), false).dataToString());
            countly.deviceId().enableTemporaryIdMode();
            for (int b = 0; b < 2; b++) {
                if (b == 1) {
                    countly.consent().giveConsent(new String[] { Countly.CountlyFeatureNames.remoteConfig });
                }
                if (a == 0 || a == 2) {
                    Assert.assertEquals(2, countly.remoteConfig().getValues().size());
                    assertCValueCachedState(countly.remoteConfig().getValues(), true);
                    Assert.assertEquals(123, countly.remoteConfig().getValue("a").value);
                    Assert.assertEquals("fg", countly.remoteConfig().getValue("b").value);
                } else {
                    Assert.assertEquals(0, countly.remoteConfig().getValues().size());
                }
            }
            valuesAreCached = false;
        }
    }
    @Test
    public void validateValuePersistence() {
        //set RC
        String[] rcArr = new String[] { rcEStr("a", 123), rcEStr("b", "fg") };
        countlyStore.setRemoteConfigValues(RemoteConfigValueStore.dataFromString(rcArrIntoJSON(rcArr), false).dataToString());
        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting();
        config.enableRemoteConfigValueCaching();
        Countly countly = new Countly().init(config);
        Assert.assertEquals(123, countly.remoteConfig().getValue("a").value);
        Assert.assertEquals("fg", countly.remoteConfig().getValue("b").value);
        Countly countly2 = new Countly().init(config);
        Assert.assertEquals(123, countly2.remoteConfig().getValue("a").value);
        Assert.assertEquals("fg", countly2.remoteConfig().getValue("b").value);
    }
    /**
     * Validate the the new and old clears are clearing values after they are directly put into storage
     */
    @Test
    public void validateClear() {
        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting();
        config.enableRemoteConfigValueCaching();
        Countly countly = new Countly().init(config);
        //set RC
        String[] rcArr = new String[] { rcEStr("a", 123), rcEStr("b", "fg") };
        countlyStore.setRemoteConfigValues(RemoteConfigValueStore.dataFromString(rcArrIntoJSON(rcArr), false).dataToString());
        Assert.assertEquals(123, countly.remoteConfig().getValue("a").value);
        Assert.assertEquals("fg", countly.remoteConfig().getValue("b").value);
        countly.remoteConfig().clearAll();
        Assert.assertEquals(0, countly.remoteConfig().getValues().size());
        countlyStore.setRemoteConfigValues(RemoteConfigValueStore.dataFromString(rcArrIntoJSON(rcArr), false).dataToString());
        Assert.assertEquals(123, countly.remoteConfig().getValue("a").value);
        Assert.assertEquals("fg", countly.remoteConfig().getValue("b").value);
        countly.remoteConfig().clearStoredValues();
        Assert.assertEquals(0, countly.remoteConfig().getValues().size());
    }
    RCDownloadCallback createCallback(int index, int[] resArray) {
        RCDownloadCallback ret = new RCDownloadCallback() {
            @Override public void callback(RequestResult downloadResult, String error, boolean fullValueUpdate, Map<String, RCData> downloadedValues) {
                resArray[index]++;
            }
        };
        return ret;
    }
    /**
     * Validating that the RC callbacks are called for the appropriate actions
     */
    @Test
    public void rcGlobalCallback() {
        int[] resArray = new int[10];
        int cIndex = 0;
        RemoteConfigCallback oldRCC = error -> resArray[0]++;
        cIndex++;
        RCDownloadCallback c1 = createCallback(cIndex++, resArray);
        RCDownloadCallback c2 = createCallback(cIndex++, resArray);
        RCDownloadCallback c3 = createCallback(cIndex++, resArray);
        RCDownloadCallback c4 = createCallback(cIndex++, resArray);
        RCDownloadCallback c5 = createCallback(cIndex++, resArray);
        RCDownloadCallback c6 = createCallback(cIndex, resArray);
        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableRemoteConfigAutomaticTriggers();
        config.RemoteConfigRegisterGlobalCallback(c1);
        config.RemoteConfigRegisterGlobalCallback(c2);
        config.setRemoteConfigAutomaticDownload(true, oldRCC);
        config.immediateRequestGenerator = () -> (ImmediateRequestI) (requestData, customEndpoint, cp, requestShouldBeDelayed, networkingIsEnabled, callback, log) -> {
            callback.callback(null);
        };
        Countly countly = new Countly().init(config);
        //check initial global ones
        Assert.assertEquals(1, resArray[0]);
        Assert.assertEquals(1, resArray[1]);
        Assert.assertEquals(1, resArray[2]);
        Assert.assertEquals(0, resArray[3]);
        countly.remoteConfig().removeDownloadCallback(c1);
        countly.remoteConfig().registerDownloadCallback(c3);
        countly.remoteConfig().downloadAllKeys(c4);
        Assert.assertEquals(2, resArray[0]);
        Assert.assertEquals(1, resArray[1]);
        Assert.assertEquals(2, resArray[2]);
        Assert.assertEquals(1, resArray[3]);
        Assert.assertEquals(1, resArray[4]);
        countly.remoteConfig().downloadSpecificKeys(new String[] {}, c5);
        Assert.assertEquals(3, resArray[0]);
        Assert.assertEquals(1, resArray[1]);
        Assert.assertEquals(3, resArray[2]);
        Assert.assertEquals(2, resArray[3]);
        Assert.assertEquals(1, resArray[4]);
        Assert.assertEquals(1, resArray[5]);
        countly.remoteConfig().removeDownloadCallback(c1);
        countly.remoteConfig().downloadOmittingKeys(new String[] {}, c6);
        Assert.assertEquals(4, resArray[0]);
        Assert.assertEquals(1, resArray[1]);
        Assert.assertEquals(4, resArray[2]);
        Assert.assertEquals(3, resArray[3]);
        Assert.assertEquals(1, resArray[4]);
        Assert.assertEquals(1, resArray[5]);
        Assert.assertEquals(1, resArray[6]);
    }
    /**
     * Validate that the new and old getters return the correct values when putting them directly into storage
     *
     * @throws JSONException
     */
    @Test
    public void validateGetters() throws JSONException {
        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting();
        config.enableRemoteConfigValueCaching();
        Countly countly = new Countly().init(config);
        //set RC
        JSONArray jArrI = new JSONArray("[3,\"44\",5.1,7.7]");
        JSONObject jObjI = new JSONObject("{\"q\":6,\"w\":\"op\"}");
        String[] rcArr = new String[] { rcEStr("a", 123, false), rcEStr("b", "fg"), rcEStr("c", 222222222222L, false), rcEStr("d", 1.5d), rcEStr("e", jArrI, false), rcEStr("f", jObjI) };
        countlyStore.setRemoteConfigValues(RemoteConfigValueStore.dataFromString(rcArrIntoJSON(rcArr), false).dataToString());
        Assert.assertEquals(123, countly.remoteConfig().getValue("a").value);
        Assert.assertEquals(123, countly.remoteConfig().getValueAndEnroll("a").value);
        Assert.assertEquals(123, countly.remoteConfig().getValueForKey("a"));
        Assert.assertFalse(countly.remoteConfig().getValue("a").isCurrentUsersData);
        Assert.assertEquals("fg", countly.remoteConfig().getValue("b").value);
        Assert.assertEquals("fg", countly.remoteConfig().getValueAndEnroll("b").value);
        Assert.assertEquals("fg", countly.remoteConfig().getValueForKey("b"));
        Assert.assertTrue(countly.remoteConfig().getValue("b").isCurrentUsersData);
        Assert.assertEquals(222_222_222_222L, countly.remoteConfig().getValue("c").value);
        Assert.assertEquals(222_222_222_222L, countly.remoteConfig().getValueAndEnroll("c").value);
        Assert.assertEquals(222_222_222_222L, countly.remoteConfig().getValueForKey("c"));
        Assert.assertFalse(countly.remoteConfig().getValue("c").isCurrentUsersData);
        Assert.assertEquals(1.5d, countly.remoteConfig().getValue("d").value);
        Assert.assertEquals(1.5d, countly.remoteConfig().getValueAndEnroll("d").value);
        Assert.assertEquals(1.5d, countly.remoteConfig().getValueForKey("d"));
        Assert.assertTrue(countly.remoteConfig().getValue("d").isCurrentUsersData);
        Assert.assertEquals(jArrI.toString(), countly.remoteConfig().getValue("e").value.toString());
        Assert.assertEquals(jArrI.toString(), countly.remoteConfig().getValueAndEnroll("e").value.toString());
        Assert.assertEquals(jArrI.toString(), countly.remoteConfig().getValueForKey("e").toString());
        Assert.assertFalse(countly.remoteConfig().getValue("e").isCurrentUsersData);
        Assert.assertEquals(jObjI.toString(), countly.remoteConfig().getValue("f").value.toString());
        Assert.assertEquals(jObjI.toString(), countly.remoteConfig().getValueAndEnroll("f").value.toString());
        Assert.assertEquals(jObjI.toString(), countly.remoteConfig().getValueForKey("f").toString());
        Assert.assertTrue(countly.remoteConfig().getValue("f").isCurrentUsersData);
        Map<String, Object> valsOld = countly.remoteConfig().getAllValues();
        Map<String, RCData> valsNew = countly.remoteConfig().getValues();
        Map<String, RCData> valsNewEnroll = countly.remoteConfig().getAllValuesAndEnroll();
        Assert.assertEquals(valsNew.size(), valsOld.size());
        Assert.assertEquals(valsNew.size(), valsNewEnroll.size());
        // for getValues
        for (Map.Entry<String, RCData> entry : valsNew.entrySet()) {
            Object valN = entry.getValue().value;
            Object valO = valsOld.get(entry.getKey());
            if (valN instanceof JSONObject || valN instanceof JSONArray) {
                Assert.assertEquals(valN.toString(), valO.toString());
            } else {
                Assert.assertEquals(valN, valO);
            }
        }
        // for getAllValuesAndEnroll
        for (Map.Entry<String, RCData> entry : valsNewEnroll.entrySet()) {
            Object valN = entry.getValue().value;
            Object valO = valsOld.get(entry.getKey());
            if (valN instanceof JSONObject || valN instanceof JSONArray) {
                Assert.assertEquals(valN.toString(), valO.toString());
            } else {
                Assert.assertEquals(valN, valO);
            }
        }
    }
    /**
     * Just making sure nothing explodes when passing bad values
     */
    @Test
    public void passingBadValues() {
        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting();
        config.enableRemoteConfigValueCaching();
        config.enableRemoteConfigAutomaticTriggers();
        Countly countly = new Countly().init(config);
        countly.remoteConfig().getValue(null);
        countly.remoteConfig().getValue("");
        countly.remoteConfig().getValueAndEnroll(null);
        countly.remoteConfig().getValueAndEnroll("");
        countly.remoteConfig().getValueForKey(null);
        countly.remoteConfig().getValueForKey("");
        countly.remoteConfig().update(null);
        countly.remoteConfig().downloadAllKeys(null);
        countly.remoteConfig().downloadOmittingKeys(null, null);
        countly.remoteConfig().downloadOmittingKeys(new String[] {}, null);
        countly.remoteConfig().updateExceptKeys(null, null);
        countly.remoteConfig().updateExceptKeys(new String[] {}, null);
        countly.remoteConfig().downloadSpecificKeys(null, null);
        countly.remoteConfig().downloadSpecificKeys(new String[] {}, null);
        countly.remoteConfig().updateForKeysOnly(null, null);
        countly.remoteConfig().updateForKeysOnly(new String[] {}, null);
        countly.remoteConfig().enrollIntoABTestsForKeys(null);
        countly.remoteConfig().enrollIntoABTestsForKeys(new String[] {});
        countly.remoteConfig().exitABTestsForKeys(null);
        countly.remoteConfig().exitABTestsForKeys(new String[] {});
        countly.remoteConfig().testingGetVariantsForKey(null);
        countly.remoteConfig().testingGetVariantsForKey("");
        countly.remoteConfig().testingEnrollIntoVariant(null, null, null);
        countly.remoteConfig().testingEnrollIntoVariant("", "", null);
        countly.remoteConfig().testingDownloadVariantInformation(null);
        countly.remoteConfig().registerDownloadCallback(null);
        countly.remoteConfig().removeDownloadCallback(null);
    }
    /**
     * validating that 'prepareKeysIncludeExclude' works as expected
     */
    @Test
    public void validateKeyIncludeExclude() {
        //first a few cases with empty or null values
        String[] res = RemoteConfigHelper.prepareKeysIncludeExclude(null, null, mock(ModuleLog.class));
        Assert.assertNull(res[0]);
        Assert.assertNull(res[1]);
        res = RemoteConfigHelper.prepareKeysIncludeExclude(new String[0], new String[0], mock(ModuleLog.class));
        Assert.assertNull(res[0]);
        Assert.assertNull(res[1]);
        //setting first
        res = RemoteConfigHelper.prepareKeysIncludeExclude(new String[] { "a", "b" }, null, mock(ModuleLog.class));
        Assert.assertEquals("[\"a\",\"b\"]", res[0]);
        Assert.assertNull(res[1]);
        //setting second
        res = RemoteConfigHelper.prepareKeysIncludeExclude(null, new String[] { "c", "d" }, mock(ModuleLog.class));
        Assert.assertNull(res[0]);
        Assert.assertEquals("[\"c\",\"d\"]", res[1]);
        //setting both (include takes precedence)
        res = RemoteConfigHelper.prepareKeysIncludeExclude(new String[] { "e", "f" }, new String[] { "g", "h" }, mock(ModuleLog.class));
        Assert.assertEquals("[\"e\",\"f\"]", res[0]);
        Assert.assertNull(res[1]);
    }
    /**
     * validating that 'mergeCheckResponseIntoCurrentValues' works as expected
     * Simulating a few data updates, with and without clearing
     */
    @Test
    public void validateMergeReceivedResponse() throws Exception {
        CountlyConfig cc = new CountlyConfig(TestUtils.getContext(), "aaa", "http://www.aa.bb");
        Countly countly = new Countly();
        countly.init(cc);
        RemoteConfigValueStore rcvs1 = RemoteConfigValueStore.dataFromString("{\"a\": 123,\"b\": \"fg\"}", false);
        RemoteConfigValueStore rcvs2 = RemoteConfigValueStore.dataFromString("{\"b\": 33.44,\"c\": \"ww\"}", false);
        RemoteConfigValueStore rcvs3 = RemoteConfigValueStore.dataFromString("{\"t\": {},\"87\": \"yy\"}", false);
        //check initial state
        Map<String, Object> vals = countly.remoteConfig().getAllValues();
        Assert.assertNotNull(vals);
        Assert.assertEquals(0, vals.size());
        //add first values without clearing
        countly.moduleRemoteConfig.mergeCheckResponseIntoCurrentValues(false, RemoteConfigHelper.DownloadedValuesIntoMap(rcvs1.values));
        vals = countly.remoteConfig().getAllValues();
        Assert.assertEquals(2, vals.size());
        Assert.assertEquals(123, vals.get("a"));
        Assert.assertEquals("fg", vals.get("b"));
        //add second pair of values without clearing
        countly.moduleRemoteConfig.mergeCheckResponseIntoCurrentValues(false, RemoteConfigHelper.DownloadedValuesIntoMap(rcvs2.values));
        vals = countly.remoteConfig().getAllValues();
        Assert.assertEquals(3, vals.size());
        Assert.assertEquals(123, vals.get("a"));
        Assert.assertEquals(33.44, vals.get("b"));
        Assert.assertEquals("ww", vals.get("c"));
        //add third pair with full clear
        countly.moduleRemoteConfig.mergeCheckResponseIntoCurrentValues(true, RemoteConfigHelper.DownloadedValuesIntoMap(rcvs3.values));
        vals = countly.remoteConfig().getAllValues();
        Assert.assertEquals(2, vals.size());
        Assert.assertEquals("yy", vals.get("87"));
        Assert.assertNotNull(vals.get("t"));
        Assert.assertEquals(0, ((JSONObject) vals.get("t")).length());
    }
    static void assertCValueCachedState(Map<String, RCData> rcValues, boolean valuesAreCached) {
        for (Map.Entry<String, RCData> entry : rcValues.entrySet()) {
            if (valuesAreCached) {
                Assert.assertFalse(entry.getValue().isCurrentUsersData);
            } else {
                Assert.assertTrue(entry.getValue().isCurrentUsersData);
            }
        }
    }
}package ly.count.android.sdk;
import androidx.annotation.NonNull;
import java.io.File;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleUserProfile extends ModuleBase {
    static final String NAME_KEY = "name";
    static final String USERNAME_KEY = "username";
    static final String EMAIL_KEY = "email";
    static final String ORG_KEY = "organization";
    static final String PHONE_KEY = "phone";
    static final String PICTURE_KEY = "picture";//the one sending the url
    static final String PICTURE_PATH_KEY = "picturePath";//path to a local file
    static final String GENDER_KEY = "gender";
    static final String BYEAR_KEY = "byear";
    static final String CUSTOM_KEY = "custom";
    String[] namedFields = { NAME_KEY, USERNAME_KEY, EMAIL_KEY, ORG_KEY, PHONE_KEY, PICTURE_KEY, PICTURE_PATH_KEY, GENDER_KEY, BYEAR_KEY };
    boolean isSynced = true;
    UserProfile userProfileInterface;
    //fields from the old object
    String name;
    String username;
    String email;
    String org;
    String phone;
    String picture;
    static String picturePath;//protected only for testing
    String gender;
    Map<String, Object> custom;
    Map<String, JSONObject> customMods;
    int byear = 0;
    ModuleUserProfile(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleUserProfile] Initialising");
        userProfileInterface = new UserProfile();
    }
    /**
     * Returns &user_details= prefixed url to add to request data when making request to server
     *
     * @return a String user_details url part with provided user data
     */
    String getDataForRequest() {
        if (!isSynced) {
            isSynced = true;
            final JSONObject json = toJSON();
            if (json != null) {
                String result = json.toString();
                try {
                    result = java.net.URLEncoder.encode(result, "UTF-8");
                    if (result != null && !result.equals("")) {
                        result = "&user_details=" + result;
                        if (picturePath != null) {
                            result += "&" + PICTURE_PATH_KEY + "=" + java.net.URLEncoder.encode(picturePath, "UTF-8");
                        }
                    } else {
                        result = "";
                        if (picturePath != null) {
                            result += "&user_details&" + PICTURE_PATH_KEY + "=" + java.net.URLEncoder.encode(picturePath, "UTF-8");
                        }
                    }
                } catch (UnsupportedEncodingException ignored) {
                    // should never happen because Android guarantees UTF-8 support
                }
                if (result != null) {
                    return result;
                }
            }
        }
        return "";
    }
    /**
     * Creates and returns a JSONObject containing the user data from this object.
     *
     * @return a JSONObject containing the user data from this object
     */
    protected JSONObject toJSON() {
        final JSONObject json = new JSONObject();
        try {
            if (name != null) {
                if (name.equals("")) {
                    json.put(NAME_KEY, JSONObject.NULL);
                } else {
                    json.put(NAME_KEY, name);
                }
            }
            if (username != null) {
                if (username.equals("")) {
                    json.put(USERNAME_KEY, JSONObject.NULL);
                } else {
                    json.put(USERNAME_KEY, username);
                }
            }
            if (email != null) {
                if (email.equals("")) {
                    json.put(EMAIL_KEY, JSONObject.NULL);
                } else {
                    json.put(EMAIL_KEY, email);
                }
            }
            if (org != null) {
                if (org.equals("")) {
                    json.put(ORG_KEY, JSONObject.NULL);
                } else {
                    json.put(ORG_KEY, org);
                }
            }
            if (phone != null) {
                if (phone.equals("")) {
                    json.put(PHONE_KEY, JSONObject.NULL);
                } else {
                    json.put(PHONE_KEY, phone);
                }
            }
            if (picture != null) {
                if (picture.equals("")) {
                    json.put(PICTURE_KEY, JSONObject.NULL);
                } else {
                    json.put(PICTURE_KEY, picture);
                }
            }
            if (gender != null) {
                if (gender.equals("")) {
                    json.put(GENDER_KEY, JSONObject.NULL);
                } else {
                    json.put(GENDER_KEY, gender);
                }
            }
            if (byear != 0) {
                if (byear > 0) {
                    json.put(BYEAR_KEY, byear);
                } else {
                    json.put(BYEAR_KEY, JSONObject.NULL);
                }
            }
            JSONObject ob;
            if (custom != null) {
                UtilsInternalLimits.truncateSegmentationValues(custom, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[ModuleUserProfile] toJSON", _cly.L);
                ob = new JSONObject(custom);
            } else {
                ob = new JSONObject();
            }
            if (customMods != null) {
                for (Map.Entry<String, JSONObject> entry : customMods.entrySet()) {
                    ob.put(entry.getKey(), entry.getValue());
                }
            }
            json.put(CUSTOM_KEY, ob);
        } catch (JSONException e) {
            L.w("[UserData] Got exception converting an UserData to JSON", e);
        }
        return json;
    }
    /**
     * Sets user data fields to values from its JSON representation.
     *
     * @param json JSON object to extract event data from
     */
    void fromJSON(final JSONObject json) {
        if (json != null) {
            name = json.optString(NAME_KEY, null);
            username = json.optString(USERNAME_KEY, null);
            email = json.optString(EMAIL_KEY, null);
            org = json.optString(ORG_KEY, null);
            phone = json.optString(PHONE_KEY, null);
            picture = json.optString(PICTURE_KEY, null);
            gender = json.optString(GENDER_KEY, null);
            byear = json.optInt(BYEAR_KEY, 0);
            if (!json.isNull(CUSTOM_KEY)) {
                JSONObject customJson;
                try {
                    customJson = json.getJSONObject(CUSTOM_KEY);
                    if (customJson.length() == 0) {
                        custom = null;
                    } else {
                        custom = new HashMap<>(customJson.length());
                        Iterator<String> nameItr = customJson.keys();
                        while (nameItr.hasNext()) {
                            final String key = nameItr.next();
                            if (!customJson.isNull(key)) {
                                custom.put(key, customJson.getString(key));
                            }
                        }
                    }
                } catch (JSONException e) {
                    L.w("[ModuleUserProfile] Got exception converting an Custom Json to Custom User data", e);
                }
            }
        }
    }
    /**
     * Atomic modifications on custom user property.
     *
     * @param key String with property name to modify
     * @param value String value to use in modification
     * @param mod String with modification command
     */
    void modifyCustomData(String key, Object value, String mod) {
        try {
            if (!(value instanceof Double || value instanceof Integer || value instanceof String)) {
                L.w("[ModuleUserProfile] modifyCustomDataCommon, provided an unsupported type for 'value'");
                return;
            }
            Object valueAdded;
            String truncatedKey = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, _cly.L, "[ModuleUserProfile] modifyCustomData");
            if (value instanceof String) {
                valueAdded = UtilsInternalLimits.truncateValueSize((String) value, _cly.config_.sdkInternalLimits.maxValueSize, _cly.L, "[ModuleUserProfile] modifyCustomData");
            } else if (UtilsInternalLimits.isSupportedDataType(value)) {
                valueAdded = value;
            } else {
                L.w("[ModuleUserProfile] modifyCustomData, provided an unsupported type for key: [" + key + "], value: [" + value + "], type: [" + value.getClass().getSimpleName() + "], mod: [" + mod + "], omitting call");
                return;
            }
            if (customMods == null) {
                customMods = new HashMap<>();
            }
            JSONObject ob;
            if (!mod.equals("$pull") && !mod.equals("$push") && !mod.equals("$addToSet")) {
                ob = new JSONObject();
                ob.put(mod, valueAdded);
            } else {
                if (customMods.containsKey(truncatedKey)) {
                    ob = customMods.get(truncatedKey);
                } else {
                    ob = new JSONObject();
                }
                ob.accumulate(mod, valueAdded);
            }
            customMods.put(truncatedKey, ob);
            isSynced = false;
        } catch (JSONException e) {
            e.printStackTrace();
        }
    }
    /**
     * This mainly performs the filtering of provided values
     * This single call would be used for both predefined properties and custom user properties
     *
     * @param data
     */
    void setPropertiesInternal(@NonNull Map<String, Object> data) {
        if (data.isEmpty()) {
            L.w("[ModuleUserProfile] setPropertiesInternal, no data was provided");
            return;
        }
        //todo recheck if in the future these can be <String, Object>
        Map<String, String> dataNamedFields = new HashMap<>();
        Map<String, Object> dataCustomFields = new HashMap<>();
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (value == null) {
                L.w("[ModuleUserProfile] setPropertiesInternal, provided value for key [" + key + "] is 'null'");
                continue;
            }
            boolean isNamed = false;
            // limit to the picture path is applied when request is being made in the ConnectionProcessor
            if (value instanceof String) {
                if (key.equals(PICTURE_PATH_KEY) || key.equals(PICTURE_KEY)) {
                    value = UtilsInternalLimits.truncateValueSize(value.toString(), _cly.config_.sdkInternalLimits.maxValueSizePicture, _cly.L, "[ModuleUserProfile] setPropertiesInternal");
                } else {
                    value = UtilsInternalLimits.truncateValueSize(value.toString(), _cly.config_.sdkInternalLimits.maxValueSize, _cly.L, "[ModuleUserProfile] setPropertiesInternal");
                }
            }
            for (String namedField : namedFields) {
                if (namedField.equals(key)) {
                    //if it's a name field
                    isNamed = true;
                    dataNamedFields.put(key, value.toString());
                    break;
                }
            }
            if (!isNamed) {
                String truncatedKey = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, _cly.L, "[ModuleUserProfile] setPropertiesInternal");
                if (UtilsInternalLimits.isSupportedDataType(value)) {
                    dataCustomFields.put(truncatedKey, value);
                } else {
                    L.w("[ModuleUserProfile] setPropertiesInternal, provided an unsupported type for key: [" + key + "], value: [" + value + "], type: [" + value.getClass().getSimpleName() + "], omitting call");
                }
            }
        }
        //setting predefined properties
        setData(dataNamedFields);
        //setting custom properties
        if (custom == null) {
            custom = new HashMap<>();
        }
        custom.putAll(dataCustomFields);
        isSynced = false;
    }
    /**
     * Sets user data values.
     *
     * @param data Map with user data
     */
    public void setData(Map<String, String> data) {
        if (data.containsKey(ModuleUserProfile.NAME_KEY)) {
            name = data.get(ModuleUserProfile.NAME_KEY);
        }
        if (data.containsKey(ModuleUserProfile.USERNAME_KEY)) {
            username = data.get(ModuleUserProfile.USERNAME_KEY);
        }
        if (data.containsKey(ModuleUserProfile.EMAIL_KEY)) {
            email = data.get(ModuleUserProfile.EMAIL_KEY);
        }
        if (data.containsKey(ModuleUserProfile.ORG_KEY)) {
            org = data.get(ModuleUserProfile.ORG_KEY);
        }
        if (data.containsKey(ModuleUserProfile.PHONE_KEY)) {
            phone = data.get(ModuleUserProfile.PHONE_KEY);
        }
        if (data.containsKey(ModuleUserProfile.PICTURE_PATH_KEY)) {
            picturePath = data.get(ModuleUserProfile.PICTURE_PATH_KEY);
        }
        if (picturePath != null) {
            File sourceFile = new File(picturePath);
            if (!sourceFile.isFile()) {
                L.w("[UserData] Provided Picture path file [" + picturePath + "] can not be opened");
                picturePath = null;
            }
        }
        if (data.containsKey(ModuleUserProfile.PICTURE_KEY)) {
            picture = data.get(ModuleUserProfile.PICTURE_KEY);
        }
        if (data.containsKey(ModuleUserProfile.GENDER_KEY)) {
            gender = data.get(ModuleUserProfile.GENDER_KEY);
        }
        if (data.containsKey(ModuleUserProfile.BYEAR_KEY)) {
            try {
                byear = Integer.parseInt(data.get(ModuleUserProfile.BYEAR_KEY));
            } catch (NumberFormatException e) {
                L.w("[UserData] Incorrect byear number format");
                byear = 0;
            }
        }
    }
    void saveInternal() {
        L.d("[ModuleUserProfile] saveInternal");
        String cachedUserData = getDataForRequest();
        if (cachedUserData.isEmpty()) {
            L.d("[ModuleUserProfile] saveInternal, no user data to save");
            return;
        }
        _cly.moduleRequestQueue.sendEventsIfNeeded(true);
        requestQueueProvider.sendUserData(cachedUserData);
        clearInternal();
    }
    void clearInternal() {
        L.d("[ModuleUserProfile] clearInternal");
        name = null;
        username = null;
        email = null;
        org = null;
        phone = null;
        picture = null;
        picturePath = null;
        gender = null;
        custom = null;
        customMods = null;
        byear = 0;
        isSynced = true;
    }
    @Override
    void initFinished(@NonNull final CountlyConfig config) {
        if (config.providedUserProperties != null) {
            L.i("[ModuleUserProfile] Custom user properties were provided during init [" + config.providedUserProperties.size() + "]");
            setPropertiesInternal(config.providedUserProperties);
            saveInternal();
        }
    }
    @Override
    void halt() {
        userProfileInterface = null;
    }
    public class UserProfile {
        /**
         * Increment custom property value by 1.
         *
         * @param key String with property name to increment
         */
        public void increment(String key) {
            synchronized (_cly) {
                modifyCustomData(key, 1, "$inc");
            }
        }
        /**
         * Increment custom property value by provided value.
         *
         * @param key String with property name to increment
         * @param value int value by which to increment
         */
        public void incrementBy(String key, int value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$inc");
            }
        }
        /**
         * Multiply custom property value by provided value.
         *
         * @param key String with property name to multiply
         * @param value int value by which to multiply
         */
        public void multiply(String key, int value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$mul");
            }
        }
        /**
         * Save maximal value between existing and provided.
         *
         * @param key String with property name to check for max
         * @param value int value to check for max
         */
        public void saveMax(String key, int value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$max");
            }
        }
        /**
         * Save minimal value between existing and provided.
         *
         * @param key String with property name to check for min
         * @param value int value to check for min
         */
        public void saveMin(String key, int value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$min");
            }
        }
        /**
         * Set value only if property does not exist yet
         *
         * @param key String with property name to set
         * @param value String value to set
         */
        public void setOnce(String key, String value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$setOnce");
            }
        }
        /**
         * Create array property, if property does not exist and add value to array
         * You can only use it on array properties or properties that do not exist yet
         *
         * @param key String with property name for array property
         * @param value String with value to add to array
         */
        public void push(String key, String value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$push");
            }
        }
        /**
         * Create array property, if property does not exist and add value to array, only if value is not yet in the array
         * You can only use it on array properties or properties that do not exist yet
         *
         * @param key String with property name for array property
         * @param value String with value to add to array
         */
        public void pushUnique(String key, String value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$addToSet");
            }
        }
        /**
         * Create array property, if property does not exist and remove value from array
         * You can only use it on array properties or properties that do not exist yet
         *
         * @param key String with property name for array property
         * @param value String with value to remove from array
         */
        public void pull(String key, String value) {
            synchronized (_cly) {
                modifyCustomData(key, value, "$pull");
            }
        }
        /**
         * Remove custom user property
         */
        //public void unset() {
        //    //todo add in the future
        //}
        /**
         * Set a single user property. It can be either a custom one or one of the predefined ones.
         *
         * @param key the key for the user property
         * @param value the value for the user property to be set. The value should be the allowed data type.
         */
        public void setProperty(String key, Object value) {
            synchronized (_cly) {
                L.i("[UserProfile] Calling 'setProperty'");
                Map<String, Object> data = new HashMap<>();
                data.put(key, value);
                setPropertiesInternal(data);
            }
        }
        /**
         * Provide a map of user properties to set.
         * Those can be either custom user properties or predefined user properties
         *
         * @param data
         */
        public void setProperties(Map<String, Object> data) {
            synchronized (_cly) {
                L.i("[UserProfile] Calling 'setProperties'");
                if (data == null) {
                    L.i("[UserProfile] Provided data can not be 'null'");
                    return;
                }
                setPropertiesInternal(data);
            }
        }
        /**
         * Send provided values to server
         */
        public void save() {
            synchronized (_cly) {
                L.i("[UserProfile] Calling 'save'");
                saveInternal();
            }
        }
        /**
         * Clear queued operations / modifications
         */
        public void clear() {
            synchronized (_cly) {
                L.i("[UserProfile] Calling 'clear'");
                clearInternal();
            }
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Collection;
import java.util.List;
import java.util.Map;
interface StorageProvider {
    String[] getRequests();
    String[] getEvents();
    List<Event> getEventList();
    @NonNull String getRequestQueueRaw();
    void addRequest(final String requestStr, final boolean writeInSync);
    void removeRequest(final String requestStr);
    void replaceRequests(final String[] newConns);
    void replaceRequestList(final List<String> newConns);
    void removeEvents(final List<Event> eventsToRemove);
    int getEventQueueSize();
    String getEventsForRequestAndEmptyEventQueue();
    @Nullable String getDeviceID();
    @Nullable String getDeviceIDType();
    void setDeviceID(String id);
    void setDeviceIDType(String type);
    void setStarRatingPreferences(String preferences);//not integrated
    String getStarRatingPreferences();//not integrated
    void setCachedAdvertisingId(String advertisingId);//not integrated
    String getCachedAdvertisingId();//not integrated
    void setRemoteConfigValues(String values);//not integrated
    String getRemoteConfigValues();//not integrated
    void esWriteCacheToStorage(@Nullable ExplicitStorageCallback callback);//required for explicit storage
    void setServerConfig(String config);
    String getServerConfig();
    //fields for data migration
    int getDataSchemaVersion();
    void setDataSchemaVersion(int version);
    boolean anythingSetInStorage();
    @NonNull String getHealthCheckCounterState();
    void setHealthCheckCounterState(String counterState);
}
/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import android.content.Context;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import org.json.JSONException;
import org.json.JSONObject;
/**
 * ConnectionQueue queues session and event data and periodically sends that data to
 * a Count.ly server on a background thread.
 *
 * None of the methods in this class are synchronized because access to this class is
 * controlled by the Countly singleton, which is synchronized.
 *
 * NOTE: This class is only public to facilitate unit testing, because
 * of this bug in dexmaker: https://code.google.com/p/dexmaker/issues/detail?id=34
 */
class ConnectionQueue implements RequestQueueProvider {
    private ExecutorService executor_;
    private Context context_;
    private Future<?> connectionProcessorFuture_;
    private DeviceIdProvider deviceIdProvider_;
    private SSLContext sslContext_;
    BaseInfoProvider baseInfoProvider;
    HealthTracker healthTracker;
    public PerformanceCounterCollector pcc;
    private Map<String, String> requestHeaderCustomValues;
    Map<String, String> metricOverride = null;
    protected ModuleLog L;
    protected ConsentProvider consentProvider;//link to the consent module
    protected ModuleRequestQueue moduleRequestQueue = null;//todo remove in the future
    protected DeviceInfo deviceInfo = null;//todo ?remove in the future?
    StorageProvider storageProvider;
    ConfigurationProvider configProvider;
    RequestInfoProvider requestInfoProvider;
    void setBaseInfoProvider(BaseInfoProvider bip) {
        baseInfoProvider = bip;
    }
    void setStorageProvider(StorageProvider sp) {
        storageProvider = sp;
    }
    StorageProvider getStorageProvider() {
        return storageProvider;
    }
    Context getContext() {
        return context_;
    }
    void setContext(final Context context) {
        context_ = context;
    }
    void setupSSLContext() {
        if (Countly.publicKeyPinCertificates == null && Countly.certificatePinCertificates == null) {
            sslContext_ = null;
        } else {
            try {
                TrustManager[] tm = { new CertificateTrustManager(Countly.publicKeyPinCertificates, Countly.certificatePinCertificates) };
                sslContext_ = SSLContext.getInstance("TLS");
                sslContext_.init(null, tm, null);
            } catch (Throwable e) {
                throw new IllegalStateException(e);
            }
        }
    }
    public void setDeviceId(DeviceIdProvider deviceIdProvider) {
        this.deviceIdProvider_ = deviceIdProvider;
    }
    protected void setRequestHeaderCustomValues(Map<String, String> headerCustomValues) {
        requestHeaderCustomValues = headerCustomValues;
    }
    protected void setMetricOverride(Map<String, String> metricOverride) {
        if (L.logEnabled()) {
            if (metricOverride != null) {
                L.d("[Connection Queue] The following metric overrides are set:");
                for (String k : metricOverride.keySet()) {
                    L.d("[Connection Queue] key[" + k + "] val[" + metricOverride.get(k) + "]");
                }
            } else {
                L.d("[Connection Queue] No metric override is provided");
            }
        }
        this.metricOverride = metricOverride;
    }
    /**
     * Checks internal state and throws IllegalStateException if state is invalid to begin use.
     *
     * @throws IllegalStateException if context, app key, store, or server URL have not been set
     */
    boolean checkInternalState() {
        //todo enable later
        //assert context_ != null;
        //assert baseInfoProvider.getAppKey() != null;
        //assert baseInfoProvider.getAppKey().length() != 0;
        //assert baseInfoProvider.getServerURL() != null;
        //assert UtilsNetworking.isValidURL(baseInfoProvider.getServerURL());
        //assert storageProvider != null;
        //assert Countly.publicKeyPinCertificates != null && baseInfoProvider.getServerURL().startsWith("https");
        if (context_ == null) {
            if (L != null) {
                L.e("[Connection Queue] context has not been set");
            }
            return false;
        }
        if (baseInfoProvider.getAppKey() == null || baseInfoProvider.getAppKey().length() == 0) {
            if (L != null) {
                L.e("[Connection Queue] app key has not been set");
            }
            return false;
        }
        if (storageProvider == null) {
            if (L != null) {
                L.e("[Connection Queue] countly storage provider has not been set");
            }
            return false;
        }
        if (baseInfoProvider.getServerURL() == null || !UtilsNetworking.isValidURL(baseInfoProvider.getServerURL())) {
            if (L != null) {
                L.e("[Connection Queue] server URL is not valid");
            }
            return false;
        }
        if (Countly.publicKeyPinCertificates != null && !baseInfoProvider.getServerURL().startsWith("https")) {
            if (L != null) {
                L.e("[Connection Queue] server must start with https once you specified public keys");
            }
            return false;
        }
        return true;
    }
    /**
     * Records a session start event for the app and sends it to the server.
     *
     * @throws IllegalStateException if context, app key, store, or server URL have not been set
     */
    public void beginSession(boolean locationDisabled, @Nullable String locationCountryCode, @Nullable String locationCity, @Nullable String locationGpsCoordinates, @Nullable String locationIpAddress, @NonNull String preparedMetrics) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] beginSession");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {
            L.d("[Connection Queue] request ignored, 'sessions' consent not given");
            return;
        }
        String data = prepareCommonRequestData();
        //add session data if consent given
        data += "&begin_session=1"
            + "&metrics=" + preparedMetrics;//can be only sent with begin session
        String locationData = prepareLocationData(locationDisabled, locationCountryCode, locationCity, locationGpsCoordinates, locationIpAddress);
        if (!locationData.isEmpty()) {
            data += locationData;
        }
        Countly.sharedInstance().isBeginSessionSent = true;
        addRequestToQueue(data, false);
        tick();
    }
    /**
     * Enrolls the user for given keys
     *
     * @throws IllegalStateException if context, app key, store, or server URL have not been set
     */
    public void enrollToKeys(@NonNull String[] keys) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] enrollToKeys");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
            L.d("[Connection Queue] request ignored, 'remoteConfig' consent not given");
            return;
        }
        String data = prepareCommonRequestDataShort()
            + "&method=ab"
            + "&keys=" + UtilsNetworking.encodedArrayBuilder(keys)
            + "&new_end_point=/o/sdk";
        addRequestToQueue(data, false);
        tick();
    }
    /**
     * Exits/removes the user for given keys from A/B tests
     *
     * @throws IllegalStateException if context, app key, store, or server URL have not been set
     */
    public void exitForKeys(@NonNull String[] keys) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] exitForKeys");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.remoteConfig)) {
            L.d("[Connection Queue] request ignored, 'remoteConfig' consent not given");
            return;
        }
        String data = prepareCommonRequestDataShort()
            + "&method=ab_opt_out";
        if (keys.length > 0) { // exits all otherwise
            data += "&keys=" + UtilsNetworking.encodedArrayBuilder(keys);
        }
        addRequestToQueue(data, false);
        tick();
    }
    /**
     * Records a session duration event for the app and sends it to the server. This method does nothing
     * if passed a negative or zero duration.
     *
     * @param duration duration in seconds to extend the current app session, should be more than zero
     * @throws IllegalStateException if context, app key, store, or server URL have not been set
     */
    public void updateSession(final int duration) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] updateSession");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {
            L.d("[Connection Queue] request ignored, 'sessions' consent not given");
            return;
        }
        if (duration > 0) {
            String data = prepareCommonRequestData();
            data += "&session_duration=" + duration;
            addRequestToQueue(data, false);
            tick();
        }
    }
    public void changeDeviceId(String deviceId, String oldDeviceId) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] changeDeviceId");
        String data = prepareCommonRequestData(deviceId);
        data += "&old_device_id=" + UtilsNetworking.urlEncodeString(oldDeviceId);
        addRequestToQueue(data, false);
        tick();
    }
    public void tokenSession(String token, Countly.CountlyMessagingProvider provider) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] tokenSession");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.push)) {
            L.d("[Connection Queue] request ignored, 'push' consent not given");
            return;
        }
        final String data = prepareCommonRequestData()
            + "&token_session=1"
            + "&android_token=" + UtilsNetworking.urlEncodeString(token)
            + "&token_provider=" + provider
            + "&locale=" + UtilsNetworking.urlEncodeString(deviceInfo.mp.getLocale());
        L.d("[Connection Queue] Waiting for 10 seconds before adding token request to queue");
        // To ensure begin_session will be fully processed by the server before token_session
        final ScheduledExecutorService worker = Executors.newSingleThreadScheduledExecutor();
        worker.schedule(new Runnable() {
            @Override
            public void run() {
                L.d("[Connection Queue] Finished waiting 10 seconds adding token request");
                addRequestToQueue(data, false);
                tick();
            }
        }, 10, TimeUnit.SECONDS);
    }
    /**
     * Records a session end event for the app and sends it to the server. Duration is only included in
     * the session end event if it is more than zero.
     *
     * @param duration duration in seconds to extend the current app session
     * @throws IllegalStateException if context, app key, store, or server URL have not been set
     */
    public void endSession(final int duration) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] endSession");
        String data = prepareCommonRequestData();
        data += "&end_session=1";
        if (duration > 0) {
            data += "&session_duration=" + duration;
        }
        addRequestToQueue(data, false);
        tick();
    }
    /**
     * Send user location
     */
    public void sendLocation(boolean locationDisabled, String locationCountryCode, String locationCity, String locationGpsCoordinates, String locationIpAddress) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendLocation");
        String data = prepareCommonRequestData();
        data += prepareLocationData(locationDisabled, locationCountryCode, locationCity, locationGpsCoordinates, locationIpAddress);
        addRequestToQueue(data, false);
        tick();
    }
    /**
     * Send user data to the server.
     *
     * @throws java.lang.IllegalStateException if context, app key, store, or server URL have not been set
     */
    public void sendUserData(String userdata) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendUserData");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.users)) {
            L.d("[Connection Queue] request ignored, 'users' consent not given");
            return;
        }
        String data = prepareCommonRequestData() + userdata;
        addRequestToQueue(data, false);
        tick();
    }
    public void sendIndirectAttribution(@NonNull String attributionObj) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendIndirectAttribution");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.attribution)) {
            L.d("[Connection Queue] request ignored, 'attribution' consent not given");
            return;
        }
        if (attributionObj.isEmpty()) {
            L.e("[Connection Queue] provided attribution ID is not valid, aborting");
            return;
        }
        String param = "&aid=" + UtilsNetworking.urlEncodeString(attributionObj);
        String data = prepareCommonRequestData() + param;
        addRequestToQueue(data, false);
        tick();
    }
    public void sendDirectAttributionTest(@NonNull String attributionData) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendDirectAttributionTest");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.attribution)) {
            L.d("[Connection Queue] request ignored, 'attribution' consent not given");
            return;
        }
        if (attributionData.isEmpty()) {
            L.w("[Connection Queue] sendDirectAttributionTest, attribution not sent, data is empty");
            return;
        }
        String res = "&attribution_data=" + UtilsNetworking.urlEncodeString(attributionData);
        String data = prepareCommonRequestData() + res;
        addRequestToQueue(data, false);
        tick();
    }
    public void sendDirectAttributionLegacy(@NonNull String campaignID, @Nullable String userID) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendDirectAttributionLegacy");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.attribution)) {
            L.d("[Connection Queue] request ignored, 'attribution' consent not given");
            return;
        }
        String res = "";
        if (!campaignID.isEmpty()) {
            res += "&campaign_id=" + UtilsNetworking.urlEncodeString(campaignID);
        }
        if (userID != null && !userID.isEmpty()) {
            res += "&campaign_user=" + UtilsNetworking.urlEncodeString(userID);
        }
        if (res.length() == 0) {
            L.w("[Connection Queue] sendDirectAttributionLegacy, attribution not sent, both campaign ID and user ID are either null or empty");
            return;
        }
        String data = prepareCommonRequestData() + res;
        addRequestToQueue(data, false);
        tick();
    }
    /**
     * Reports a crash with device data to the server.
     *
     * @throws IllegalStateException if context, app key, store, or server URL have not been set
     */
    public void sendCrashReport(@NonNull final String crashData, final boolean nonFatalCrash) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendCrashReport");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.crashes)) {
            L.d("[Connection Queue] request ignored, 'crashes' consent not given");
            return;
        }
        final String data = prepareCommonRequestData()
            + "&crash=" + UtilsNetworking.urlEncodeString(crashData);
        //in case of a fatal crash, write it in sync to shared preferences
        addRequestToQueue(data, !nonFatalCrash);
        tick();
    }
    /**
     * Send a direct request to server
     * We have encoded each key and value as http url encoded.
     * You need to check the required consents by yourself before this call, we are just checking that if any consent is given.
     *
     * @param requestData key value pair for direct request
     */
    public void sendDirectRequest(@NonNull final Map<String, String> requestData) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendDirectRequest");
        if (!consentProvider.anyConsentGiven()) {
            L.d("[Connection Queue] request ignored, no consent given");
            return;
        }
        StringBuilder data = new StringBuilder(prepareCommonRequestData());
        data.append("&dr=1");
        for (Map.Entry<String, String> entry : requestData.entrySet()) {
            if (data.length() > 0) {
                data.append("&");
            }
            data.append(String.format("%s=%s",
                UtilsNetworking.urlEncodeString(entry.getKey()),
                UtilsNetworking.urlEncodeString(entry.getValue())
            ));
        }
        addRequestToQueue(data.toString(), false);
        tick();
    }
    /**
     * Records the specified events and sends them to the server.
     *
     * @param events URL-encoded JSON string of event data
     * @throws IllegalStateException if context, app key, store, or server URL have not been set
     */
    public void recordEvents(final String events) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendConsentChanges");
        ////////////////////////////////////////////////////
        ///CONSENT FOR EVENTS IS CHECKED ON EVENT CREATION//
        ////////////////////////////////////////////////////
        final String data = prepareCommonRequestData()
            + "&events=" + events;
        addRequestToQueue(data, false);
        tick();
    }
    public void sendConsentChanges(String formattedConsentChanges) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendConsentChanges");
        final String data = prepareCommonRequestData()
            + "&consent=" + UtilsNetworking.urlEncodeString(formattedConsentChanges);
        addRequestToQueue(data, false);
        tick();
    }
    public void sendAPMCustomTrace(String key, Long durationMs, Long startMs, Long endMs, String customMetrics) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendAPMCustomTrace");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.apm)) {
            L.d("[Connection Queue] request ignored, 'apm' consent not given");
            return;
        }
        // https://abc.count.ly/i?app_key=xyz&device_id=pts911
        // &apm={"type":"device","name":"forLoopProfiling_1","apm_metrics":{"duration": 10, "memory": 200}, "stz": 1584698900, "etz": 1584699900}
        // &timestamp=1584698900&count=1
        String apmData = "{\"type\":\"device\",\"name\":\"" + key + "\", \"apm_metrics\":{\"duration\": " + durationMs + customMetrics + "}, \"stz\": " + startMs + ", \"etz\": " + endMs + "}";
        final String data = prepareCommonRequestData()
            + "&count=1"
            + "&apm=" + UtilsNetworking.urlEncodeString(apmData);
        addRequestToQueue(data, false);
        tick();
    }
    public void sendAPMNetworkTrace(String networkTraceKey, Long responseTimeMs, int responseCode, int requestPayloadSize, int responsePayloadSize, Long startMs, Long endMs) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendAPMNetworkTrace");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.apm)) {
            L.d("[Connection Queue] request ignored, 'apm' consent not given");
            return;
        }
        // https://abc.count.ly/i?app_key=xyz&device_id=pts911
        // &apm={"type":"network","name":"/count.ly/about","apm_metrics":{"response_time":1330,"response_payload_size":120, "response_code": 300, "request_payload_size": 70}, "stz": 1584698900, "etz": 1584699900}
        // &timestamp=1584698900&count=1
        String apmMetrics = "{\"response_time\": " + responseTimeMs + ", \"response_payload_size\":" + responsePayloadSize + ", \"response_code\":" + responseCode + ", \"request_payload_size\":" + requestPayloadSize + "}";
        String apmData = "{\"type\":\"network\",\"name\":\"" + networkTraceKey + "\", \"apm_metrics\":" + apmMetrics + ", \"stz\": " + startMs + ", \"etz\": " + endMs + "}";
        final String data = prepareCommonRequestData()
            + "&count=1"
            + "&apm=" + UtilsNetworking.urlEncodeString(apmData);
        addRequestToQueue(data, false);
        tick();
    }
    public void sendAPMAppStart(long durationMs, Long startMs, Long endMs) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendAPMAppStart");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.apm)) {
            L.d("[Connection Queue] request ignored, 'apm' consent not given");
            return;
        }
        //https://abc.count.ly/i?app_key=xyz&device_id=pts911&apm={"type":"device","name":"app_start","apm_metrics":{"duration": 15000}, "stz": 1584698900, "etz": 1584699900}
        // &timestamp=1584698900&count=1
        String apmData = "{\"type\":\"device\",\"name\":\"app_start\", \"apm_metrics\":{\"duration\": " + durationMs + "}, \"stz\": " + startMs + ", \"etz\": " + endMs + "}";
        final String data = prepareCommonRequestData()
            + "&count=1"
            + "&apm=" + UtilsNetworking.urlEncodeString(apmData);
        addRequestToQueue(data, false);
        tick();
    }
    public void sendAPMScreenTime(boolean recordForegroundTime, long durationMs, Long startMs, Long endMs) {
        if (!checkInternalState()) {
            return;
        }
        L.d("[Connection Queue] sendAPMScreenTime, recording foreground time: [" + recordForegroundTime + "]");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.apm)) {
            L.d("[Connection Queue] request ignored, 'apm' consent not given");
            return;
        }
        final String eventName = recordForegroundTime ? "app_in_foreground" : "app_in_background";
        String apmData = "{\"type\":\"device\",\"name\":\"" + eventName + "\", \"apm_metrics\":{\"duration\": " + durationMs + "}, \"stz\": " + startMs + ", \"etz\": " + endMs + "}";
        final String data = prepareCommonRequestData()
            + "&count=1"
            + "&apm=" + UtilsNetworking.urlEncodeString(apmData);
        addRequestToQueue(data, false);
        tick();
    }
    @NonNull
    String prepareCommonRequestData() {
        return prepareCommonRequestData(deviceIdProvider_.getDeviceId());
    }
    @NonNull
    String prepareCommonRequestData(@NonNull String deviceId) {
        UtilsTime.Instant instant = UtilsTime.getCurrentInstant();
        return prepareCommonRequestDataShort(instant, deviceId)
            + "&hour=" + instant.hour
            + "&dow=" + instant.dow
            + "&tz=" + deviceInfo.mp.getTimezoneOffset();
    }
    @NonNull
    String prepareCommonRequestDataShort() {
        UtilsTime.Instant instant = UtilsTime.getCurrentInstant();
        return prepareCommonRequestDataShort(instant);
    }
    @NonNull
    String prepareCommonRequestDataShort(@NonNull UtilsTime.Instant instant) {
        return prepareCommonRequestDataShort(instant, deviceIdProvider_.getDeviceId());
    }
    @NonNull
    String prepareCommonRequestDataShort(@NonNull UtilsTime.Instant instant, @NonNull String deviceId) {
        return "app_key=" + UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey())
            + "&device_id=" + UtilsNetworking.urlEncodeString(deviceId)
            + "&timestamp=" + instant.timestampMs
            + "&sdk_version=" + Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING
            + "&sdk_name=" + Countly.sharedInstance().COUNTLY_SDK_NAME
            + "&av=" + UtilsNetworking.urlEncodeString(deviceInfo.getAppVersionWithOverride(context_, metricOverride));
    }
    private String prepareLocationData(boolean locationDisabled, String locationCountryCode, String locationCity, String locationGpsCoordinates, String locationIpAddress) {
        String data = "";
        if (locationDisabled || !consentProvider.getConsent(Countly.CountlyFeatureNames.location)) {
            //if location is disabled or consent not given, send empty location info
            //this way it is cleared server side and geoip is not used
            //do this only if allowed
            data += "&location=";
        } else {
            //if we get here, location consent was given
            //location should be sent, add all the fields we have
            if (locationGpsCoordinates != null && !locationGpsCoordinates.isEmpty()) {
                data += "&location=" + UtilsNetworking.urlEncodeString(locationGpsCoordinates);
            }
            if (locationCity != null && !locationCity.isEmpty()) {
                data += "&city=" + UtilsNetworking.urlEncodeString(locationCity);
            }
            if (locationCountryCode != null && !locationCountryCode.isEmpty()) {
                data += "&country_code=" + UtilsNetworking.urlEncodeString(locationCountryCode);
            }
            if (locationIpAddress != null && !locationIpAddress.isEmpty()) {
                data += "&ip=" + UtilsNetworking.urlEncodeString(locationIpAddress);
            }
        }
        return data;
    }
    public String prepareRemoteConfigRequestLegacy(@Nullable String keysInclude, @Nullable String keysExclude, @NonNull String preparedMetrics) {
        String data = prepareCommonRequestData() + "&method=fetch_remote_config";
        if (consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {
            //add session data if consent given
            data += "&metrics=" + preparedMetrics;
        }
        //add key filters
        if (keysInclude != null) {
            data += "&keys=" + UtilsNetworking.urlEncodeString(keysInclude);
        } else if (keysExclude != null) {
            data += "&omit_keys=" + UtilsNetworking.urlEncodeString(keysExclude);
        }
        return data;
    }
    public String prepareRemoteConfigRequest(@Nullable String keysInclude, @Nullable String keysExclude, @NonNull String preparedMetrics, boolean autoEnroll) {
        String data = prepareCommonRequestData() + "&method=rc";
        if (consentProvider.getConsent(Countly.CountlyFeatureNames.sessions)) {
            //add session data if consent given
            data += "&metrics=" + preparedMetrics;
        }
        //add key filters
        if (keysInclude != null) {
            data += "&keys=" + UtilsNetworking.urlEncodeString(keysInclude);
        } else if (keysExclude != null) {
            data += "&omit_keys=" + UtilsNetworking.urlEncodeString(keysExclude);
        }
        // if auto enroll was enabled add oi=1 to the request
        if (autoEnroll) {
            data += "&oi=1";
        }
        return data;
    }
    /**
     * To fetch all variants from the server. Something like this should be formed: method=ab_fetch_variants&app_key="APP_KEY"&device_id=DEVICE_ID
     * API end point for this is /i/sdk (also o/sdk)
     *
     * @return
     */
    public String prepareFetchAllVariants() {
        return prepareCommonRequestDataShort() + "&method=ab_fetch_variants";
    }
    /**
     * To fetch all experiments from the server. Something like this should be formed: method=ab_fetch_experiments&app_key="APP_KEY"&device_id=DEVICE_ID
     * Provides detailed experiment and variant information
     * API end point for this is /o/sdk
     *
     * @return
     */
    public String prepareFetchAllExperiments() {
        return prepareCommonRequestDataShort() + "&method=ab_fetch_experiments";
    }
    public String prepareEnrollVariant(String key, String variant) {
        String data = prepareCommonRequestDataShort()
            + "&method=ab_enroll_variant"
            + "&key=" + UtilsNetworking.urlEncodeString(key)
            + "&variant=" + UtilsNetworking.urlEncodeString(variant);
        return data;
    }
    public String prepareRatingWidgetRequest(String widgetId) {
        return prepareCommonRequestData() + "&widget_id=" + UtilsNetworking.urlEncodeString(widgetId);
    }
    public String prepareFeedbackListRequest() {
        return prepareCommonRequestData() + "&method=feedback";
    }
    public String prepareHealthCheckRequest(String preparedMetrics) {
        return prepareCommonRequestData() + "&metrics=" + preparedMetrics;
    }
    public String prepareFetchContents(int portraitWidth, int portraitHeight, int landscapeWidth, int landscapeHeight, String[] categories, String language) {
        JSONObject json = new JSONObject();
        try {
            JSONObject landscapeJson = new JSONObject();
            landscapeJson.put("w", landscapeWidth);
            landscapeJson.put("h", landscapeHeight);
            JSONObject portraitJson = new JSONObject();
            portraitJson.put("w", portraitWidth);
            portraitJson.put("h", portraitHeight);
            json.put("l", landscapeJson);
            json.put("p", portraitJson);
        } catch (JSONException e) {
            L.e("Error while preparing fetch contents request");
        }
        return prepareCommonRequestData() + "&method=queue" + "&category=" + Arrays.asList(categories) + "&resolution=" + UtilsNetworking.urlEncodeString(json.toString()) + "&la=" + language;
    }
    @Override
    public String prepareServerConfigRequest() {
        return prepareCommonRequestDataShort() + "&method=sc";
    }
    /**
     * Ensures that an executor has been created for ConnectionProcessor instances to be submitted to.
     */
    void ensureExecutor() {
        if (executor_ == null) {
            if (L != null) {
                L.v("[ConnectionQueue] ensureExecutor, Creating new executor");
            }
            executor_ = Executors.newSingleThreadExecutor();
        }
    }
    /**
     * Starts ConnectionProcessor instances running in the background to
     * process the local connection queue data.
     * Does nothing if there is connection queue data or if a ConnectionProcessor
     * is already running.
     * <br>
     * Should only be called if SDK is initialized
     */
    public void tick() {
        //todo enable later
        //assert storageProvider != null;
        boolean rqEmpty = isRequestQueueEmpty(); // this is a heavy operation, do it only once. Why heavy? reading storage
        boolean cpDoneIfOngoing = connectionProcessorFuture_ != null && connectionProcessorFuture_.isDone();
        L.v("[ConnectionQueue] tick, IsRQEmpty:[" + rqEmpty + "], HasOngoingProcess:[" + (connectionProcessorFuture_ == null) + "], OngoingProcess_Done:[" + cpDoneIfOngoing + "]");
        if (!Countly.sharedInstance().isInitialized()) {
            L.e("[ConnectionQueue] tick, SDK is not initialized");
            //attempting to tick when the SDK is not initialized
            return;
        }
        if (!rqEmpty && (connectionProcessorFuture_ == null || cpDoneIfOngoing)) {
            L.d("[ConnectionQueue] tick, Starting ConnectionProcessor");
            ensureExecutor();
            connectionProcessorFuture_ = executor_.submit(createConnectionProcessor());
        }
    }
    public ConnectionProcessor createConnectionProcessor() {
        ConnectionProcessor cp = new ConnectionProcessor(baseInfoProvider.getServerURL(), storageProvider, deviceIdProvider_, configProvider, requestInfoProvider, sslContext_, requestHeaderCustomValues, L, healthTracker);
        cp.pcc = pcc;
        return cp;
    }
    public boolean queueContainsTemporaryIdItems() {
        String[] storedRequests = storageProvider.getRequests();
        String temporaryIdTag = "&device_id=" + DeviceId.temporaryCountlyDeviceId;
        for (String storedRequest : storedRequests) {
            if (storedRequest.contains(temporaryIdTag)) {
                return true;
            }
        }
        return false;
    }
    void addRequestToQueue(final @NonNull String requestData, final boolean writeInSync) {
        storageProvider.addRequest(requestData, writeInSync);
    }
    /**
     * Returns true if no requests are current stored, false otherwise.
     */
    boolean isRequestQueueEmpty() {
        String rawRequestQueue = storageProvider.getRequestQueueRaw();
        return rawRequestQueue.isEmpty();
    }
    // for unit testing
    ExecutorService getExecutor() {
        return executor_;
    }
    void setExecutor(final ExecutorService executor) {
        executor_ = executor;
    }
    Future<?> getConnectionProcessorFuture() {
        return connectionProcessorFuture_;
    }
    void setConnectionProcessorFuture(final Future<?> connectionProcessorFuture) {
        connectionProcessorFuture_ = connectionProcessorFuture;
    }
}
/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static ly.count.android.sdk.UtilsNetworking.sha256Hash;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.anyString;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.isNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
@RunWith(AndroidJUnit4.class)
public class ConnectionProcessorTests {
    ConnectionProcessor connectionProcessor;
    CountlyStore mockStore;
    DeviceIdProvider mockDeviceId;
    String testDeviceId;
    ModuleLog moduleLog;
    HealthTracker healthTrackerMock;
    ConfigurationProvider configurationProviderFake;
    RequestInfoProvider rip;
    String testSaltValue;
    String testSaltValueDefult = "123qwerty";
    @Before
    public void setUp() {
        configurationProviderFake = new ConfigurationProvider() {
            @Override public boolean getNetworkingEnabled() {
                return true;
            }
            @Override public boolean getTrackingEnabled() {
                return true;
            }
        };
        Countly.sharedInstance().setLoggingEnabled(true);
        mockStore = mock(CountlyStore.class);
        mockDeviceId = mock(DeviceIdProvider.class);
        moduleLog = mock(ModuleLog.class);
        healthTrackerMock = mock(HealthTracker.class);
        testSaltValue = testSaltValueDefult;//in case a test wants to override the value
        rip = new RequestInfoProvider() {
            @Override public boolean isHttpPostForced() {
                return false;
            }
            @Override public boolean isDeviceAppCrawler() {
                return false;
            }
            @Override public boolean ifShouldIgnoreCrawlers() {
                return false;
            }
            @Override public int getRequestDropAgeHours() {
                return 0;
            }
            @Override public String getRequestSalt() {
                return testSaltValue;
            }
        };
        connectionProcessor = new ConnectionProcessor("http://server", mockStore, mockDeviceId, configurationProviderFake, rip, null, null, moduleLog, healthTrackerMock);
        testDeviceId = "123";
    }
    @Test
    public void testConstructorAndGetters() {
        final String serverURL = "https://secureserver";
        final CountlyStore mockStore = mock(CountlyStore.class);
        final DeviceIdProvider mockDeviceId = mock(DeviceIdProvider.class);
        final ConnectionProcessor connectionProcessor1 = new ConnectionProcessor(serverURL, mockStore, mockDeviceId, configurationProviderFake, rip, null, null, moduleLog, healthTrackerMock);
        assertEquals(serverURL, connectionProcessor1.getServerURL());
        assertSame(mockStore, connectionProcessor1.getCountlyStore());
    }
    /**
     * Make sure that a correct url is generated
     * No salt provided and no custom endpoint
     *
     * @throws IOException
     */
    @Test
    public void testUrlConnectionForEventData() throws IOException {
        testSaltValue = null;
        final String eventData = "blahblahblah";
        final URLConnection urlConnection = connectionProcessor.urlConnectionForServerRequest(eventData, null);
        assertEquals(30_000, urlConnection.getConnectTimeout());
        assertEquals(30_000, urlConnection.getReadTimeout());
        assertFalse(urlConnection.getUseCaches());
        assertTrue(urlConnection.getDoInput());
        assertFalse(urlConnection.getDoOutput());
        assertEquals(new URL(connectionProcessor.getServerURL() + "/i?" + eventData + "&checksum256=" + sha256Hash(eventData + null)), urlConnection.getURL());
    }
    /**
     * Make sure that a correct url is generated
     * With salt provided and no custom endpoint
     *
     * @throws IOException
     */
    @Test
    public void urlConnectionForEventDataWithSalt() throws IOException {
        final String eventData = "blahblahblahasd";
        final URLConnection urlConnection = connectionProcessor.urlConnectionForServerRequest(eventData, null);
        assertEquals(new URL(connectionProcessor.getServerURL() + "/i?" + eventData + "&checksum256=" + sha256Hash(eventData + testSaltValue)), urlConnection.getURL());
    }
    /**
     * Make sure that a correct url is generated
     * With salt provided and custom endpoint
     *
     * @throws IOException
     */
    @Test
    public void urlConnectionForEventDataWithSaltCustomEndpoint() throws IOException {
        final String eventData = "blahblahblah123";
        final String endpoint = "/thisthat";
        final URLConnection urlConnection = connectionProcessor.urlConnectionForServerRequest(eventData, endpoint);
        assertEquals(new URL(connectionProcessor.getServerURL() + endpoint + "?" + eventData + "&checksum256=" + sha256Hash(eventData + testSaltValue)), urlConnection.getURL());
    }
    /**
     * Making sure that custom header values are set correctly
     *
     * @throws IOException
     */
    @Test
    public void urlConnectionCustomHeaderValues() throws IOException {
        Map<String, String> customValues = new HashMap<>();
        customValues.put("aa", "bb");
        customValues.put("dd", "cc");
        customValues.put("11", "22");
        customValues.put(null, "33");
        customValues.put("", "44");
        customValues.put("5", "");
        customValues.put("6", null);
        ConnectionProcessor connectionProcessor = new ConnectionProcessor("http://server", mockStore, mockDeviceId, configurationProviderFake, rip, null, customValues, moduleLog, healthTrackerMock);
        final URLConnection urlConnection = connectionProcessor.urlConnectionForServerRequest("eventData", null);
        assertEquals("bb", urlConnection.getRequestProperty("aa"));
        assertEquals("cc", urlConnection.getRequestProperty("dd"));
        assertEquals("22", urlConnection.getRequestProperty("11"));
        assertNull(urlConnection.getRequestProperty(""));
        assertEquals("", urlConnection.getRequestProperty("5"));
        assertNull(urlConnection.getRequestProperty("33"));
    }
    @Test
    public void testRun_storeReturnsNullConnections() throws IOException {
        connectionProcessor = spy(connectionProcessor);
        when(mockStore.getRequests()).thenReturn(null);
        connectionProcessor.run();
        verify(mockStore).getRequests();
        verify(connectionProcessor, times(0)).urlConnectionForServerRequest(anyString(), isNull(String.class));
    }
    @Test
    public void testRun_storeReturnsEmptyConnections() throws IOException {
        connectionProcessor = spy(connectionProcessor);
        when(mockStore.getRequests()).thenReturn(new String[0]);
        connectionProcessor.run();
        verify(mockStore).getRequests();
        verify(connectionProcessor, times(0)).urlConnectionForServerRequest(anyString(), isNull(String.class));
    }
    private static class TestInputStream extends InputStream {
        int readCount = 0;
        boolean fullyRead() {
            return readCount >= 2;
        }
        boolean closed = false;
        @Override
        public int read() {
            return readCount++ < 1 ? 1 : -1;
        }
        @Override
        public void close() throws IOException {
            super.close();
            closed = true;
        }
    }
    private static class CountlyResponseStream extends ByteArrayInputStream {
        boolean closed = false;
        CountlyResponseStream(final String result) throws UnsupportedEncodingException {
            super(("{\"result\":\"" + result + "\"}").getBytes("UTF-8"));
        }
        boolean fullyRead() {
            return pos == buf.length;
        }
        @Override
        public void close() throws IOException {
            super.close();
            closed = true;
        }
    }
    @Test
    public void testRun_storeHasSingleConnection() throws IOException {
        final String eventData = "blahblahblah";
        connectionProcessor = spy(connectionProcessor);
        when(mockStore.getRequests()).thenReturn(new String[] { eventData }, new String[0]);
        when(mockDeviceId.getDeviceId()).thenReturn(testDeviceId);
        final HttpURLConnection mockURLConnection = mock(HttpURLConnection.class);
        final CountlyResponseStream testInputStream = new CountlyResponseStream("Success");
        when(mockURLConnection.getInputStream()).thenReturn(testInputStream);
        when(mockURLConnection.getResponseCode()).thenReturn(200);
        doReturn(mockURLConnection).when(connectionProcessor).urlConnectionForServerRequest(eventData + "&rr=0", null);
        connectionProcessor.run();
        verify(mockStore, times(2)).getRequests();
        verify(connectionProcessor).urlConnectionForServerRequest(eventData + "&rr=0", null);
        verify(mockURLConnection).connect();
        verify(mockURLConnection).getInputStream();
        verify(mockURLConnection).getResponseCode();
        assertTrue(testInputStream.fullyRead());
        verify(mockStore).removeRequest(eventData);
        assertTrue(testInputStream.closed);
        verify(mockURLConnection).disconnect();
    }
    @Test
    public void testRun_storeHasSingleConnection_butHTTPResponseCodeWasNot2xx() throws IOException {
        final String eventData = "blahblahblah";
        connectionProcessor = spy(connectionProcessor);
        when(mockStore.getRequests()).thenReturn(new String[] { eventData }, new String[0]);
        when(mockDeviceId.getDeviceId()).thenReturn(testDeviceId);
        final HttpURLConnection mockURLConnection = mock(HttpURLConnection.class);
        final CountlyResponseStream testInputStream = new CountlyResponseStream("Success");
        when(mockURLConnection.getInputStream()).thenReturn(testInputStream);
        when(mockURLConnection.getResponseCode()).thenReturn(300);
        doReturn(mockURLConnection).when(connectionProcessor).urlConnectionForServerRequest(eventData + "&rr=0", null);
        connectionProcessor.run();
        verify(mockStore, times(1)).getRequests();
        verify(connectionProcessor).urlConnectionForServerRequest(eventData + "&rr=0", null);
        verify(mockURLConnection).connect();
        verify(mockURLConnection).getInputStream();
        verify(mockURLConnection).getResponseCode();
        assertTrue(testInputStream.fullyRead());
        verify(mockStore, times(0)).removeRequest(eventData);
        assertTrue(testInputStream.closed);
        verify(mockURLConnection).disconnect();
    }
    @Test
    public void testRun_storeHasSingleConnection_butResponseWasNotJSON() throws IOException {
        final String eventData = "blahblahblah";
        connectionProcessor = spy(connectionProcessor);
        when(mockStore.getRequests()).thenReturn(new String[] { eventData }, new String[0]);
        when(mockDeviceId.getDeviceId()).thenReturn(testDeviceId);
        final HttpURLConnection mockURLConnection = mock(HttpURLConnection.class);
        final TestInputStream testInputStream = new TestInputStream();
        when(mockURLConnection.getInputStream()).thenReturn(testInputStream);
        when(mockURLConnection.getResponseCode()).thenReturn(200);
        doReturn(mockURLConnection).when(connectionProcessor).urlConnectionForServerRequest(eventData + "&rr=0", null);
        connectionProcessor.run();
        verify(mockStore, times(1)).getRequests();
        verify(connectionProcessor).urlConnectionForServerRequest(eventData + "&rr=0", null);
        verify(mockURLConnection).connect();
        verify(mockURLConnection).getInputStream();
        verify(mockURLConnection).getResponseCode();
        assertTrue(testInputStream.fullyRead());
        verify(mockStore, times(0)).removeRequest(eventData);
        assertTrue(testInputStream.closed);
        verify(mockURLConnection).disconnect();
    }
    @Test
    public void testRun_storeHasSingleConnection_butResponseJSONWasNotSuccess() throws IOException {
        final String eventData = "blahblahblah";
        connectionProcessor = spy(connectionProcessor);
        when(mockStore.getRequests()).thenReturn(new String[] { eventData }, new String[0]);
        when(mockDeviceId.getDeviceId()).thenReturn(testDeviceId);
        final HttpURLConnection mockURLConnection = mock(HttpURLConnection.class);
        final CountlyResponseStream testInputStream = new CountlyResponseStream("Failed");
        when(mockURLConnection.getInputStream()).thenReturn(testInputStream);
        when(mockURLConnection.getResponseCode()).thenReturn(200);
        doReturn(mockURLConnection).when(connectionProcessor).urlConnectionForServerRequest(eventData + "&rr=0", null);
        connectionProcessor.run();
        verify(mockStore, times(2)).getRequests();
        verify(connectionProcessor).urlConnectionForServerRequest(eventData + "&rr=0", null);
        verify(mockURLConnection).connect();
        verify(mockURLConnection).getInputStream();
        assertTrue(testInputStream.fullyRead());
        verify(mockURLConnection).getResponseCode();
        verify(mockStore, times(1)).removeRequest(eventData);
        assertTrue(testInputStream.closed);
        verify(mockURLConnection).disconnect();
    }
    @Test
    public void testRun_storeHasTwoConnections() throws IOException {
        final String eventData1 = "blahblahblah";
        final String eventData2 = "123523523432";
        connectionProcessor = spy(connectionProcessor);
        when(mockStore.getRequests()).thenReturn(new String[] { eventData1, eventData2 }, new String[] { eventData2 }, new String[0]);
        when(mockDeviceId.getDeviceId()).thenReturn(testDeviceId);
        final HttpURLConnection mockURLConnection = mock(HttpURLConnection.class);
        final CountlyResponseStream testInputStream1 = new CountlyResponseStream("Success");
        final CountlyResponseStream testInputStream2 = new CountlyResponseStream("Success");
        when(mockURLConnection.getInputStream()).thenReturn(testInputStream1, testInputStream2);
        doReturn(mockURLConnection).when(connectionProcessor).urlConnectionForServerRequest(eventData1 + "&rr=1", null);
        doReturn(mockURLConnection).when(connectionProcessor).urlConnectionForServerRequest(eventData2 + "&rr=0", null);
        when(mockURLConnection.getResponseCode()).thenReturn(200, 200);
        connectionProcessor.run();
        verify(mockStore, times(3)).getRequests();
        verify(connectionProcessor).urlConnectionForServerRequest(eventData1 + "&rr=1", null);
        verify(connectionProcessor).urlConnectionForServerRequest(eventData2 + "&rr=0", null);
        verify(mockURLConnection, times(2)).connect();
        verify(mockURLConnection, times(2)).getInputStream();
        verify(mockURLConnection, times(2)).getResponseCode();
        assertTrue(testInputStream1.fullyRead());
        assertTrue(testInputStream2.fullyRead());
        verify(mockStore).removeRequest(eventData1);
        verify(mockStore).removeRequest(eventData2);
        assertTrue(testInputStream1.closed);
        assertTrue(testInputStream2.closed);
        verify(mockURLConnection, times(2)).disconnect();
    }
    private static class TestInputStream2 extends InputStream {
        boolean closed = false;
        @Override
        public int read() throws IOException {
            throw new IOException();
        }
        @Override
        public void close() throws IOException {
            super.close();
            closed = true;
        }
    }
}