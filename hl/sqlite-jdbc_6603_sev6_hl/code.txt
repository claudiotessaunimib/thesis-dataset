/*
 * Copyright (c) 2007 David Crawshaw <david@zentus.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
package org.sqlite.core;
import java.sql.BatchUpdateException;
import java.sql.SQLException;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import org.sqlite.BusyHandler;
import org.sqlite.Collation;
import org.sqlite.Function;
import org.sqlite.ProgressHandler;
import org.sqlite.SQLiteCommitListener;
import org.sqlite.SQLiteConfig;
import org.sqlite.SQLiteErrorCode;
import org.sqlite.SQLiteException;
import org.sqlite.SQLiteUpdateListener;
/*
 * This class is the interface to SQLite. It provides some helper functions
 * used by other parts of the driver. The goal of the helper functions here
 * are not only to provide functionality, but to handle contractual
 * differences between the JDBC specification and the SQLite C API.
 *
 * The process of moving SQLite weirdness into this class is incomplete.
 * You'll still find lots of code in Stmt and PrepStmt that are doing
 * implicit contract conversions. Sorry.
 *
 * The subclass, NativeDB, provides the actual access to SQLite functions.
 */
public abstract class DB implements Codes {
    private final String url;
    private final String fileName;
    private final SQLiteConfig config;
    private final AtomicBoolean closed = new AtomicBoolean(true);
    /** The "begin;"and "commit;" statement handles. */
    volatile SafeStmtPtr begin;
    volatile SafeStmtPtr commit;
    /** Tracer for statements to avoid unfinalized statements on db close. */
    private final Set<SafeStmtPtr> stmts = ConcurrentHashMap.newKeySet();
    private final Set<SQLiteUpdateListener> updateListeners = new HashSet<>();
    private final Set<SQLiteCommitListener> commitListeners = new HashSet<>();
    public DB(String url, String fileName, SQLiteConfig config) throws SQLException {
        this.url = url;
        this.fileName = fileName;
        this.config = config;
    }
    public String getUrl() {
        return url;
    }
    public boolean isClosed() {
        return closed.get();
    }
    public SQLiteConfig getConfig() {
        return config;
    }
    // WRAPPER FUNCTIONS ////////////////////////////////////////////
    /**
     * Aborts any pending operation and returns at its earliest opportunity.
     *
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/interrupt.html">https://www.sqlite.org/c3ref/interrupt.html</a>
     */
    public abstract void interrupt() throws SQLException;
    /**
     * Sets a <a href="https://www.sqlite.org/c3ref/busy_handler.html">busy handler</a> that sleeps
     * for a specified amount of time when a table is locked.
     *
     * @param ms Time to sleep in milliseconds.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/busy_timeout.html">https://www.sqlite.org/c3ref/busy_timeout.html</a>
     */
    public abstract void busy_timeout(int ms) throws SQLException;
    /**
     * Sets a <a href="https://www.sqlite.org/c3ref/busy_handler.html">busy handler</a> that sleeps
     * for a specified amount of time when a table is locked.
     *
     * @param busyHandler
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/busy_handler.html">https://www.sqlite.org/c3ref/busy_timeout.html</a>
     */
    public abstract void busy_handler(BusyHandler busyHandler) throws SQLException;
    /**
     * Return English-language text that describes the error as either UTF-8 or UTF-16.
     *
     * @return Error description in English.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/errcode.html">https://www.sqlite.org/c3ref/errcode.html</a>
     */
    abstract String errmsg() throws SQLException;
    /**
     * Returns the value for SQLITE_VERSION, SQLITE_VERSION_NUMBER, and SQLITE_SOURCE_ID C
     * preprocessor macros that are associated with the library.
     *
     * @return Compile-time SQLite version information.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/libversion.html">https://www.sqlite.org/c3ref/libversion.html</a>
     * @see <a
     *     href="https://www.sqlite.org/c3ref/c_source_id.html">https://www.sqlite.org/c3ref/c_source_id.html</a>
     */
    public abstract String libversion() throws SQLException;
    /**
     * @return Number of rows that were changed, inserted or deleted by the last SQL statement
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/changes.html">https://www.sqlite.org/c3ref/changes.html</a>
     */
    public abstract long changes() throws SQLException;
    /**
     * @return Number of row changes caused by INSERT, UPDATE or DELETE statements since the
     *     database connection was opened.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/total_changes.html">https://www.sqlite.org/c3ref/total_changes.html</a>
     */
    public abstract long total_changes() throws SQLException;
    /**
     * Enables or disables the sharing of the database cache and schema data structures between
     * connections to the same database.
     *
     * @param enable True to enable; false otherwise.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/enable_shared_cache.html">https://www.sqlite.org/c3ref/enable_shared_cache.html</a>
     * @see org.sqlite.SQLiteErrorCode
     */
    public abstract int shared_cache(boolean enable) throws SQLException;
    /**
     * Enables or disables loading of SQLite extensions.
     *
     * @param enable True to enable; false otherwise.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/load_extension.html">https://www.sqlite.org/c3ref/load_extension.html</a>
     */
    public abstract int enable_load_extension(boolean enable) throws SQLException;
    /**
     * Executes an SQL statement using the process of compiling, evaluating, and destroying the
     * prepared statement object.
     *
     * @param sql SQL statement to be executed.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/exec.html">https://www.sqlite.org/c3ref/exec.html</a>
     */
    public final synchronized void exec(String sql, boolean autoCommit) throws SQLException {
        SafeStmtPtr pointer = prepare(sql);
        try {
            int rc = pointer.safeRunInt(DB::step);
            switch (rc) {
                case SQLITE_DONE:
                    ensureAutoCommit(autoCommit);
                    return;
                case SQLITE_ROW:
                    return;
                default:
                    throwex(rc);
            }
        } finally {
            pointer.close();
        }
    }
    /**
     * Creates an SQLite interface to a database for the given connection.
     *
     * @param file The database.
     * @param openFlags File opening configurations (<a
     *     href="https://www.sqlite.org/c3ref/c_open_autoproxy.html">https://www.sqlite.org/c3ref/c_open_autoproxy.html</a>)
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/open.html">https://www.sqlite.org/c3ref/open.html</a>
     */
    public final synchronized void open(String file, int openFlags) throws SQLException {
        _open(file, openFlags);
        closed.set(false);
        if (fileName.startsWith("file:") && !fileName.contains("cache=")) {
            // URI cache overrides flags
            shared_cache(config.isEnabledSharedCache());
        }
        enable_load_extension(config.isEnabledLoadExtension());
        busy_timeout(config.getBusyTimeout());
    }
    /**
     * Closes a database connection and finalizes any remaining statements before the closing
     * operation.
     *
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/close.html">https://www.sqlite.org/c3ref/close.html</a>
     */
    public final synchronized void close() throws SQLException {
        // finalize any remaining statements before closing db
        for (SafeStmtPtr element : stmts) {
            element.close();
        }
        // clean up commit object
        if (begin != null) begin.close();
        if (commit != null) commit.close();
        closed.set(true);
        _close();
    }
    /**
     * Complies the an SQL statement.
     *
     * @param stmt The SQL statement to compile.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/prepare.html">https://www.sqlite.org/c3ref/prepare.html</a>
     */
    public final synchronized void prepare(CoreStatement stmt) throws SQLException {
        if (stmt.sql == null) {
            throw new NullPointerException();
        }
        if (stmt.pointer != null) {
            stmt.pointer.close();
        }
        stmt.pointer = prepare(stmt.sql);
        final boolean added = stmts.add(stmt.pointer);
        if (!added) {
            throw new IllegalStateException("Already added pointer to statements set");
        }
    }
    /**
     * Destroys a statement.
     *
     * @param safePtr the pointer wrapper to remove from internal structures
     * @param ptr the raw pointer to free
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException if finalization fails
     * @see <a
     *     href="https://www.sqlite.org/c3ref/finalize.html">https://www.sqlite.org/c3ref/finalize.html</a>
     */
    public synchronized int finalize(SafeStmtPtr safePtr, long ptr) throws SQLException {
        try {
            return finalize(ptr);
        } finally {
            stmts.remove(safePtr);
        }
    }
    /**
     * Creates an SQLite interface to a database with the provided open flags.
     *
     * @param filename The database to open.
     * @param openFlags File opening configurations (<a
     *     href="https://www.sqlite.org/c3ref/c_open_autoproxy.html">https://www.sqlite.org/c3ref/c_open_autoproxy.html</a>)
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/open.html">https://www.sqlite.org/c3ref/open.html</a>
     */
    protected abstract void _open(String filename, int openFlags) throws SQLException;
    /**
     * Closes the SQLite interface to a database.
     *
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/close.html">https://www.sqlite.org/c3ref/close.html</a>
     */
    protected abstract void _close() throws SQLException;
    /**
     * Complies, evaluates, executes and commits an SQL statement.
     *
     * @param sql An SQL statement.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/exec.html">https://www.sqlite.org/c3ref/exec.html</a>
     */
    public abstract int _exec(String sql) throws SQLException;
    /**
     * Complies an SQL statement.
     *
     * @param sql An SQL statement.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/prepare.html">https://www.sqlite.org/c3ref/prepare.html</a>
     */
    protected abstract SafeStmtPtr prepare(String sql) throws SQLException;
    /**
     * Destroys a prepared statement.
     *
     * @param stmt Pointer to the statement pointer.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/finalize.html">https://www.sqlite.org/c3ref/finalize.html</a>
     */
    protected abstract int finalize(long stmt) throws SQLException;
    /**
     * Evaluates a statement.
     *
     * @param stmt Pointer to the statement.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/step.html">https://www.sqlite.org/c3ref/step.html</a>
     */
    public abstract int step(long stmt) throws SQLException;
    /**
     * Sets a prepared statement object back to its initial state, ready to be re-executed.
     *
     * @param stmt Pointer to the statement.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/reset.html">https://www.sqlite.org/c3ref/reset.html</a>
     */
    public abstract int reset(long stmt) throws SQLException;
    /**
     * Reset all bindings on a prepared statement (reset all host parameters to NULL).
     *
     * @param stmt Pointer to the statement.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/clear_bindings.html">https://www.sqlite.org/c3ref/clear_bindings.html</a>
     */
    public abstract int clear_bindings(long stmt) throws SQLException; // TODO remove?
    /**
     * @param stmt Pointer to the statement.
     * @return Number of parameters in a prepared SQL.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/bind_parameter_count.html">https://www.sqlite.org/c3ref/bind_parameter_count.html</a>
     */
    abstract int bind_parameter_count(long stmt) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @return Number of columns in the result set returned by the prepared statement.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_count.html">https://www.sqlite.org/c3ref/column_count.html</a>
     */
    public abstract int column_count(long stmt) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col Number of column.
     * @return Datatype code for the initial data type of the result column.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_blob.html">https://www.sqlite.org/c3ref/column_blob.html</a>
     */
    public abstract int column_type(long stmt, int col) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col Number of column.
     * @return Declared type of the table column for prepared statement.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_decltype.html">https://www.sqlite.org/c3ref/column_decltype.html</a>
     */
    public abstract String column_decltype(long stmt, int col) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col Number of column.
     * @return Original text of column name which is the declared in the CREATE TABLE statement.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_database_name.html">https://www.sqlite.org/c3ref/column_database_name.html</a>
     */
    public abstract String column_table_name(long stmt, int col) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col The number of column.
     * @return Name assigned to a particular column in the result set of a SELECT statement.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_name.html">https://www.sqlite.org/c3ref/column_name.html</a>
     */
    public abstract String column_name(long stmt, int col) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col Number of column.
     * @return Value of the column as text data type in the result set of a SELECT statement.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_blob.html">https://www.sqlite.org/c3ref/column_blob.html</a>
     */
    public abstract String column_text(long stmt, int col) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col Number of column.
     * @return BLOB value of the column in the result set of a SELECT statement
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_blob.html">https://www.sqlite.org/c3ref/column_blob.html</a>
     */
    public abstract byte[] column_blob(long stmt, int col) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col Number of column.
     * @return DOUBLE value of the column in the result set of a SELECT statement
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_blob.html">https://www.sqlite.org/c3ref/column_blob.html</a>
     */
    public abstract double column_double(long stmt, int col) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col Number of column.
     * @return LONG value of the column in the result set of a SELECT statement.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_blob.html">https://www.sqlite.org/c3ref/column_blob.html</a>
     */
    public abstract long column_long(long stmt, int col) throws SQLException;
    /**
     * @param stmt Pointer to the statement.
     * @param col Number of column.
     * @return INT value of column in the result set of a SELECT statement.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/column_blob.html">https://www.sqlite.org/c3ref/column_blob.html</a>
     */
    public abstract int column_int(long stmt, int col) throws SQLException;
    /**
     * Binds NULL value to prepared statements with the pointer to the statement object and the
     * index of the SQL parameter to be set to NULL.
     *
     * @param stmt Pointer to the statement.
     * @param pos The index of the SQL parameter to be set to NULL.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     */
    abstract int bind_null(long stmt, int pos) throws SQLException;
    /**
     * Binds int value to prepared statements with the pointer to the statement object, the index of
     * the SQL parameter to be set and the value to bind to the parameter.
     *
     * @param stmt Pointer to the statement.
     * @param pos The index of the SQL parameter to be set.
     * @param v Value to bind to the parameter.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/bind_blob.html">https://www.sqlite.org/c3ref/bind_blob.html</a>
     */
    abstract int bind_int(long stmt, int pos, int v) throws SQLException;
    /**
     * Binds long value to prepared statements with the pointer to the statement object, the index
     * of the SQL parameter to be set and the value to bind to the parameter.
     *
     * @param stmt Pointer to the statement.
     * @param pos The index of the SQL parameter to be set.
     * @param v Value to bind to the parameter.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/bind_blob.html">https://www.sqlite.org/c3ref/bind_blob.html</a>
     */
    abstract int bind_long(long stmt, int pos, long v) throws SQLException;
    /**
     * Binds double value to prepared statements with the pointer to the statement object, the index
     * of the SQL parameter to be set and the value to bind to the parameter.
     *
     * @param stmt Pointer to the statement.
     * @param pos Index of the SQL parameter to be set.
     * @param v Value to bind to the parameter.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/bind_blob.html">https://www.sqlite.org/c3ref/bind_blob.html</a>
     */
    abstract int bind_double(long stmt, int pos, double v) throws SQLException;
    /**
     * Binds text value to prepared statements with the pointer to the statement object, the index
     * of the SQL parameter to be set and the value to bind to the parameter.
     *
     * @param stmt Pointer to the statement.
     * @param pos Index of the SQL parameter to be set.
     * @param v value to bind to the parameter.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/bind_blob.html">https://www.sqlite.org/c3ref/bind_blob.html</a>
     */
    abstract int bind_text(long stmt, int pos, String v) throws SQLException;
    /**
     * Binds blob value to prepared statements with the pointer to the statement object, the index
     * of the SQL parameter to be set and the value to bind to the parameter.
     *
     * @param stmt Pointer to the statement.
     * @param pos Index of the SQL parameter to be set.
     * @param v Value to bind to the parameter.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/bind_blob.html">https://www.sqlite.org/c3ref/bind_blob.html</a>
     */
    abstract int bind_blob(long stmt, int pos, byte[] v) throws SQLException;
    /**
     * Sets the result of an SQL function as NULL with the pointer to the SQLite database context.
     *
     * @param context Pointer to the SQLite database context.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/result_blob.html">https://www.sqlite.org/c3ref/result_blob.html</a>
     */
    public abstract void result_null(long context) throws SQLException;
    /**
     * Sets the result of an SQL function as text data type with the pointer to the SQLite database
     * context and the the result value of String.
     *
     * @param context Pointer to the SQLite database context.
     * @param val Result value of an SQL function.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/result_blob.html">https://www.sqlite.org/c3ref/result_blob.html</a>
     */
    public abstract void result_text(long context, String val) throws SQLException;
    /**
     * Sets the result of an SQL function as blob data type with the pointer to the SQLite database
     * context and the the result value of byte array.
     *
     * @param context Pointer to the SQLite database context.
     * @param val Result value of an SQL function.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/result_blob.html">https://www.sqlite.org/c3ref/result_blob.html</a>
     */
    public abstract void result_blob(long context, byte[] val) throws SQLException;
    /**
     * Sets the result of an SQL function as double data type with the pointer to the SQLite
     * database context and the the result value of double.
     *
     * @param context Pointer to the SQLite database context.
     * @param val Result value of an SQL function.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/result_blob.html">https://www.sqlite.org/c3ref/result_blob.html</a>
     */
    public abstract void result_double(long context, double val) throws SQLException;
    /**
     * Sets the result of an SQL function as long data type with the pointer to the SQLite database
     * context and the the result value of long.
     *
     * @param context Pointer to the SQLite database context.
     * @param val Result value of an SQL function.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/result_blob.html">https://www.sqlite.org/c3ref/result_blob.html</a>
     */
    public abstract void result_long(long context, long val) throws SQLException;
    /**
     * Sets the result of an SQL function as int data type with the pointer to the SQLite database
     * context and the the result value of int.
     *
     * @param context Pointer to the SQLite database context.
     * @param val Result value of an SQL function.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/result_blob.html">https://www.sqlite.org/c3ref/result_blob.html</a>
     */
    public abstract void result_int(long context, int val) throws SQLException;
    /**
     * Sets the result of an SQL function as an error with the pointer to the SQLite database
     * context and the the error of String.
     *
     * @param context Pointer to the SQLite database context.
     * @param err Error result of an SQL function.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/result_blob.html">https://www.sqlite.org/c3ref/result_blob.html</a>
     */
    public abstract void result_error(long context, String err) throws SQLException;
    /**
     * @param f SQLite function object.
     * @param arg Pointer to the parameter of the SQLite function or aggregate.
     * @return Parameter value of the given SQLite function or aggregate in text data type.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/value_blob.html">https://www.sqlite.org/c3ref/value_blob.html</a>
     */
    public abstract String value_text(Function f, int arg) throws SQLException;
    /**
     * @param f SQLite function object.
     * @param arg Pointer to the parameter of the SQLite function or aggregate.
     * @return Parameter value of the given SQLite function or aggregate in blob data type.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/value_blob.html">https://www.sqlite.org/c3ref/value_blob.html</a>
     */
    public abstract byte[] value_blob(Function f, int arg) throws SQLException;
    /**
     * @param f SQLite function object.
     * @param arg Pointer to the parameter of the SQLite function or aggregate.
     * @return Parameter value of the given SQLite function or aggregate in double data type
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/value_blob.html">https://www.sqlite.org/c3ref/value_blob.html</a>
     */
    public abstract double value_double(Function f, int arg) throws SQLException;
    /**
     * @param f SQLite function object.
     * @param arg Pointer to the parameter of the SQLite function or aggregate.
     * @return Parameter value of the given SQLite function or aggregate in long data type.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/value_blob.html">https://www.sqlite.org/c3ref/value_blob.html</a>
     */
    public abstract long value_long(Function f, int arg) throws SQLException;
    /**
     * Accesses the parameter values on the function or aggregate in int data type with the function
     * object and the parameter value.
     *
     * @param f SQLite function object.
     * @param arg Pointer to the parameter of the SQLite function or aggregate.
     * @return Parameter value of the given SQLite function or aggregate.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/value_blob.html">https://www.sqlite.org/c3ref/value_blob.html</a>
     */
    public abstract int value_int(Function f, int arg) throws SQLException;
    /**
     * @param f SQLite function object.
     * @param arg Pointer to the parameter of the SQLite function or aggregate.
     * @return Parameter datatype of the function or aggregate in int data type.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/value_blob.html">https://www.sqlite.org/c3ref/value_blob.html</a>
     */
    public abstract int value_type(Function f, int arg) throws SQLException;
    /**
     * Create a user defined function with given function name and the function object.
     *
     * @param name The function name to be created.
     * @param f SQLite function object.
     * @param flags Extra flags to use when creating the function, such as {@link
     *     Function#FLAG_DETERMINISTIC}
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/create_function.html">https://www.sqlite.org/c3ref/create_function.html</a>
     */
    public abstract int create_function(String name, Function f, int nArgs, int flags)
            throws SQLException;
    /**
     * De-registers a user defined function
     *
     * @param name Name of the function to de-registered.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     */
    public abstract int destroy_function(String name) throws SQLException;
    /**
     * Create a user defined collation with given collation name and the collation object.
     *
     * @param name The collation name to be created.
     * @param c SQLite collation object.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/create_collation.html">https://www.sqlite.org/c3ref/create_collation.html</a>
     */
    public abstract int create_collation(String name, Collation c) throws SQLException;
    /**
     * Create a user defined collation with given collation name and the collation object.
     *
     * @param name The collation name to be created.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     */
    public abstract int destroy_collation(String name) throws SQLException;
    /**
     * @param dbName Database name to be backed up.
     * @param destFileName Target backup file name.
     * @param observer ProgressObserver object.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     */
    public abstract int backup(String dbName, String destFileName, ProgressObserver observer)
            throws SQLException;
    /**
     * @param dbName Database name to be backed up.
     * @param destFileName Target backup file name.
     * @param observer ProgressObserver object.
     * @param sleepTimeMillis time to wait during a backup/restore operation if sqlite3_backup_step
     *     returns SQLITE_BUSY before continuing
     * @param nTimeouts the number of times sqlite3_backup_step can return SQLITE_BUSY before
     *     failing
     * @param pagesPerStep the number of pages to copy in each sqlite3_backup_step. If this is
     *     negative, the entire DB is copied at once.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     */
    public abstract int backup(
            String dbName,
            String destFileName,
            ProgressObserver observer,
            int sleepTimeMillis,
            int nTimeouts,
            int pagesPerStep)
            throws SQLException;
    /**
     * @param dbName Database name for restoring data.
     * @param sourceFileName Source file name.
     * @param observer ProgressObserver object.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     */
    public abstract int restore(String dbName, String sourceFileName, ProgressObserver observer)
            throws SQLException;
    /**
     * @param dbName the name of the db to restore
     * @param sourceFileName the filename of the source db to restore
     * @param observer ProgressObserver object.
     * @param sleepTimeMillis time to wait during a backup/restore operation if sqlite3_backup_step
     *     returns SQLITE_BUSY before continuing
     * @param nTimeouts the number of times sqlite3_backup_step can return SQLITE_BUSY before
     *     failing
     * @param pagesPerStep the number of pages to copy in each sqlite3_backup_step. If this is
     *     negative, the entire DB is copied at once.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     */
    public abstract int restore(
            String dbName,
            String sourceFileName,
            ProgressObserver observer,
            int sleepTimeMillis,
            int nTimeouts,
            int pagesPerStep)
            throws SQLException;
    /**
     * @param id The id of the limit.
     * @param value The new value of the limit.
     * @return The prior value of the limit
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/limit.html">https://www.sqlite.org/c3ref/limit.html</a>
     */
    public abstract int limit(int id, int value) throws SQLException;
    public interface ProgressObserver {
        void progress(int remaining, int pageCount);
    }
    /** Progress handler */
    public abstract void register_progress_handler(int vmCalls, ProgressHandler progressHandler)
            throws SQLException;
    public abstract void clear_progress_handler() throws SQLException;
    /**
     * Returns an array describing the attributes (not null, primary key and auto increment) of
     * columns.
     *
     * @param stmt Pointer to the statement.
     * @return Column attribute array.<br>
     *     index[col][0] = true if column constrained NOT NULL;<br>
     *     index[col][1] = true if column is part of the primary key; <br>
     *     index[col][2] = true if column is auto-increment.
     * @throws SQLException
     */
    abstract boolean[][] column_metadata(long stmt) throws SQLException;
    // COMPOUND FUNCTIONS ////////////////////////////////////////////
    /**
     * Returns an array of column names in the result set of the SELECT statement.
     *
     * @param stmt Stmt object.
     * @return String array of column names.
     * @throws SQLException
     */
    public final synchronized String[] column_names(long stmt) throws SQLException {
        String[] names = new String[column_count(stmt)];
        for (int i = 0; i < names.length; i++) {
            names[i] = column_name(stmt, i);
        }
        return names;
    }
    /**
     * Bind values to prepared statements
     *
     * @param stmt Pointer to the statement.
     * @param pos Index of the SQL parameter to be set to NULL.
     * @param v Value to bind to the parameter.
     * @return <a href="https://www.sqlite.org/c3ref/c_abort.html">Result Codes</a>
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/bind_blob.html">https://www.sqlite.org/c3ref/bind_blob.html</a>
     */
    final synchronized int sqlbind(long stmt, int pos, Object v) throws SQLException {
        pos++;
        if (v == null) {
            return bind_null(stmt, pos);
        } else if (v instanceof Integer) {
            return bind_int(stmt, pos, (Integer) v);
        } else if (v instanceof Short) {
            return bind_int(stmt, pos, ((Short) v).intValue());
        } else if (v instanceof Long) {
            return bind_long(stmt, pos, (Long) v);
        } else if (v instanceof Float) {
            return bind_double(stmt, pos, ((Float) v).doubleValue());
        } else if (v instanceof Double) {
            return bind_double(stmt, pos, (Double) v);
        } else if (v instanceof String) {
            return bind_text(stmt, pos, (String) v);
        } else if (v instanceof byte[]) {
            return bind_blob(stmt, pos, (byte[]) v);
        } else {
            throw new SQLException("unexpected param type: " + v.getClass());
        }
    }
    /**
     * Submits a batch of commands to the database for execution.
     *
     * @see java.sql.Statement#executeBatch()
     * @param stmt Pointer of Stmt object.
     * @param count Number of SQL statements.
     * @param vals Array of parameter values.
     * @return Array of the number of rows changed or inserted or deleted for each command if all
     *     commands execute successfully;
     * @throws SQLException if statement is not open or is being used elsewhere
     */
    final synchronized long[] executeBatch(
            SafeStmtPtr stmt, int count, Object[] vals, boolean autoCommit) throws SQLException {
        return stmt.safeRun((db, ptr) -> this.executeBatch(ptr, count, vals, autoCommit));
    }
    private synchronized long[] executeBatch(
            long stmt, int count, Object[] vals, boolean autoCommit) throws SQLException {
        if (count < 1) {
            throw new SQLException("count (" + count + ") < 1");
        }
        final int params = bind_parameter_count(stmt);
        int rc;
        long[] changes = new long[count];
        try {
            for (int i = 0; i < count; i++) {
                reset(stmt);
                for (int j = 0; j < params; j++) {
                    rc = sqlbind(stmt, j, vals[(i * params) + j]);
                    if (rc != SQLITE_OK) {
                        throwex(rc);
                    }
                }
                rc = step(stmt);
                if (rc != SQLITE_DONE) {
                    reset(stmt);
                    if (rc == SQLITE_ROW) {
                        throw new BatchUpdateException(
                                "batch entry " + i + ": query returns results",
                                null,
                                0,
                                changes,
                                null);
                    }
                    throwex(rc);
                }
                changes[i] = changes();
            }
        } finally {
            ensureAutoCommit(autoCommit);
        }
        reset(stmt);
        return changes;
    }
    /**
     * @see <a
     *     href="https://www.sqlite.org/c_interface.html#sqlite_exec">https://www.sqlite.org/c_interface.html#sqlite_exec</a>
     * @param stmt Stmt object.
     * @param vals Array of parameter values.
     * @return True if a row of ResultSet is ready; false otherwise.
     * @throws SQLException
     */
    public final synchronized boolean execute(CoreStatement stmt, Object[] vals)
            throws SQLException {
        int statusCode = stmt.pointer.safeRunInt((db, ptr) -> execute(ptr, vals));
        switch (statusCode & 0xFF) {
            case SQLITE_DONE:
                ensureAutoCommit(stmt.conn.getAutoCommit());
                return false;
            case SQLITE_ROW:
                return true;
            case SQLITE_BUSY:
            case SQLITE_LOCKED:
            case SQLITE_MISUSE:
            case SQLITE_CONSTRAINT:
                throw newSQLException(statusCode);
            default:
                stmt.pointer.close();
                throw newSQLException(statusCode);
        }
    }
    private synchronized int execute(long ptr, Object[] vals) throws SQLException {
        if (vals != null) {
            final int params = bind_parameter_count(ptr);
            if (params > vals.length) {
                throw new SQLException(
                        "assertion failure: param count ("
                                + params
                                + ") > value count ("
                                + vals.length
                                + ")");
            }
            for (int i = 0; i < params; i++) {
                int rc = sqlbind(ptr, i, vals[i]);
                if (rc != SQLITE_OK) {
                    throwex(rc);
                }
            }
        }
        int statusCode = step(ptr);
        if ((statusCode & 0xFF) == SQLITE_DONE) reset(ptr);
        return statusCode;
    }
    /**
     * Executes the given SQL statement using the one-step query execution interface.
     *
     * @param sql SQL statement to be executed.
     * @return True if a row of ResultSet is ready; false otherwise.
     * @throws SQLException
     * @see <a
     *     href="https://www.sqlite.org/c3ref/exec.html">https://www.sqlite.org/c3ref/exec.html</a>
     */
    final synchronized boolean execute(String sql, boolean autoCommit) throws SQLException {
        int statusCode = _exec(sql);
        switch (statusCode) {
            case SQLITE_OK:
                return false;
            case SQLITE_DONE:
                ensureAutoCommit(autoCommit);
                return false;
            case SQLITE_ROW:
                return true;
            default:
                throw newSQLException(statusCode);
        }
    }
    /**
     * Execute an SQL INSERT, UPDATE or DELETE statement with the Stmt object and an array of
     * parameter values of the SQL statement..
     *
     * @param stmt Stmt object.
     * @param vals Array of parameter values.
     * @return Number of database rows that were changed or inserted or deleted by the most recently
     *     completed SQL.
     * @throws SQLException
     */
    public final synchronized long executeUpdate(CoreStatement stmt, Object[] vals)
            throws SQLException {
        try {
            if (execute(stmt, vals)) {
                throw new SQLException("query returns results");
            }
        } finally {
            if (!stmt.pointer.isClosed()) {
                stmt.pointer.safeRunInt(DB::reset);
            }
        }
        return changes();
    }
    abstract void set_commit_listener(boolean enabled);
    abstract void set_update_listener(boolean enabled);
    public synchronized void addUpdateListener(SQLiteUpdateListener listener) {
        if (updateListeners.add(listener) && updateListeners.size() == 1) {
            set_update_listener(true);
        }
    }
    public synchronized void addCommitListener(SQLiteCommitListener listener) {
        if (commitListeners.add(listener) && commitListeners.size() == 1) {
            set_commit_listener(true);
        }
    }
    public synchronized void removeUpdateListener(SQLiteUpdateListener listener) {
        if (updateListeners.remove(listener) && updateListeners.isEmpty()) {
            set_update_listener(false);
        }
    }
    public synchronized void removeCommitListener(SQLiteCommitListener listener) {
        if (commitListeners.remove(listener) && commitListeners.isEmpty()) {
            set_commit_listener(false);
        }
    }
    void onUpdate(int type, String database, String table, long rowId) {
        Set<SQLiteUpdateListener> listeners;
        synchronized (this) {
            listeners = new HashSet<>(updateListeners);
        }
        for (SQLiteUpdateListener listener : listeners) {
            SQLiteUpdateListener.Type operationType;
            switch (type) {
                case 18:
                    operationType = SQLiteUpdateListener.Type.INSERT;
                    break;
                case 9:
                    operationType = SQLiteUpdateListener.Type.DELETE;
                    break;
                case 23:
                    operationType = SQLiteUpdateListener.Type.UPDATE;
                    break;
                default:
                    throw new AssertionError("Unknown type: " + type);
            }
            listener.onUpdate(operationType, database, table, rowId);
        }
    }
    void onCommit(boolean commit) {
        Set<SQLiteCommitListener> listeners;
        synchronized (this) {
            listeners = new HashSet<>(commitListeners);
        }
        for (SQLiteCommitListener listener : listeners) {
            if (commit) listener.onCommit();
            else listener.onRollback();
        }
    }
    /**
     * Throws SQLException with error message.
     *
     * @throws SQLException
     */
    final void throwex() throws SQLException {
        throw new SQLException(errmsg());
    }
    /**
     * Throws SQLException with error code.
     *
     * @param errorCode Error code to be passed.
     * @throws SQLException Formatted SQLException with error code.
     */
    public final void throwex(int errorCode) throws SQLException {
        throw newSQLException(errorCode);
    }
    /**
     * Throws SQL Exception with error code and message.
     *
     * @param errorCode Error code to be passed.
     * @param errorMessage Error message to be passed.
     * @throws SQLException Formatted SQLException with error code and message.
     */
    static void throwex(int errorCode, String errorMessage) throws SQLException {
        throw newSQLException(errorCode, errorMessage);
    }
    /**
     * Throws formatted SQLException with error code and message.
     *
     * @param errorCode Error code to be passed.
     * @param errorMessage Error message to be passed.
     * @return Formatted SQLException with error code and message.
     */
    public static SQLiteException newSQLException(int errorCode, String errorMessage) {
        SQLiteErrorCode code = SQLiteErrorCode.getErrorCode(errorCode);
        String msg;
        if (code == SQLiteErrorCode.UNKNOWN_ERROR) {
            msg = String.format("%s:%s (%s)", code, errorCode, errorMessage);
        } else {
            msg = String.format("%s (%s)", code, errorMessage);
        }
        return new SQLiteException(msg, code);
    }
    /**
     * Throws SQL Exception with error code.
     *
     * @param errorCode Error code to be passed.
     * @return SQLException with error code and message.
     * @throws SQLException Formatted SQLException with error code
     */
    private SQLiteException newSQLException(int errorCode) throws SQLException {
        return newSQLException(errorCode, errmsg());
    }
    /**
     * SQLite and the JDBC API have very different ideas about the meaning of auto-commit. Under
     * JDBC, when executeUpdate() returns in auto-commit mode (the default), the programmer assumes
     * the data has been written to disk. In SQLite however, a call to sqlite3_step() with an INSERT
     * statement can return SQLITE_OK, and yet the data is still in limbo.
     *
     * <p>This limbo appears when another statement on the database is active, e.g. a SELECT. SQLite
     * auto-commit waits until the final read statement finishes, and then writes whatever updates
     * have already been OKed. So if a program crashes before the reads are complete, data is lost.
     * E.g:
     *
     * <p>select begins insert select continues select finishes
     *
     * <p>Works as expected, however
     *
     * <p>select beings insert select continues crash
     *
     * <p>Results in the data never being written to disk.
     *
     * <p>As a solution, we call "commit" after every statement in auto-commit mode.
     *
     * @throws SQLException
     */
    final void ensureAutoCommit(boolean autoCommit) throws SQLException {
        if (!autoCommit) {
            return;
        }
        ensureBeginAndCommit();
        begin.safeRunConsume(
                (db, beginPtr) -> {
                    commit.safeRunConsume(
                            (db2, commitPtr) -> ensureAutocommit(beginPtr, commitPtr));
                });
    }
    private void ensureBeginAndCommit() throws SQLException {
        if (begin == null) {
            synchronized (this) {
                if (begin == null) {
                    begin = prepare("begin;");
                }
            }
        }
        if (commit == null) {
            synchronized (this) {
                if (commit == null) {
                    commit = prepare("commit;");
                }
            }
        }
    }
    private void ensureAutocommit(long beginPtr, long commitPtr) throws SQLException {
        try {
            if (step(beginPtr) != SQLITE_DONE) {
                return; // assume we are in a transaction
            }
            int rc = step(commitPtr);
            if (rc != SQLITE_DONE) {
                reset(commitPtr);
                throwex(rc);
            }
            // throw new SQLException("unable to auto-commit");
        } finally {
            reset(beginPtr);
            reset(commitPtr);
        }
    }
    public abstract byte[] serialize(String schema) throws SQLException;
    public abstract void deserialize(String schema, byte[] buff) throws SQLException;
}
/*
 * Copyright (c) 2007 David Crawshaw <david@zentus.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
package org.sqlite.core;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.regex.Pattern;
import org.sqlite.SQLiteConnection;
import org.sqlite.SQLiteConnectionConfig;
import org.sqlite.jdbc3.JDBC3Connection;
import org.sqlite.jdbc4.JDBC4ResultSet;
public abstract class CoreStatement implements Codes {
    public final SQLiteConnection conn;
    protected final CoreResultSet rs;
    public SafeStmtPtr pointer;
    protected String sql = null;
    protected int batchPos;
    protected Object[] batch = null;
    protected boolean resultsWaiting = false;
    private Statement generatedKeysStat = null;
    private ResultSet generatedKeysRs = null;
    // pattern for matching insert statements of the general format starting with INSERT or REPLACE.
    // CTEs used prior to the insert or replace keyword are also be permitted.
    private static final Pattern INSERT_PATTERN =
            Pattern.compile(
                    "^\\s*(?:with\\s+.+\\(.+?\\))*\\s*(?:insert|replace)\\s*",
                    Pattern.DOTALL | Pattern.CASE_INSENSITIVE);
    protected CoreStatement(SQLiteConnection c) {
        conn = c;
        rs = new JDBC4ResultSet(this);
    }
    public DB getDatabase() {
        return conn.getDatabase();
    }
    public SQLiteConnectionConfig getConnectionConfig() {
        return conn.getConnectionConfig();
    }
    /** @throws SQLException If the database is not opened. */
    protected final void checkOpen() throws SQLException {
        if (pointer.isClosed()) throw new SQLException("statement is not executing");
    }
    /**
     * @return True if the database is opened; false otherwise.
     * @throws SQLException
     */
    boolean isOpen() throws SQLException {
        return !pointer.isClosed();
    }
    /**
     * Calls sqlite3_step() and sets up results. Expects a clean stmt.
     *
     * @return True if the ResultSet has at least one row; false otherwise.
     * @throws SQLException If the given SQL statement is null or no database is open.
     */
    protected boolean exec() throws SQLException {
        if (sql == null) throw new SQLException("SQLiteJDBC internal error: sql==null");
        if (rs.isOpen()) throw new SQLException("SQLite JDBC internal error: rs.isOpen() on exec.");
        if (this.conn instanceof JDBC3Connection) {
            ((JDBC3Connection) this.conn).tryEnforceTransactionMode();
        }
        boolean success = false;
        boolean rc = false;
        try {
            rc = conn.getDatabase().execute(this, null);
            success = true;
        } finally {
            notifyFirstStatementExecuted();
            resultsWaiting = rc;
            if (!success) {
                this.pointer.close();
            }
        }
        return pointer.safeRunInt(DB::column_count) != 0;
    }
    /**
     * Executes SQL statement and throws SQLExceptions if the given SQL statement is null or no
     * database is open.
     *
     * @param sql SQL statement.
     * @return True if the ResultSet has at least one row; false otherwise.
     * @throws SQLException If the given SQL statement is null or no database is open.
     */
    protected boolean exec(String sql) throws SQLException {
        if (sql == null) throw new SQLException("SQLiteJDBC internal error: sql==null");
        if (rs.isOpen()) throw new SQLException("SQLite JDBC internal error: rs.isOpen() on exec.");
        if (this.conn instanceof JDBC3Connection) {
            ((JDBC3Connection) this.conn).tryEnforceTransactionMode();
        }
        boolean rc = false;
        boolean success = false;
        try {
            rc = conn.getDatabase().execute(sql, conn.getAutoCommit());
            success = true;
        } finally {
            notifyFirstStatementExecuted();
            resultsWaiting = rc;
            if (!success && pointer != null) {
                pointer.close();
            }
        }
        return pointer.safeRunInt(DB::column_count) != 0;
    }
    protected void internalClose() throws SQLException {
        if (this.pointer != null && !this.pointer.isClosed()) {
            if (conn.isClosed()) throw DB.newSQLException(SQLITE_ERROR, "Connection is closed");
            rs.close();
            batch = null;
            batchPos = 0;
            int resp = this.pointer.close();
            if (resp != SQLITE_OK && resp != SQLITE_MISUSE) conn.getDatabase().throwex(resp);
        }
    }
    protected void notifyFirstStatementExecuted() {
        conn.setFirstStatementExecuted(true);
    }
    public abstract ResultSet executeQuery(String sql, boolean closeStmt) throws SQLException;
    protected void checkIndex(int index) throws SQLException {
        if (batch == null) {
            throw new SQLException("No parameter has been set yet");
        }
        if (index < 1 || index > batch.length) {
            throw new SQLException("Parameter index is invalid");
        }
    }
    protected void clearGeneratedKeys() throws SQLException {
        if (generatedKeysRs != null && !generatedKeysRs.isClosed()) {
            generatedKeysRs.close();
        }
        generatedKeysRs = null;
        if (generatedKeysStat != null && !generatedKeysStat.isClosed()) {
            generatedKeysStat.close();
        }
        generatedKeysStat = null;
    }
    /**
     * SQLite's last_insert_rowid() function is DB-specific. However, in this implementation we
     * ensure the Generated Key result set is statement-specific by executing the query immediately
     * after an insert operation is performed. The caller is simply responsible for calling
     * updateGeneratedKeys on the statement object right after execute in a synchronized(connection)
     * block.
     */
    public void updateGeneratedKeys() throws SQLException {
        if (conn.getConnectionConfig().isGetGeneratedKeys()) {
            clearGeneratedKeys();
            if (sql != null && INSERT_PATTERN.matcher(sql).find()) {
                generatedKeysStat = conn.createStatement();
                generatedKeysRs = generatedKeysStat.executeQuery("SELECT last_insert_rowid();");
            }
        }
    }
    /**
     * This implementation uses SQLite's last_insert_rowid function to obtain the row ID. It cannot
     * provide multiple values when inserting multiple rows. Suggestion is to use a <a
     * href=https://www.sqlite.org/lang_returning.html>RETURNING</a> clause instead.
     *
     * @see java.sql.Statement#getGeneratedKeys()
     */
    public ResultSet getGeneratedKeys() throws SQLException {
        // getGeneratedKeys is required to return an EmptyResult set if the statement
        // did not generate any keys. Thus, if the generateKeysResultSet is NULL, spin
        // up a new result set without any contents by issuing a query with a false where condition
        if (generatedKeysRs == null) {
            generatedKeysStat = conn.createStatement();
            generatedKeysRs = generatedKeysStat.executeQuery("SELECT 1 WHERE 1 = 2;");
        }
        return generatedKeysRs;
    }
}
package org.sqlite.jdbc4;
import java.io.InputStream;
import java.io.Reader;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLXML;
import java.util.Arrays;
import org.sqlite.SQLiteConnection;
import org.sqlite.jdbc3.JDBC3PreparedStatement;
public class JDBC4PreparedStatement extends JDBC3PreparedStatement
        implements PreparedStatement, ParameterMetaData {
    @Override
    public String toString() {
        return sql + " \n parameters=" + Arrays.toString(batch);
    }
    public JDBC4PreparedStatement(SQLiteConnection conn, String sql) throws SQLException {
        super(conn, sql);
    }
    // JDBC 4
    public void setRowId(int parameterIndex, RowId x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setNString(int parameterIndex, String value) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setNCharacterStream(int parameterIndex, Reader value, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setNClob(int parameterIndex, NClob value) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setBlob(int parameterIndex, InputStream inputStream, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setBinaryStream(int parameterIndex, InputStream x, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setCharacterStream(int parameterIndex, Reader reader, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setClob(int parameterIndex, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void setNClob(int parameterIndex, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
}
package org.sqlite.jdbc3;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.JDBCType;
import java.sql.ParameterMetaData;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Calendar;
import org.sqlite.SQLiteConnection;
import org.sqlite.core.CorePreparedStatement;
import org.sqlite.core.DB;
public abstract class JDBC3PreparedStatement extends CorePreparedStatement {
    protected JDBC3PreparedStatement(SQLiteConnection conn, String sql) throws SQLException {
        super(conn, sql);
    }
    /** @see java.sql.PreparedStatement#clearParameters() */
    public void clearParameters() throws SQLException {
        checkOpen();
        pointer.safeRunConsume(DB::clear_bindings);
        if (batch != null) for (int i = batchPos; i < batchPos + paramCount; i++) batch[i] = null;
    }
    /** @see java.sql.PreparedStatement#execute() */
    public boolean execute() throws SQLException {
        checkOpen();
        rs.close();
        pointer.safeRunConsume(DB::reset);
        exhaustedResults = false;
        if (this.conn instanceof JDBC3Connection) {
            ((JDBC3Connection) this.conn).tryEnforceTransactionMode();
        }
        return this.withConnectionTimeout(
                () -> {
                    boolean success = false;
                    try {
                        synchronized (conn) {
                            resultsWaiting =
                                    conn.getDatabase().execute(JDBC3PreparedStatement.this, batch);
                            updateGeneratedKeys();
                            success = true;
                            updateCount = getDatabase().changes();
                        }
                        return 0 != columnCount;
                    } finally {
                        if (!success && !pointer.isClosed()) pointer.safeRunConsume(DB::reset);
                    }
                });
    }
    /** @see java.sql.PreparedStatement#executeQuery() */
    public ResultSet executeQuery() throws SQLException {
        checkOpen();
        if (columnCount == 0) {
            throw new SQLException("Query does not return results");
        }
        rs.close();
        pointer.safeRunConsume(DB::reset);
        exhaustedResults = false;
        if (this.conn instanceof JDBC3Connection) {
            ((JDBC3Connection) this.conn).tryEnforceTransactionMode();
        }
        return this.withConnectionTimeout(
                () -> {
                    boolean success = false;
                    try {
                        resultsWaiting =
                                conn.getDatabase().execute(JDBC3PreparedStatement.this, batch);
                        success = true;
                    } finally {
                        if (!success && !pointer.isClosed()) {
                            pointer.safeRunInt(DB::reset);
                        }
                    }
                    return getResultSet();
                });
    }
    /** @see java.sql.PreparedStatement#executeUpdate() */
    public int executeUpdate() throws SQLException {
        return (int) executeLargeUpdate();
    }
    /** @see java.sql.PreparedStatement#executeLargeUpdate() */
    public long executeLargeUpdate() throws SQLException {
        checkOpen();
        if (columnCount != 0) {
            throw new SQLException("Query returns results");
        }
        rs.close();
        pointer.safeRunConsume(DB::reset);
        exhaustedResults = false;
        if (this.conn instanceof JDBC3Connection) {
            ((JDBC3Connection) this.conn).tryEnforceTransactionMode();
        }
        return this.withConnectionTimeout(
                () -> {
                    synchronized (conn) {
                        long rc =
                                conn.getDatabase()
                                        .executeUpdate(JDBC3PreparedStatement.this, batch);
                        updateGeneratedKeys();
                        return rc;
                    }
                });
    }
    /** @see java.sql.PreparedStatement#addBatch() */
    public void addBatch() throws SQLException {
        checkOpen();
        batchPos += paramCount;
        batchQueryCount++;
        if (batch == null) {
            batch = new Object[paramCount];
        }
        if (batchPos + paramCount > batch.length) {
            Object[] nb = new Object[batch.length * 2];
            System.arraycopy(batch, 0, nb, 0, batch.length);
            batch = nb;
        }
        System.arraycopy(batch, batchPos - paramCount, batch, batchPos, paramCount);
    }
    // ParameterMetaData FUNCTIONS //////////////////////////////////
    /** @see java.sql.PreparedStatement#getParameterMetaData() */
    public ParameterMetaData getParameterMetaData() {
        return (ParameterMetaData) this;
    }
    /** @see java.sql.ParameterMetaData#getParameterCount() */
    public int getParameterCount() throws SQLException {
        checkOpen();
        return paramCount;
    }
    /** @see java.sql.ParameterMetaData#getParameterClassName(int) */
    public String getParameterClassName(int param) throws SQLException {
        checkOpen();
        return "java.lang.String";
    }
    /** @see java.sql.ParameterMetaData#getParameterTypeName(int) */
    public String getParameterTypeName(int pos) throws SQLException {
        checkIndex(pos);
        return JDBCType.valueOf(getParameterType(pos)).getName();
    }
    /** @see java.sql.ParameterMetaData#getParameterType(int) */
    public int getParameterType(int pos) throws SQLException {
        checkIndex(pos);
        Object paramValue = batch[pos - 1];
        if (paramValue == null) {
            return Types.NULL;
        } else if (paramValue instanceof Integer
                || paramValue instanceof Short
                || paramValue instanceof Boolean) {
            return Types.INTEGER;
        } else if (paramValue instanceof Long) {
            return Types.BIGINT;
        } else if (paramValue instanceof Double || paramValue instanceof Float) {
            return Types.REAL;
        } else {
            return Types.VARCHAR;
        }
    }
    /** @see java.sql.ParameterMetaData#getParameterMode(int) */
    public int getParameterMode(int pos) {
        return ParameterMetaData.parameterModeIn;
    }
    /** @see java.sql.ParameterMetaData#getPrecision(int) */
    public int getPrecision(int pos) {
        return 0;
    }
    /** @see java.sql.ParameterMetaData#getScale(int) */
    public int getScale(int pos) {
        return 0;
    }
    /** @see java.sql.ParameterMetaData#isNullable(int) */
    public int isNullable(int pos) {
        return ParameterMetaData.parameterNullable;
    }
    /** @see java.sql.ParameterMetaData#isSigned(int) */
    public boolean isSigned(int pos) {
        return true;
    }
    /** @return */
    public Statement getStatement() {
        return this;
    }
    /** @see java.sql.PreparedStatement#setBigDecimal(int, java.math.BigDecimal) */
    public void setBigDecimal(int pos, BigDecimal value) throws SQLException {
        batch(pos, value == null ? null : value.toString());
    }
    /**
     * Reads given number of bytes from an input stream.
     *
     * @param istream The input stream.
     * @param length The number of bytes to read.
     * @return byte array.
     * @throws SQLException
     */
    private byte[] readBytes(InputStream istream, int length) throws SQLException {
        if (length < 0) {
            throw new SQLException("Error reading stream. Length should be non-negative");
        }
        byte[] bytes = new byte[length];
        try {
            int bytesRead;
            int totalBytesRead = 0;
            while (totalBytesRead < length) {
                bytesRead = istream.read(bytes, totalBytesRead, length - totalBytesRead);
                if (bytesRead == -1) {
                    throw new IOException("End of stream has been reached");
                }
                totalBytesRead += bytesRead;
            }
            return bytes;
        } catch (IOException cause) {
            SQLException exception = new SQLException("Error reading stream");
            exception.initCause(cause);
            throw exception;
        }
    }
    /** @see java.sql.PreparedStatement#setBinaryStream(int, java.io.InputStream, int) */
    public void setBinaryStream(int pos, InputStream istream, int length) throws SQLException {
        if (istream == null && length == 0) {
            setBytes(pos, null);
        }
        setBytes(pos, readBytes(istream, length));
    }
    /** @see java.sql.PreparedStatement#setAsciiStream(int, java.io.InputStream, int) */
    public void setAsciiStream(int pos, InputStream istream, int length) throws SQLException {
        setUnicodeStream(pos, istream, length);
    }
    /** @see java.sql.PreparedStatement#setUnicodeStream(int, java.io.InputStream, int) */
    public void setUnicodeStream(int pos, InputStream istream, int length) throws SQLException {
        if (istream == null && length == 0) {
            setString(pos, null);
        }
        try {
            setString(pos, new String(readBytes(istream, length), "UTF-8"));
        } catch (UnsupportedEncodingException e) {
            SQLException exception = new SQLException("UTF-8 is not supported");
            exception.initCause(e);
            throw exception;
        }
    }
    /** @see java.sql.PreparedStatement#setBoolean(int, boolean) */
    public void setBoolean(int pos, boolean value) throws SQLException {
        setInt(pos, value ? 1 : 0);
    }
    /** @see java.sql.PreparedStatement#setByte(int, byte) */
    public void setByte(int pos, byte value) throws SQLException {
        setInt(pos, value);
    }
    /** @see java.sql.PreparedStatement#setBytes(int, byte[]) */
    public void setBytes(int pos, byte[] value) throws SQLException {
        batch(pos, value);
    }
    /** @see java.sql.PreparedStatement#setDouble(int, double) */
    public void setDouble(int pos, double value) throws SQLException {
        batch(pos, new Double(value));
    }
    /** @see java.sql.PreparedStatement#setFloat(int, float) */
    public void setFloat(int pos, float value) throws SQLException {
        batch(pos, new Float(value));
    }
    /** @see java.sql.PreparedStatement#setInt(int, int) */
    public void setInt(int pos, int value) throws SQLException {
        batch(pos, new Integer(value));
    }
    /** @see java.sql.PreparedStatement#setLong(int, long) */
    public void setLong(int pos, long value) throws SQLException {
        batch(pos, new Long(value));
    }
    /** @see java.sql.PreparedStatement#setNull(int, int) */
    public void setNull(int pos, int u1) throws SQLException {
        setNull(pos, u1, null);
    }
    /** @see java.sql.PreparedStatement#setNull(int, int, java.lang.String) */
    public void setNull(int pos, int u1, String u2) throws SQLException {
        batch(pos, null);
    }
    /** @see java.sql.PreparedStatement#setObject(int, java.lang.Object) */
    public void setObject(int pos, Object value) throws SQLException {
        if (value == null) {
            batch(pos, null);
        } else if (value instanceof java.util.Date) {
            setDateByMilliseconds(pos, ((java.util.Date) value).getTime(), Calendar.getInstance());
        } else if (value instanceof Long) {
            batch(pos, value);
        } else if (value instanceof Integer) {
            batch(pos, value);
        } else if (value instanceof Short) {
            batch(pos, new Integer(((Short) value).intValue()));
        } else if (value instanceof Float) {
            batch(pos, value);
        } else if (value instanceof Double) {
            batch(pos, value);
        } else if (value instanceof Boolean) {
            setBoolean(pos, ((Boolean) value).booleanValue());
        } else if (value instanceof byte[]) {
            batch(pos, value);
        } else if (value instanceof BigDecimal) {
            setBigDecimal(pos, (BigDecimal) value);
        } else {
            batch(pos, value.toString());
        }
    }
    /** @see java.sql.PreparedStatement#setObject(int, java.lang.Object, int) */
    public void setObject(int p, Object v, int t) throws SQLException {
        setObject(p, v);
    }
    /** @see java.sql.PreparedStatement#setObject(int, java.lang.Object, int, int) */
    public void setObject(int p, Object v, int t, int s) throws SQLException {
        setObject(p, v);
    }
    /** @see java.sql.PreparedStatement#setShort(int, short) */
    public void setShort(int pos, short value) throws SQLException {
        setInt(pos, value);
    }
    /** @see java.sql.PreparedStatement#setString(int, java.lang.String) */
    public void setString(int pos, String value) throws SQLException {
        batch(pos, value);
    }
    /** @see java.sql.PreparedStatement#setCharacterStream(int, java.io.Reader, int) */
    public void setCharacterStream(int pos, Reader reader, int length) throws SQLException {
        try {
            // copy chars from reader to StringBuffer
            StringBuffer sb = new StringBuffer();
            char[] cbuf = new char[8192];
            int cnt;
            while ((cnt = reader.read(cbuf)) > 0) {
                sb.append(cbuf, 0, cnt);
            }
            // set as string
            setString(pos, sb.toString());
        } catch (IOException e) {
            throw new SQLException(
                    "Cannot read from character stream, exception message: " + e.getMessage());
        }
    }
    /** @see java.sql.PreparedStatement#setDate(int, java.sql.Date) */
    public void setDate(int pos, Date x) throws SQLException {
        setDate(pos, x, Calendar.getInstance());
    }
    /** @see java.sql.PreparedStatement#setDate(int, java.sql.Date, java.util.Calendar) */
    public void setDate(int pos, Date x, Calendar cal) throws SQLException {
        if (x == null) {
            setObject(pos, null);
        } else {
            setDateByMilliseconds(pos, x.getTime(), cal);
        }
    }
    /** @see java.sql.PreparedStatement#setTime(int, java.sql.Time) */
    public void setTime(int pos, Time x) throws SQLException {
        setTime(pos, x, Calendar.getInstance());
    }
    /** @see java.sql.PreparedStatement#setTime(int, java.sql.Time, java.util.Calendar) */
    public void setTime(int pos, Time x, Calendar cal) throws SQLException {
        if (x == null) {
            setObject(pos, null);
        } else {
            setDateByMilliseconds(pos, x.getTime(), cal);
        }
    }
    /** @see java.sql.PreparedStatement#setTimestamp(int, java.sql.Timestamp) */
    public void setTimestamp(int pos, Timestamp x) throws SQLException {
        setTimestamp(pos, x, Calendar.getInstance());
    }
    /** @see java.sql.PreparedStatement#setTimestamp(int, java.sql.Timestamp, java.util.Calendar) */
    public void setTimestamp(int pos, Timestamp x, Calendar cal) throws SQLException {
        if (x == null) {
            setObject(pos, null);
        } else {
            setDateByMilliseconds(pos, x.getTime(), cal);
        }
    }
    /** @see java.sql.PreparedStatement#getMetaData() */
    public ResultSetMetaData getMetaData() throws SQLException {
        checkOpen();
        return (ResultSetMetaData) rs;
    }
    protected SQLException unsupported() {
        return new SQLFeatureNotSupportedException("not implemented by SQLite JDBC driver");
    }
    protected SQLException invalid() {
        return new SQLException("method cannot be called on a PreparedStatement");
    }
    // PreparedStatement ////////////////////////////////////////////
    public void setArray(int i, Array x) throws SQLException {
        throw unsupported();
    }
    public void setBlob(int i, Blob x) throws SQLException {
        throw unsupported();
    }
    public void setClob(int i, Clob x) throws SQLException {
        throw unsupported();
    }
    public void setRef(int i, Ref x) throws SQLException {
        throw unsupported();
    }
    public void setURL(int pos, URL x) throws SQLException {
        throw unsupported();
    }
    /** @see org.sqlite.core.CoreStatement#exec(java.lang.String) */
    @Override
    public boolean execute(String sql) throws SQLException {
        throw invalid();
    }
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        throw invalid();
    }
    public boolean execute(String sql, int[] colinds) throws SQLException {
        throw invalid();
    }
    public boolean execute(String sql, String[] colnames) throws SQLException {
        throw invalid();
    }
    /** @see org.sqlite.core.CoreStatement#exec(java.lang.String) */
    @Override
    public int executeUpdate(String sql) throws SQLException {
        throw invalid();
    }
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw invalid();
    }
    public int executeUpdate(String sql, int[] colinds) throws SQLException {
        throw invalid();
    }
    public int executeUpdate(String sql, String[] cols) throws SQLException {
        throw invalid();
    }
    public long executeLargeUpdate(String sql) throws SQLException {
        throw invalid();
    }
    public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        throw invalid();
    }
    public long executeLargeUpdate(String sql, int[] colinds) throws SQLException {
        throw invalid();
    }
    public long executeLargeUpdate(String sql, String[] cols) throws SQLException {
        throw invalid();
    }
    /** @see org.sqlite.core.CoreStatement#exec(String) */
    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        throw invalid();
    }
    /** */
    @Override
    public void addBatch(String sql) throws SQLException {
        throw invalid();
    }
}
package org.sqlite.jdbc4;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Date;
import java.sql.NClob;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Map;
import org.sqlite.core.CoreStatement;
import org.sqlite.jdbc3.JDBC3ResultSet;
public class JDBC4ResultSet extends JDBC3ResultSet implements ResultSet, ResultSetMetaData {
    public JDBC4ResultSet(CoreStatement stmt) {
        super(stmt);
    }
    @Override
    public void close() throws SQLException {
        final boolean wasOpen = isOpen(); // prevent close() recursion
        super.close();
        // close-on-completion regardless of closeStmt
        if (wasOpen && stmt instanceof JDBC4Statement) {
            JDBC4Statement stat = (JDBC4Statement) stmt;
            // check if its not closed already in which case no-op
            if (stat.closeOnCompletion && !stat.isClosed()) {
                stat.close();
            }
        }
    }
    // JDBC 4
    public <T> T unwrap(Class<T> iface) throws ClassCastException {
        return iface.cast(this);
    }
    public boolean isWrapperFor(Class<?> iface) {
        return iface.isInstance(this);
    }
    public RowId getRowId(int columnIndex) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public RowId getRowId(String columnLabel) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateRowId(int columnIndex, RowId x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateRowId(String columnLabel, RowId x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public int getHoldability() throws SQLException {
        // TODO Auto-generated method stub
        return 0;
    }
    public boolean isClosed() throws SQLException {
        return !isOpen();
    }
    public void updateNString(int columnIndex, String nString) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNString(String columnLabel, String nString) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNClob(String columnLabel, NClob nClob) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public NClob getNClob(int columnIndex) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public NClob getNClob(String columnLabel) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public SQLXML getSQLXML(int columnIndex) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public SQLXML getSQLXML(String columnLabel) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateSQLXML(String columnLabel, SQLXML xmlObject) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public String getNString(int columnIndex) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public String getNString(String columnLabel) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public Reader getNCharacterStream(int col) throws SQLException {
        String data = getString(col);
        return getNCharacterStreamInternal(data);
    }
    private Reader getNCharacterStreamInternal(String data) {
        if (data == null) {
            return null;
        }
        Reader reader = new StringReader(data);
        return reader;
    }
    public Reader getNCharacterStream(String col) throws SQLException {
        String data = getString(col);
        return getNCharacterStreamInternal(data);
    }
    public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNCharacterStream(String columnLabel, Reader reader, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateBinaryStream(int columnIndex, InputStream x, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateAsciiStream(String columnLabel, InputStream x, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateBinaryStream(String columnLabel, InputStream x, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateCharacterStream(String columnLabel, Reader reader, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateBlob(int columnIndex, InputStream inputStream, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateBlob(String columnLabel, InputStream inputStream, long length)
            throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateClob(int columnIndex, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateClob(String columnLabel, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNClob(int columnIndex, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public void updateNClob(String columnLabel, Reader reader) throws SQLException {
        // TODO Support this
        throw new SQLFeatureNotSupportedException();
    }
    public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
        if (type == null) throw new SQLException("requested type cannot be null");
        if (type == String.class) return type.cast(getString(columnIndex));
        if (type == Boolean.class) return type.cast(getBoolean(columnIndex));
        if (type == BigDecimal.class) return type.cast(getBigDecimal(columnIndex));
        if (type == byte[].class) return type.cast(getBytes(columnIndex));
        if (type == Date.class) return type.cast(getDate(columnIndex));
        if (type == Time.class) return type.cast(getTime(columnIndex));
        if (type == Timestamp.class) return type.cast(getTimestamp(columnIndex));
        if (type == LocalDate.class) {
            try {
                Date date = getDate(columnIndex);
                if (date != null) return type.cast(date.toLocalDate());
                else return null;
            } catch (SQLException sqlException) {
                // If the FastDateParser failed, try parse it with LocalDate.
                // It's a workaround for a value like '2022-12-1' (i.e no time presents).
                return type.cast(LocalDate.parse(getString(columnIndex)));
            }
        }
        if (type == LocalTime.class) {
            try {
                Time time = getTime(columnIndex);
                if (time != null) return type.cast(time.toLocalTime());
                else return null;
            } catch (SQLException sqlException) {
                // If the FastDateParser failed, try parse it with LocalTime.
                // It's a workaround for a value like '11:22:22' (i.e no date presents).
                return type.cast(LocalTime.parse(getString(columnIndex)));
            }
        }
        if (type == LocalDateTime.class) {
            try {
                Timestamp timestamp = getTimestamp(columnIndex);
                if (timestamp != null) return type.cast(timestamp.toLocalDateTime());
                else return null;
            } catch (SQLException e) {
                // If the FastDateParser failed, try parse it with LocalDateTime.
                return type.cast(LocalDateTime.parse(getString(columnIndex)));
            }
        }
        int columnType = safeGetColumnType(markCol(columnIndex));
        if (type == Double.class) {
            if (columnType == SQLITE_INTEGER || columnType == SQLITE_FLOAT)
                return type.cast(getDouble(columnIndex));
            throw new SQLException("Bad value for type Double");
        }
        if (type == Long.class) {
            if (columnType == SQLITE_INTEGER || columnType == SQLITE_FLOAT)
                return type.cast(getLong(columnIndex));
            throw new SQLException("Bad value for type Long");
        }
        if (type == Float.class) {
            if (columnType == SQLITE_INTEGER || columnType == SQLITE_FLOAT)
                return type.cast(getFloat(columnIndex));
            throw new SQLException("Bad value for type Float");
        }
        if (type == Integer.class) {
            if (columnType == SQLITE_INTEGER || columnType == SQLITE_FLOAT)
                return type.cast(getInt(columnIndex));
            throw new SQLException("Bad value for type Integer");
        }
        throw unsupported();
    }
    public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
        return getObject(findColumn(columnLabel), type);
    }
    protected SQLException unsupported() {
        return new SQLFeatureNotSupportedException("not implemented by SQLite JDBC driver");
    }
    // ResultSet ////////////////////////////////////////////////////
    public Array getArray(int i) throws SQLException {
        throw unsupported();
    }
    public Array getArray(String col) throws SQLException {
        throw unsupported();
    }
    public InputStream getAsciiStream(int col) throws SQLException {
        String data = getString(col);
        return getAsciiStreamInternal(data);
    }
    public InputStream getAsciiStream(String col) throws SQLException {
        String data = getString(col);
        return getAsciiStreamInternal(data);
    }
    private InputStream getAsciiStreamInternal(String data) {
        if (data == null) {
            return null;
        }
        InputStream inputStream;
        try {
            inputStream = new ByteArrayInputStream(data.getBytes("ASCII"));
        } catch (UnsupportedEncodingException e) {
            return null;
        }
        return inputStream;
    }
    @Deprecated
    public BigDecimal getBigDecimal(int col, int s) throws SQLException {
        throw unsupported();
    }
    @Deprecated
    public BigDecimal getBigDecimal(String col, int s) throws SQLException {
        throw unsupported();
    }
    public Blob getBlob(int col) throws SQLException {
        throw unsupported();
    }
    public Blob getBlob(String col) throws SQLException {
        throw unsupported();
    }
    public Clob getClob(int col) throws SQLException {
        String clob = getString(col);
        return clob == null ? null : new SqliteClob(clob);
    }
    public Clob getClob(String col) throws SQLException {
        String clob = getString(col);
        return clob == null ? null : new SqliteClob(clob);
    }
    @SuppressWarnings("rawtypes")
    public Object getObject(int col, Map map) throws SQLException {
        throw unsupported();
    }
    @SuppressWarnings("rawtypes")
    public Object getObject(String col, Map map) throws SQLException {
        throw unsupported();
    }
    public Ref getRef(int i) throws SQLException {
        throw unsupported();
    }
    public Ref getRef(String col) throws SQLException {
        throw unsupported();
    }
    public InputStream getUnicodeStream(int col) throws SQLException {
        return getAsciiStream(col);
    }
    public InputStream getUnicodeStream(String col) throws SQLException {
        return getAsciiStream(col);
    }
    public URL getURL(int col) throws SQLException {
        throw unsupported();
    }
    public URL getURL(String col) throws SQLException {
        throw unsupported();
    }
    public void insertRow() throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public void moveToCurrentRow() throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public void moveToInsertRow() throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public boolean last() throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public boolean previous() throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public boolean relative(int rows) throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public boolean absolute(int row) throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public void afterLast() throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public void beforeFirst() throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public boolean first() throws SQLException {
        throw new SQLException("ResultSet is TYPE_FORWARD_ONLY");
    }
    public void cancelRowUpdates() throws SQLException {
        throw unsupported();
    }
    public void deleteRow() throws SQLException {
        throw unsupported();
    }
    public void updateArray(int col, Array x) throws SQLException {
        throw unsupported();
    }
    public void updateArray(String col, Array x) throws SQLException {
        throw unsupported();
    }
    public void updateAsciiStream(int col, InputStream x, int l) throws SQLException {
        throw unsupported();
    }
    public void updateAsciiStream(String col, InputStream x, int l) throws SQLException {
        throw unsupported();
    }
    public void updateBigDecimal(int col, BigDecimal x) throws SQLException {
        throw unsupported();
    }
    public void updateBigDecimal(String col, BigDecimal x) throws SQLException {
        throw unsupported();
    }
    public void updateBinaryStream(int c, InputStream x, int l) throws SQLException {
        throw unsupported();
    }
    public void updateBinaryStream(String c, InputStream x, int l) throws SQLException {
        throw unsupported();
    }
    public void updateBlob(int col, Blob x) throws SQLException {
        throw unsupported();
    }
    public void updateBlob(String col, Blob x) throws SQLException {
        throw unsupported();
    }
    public void updateBoolean(int col, boolean x) throws SQLException {
        throw unsupported();
    }
    public void updateBoolean(String col, boolean x) throws SQLException {
        throw unsupported();
    }
    public void updateByte(int col, byte x) throws SQLException {
        throw unsupported();
    }
    public void updateByte(String col, byte x) throws SQLException {
        throw unsupported();
    }
    public void updateBytes(int col, byte[] x) throws SQLException {
        throw unsupported();
    }
    public void updateBytes(String col, byte[] x) throws SQLException {
        throw unsupported();
    }
    public void updateCharacterStream(int c, Reader x, int l) throws SQLException {
        throw unsupported();
    }
    public void updateCharacterStream(String c, Reader r, int l) throws SQLException {
        throw unsupported();
    }
    public void updateClob(int col, Clob x) throws SQLException {
        throw unsupported();
    }
    public void updateClob(String col, Clob x) throws SQLException {
        throw unsupported();
    }
    public void updateDate(int col, Date x) throws SQLException {
        throw unsupported();
    }
    public void updateDate(String col, Date x) throws SQLException {
        throw unsupported();
    }
    public void updateDouble(int col, double x) throws SQLException {
        throw unsupported();
    }
    public void updateDouble(String col, double x) throws SQLException {
        throw unsupported();
    }
    public void updateFloat(int col, float x) throws SQLException {
        throw unsupported();
    }
    public void updateFloat(String col, float x) throws SQLException {
        throw unsupported();
    }
    public void updateInt(int col, int x) throws SQLException {
        throw unsupported();
    }
    public void updateInt(String col, int x) throws SQLException {
        throw unsupported();
    }
    public void updateLong(int col, long x) throws SQLException {
        throw unsupported();
    }
    public void updateLong(String col, long x) throws SQLException {
        throw unsupported();
    }
    public void updateNull(int col) throws SQLException {
        throw unsupported();
    }
    public void updateNull(String col) throws SQLException {
        throw unsupported();
    }
    public void updateObject(int c, Object x) throws SQLException {
        throw unsupported();
    }
    public void updateObject(int c, Object x, int s) throws SQLException {
        throw unsupported();
    }
    public void updateObject(String col, Object x) throws SQLException {
        throw unsupported();
    }
    public void updateObject(String c, Object x, int s) throws SQLException {
        throw unsupported();
    }
    public void updateRef(int col, Ref x) throws SQLException {
        throw unsupported();
    }
    public void updateRef(String c, Ref x) throws SQLException {
        throw unsupported();
    }
    public void updateRow() throws SQLException {
        throw unsupported();
    }
    public void updateShort(int c, short x) throws SQLException {
        throw unsupported();
    }
    public void updateShort(String c, short x) throws SQLException {
        throw unsupported();
    }
    public void updateString(int c, String x) throws SQLException {
        throw unsupported();
    }
    public void updateString(String c, String x) throws SQLException {
        throw unsupported();
    }
    public void updateTime(int c, Time x) throws SQLException {
        throw unsupported();
    }
    public void updateTime(String c, Time x) throws SQLException {
        throw unsupported();
    }
    public void updateTimestamp(int c, Timestamp x) throws SQLException {
        throw unsupported();
    }
    public void updateTimestamp(String c, Timestamp x) throws SQLException {
        throw unsupported();
    }
    public void refreshRow() throws SQLException {
        throw unsupported();
    }
    class SqliteClob implements NClob {
        private String data;
        protected SqliteClob(String data) {
            this.data = data;
        }
        public void free() throws SQLException {
            data = null;
        }
        public InputStream getAsciiStream() throws SQLException {
            return getAsciiStreamInternal(data);
        }
        public Reader getCharacterStream() throws SQLException {
            return getNCharacterStreamInternal(data);
        }
        public Reader getCharacterStream(long arg0, long arg1) throws SQLException {
            return getNCharacterStreamInternal(data);
        }
        public String getSubString(long position, int length) throws SQLException {
            if (data == null) {
                throw new SQLException("no data");
            }
            if (position < 1) {
                throw new SQLException("Position must be greater than or equal to 1");
            }
            if (length < 0) {
                throw new SQLException("Length must be greater than or equal to 0");
            }
            int start = (int) position - 1;
            return data.substring(start, Math.min(start + length, data.length()));
        }
        public long length() throws SQLException {
            if (data == null) {
                throw new SQLException("no data");
            }
            return data.length();
        }
        public long position(String arg0, long arg1) throws SQLException {
            unsupported();
            return -1;
        }
        public long position(Clob arg0, long arg1) throws SQLException {
            unsupported();
            return -1;
        }
        public OutputStream setAsciiStream(long arg0) throws SQLException {
            unsupported();
            return null;
        }
        public Writer setCharacterStream(long arg0) throws SQLException {
            unsupported();
            return null;
        }
        public int setString(long arg0, String arg1) throws SQLException {
            unsupported();
            return -1;
        }
        public int setString(long arg0, String arg1, int arg2, int arg3) throws SQLException {
            unsupported();
            return -1;
        }
        public void truncate(long arg0) throws SQLException {
            unsupported();
        }
    }
}
package org.sqlite.jdbc3;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.math.BigDecimal;
import java.sql.Date;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sqlite.core.CoreResultSet;
import org.sqlite.core.CoreStatement;
import org.sqlite.core.DB;
import org.sqlite.date.FastDateFormat;
public abstract class JDBC3ResultSet extends CoreResultSet {
    // ResultSet Functions //////////////////////////////////////////
    protected JDBC3ResultSet(CoreStatement stmt) {
        super(stmt);
    }
    /**
     * returns col in [1,x] form
     *
     * @see java.sql.ResultSet#findColumn(java.lang.String)
     */
    public int findColumn(String col) throws SQLException {
        checkOpen();
        Integer index = findColumnIndexInCache(col);
        if (index != null) {
            return index;
        }
        for (int i = 0; i < cols.length; i++) {
            if (col.equalsIgnoreCase(cols[i])) {
                return addColumnIndexInCache(col, i + 1);
            }
        }
        throw new SQLException("no such column: '" + col + "'");
    }
    /** @see java.sql.ResultSet#next() */
    public boolean next() throws SQLException {
        if (!open || emptyResultSet || pastLastRow) {
            return false; // finished ResultSet
        }
        lastCol = -1;
        // first row is loaded by execute(), so do not step() again
        if (row == 0) {
            row++;
            return true;
        }
        // check if we are row limited by the statement or the ResultSet
        if (maxRows != 0 && row == maxRows) {
            return false;
        }
        // do the real work
        int statusCode = stmt.pointer.safeRunInt(DB::step);
        switch (statusCode) {
            case SQLITE_DONE:
                pastLastRow = true;
                return false;
            case SQLITE_ROW:
                row++;
                return true;
            case SQLITE_BUSY:
            default:
                getDatabase().throwex(statusCode);
                return false;
        }
    }
    /** @see java.sql.ResultSet#getType() */
    public int getType() {
        return ResultSet.TYPE_FORWARD_ONLY;
    }
    /** @see java.sql.ResultSet#getFetchSize() */
    public int getFetchSize() {
        return limitRows;
    }
    /** @see java.sql.ResultSet#setFetchSize(int) */
    public void setFetchSize(int rows) throws SQLException {
        if (0 > rows || (maxRows != 0 && rows > maxRows)) {
            throw new SQLException("fetch size " + rows + " out of bounds " + maxRows);
        }
        limitRows = rows;
    }
    /** @see java.sql.ResultSet#getFetchDirection() */
    public int getFetchDirection() throws SQLException {
        checkOpen();
        return ResultSet.FETCH_FORWARD;
    }
    /** @see java.sql.ResultSet#setFetchDirection(int) */
    public void setFetchDirection(int d) throws SQLException {
        checkOpen();
        // Only FORWARD_ONLY ResultSets exist in SQLite, so only FETCH_FORWARD is permitted
        if (
        /*getType() == ResultSet.TYPE_FORWARD_ONLY &&*/
        d != ResultSet.FETCH_FORWARD) {
            throw new SQLException("only FETCH_FORWARD direction supported");
        }
    }
    /** @see java.sql.ResultSet#isAfterLast() */
    public boolean isAfterLast() {
        return pastLastRow && !emptyResultSet;
    }
    /** @see java.sql.ResultSet#isBeforeFirst() */
    public boolean isBeforeFirst() {
        return !emptyResultSet && open && row == 0;
    }
    /** @see java.sql.ResultSet#isFirst() */
    public boolean isFirst() {
        return row == 1;
    }
    /** @see java.sql.ResultSet#isLast() */
    public boolean isLast() throws SQLException {
        throw new SQLFeatureNotSupportedException("not supported by sqlite");
    }
    /** @see java.sql.ResultSet#getRow() */
    public int getRow() {
        return row;
    }
    /** @see java.sql.ResultSet#wasNull() */
    public boolean wasNull() throws SQLException {
        return safeGetColumnType(markCol(lastCol)) == SQLITE_NULL;
    }
    // DATA ACCESS FUNCTIONS ////////////////////////////////////////
    /** @see java.sql.ResultSet#getBigDecimal(int) */
    public BigDecimal getBigDecimal(int col) throws SQLException {
        switch (safeGetColumnType(checkCol(col))) {
            case SQLITE_NULL:
                return null;
            case SQLITE_INTEGER:
                return BigDecimal.valueOf(safeGetLongCol(col));
            case SQLITE_FLOAT:
                // avoid double precision
            default:
                final String stringValue = safeGetColumnText(col);
                try {
                    return new BigDecimal(stringValue);
                } catch (NumberFormatException e) {
                    throw new SQLException("Bad value for type BigDecimal : " + stringValue);
                }
        }
    }
    /** @see java.sql.ResultSet#getBigDecimal(java.lang.String) */
    public BigDecimal getBigDecimal(String col) throws SQLException {
        return getBigDecimal(findColumn(col));
    }
    /** @see java.sql.ResultSet#getBoolean(int) */
    public boolean getBoolean(int col) throws SQLException {
        return getInt(col) != 0;
    }
    /** @see java.sql.ResultSet#getBoolean(java.lang.String) */
    public boolean getBoolean(String col) throws SQLException {
        return getBoolean(findColumn(col));
    }
    /** @see java.sql.ResultSet#getBinaryStream(int) */
    public InputStream getBinaryStream(int col) throws SQLException {
        byte[] bytes = getBytes(col);
        if (bytes != null) {
            return new ByteArrayInputStream(bytes);
        } else {
            return null;
        }
    }
    /** @see java.sql.ResultSet#getBinaryStream(java.lang.String) */
    public InputStream getBinaryStream(String col) throws SQLException {
        return getBinaryStream(findColumn(col));
    }
    /** @see java.sql.ResultSet#getByte(int) */
    public byte getByte(int col) throws SQLException {
        return (byte) getInt(col);
    }
    /** @see java.sql.ResultSet#getByte(java.lang.String) */
    public byte getByte(String col) throws SQLException {
        return getByte(findColumn(col));
    }
    /** @see java.sql.ResultSet#getBytes(int) */
    public byte[] getBytes(int col) throws SQLException {
        return stmt.pointer.safeRun((db, ptr) -> db.column_blob(ptr, markCol(col)));
    }
    /** @see java.sql.ResultSet#getBytes(java.lang.String) */
    public byte[] getBytes(String col) throws SQLException {
        return getBytes(findColumn(col));
    }
    /** @see java.sql.ResultSet#getCharacterStream(int) */
    public Reader getCharacterStream(int col) throws SQLException {
        String string = getString(col);
        return string == null ? null : new StringReader(string);
    }
    /** @see java.sql.ResultSet#getCharacterStream(java.lang.String) */
    public Reader getCharacterStream(String col) throws SQLException {
        return getCharacterStream(findColumn(col));
    }
    /** @see java.sql.ResultSet#getDate(int) */
    public Date getDate(int col) throws SQLException {
        switch (safeGetColumnType(markCol(col))) {
            case SQLITE_NULL:
                return null;
            case SQLITE_TEXT:
                String dateText = safeGetColumnText(col);
                if ("".equals(dateText)) {
                    return null;
                }
                try {
                    return new Date(
                            getConnectionConfig().getDateFormat().parse(dateText).getTime());
                } catch (Exception e) {
                    throw new SQLException("Error parsing date", e);
                }
            case SQLITE_FLOAT:
                return new Date(julianDateToCalendar(safeGetDoubleCol(col)).getTimeInMillis());
            default: // SQLITE_INTEGER:
                return new Date(safeGetLongCol(col) * getConnectionConfig().getDateMultiplier());
        }
    }
    /** @see java.sql.ResultSet#getDate(int, java.util.Calendar) */
    public Date getDate(int col, Calendar cal) throws SQLException {
        requireCalendarNotNull(cal);
        switch (safeGetColumnType(markCol(col))) {
            case SQLITE_NULL:
                return null;
            case SQLITE_TEXT:
                String dateText = safeGetColumnText(col);
                if ("".equals(dateText)) {
                    return null;
                }
                try {
                    FastDateFormat dateFormat =
                            FastDateFormat.getInstance(
                                    getConnectionConfig().getDateStringFormat(), cal.getTimeZone());
                    return new java.sql.Date(dateFormat.parse(dateText).getTime());
                } catch (Exception e) {
                    throw new SQLException("Error parsing time stamp", e);
                }
            case SQLITE_FLOAT:
                return new Date(julianDateToCalendar(safeGetDoubleCol(col), cal).getTimeInMillis());
            default: // SQLITE_INTEGER:
                cal.setTimeInMillis(
                        safeGetLongCol(col) * getConnectionConfig().getDateMultiplier());
                return new Date(cal.getTime().getTime());
        }
    }
    /** @see java.sql.ResultSet#getDate(java.lang.String) */
    public Date getDate(String col) throws SQLException {
        return getDate(findColumn(col), Calendar.getInstance());
    }
    /** @see java.sql.ResultSet#getDate(java.lang.String, java.util.Calendar) */
    public Date getDate(String col, Calendar cal) throws SQLException {
        return getDate(findColumn(col), cal);
    }
    /** @see java.sql.ResultSet#getDouble(int) */
    public double getDouble(int col) throws SQLException {
        if (safeGetColumnType(markCol(col)) == SQLITE_NULL) {
            return 0;
        }
        return safeGetDoubleCol(col);
    }
    /** @see java.sql.ResultSet#getDouble(java.lang.String) */
    public double getDouble(String col) throws SQLException {
        return getDouble(findColumn(col));
    }
    /** @see java.sql.ResultSet#getFloat(int) */
    public float getFloat(int col) throws SQLException {
        if (safeGetColumnType(markCol(col)) == SQLITE_NULL) {
            return 0;
        }
        return (float) safeGetDoubleCol(col);
    }
    /** @see java.sql.ResultSet#getFloat(java.lang.String) */
    public float getFloat(String col) throws SQLException {
        return getFloat(findColumn(col));
    }
    /** @see java.sql.ResultSet#getInt(int) */
    public int getInt(int col) throws SQLException {
        return stmt.pointer.safeRunInt((db, ptr) -> db.column_int(ptr, markCol(col)));
    }
    /** @see java.sql.ResultSet#getInt(java.lang.String) */
    public int getInt(String col) throws SQLException {
        return getInt(findColumn(col));
    }
    /** @see java.sql.ResultSet#getLong(int) */
    public long getLong(int col) throws SQLException {
        return safeGetLongCol(col);
    }
    /** @see java.sql.ResultSet#getLong(java.lang.String) */
    public long getLong(String col) throws SQLException {
        return getLong(findColumn(col));
    }
    /** @see java.sql.ResultSet#getShort(int) */
    public short getShort(int col) throws SQLException {
        return (short) getInt(col);
    }
    /** @see java.sql.ResultSet#getShort(java.lang.String) */
    public short getShort(String col) throws SQLException {
        return getShort(findColumn(col));
    }
    /** @see java.sql.ResultSet#getString(int) */
    public String getString(int col) throws SQLException {
        return safeGetColumnText(col);
    }
    /** @see java.sql.ResultSet#getString(java.lang.String) */
    public String getString(String col) throws SQLException {
        return getString(findColumn(col));
    }
    /** @see java.sql.ResultSet#getTime(int) */
    public Time getTime(int col) throws SQLException {
        switch (safeGetColumnType(markCol(col))) {
            case SQLITE_NULL:
                return null;
            case SQLITE_TEXT:
                String dateText = safeGetColumnText(col);
                if ("".equals(dateText)) {
                    return null;
                }
                try {
                    return new Time(
                            getConnectionConfig().getDateFormat().parse(dateText).getTime());
                } catch (Exception e) {
                    throw new SQLException("Error parsing time", e);
                }
            case SQLITE_FLOAT:
                return new Time(julianDateToCalendar(safeGetDoubleCol(col)).getTimeInMillis());
            default: // SQLITE_INTEGER
                return new Time(safeGetLongCol(col) * getConnectionConfig().getDateMultiplier());
        }
    }
    /** @see java.sql.ResultSet#getTime(int, java.util.Calendar) */
    public Time getTime(int col, Calendar cal) throws SQLException {
        requireCalendarNotNull(cal);
        switch (safeGetColumnType(markCol(col))) {
            case SQLITE_NULL:
                return null;
            case SQLITE_TEXT:
                String dateText = safeGetColumnText(col);
                if ("".equals(dateText)) {
                    return null;
                }
                try {
                    FastDateFormat dateFormat =
                            FastDateFormat.getInstance(
                                    getConnectionConfig().getDateStringFormat(), cal.getTimeZone());
                    return new Time(dateFormat.parse(dateText).getTime());
                } catch (Exception e) {
                    throw new SQLException("Error parsing time", e);
                }
            case SQLITE_FLOAT:
                return new Time(julianDateToCalendar(safeGetDoubleCol(col), cal).getTimeInMillis());
            default: // SQLITE_INTEGER
                cal.setTimeInMillis(
                        safeGetLongCol(col) * getConnectionConfig().getDateMultiplier());
                return new Time(cal.getTime().getTime());
        }
    }
    /** @see java.sql.ResultSet#getTime(java.lang.String) */
    public Time getTime(String col) throws SQLException {
        return getTime(findColumn(col));
    }
    /** @see java.sql.ResultSet#getTime(java.lang.String, java.util.Calendar) */
    public Time getTime(String col, Calendar cal) throws SQLException {
        return getTime(findColumn(col), cal);
    }
    /** @see java.sql.ResultSet#getTimestamp(int) */
    public Timestamp getTimestamp(int col) throws SQLException {
        switch (safeGetColumnType(markCol(col))) {
            case SQLITE_NULL:
                return null;
            case SQLITE_TEXT:
                String dateText = safeGetColumnText(col);
                if ("".equals(dateText)) {
                    return null;
                }
                try {
                    return new Timestamp(
                            getConnectionConfig().getDateFormat().parse(dateText).getTime());
                } catch (Exception e) {
                    throw new SQLException("Error parsing time stamp", e);
                }
            case SQLITE_FLOAT:
                return new Timestamp(julianDateToCalendar(safeGetDoubleCol(col)).getTimeInMillis());
            default: // SQLITE_INTEGER:
                return new Timestamp(
                        safeGetLongCol(col) * getConnectionConfig().getDateMultiplier());
        }
    }
    /** @see java.sql.ResultSet#getTimestamp(int, java.util.Calendar) */
    public Timestamp getTimestamp(int col, Calendar cal) throws SQLException {
        requireCalendarNotNull(cal);
        switch (safeGetColumnType(markCol(col))) {
            case SQLITE_NULL:
                return null;
            case SQLITE_TEXT:
                String dateText = safeGetColumnText(col);
                if ("".equals(dateText)) {
                    return null;
                }
                try {
                    FastDateFormat dateFormat =
                            FastDateFormat.getInstance(
                                    getConnectionConfig().getDateStringFormat(), cal.getTimeZone());
                    return new Timestamp(dateFormat.parse(dateText).getTime());
                } catch (Exception e) {
                    throw new SQLException("Error parsing time stamp", e);
                }
            case SQLITE_FLOAT:
                return new Timestamp(julianDateToCalendar(safeGetDoubleCol(col)).getTimeInMillis());
            default: // SQLITE_INTEGER
                cal.setTimeInMillis(
                        safeGetLongCol(col) * getConnectionConfig().getDateMultiplier());
                return new Timestamp(cal.getTime().getTime());
        }
    }
    /** @see java.sql.ResultSet#getTimestamp(java.lang.String) */
    public Timestamp getTimestamp(String col) throws SQLException {
        return getTimestamp(findColumn(col));
    }
    /** @see java.sql.ResultSet#getTimestamp(java.lang.String, java.util.Calendar) */
    public Timestamp getTimestamp(String c, Calendar ca) throws SQLException {
        return getTimestamp(findColumn(c), ca);
    }
    /** @see java.sql.ResultSet#getObject(int) */
    public Object getObject(int col) throws SQLException {
        switch (safeGetColumnType(markCol(col))) {
            case SQLITE_INTEGER:
                long val = getLong(col);
                if (val > Integer.MAX_VALUE || val < Integer.MIN_VALUE) {
                    return new Long(val);
                } else {
                    return new Integer((int) val);
                }
            case SQLITE_FLOAT:
                return new Double(getDouble(col));
            case SQLITE_BLOB:
                return getBytes(col);
            case SQLITE_NULL:
                return null;
            case SQLITE_TEXT:
            default:
                return getString(col);
        }
    }
    /** @see java.sql.ResultSet#getObject(java.lang.String) */
    public Object getObject(String col) throws SQLException {
        return getObject(findColumn(col));
    }
    /** @see java.sql.ResultSet#getStatement() */
    public Statement getStatement() {
        return (Statement) stmt;
    }
    /** @see java.sql.ResultSet#getCursorName() */
    public String getCursorName() {
        return null;
    }
    /** @see java.sql.ResultSet#getWarnings() */
    public SQLWarning getWarnings() {
        return null;
    }
    /** @see java.sql.ResultSet#clearWarnings() */
    public void clearWarnings() {}
    // ResultSetMetaData Functions //////////////////////////////////
    /** Pattern used to extract the column type name from table column definition. */
    protected static final Pattern COLUMN_TYPENAME = Pattern.compile("([^\\(]*)");
    /** Pattern used to extract the column type name from a cast(col as type) */
    protected static final Pattern COLUMN_TYPECAST =
            Pattern.compile("cast\\(.*?\\s+as\\s+(.*?)\\s*\\)");
    /**
     * Pattern used to extract the precision and scale from column meta returned by the JDBC driver.
     */
    protected static final Pattern COLUMN_PRECISION = Pattern.compile(".*?\\((.*?)\\)");
    // we do not need to check the RS is open, only that colsMeta
    // is not null, done with checkCol(int).
    /** @see java.sql.ResultSet#getMetaData() */
    public ResultSetMetaData getMetaData() {
        return (ResultSetMetaData) this;
    }
    /** @see java.sql.ResultSetMetaData#getCatalogName(int) */
    public String getCatalogName(int col) throws SQLException {
        return safeGetColumnTableName(col);
    }
    /** @see java.sql.ResultSetMetaData#getColumnClassName(int) */
    public String getColumnClassName(int col) throws SQLException {
        switch (safeGetColumnType(markCol(col))) {
            case SQLITE_INTEGER:
                long val = getLong(col);
                if (val > Integer.MAX_VALUE || val < Integer.MIN_VALUE) {
                    return "java.lang.Long";
                } else {
                    return "java.lang.Integer";
                }
            case SQLITE_FLOAT:
                return "java.lang.Double";
            case SQLITE_BLOB:
            case SQLITE_NULL:
                return "java.lang.Object";
            case SQLITE_TEXT:
            default:
                return "java.lang.String";
        }
    }
    /** @see java.sql.ResultSetMetaData#getColumnCount() */
    public int getColumnCount() throws SQLException {
        checkCol(1);
        return colsMeta.length;
    }
    /** @see java.sql.ResultSetMetaData#getColumnDisplaySize(int) */
    public int getColumnDisplaySize(int col) {
        return Integer.MAX_VALUE;
    }
    /** @see java.sql.ResultSetMetaData#getColumnLabel(int) */
    public String getColumnLabel(int col) throws SQLException {
        return getColumnName(col);
    }
    /** @see java.sql.ResultSetMetaData#getColumnName(int) */
    public String getColumnName(int col) throws SQLException {
        return safeGetColumnName(col);
    }
    /** @see java.sql.ResultSetMetaData#getColumnType(int) */
    public int getColumnType(int col) throws SQLException {
        String typeName = getColumnTypeName(col);
        int valueType = safeGetColumnType(checkCol(col));
        if (valueType == SQLITE_INTEGER || valueType == SQLITE_NULL) {
            if ("BOOLEAN".equals(typeName)) {
                return Types.BOOLEAN;
            }
            if ("TINYINT".equals(typeName)) {
                return Types.TINYINT;
            }
            if ("SMALLINT".equals(typeName) || "INT2".equals(typeName)) {
                return Types.SMALLINT;
            }
            if ("BIGINT".equals(typeName)
                    || "INT8".equals(typeName)
                    || "UNSIGNED BIG INT".equals(typeName)) {
                return Types.BIGINT;
            }
            if ("DATE".equals(typeName) || "DATETIME".equals(typeName)) {
                return Types.DATE;
            }
            if ("TIMESTAMP".equals(typeName)) {
                return Types.TIMESTAMP;
            }
            if (valueType == SQLITE_INTEGER
                    || "INT".equals(typeName)
                    || "INTEGER".equals(typeName)
                    || "MEDIUMINT".equals(typeName)) {
                long val = getLong(col);
                if (val > Integer.MAX_VALUE || val < Integer.MIN_VALUE) {
                    return Types.BIGINT;
                } else {
                    return Types.INTEGER;
                }
            }
        }
        if (valueType == SQLITE_FLOAT || valueType == SQLITE_NULL) {
            if ("DECIMAL".equals(typeName)) {
                return Types.DECIMAL;
            }
            if ("DOUBLE".equals(typeName) || "DOUBLE PRECISION".equals(typeName)) {
                return Types.DOUBLE;
            }
            if ("NUMERIC".equals(typeName)) {
                return Types.NUMERIC;
            }
            if ("REAL".equals(typeName)) {
                return Types.REAL;
            }
            if (valueType == SQLITE_FLOAT || "FLOAT".equals(typeName)) {
                return Types.FLOAT;
            }
        }
        if (valueType == SQLITE_TEXT || valueType == SQLITE_NULL) {
            if ("CHARACTER".equals(typeName)
                    || "NCHAR".equals(typeName)
                    || "NATIVE CHARACTER".equals(typeName)
                    || "CHAR".equals(typeName)) {
                return Types.CHAR;
            }
            if ("CLOB".equals(typeName)) {
                return Types.CLOB;
            }
            if ("DATE".equals(typeName) || "DATETIME".equals(typeName)) {
                return Types.DATE;
            }
            if ("TIMESTAMP".equals(typeName)) {
                return Types.TIMESTAMP;
            }
            if (valueType == SQLITE_TEXT
                    || "VARCHAR".equals(typeName)
                    || "VARYING CHARACTER".equals(typeName)
                    || "NVARCHAR".equals(typeName)
                    || "TEXT".equals(typeName)) {
                return Types.VARCHAR;
            }
        }
        if (valueType == SQLITE_BLOB || valueType == SQLITE_NULL) {
            if ("BINARY".equals(typeName)) {
                return Types.BINARY;
            }
            if (valueType == SQLITE_BLOB || "BLOB".equals(typeName)) {
                return Types.BLOB;
            }
        }
        return Types.NUMERIC;
    }
    /**
     * @return The data type from either the 'create table' statement, or CAST(expr AS TYPE)
     *     otherwise sqlite3_value_type.
     * @see java.sql.ResultSetMetaData#getColumnTypeName(int)
     */
    public String getColumnTypeName(int col) throws SQLException {
        String declType = getColumnDeclType(col);
        if (declType != null) {
            Matcher matcher = COLUMN_TYPENAME.matcher(declType);
            matcher.find();
            return matcher.group(1).toUpperCase(Locale.ENGLISH);
        }
        switch (safeGetColumnType(checkCol(col))) {
            case SQLITE_INTEGER:
                return "INTEGER";
            case SQLITE_FLOAT:
                return "FLOAT";
            case SQLITE_BLOB:
                return "BLOB";
            case SQLITE_TEXT:
                return "TEXT";
            case SQLITE_NULL:
            default:
                return "NUMERIC";
        }
    }
    /** @see java.sql.ResultSetMetaData#getPrecision(int) */
    public int getPrecision(int col) throws SQLException {
        String declType = getColumnDeclType(col);
        if (declType != null) {
            Matcher matcher = COLUMN_PRECISION.matcher(declType);
            return matcher.find() ? Integer.parseInt(matcher.group(1).split(",")[0].trim()) : 0;
        }
        return 0;
    }
    private String getColumnDeclType(int col) throws SQLException {
        String declType = stmt.pointer.safeRun((db, ptr) -> db.column_decltype(ptr, checkCol(col)));
        if (declType == null) {
            Matcher matcher = COLUMN_TYPECAST.matcher(safeGetColumnName(col));
            declType = matcher.find() ? matcher.group(1) : null;
        }
        return declType;
    }
    /** @see java.sql.ResultSetMetaData#getScale(int) */
    public int getScale(int col) throws SQLException {
        String declType = getColumnDeclType(col);
        if (declType != null) {
            Matcher matcher = COLUMN_PRECISION.matcher(declType);
            if (matcher.find()) {
                String[] array = matcher.group(1).split(",");
                if (array.length == 2) {
                    return Integer.parseInt(array[1].trim());
                }
            }
        }
        return 0;
    }
    /** @see java.sql.ResultSetMetaData#getSchemaName(int) */
    public String getSchemaName(int col) {
        return "";
    }
    /** @see java.sql.ResultSetMetaData#getTableName(int) */
    public String getTableName(int col) throws SQLException {
        final String tableName = safeGetColumnTableName(col);
        if (tableName == null) {
            // JDBC specifies an empty string instead of null
            return "";
        }
        return tableName;
    }
    /** @see java.sql.ResultSetMetaData#isNullable(int) */
    public int isNullable(int col) throws SQLException {
        checkMeta();
        return meta[checkCol(col)][0]
                ? ResultSetMetaData.columnNoNulls
                : ResultSetMetaData.columnNullable;
    }
    /** @see java.sql.ResultSetMetaData#isAutoIncrement(int) */
    public boolean isAutoIncrement(int col) throws SQLException {
        checkMeta();
        return meta[checkCol(col)][2];
    }
    /** @see java.sql.ResultSetMetaData#isCaseSensitive(int) */
    public boolean isCaseSensitive(int col) {
        return true;
    }
    /** @see java.sql.ResultSetMetaData#isCurrency(int) */
    public boolean isCurrency(int col) {
        return false;
    }
    /** @see java.sql.ResultSetMetaData#isDefinitelyWritable(int) */
    public boolean isDefinitelyWritable(int col) {
        return true;
    } // FIXME: check db file constraints?
    /** @see java.sql.ResultSetMetaData#isReadOnly(int) */
    public boolean isReadOnly(int col) {
        return false;
    }
    /** @see java.sql.ResultSetMetaData#isSearchable(int) */
    public boolean isSearchable(int col) {
        return true;
    }
    /** @see java.sql.ResultSetMetaData#isSigned(int) */
    public boolean isSigned(int col) throws SQLException {
        String typeName = getColumnTypeName(col);
        return "NUMERIC".equals(typeName) || "INTEGER".equals(typeName) || "REAL".equals(typeName);
    }
    /** @see java.sql.ResultSetMetaData#isWritable(int) */
    public boolean isWritable(int col) {
        return true;
    }
    /** @see java.sql.ResultSet#getConcurrency() */
    public int getConcurrency() {
        return ResultSet.CONCUR_READ_ONLY;
    }
    /** @see java.sql.ResultSet#rowDeleted() */
    public boolean rowDeleted() {
        return false;
    }
    /** @see java.sql.ResultSet#rowInserted() */
    public boolean rowInserted() {
        return false;
    }
    /** @see java.sql.ResultSet#rowUpdated() */
    public boolean rowUpdated() {
        return false;
    }
    /** Transforms a Julian Date to java.util.Calendar object. */
    private Calendar julianDateToCalendar(Double jd) {
        return julianDateToCalendar(jd, Calendar.getInstance());
    }
    /**
     * Transforms a Julian Date to java.util.Calendar object. Based on Guine Christian's function
     * found here:
     * http://java.ittoolbox.com/groups/technical-functional/java-l/java-function-to-convert-julian-date-to-calendar-date-1947446
     */
    private Calendar julianDateToCalendar(Double jd, Calendar cal) {
        if (jd == null) {
            return null;
        }
        int yyyy, dd, mm, hh, mn, ss, ms, A;
        double w = jd + 0.5;
        int Z = (int) w;
        double F = w - Z;
        if (Z < 2299161) {
            A = Z;
        } else {
            int alpha = (int) ((Z - 1867216.25) / 36524.25);
            A = Z + 1 + alpha - (int) (alpha / 4.0);
        }
        int B = A + 1524;
        int C = (int) ((B - 122.1) / 365.25);
        int D = (int) (365.25 * C);
        int E = (int) ((B - D) / 30.6001);
        //  month
        mm = E - ((E < 13.5) ? 1 : 13);
        // year
        yyyy = C - ((mm > 2.5) ? 4716 : 4715);
        // Day
        double jjd = B - D - (int) (30.6001 * E) + F;
        dd = (int) jjd;
        // Hour
        double hhd = jjd - dd;
        hh = (int) (24 * hhd);
        // Minutes
        double mnd = (24 * hhd) - hh;
        mn = (int) (60 * mnd);
        // Seconds
        double ssd = (60 * mnd) - mn;
        ss = (int) (60 * ssd);
        // Milliseconds
        double msd = (60 * ssd) - ss;
        ms = (int) (1000 * msd);
        cal.set(yyyy, mm - 1, dd, hh, mn, ss);
        cal.set(Calendar.MILLISECOND, ms);
        if (yyyy < 1) {
            cal.set(Calendar.ERA, GregorianCalendar.BC);
            cal.set(Calendar.YEAR, -(yyyy - 1));
        }
        return cal;
    }
    private void requireCalendarNotNull(Calendar cal) throws SQLException {
        if (cal == null) {
            throw new SQLException("Expected a calendar instance.", new IllegalArgumentException());
        }
    }
    protected int safeGetColumnType(int col) throws SQLException {
        return stmt.pointer.safeRunInt((db, ptr) -> db.column_type(ptr, col));
    }
    private long safeGetLongCol(int col) throws SQLException {
        return stmt.pointer.safeRunLong((db, ptr) -> db.column_long(ptr, markCol(col)));
    }
    private double safeGetDoubleCol(int col) throws SQLException {
        return stmt.pointer.safeRunDouble((db, ptr) -> db.column_double(ptr, markCol(col)));
    }
    private String safeGetColumnText(int col) throws SQLException {
        return stmt.pointer.safeRun((db, ptr) -> db.column_text(ptr, markCol(col)));
    }
    private String safeGetColumnTableName(int col) throws SQLException {
        return stmt.pointer.safeRun((db, ptr) -> db.column_table_name(ptr, checkCol(col)));
    }
    private String safeGetColumnName(int col) throws SQLException {
        return stmt.pointer.safeRun((db, ptr) -> db.column_name(ptr, checkCol(col)));
    }
}
/*
 * Copyright (c) 2007 David Crawshaw <david@zentus.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
package org.sqlite.core;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map;
import org.sqlite.SQLiteConnectionConfig;
/** Implements a JDBC ResultSet. */
public abstract class CoreResultSet implements Codes {
    protected final CoreStatement stmt;
    /** If the result set does not have any rows. */
    public boolean emptyResultSet = false;
    /** If the result set is open. Doesn't mean it has results. */
    public boolean open = false;
    /** Maximum number of rows as set by a Statement */
    public long maxRows;
    /** if null, the RS is closed() */
    public String[] cols = null;
    /** same as cols, but used by Meta interface */
    public String[] colsMeta = null;
    protected boolean[][] meta = null;
    /** 0 means no limit, must check against maxRows */
    protected int limitRows;
    /** number of current row, starts at 1 (0 is for before loading data) */
    protected int row = 0;
    protected boolean pastLastRow = false;
    /** last column accessed, for wasNull(). -1 if none */
    protected int lastCol;
    public boolean closeStmt;
    protected Map<String, Integer> columnNameToIndex = null;
    /**
     * Default constructor for a given statement.
     *
     * @param stmt The statement.
     */
    protected CoreResultSet(CoreStatement stmt) {
        this.stmt = stmt;
    }
    // INTERNAL FUNCTIONS ///////////////////////////////////////////
    protected DB getDatabase() {
        return stmt.getDatabase();
    }
    protected SQLiteConnectionConfig getConnectionConfig() {
        return stmt.getConnectionConfig();
    }
    /**
     * Checks the status of the result set.
     *
     * @return True if has results and can iterate them; false otherwise.
     */
    public boolean isOpen() {
        return open;
    }
    /** @throws SQLException if ResultSet is not open. */
    protected void checkOpen() throws SQLException {
        if (!open) {
            throw new SQLException("ResultSet closed");
        }
    }
    /**
     * Takes col in [1,x] form, returns in [0,x-1] form
     *
     * @param col
     * @return
     * @throws SQLException
     */
    public int checkCol(int col) throws SQLException {
        if (colsMeta == null) {
            throw new SQLException("SQLite JDBC: inconsistent internal state");
        }
        if (col < 1 || col > colsMeta.length) {
            throw new SQLException("column " + col + " out of bounds [1," + colsMeta.length + "]");
        }
        return --col;
    }
    /**
     * Takes col in [1,x] form, marks it as last accessed and returns [0,x-1]
     *
     * @param col
     * @return
     * @throws SQLException
     */
    protected int markCol(int col) throws SQLException {
        checkCol(col);
        lastCol = col;
        return --col;
    }
    /** @throws SQLException */
    public void checkMeta() throws SQLException {
        checkCol(1);
        if (meta == null) {
            meta = stmt.pointer.safeRun(DB::column_metadata);
        }
    }
    public void close() throws SQLException {
        cols = null;
        colsMeta = null;
        meta = null;
        limitRows = 0;
        row = 0;
        pastLastRow = false;
        lastCol = -1;
        columnNameToIndex = null;
        emptyResultSet = false;
        if (stmt.pointer.isClosed() || (!open && !closeStmt)) {
            return;
        }
        DB db = stmt.getDatabase();
        synchronized (db) {
            if (!stmt.pointer.isClosed()) {
                stmt.pointer.safeRunInt(DB::reset);
                if (closeStmt) {
                    closeStmt = false; // break recursive call
                    ((Statement) stmt).close();
                }
            }
        }
        open = false;
    }
    protected Integer findColumnIndexInCache(String col) {
        if (columnNameToIndex == null) {
            return null;
        }
        return columnNameToIndex.get(col);
    }
    protected int addColumnIndexInCache(String col, int index) {
        if (columnNameToIndex == null) {
            columnNameToIndex = new HashMap<String, Integer>(cols.length);
        }
        columnNameToIndex.put(col, index);
        return index;
    }
}
package org.sqlite.core;
import java.sql.SQLException;
/**
 * A class for safely wrapping calls to a native pointer to a statement, ensuring no other thread
 * has access to the pointer while it is run
 */
public class SafeStmtPtr {
    // store a reference to the DB, to lock it before any safe function is called. This avoids
    // deadlocking by locking the DB. All calls with the raw pointer are synchronized with the DB
    // anyways, so making a separate lock would be pointless
    private final DB db;
    private final long ptr;
    private volatile boolean closed = false;
    // to return on subsequent calls to close() after this ptr has been closed
    private int closedRC;
    // to throw on subsequent calls to close after this ptr has been closed, if the close function
    // threw an exception
    private SQLException closeException;
    /**
     * Construct a new Safe Pointer Wrapper to ensure a pointer is properly handled
     *
     * @param db the database that made this pointer. Always locked before any safe run function is
     *     executed to avoid deadlocks
     * @param ptr the raw pointer
     */
    public SafeStmtPtr(DB db, long ptr) {
        this.db = db;
        this.ptr = ptr;
    }
    /**
     * Check whether this pointer has been closed
     *
     * @return whether this pointer has been closed
     */
    public boolean isClosed() {
        return closed;
    }
    /**
     * Close this pointer
     *
     * @return the return code of the close callback function
     * @throws SQLException if the close callback throws an SQLException, or the pointer is locked
     *     elsewhere
     */
    public int close() throws SQLException {
        synchronized (db) {
            return internalClose();
        }
    }
    private int internalClose() throws SQLException {
        try {
            // if this is already closed, return or throw the previous result
            if (closed) {
                if (closeException != null) throw closeException;
                return closedRC;
            }
            closedRC = db.finalize(this, ptr);
            return closedRC;
        } catch (SQLException ex) {
            this.closeException = ex;
            throw ex;
        } finally {
            this.closed = true;
        }
    }
    /**
     * Run a callback with the wrapped pointer safely.
     *
     * @param run the function to run
     * @return the return of the passed in function
     * @throws SQLException if the pointer is utilized elsewhere
     */
    public <E extends Throwable> int safeRunInt(SafePtrIntFunction<E> run) throws SQLException, E {
        synchronized (db) {
            this.ensureOpen();
            return run.run(db, ptr);
        }
    }
    /**
     * Run a callback with the wrapped pointer safely.
     *
     * @param run the function to run
     * @return the return of the passed in function
     * @throws SQLException if the pointer is utilized elsewhere
     */
    public <E extends Throwable> long safeRunLong(SafePtrLongFunction<E> run)
            throws SQLException, E {
        synchronized (db) {
            this.ensureOpen();
            return run.run(db, ptr);
        }
    }
    /**
     * Run a callback with the wrapped pointer safely.
     *
     * @param run the function to run
     * @return the return of the passed in function
     * @throws SQLException if the pointer is utilized elsewhere
     */
    public <E extends Throwable> double safeRunDouble(SafePtrDoubleFunction<E> run)
            throws SQLException, E {
        synchronized (db) {
            this.ensureOpen();
            return run.run(db, ptr);
        }
    }
    /**
     * Run a callback with the wrapped pointer safely.
     *
     * @param run the function to run
     * @return the return code of the function
     * @throws SQLException if the pointer is utilized elsewhere
     */
    public <T, E extends Throwable> T safeRun(SafePtrFunction<T, E> run) throws SQLException, E {
        synchronized (db) {
            this.ensureOpen();
            return run.run(db, ptr);
        }
    }
    /**
     * Run a callback with the wrapped pointer safely.
     *
     * @param run the function to run
     * @throws SQLException if the pointer is utilized elsewhere
     */
    public <E extends Throwable> void safeRunConsume(SafePtrConsumer<E> run)
            throws SQLException, E {
        synchronized (db) {
            this.ensureOpen();
            run.run(db, ptr);
        }
    }
    private void ensureOpen() throws SQLException {
        if (this.closed) {
            throw new SQLException("stmt pointer is closed");
        }
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SafeStmtPtr that = (SafeStmtPtr) o;
        return ptr == that.ptr;
    }
    @Override
    public int hashCode() {
        return Long.hashCode(ptr);
    }
    @FunctionalInterface
    public interface SafePtrIntFunction<E extends Throwable> {
        int run(DB db, long ptr) throws E;
    }
    @FunctionalInterface
    public interface SafePtrLongFunction<E extends Throwable> {
        long run(DB db, long ptr) throws E;
    }
    @FunctionalInterface
    public interface SafePtrDoubleFunction<E extends Throwable> {
        double run(DB db, long ptr) throws E;
    }
    @FunctionalInterface
    public interface SafePtrFunction<T, E extends Throwable> {
        T run(DB db, long ptr) throws E;
    }
    @FunctionalInterface
    public interface SafePtrConsumer<E extends Throwable> {
        void run(DB db, long ptr) throws E;
    }
}
package org.sqlite.jdbc3;
import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;
import java.sql.Savepoint;
import java.sql.Statement;
import java.sql.Struct;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicInteger;
import org.sqlite.SQLiteConfig;
import org.sqlite.SQLiteConfig.TransactionMode;
import org.sqlite.SQLiteConnection;
import org.sqlite.SQLiteOpenMode;
public abstract class JDBC3Connection extends SQLiteConnection {
    private final AtomicInteger savePoint = new AtomicInteger(0);
    private Map<String, Class<?>> typeMap;
    private boolean readOnly = false;
    protected JDBC3Connection(String url, String fileName, Properties prop) throws SQLException {
        super(url, fileName, prop);
    }
    /**
     * This will try to enforce the transaction mode if SQLiteConfig#isExplicitReadOnly is true and
     * auto commit is disabled.
     *
     * <ul>
     *   <li>If this connection is read only, the PRAGMA query_only will be set
     *   <li>If this connection is not read only:
     *       <ul>
     *         <li>if no statement has been executed, PRAGMA query_only will be set to false, and an
     *             IMMEDIATE transaction will be started
     *         <li>if a statement has already been executed, an exception is thrown
     *       </ul>
     * </ul>
     *
     * @throws SQLException if a statement has already been executed on this connection, then the
     *     transaction cannot be upgraded to write
     */
    @SuppressWarnings("deprecation")
    public void tryEnforceTransactionMode() throws SQLException {
        // important note: read-only mode is only supported when auto-commit is disabled
        if (getDatabase().getConfig().isExplicitReadOnly()
                && !this.getAutoCommit()
                && this.getCurrentTransactionMode() != null) {
            if (isReadOnly()) {
                // this is a read-only transaction, make sure all writing operations are rejected by
                // the DB
                // (note: this pragma is evaluated on a per-transaction basis by SQLite)
                getDatabase()._exec("PRAGMA query_only = true;");
            } else {
                if (getCurrentTransactionMode() == TransactionMode.DEFERRED) {
                    if (isFirstStatementExecuted()) {
                        // first statement was already executed; cannot upgrade to write
                        // transaction!
                        throw new SQLException(
                                "A statement has already been executed on this connection; cannot upgrade to write transaction");
                    } else {
                        // this is the first statement in the transaction; close and create an
                        // immediate one
                        getDatabase()._exec("commit; /* need to explicitly upgrade transaction */");
                        // start the write transaction
                        getDatabase()._exec("PRAGMA query_only = false;");
                        getDatabase()
                                ._exec("BEGIN IMMEDIATE; /* explicitly upgrade transaction */");
                        setCurrentTransactionMode(TransactionMode.IMMEDIATE);
                    }
                }
            }
        }
    }
    /** @see java.sql.Connection#getCatalog() */
    public String getCatalog() throws SQLException {
        checkOpen();
        return null;
    }
    /** @see java.sql.Connection#setCatalog(java.lang.String) */
    public void setCatalog(String catalog) throws SQLException {
        checkOpen();
    }
    /** @see java.sql.Connection#getHoldability() */
    public int getHoldability() throws SQLException {
        checkOpen();
        return ResultSet.CLOSE_CURSORS_AT_COMMIT;
    }
    /** @see java.sql.Connection#setHoldability(int) */
    public void setHoldability(int h) throws SQLException {
        checkOpen();
        if (h != ResultSet.CLOSE_CURSORS_AT_COMMIT) {
            throw new SQLException("SQLite only supports CLOSE_CURSORS_AT_COMMIT");
        }
    }
    /** @see java.sql.Connection#getTypeMap() */
    public Map<String, Class<?>> getTypeMap() throws SQLException {
        synchronized (this) {
            if (this.typeMap == null) {
                this.typeMap = new HashMap<String, Class<?>>();
            }
            return this.typeMap;
        }
    }
    /** @see java.sql.Connection#setTypeMap(java.util.Map) */
    public void setTypeMap(Map map) throws SQLException {
        synchronized (this) {
            this.typeMap = map;
        }
    }
    /** @see java.sql.Connection#isReadOnly() */
    public boolean isReadOnly() {
        SQLiteConfig config = getDatabase().getConfig();
        return (
        // the entire database is read-only
        ((config.getOpenModeFlags() & SQLiteOpenMode.READONLY.flag) != 0)
                // the flag was set explicitly by the user on this connection
                || (config.isExplicitReadOnly() && this.readOnly));
    }
    /** @see java.sql.Connection#setReadOnly(boolean) */
    public void setReadOnly(boolean ro) throws SQLException {
        if (getDatabase().getConfig().isExplicitReadOnly()) {
            if (ro != readOnly && isFirstStatementExecuted()) {
                throw new SQLException(
                        "Cannot change Read-Only status of this connection: the first statement was"
                                + " already executed and the transaction is open.");
            }
        } else {
            // trying to change read-only flag
            if (ro != isReadOnly()) {
                throw new SQLException(
                        "Cannot change read-only flag after establishing a connection."
                                + " Use SQLiteConfig#setReadOnly and SQLiteConfig.createConnection().");
            }
        }
        this.readOnly = ro;
    }
    /** @see java.sql.Connection#nativeSQL(java.lang.String) */
    public String nativeSQL(String sql) {
        return sql;
    }
    /** @see java.sql.Connection#clearWarnings() */
    public void clearWarnings() throws SQLException {}
    /** @see java.sql.Connection#getWarnings() */
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }
    /** @see java.sql.Connection#createStatement() */
    public Statement createStatement() throws SQLException {
        return createStatement(
                ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_READ_ONLY,
                ResultSet.CLOSE_CURSORS_AT_COMMIT);
    }
    /** @see java.sql.Connection#createStatement(int, int) */
    public Statement createStatement(int rsType, int rsConcurr) throws SQLException {
        return createStatement(rsType, rsConcurr, ResultSet.CLOSE_CURSORS_AT_COMMIT);
    }
    /** @see java.sql.Connection#createStatement(int, int, int) */
    public abstract Statement createStatement(int rst, int rsc, int rsh) throws SQLException;
    /** @see java.sql.Connection#prepareCall(java.lang.String) */
    public CallableStatement prepareCall(String sql) throws SQLException {
        return prepareCall(
                sql,
                ResultSet.TYPE_FORWARD_ONLY,
                ResultSet.CONCUR_READ_ONLY,
                ResultSet.CLOSE_CURSORS_AT_COMMIT);
    }
    /** @see java.sql.Connection#prepareCall(java.lang.String, int, int) */
    public CallableStatement prepareCall(String sql, int rst, int rsc) throws SQLException {
        return prepareCall(sql, rst, rsc, ResultSet.CLOSE_CURSORS_AT_COMMIT);
    }
    /** @see java.sql.Connection#prepareCall(java.lang.String, int, int, int) */
    public CallableStatement prepareCall(String sql, int rst, int rsc, int rsh)
            throws SQLException {
        throw new SQLException("SQLite does not support Stored Procedures");
    }
    /** @see java.sql.Connection#prepareStatement(java.lang.String) */
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
    }
    /** @see java.sql.Connection#prepareStatement(java.lang.String, int) */
    public PreparedStatement prepareStatement(String sql, int autoC) throws SQLException {
        return prepareStatement(sql);
    }
    /** @see java.sql.Connection#prepareStatement(java.lang.String, int[]) */
    public PreparedStatement prepareStatement(String sql, int[] colInds) throws SQLException {
        return prepareStatement(sql);
    }
    /** @see java.sql.Connection#prepareStatement(java.lang.String, java.lang.String[]) */
    public PreparedStatement prepareStatement(String sql, String[] colNames) throws SQLException {
        return prepareStatement(sql);
    }
    /** @see java.sql.Connection#prepareStatement(java.lang.String, int, int) */
    public PreparedStatement prepareStatement(String sql, int rst, int rsc) throws SQLException {
        return prepareStatement(sql, rst, rsc, ResultSet.CLOSE_CURSORS_AT_COMMIT);
    }
    /** @see java.sql.Connection#prepareStatement(java.lang.String, int, int, int) */
    public abstract PreparedStatement prepareStatement(String sql, int rst, int rsc, int rsh)
            throws SQLException;
    /** @see java.sql.Connection#setSavepoint() */
    public Savepoint setSavepoint() throws SQLException {
        checkOpen();
        if (getAutoCommit()) {
            // when a SAVEPOINT is the outermost savepoint and not
            // with a BEGIN...COMMIT then the behavior is the same
            // as BEGIN DEFERRED TRANSACTION
            // https://www.sqlite.org/lang_savepoint.html
            getConnectionConfig().setAutoCommit(false);
        }
        Savepoint sp = new JDBC3Savepoint(savePoint.incrementAndGet());
        getDatabase().exec(String.format("SAVEPOINT %s", sp.getSavepointName()), false);
        return sp;
    }
    /** @see java.sql.Connection#setSavepoint(java.lang.String) */
    public Savepoint setSavepoint(String name) throws SQLException {
        checkOpen();
        if (getAutoCommit()) {
            // when a SAVEPOINT is the outermost savepoint and not
            // with a BEGIN...COMMIT then the behavior is the same
            // as BEGIN DEFERRED TRANSACTION
            // https://www.sqlite.org/lang_savepoint.html
            getConnectionConfig().setAutoCommit(false);
        }
        Savepoint sp = new JDBC3Savepoint(savePoint.incrementAndGet(), name);
        getDatabase().exec(String.format("SAVEPOINT %s", sp.getSavepointName()), false);
        return sp;
    }
    /** @see java.sql.Connection#releaseSavepoint(java.sql.Savepoint) */
    public void releaseSavepoint(Savepoint savepoint) throws SQLException {
        checkOpen();
        if (getAutoCommit()) {
            throw new SQLException("database in auto-commit mode");
        }
        getDatabase()
                .exec(String.format("RELEASE SAVEPOINT %s", savepoint.getSavepointName()), false);
    }
    /** @see java.sql.Connection#rollback(java.sql.Savepoint) */
    public void rollback(Savepoint savepoint) throws SQLException {
        checkOpen();
        if (getAutoCommit()) {
            throw new SQLException("database in auto-commit mode");
        }
        getDatabase()
                .exec(
                        String.format("ROLLBACK TO SAVEPOINT %s", savepoint.getSavepointName()),
                        getAutoCommit());
    }
    public Struct createStruct(String t, Object[] attr) throws SQLException {
        throw new SQLFeatureNotSupportedException("not implemented by SQLite JDBC driver");
    }
}
/*
 * Copyright (c) 2007 David Crawshaw <david@zentus.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
package org.sqlite.core;
import java.sql.Date;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Calendar;
import org.sqlite.SQLiteConnection;
import org.sqlite.SQLiteConnectionConfig;
import org.sqlite.date.FastDateFormat;
import org.sqlite.jdbc3.JDBC3Connection;
import org.sqlite.jdbc4.JDBC4Statement;
public abstract class CorePreparedStatement extends JDBC4Statement {
    protected int columnCount;
    protected int paramCount;
    protected int batchQueryCount;
    /**
     * Constructs a prepared statement on a provided connection.
     *
     * @param conn Connection on which to create the prepared statement.
     * @param sql The SQL script to prepare.
     * @throws SQLException
     */
    protected CorePreparedStatement(SQLiteConnection conn, String sql) throws SQLException {
        super(conn);
        this.sql = sql;
        DB db = conn.getDatabase();
        db.prepare(this);
        rs.colsMeta = pointer.safeRun(DB::column_names);
        columnCount = pointer.safeRunInt(DB::column_count);
        paramCount = pointer.safeRunInt(DB::bind_parameter_count);
        batchQueryCount = 0;
        batch = null;
        batchPos = 0;
    }
    /** @see org.sqlite.jdbc3.JDBC3Statement#executeBatch() */
    @Override
    public int[] executeBatch() throws SQLException {
        return Arrays.stream(executeLargeBatch()).mapToInt(l -> (int) l).toArray();
    }
    /** @see org.sqlite.jdbc3.JDBC3Statement#executeLargeBatch() */
    @Override
    public long[] executeLargeBatch() throws SQLException {
        if (batchQueryCount == 0) {
            return new long[] {};
        }
        if (this.conn instanceof JDBC3Connection) {
            ((JDBC3Connection) this.conn).tryEnforceTransactionMode();
        }
        return this.withConnectionTimeout(
                () -> {
                    try {
                        return conn.getDatabase()
                                .executeBatch(
                                        pointer, batchQueryCount, batch, conn.getAutoCommit());
                    } finally {
                        clearBatch();
                    }
                });
    }
    /** @see org.sqlite.jdbc3.JDBC3Statement#clearBatch() () */
    @Override
    public void clearBatch() throws SQLException {
        super.clearBatch();
        batchQueryCount = 0;
    }
    // PARAMETER FUNCTIONS //////////////////////////////////////////
    /**
     * Assigns the object value to the element at the specific position of array batch.
     *
     * @param pos
     * @param value
     * @throws SQLException
     */
    protected void batch(int pos, Object value) throws SQLException {
        checkOpen();
        if (batch == null) {
            batch = new Object[paramCount];
        }
        batch[batchPos + pos - 1] = value;
    }
    /** Store the date in the user's preferred format (text, int, or real) */
    protected void setDateByMilliseconds(int pos, Long value, Calendar calendar)
            throws SQLException {
        SQLiteConnectionConfig config = conn.getConnectionConfig();
        switch (config.getDateClass()) {
            case TEXT:
                batch(
                        pos,
                        FastDateFormat.getInstance(
                                        config.getDateStringFormat(), calendar.getTimeZone())
                                .format(new Date(value)));
                break;
            case REAL:
                // long to Julian date
                batch(pos, new Double((value / 86400000.0) + 2440587.5));
                break;
            default: // INTEGER:
                batch(pos, new Long(value / config.getDateMultiplier()));
        }
    }
}
package org.sqlite.jdbc3;
import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.text.MessageFormat;
import java.util.Arrays;
import org.sqlite.ExtendedCommand;
import org.sqlite.ExtendedCommand.SQLExtension;
import org.sqlite.SQLiteConnection;
import org.sqlite.core.CoreStatement;
import org.sqlite.core.DB;
import org.sqlite.core.DB.ProgressObserver;
import org.sqlite.util.Logger;
import org.sqlite.util.LoggerFactory;
public abstract class JDBC3Statement extends CoreStatement {
    private int queryTimeout; // in seconds, as per the JDBC spec
    protected long updateCount;
    protected boolean exhaustedResults = false;
    // PUBLIC INTERFACE /////////////////////////////////////////////
    protected JDBC3Statement(SQLiteConnection conn) {
        super(conn);
        this.queryTimeout = 0;
    }
    /** @see java.sql.Statement#close() */
    public void close() throws SQLException {
        clearGeneratedKeys();
        internalClose();
    }
    /** @see java.sql.Statement#execute(java.lang.String) */
    public boolean execute(final String sql) throws SQLException {
        internalClose();
        return this.withConnectionTimeout(
                () -> {
                    SQLExtension ext = ExtendedCommand.parse(sql);
                    if (ext != null) {
                        ext.execute(conn.getDatabase());
                        return false;
                    }
                    JDBC3Statement.this.sql = sql;
                    synchronized (conn) {
                        conn.getDatabase().prepare(JDBC3Statement.this);
                        boolean result = exec();
                        updateGeneratedKeys();
                        updateCount = getDatabase().changes();
                        exhaustedResults = false;
                        return result;
                    }
                });
    }
    /** @see java.sql.Statement#execute(java.lang.String, int) */
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return execute(sql);
    }
    /**
     * @param closeStmt Whether to close this statement when the resultset is closed.
     * @see java.sql.Statement#executeQuery(java.lang.String)
     */
    public ResultSet executeQuery(String sql, boolean closeStmt) throws SQLException {
        rs.closeStmt = closeStmt;
        return executeQuery(sql);
    }
    /** @see java.sql.Statement#executeQuery(java.lang.String) */
    public ResultSet executeQuery(String sql) throws SQLException {
        internalClose();
        this.sql = sql;
        return this.withConnectionTimeout(
                () -> {
                    conn.getDatabase().prepare(JDBC3Statement.this);
                    if (!exec()) {
                        internalClose();
                        throw new SQLException(
                                "query does not return ResultSet", "SQLITE_DONE", SQLITE_DONE);
                    }
                    exhaustedResults = false;
                    return getResultSet();
                });
    }
    static class BackupObserver implements ProgressObserver {
        private static final Logger logger = LoggerFactory.getLogger(BackupObserver.class);
        public void progress(int remaining, int pageCount) {
            logger.info(
                    () ->
                            MessageFormat.format(
                                    "remaining:{0}, page count:{1}", remaining, pageCount));
        }
    }
    /** @see java.sql.Statement#executeUpdate(java.lang.String) */
    public int executeUpdate(final String sql) throws SQLException {
        return (int) executeLargeUpdate(sql);
    }
    /** @see java.sql.Statement#executeUpdate(java.lang.String, int) */
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return executeUpdate(sql);
    }
    /** @see java.sql.Statement#executeLargeUpdate(java.lang.String) */
    public long executeLargeUpdate(String sql) throws SQLException {
        internalClose();
        this.sql = sql;
        return this.withConnectionTimeout(
                () -> {
                    DB db = conn.getDatabase();
                    long changes = 0;
                    SQLExtension ext = ExtendedCommand.parse(sql);
                    if (ext != null) {
                        // execute extended command
                        ext.execute(db);
                    } else {
                        try {
                            synchronized (db) {
                                changes = db.total_changes();
                                // directly invokes the exec API to support multiple SQL statements
                                int statusCode = db._exec(sql);
                                if (statusCode != SQLITE_OK)
                                    throw DB.newSQLException(statusCode, "");
                                updateGeneratedKeys();
                                changes = db.total_changes() - changes;
                            }
                        } finally {
                            internalClose();
                        }
                    }
                    return changes;
                });
    }
    /** @see java.sql.Statement#executeLargeUpdate(java.lang.String, int) */
    public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return executeLargeUpdate(sql);
    }
    /** @see java.sql.Statement#getResultSet() */
    public ResultSet getResultSet() throws SQLException {
        checkOpen();
        if (exhaustedResults) return null;
        if (rs.isOpen()) {
            throw new SQLException("ResultSet already requested");
        }
        if (pointer.safeRunInt(DB::column_count) == 0) {
            return null;
        }
        if (rs.colsMeta == null) {
            rs.colsMeta = pointer.safeRun(DB::column_names);
        }
        rs.cols = rs.colsMeta;
        rs.emptyResultSet = !resultsWaiting;
        rs.open = true;
        resultsWaiting = false;
        return (ResultSet) rs;
    }
    /**
     * This function has a complex behaviour best understood by carefully reading the JavaDoc for
     * getMoreResults() and considering the test StatementTest.execute().
     *
     * @see java.sql.Statement#getUpdateCount()
     */
    public int getUpdateCount() throws SQLException {
        return (int) getLargeUpdateCount();
    }
    /**
     * This function has a complex behaviour best understood by carefully reading the JavaDoc for
     * getMoreResults() and considering the test StatementTest.execute().
     *
     * @see java.sql.Statement#getLargeUpdateCount()
     */
    public long getLargeUpdateCount() throws SQLException {
        DB db = conn.getDatabase();
        if (!pointer.isClosed()
                && !rs.isOpen()
                && !resultsWaiting
                && pointer.safeRunInt(DB::column_count) == 0) return updateCount;
        return -1;
    }
    /** @see java.sql.Statement#addBatch(java.lang.String) */
    public void addBatch(String sql) throws SQLException {
        internalClose();
        if (batch == null || batchPos + 1 >= batch.length) {
            Object[] nb = new Object[Math.max(10, batchPos * 2)];
            if (batch != null) System.arraycopy(batch, 0, nb, 0, batch.length);
            batch = nb;
        }
        batch[batchPos++] = sql;
    }
    /** @see java.sql.Statement#clearBatch() */
    public void clearBatch() throws SQLException {
        batchPos = 0;
        if (batch != null) for (int i = 0; i < batch.length; i++) batch[i] = null;
    }
    /** @see java.sql.Statement#executeBatch() */
    public int[] executeBatch() throws SQLException {
        return Arrays.stream(executeLargeBatch()).mapToInt(l -> (int) l).toArray();
    }
    /** @see java.sql.Statement#executeLargeBatch() */
    public long[] executeLargeBatch() throws SQLException {
        // TODO: optimize
        internalClose();
        if (batch == null || batchPos == 0) return new long[] {};
        long[] changes = new long[batchPos];
        DB db = conn.getDatabase();
        synchronized (db) {
            try {
                for (int i = 0; i < changes.length; i++) {
                    try {
                        this.sql = (String) batch[i];
                        db.prepare(this);
                        changes[i] = db.executeUpdate(this, null);
                    } catch (SQLException e) {
                        throw new BatchUpdateException(
                                "batch entry " + i + ": " + e.getMessage(), null, 0, changes, e);
                    } finally {
                        if (pointer != null) pointer.close();
                    }
                }
            } finally {
                clearBatch();
            }
        }
        return changes;
    }
    /** @see java.sql.Statement#setCursorName(java.lang.String) */
    public void setCursorName(String name) {}
    /** @see java.sql.Statement#getWarnings() */
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }
    /** @see java.sql.Statement#clearWarnings() */
    public void clearWarnings() throws SQLException {}
    /** @see java.sql.Statement#getConnection() */
    public Connection getConnection() throws SQLException {
        return conn;
    }
    /** @see java.sql.Statement#cancel() */
    public void cancel() throws SQLException {
        conn.getDatabase().interrupt();
    }
    /** @see java.sql.Statement#getQueryTimeout() */
    public int getQueryTimeout() throws SQLException {
        return queryTimeout;
    }
    /** @see java.sql.Statement#setQueryTimeout(int) */
    public void setQueryTimeout(int seconds) throws SQLException {
        if (seconds < 0) {
            throw new SQLException("query timeout must be >= 0");
        }
        this.queryTimeout = seconds;
    }
    // TODO: write test
    /** @see java.sql.Statement#getMaxRows() */
    public int getMaxRows() throws SQLException {
        // checkOpen();
        return (int) rs.maxRows;
    }
    /** @see java.sql.Statement#getLargeMaxRows() */
    public long getLargeMaxRows() throws SQLException {
        // checkOpen();
        return rs.maxRows;
    }
    /** @see java.sql.Statement#setMaxRows(int) */
    public void setMaxRows(int max) throws SQLException {
        setLargeMaxRows(max);
    }
    /** @see java.sql.Statement#setLargeMaxRows(long) */
    public void setLargeMaxRows(long max) throws SQLException {
        // checkOpen();
        if (max < 0) throw new SQLException("max row count must be >= 0");
        rs.maxRows = max;
    }
    /** @see java.sql.Statement#getMaxFieldSize() */
    public int getMaxFieldSize() throws SQLException {
        return 0;
    }
    /** @see java.sql.Statement#setMaxFieldSize(int) */
    public void setMaxFieldSize(int max) throws SQLException {
        if (max < 0) throw new SQLException("max field size " + max + " cannot be negative");
    }
    /** @see java.sql.Statement#getFetchSize() */
    public int getFetchSize() throws SQLException {
        return ((ResultSet) rs).getFetchSize();
    }
    /** @see java.sql.Statement#setFetchSize(int) */
    public void setFetchSize(int r) throws SQLException {
        ((ResultSet) rs).setFetchSize(r);
    }
    /** @see java.sql.Statement#getFetchDirection() */
    public int getFetchDirection() throws SQLException {
        return ResultSet.FETCH_FORWARD;
    }
    /** @see java.sql.Statement#setFetchDirection(int) */
    public void setFetchDirection(int direction) throws SQLException {
        switch (direction) {
            case ResultSet.FETCH_FORWARD:
            case ResultSet.FETCH_REVERSE:
            case ResultSet.FETCH_UNKNOWN:
                // No-op: SQLite does not support a value other than FETCH_FORWARD
                break;
            default:
                throw new SQLException(
                        "Unknown fetch direction "
                                + direction
                                + ". "
                                + "Must be one of FETCH_FORWARD, FETCH_REVERSE, or FETCH_UNKNOWN in java.sql.ResultSet");
        }
    }
    /**
     * SQLite does not support multiple results from execute().
     *
     * @see java.sql.Statement#getMoreResults()
     */
    public boolean getMoreResults() throws SQLException {
        return getMoreResults(Statement.CLOSE_CURRENT_RESULT);
    }
    /** @see java.sql.Statement#getMoreResults(int) */
    public boolean getMoreResults(int current) throws SQLException {
        checkOpen();
        if (current == Statement.KEEP_CURRENT_RESULT || current == Statement.CLOSE_ALL_RESULTS) {
            throw new SQLFeatureNotSupportedException(
                    "Argument not supported: Statement.KEEP_CURRENT_RESULT or Statement.CLOSE_ALL_RESULTS");
        }
        if (current != Statement.CLOSE_CURRENT_RESULT) {
            throw new SQLException("Invalid argument");
        }
        // we support a single result set, close it
        rs.close();
        // as we don't have more result, change the update count to -1
        updateCount = -1;
        exhaustedResults = true;
        // always return false as we never have more results
        return false;
    }
    /** @see java.sql.Statement#getResultSetConcurrency() */
    public int getResultSetConcurrency() throws SQLException {
        return ResultSet.CONCUR_READ_ONLY;
    }
    /** @see java.sql.Statement#getResultSetHoldability() */
    public int getResultSetHoldability() throws SQLException {
        return ResultSet.CLOSE_CURSORS_AT_COMMIT;
    }
    /** @see java.sql.Statement#getResultSetType() */
    public int getResultSetType() throws SQLException {
        return ResultSet.TYPE_FORWARD_ONLY;
    }
    /** @see java.sql.Statement#setEscapeProcessing(boolean) */
    public void setEscapeProcessing(boolean enable) {
        // no-op
        // This previously threw a SQLException as unsupported (added in
        // 44e559b74d53e2ca006a4638f57a4e6662d0f2c0),
        // but it's not allowed to do that according to the method documentation.
        // This had impacts when using CachedRowSet for example (Github #224).
        // The default value according to the JDBC spec is true, so changing this should not have
        // any impact.
    }
    protected SQLException unsupported() {
        return new SQLFeatureNotSupportedException("not implemented by SQLite JDBC driver");
    }
    // Statement ////////////////////////////////////////////////////
    public boolean execute(String sql, int[] colinds) throws SQLException {
        throw unsupported();
    }
    public boolean execute(String sql, String[] colnames) throws SQLException {
        throw unsupported();
    }
    public int executeUpdate(String sql, int[] colinds) throws SQLException {
        throw unsupported();
    }
    public int executeUpdate(String sql, String[] cols) throws SQLException {
        throw unsupported();
    }
    public long executeLargeUpdate(String sql, int[] colinds) throws SQLException {
        throw unsupported();
    }
    public long executeLargeUpdate(String sql, String[] cols) throws SQLException {
        throw unsupported();
    }
    protected <T> T withConnectionTimeout(SQLCallable<T> callable) throws SQLException {
        int origBusyTimeout = conn.getBusyTimeout();
        if (queryTimeout > 0) {
            // SQLite handles busy timeout in milliseconds, JDBC in seconds
            conn.setBusyTimeout(1000 * queryTimeout);
        }
        try {
            return callable.call();
        } finally {
            if (queryTimeout > 0) {
                // reset connection timeout to the original value
                conn.setBusyTimeout(origBusyTimeout);
            }
        }
    }
    @FunctionalInterface
    protected interface SQLCallable<T> {
        T call() throws SQLException;
    }
}
package org.sqlite.jdbc3;
import java.io.IOException;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.Statement;
import java.sql.Struct;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.sqlite.SQLiteConnection;
import org.sqlite.core.CoreDatabaseMetaData;
import org.sqlite.core.CoreStatement;
import org.sqlite.jdbc3.JDBC3DatabaseMetaData.ImportedKeyFinder.ForeignKey;
import org.sqlite.util.Logger;
import org.sqlite.util.LoggerFactory;
import org.sqlite.util.QueryUtils;
import org.sqlite.util.StringUtils;
public abstract class JDBC3DatabaseMetaData extends CoreDatabaseMetaData {
    private static String driverName;
    private static String driverVersion;
    static {
        try (InputStream sqliteJdbcPropStream =
                JDBC3DatabaseMetaData.class
                        .getClassLoader()
                        .getResourceAsStream("sqlite-jdbc.properties")) {
            if (sqliteJdbcPropStream == null) {
                throw new IOException("Cannot load sqlite-jdbc.properties from jar");
            }
            final Properties sqliteJdbcProp = new Properties();
            sqliteJdbcProp.load(sqliteJdbcPropStream);
            driverName = sqliteJdbcProp.getProperty("name");
            driverVersion = sqliteJdbcProp.getProperty("version");
        } catch (Exception e) {
            // Default values
            driverName = "SQLite JDBC";
            driverVersion = "3.0.0-UNKNOWN";
        }
    }
    protected JDBC3DatabaseMetaData(SQLiteConnection conn) {
        super(conn);
    }
    /** @see java.sql.DatabaseMetaData#getConnection() */
    public Connection getConnection() {
        return conn;
    }
    /** @see java.sql.DatabaseMetaData#getDatabaseMajorVersion() */
    public int getDatabaseMajorVersion() throws SQLException {
        return Integer.parseInt(conn.libversion().split("\\.")[0]);
    }
    /** @see java.sql.DatabaseMetaData#getDatabaseMinorVersion() */
    public int getDatabaseMinorVersion() throws SQLException {
        return Integer.parseInt(conn.libversion().split("\\.")[1]);
    }
    /** @see java.sql.DatabaseMetaData#getDriverMajorVersion() */
    public int getDriverMajorVersion() {
        return Integer.parseInt(driverVersion.split("\\.")[0]);
    }
    /** @see java.sql.DatabaseMetaData#getDriverMinorVersion() */
    public int getDriverMinorVersion() {
        return Integer.parseInt(driverVersion.split("\\.")[1]);
    }
    /** @see java.sql.DatabaseMetaData#getJDBCMajorVersion() */
    public int getJDBCMajorVersion() {
        return 4;
    }
    /** @see java.sql.DatabaseMetaData#getJDBCMinorVersion() */
    public int getJDBCMinorVersion() {
        return 2;
    }
    /** @see java.sql.DatabaseMetaData#getDefaultTransactionIsolation() */
    public int getDefaultTransactionIsolation() {
        return Connection.TRANSACTION_SERIALIZABLE;
    }
    /** @see java.sql.DatabaseMetaData#getMaxBinaryLiteralLength() */
    public int getMaxBinaryLiteralLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxCatalogNameLength() */
    public int getMaxCatalogNameLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxCharLiteralLength() */
    public int getMaxCharLiteralLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxColumnNameLength() */
    public int getMaxColumnNameLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxColumnsInGroupBy() */
    public int getMaxColumnsInGroupBy() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxColumnsInIndex() */
    public int getMaxColumnsInIndex() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxColumnsInOrderBy() */
    public int getMaxColumnsInOrderBy() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxColumnsInSelect() */
    public int getMaxColumnsInSelect() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxColumnsInTable() */
    public int getMaxColumnsInTable() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxConnections() */
    public int getMaxConnections() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxCursorNameLength() */
    public int getMaxCursorNameLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxIndexLength() */
    public int getMaxIndexLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxProcedureNameLength() */
    public int getMaxProcedureNameLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxRowSize() */
    public int getMaxRowSize() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxSchemaNameLength() */
    public int getMaxSchemaNameLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxStatementLength() */
    public int getMaxStatementLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxStatements() */
    public int getMaxStatements() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxTableNameLength() */
    public int getMaxTableNameLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxTablesInSelect() */
    public int getMaxTablesInSelect() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getMaxUserNameLength() */
    public int getMaxUserNameLength() {
        return 0;
    }
    /** @see java.sql.DatabaseMetaData#getResultSetHoldability() */
    public int getResultSetHoldability() {
        return ResultSet.CLOSE_CURSORS_AT_COMMIT;
    }
    /** @see java.sql.DatabaseMetaData#getSQLStateType() */
    public int getSQLStateType() {
        return DatabaseMetaData.sqlStateSQL99;
    }
    /** @see java.sql.DatabaseMetaData#getDatabaseProductName() */
    public String getDatabaseProductName() {
        return "SQLite";
    }
    /** @see java.sql.DatabaseMetaData#getDatabaseProductVersion() */
    public String getDatabaseProductVersion() throws SQLException {
        return conn.libversion();
    }
    /** @see java.sql.DatabaseMetaData#getDriverName() */
    public String getDriverName() {
        return driverName;
    }
    /** @see java.sql.DatabaseMetaData#getDriverVersion() */
    public String getDriverVersion() {
        return driverVersion;
    }
    /** @see java.sql.DatabaseMetaData#getExtraNameCharacters() */
    public String getExtraNameCharacters() {
        return "";
    }
    /** @see java.sql.DatabaseMetaData#getCatalogSeparator() */
    public String getCatalogSeparator() {
        return ".";
    }
    /** @see java.sql.DatabaseMetaData#getCatalogTerm() */
    public String getCatalogTerm() {
        return "catalog";
    }
    /** @see java.sql.DatabaseMetaData#getSchemaTerm() */
    public String getSchemaTerm() {
        return "schema";
    }
    /** @see java.sql.DatabaseMetaData#getProcedureTerm() */
    public String getProcedureTerm() {
        return "not_implemented";
    }
    /** @see java.sql.DatabaseMetaData#getSearchStringEscape() */
    public String getSearchStringEscape() {
        return "\\";
    }
    /** @see java.sql.DatabaseMetaData#getIdentifierQuoteString() */
    public String getIdentifierQuoteString() {
        return "\"";
    }
    /**
     * @see java.sql.DatabaseMetaData#getSQLKeywords()
     * @see <a href="https://www.sqlite.org/lang_keywords.html">SQLite Keywords</a>
     */
    public String getSQLKeywords() {
        return "ABORT,ACTION,AFTER,ANALYZE,ATTACH,AUTOINCREMENT,BEFORE,"
                + "CASCADE,CONFLICT,DATABASE,DEFERRABLE,DEFERRED,DESC,DETACH,"
                + "EXCLUSIVE,EXPLAIN,FAIL,GLOB,IGNORE,INDEX,INDEXED,INITIALLY,INSTEAD,ISNULL,"
                + "KEY,LIMIT,NOTNULL,OFFSET,PLAN,PRAGMA,QUERY,"
                + "RAISE,REGEXP,REINDEX,RENAME,REPLACE,RESTRICT,"
                + "TEMP,TEMPORARY,TRANSACTION,VACUUM,VIEW,VIRTUAL";
    }
    /** @see java.sql.DatabaseMetaData#getNumericFunctions() */
    public String getNumericFunctions() {
        return "";
    }
    /** @see java.sql.DatabaseMetaData#getStringFunctions() */
    public String getStringFunctions() {
        return "";
    }
    /** @see java.sql.DatabaseMetaData#getSystemFunctions() */
    public String getSystemFunctions() {
        return "";
    }
    /** @see java.sql.DatabaseMetaData#getTimeDateFunctions() */
    public String getTimeDateFunctions() {
        return "DATE,TIME,DATETIME,JULIANDAY,STRFTIME";
    }
    /** @see java.sql.DatabaseMetaData#getURL() */
    public String getURL() {
        return conn.getUrl();
    }
    /** @see java.sql.DatabaseMetaData#getUserName() */
    public String getUserName() {
        return null;
    }
    /** @see java.sql.DatabaseMetaData#allProceduresAreCallable() */
    public boolean allProceduresAreCallable() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#allTablesAreSelectable() */
    public boolean allTablesAreSelectable() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#dataDefinitionCausesTransactionCommit() */
    public boolean dataDefinitionCausesTransactionCommit() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#dataDefinitionIgnoredInTransactions() */
    public boolean dataDefinitionIgnoredInTransactions() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#doesMaxRowSizeIncludeBlobs() */
    public boolean doesMaxRowSizeIncludeBlobs() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#deletesAreDetected(int) */
    public boolean deletesAreDetected(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#insertsAreDetected(int) */
    public boolean insertsAreDetected(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#isCatalogAtStart() */
    public boolean isCatalogAtStart() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#locatorsUpdateCopy() */
    public boolean locatorsUpdateCopy() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#nullPlusNonNullIsNull() */
    public boolean nullPlusNonNullIsNull() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#nullsAreSortedAtEnd() */
    public boolean nullsAreSortedAtEnd() {
        return !nullsAreSortedAtStart();
    }
    /** @see java.sql.DatabaseMetaData#nullsAreSortedAtStart() */
    public boolean nullsAreSortedAtStart() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#nullsAreSortedHigh() */
    public boolean nullsAreSortedHigh() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#nullsAreSortedLow() */
    public boolean nullsAreSortedLow() {
        return !nullsAreSortedHigh();
    }
    /** @see java.sql.DatabaseMetaData#othersDeletesAreVisible(int) */
    public boolean othersDeletesAreVisible(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#othersInsertsAreVisible(int) */
    public boolean othersInsertsAreVisible(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#othersUpdatesAreVisible(int) */
    public boolean othersUpdatesAreVisible(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#ownDeletesAreVisible(int) */
    public boolean ownDeletesAreVisible(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#ownInsertsAreVisible(int) */
    public boolean ownInsertsAreVisible(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#ownUpdatesAreVisible(int) */
    public boolean ownUpdatesAreVisible(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#storesLowerCaseIdentifiers() */
    public boolean storesLowerCaseIdentifiers() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#storesLowerCaseQuotedIdentifiers() */
    public boolean storesLowerCaseQuotedIdentifiers() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#storesMixedCaseIdentifiers() */
    public boolean storesMixedCaseIdentifiers() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#storesMixedCaseQuotedIdentifiers() */
    public boolean storesMixedCaseQuotedIdentifiers() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#storesUpperCaseIdentifiers() */
    public boolean storesUpperCaseIdentifiers() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#storesUpperCaseQuotedIdentifiers() */
    public boolean storesUpperCaseQuotedIdentifiers() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsAlterTableWithAddColumn() */
    public boolean supportsAlterTableWithAddColumn() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsAlterTableWithDropColumn() */
    public boolean supportsAlterTableWithDropColumn() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsANSI92EntryLevelSQL() */
    public boolean supportsANSI92EntryLevelSQL() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsANSI92FullSQL() */
    public boolean supportsANSI92FullSQL() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsANSI92IntermediateSQL() */
    public boolean supportsANSI92IntermediateSQL() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsBatchUpdates() */
    public boolean supportsBatchUpdates() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsCatalogsInDataManipulation() */
    public boolean supportsCatalogsInDataManipulation() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsCatalogsInIndexDefinitions() */
    public boolean supportsCatalogsInIndexDefinitions() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsCatalogsInPrivilegeDefinitions() */
    public boolean supportsCatalogsInPrivilegeDefinitions() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsCatalogsInProcedureCalls() */
    public boolean supportsCatalogsInProcedureCalls() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsCatalogsInTableDefinitions() */
    public boolean supportsCatalogsInTableDefinitions() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsColumnAliasing() */
    public boolean supportsColumnAliasing() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsConvert() */
    public boolean supportsConvert() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsConvert(int, int) */
    public boolean supportsConvert(int fromType, int toType) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsCorrelatedSubqueries() */
    public boolean supportsCorrelatedSubqueries() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsDataDefinitionAndDataManipulationTransactions() */
    public boolean supportsDataDefinitionAndDataManipulationTransactions() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsDataManipulationTransactionsOnly() */
    public boolean supportsDataManipulationTransactionsOnly() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsDifferentTableCorrelationNames() */
    public boolean supportsDifferentTableCorrelationNames() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsExpressionsInOrderBy() */
    public boolean supportsExpressionsInOrderBy() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsMinimumSQLGrammar() */
    public boolean supportsMinimumSQLGrammar() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsCoreSQLGrammar() */
    public boolean supportsCoreSQLGrammar() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsExtendedSQLGrammar() */
    public boolean supportsExtendedSQLGrammar() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsLimitedOuterJoins() */
    public boolean supportsLimitedOuterJoins() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsFullOuterJoins() */
    public boolean supportsFullOuterJoins() throws SQLException {
        String[] version = conn.libversion().split("\\.");
        return Integer.parseInt(version[0]) >= 3 && Integer.parseInt(version[1]) >= 39;
    }
    /** @see java.sql.DatabaseMetaData#supportsGetGeneratedKeys() */
    public boolean supportsGetGeneratedKeys() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsGroupBy() */
    public boolean supportsGroupBy() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsGroupByBeyondSelect() */
    public boolean supportsGroupByBeyondSelect() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsGroupByUnrelated() */
    public boolean supportsGroupByUnrelated() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsIntegrityEnhancementFacility() */
    public boolean supportsIntegrityEnhancementFacility() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsLikeEscapeClause() */
    public boolean supportsLikeEscapeClause() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsMixedCaseIdentifiers() */
    public boolean supportsMixedCaseIdentifiers() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsMixedCaseQuotedIdentifiers() */
    public boolean supportsMixedCaseQuotedIdentifiers() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsMultipleOpenResults() */
    public boolean supportsMultipleOpenResults() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsMultipleResultSets() */
    public boolean supportsMultipleResultSets() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsMultipleTransactions() */
    public boolean supportsMultipleTransactions() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsNamedParameters() */
    public boolean supportsNamedParameters() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsNonNullableColumns() */
    public boolean supportsNonNullableColumns() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsOpenCursorsAcrossCommit() */
    public boolean supportsOpenCursorsAcrossCommit() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsOpenCursorsAcrossRollback() */
    public boolean supportsOpenCursorsAcrossRollback() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsOpenStatementsAcrossCommit() */
    public boolean supportsOpenStatementsAcrossCommit() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsOpenStatementsAcrossRollback() */
    public boolean supportsOpenStatementsAcrossRollback() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsOrderByUnrelated() */
    public boolean supportsOrderByUnrelated() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsOuterJoins() */
    public boolean supportsOuterJoins() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsPositionedDelete() */
    public boolean supportsPositionedDelete() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsPositionedUpdate() */
    public boolean supportsPositionedUpdate() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsResultSetConcurrency(int, int) */
    public boolean supportsResultSetConcurrency(int t, int c) {
        return t == ResultSet.TYPE_FORWARD_ONLY && c == ResultSet.CONCUR_READ_ONLY;
    }
    /** @see java.sql.DatabaseMetaData#supportsResultSetHoldability(int) */
    public boolean supportsResultSetHoldability(int h) {
        return h == ResultSet.CLOSE_CURSORS_AT_COMMIT;
    }
    /** @see java.sql.DatabaseMetaData#supportsResultSetType(int) */
    public boolean supportsResultSetType(int t) {
        return t == ResultSet.TYPE_FORWARD_ONLY;
    }
    /** @see java.sql.DatabaseMetaData#supportsSavepoints() */
    public boolean supportsSavepoints() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsSchemasInDataManipulation() */
    public boolean supportsSchemasInDataManipulation() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsSchemasInIndexDefinitions() */
    public boolean supportsSchemasInIndexDefinitions() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsSchemasInPrivilegeDefinitions() */
    public boolean supportsSchemasInPrivilegeDefinitions() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsSchemasInProcedureCalls() */
    public boolean supportsSchemasInProcedureCalls() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsSchemasInTableDefinitions() */
    public boolean supportsSchemasInTableDefinitions() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsSelectForUpdate() */
    public boolean supportsSelectForUpdate() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsStatementPooling() */
    public boolean supportsStatementPooling() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsStoredProcedures() */
    public boolean supportsStoredProcedures() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsSubqueriesInComparisons() */
    public boolean supportsSubqueriesInComparisons() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsSubqueriesInExists() */
    public boolean supportsSubqueriesInExists() {
        return true;
    } // TODO: check
    /** @see java.sql.DatabaseMetaData#supportsSubqueriesInIns() */
    public boolean supportsSubqueriesInIns() {
        return true;
    } // TODO: check
    /** @see java.sql.DatabaseMetaData#supportsSubqueriesInQuantifieds() */
    public boolean supportsSubqueriesInQuantifieds() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsTableCorrelationNames() */
    public boolean supportsTableCorrelationNames() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#supportsTransactionIsolationLevel(int) */
    public boolean supportsTransactionIsolationLevel(int level) {
        return level == Connection.TRANSACTION_SERIALIZABLE;
    }
    /** @see java.sql.DatabaseMetaData#supportsTransactions() */
    public boolean supportsTransactions() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsUnion() */
    public boolean supportsUnion() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#supportsUnionAll() */
    public boolean supportsUnionAll() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#updatesAreDetected(int) */
    public boolean updatesAreDetected(int type) {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#usesLocalFilePerTable() */
    public boolean usesLocalFilePerTable() {
        return false;
    }
    /** @see java.sql.DatabaseMetaData#usesLocalFiles() */
    public boolean usesLocalFiles() {
        return true;
    }
    /** @see java.sql.DatabaseMetaData#isReadOnly() */
    public boolean isReadOnly() throws SQLException {
        return conn.isReadOnly();
    }
    /**
     * @see java.sql.DatabaseMetaData#getAttributes(java.lang.String, java.lang.String,
     *     java.lang.String, java.lang.String)
     */
    public ResultSet getAttributes(String c, String s, String t, String a) throws SQLException {
        if (getAttributes == null) {
            getAttributes =
                    conn.prepareStatement(
                            "select null as TYPE_CAT, null as TYPE_SCHEM, "
                                    + "null as TYPE_NAME, null as ATTR_NAME, null as DATA_TYPE, "
                                    + "null as ATTR_TYPE_NAME, null as ATTR_SIZE, null as DECIMAL_DIGITS, "
                                    + "null as NUM_PREC_RADIX, null as NULLABLE, null as REMARKS, null as ATTR_DEF, "
                                    + "null as SQL_DATA_TYPE, null as SQL_DATETIME_SUB, null as CHAR_OCTET_LENGTH, "
                                    + "null as ORDINAL_POSITION, null as IS_NULLABLE, null as SCOPE_CATALOG, "
                                    + "null as SCOPE_SCHEMA, null as SCOPE_TABLE, null as SOURCE_DATA_TYPE limit 0;");
        }
        return getAttributes.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getBestRowIdentifier(java.lang.String, java.lang.String,
     *     java.lang.String, int, boolean)
     */
    public ResultSet getBestRowIdentifier(String c, String s, String t, int scope, boolean n)
            throws SQLException {
        if (getBestRowIdentifier == null) {
            getBestRowIdentifier =
                    conn.prepareStatement(
                            "select null as SCOPE, null as COLUMN_NAME, "
                                    + "null as DATA_TYPE, null as TYPE_NAME, null as COLUMN_SIZE, "
                                    + "null as BUFFER_LENGTH, null as DECIMAL_DIGITS, null as PSEUDO_COLUMN limit 0;");
        }
        return getBestRowIdentifier.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getColumnPrivileges(java.lang.String, java.lang.String,
     *     java.lang.String, java.lang.String)
     */
    public ResultSet getColumnPrivileges(String c, String s, String t, String colPat)
            throws SQLException {
        if (getColumnPrivileges == null) {
            getColumnPrivileges =
                    conn.prepareStatement(
                            "select null as TABLE_CAT, null as TABLE_SCHEM, "
                                    + "null as TABLE_NAME, null as COLUMN_NAME, null as GRANTOR, null as GRANTEE, "
                                    + "null as PRIVILEGE, null as IS_GRANTABLE limit 0;");
        }
        return getColumnPrivileges.executeQuery();
    }
    // Column type patterns
    protected static final Pattern TYPE_INTEGER = Pattern.compile(".*(INT|BOOL).*");
    protected static final Pattern TYPE_VARCHAR = Pattern.compile(".*(CHAR|CLOB|TEXT|BLOB).*");
    protected static final Pattern TYPE_FLOAT = Pattern.compile(".*(REAL|FLOA|DOUB|DEC|NUM).*");
    /**
     * @see java.sql.DatabaseMetaData#getColumns(java.lang.String, java.lang.String,
     *     java.lang.String, java.lang.String)
     */
    public ResultSet getColumns(String c, String s, String tblNamePattern, String colNamePattern)
            throws SQLException {
        // get the list of tables matching the pattern (getTables)
        // create a Matrix Cursor for each of the tables
        // create a merge cursor from all the Matrix Cursors
        // and return the columname and type from:
        //    "PRAGMA table_xinfo(tablename)"
        // which returns data like this:
        //        sqlite> PRAGMA lastyear.table_info(gross_sales);
        //        cid|name|type|notnull|dflt_value|pk
        //        0|year|INTEGER|0|'2006'|0
        //        1|month|TEXT|0||0
        //        2|monthlygross|REAL|0||0
        //        3|sortcol|INTEGER|0||0
        //        sqlite>
        // and then make the cursor have these columns
        //        TABLE_CAT String => table catalog (may be null)
        //        TABLE_SCHEM String => table schema (may be null)
        //        TABLE_NAME String => table name
        //        COLUMN_NAME String => column name
        //        DATA_TYPE int => SQL type from java.sql.Types
        //        TYPE_NAME String => Data source dependent type name, for a UDT the type name is
        // fully qualified
        //        COLUMN_SIZE int => column size.
        //        BUFFER_LENGTH is not used.
        //        DECIMAL_DIGITS int => the number of fractional digits. Null is returned for data
        // types where DECIMAL_DIGITS is not applicable.
        //        NUM_PREC_RADIX int => Radix (typically either 10 or 2)
        //        NULLABLE int => is NULL allowed.
        //        columnNoNulls - might not allow NULL values
        //        columnNullable - definitely allows NULL values
        //        columnNullableUnknown - nullability unknown
        //        REMARKS String => comment describing column (may be null)
        //        COLUMN_DEF String => default value for the column, which should be interpreted as
        // a string when the value is enclosed in single quotes (may be null)
        //        SQL_DATA_TYPE int => unused
        //        SQL_DATETIME_SUB int => unused
        //        CHAR_OCTET_LENGTH int => for char types the maximum number of bytes in the column
        //        ORDINAL_POSITION int => index of column in table (starting at 1)
        //        IS_NULLABLE String => ISO rules are used to determine the nullability for a
        // column.
        //        YES --- if the parameter can include NULLs
        //        NO --- if the parameter cannot include NULLs
        //        empty string --- if the nullability for the parameter is unknown
        //        SCOPE_CATALOG String => catalog of table that is the scope of a reference
        // attribute
        // (null if DATA_TYPE isn't REF)
        //        SCOPE_SCHEMA String => schema of table that is the scope of a reference attribute
        // (null if the DATA_TYPE isn't REF)
        //        SCOPE_TABLE String => table name that this the scope of a reference attribute
        // (null if the DATA_TYPE isn't REF)
        //        SOURCE_DATA_TYPE short => source type of a distinct type or user-generated Ref
        // type, SQL type from java.sql.Types (null if DATA_TYPE isn't DISTINCT or user-generated
        // REF)
        //        IS_AUTOINCREMENT String => Indicates whether this column is auto incremented
        //        YES --- if the column is auto incremented
        //        NO --- if the column is not auto incremented
        //        empty string --- if it cannot be determined whether the column is auto incremented
        // parameter is unknown
        //        IS_GENERATEDCOLUMN String => Indicates whether this column is auto incremented
        //        YES --- if the column is generated
        //        NO --- if the column is not generated
        //        empty string --- if it cannot be determined whether the column is auto incremented
        // parameter is unknown
        checkOpen();
        StringBuilder sql = new StringBuilder(700);
        sql.append("select null as TABLE_CAT, null as TABLE_SCHEM, tblname as TABLE_NAME, ")
                .append(
                        "cn as COLUMN_NAME, ct as DATA_TYPE, tn as TYPE_NAME, colSize as COLUMN_SIZE, ")
                .append(
                        "2000000000 as BUFFER_LENGTH, colDecimalDigits as DECIMAL_DIGITS, 10   as NUM_PREC_RADIX, ")
                .append("colnullable as NULLABLE, null as REMARKS, colDefault as COLUMN_DEF, ")
                .append(
                        "0    as SQL_DATA_TYPE, 0    as SQL_DATETIME_SUB, 2000000000 as CHAR_OCTET_LENGTH, ")
                .append(
                        "ordpos as ORDINAL_POSITION, (case colnullable when 0 then 'NO' when 1 then 'YES' else '' end)")
                .append("    as IS_NULLABLE, null as SCOPE_CATALOG, null as SCOPE_SCHEMA, ")
                .append("null as SCOPE_TABLE, null as SOURCE_DATA_TYPE, ")
                .append(
                        "(case colautoincrement when 0 then 'NO' when 1 then 'YES' else '' end) as IS_AUTOINCREMENT, ")
                .append(
                        "(case colgenerated when 0 then 'NO' when 1 then 'YES' else '' end) as IS_GENERATEDCOLUMN from (");
        boolean colFound = false;
        ResultSet rs = null;
        try {
            // Get all tables implied by the input
            rs = getTables(c, s, tblNamePattern, null);
            while (rs.next()) {
                String tableName = rs.getString(3);
                boolean isAutoIncrement;
                Statement statColAutoinc = conn.createStatement();
                ResultSet rsColAutoinc = null;
                try {
                    statColAutoinc = conn.createStatement();
                    rsColAutoinc =
                            statColAutoinc.executeQuery(
                                    "SELECT LIKE('%autoincrement%', LOWER(sql)) FROM sqlite_schema "
                                            + "WHERE LOWER(name) = LOWER('"
                                            + escape(tableName)
                                            + "') AND TYPE IN ('table', 'view')");
                    rsColAutoinc.next();
                    isAutoIncrement = rsColAutoinc.getInt(1) == 1;
                } finally {
                    if (rsColAutoinc != null) {
                        try {
                            rsColAutoinc.close();
                        } catch (Exception e) {
                            LogHolder.logger.error(() -> "Could not close ResultSet", e);
                        }
                    }
                    if (statColAutoinc != null) {
                        try {
                            statColAutoinc.close();
                        } catch (Exception e) {
                            LogHolder.logger.error(() -> "Could not close statement", e);
                        }
                    }
                }
                // For each table, get the column info and build into overall SQL
                String pragmaStatement = "PRAGMA table_xinfo('" + escape(tableName) + "')";
                try (Statement colstat = conn.createStatement();
                        ResultSet rscol = colstat.executeQuery(pragmaStatement)) {
                    for (int i = 0; rscol.next(); i++) {
                        String colName = rscol.getString(2);
                        String colType = rscol.getString(3);
                        String colNotNull = rscol.getString(4);
                        String colDefault = rscol.getString(5);
                        boolean isPk = "1".equals(rscol.getString(6));
                        String colHidden = rscol.getString(7);
                        int colNullable = 2;
                        if (colNotNull != null) {
                            colNullable = colNotNull.equals("0") ? 1 : 0;
                        }
                        if (colFound) {
                            sql.append(" union all ");
                        }
                        colFound = true;
                        // default values
                        int iColumnSize = 2000000000;
                        int iDecimalDigits = 10;
                        /*
                         * improved column types
                         * ref https://www.sqlite.org/datatype3.html - 2.1 Determination Of Column Affinity
                         * plus some degree of artistic-license applied
                         */
                        colType = colType == null ? "TEXT" : colType.toUpperCase();
                        int colAutoIncrement = 0;
                        if (isPk && isAutoIncrement) {
                            colAutoIncrement = 1;
                        }
                        int colJavaType;
                        // rule #1 + boolean
                        if (TYPE_INTEGER.matcher(colType).find()) {
                            colJavaType = Types.INTEGER;
                            // there are no decimal digits
                            iDecimalDigits = 0;
                        } else if (TYPE_VARCHAR.matcher(colType).find()) {
                            colJavaType = Types.VARCHAR;
                            // there are no decimal digits
                            iDecimalDigits = 0;
                        } else if (TYPE_FLOAT.matcher(colType).find()) {
                            colJavaType = Types.FLOAT;
                        } else {
                            // catch-all
                            colJavaType = Types.VARCHAR;
                        }
                        // try to find an (optional) length/dimension of the column
                        int iStartOfDimension = colType.indexOf('(');
                        if (iStartOfDimension > 0) {
                            // find end of dimension
                            int iEndOfDimension = colType.indexOf(')', iStartOfDimension);
                            if (iEndOfDimension > 0) {
                                String sInteger, sDecimal;
                                // check for two values (integer part, fraction) divided by
                                // comma
                                int iDimensionSeparator = colType.indexOf(',', iStartOfDimension);
                                if (iDimensionSeparator > 0) {
                                    sInteger =
                                            colType.substring(
                                                    iStartOfDimension + 1, iDimensionSeparator);
                                    sDecimal =
                                            colType.substring(
                                                    iDimensionSeparator + 1, iEndOfDimension);
                                }
                                // only a single dimension
                                else {
                                    sInteger =
                                            colType.substring(
                                                    iStartOfDimension + 1, iEndOfDimension);
                                    sDecimal = null;
                                }
                                // try to parse the values
                                try {
                                    int iInteger = Integer.parseUnsignedInt(sInteger.trim());
                                    // parse decimals?
                                    if (sDecimal != null) {
                                        iDecimalDigits = Integer.parseUnsignedInt(sDecimal.trim());
                                        // columns size equals sum of integer and decimal part
                                        // of dimension
                                        iColumnSize = iInteger + iDecimalDigits;
                                    } else {
                                        // no decimals
                                        iDecimalDigits = 0;
                                        // columns size equals dimension
                                        iColumnSize = iInteger;
                                    }
                                } catch (NumberFormatException ex) {
                                    // just ignore invalid dimension formats here
                                }
                            }
                            // "TYPE_NAME" (colType) is without the length/ dimension
                            colType = colType.substring(0, iStartOfDimension).trim();
                        }
                        int colGenerated = 0;
                        if ("2".equals(colHidden) || "3".equals(colHidden)) {
                            colGenerated = 1;
                        }
                        sql.append("select ")
                                .append(i + 1)
                                .append(" as ordpos, ")
                                .append(colNullable)
                                .append(" as colnullable,")
                                .append(colJavaType)
                                .append(" as ct, ")
                                .append(iColumnSize)
                                .append(" as colSize, ")
                                .append(iDecimalDigits)
                                .append(" as colDecimalDigits, ")
                                .append("'")
                                .append(tableName)
                                .append("' as tblname, ")
                                .append("'")
                                .append(escape(colName))
                                .append("' as cn, ")
                                .append("'")
                                .append(escape(colType))
                                .append("' as tn, ")
                                .append(quote(colDefault == null ? null : escape(colDefault)))
                                .append(" as colDefault,")
                                .append(colAutoIncrement)
                                .append(" as colautoincrement,")
                                .append(colGenerated)
                                .append(" as colgenerated");
                        if (colNamePattern != null) {
                            sql.append(" where upper(cn) like upper('")
                                    .append(escape(colNamePattern))
                                    .append("') ESCAPE '")
                                    .append(getSearchStringEscape())
                                    .append("'");
                        }
                    }
                }
            }
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (Exception e) {
                    LogHolder.logger.error(() -> "Could not close ResultSet", e);
                }
            }
        }
        if (colFound) {
            sql.append(") order by TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;");
        } else {
            sql.append(
                    "select null as ordpos, null as colnullable, null as ct, null as colsize, null as colDecimalDigits, null as tblname, null as cn, null as tn, null as colDefault, null as colautoincrement, null as colgenerated) limit 0;");
        }
        Statement stat = conn.createStatement();
        return ((CoreStatement) stat).executeQuery(sql.toString(), true);
    }
    /**
     * @see java.sql.DatabaseMetaData#getCrossReference(java.lang.String, java.lang.String,
     *     java.lang.String, java.lang.String, java.lang.String, java.lang.String)
     */
    public ResultSet getCrossReference(
            String pc, String ps, String pt, String fc, String fs, String ft) throws SQLException {
        if (pt == null) {
            return getExportedKeys(fc, fs, ft);
        }
        if (ft == null) {
            return getImportedKeys(pc, ps, pt);
        }
        String query =
                "select "
                        + quote(pc)
                        + " as PKTABLE_CAT, "
                        + quote(ps)
                        + " as PKTABLE_SCHEM, "
                        + quote(pt)
                        + " as PKTABLE_NAME, "
                        + "'' as PKCOLUMN_NAME, "
                        + quote(fc)
                        + " as FKTABLE_CAT, "
                        + quote(fs)
                        + " as FKTABLE_SCHEM, "
                        + quote(ft)
                        + " as FKTABLE_NAME, "
                        + "'' as FKCOLUMN_NAME, -1 as KEY_SEQ, 3 as UPDATE_RULE, 3 as DELETE_RULE, '' as FK_NAME, '' as PK_NAME, "
                        + DatabaseMetaData.importedKeyInitiallyDeferred
                        + " as DEFERRABILITY limit 0 ";
        return ((CoreStatement) conn.createStatement()).executeQuery(query, true);
    }
    /** @see java.sql.DatabaseMetaData#getSchemas() */
    public ResultSet getSchemas() throws SQLException {
        if (getSchemas == null) {
            getSchemas =
                    conn.prepareStatement(
                            "select null as TABLE_SCHEM, null as TABLE_CATALOG limit 0;");
        }
        return getSchemas.executeQuery();
    }
    /** @see java.sql.DatabaseMetaData#getCatalogs() */
    public ResultSet getCatalogs() throws SQLException {
        if (getCatalogs == null) {
            getCatalogs = conn.prepareStatement("select null as TABLE_CAT limit 0;");
        }
        return getCatalogs.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getPrimaryKeys(java.lang.String, java.lang.String,
     *     java.lang.String)
     */
    public ResultSet getPrimaryKeys(String c, String s, String table) throws SQLException {
        PrimaryKeyFinder pkFinder = new PrimaryKeyFinder(table);
        String[] columns = pkFinder.getColumns();
        Statement stat = conn.createStatement();
        StringBuilder sql = new StringBuilder(512);
        sql.append("select null as TABLE_CAT, null as TABLE_SCHEM, '")
                .append(escape(table))
                .append("' as TABLE_NAME, cn as COLUMN_NAME, ks as KEY_SEQ, pk as PK_NAME from (");
        if (columns == null) {
            sql.append("select null as cn, null as pk, 0 as ks) limit 0;");
            return ((CoreStatement) stat).executeQuery(sql.toString(), true);
        }
        String pkName = pkFinder.getName();
        if (pkName != null) {
            pkName = "'" + pkName + "'";
        }
        for (int i = 0; i < columns.length; i++) {
            if (i > 0) sql.append(" union ");
            sql.append("select ")
                    .append(pkName)
                    .append(" as pk, '")
                    .append(escape(unquoteIdentifier(columns[i])))
                    .append("' as cn, ")
                    .append(i + 1)
                    .append(" as ks");
        }
        return ((CoreStatement) stat).executeQuery(sql.append(") order by cn;").toString(), true);
    }
    private static final Map<String, Integer> RULE_MAP = new HashMap<>();
    static {
        RULE_MAP.put("NO ACTION", DatabaseMetaData.importedKeyNoAction);
        RULE_MAP.put("CASCADE", DatabaseMetaData.importedKeyCascade);
        RULE_MAP.put("RESTRICT", DatabaseMetaData.importedKeyRestrict);
        RULE_MAP.put("SET NULL", DatabaseMetaData.importedKeySetNull);
        RULE_MAP.put("SET DEFAULT", DatabaseMetaData.importedKeySetDefault);
    }
    /**
     * @see java.sql.DatabaseMetaData#getExportedKeys(java.lang.String, java.lang.String,
     *     java.lang.String)
     */
    public ResultSet getExportedKeys(String catalog, String schema, String table)
            throws SQLException {
        PrimaryKeyFinder pkFinder = new PrimaryKeyFinder(table);
        String[] pkColumns = pkFinder.getColumns();
        Statement stat = conn.createStatement();
        catalog = (catalog != null) ? quote(catalog) : null;
        schema = (schema != null) ? quote(schema) : null;
        StringBuilder exportedKeysQuery = new StringBuilder(512);
        String target = null;
        int count = 0;
        if (pkColumns != null) {
            // retrieve table list
            ArrayList<String> tableList;
            try (ResultSet rs =
                    stat.executeQuery("select name from sqlite_schema where type = 'table'")) {
                tableList = new ArrayList<>();
                while (rs.next()) {
                    String tblname = rs.getString(1);
                    tableList.add(tblname);
                    if (tblname.equalsIgnoreCase(table)) {
                        // get the correct case as in the database
                        // (not uppercase nor lowercase)
                        target = tblname;
                    }
                }
            }
            // find imported keys for each table
            for (String tbl : tableList) {
                final ImportedKeyFinder impFkFinder = new ImportedKeyFinder(tbl);
                List<ForeignKey> fkNames = impFkFinder.getFkList();
                for (ForeignKey foreignKey : fkNames) {
                    String PKTabName = foreignKey.getPkTableName();
                    if (PKTabName == null || !PKTabName.equalsIgnoreCase(target)) {
                        continue;
                    }
                    for (int j = 0; j < foreignKey.getColumnMappingCount(); j++) {
                        int keySeq = j + 1;
                        String[] columnMapping = foreignKey.getColumnMapping(j);
                        String PKColName = columnMapping[1];
                        PKColName = (PKColName == null) ? "" : PKColName;
                        String FKColName = columnMapping[0];
                        FKColName = (FKColName == null) ? "" : FKColName;
                        boolean usePkName = false;
                        for (String pkColumn : pkColumns) {
                            if (pkColumn != null && pkColumn.equalsIgnoreCase(PKColName)) {
                                usePkName = true;
                                break;
                            }
                        }
                        String pkName =
                                (usePkName && pkFinder.getName() != null) ? pkFinder.getName() : "";
                        exportedKeysQuery
                                .append(count > 0 ? " union all select " : "select ")
                                .append(keySeq)
                                .append(" as ks, '")
                                .append(escape(tbl))
                                .append("' as fkt, '")
                                .append(escape(FKColName))
                                .append("' as fcn, '")
                                .append(escape(PKColName))
                                .append("' as pcn, '")
                                .append(escape(pkName))
                                .append("' as pkn, ")
                                .append(RULE_MAP.get(foreignKey.getOnUpdate()))
                                .append(" as ur, ")
                                .append(RULE_MAP.get(foreignKey.getOnDelete()))
                                .append(" as dr, ");
                        String fkName = foreignKey.getFkName();
                        if (fkName != null) {
                            exportedKeysQuery.append("'").append(escape(fkName)).append("' as fkn");
                        } else {
                            exportedKeysQuery.append("'' as fkn");
                        }
                        count++;
                    }
                }
            }
        }
        boolean hasImportedKey = (count > 0);
        StringBuilder sql = new StringBuilder(512);
        sql.append("select ")
                .append(catalog)
                .append(" as PKTABLE_CAT, ")
                .append(schema)
                .append(" as PKTABLE_SCHEM, ")
                .append(quote(target))
                .append(" as PKTABLE_NAME, ")
                .append(hasImportedKey ? "pcn" : "''")
                .append(" as PKCOLUMN_NAME, ")
                .append(catalog)
                .append(" as FKTABLE_CAT, ")
                .append(schema)
                .append(" as FKTABLE_SCHEM, ")
                .append(hasImportedKey ? "fkt" : "''")
                .append(" as FKTABLE_NAME, ")
                .append(hasImportedKey ? "fcn" : "''")
                .append(" as FKCOLUMN_NAME, ")
                .append(hasImportedKey ? "ks" : "-1")
                .append(" as KEY_SEQ, ")
                .append(hasImportedKey ? "ur" : "3")
                .append(" as UPDATE_RULE, ")
                .append(hasImportedKey ? "dr" : "3")
                .append(" as DELETE_RULE, ")
                .append(hasImportedKey ? "fkn" : "''")
                .append(" as FK_NAME, ")
                .append(hasImportedKey ? "pkn" : "''")
                .append(" as PK_NAME, ")
                .append(DatabaseMetaData.importedKeyInitiallyDeferred) // FIXME: Check for pragma
                // foreign_keys = true ?
                .append(" as DEFERRABILITY ");
        if (hasImportedKey) {
            sql.append("from (")
                    .append(exportedKeysQuery)
                    .append(") ORDER BY FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, KEY_SEQ");
        } else {
            sql.append("limit 0");
        }
        return ((CoreStatement) stat).executeQuery(sql.toString(), true);
    }
    private StringBuilder appendDummyForeignKeyList(StringBuilder sql) {
        sql.append("select -1 as ks, '' as ptn, '' as fcn, '' as pcn, ")
                .append(DatabaseMetaData.importedKeyNoAction)
                .append(" as ur, ")
                .append(DatabaseMetaData.importedKeyNoAction)
                .append(" as dr, ")
                .append(" '' as fkn, ")
                .append(" '' as pkn ")
                .append(") limit 0;");
        return sql;
    }
    /**
     * @see java.sql.DatabaseMetaData#getImportedKeys(java.lang.String, java.lang.String,
     *     java.lang.String)
     */
    public ResultSet getImportedKeys(String catalog, String schema, String table)
            throws SQLException {
        ResultSet rs;
        Statement stat = conn.createStatement();
        StringBuilder sql = new StringBuilder(700);
        sql.append("select ")
                .append(quote(catalog))
                .append(" as PKTABLE_CAT, ")
                .append(quote(schema))
                .append(" as PKTABLE_SCHEM, ")
                .append("ptn as PKTABLE_NAME, pcn as PKCOLUMN_NAME, ")
                .append(quote(catalog))
                .append(" as FKTABLE_CAT, ")
                .append(quote(schema))
                .append(" as FKTABLE_SCHEM, ")
                .append(quote(table))
                .append(" as FKTABLE_NAME, ")
                .append(
                        "fcn as FKCOLUMN_NAME, ks as KEY_SEQ, ur as UPDATE_RULE, dr as DELETE_RULE, fkn as FK_NAME, pkn as PK_NAME, ")
                .append(DatabaseMetaData.importedKeyInitiallyDeferred)
                .append(" as DEFERRABILITY from (");
        // Use a try catch block to avoid "query does not return ResultSet" error
        try {
            rs = stat.executeQuery("pragma foreign_key_list('" + escape(table) + "');");
        } catch (SQLException e) {
            sql = appendDummyForeignKeyList(sql);
            return ((CoreStatement) stat).executeQuery(sql.toString(), true);
        }
        final ImportedKeyFinder impFkFinder = new ImportedKeyFinder(table);
        List<ForeignKey> fkNames = impFkFinder.getFkList();
        int i = 0;
        for (; rs.next(); i++) {
            int keySeq = rs.getInt(2) + 1;
            int keyId = rs.getInt(1);
            String PKTabName = rs.getString(3);
            String FKColName = rs.getString(4);
            String PKColName = rs.getString(5);
            String pkName = null;
            try {
                PrimaryKeyFinder pkFinder = new PrimaryKeyFinder(PKTabName);
                pkName = pkFinder.getName();
                if (PKColName == null) {
                    PKColName = pkFinder.getColumns()[0];
                }
            } catch (SQLException ignored) {
            }
            String updateRule = rs.getString(6);
            String deleteRule = rs.getString(7);
            if (i > 0) {
                sql.append(" union all ");
            }
            String fkName = null;
            if (fkNames.size() > keyId) fkName = fkNames.get(keyId).getFkName();
            sql.append("select ")
                    .append(keySeq)
                    .append(" as ks,")
                    .append("'")
                    .append(escape(PKTabName))
                    .append("' as ptn, '")
                    .append(escape(FKColName))
                    .append("' as fcn, '")
                    .append(escape(PKColName))
                    .append("' as pcn,")
                    .append("case '")
                    .append(escape(updateRule))
                    .append("'")
                    .append(" when 'NO ACTION' then ")
                    .append(DatabaseMetaData.importedKeyNoAction)
                    .append(" when 'CASCADE' then ")
                    .append(DatabaseMetaData.importedKeyCascade)
                    .append(" when 'RESTRICT' then ")
                    .append(DatabaseMetaData.importedKeyRestrict)
                    .append(" when 'SET NULL' then ")
                    .append(DatabaseMetaData.importedKeySetNull)
                    .append(" when 'SET DEFAULT' then ")
                    .append(DatabaseMetaData.importedKeySetDefault)
                    .append(" end as ur, ")
                    .append("case '")
                    .append(escape(deleteRule))
                    .append("'")
                    .append(" when 'NO ACTION' then ")
                    .append(DatabaseMetaData.importedKeyNoAction)
                    .append(" when 'CASCADE' then ")
                    .append(DatabaseMetaData.importedKeyCascade)
                    .append(" when 'RESTRICT' then ")
                    .append(DatabaseMetaData.importedKeyRestrict)
                    .append(" when 'SET NULL' then ")
                    .append(DatabaseMetaData.importedKeySetNull)
                    .append(" when 'SET DEFAULT' then ")
                    .append(DatabaseMetaData.importedKeySetDefault)
                    .append(" end as dr, ")
                    .append(fkName == null ? "''" : quote(fkName))
                    .append(" as fkn, ")
                    .append(pkName == null ? "''" : quote(pkName))
                    .append(" as pkn");
        }
        rs.close();
        if (i == 0) {
            sql = appendDummyForeignKeyList(sql);
        } else {
            sql.append(") ORDER BY PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME, KEY_SEQ;");
        }
        return ((CoreStatement) stat).executeQuery(sql.toString(), true);
    }
    /**
     * @see java.sql.DatabaseMetaData#getIndexInfo(java.lang.String, java.lang.String,
     *     java.lang.String, boolean, boolean)
     */
    public ResultSet getIndexInfo(String c, String s, String table, boolean u, boolean approximate)
            throws SQLException {
        ResultSet rs;
        Statement stat = conn.createStatement();
        StringBuilder sql = new StringBuilder(500);
        // define the column header
        // this is from the JDBC spec, it is part of the driver protocol
        sql.append("select null as TABLE_CAT, null as TABLE_SCHEM, '")
                .append(escape(table))
                .append(
                        "' as TABLE_NAME, un as NON_UNIQUE, null as INDEX_QUALIFIER, n as INDEX_NAME, ")
                .append(Integer.toString(DatabaseMetaData.tableIndexOther))
                .append(" as TYPE, op as ORDINAL_POSITION, ")
                .append(
                        "cn as COLUMN_NAME, null as ASC_OR_DESC, 0 as CARDINALITY, 0 as PAGES, null as FILTER_CONDITION from (");
        // this always returns a result set now, previously threw exception
        rs = stat.executeQuery("pragma index_list('" + escape(table) + "');");
        ArrayList<ArrayList<Object>> indexList = new ArrayList<>();
        while (rs.next()) {
            indexList.add(new ArrayList<>());
            indexList.get(indexList.size() - 1).add(rs.getString(2));
            indexList.get(indexList.size() - 1).add(rs.getInt(3));
        }
        rs.close();
        if (indexList.size() == 0) {
            // if pragma index_list() returns no information, use this null block
            sql.append("select null as un, null as n, null as op, null as cn) limit 0;");
            return ((CoreStatement) stat).executeQuery(sql.toString(), true);
        } else {
            // loop over results from pragma call, getting specific info for each index
            Iterator<ArrayList<Object>> indexIterator = indexList.iterator();
            ArrayList<Object> currentIndex;
            ArrayList<String> unionAll = new ArrayList<>();
            while (indexIterator.hasNext()) {
                currentIndex = indexIterator.next();
                String indexName = currentIndex.get(0).toString();
                rs = stat.executeQuery("pragma index_info('" + escape(indexName) + "');");
                while (rs.next()) {
                    StringBuilder sqlRow = new StringBuilder();
                    String colName = rs.getString(3);
                    sqlRow.append("select ")
                            .append(1 - (Integer) currentIndex.get(1))
                            .append(" as un,'")
                            .append(escape(indexName))
                            .append("' as n,")
                            .append(rs.getInt(1) + 1)
                            .append(" as op,");
                    if (colName == null) { // expression index
                        sqlRow.append("null");
                    } else {
                        sqlRow.append("'").append(escape(colName)).append("'");
                    }
                    sqlRow.append(" as cn");
                    unionAll.add(sqlRow.toString());
                }
                rs.close();
            }
            String sqlBlock = StringUtils.join(unionAll, " union all ");
            return ((CoreStatement) stat)
                    .executeQuery(sql.append(sqlBlock).append(");").toString(), true);
        }
    }
    /**
     * @see java.sql.DatabaseMetaData#getProcedureColumns(java.lang.String, java.lang.String,
     *     java.lang.String, java.lang.String)
     */
    public ResultSet getProcedureColumns(String c, String s, String p, String colPat)
            throws SQLException {
        if (getProcedureColumns == null) {
            getProcedureColumns =
                    conn.prepareStatement(
                            "select null as PROCEDURE_CAT, "
                                    + "null as PROCEDURE_SCHEM, null as PROCEDURE_NAME, null as COLUMN_NAME, "
                                    + "null as COLUMN_TYPE, null as DATA_TYPE, null as TYPE_NAME, null as PRECISION, "
                                    + "null as LENGTH, null as SCALE, null as RADIX, null as NULLABLE, "
                                    + "null as REMARKS limit 0;");
        }
        return getProcedureColumns.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getProcedures(java.lang.String, java.lang.String,
     *     java.lang.String)
     */
    public ResultSet getProcedures(String c, String s, String p) throws SQLException {
        if (getProcedures == null) {
            getProcedures =
                    conn.prepareStatement(
                            "select null as PROCEDURE_CAT, null as PROCEDURE_SCHEM, "
                                    + "null as PROCEDURE_NAME, null as UNDEF1, null as UNDEF2, null as UNDEF3, "
                                    + "null as REMARKS, null as PROCEDURE_TYPE limit 0;");
        }
        return getProcedures.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getSuperTables(java.lang.String, java.lang.String,
     *     java.lang.String)
     */
    public ResultSet getSuperTables(String c, String s, String t) throws SQLException {
        if (getSuperTables == null) {
            getSuperTables =
                    conn.prepareStatement(
                            "select null as TABLE_CAT, null as TABLE_SCHEM, "
                                    + "null as TABLE_NAME, null as SUPERTABLE_NAME limit 0;");
        }
        return getSuperTables.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getSuperTypes(java.lang.String, java.lang.String,
     *     java.lang.String)
     */
    public ResultSet getSuperTypes(String c, String s, String t) throws SQLException {
        if (getSuperTypes == null) {
            getSuperTypes =
                    conn.prepareStatement(
                            "select null as TYPE_CAT, null as TYPE_SCHEM, "
                                    + "null as TYPE_NAME, null as SUPERTYPE_CAT, null as SUPERTYPE_SCHEM, "
                                    + "null as SUPERTYPE_NAME limit 0;");
        }
        return getSuperTypes.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getTablePrivileges(java.lang.String, java.lang.String,
     *     java.lang.String)
     */
    public ResultSet getTablePrivileges(String c, String s, String t) throws SQLException {
        if (getTablePrivileges == null) {
            getTablePrivileges =
                    conn.prepareStatement(
                            "select  null as TABLE_CAT, "
                                    + "null as TABLE_SCHEM, null as TABLE_NAME, null as GRANTOR, null "
                                    + "GRANTEE,  null as PRIVILEGE, null as IS_GRANTABLE limit 0;");
        }
        return getTablePrivileges.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getTables(java.lang.String, java.lang.String,
     *     java.lang.String, java.lang.String[])
     */
    public synchronized ResultSet getTables(
            String c, String s, String tblNamePattern, String[] types) throws SQLException {
        checkOpen();
        tblNamePattern =
                (tblNamePattern == null || "".equals(tblNamePattern))
                        ? "%"
                        : escape(tblNamePattern);
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT").append("\n");
        sql.append("  NULL AS TABLE_CAT,").append("\n");
        sql.append("  NULL AS TABLE_SCHEM,").append("\n");
        sql.append("  NAME AS TABLE_NAME,").append("\n");
        sql.append("  TYPE AS TABLE_TYPE,").append("\n");
        sql.append("  NULL AS REMARKS,").append("\n");
        sql.append("  NULL AS TYPE_CAT,").append("\n");
        sql.append("  NULL AS TYPE_SCHEM,").append("\n");
        sql.append("  NULL AS TYPE_NAME,").append("\n");
        sql.append("  NULL AS SELF_REFERENCING_COL_NAME,").append("\n");
        sql.append("  NULL AS REF_GENERATION").append("\n");
        sql.append("FROM").append("\n");
        sql.append("  (").append("\n");
        sql.append("    SELECT\n");
        sql.append("      'sqlite_schema' AS NAME,\n");
        sql.append("      'SYSTEM TABLE' AS TYPE");
        sql.append("    UNION ALL").append("\n");
        sql.append("    SELECT").append("\n");
        sql.append("      NAME,").append("\n");
        sql.append("      UPPER(TYPE) AS TYPE").append("\n");
        sql.append("    FROM").append("\n");
        sql.append("      sqlite_schema").append("\n");
        sql.append("    WHERE").append("\n");
        sql.append("      NAME NOT LIKE 'sqlite\\_%' ESCAPE '\\'").append("\n");
        sql.append("      AND UPPER(TYPE) IN ('TABLE', 'VIEW')").append("\n");
        sql.append("    UNION ALL").append("\n");
        sql.append("    SELECT").append("\n");
        sql.append("      NAME,").append("\n");
        sql.append("      'GLOBAL TEMPORARY' AS TYPE").append("\n");
        sql.append("    FROM").append("\n");
        sql.append("      sqlite_temp_master").append("\n");
        sql.append("    UNION ALL").append("\n");
        sql.append("    SELECT").append("\n");
        sql.append("      NAME,").append("\n");
        sql.append("      'SYSTEM TABLE' AS TYPE").append("\n");
        sql.append("    FROM").append("\n");
        sql.append("      sqlite_schema").append("\n");
        sql.append("    WHERE").append("\n");
        sql.append("      NAME LIKE 'sqlite\\_%' ESCAPE '\\'").append("\n");
        sql.append("  )").append("\n");
        sql.append(" WHERE TABLE_NAME LIKE '");
        sql.append(tblNamePattern);
        sql.append("' ESCAPE '");
        sql.append(getSearchStringEscape());
        sql.append("'");
        if (types != null && types.length != 0) {
            sql.append(" AND TABLE_TYPE IN (");
            sql.append(
                    Arrays.stream(types)
                            .map((t) -> "'" + t.toUpperCase() + "'")
                            .collect(Collectors.joining(",")));
            sql.append(")");
        }
        sql.append(" ORDER BY TABLE_TYPE, TABLE_NAME;");
        return ((CoreStatement) conn.createStatement()).executeQuery(sql.toString(), true);
    }
    /** @see java.sql.DatabaseMetaData#getTableTypes() */
    public ResultSet getTableTypes() throws SQLException {
        checkOpen();
        String sql =
                "SELECT 'TABLE' AS TABLE_TYPE "
                        + "UNION "
                        + "SELECT 'VIEW' AS TABLE_TYPE "
                        + "UNION "
                        + "SELECT 'SYSTEM TABLE' AS TABLE_TYPE "
                        + "UNION "
                        + "SELECT 'GLOBAL TEMPORARY' AS TABLE_TYPE;";
        if (getTableTypes == null) {
            getTableTypes = conn.prepareStatement(sql);
        }
        getTableTypes.clearParameters();
        return getTableTypes.executeQuery();
    }
    /** @see java.sql.DatabaseMetaData#getTypeInfo() */
    public ResultSet getTypeInfo() throws SQLException {
        if (getTypeInfo == null) {
            String sql =
                    QueryUtils.valuesQuery(
                                    Arrays.asList(
                                            "TYPE_NAME",
                                            "DATA_TYPE",
                                            "PRECISION",
                                            "LITERAL_PREFIX",
                                            "LITERAL_SUFFIX",
                                            "CREATE_PARAMS",
                                            "NULLABLE",
                                            "CASE_SENSITIVE",
                                            "SEARCHABLE",
                                            "UNSIGNED_ATTRIBUTE",
                                            "FIXED_PREC_SCALE",
                                            "AUTO_INCREMENT",
                                            "LOCAL_TYPE_NAME",
                                            "MINIMUM_SCALE",
                                            "MAXIMUM_SCALE",
                                            "SQL_DATA_TYPE",
                                            "SQL_DATETIME_SUB",
                                            "NUM_PREC_RADIX"),
                                    Arrays.asList(
                                            Arrays.asList(
                                                    "BLOB",
                                                    Types.BLOB,
                                                    0,
                                                    null,
                                                    null,
                                                    null,
                                                    DatabaseMetaData.typeNullable,
                                                    0,
                                                    DatabaseMetaData.typeSearchable,
                                                    1,
                                                    0,
                                                    0,
                                                    null,
                                                    0,
                                                    0,
                                                    0,
                                                    0,
                                                    10),
                                            Arrays.asList(
                                                    "INTEGER",
                                                    Types.INTEGER,
                                                    0,
                                                    null,
                                                    null,
                                                    null,
                                                    DatabaseMetaData.typeNullable,
                                                    0,
                                                    DatabaseMetaData.typeSearchable,
                                                    0,
                                                    0,
                                                    1,
                                                    null,
                                                    0,
                                                    0,
                                                    0,
                                                    0,
                                                    10),
                                            Arrays.asList(
                                                    "NULL",
                                                    Types.NULL,
                                                    0,
                                                    null,
                                                    null,
                                                    null,
                                                    DatabaseMetaData.typeNullable,
                                                    0,
                                                    DatabaseMetaData.typeSearchable,
                                                    1,
                                                    0,
                                                    0,
                                                    null,
                                                    0,
                                                    0,
                                                    0,
                                                    0,
                                                    10),
                                            Arrays.asList(
                                                    "REAL",
                                                    Types.REAL,
                                                    0,
                                                    null,
                                                    null,
                                                    null,
                                                    DatabaseMetaData.typeNullable,
                                                    0,
                                                    DatabaseMetaData.typeSearchable,
                                                    0,
                                                    0,
                                                    0,
                                                    null,
                                                    0,
                                                    0,
                                                    0,
                                                    0,
                                                    10),
                                            Arrays.asList(
                                                    "TEXT",
                                                    Types.VARCHAR,
                                                    0,
                                                    null,
                                                    null,
                                                    null,
                                                    DatabaseMetaData.typeNullable,
                                                    1,
                                                    DatabaseMetaData.typeSearchable,
                                                    1,
                                                    0,
                                                    0,
                                                    null,
                                                    0,
                                                    0,
                                                    0,
                                                    0,
                                                    10)))
                            + " order by DATA_TYPE";
            getTypeInfo = conn.prepareStatement(sql);
        }
        getTypeInfo.clearParameters();
        return getTypeInfo.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getUDTs(java.lang.String, java.lang.String, java.lang.String,
     *     int[])
     */
    public ResultSet getUDTs(String c, String s, String t, int[] types) throws SQLException {
        if (getUDTs == null) {
            getUDTs =
                    conn.prepareStatement(
                            "select  null as TYPE_CAT, null as TYPE_SCHEM, "
                                    + "null as TYPE_NAME,  null as CLASS_NAME,  null as DATA_TYPE, null as REMARKS, "
                                    + "null as BASE_TYPE "
                                    + "limit 0;");
        }
        getUDTs.clearParameters();
        return getUDTs.executeQuery();
    }
    /**
     * @see java.sql.DatabaseMetaData#getVersionColumns(java.lang.String, java.lang.String,
     *     java.lang.String)
     */
    public ResultSet getVersionColumns(String c, String s, String t) throws SQLException {
        if (getVersionColumns == null) {
            getVersionColumns =
                    conn.prepareStatement(
                            "select null as SCOPE, null as COLUMN_NAME, "
                                    + "null as DATA_TYPE, null as TYPE_NAME, null as COLUMN_SIZE, "
                                    + "null as BUFFER_LENGTH, null as DECIMAL_DIGITS, null as PSEUDO_COLUMN limit 0;");
        }
        return getVersionColumns.executeQuery();
    }
    /**
     * @deprecated Not exactly sure what this function does, as it is not implementing any
     *     interface, and is not used anywhere in the code. Deprecated since 3.43.0.0.
     */
    @Deprecated
    public ResultSet getGeneratedKeys() throws SQLException {
        throw new SQLFeatureNotSupportedException("not implemented by SQLite JDBC driver");
    }
    /** Not implemented yet. */
    public Struct createStruct(String t, Object[] attr) throws SQLException {
        throw new SQLFeatureNotSupportedException("Not yet implemented by SQLite JDBC driver");
    }
    /** Not implemented yet. */
    public ResultSet getFunctionColumns(String a, String b, String c, String d)
            throws SQLException {
        throw new SQLFeatureNotSupportedException("Not yet implemented by SQLite JDBC driver");
    }
    // inner classes
    /** Pattern used to extract column order for an unnamed primary key. */
    protected static final Pattern PK_UNNAMED_PATTERN =
            Pattern.compile(
                    ".*PRIMARY\\s+KEY\\s*\\((.*?)\\).*", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
    /** Pattern used to extract a named primary key. */
    protected static final Pattern PK_NAMED_PATTERN =
            Pattern.compile(
                    ".*CONSTRAINT\\s*(.*?)\\s*PRIMARY\\s+KEY\\s*\\((.*?)\\).*",
                    Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
    /** Parses the sqlite_schema table for a table's primary key */
    class PrimaryKeyFinder {
        /** The table name. */
        String table;
        /** The primary key name. */
        String pkName = null;
        /** The column(s) for the primary key. */
        String[] pkColumns = null;
        /**
         * Constructor.
         *
         * @param table The table for which to get find a primary key.
         * @throws SQLException
         */
        public PrimaryKeyFinder(String table) throws SQLException {
            this.table = table;
            // specific handling for sqlite_schema and synonyms, so that
            // getExportedKeys/getPrimaryKeys return an empty ResultSet instead of throwing an
            // exception
            if ("sqlite_schema".equals(table) || "sqlite_master".equals(table)) return;
            if (table == null || table.trim().length() == 0) {
                throw new SQLException("Invalid table name: '" + this.table + "'");
            }
            try (Statement stat = conn.createStatement();
                    // read create SQL script for table
                    ResultSet rs =
                            stat.executeQuery(
                                    "select sql from sqlite_schema where"
                                            + " lower(name) = lower('"
                                            + escape(table)
                                            + "') and type in ('table', 'view')")) {
                if (!rs.next()) throw new SQLException("Table not found: '" + table + "'");
                Matcher matcher = PK_NAMED_PATTERN.matcher(rs.getString(1));
                if (matcher.find()) {
                    pkName = unquoteIdentifier(escape(matcher.group(1)));
                    pkColumns = matcher.group(2).split(",");
                } else {
                    matcher = PK_UNNAMED_PATTERN.matcher(rs.getString(1));
                    if (matcher.find()) {
                        pkColumns = matcher.group(1).split(",");
                    }
                }
                if (pkColumns == null) {
                    try (ResultSet rs2 =
                            stat.executeQuery("pragma table_info('" + escape(table) + "');")) {
                        while (rs2.next()) {
                            if (rs2.getBoolean(6)) pkColumns = new String[] {rs2.getString(2)};
                        }
                    }
                }
                if (pkColumns != null) {
                    for (int i = 0; i < pkColumns.length; i++) {
                        pkColumns[i] = unquoteIdentifier(pkColumns[i]);
                    }
                }
            }
        }
        /** @return The primary key name if any. */
        public String getName() {
            return pkName;
        }
        /** @return Array of primary key column(s) if any. */
        public String[] getColumns() {
            return pkColumns;
        }
    }
    class ImportedKeyFinder {
        /** Pattern used to extract a named primary key. */
        private final Pattern FK_NAMED_PATTERN =
                Pattern.compile(
                        "CONSTRAINT\\s*\"?([A-Za-z_][A-Za-z\\d_]*)?\"?\\s*FOREIGN\\s+KEY\\s*\\((.*?)\\)",
                        Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
        private final String fkTableName;
        private final List<ForeignKey> fkList = new ArrayList<>();
        public ImportedKeyFinder(String table) throws SQLException {
            if (table == null || table.trim().length() == 0) {
                throw new SQLException("Invalid table name: '" + table + "'");
            }
            this.fkTableName = table;
            List<String> fkNames = getForeignKeyNames(this.fkTableName);
            try (Statement stat = conn.createStatement();
                    ResultSet rs =
                            stat.executeQuery(
                                    "pragma foreign_key_list('"
                                            + escape(this.fkTableName.toLowerCase())
                                            + "')")) {
                int prevFkId = -1;
                int count = 0;
                ForeignKey fk = null;
                while (rs.next()) {
                    int fkId = rs.getInt(1);
                    String pkTableName = rs.getString(3);
                    String fkColName = rs.getString(4);
                    String pkColName = rs.getString(5);
                    String onUpdate = rs.getString(6);
                    String onDelete = rs.getString(7);
                    String match = rs.getString(8);
                    String fkName = null;
                    if (fkNames.size() > count) fkName = fkNames.get(count);
                    if (fkId != prevFkId) {
                        fk =
                                new ForeignKey(
                                        fkName,
                                        pkTableName,
                                        fkTableName,
                                        onUpdate,
                                        onDelete,
                                        match);
                        fkList.add(fk);
                        prevFkId = fkId;
                        count++;
                    }
                    if (fk != null) {
                        fk.addColumnMapping(fkColName, pkColName);
                    }
                }
            }
        }
        private List<String> getForeignKeyNames(String tbl) throws SQLException {
            List<String> fkNames = new ArrayList<>();
            if (tbl == null) {
                return fkNames;
            }
            try (Statement stat2 = conn.createStatement();
                    ResultSet rs =
                            stat2.executeQuery(
                                    "select sql from sqlite_schema where"
                                            + " lower(name) = lower('"
                                            + escape(tbl)
                                            + "')")) {
                if (rs.next()) {
                    Matcher matcher = FK_NAMED_PATTERN.matcher(rs.getString(1));
                    while (matcher.find()) {
                        fkNames.add(matcher.group(1));
                    }
                }
            }
            Collections.reverse(fkNames);
            return fkNames;
        }
        public String getFkTableName() {
            return fkTableName;
        }
        public List<ForeignKey> getFkList() {
            return fkList;
        }
        class ForeignKey {
            private final String fkName;
            private final String pkTableName;
            private final String fkTableName;
            private final List<String> fkColNames = new ArrayList<>();
            private final List<String> pkColNames = new ArrayList<>();
            private final String onUpdate;
            private final String onDelete;
            private final String match;
            ForeignKey(
                    String fkName,
                    String pkTableName,
                    String fkTableName,
                    String onUpdate,
                    String onDelete,
                    String match) {
                this.fkName = fkName;
                this.pkTableName = pkTableName;
                this.fkTableName = fkTableName;
                this.onUpdate = onUpdate;
                this.onDelete = onDelete;
                this.match = match;
            }
            public String getFkName() {
                return fkName;
            }
            void addColumnMapping(String fkColName, String pkColName) {
                fkColNames.add(fkColName);
                pkColNames.add(pkColName);
            }
            public String[] getColumnMapping(int colSeq) {
                return new String[] {fkColNames.get(colSeq), pkColNames.get(colSeq)};
            }
            public int getColumnMappingCount() {
                return fkColNames.size();
            }
            public String getPkTableName() {
                return pkTableName;
            }
            public String getFkTableName() {
                return fkTableName;
            }
            public String getOnUpdate() {
                return onUpdate;
            }
            public String getOnDelete() {
                return onDelete;
            }
            public String getMatch() {
                return match;
            }
            @Override
            public String toString() {
                return "ForeignKey [fkName="
                        + fkName
                        + ", pkTableName="
                        + pkTableName
                        + ", fkTableName="
                        + fkTableName
                        + ", pkColNames="
                        + pkColNames
                        + ", fkColNames="
                        + fkColNames
                        + "]";
            }
        }
    }
    /** @see java.lang.Object#finalize() */
    protected void finalize() throws Throwable {
        close();
    }
    /**
     * Follow rules in <a href="https://www.sqlite.org/lang_keywords.html">SQLite Keywords</a>
     *
     * @param name Identifier name
     * @return Unquoted identifier
     */
    private String unquoteIdentifier(String name) {
        if (name == null) return name;
        name = name.trim();
        if (name.length() > 2
                && ((name.startsWith("`") && name.endsWith("`"))
                        || (name.startsWith("\"") && name.endsWith("\""))
                        || (name.startsWith("[") && name.endsWith("]")))) {
            // unquote to be consistent with column names returned by getColumns()
            name = name.substring(1, name.length() - 1);
        }
        return name;
    }
    /**
     * Class-wrapper around the logger object to avoid build-time initialization of the logging
     * framework in native-image
     */
    private static class LogHolder {
        private static final Logger logger = LoggerFactory.getLogger(JDBC3DatabaseMetaData.class);
    }
}