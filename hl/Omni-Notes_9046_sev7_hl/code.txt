/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.async.upgrade;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_FILES;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO;
import static java.lang.Integer.parseInt;
import static java.util.stream.Collectors.toList;
import android.content.ContentValues;
import android.net.Uri;
import android.text.TextUtils;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.StorageHelper;
import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.apache.commons.io.FilenameUtils;
/**
 * Processor used to perform asynchronous tasks on database upgrade. It's not intended to be used to
 * perform actions strictly related to DB (for this
 * {@link it.feio.android.omninotes.db.DbHelper#onUpgrade(android.database.sqlite.SQLiteDatabase,
 * int, int)} DbHelper.onUpgrade()} is used
 */
public class UpgradeProcessor {
  private static final String METHODS_PREFIX = "onUpgradeTo";
  private static UpgradeProcessor instance;
  private UpgradeProcessor() {
  }
  private static UpgradeProcessor getInstance() {
    if (instance == null) {
      instance = new UpgradeProcessor();
    }
    return instance;
  }
  public static void process(int dbOldVersion, int dbNewVersion)
      throws InvocationTargetException, IllegalAccessException {
    try {
      var methodsToLaunch = getInstance().getMethodsToLaunch(dbOldVersion, dbNewVersion);
      for (Method methodToLaunch : methodsToLaunch) {
        LogDelegate.d("Running upgrade processing method: " + methodToLaunch.getName());
        methodToLaunch.invoke(getInstance());
      }
    } catch (SecurityException | IllegalAccessException | InvocationTargetException e) {
      LogDelegate.e("Explosion processing upgrade!", e);
      throw e;
    }
  }
  private List<Method> getMethodsToLaunch(int dbOldVersion, int dbNewVersion) {
    return Arrays.stream(getInstance().getClass().getDeclaredMethods())
        .filter(method -> method.getName().matches(METHODS_PREFIX + "\\d+"))
        .filter(method -> {
          int methodVersionPostfix = parseInt(method.getName().replace(METHODS_PREFIX, ""));
          return dbOldVersion <= methodVersionPostfix && methodVersionPostfix <= dbNewVersion;
        }).collect(toList());
  }
  /**
   * Adjustment of all the old attachments without mimetype field set into DB
   */
  private void onUpgradeTo476() {
    final DbHelper dbHelper = DbHelper.getInstance();
    for (Attachment attachment : dbHelper.getAllAttachments()) {
      if (attachment.getMime_type() == null) {
        String mimeType = StorageHelper.getMimeType(attachment.getUri().toString());
        if (!TextUtils.isEmpty(mimeType)) {
          String type = mimeType.replaceFirst("/.*", "");
          switch (type) {
            case "image":
              attachment.setMime_type(MIME_TYPE_IMAGE);
              break;
            case "video":
              attachment.setMime_type(MIME_TYPE_VIDEO);
              break;
            case "audio":
              attachment.setMime_type(MIME_TYPE_AUDIO);
              break;
            default:
              attachment.setMime_type(MIME_TYPE_FILES);
              break;
          }
          dbHelper.updateAttachment(attachment);
        } else {
          attachment.setMime_type(MIME_TYPE_FILES);
        }
      }
    }
  }
  /**
   * Upgrades all the old audio attachments to the new format 3gpp to avoid mixing with videos
   */
  private void onUpgradeTo480() {
    final DbHelper dbHelper = DbHelper.getInstance();
    for (Attachment attachment : dbHelper.getAllAttachments()) {
      if ("audio/3gp".equals(attachment.getMime_type()) || "audio/3gpp"
          .equals(attachment.getMime_type
              ())) {
        File from = new File(attachment.getUriPath());
        FilenameUtils.getExtension(from.getName());
        File to = new File(from.getParent(), from.getName().replace(FilenameUtils.getExtension(from
            .getName()), MIME_TYPE_AUDIO_EXT));
        boolean successRenaming = from.renameTo(to);
        if (successRenaming) {
          attachment.setUri(Uri.fromFile(to));
          attachment.setMime_type(MIME_TYPE_AUDIO);
          dbHelper.updateAttachment(attachment);
        } else {
          LogDelegate.e("onUpgradeTo480 - Error renaming attachment: " + attachment.getName());
        }
      }
    }
  }
  /**
   * Reschedule reminders after upgrade
   */
  private void onUpgradeTo482() {
    for (Note note : DbHelper.getInstance().getNotesWithReminderNotFired()) {
      ReminderHelper.addReminder(OmniNotes.getAppContext(), note);
    }
  }
  /**
   * Ensures that no duplicates will be found during the creation-to-ID transition
   */
  private void onUpgradeTo501() {
    List<Long> creations = new ArrayList<>();
    for (Note note : DbHelper.getInstance().getAllNotes(false)) {
      if (creations.contains(note.getCreation())) {
        ContentValues values = new ContentValues();
        values.put(DbHelper.KEY_CREATION, note.getCreation() + (long) (Math.random() * 999));
        DbHelper.getInstance().getDatabase()
            .update(DbHelper.TABLE_NOTES, values, DbHelper.KEY_TITLE +
                    " = ? AND " + DbHelper.KEY_CREATION + " = ? AND " + DbHelper.KEY_CONTENT + " = ?",
                new String[]{note
                    .getTitle(), String.valueOf(note.getCreation()), note.getContent()});
      }
      creations.add(note.getCreation());
    }
  }
  /**
   * Attachment uri replacement
   */
  private void onUpgradeTo625() {
    var attachmentsDir = StorageHelper.getAttachmentDir();
    var dbHelper = DbHelper.getInstance();
    dbHelper.getAllAttachments().stream()
        .filter(attachment -> "content".equals(attachment.getUri().getScheme()))
        .forEach(attachment -> {
          var fileName = attachment.getUri().getPathSegments()
              .get(attachment.getUri().getPathSegments().size() - 1);
          var file = new File(attachmentsDir + "/" + fileName);
          if (file.exists()) {
            attachment.setUri(Uri.fromFile(file));
            dbHelper.updateAttachment(attachment);
          }
        });
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.utils;
import static android.app.PendingIntent.FLAG_CANCEL_CURRENT;
import static android.app.PendingIntent.FLAG_NO_CREATE;
import static android.widget.Toast.LENGTH_LONG;
import static it.feio.android.omninotes.helpers.IntentHelper.immutablePendingIntentFlag;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.os.Handler;
import android.provider.Settings;
import android.text.TextUtils;
import android.widget.Toast;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.helpers.date.DateHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.receiver.AlarmReceiver;
import it.feio.android.omninotes.utils.date.DateUtils;
import java.util.Calendar;
public class ReminderHelper {
  private ReminderHelper() {
    // hides public constructor
  }
  public static void addReminder(Context context, Note note) {
    if (note.getAlarm() != null) {
      addReminder(context, note, Long.parseLong(note.getAlarm()));
    }
  }
  public static void addReminder(Context context, Note note, long reminder) {
    if (DateUtils.isFuture(reminder)) {
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { // Android 12 (API 31) and above
        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        if (!alarmManager.canScheduleExactAlarms()) {
          Intent intent = new Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM);
          context.startActivity(intent);
          return;
        }
      }
      Intent intent = new Intent(context, AlarmReceiver.class);
      intent.putExtra(INTENT_NOTE, ParcelableUtil.marshall(note));
      PendingIntent sender = PendingIntent.getBroadcast(
          context,
          getRequestCode(note),
          intent,
          immutablePendingIntentFlag(PendingIntent.FLAG_CANCEL_CURRENT)
      );
      AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
      am.setExact(AlarmManager.RTC_WAKEUP, reminder, sender);
    }
  }
  /**
   * Checks if exists any reminder for given note
   */
  public static boolean checkReminder(Context context, Note note) {
    return
        PendingIntent.getBroadcast(context, getRequestCode(note), new Intent(context, AlarmReceiver
            .class), immutablePendingIntentFlag(FLAG_NO_CREATE)) != null;
  }
  static int getRequestCode(Note note) {
    long longCode = note.getCreation() != null ? note.getCreation()
        : Calendar.getInstance().getTimeInMillis() / 1000L;
    return (int) longCode;
  }
  public static void removeReminder(Context context, Note note) {
    if (!TextUtils.isEmpty(note.getAlarm())) {
      AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
      Intent intent = new Intent(context, AlarmReceiver.class);
      PendingIntent p = PendingIntent.getBroadcast(context, getRequestCode(note), intent,
          immutablePendingIntentFlag(0));
      am.cancel(p);
      p.cancel();
    }
  }
  public static void showReminderMessage(String reminderString) {
    if (reminderString != null) {
      var context = OmniNotes.getAppContext();
      long reminder = Long.parseLong(reminderString);
      if (reminder > Calendar.getInstance().getTimeInMillis()) {
        new Handler(OmniNotes.getAppContext().getMainLooper()).post(() ->
            Toast.makeText(context,
                context.getString(R.string.alarm_set_on) + " " + DateHelper
                    .getDateTimeShort(context, reminder), LENGTH_LONG).show());
        if (!new NotificationsHelper(context).checkNotificationsEnabled(context)) {
          Toast.makeText(context, context.getString(R.string.denied_notifications_permission), LENGTH_LONG).show();
        }
      }
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.models;
import android.os.Parcel;
import android.os.Parcelable;
import it.feio.android.omninotes.commons.models.BaseAttachment;
import it.feio.android.omninotes.commons.models.BaseCategory;
import it.feio.android.omninotes.commons.models.BaseNote;
import java.util.ArrayList;
import java.util.List;
public class Note extends BaseNote implements Parcelable {
  /*
   * Parcelable interface must also have a static field called CREATOR, which is an object implementing the
   * Parcelable.Creator interface. Used to un-marshal or de-serialize object from Parcel.
   */
  public static final Parcelable.Creator<Note> CREATOR = new Parcelable.Creator<>() {
    public Note createFromParcel(Parcel in) {
      return new Note(in);
    }
    public Note[] newArray(int size) {
      return new Note[size];
    }
  };
  // Not saved in DB
  private boolean passwordChecked = false;
  public Note() {
    super();
  }
  public Note(Long creation, Long lastModification, String title, String content, Integer archived,
      Integer trashed, String alarm, String recurrenceRule, Integer reminderFired, String latitude,
      String longitude,
      Category
          category, Integer locked, Integer checklist) {
    super(creation, lastModification, title, content, archived, trashed, alarm, reminderFired,
        recurrenceRule,
        latitude,
        longitude, category, locked, checklist);
  }
  public Note(Note note) {
    super(note);
    setPasswordChecked(note.isPasswordChecked());
  }
  private Note(Parcel in) {
    setCreation(in.readString());
    setLastModification(in.readString());
    setTitle(in.readString());
    setContent(in.readString());
    setArchived(in.readInt());
    setTrashed(in.readInt());
    setAlarm(in.readString());
    setReminderFired(in.readInt());
    setRecurrenceRule(in.readString());
    setLatitude(in.readString());
    setLongitude(in.readString());
    setAddress(in.readString());
    super.setCategory(in.readParcelable(Category.class.getClassLoader()));
    setLocked(in.readInt());
    setChecklist(in.readInt());
    in.readList(getAttachmentsList(), Attachment.class.getClassLoader());
  }
  public List<Attachment> getAttachmentsList() {
//		List<Attachment> list = new ArrayList<>();
//		for (it.feio.android.omninotes.commons.models.Attachment attachment : super.getAttachmentsList()) {
//			if (attachment.getClass().equals(Attachment.class)) {
//				list.add((Attachment) attachment);
//			} else {
//				list.add(new Attachment(attachment));
//			}
//		}
//		return list;
    // FIXME This fixes https://github.com/federicoiosue/Omni-Notes/issues/199 but could introduce other issues
    return (List<Attachment>) super.getAttachmentsList();
  }
  public void setAttachmentsList(ArrayList<Attachment> attachmentsList) {
    super.setAttachmentsList(attachmentsList);
  }
  public void addAttachment(Attachment attachment) {
    List<Attachment> attachmentsList = ((List<Attachment>) super.getAttachmentsList());
    attachmentsList.add(attachment);
    setAttachmentsList(attachmentsList);
  }
  public void removeAttachment(Attachment attachment) {
    List<Attachment> attachmentsList = ((List<Attachment>) super.getAttachmentsList());
    attachmentsList.remove(attachment);
    setAttachmentsList(attachmentsList);
  }
  public List<Attachment> getAttachmentsListOld() {
    return (List<Attachment>) super.getAttachmentsListOld();
  }
  public void setAttachmentsListOld(ArrayList<Attachment> attachmentsListOld) {
    super.setAttachmentsListOld(attachmentsListOld);
  }
  public boolean isPasswordChecked() {
    return passwordChecked;
  }
  public void setPasswordChecked(boolean passwordChecked) {
    this.passwordChecked = passwordChecked;
  }
  @Override
  public Category getCategory() {
    try {
      return (Category) super.getCategory();
    } catch (ClassCastException e) {
      return new Category(super.getCategory());
    }
  }
  public void setCategory(Category category) {
    if (category != null && category.getClass().equals(BaseCategory.class)) {
      setCategory(new Category(category));
    }
    super.setCategory(category);
  }
  @Override
  public void buildFromJson(String jsonNote) {
    super.buildFromJson(jsonNote);
    List<Attachment> attachments = new ArrayList<>();
    for (BaseAttachment attachment : getAttachmentsList()) {
      attachments.add(new Attachment(attachment));
    }
    setAttachmentsList(attachments);
  }
  @Override
  public int describeContents() {
    return 0;
  }
  @Override
  public void writeToParcel(Parcel parcel, int flags) {
    parcel.writeString(String.valueOf(getCreation()));
    parcel.writeString(String.valueOf(getLastModification()));
    parcel.writeString(getTitle());
    parcel.writeString(getContent());
    parcel.writeInt(isArchived() ? 1 : 0);
    parcel.writeInt(isTrashed() ? 1 : 0);
    parcel.writeString(getAlarm());
    parcel.writeInt(isReminderFired() ? 1 : 0);
    parcel.writeString(getRecurrenceRule());
    parcel.writeString(String.valueOf(getLatitude()));
    parcel.writeString(String.valueOf(getLongitude()));
    parcel.writeString(getAddress());
    parcel.writeParcelable(getCategory(), 0);
    parcel.writeInt(isLocked() ? 1 : 0);
    parcel.writeInt(isChecklist() ? 1 : 0);
    parcel.writeList(getAttachmentsList());
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static it.feio.android.omninotes.helpers.BuildHelper.isDebugBuild;
import static it.feio.android.omninotes.utils.Constants.PACKAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_LANG;
import android.content.Context;
import android.content.res.Configuration;
import android.os.StrictMode;
import android.text.TextUtils;
import androidx.multidex.MultiDexApplication;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.helpers.LanguageHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import org.acra.ACRA;
import org.acra.config.CoreConfigurationBuilder;
import org.acra.config.HttpSenderConfigurationBuilder;
import org.acra.config.ToastConfigurationBuilder;
import org.acra.sender.HttpSender.Method;
public class OmniNotes extends MultiDexApplication {
  private static Context mContext;
  public static Context getAppContext() {
    return OmniNotes.mContext;
  }
  @Override
  protected void attachBaseContext(Context base) {
    super.attachBaseContext(base);
    initAcra();
  }
  @Override
  public void onCreate() {
    super.onCreate();
    mContext = getApplicationContext();
    initSharedPreferences();
    enableStrictMode();
    new NotificationsHelper(this).initNotificationChannels();
  }
  private void initAcra() {
    if (!TextUtils.isEmpty(BuildConfig.CRASH_REPORTING_URL)) {
      HttpSenderConfigurationBuilder httpBuilder = new HttpSenderConfigurationBuilder()
          .withUri(BuildConfig.CRASH_REPORTING_URL)
          .withBasicAuthLogin(BuildConfig.CRASH_REPORTING_LOGIN)
          .withBasicAuthPassword(BuildConfig.CRASH_REPORTING_PASSWORD)
          .withHttpMethod(Method.POST)
          .withEnabled(true);
      ToastConfigurationBuilder toastBuilder = new ToastConfigurationBuilder()
          .withText(this.getString(R.string.crash_toast))
          .withEnabled(true);
      CoreConfigurationBuilder builder = new CoreConfigurationBuilder()
          .withPluginConfigurations(httpBuilder.build(), toastBuilder.build());
      ACRA.init(this, builder);
      ACRA.getErrorReporter().putCustomData("TRACEPOT_DEVELOP_MODE", isDebugBuild() ? "1" : "0");
    }
  }
  private void initSharedPreferences() {
    new Prefs.Builder()
        .setContext(this)
        .setMode(MODE_PRIVATE)
        .setPrefsName(PACKAGE)
        .setUseDefaultSharedPreference(true)
        .build();
  }
  private void enableStrictMode() {
    if (isDebugBuild()) {
      StrictMode.enableDefaults();
    }
  }
  @Override
  public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    String language = Prefs.getString(PREF_LANG, "");
    LanguageHelper.updateLanguage(this, language);
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.helpers.date;
import static it.feio.android.omninotes.utils.ConstantsBase.DATE_FORMAT_SORTABLE;
import android.content.Context;
import android.text.format.DateUtils;
import it.feio.android.omninotes.OmniNotes;
import java.text.SimpleDateFormat;
import java.util.Calendar;
/**
 * Helper per la generazione di date nel formato specificato nelle costanti
 */
public class DateHelper {
  private DateHelper() {
    // hides public constructor
  }
  public static String getSortableDate() {
    SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT_SORTABLE);
    return sdf.format(Calendar.getInstance().getTime());
  }
  /**
   * Build a formatted date string starting from values obtained by a DatePicker
   */
  public static String onDateSet(int year, int month, int day, String format) {
    SimpleDateFormat sdf = new SimpleDateFormat(format);
    Calendar cal = Calendar.getInstance();
    cal.set(Calendar.YEAR, year);
    cal.set(Calendar.MONTH, month);
    cal.set(Calendar.DAY_OF_MONTH, day);
    return sdf.format(cal.getTime());
  }
  /**
   * Build a formatted time string starting from values obtained by a TimePicker
   */
  public static String onTimeSet(int hour, int minute, String format) {
    SimpleDateFormat sdf = new SimpleDateFormat(format);
    Calendar cal = Calendar.getInstance();
    cal.set(Calendar.HOUR_OF_DAY, hour);
    cal.set(Calendar.MINUTE, minute);
    return sdf.format(cal.getTime());
  }
  /**
   *
   */
  public static String getDateTimeShort(Context mContext, Long date) {
    int flags = DateUtils.FORMAT_ABBREV_WEEKDAY | DateUtils.FORMAT_SHOW_WEEKDAY
        | DateUtils.FORMAT_ABBREV_MONTH | DateUtils.FORMAT_SHOW_DATE;
    return (date == null) ? "" : DateUtils.formatDateTime(mContext, date, flags)
        + " " + DateUtils.formatDateTime(mContext, date, DateUtils.FORMAT_SHOW_TIME);
  }
  /**
   *
   */
  public static String getTimeShort(Context mContext, Long time) {
    if (time == null) {
      return "";
    }
    Calendar c = Calendar.getInstance();
    c.setTimeInMillis(time);
    return DateUtils.formatDateTime(mContext, time, DateUtils.FORMAT_SHOW_TIME);
  }
  /**
   *
   */
  public static String getTimeShort(Context mContext, int hourOfDay, int minute) {
    Calendar c = Calendar.getInstance();
    c.set(Calendar.HOUR_OF_DAY, hourOfDay);
    c.set(Calendar.MINUTE, minute);
    return DateUtils.formatDateTime(mContext, c.getTimeInMillis(), DateUtils.FORMAT_SHOW_TIME);
  }
  /**
   * Formats a short time period (minutes)
   */
  public static String formatShortTime(Context mContext, long time) {
    String m = String.valueOf(time / 1000 / 60);
    String s = String.format("%02d", (time / 1000) % 60);
    return m + ":" + s;
  }
  public static String getFormattedDate(Long timestamp, boolean prettified) {
    if (prettified) {
      return it.feio.android.omninotes.utils.date.DateUtils.prettyTime(timestamp);
    } else {
      return DateHelper.getDateTimeShort(OmniNotes.getAppContext(), timestamp);
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.utils.date;
import static it.feio.android.omninotes.utils.ConstantsBase.DATE_FORMAT_SORTABLE_OLD;
import android.content.Context;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.helpers.LogDelegate;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import org.apache.commons.lang3.StringUtils;
import org.ocpsoft.prettytime.PrettyTime;
/**
 * Helper per la generazione di date nel formato specificato nelle costanti
 */
public class DateUtils {
  private DateUtils() {
    throw new IllegalStateException("Utility class");
  }
  public static String getString(long date, String format) {
    Date d = new Date(date);
    return getString(d, format);
  }
  public static String getString(Date d, String format) {
    SimpleDateFormat sdf = new SimpleDateFormat(format);
    return sdf.format(d);
  }
  public static Calendar getDateFromString(String str, String format) {
    Calendar cal = Calendar.getInstance();
    SimpleDateFormat sdf = new SimpleDateFormat(format);
    try {
      cal.setTime(sdf.parse(str));
    } catch (ParseException e) {
      LogDelegate.e("Malformed datetime string" + e.getMessage());
    } catch (NullPointerException e) {
      LogDelegate.e("Date or time not set");
    }
    return cal;
  }
  public static Calendar getLongFromDateTime(String date, String dateFormat, String time,
      String timeFormat) {
    Calendar cal = Calendar.getInstance();
    Calendar cDate = Calendar.getInstance();
    Calendar cTime = Calendar.getInstance();
    SimpleDateFormat sdfDate = new SimpleDateFormat(dateFormat);
    SimpleDateFormat sdfTime = new SimpleDateFormat(timeFormat);
    try {
      cDate.setTime(sdfDate.parse(date));
      cTime.setTime(sdfTime.parse(time));
    } catch (ParseException e) {
      LogDelegate.e("Date or time parsing error: " + e.getMessage());
    }
    cal.set(Calendar.YEAR, cDate.get(Calendar.YEAR));
    cal.set(Calendar.MONTH, cDate.get(Calendar.MONTH));
    cal.set(Calendar.DAY_OF_MONTH, cDate.get(Calendar.DAY_OF_MONTH));
    cal.set(Calendar.HOUR_OF_DAY, cTime.get(Calendar.HOUR_OF_DAY));
    cal.set(Calendar.MINUTE, cTime.get(Calendar.MINUTE));
    cal.set(Calendar.SECOND, 0);
    return cal;
  }
  public static Calendar getCalendar(Long dateTime) {
    Calendar cal = Calendar.getInstance();
    if (dateTime != null && dateTime != 0) {
      cal.setTimeInMillis(dateTime);
    }
    return cal;
  }
  public static String getLocalizedDateTime(Context mContext,
      String dateString, String format) {
    String res = null;
    SimpleDateFormat sdf = new SimpleDateFormat(format);
    Date date = null;
    try {
      date = sdf.parse(dateString);
    } catch (ParseException e) {
      sdf = new SimpleDateFormat(DATE_FORMAT_SORTABLE_OLD);
      try {
        date = sdf.parse(dateString);
      } catch (ParseException e1) {
        LogDelegate.e("String is not formattable into date");
      }
    }
    if (date != null) {
      String dateFormatted = android.text.format.DateUtils
          .formatDateTime(mContext, date.getTime(), android
              .text.format.DateUtils.FORMAT_ABBREV_MONTH);
      String timeFormatted = android.text.format.DateUtils
          .formatDateTime(mContext, date.getTime(), android
              .text.format.DateUtils.FORMAT_SHOW_TIME);
      res = dateFormatted + " " + timeFormatted;
    }
    return res;
  }
  public static boolean is24HourMode(Context mContext) {
    Calendar c = Calendar.getInstance();
    String timeFormatted = android.text.format.DateUtils
        .formatDateTime(mContext, c.getTimeInMillis(), android
            .text.format.DateUtils.FORMAT_SHOW_TIME);
    return !timeFormatted.toLowerCase().contains("am") && !timeFormatted.toLowerCase()
        .contains("pm");
  }
  public static boolean isSameDay(long date1, long date2) {
    Calendar cal1 = Calendar.getInstance();
    Calendar cal2 = Calendar.getInstance();
    cal1.setTimeInMillis(date1);
    cal2.setTimeInMillis(date2);
    return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR)
        && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get
        (Calendar.DAY_OF_YEAR);
  }
  public static long getNextMinute() {
    return Calendar.getInstance().getTimeInMillis() + 1000 * 60;
  }
  /**
   * Returns actually set reminder if that is on the future, next-minute-reminder otherwise
   */
  public static long getPresetReminder(Long currentReminder) {
    long now = Calendar.getInstance().getTimeInMillis();
    return currentReminder != null && currentReminder > now ? currentReminder : getNextMinute();
  }
  public static Long getPresetReminder(String alarm) {
    long alarmChecked = alarm == null ? 0 : Long.parseLong(alarm);
    return getPresetReminder(alarmChecked);
  }
  /**
   * Checks if a epoch-date timestamp is in the future
   */
  public static boolean isFuture(String timestamp) {
    return !StringUtils.isEmpty(timestamp) && isFuture(Long.parseLong(timestamp));
  }
  /**
   * Checks if a epoch-date timestamp is in the future
   */
  public static boolean isFuture(Long timestamp) {
    return timestamp != null && timestamp > Calendar.getInstance().getTimeInMillis();
  }
  public static String prettyTime(String timeInMillisec) {
    if (timeInMillisec == null) {
      return "";
    }
    return prettyTime(Long.parseLong(timeInMillisec),
        OmniNotes.getAppContext().getResources().getConfiguration().locale);
  }
  public static String prettyTime(Long timeInMillisec) {
    return prettyTime(timeInMillisec,
        OmniNotes.getAppContext().getResources().getConfiguration().locale);
  }
  static String prettyTime(Long timeInMillisec, Locale locale) {
    if (timeInMillisec == null) {
      return "";
    }
    Date d = new Date(timeInMillisec);
    PrettyTime pt = new PrettyTime();
    if (locale != null) {
      pt.setLocale(locale);
    }
    return pt.format(d);
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.helpers.notifications;
import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
import static it.feio.android.omninotes.helpers.IntentHelper.immutablePendingIntentFlag;
import android.Manifest.permission;
import android.annotation.TargetApi;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.media.AudioAttributes;
import android.media.RingtoneManager;
import android.net.Uri;
import android.os.Build;
import android.os.Build.VERSION_CODES;
import android.provider.Settings;
import androidx.activity.ComponentActivity;
import androidx.activity.result.contract.ActivityResultContracts.RequestPermission;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationCompat.Builder;
import androidx.core.content.ContextCompat;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.async.bus.NotificationsGrantedEvent;
import it.feio.android.omninotes.helpers.BuildHelper;
import lombok.NonNull;
public class NotificationsHelper {
  private final Context mContext;
  private Builder mBuilder;
  private NotificationManager mNotificationManager;
  public NotificationsHelper(Context mContext) {
    this.mContext = mContext.getApplicationContext();
    if (mNotificationManager == null) {
      mNotificationManager = (NotificationManager) mContext
          .getSystemService(Context.NOTIFICATION_SERVICE);
    }
  }
  /**
   * Creates the NotificationChannel, but only on API 26+ because the NotificationChannel class is
   * new and not in the support library
   */
  @TargetApi(VERSION_CODES.O)
  public void initNotificationChannels() {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.O)) {
      String soundFromPrefs = Prefs.getString("settings_notification_ringtone", null);
      Uri sound = soundFromPrefs != null ? Uri.parse(soundFromPrefs)
          : RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);
      NotificationChannels.channels.forEach(
          (notificationChannelNames, notificationChannel) -> {
            NotificationChannel channel = new NotificationChannel(notificationChannel.id,
                notificationChannel
                    .name, notificationChannel.importance);
            channel.setDescription(notificationChannel.description);
            AudioAttributes audioAttributes = new AudioAttributes.Builder()
                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
                .setUsage(AudioAttributes.USAGE_NOTIFICATION)
                .build();
            channel.setSound(sound, audioAttributes);
            mNotificationManager.createNotificationChannel(channel);
          });
    }
  }
  @TargetApi(Build.VERSION_CODES.O)
  public void updateNotificationChannelsSound() {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.O)) {
      Intent intent = new Intent(Settings.ACTION_APP_NOTIFICATION_SETTINGS);
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      intent.putExtra(Settings.EXTRA_APP_PACKAGE, mContext.getPackageName());
      mContext.startActivity(intent);
    }
  }
  public NotificationsHelper createStandardNotification(
      @NonNull NotificationChannels.NotificationChannelNames channelName, int
      smallIcon, String title, PendingIntent notifyIntent) {
    return createNotification(channelName, smallIcon, title, notifyIntent, false);
  }
  public NotificationsHelper createOngoingNotification(
      @NonNull NotificationChannels.NotificationChannelNames channelName, int
      smallIcon, String title, PendingIntent notifyIntent) {
    return createNotification(channelName, smallIcon, title, notifyIntent, true);
  }
  public NotificationsHelper createNotification(
      @NonNull NotificationChannels.NotificationChannelNames channelName, int
      smallIcon, String title, PendingIntent notifyIntent, boolean isOngoing) {
    mBuilder = new NotificationCompat.Builder(mContext,
        NotificationChannels.channels.get(channelName).id)
        .setSmallIcon(smallIcon)
        .setContentTitle(title)
        .setAutoCancel(!isOngoing)
        .setOngoing(isOngoing)
        .setColor(mContext.getResources().getColor(R.color.colorAccent))
        .setContentIntent(notifyIntent);
    setLargeIcon(R.drawable.logo_notification_lollipop);
    return this;
  }
  public Builder getBuilder() {
    return mBuilder;
  }
  public NotificationsHelper setLargeIcon(Bitmap largeIconBitmap) {
    mBuilder.setLargeIcon(largeIconBitmap);
    return this;
  }
  public NotificationsHelper setLargeIcon(int largeIconResource) {
    Bitmap largeIconBitmap = BitmapFactory
        .decodeResource(mContext.getResources(), largeIconResource);
    return setLargeIcon(largeIconBitmap);
  }
  public NotificationsHelper setRingtone(String ringtone) {
    if (ringtone != null && BuildHelper.isBelow(VERSION_CODES.O)) {
      mBuilder.setSound(Uri.parse(ringtone));
    }
    return this;
  }
  public NotificationsHelper setVibration() {
    return setVibration(null);
  }
  public NotificationsHelper setVibration(long[] pattern) {
    if (pattern == null || pattern.length == 0) {
      pattern = new long[]{500, 500};
    }
    mBuilder.setVibrate(pattern);
    return this;
  }
  public NotificationsHelper setLedActive() {
    mBuilder.setLights(Color.BLUE, 1000, 1000);
    return this;
  }
  public NotificationsHelper setIcon(int icon) {
    mBuilder.setSmallIcon(icon);
    return this;
  }
  public NotificationsHelper setMessage(String message) {
    mBuilder.setContentText(message);
    return this;
  }
  public NotificationsHelper setIndeterminate() {
    mBuilder.setProgress(0, 0, true);
    return this;
  }
  public NotificationsHelper setOngoing() {
    mBuilder.setOngoing(true);
    return this;
  }
  public NotificationsHelper show() {
    show(0);
    return this;
  }
  public NotificationsHelper show(long id) {
    var mNotification = mBuilder.build();
    if (mNotification.contentIntent == null) {
      var emptyExplicitIntent = new Intent(mContext, MainActivity.class);
      var pendingIntent = PendingIntent.getActivity(mContext, 0, emptyExplicitIntent,
          immutablePendingIntentFlag(FLAG_UPDATE_CURRENT));
      mBuilder.setContentIntent(pendingIntent);
    }
    mNotificationManager.notify(String.valueOf(id), 0, mBuilder.build());
    return this;
  }
  public NotificationsHelper start(NotificationChannels.NotificationChannelNames channelName, int
      smallIcon, String title) {
    createStandardNotification(channelName, smallIcon, title, null).setIndeterminate().setOngoing();
    mNotificationManager.notify(0, mBuilder.setOnlyAlertOnce(true).build());
    return this;
  }
  public void updateMessage(String message) {
    updateMessage(0, message);
  }
  public void updateMessage(int id, String message) {
    mNotificationManager.notify(id, mBuilder.setContentText(message).build());
  }
  public void finish(String title, String message) {
    finish(0, title, message);
  }
  public void finish(int id, String title, String message) {
    mBuilder.setContentTitle(title).setContentText(message)
        .setProgress(0, 0, false).setOngoing(false);
    mNotificationManager.notify(id, mBuilder.build());
  }
  public void cancel() {
    mNotificationManager.cancel(0);
  }
  public void cancel(int id) {
    mNotificationManager.cancel(id);
  }
  public boolean checkNotificationsEnabled(Context context) {
    return BuildHelper.isBelow(VERSION_CODES.TIRAMISU)
        || BuildHelper.isDebugBuild()
        || ContextCompat.checkSelfPermission(context, permission.POST_NOTIFICATIONS)
        == PackageManager.PERMISSION_GRANTED;
  }
  public void askToEnableNotifications(ComponentActivity activity) {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.TIRAMISU)) {
      if (!checkNotificationsEnabled(activity)) {
        activity.registerForActivityResult(new RequestPermission(),
                isGranted -> EventBus.getDefault().post(new NotificationsGrantedEvent(isGranted)))
            .launch(permission.POST_NOTIFICATIONS);
      } else {
        EventBus.getDefault().post(new NotificationsGrantedEvent(true));
      }
    } else {
      EventBus.getDefault().post(new NotificationsGrantedEvent(true));
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.helpers;
import android.content.Context;
import android.content.Intent;
import android.graphics.Color;
import android.net.Uri;
import android.text.Html;
import android.text.TextUtils;
import android.widget.Toast;
import exceptions.ImportException;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationChannels.NotificationChannelNames;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.utils.GeocodeHelper;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.StorageHelper;
import it.feio.android.springpadimporter.Importer;
import it.feio.android.springpadimporter.models.SpringpadAttachment;
import it.feio.android.springpadimporter.models.SpringpadComment;
import it.feio.android.springpadimporter.models.SpringpadElement;
import it.feio.android.springpadimporter.models.SpringpadItem;
import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.util.HashMap;
import java.util.List;
public class SpringImportHelper {
  public static final String ACTION_DATA_IMPORT_SPRINGPAD = "action_data_import_springpad";
  public static final String EXTRA_SPRINGPAD_BACKUP = "extra_springpad_backup";
  private final Context context;
  private int importedSpringpadNotes, importedSpringpadNotebooks;
  public SpringImportHelper(Context context) {
    this.context = context;
  }
  /**
   * Imports notes and notebooks from Springpad exported archive
   */
  public synchronized void importDataFromSpringpad(Intent intent,
      NotificationsHelper mNotificationsHelper) {
    String backupPath = intent.getStringExtra(EXTRA_SPRINGPAD_BACKUP);
    Importer importer = new Importer();
    try {
      importer.setZipProgressesListener(percentage -> mNotificationsHelper.setMessage(context
          .getString(R.string.extracted) + " " + percentage + "%").show());
      importer.doImport(backupPath);
      // Updating notification
      updateImportNotification(importer, mNotificationsHelper);
    } catch (ImportException e) {
      new NotificationsHelper(context)
          .createStandardNotification(NotificationChannelNames.BACKUPS,
              R.drawable.ic_emoticon_sad_white_24dp,
              context.getString(R.string.import_fail) + ": " + e.getMessage(), null).setLedActive()
          .show();
      return;
    }
    List<SpringpadElement> elements = importer.getSpringpadNotes();
    // If nothing is retrieved it will exit
    if (elements == null || elements.isEmpty()) {
      return;
    }
    // These maps are used to associate with post processing notes to categories (notebooks)
    HashMap<String, Category> categoriesWithUuid = new HashMap<>();
    // Adds all the notebooks (categories)
    for (SpringpadElement springpadElement : importer.getNotebooks()) {
      Category cat = new Category();
      cat.setName(springpadElement.getName());
      cat.setColor(String.valueOf(Color.parseColor("#F9EA1B")));
      DbHelper.getInstance().updateCategory(cat);
      categoriesWithUuid.put(springpadElement.getUuid(), cat);
      // Updating notification
      importedSpringpadNotebooks++;
      updateImportNotification(importer, mNotificationsHelper);
    }
    // And creates a default one for notes without notebook
    Category defaulCategory = new Category();
    defaulCategory.setName("Springpad");
    defaulCategory.setColor(String.valueOf(Color.parseColor("#F9EA1B")));
    DbHelper.getInstance().updateCategory(defaulCategory);
    // And then notes are created
    Note note;
    Attachment mAttachment = null;
    Uri uri;
    for (SpringpadElement springpadElement : importer.getNotes()) {
      note = new Note();
      // Title
      note.setTitle(springpadElement.getName());
      // Content dependent from type of Springpad note
      StringBuilder content = new StringBuilder();
      content.append(
          TextUtils.isEmpty(springpadElement.getText()) ? "" : Html.fromHtml(springpadElement
              .getText()));
      content.append(TextUtils.isEmpty(springpadElement.getDescription()) ? "" : springpadElement
          .getDescription());
      // Some notes could have been exported wrongly
      if (springpadElement.getType() == null) {
        Toast.makeText(context, context.getString(R.string.error), Toast.LENGTH_SHORT).show();
        continue;
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_VIDEO)) {
        try {
          content.append(System.getProperty("line.separator"))
              .append(springpadElement.getVideos().get(0));
        } catch (IndexOutOfBoundsException e) {
          content.append(System.getProperty("line.separator")).append(springpadElement.getUrl());
        }
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_TVSHOW)) {
        content.append(System.getProperty("line.separator")).append(
            TextUtils.join(", ", springpadElement.getCast()));
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_BOOK)) {
        content.append(System.getProperty("line.separator")).append("Author: ")
            .append(springpadElement.getAuthor()).append(System.getProperty("line.separator"))
            .append("Publication date: ").append(springpadElement.getPublicationDate());
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_RECIPE)) {
        content.append(System.getProperty("line.separator")).append("Ingredients: ")
            .append(springpadElement.getIngredients()).append(System.getProperty("line.separator"))
            .append("Directions: ").append(springpadElement.getDirections());
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_BOOKMARK)) {
        content.append(System.getProperty("line.separator")).append(springpadElement.getUrl());
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_BUSINESS)
          && springpadElement.getPhoneNumbers() != null) {
        content.append(System.getProperty("line.separator")).append("Phone number: ")
            .append(springpadElement.getPhoneNumbers().getPhone());
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_PRODUCT)) {
        content.append(System.getProperty("line.separator")).append("Category: ")
            .append(springpadElement.getCategory()).append(System.getProperty("line.separator"))
            .append("Manufacturer: ").append(springpadElement.getManufacturer())
            .append(System.getProperty("line.separator")).append("Price: ")
            .append(springpadElement.getPrice());
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_WINE)) {
        content.append(System.getProperty("line.separator")).append("Wine type: ")
            .append(springpadElement.getWine_type()).append(System.getProperty("line.separator"))
            .append("Varietal: ").append(springpadElement.getVarietal())
            .append(System.getProperty("line.separator")).append("Price: ")
            .append(springpadElement.getPrice());
      }
      if (springpadElement.getType().equals(SpringpadElement.TYPE_ALBUM)) {
        content.append(System.getProperty("line.separator")).append("Artist: ")
            .append(springpadElement.getArtist());
      }
      for (SpringpadComment springpadComment : springpadElement.getComments()) {
        content.append(System.getProperty("line.separator")).append(springpadComment.getCommenter())
            .append(" commented at 0").append(springpadComment.getDate()).append(": ")
            .append(springpadElement.getArtist());
      }
      note.setContent(content.toString());
      // Checklists
      if (springpadElement.getType().equals(SpringpadElement.TYPE_CHECKLIST)) {
        StringBuilder sb = new StringBuilder();
        String checkmark;
        for (SpringpadItem mSpringpadItem : springpadElement.getItems()) {
          checkmark =
              mSpringpadItem.getComplete() ? it.feio.android.checklistview.interfaces.Constants
                  .CHECKED_SYM
                  : it.feio.android.checklistview.interfaces.Constants.UNCHECKED_SYM;
          sb.append(checkmark).append(mSpringpadItem.getName())
              .append(System.getProperty("line.separator"));
        }
        note.setContent(sb.toString());
        note.setChecklist(true);
      }
      // Tags
      String tags = springpadElement.getTags().size() > 0 ? "#"
          + TextUtils.join(" #", springpadElement.getTags()) : "";
      if (note.isChecklist()) {
        note.setTitle(note.getTitle() + tags);
      } else {
        note.setContent(note.getContent() + System.getProperty("line.separator") + tags);
      }
      // Address
      String address =
          springpadElement.getAddresses() != null ? springpadElement.getAddresses().getAddress()
              : "";
      if (!TextUtils.isEmpty(address)) {
        try {
          double[] coords = GeocodeHelper.getCoordinatesFromAddress(context, address);
          note.setLatitude(coords[0]);
          note.setLongitude(coords[1]);
        } catch (IOException e) {
          LogDelegate.e("An error occurred trying to resolve address to coords during Springpad " +
              "import");
        }
        note.setAddress(address);
      }
      // Reminder
      if (springpadElement.getDate() != null) {
        note.setAlarm(springpadElement.getDate().getTime());
      }
      // Creation, modification, category
      note.setCreation(springpadElement.getCreated().getTime());
      note.setLastModification(springpadElement.getModified().getTime());
      // Image
      String image = springpadElement.getImage();
      if (!TextUtils.isEmpty(image)) {
        try {
          File file = StorageHelper.createNewAttachmentFileFromHttp(context, image);
          uri = Uri.fromFile(file);
          String mimeType = StorageHelper.getMimeType(uri.getPath());
          mAttachment = new Attachment(uri, mimeType);
        } catch (MalformedURLException e) {
          uri = Uri.parse(importer.getWorkingPath() + image);
          mAttachment = StorageHelper.createAttachmentFromUri(context, uri, true);
        } catch (IOException e) {
          LogDelegate.e("Error retrieving Springpad online image");
        }
        if (mAttachment != null) {
          note.addAttachment(mAttachment);
        }
        mAttachment = null;
      }
      // Other attachments
      for (SpringpadAttachment springpadAttachment : springpadElement.getAttachments()) {
        // The attachment could be the image itself so it's jumped
        if (image != null && image.equals(springpadAttachment.getUrl())) {
          continue;
        }
        if (TextUtils.isEmpty(springpadAttachment.getUrl())) {
          continue;
        }
        // Tries first with online images
        try {
          File file = StorageHelper
              .createNewAttachmentFileFromHttp(context, springpadAttachment.getUrl());
          uri = Uri.fromFile(file);
          String mimeType = StorageHelper.getMimeType(uri.getPath());
          mAttachment = new Attachment(uri, mimeType);
        } catch (MalformedURLException e) {
          uri = Uri.parse(importer.getWorkingPath() + springpadAttachment.getUrl());
          mAttachment = StorageHelper.createAttachmentFromUri(context, uri, true);
        } catch (IOException e) {
          LogDelegate.e("Error retrieving Springpad online image");
        }
        if (mAttachment != null) {
          note.addAttachment(mAttachment);
        }
        mAttachment = null;
      }
      // If the note has a category is added to the map to be post-processed
      if (!springpadElement.getNotebooks().isEmpty()) {
        note.setCategory(categoriesWithUuid.get(springpadElement.getNotebooks().get(0)));
      } else {
        note.setCategory(defaulCategory);
      }
      // The note is saved
      DbHelper.getInstance().updateNote(note, false);
      ReminderHelper.addReminder(context, note);
      // Updating notification
      importedSpringpadNotes++;
      updateImportNotification(importer, mNotificationsHelper);
    }
    // Delete temp data
    try {
      importer.clean();
    } catch (IOException e) {
      LogDelegate.w("Springpad import temp files not deleted");
    }
  }
  private void updateImportNotification(Importer importer,
      NotificationsHelper mNotificationsHelper) {
    mNotificationsHelper.setMessage(
        importer.getNotebooksCount() + " " + context.getString(R.string.categories) + " ("
            + importedSpringpadNotebooks + " " + context.getString(R.string.imported) + "), "
            + +importer.getNotesCount() + " " + context.getString(R.string.notes) + " ("
            + importedSpringpadNotes + " " + context.getString(R.string.imported) + ")").show();
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.async;
import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
import static it.feio.android.omninotes.helpers.IntentHelper.immutablePendingIntentFlag;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_RESTART_APP;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_BACKUP_FOLDER_URI;
import android.annotation.TargetApi;
import android.app.IntentService;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Build.VERSION_CODES;
import com.lazygeniouz.dfc.file.DocumentFileCompat;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.exceptions.BackupException;
import it.feio.android.omninotes.helpers.BackupHelper;
import it.feio.android.omninotes.helpers.DocumentFileHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.SpringImportHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationChannels.NotificationChannelNames;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.listeners.OnAttachingFileListener;
import it.feio.android.omninotes.utils.ReminderHelper;
import java.io.IOException;
public class DataBackupIntentService extends IntentService implements OnAttachingFileListener {
  public static final String INTENT_BACKUP_NAME = "backup_name";
  public static final String ACTION_DATA_EXPORT = "action_data_export";
  public static final String ACTION_DATA_IMPORT = "action_data_import";
  public static final String ACTION_DATA_DELETE = "action_data_delete";
  private NotificationsHelper mNotificationsHelper;
//    {
//        File autoBackupDir = StorageHelper.getBackupDir(Constants.AUTO_BACKUP_DIR);
//        BackupHelper.exportNotes(autoBackupDir);
//        BackupHelper.exportAttachments(autoBackupDir);
//    }
  public DataBackupIntentService() {
    super("DataBackupIntentService");
  }
  @Override
  protected void onHandleIntent(Intent intent) {
    mNotificationsHelper = new NotificationsHelper(this).start(NotificationChannelNames.BACKUPS,
        R.drawable.ic_content_save_white_24dp, getString(R.string.working));
    // If an alarm has been fired a notification must be generated
    if (ACTION_DATA_EXPORT.equals(intent.getAction())) {
      exportData(intent);
    } else if (ACTION_DATA_IMPORT.equals(intent.getAction())) {
      importData(intent);
    } else if (SpringImportHelper.ACTION_DATA_IMPORT_SPRINGPAD.equals(intent.getAction())) {
      importDataFromSpringpad(intent, mNotificationsHelper);
    } else if (ACTION_DATA_DELETE.equals(intent.getAction())) {
      deleteData(intent);
    }
  }
  private void importDataFromSpringpad(Intent intent, NotificationsHelper mNotificationsHelper) {
    new SpringImportHelper(OmniNotes.getAppContext())
        .importDataFromSpringpad(intent, mNotificationsHelper);
    String title = getString(R.string.data_import_completed);
    String text = getString(R.string.click_to_refresh_application);
    createNotification(intent, this, title, text);
  }
  private void exportData(Intent intent) {
    String backupName = intent.getStringExtra(INTENT_BACKUP_NAME);
    var backupDir = DocumentFileCompat.Companion.fromTreeUri(getBaseContext(),
        Uri.parse(Prefs.getString(PREF_BACKUP_FOLDER_URI, null))).createDirectory(backupName);
    BackupHelper.exportNotes(backupDir);
    BackupHelper.exportAttachments(backupDir, mNotificationsHelper);
    var readableBackupFolder = BackupHelper.getBackupFolderPath() + "/" + backupName;
    mNotificationsHelper.finish(getString(R.string.data_export_completed), readableBackupFolder);
  }
  @TargetApi(VERSION_CODES.O)
  private synchronized void importData(Intent intent) {
    var backupDir = DocumentFileCompat.Companion.fromTreeUri(getBaseContext(),
            Uri.parse(Prefs.getString(PREF_BACKUP_FOLDER_URI, null))).listFiles().stream()
        .filter(f -> f.getName().equals(intent.getStringExtra(INTENT_BACKUP_NAME))).findFirst();
    if (!backupDir.isPresent()) {
      throw new BackupException("Backup folder not found", new RuntimeException());
    }
    BackupHelper.importNotes(backupDir.get());
    BackupHelper.importAttachments(backupDir.get(), mNotificationsHelper);
    resetReminders();
    mNotificationsHelper.cancel();
    createNotification(intent, this, getString(R.string.data_import_completed),
        getString(R.string.click_to_refresh_application));
    // Performs auto-backup filling after backup restore
//        if (Prefs.getBoolean(Constants.PREF_ENABLE_AUTOBACKUP, false)) {
//            File autoBackupDir = StorageHelper.getBackupDir(Constants.AUTO_BACKUP_DIR);
//            BackupHelper.exportNotes(autoBackupDir);
//            BackupHelper.exportAttachments(autoBackupDir);
//        }
  }
  private synchronized void deleteData(Intent intent) {
    String backupName = intent.getStringExtra(INTENT_BACKUP_NAME);
    var backupDir = DocumentFileCompat.Companion.fromTreeUri(getBaseContext(),
            Uri.parse(Prefs.getString(PREF_BACKUP_FOLDER_URI, null))).listFiles().stream()
        .filter(f -> f.getName().equals(intent.getStringExtra(INTENT_BACKUP_NAME)))
        .findFirst();
    if (backupDir.isPresent()) {
      try {
        if (DocumentFileHelper.delete(backupDir.get())) {
          mNotificationsHelper.finish(getString(R.string.data_deletion_completed),
              backupName + " " + getString(R.string.deleted));
        } else {
          LogDelegate.e("Can't delete backup " + backupName);
          mNotificationsHelper.finish(getString(R.string.data_deletion_error), backupName);
        }
      } catch (IOException e) {
        LogDelegate.e("Can't delete backup " + backupName, e);
        mNotificationsHelper.finish(getString(R.string.data_deletion_error), backupName);
      }
    }
  }
  private void createNotification(Intent intent, Context context, String title, String message) {
    Intent intentLaunch;
    if (DataBackupIntentService.ACTION_DATA_IMPORT.equals(intent.getAction())
        || SpringImportHelper.ACTION_DATA_IMPORT_SPRINGPAD.equals(intent.getAction())) {
      intentLaunch = new Intent(context, MainActivity.class);
      intentLaunch.setAction(ACTION_RESTART_APP);
    } else {
      intentLaunch = new Intent();
    }
    // Add this bundle to the intent
    intentLaunch.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intentLaunch.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    PendingIntent notifyIntent = PendingIntent.getActivity(context, 0, intentLaunch,
        immutablePendingIntentFlag(FLAG_UPDATE_CURRENT));
    NotificationsHelper notificationsHelper = new NotificationsHelper(context);
    notificationsHelper.createStandardNotification(NotificationChannelNames.BACKUPS,
        R.drawable.ic_content_save_white_24dp, title, notifyIntent)
        .setMessage(message).setRingtone(Prefs.getString("settings_notification_ringtone", null))
        .setLedActive();
    if (Prefs.getBoolean("settings_notification_vibration", true)) {
      notificationsHelper.setVibration();
    }
    notificationsHelper.show();
  }
  /**
   * Schedules reminders
   */
  private void resetReminders() {
    LogDelegate.d("Resetting reminders");
    for (Note note : DbHelper.getInstance().getNotesWithReminderNotFired()) {
      ReminderHelper.addReminder(OmniNotes.getAppContext(), note);
    }
  }
  @Override
  public void onAttachingFileErrorOccurred(Attachment mAttachment) {
    // TODO Auto-generated method stub
  }
  @Override
  public void onAttachingFileFinished(Attachment mAttachment) {
    // TODO Auto-generated method stub
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static android.Manifest.permission.CAMERA;
import static android.content.Context.CLIPBOARD_SERVICE;
import static android.content.Context.LAYOUT_INFLATER_SERVICE;
import static android.content.pm.PackageManager.FEATURE_CAMERA;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;
import static android.widget.Toast.LENGTH_SHORT;
import static androidx.core.view.ViewCompat.animate;
import static it.feio.android.omninotes.BaseActivity.TRANSITION_HORIZONTAL;
import static it.feio.android.omninotes.BaseActivity.TRANSITION_VERTICAL;
import static it.feio.android.omninotes.MainActivity.FRAGMENT_DETAIL_TAG;
import static it.feio.android.omninotes.MainActivity.FRAGMENT_SKETCH_TAG;
import static it.feio.android.omninotes.OmniNotes.getAppContext;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_DISMISS;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_FAB_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_MERGE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_NOTIFICATION_CLICK;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_PINNED;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_SHOW_LIST;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_CLICKED_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_IMAGES;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_TITLE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_GOOGLE_NOW;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_KEY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_FILES;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_SKETCH;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_SKETCH_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_ATTACHMENTS_ON_BOTTOM;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_AUTO_LOCATION;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_COLORS_APP_DEFAULT;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_KEEP_CHECKED;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_KEEP_CHECKMARKS;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PRETTIFIED_DATES;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_WIDGET_PREFIX;
import static it.feio.android.omninotes.utils.ConstantsBase.SWIPE_MARGIN;
import static it.feio.android.omninotes.utils.ConstantsBase.SWIPE_OFFSET;
import static it.feio.android.omninotes.utils.ConstantsBase.THUMBNAIL_SIZE;
import static java.lang.Integer.parseInt;
import static java.lang.Long.parseLong;
import android.Manifest;
import android.Manifest.permission;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.Point;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.location.Location;
import android.media.MediaPlayer;
import android.media.MediaRecorder;
import android.media.ThumbnailUtils;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.provider.MediaStore;
import android.text.Editable;
import android.text.Selection;
import android.text.Spanned;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.AutoCompleteTextView;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.Toast;
import androidx.activity.result.ActivityResultCallback;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.core.content.ContextCompat;
import androidx.core.util.Pair;
import androidx.drawerlayout.widget.DrawerLayout;
import androidx.fragment.app.FragmentTransaction;
import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.neopixl.pixlui.components.edittext.EditText;
import com.pixplicity.easyprefs.library.Prefs;
import com.pushbullet.android.extension.MessagingExtension;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Style;
import it.feio.android.checklistview.exceptions.ViewNotSupportedException;
import it.feio.android.checklistview.interfaces.CheckListChangedListener;
import it.feio.android.checklistview.models.CheckListView;
import it.feio.android.checklistview.models.CheckListViewItem;
import it.feio.android.checklistview.models.ChecklistManager;
import it.feio.android.omninotes.async.AttachmentTask;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import it.feio.android.omninotes.async.bus.PushbulletReplyEvent;
import it.feio.android.omninotes.async.bus.SwitchFragmentEvent;
import it.feio.android.omninotes.async.notes.NoteProcessorDelete;
import it.feio.android.omninotes.async.notes.SaveNoteTask;
import it.feio.android.omninotes.databinding.FragmentDetailBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.exceptions.checked.ContentSecurityException;
import it.feio.android.omninotes.exceptions.checked.UnhandledIntentException;
import it.feio.android.omninotes.helpers.AttachmentsHelper;
import it.feio.android.omninotes.helpers.BuildHelper;
import it.feio.android.omninotes.helpers.IntentHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.PermissionsHelper;
import it.feio.android.omninotes.helpers.TagOpenerHelper;
import it.feio.android.omninotes.helpers.date.DateHelper;
import it.feio.android.omninotes.helpers.date.RecurrenceHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationChannels.NotificationChannelNames;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.PasswordValidator.Result;
import it.feio.android.omninotes.models.Tag;
import it.feio.android.omninotes.models.adapters.AttachmentAdapter;
import it.feio.android.omninotes.models.adapters.CategoryRecyclerViewAdapter;
import it.feio.android.omninotes.models.adapters.PlacesAutoCompleteAdapter;
import it.feio.android.omninotes.models.listeners.OnAttachingFileListener;
import it.feio.android.omninotes.models.listeners.OnGeoUtilResultListener;
import it.feio.android.omninotes.models.listeners.OnReminderPickedListener;
import it.feio.android.omninotes.models.listeners.RecyclerViewItemClickSupport;
import it.feio.android.omninotes.models.views.ExpandableHeightGridView;
import it.feio.android.omninotes.utils.AlphaManager;
import it.feio.android.omninotes.utils.BitmapHelper;
import it.feio.android.omninotes.utils.Display;
import it.feio.android.omninotes.utils.FileHelper;
import it.feio.android.omninotes.utils.FileProviderHelper;
import it.feio.android.omninotes.utils.GeocodeHelper;
import it.feio.android.omninotes.utils.IntentChecker;
import it.feio.android.omninotes.utils.KeyboardUtils;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.Security;
import it.feio.android.omninotes.utils.ShortcutHelper;
import it.feio.android.omninotes.utils.StorageHelper;
import it.feio.android.omninotes.utils.TagsHelper;
import it.feio.android.omninotes.utils.TextHelper;
import it.feio.android.omninotes.utils.date.DateUtils;
import it.feio.android.omninotes.utils.date.ReminderPickers;
import it.feio.android.pixlui.links.TextLinkClickListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.commons.collections4.CollectionUtils;
public class DetailFragment extends BaseFragment implements OnReminderPickedListener,
    OnTouchListener,
    OnAttachingFileListener, TextWatcher, CheckListChangedListener,
    OnGeoUtilResultListener {
  private static final int TAKE_PHOTO = 1;
  private static final int TAKE_VIDEO = 2;
  private static final int SET_PASSWORD = 3;
  private static final int SKETCH = 4;
  private static final int CATEGORY = 5;
  private static final int DETAIL = 6;
  private static final int FILES = 7;
  private FragmentDetailBinding binding;
  boolean goBack = false;
  private ExpandableHeightGridView mGridView;
  private View toggleChecklistView;
  private Uri attachmentUri;
  private AttachmentAdapter mAttachmentAdapter;
  private MaterialDialog attachmentDialog;
  private Note note;
  private Note noteTmp;
  private Note noteOriginal;
  // Audio recording
  private String recordName;
  private MediaRecorder mRecorder = null;
  private MediaPlayer mPlayer = null;
  private boolean isRecording = false;
  private View isPlayingView = null;
  private Bitmap recordingBitmap;
  private ChecklistManager mChecklistManager;
  // Values to print result
  private String exitMessage;
  private Style exitCroutonStyle = ONStyle.CONFIRM;
  // Flag to check if after editing it will return to ListActivity or not
  // and in the last case a Toast will be shown instead than Crouton
  private boolean afterSavedReturnsToList = true;
  private boolean showKeyboard = false;
  private boolean swiping;
  private int startSwipeX;
  private boolean orientationChanged;
  private long audioRecordingTimeStart;
  private long audioRecordingTime;
  private DetailFragment mFragment;
  private Attachment sketchEdited;
  private int contentLineCounter = 1;
  private int contentCursorPosition;
  private ArrayList<String> mergedNotesIds;
  private MainActivity mainActivity;
  private boolean activityPausing;
  TextLinkClickListener textLinkClickListener = (view, clickedString, url) -> {
      new MaterialDialog.Builder(mainActivity)
          .content(clickedString)
          .negativeColorRes(R.color.colorPrimary)
          .positiveText(R.string.open)
          .negativeText(R.string.copy)
          .onPositive((dialog, which) -> {
            try {
              Intent intent = TagOpenerHelper.openOrGetIntent(getContext(), url);
              if (intent != null) {
                mainActivity.initNotesList(intent);
              }
            } catch (UnhandledIntentException e) {
              mainActivity.showMessage(R.string.no_application_can_perform_this_action,
                  ONStyle.ALERT);
            }
          })
          .onNegative((dialog, which) -> {
            android.content.ClipboardManager clipboard = (android.content.ClipboardManager)
                mainActivity.getSystemService(CLIPBOARD_SERVICE);
            android.content.ClipData clip = android.content.ClipData.newPlainText("text label",
                clickedString);
            clipboard.setPrimaryClip(clip);
          }).build().show();
      View clickedView =
          Boolean.TRUE.equals(noteTmp.isChecklist()) ? toggleChecklistView : binding.contentWrapper;
      clickedView.clearFocus();
      KeyboardUtils.hideKeyboard(clickedView);
      new Handler().post(() -> {
        View clickedView1 = Boolean.TRUE.equals(noteTmp.isChecklist()) ? toggleChecklistView : binding.contentWrapper;
        KeyboardUtils.hideKeyboard(clickedView1);
      });
  };
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mFragment = this;
  }
  @Override
  public void onAttach(Context context) {
    super.onAttach(context);
    EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.CHILDREN));
  }
  @Override
  public void onStop() {
    super.onStop();
    GeocodeHelper.stop();
  }
  @Override
  public void onResume() {
    super.onResume();
    activityPausing = false;
    EventBus.getDefault().register(this);
  }
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    binding = FragmentDetailBinding.inflate(inflater, container, false);
    return binding.getRoot();
  }
  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    mainActivity = (MainActivity) getActivity();
    mainActivity.getSupportActionBar().setDisplayShowTitleEnabled(false);
    mainActivity.getToolbar().setNavigationOnClickListener(v -> navigateUp());
    // Force the navigation drawer to stay opened if tablet mode is on, otherwise has to stay closed
    if (NavigationDrawerFragment.isDoublePanelActive()) {
      mainActivity.getDrawerLayout().setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_OPEN);
    } else {
      mainActivity.getDrawerLayout().setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED);
    }
    restoreTempNoteAfterOrientationChange(savedInstanceState);
    addSketchedImageIfPresent();
    // Ensures that Detail Fragment always have the back Arrow when it's created
    EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.CHILDREN));
    init();
    setHasOptionsMenu(true);
    setRetainInstance(false);
  }
  private void addSketchedImageIfPresent() {
    if (mainActivity.getSketchUri() != null) {
      Attachment mAttachment = new Attachment(mainActivity.getSketchUri(), MIME_TYPE_SKETCH);
      addAttachment(mAttachment);
      mainActivity.setSketchUri(null);
      // Removes previous version of edited image
      if (sketchEdited != null) {
        noteTmp.getAttachmentsList().remove(sketchEdited);
        sketchEdited = null;
      }
    }
  }
  private void restoreTempNoteAfterOrientationChange(Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      noteTmp = savedInstanceState.getParcelable("noteTmp");
      note = savedInstanceState.getParcelable("note");
      noteOriginal = savedInstanceState.getParcelable("noteOriginal");
      attachmentUri = savedInstanceState.getParcelable("attachmentUri");
      orientationChanged = savedInstanceState.getBoolean("orientationChanged");
    }
  }
  @Override
  public void onSaveInstanceState(Bundle outState) {
    if (noteTmp != null) {
      noteTmp.setTitle(getNoteTitle());
      noteTmp.setContent(getNoteContent());
      outState.putParcelable("noteTmp", noteTmp);
      outState.putParcelable("note", note);
      outState.putParcelable("noteOriginal", noteOriginal);
      outState.putParcelable("attachmentUri", attachmentUri);
      outState.putBoolean("orientationChanged", orientationChanged);
    }
    super.onSaveInstanceState(outState);
  }
  @Override
  public void onPause() {
    super.onPause();
    //to prevent memory leak fragment keep refernce of event but until deregister
    EventBus.getDefault().unregister(this);
    activityPausing = true;
    // Checks "goBack" value to avoid performing a double saving
    if (!goBack) {
      saveNote();
    }
    if (toggleChecklistView != null) {
      KeyboardUtils.hideKeyboard(toggleChecklistView);
      binding.contentWrapper.clearFocus();
    }
  }
  @Override
  public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (getResources().getConfiguration().orientation != newConfig.orientation) {
      orientationChanged = true;
    }
  }
  private void init() {
    // Handling of Intent actions
    handleIntents();
    if (noteOriginal == null) {
      noteOriginal = getArguments().getParcelable(INTENT_NOTE);
    }
    if (note == null) {
      note = new Note(noteOriginal);
    }
    if (noteTmp == null) {
      noteTmp = new Note(note);
    }
    if (Boolean.TRUE.equals(noteTmp.isLocked()) && !noteTmp.isPasswordChecked()) {
      checkNoteLock(noteTmp);
      return;
    }
    initViews();
  }
  /**
   * Checks note lock and password before showing note content
   */
  private void checkNoteLock(Note note) {
    // If note is locked security password will be requested
    if (Boolean.TRUE.equals(note.isLocked()
        && Prefs.getString(PREF_PASSWORD, null) != null)
        && !Prefs.getBoolean("settings_password_access", false)) {
      PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
        switch (passwordConfirmed) {
          case SUCCEED:
            noteTmp.setPasswordChecked(true);
            init();
            break;
          case FAIL:
            goBack = true;
            goHome();
            break;
          case RESTORE:
            goBack = true;
            goHome();
            PasswordHelper.resetPassword(mainActivity);
            break;
        }
      });
    } else {
      noteTmp.setPasswordChecked(true);
      init();
    }
  }
  private void handleIntents() {
    Intent i = mainActivity.getIntent();
    if (IntentChecker.checkAction(i, ACTION_MERGE)) {
      noteOriginal = new Note();
      note = new Note(noteOriginal);
      noteTmp = getArguments().getParcelable(INTENT_NOTE);
      if (i.getStringArrayListExtra("merged_notes") != null) {
        mergedNotesIds = i.getStringArrayListExtra("merged_notes");
      }
    }
    // Action called from home shortcut
    if (IntentChecker.checkAction(i, ACTION_SHORTCUT, ACTION_NOTIFICATION_CLICK)) {
      afterSavedReturnsToList = false;
      noteOriginal = DbHelper.getInstance().getNote(i.getLongExtra(INTENT_KEY, 0));
      // Checks if the note pointed from the shortcut has been deleted
      try {
        note = new Note(noteOriginal);
        noteTmp = new Note(noteOriginal);
      } catch (NullPointerException e) {
        mainActivity.showToast(getText(R.string.shortcut_note_deleted), Toast.LENGTH_LONG);
        mainActivity.finish();
      }
    }
    // Check if is launched from a widget
    if (IntentChecker.checkAction(i, ACTION_WIDGET, ACTION_WIDGET_TAKE_PHOTO)) {
      afterSavedReturnsToList = false;
      showKeyboard = true;
      //  with tags to set tag
      if (i.hasExtra(INTENT_WIDGET)) {
        String widgetId = i.getExtras().get(INTENT_WIDGET).toString();
        String sqlCondition = Prefs.getString(PREF_WIDGET_PREFIX + widgetId, "");
        String categoryId = TextHelper.checkIntentCategory(sqlCondition);
        if (categoryId != null) {
          Category category;
          try {
            category = DbHelper.getInstance().getCategory(parseLong(categoryId));
            noteTmp = new Note();
            noteTmp.setCategory(category);
          } catch (NumberFormatException e) {
            LogDelegate.e("Category with not-numeric value!", e);
          }
        }
      }
      // Sub-action is to take a photo
      if (IntentChecker.checkAction(i, ACTION_WIDGET_TAKE_PHOTO)) {
        takePhoto();
      }
    }
    if (IntentChecker.checkAction(i, ACTION_FAB_TAKE_PHOTO)) {
      takePhoto();
    }
    // Handles third party apps requests of sharing
    if (IntentChecker
        .checkAction(i, Intent.ACTION_SEND, Intent.ACTION_SEND_MULTIPLE, Intent.ACTION_PROCESS_TEXT, INTENT_GOOGLE_NOW)
        && i.getType() != null) {
      afterSavedReturnsToList = false;
      if (noteTmp == null) {
        noteTmp = new Note();
      }
      // Text title
      String title = i.getStringExtra(Intent.EXTRA_SUBJECT);
      if (title != null) {
        noteTmp.setTitle(title);
      }
      // Text content
      String content = null;
      if (Intent.ACTION_PROCESS_TEXT.equals(i.getAction())){
        content = i.getStringExtra(Intent.EXTRA_PROCESS_TEXT).toString();
      } else {
        content = i.getStringExtra(Intent.EXTRA_TEXT);
      }
      if (content != null) {
        noteTmp.setContent(content);
      }
      importAttachments(i);
    }
    if (IntentChecker
        .checkAction(i, Intent.ACTION_MAIN, ACTION_WIDGET_SHOW_LIST, ACTION_SHORTCUT_WIDGET,
            ACTION_WIDGET)) {
      showKeyboard = true;
    }
    i.setAction(null);
  }
  private void importAttachments(Intent i) {
    if (!i.hasExtra(Intent.EXTRA_STREAM)) {
      return;
    }
    if (i.getExtras().get(Intent.EXTRA_STREAM) instanceof Uri) {
      Uri uri = i.getParcelableExtra(Intent.EXTRA_STREAM);
      // Google Now passes Intent as text but with audio recording attached the case must be handled like this
      if (validatePath(uri.getPath()) && !INTENT_GOOGLE_NOW.equals(i.getAction())) {
        String name = FileHelper.getNameFromUri(mainActivity, uri);
        new AttachmentTask(this, uri, name, this).execute();
      }
    } else {
      ArrayList<Uri> uris = i.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
      for (Uri uriSingle : uris) {
        if (validatePath(uriSingle.getPath())) {
          String name = FileHelper.getNameFromUri(mainActivity, uriSingle);
          new AttachmentTask(this, uriSingle, name, this).execute();
        }
      }
    }
  }
  private boolean validatePath(String path) {
    try {
      Security.validatePath(path);
      return true;
    } catch (ContentSecurityException e) {
      mainActivity.showMessage(R.string.insecure_content_found, ONStyle.WARN);
      return false;
    }
  }
  @SuppressLint("NewApi")
  private void initViews() {
    // Sets onTouchListener to the whole activity to swipe notes
    binding.detailRoot.setOnTouchListener(this);
    // Color of tag marker if note is tagged a function is active in preferences
    setTagMarkerColor(noteTmp.getCategory());
    initViewTitle();
    initViewContent();
    initViewLocation();
    initViewAttachments();
    initViewReminder();
    initViewFooter();
  }
  private void initViewFooter() {
    String creation = DateHelper
        .getFormattedDate(noteTmp.getCreation(), Prefs.getBoolean(PREF_PRETTIFIED_DATES, true));
    binding.creation
        .append(creation.length() > 0 ? getString(R.string.creation) + " " + creation : "");
    if (binding.creation.getText().length() == 0) {
      binding.creation.setVisibility(View.GONE);
    }
    String lastModification = DateHelper
        .getFormattedDate(noteTmp.getLastModification(), Prefs.getBoolean(
            PREF_PRETTIFIED_DATES, true));
    binding.lastModification
        .append(lastModification.length() > 0 ? getString(R.string.last_update) + " " +
            lastModification : "");
    if (binding.lastModification.getText().length() == 0) {
      binding.lastModification.setVisibility(View.GONE);
    }
  }
  private void initViewReminder() {
    binding.fragmentDetailContent.reminderLayout.setOnClickListener(v -> {
      ReminderPickers reminderPicker = new ReminderPickers(mainActivity, mFragment);
      reminderPicker.pick(DateUtils.getPresetReminder(noteTmp.getAlarm()), noteTmp
          .getRecurrenceRule());
    });
    binding.fragmentDetailContent.reminderLayout.setOnLongClickListener(v -> {
      MaterialDialog dialog = new MaterialDialog.Builder(mainActivity)
          .content(R.string.remove_reminder)
          .positiveText(R.string.ok)
          .onPositive((dialog1, which) -> {
            ReminderHelper.removeReminder(getAppContext(), noteTmp);
            noteTmp.setAlarm(null);
            binding.fragmentDetailContent.reminderIcon
                .setImageResource(R.drawable.ic_alarm_black_18dp);
            binding.fragmentDetailContent.datetime.setText("");
          }).build();
      dialog.show();
      return true;
    });
    // Reminder
    String reminderString = initReminder(noteTmp);
    if (!TextUtils.isEmpty(reminderString)) {
      binding.fragmentDetailContent.reminderIcon
          .setImageResource(R.drawable.ic_alarm_add_black_18dp);
      binding.fragmentDetailContent.datetime.setText(reminderString);
    }
  }
  private void initViewLocation() {
    DetailFragment detailFragment = this;
    if (isNoteLocationValid()) {
      if (TextUtils.isEmpty(noteTmp.getAddress())) {
        //FIXME: What's this "sasd"?
        GeocodeHelper.getAddressFromCoordinates(new Location("sasd"), detailFragment);
      } else {
        binding.fragmentDetailContent.location.setText(noteTmp.getAddress());
        binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
      }
    }
    // Automatic location insertion
    if (Prefs.getBoolean(PREF_AUTO_LOCATION, false) && noteTmp.get_id() == null) {
      getLocation(detailFragment);
    }
    binding.fragmentDetailContent.location.setOnClickListener(v -> {
      String uriString = "geo:" + noteTmp.getLatitude() + ',' + noteTmp.getLongitude()
          + "?q=" + noteTmp.getLatitude() + ',' + noteTmp.getLongitude();
      Intent locationIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(uriString));
      if (!IntentChecker.isAvailable(mainActivity, locationIntent, null)) {
        uriString = "http://maps.google.com/maps?q=" + noteTmp.getLatitude() + ',' + noteTmp
            .getLongitude();
        locationIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(uriString));
      }
      startActivity(locationIntent);
    });
    binding.fragmentDetailContent.location.setOnLongClickListener(v -> {
      MaterialDialog.Builder builder = new MaterialDialog.Builder(mainActivity);
      builder.content(R.string.remove_location);
      builder.positiveText(R.string.ok);
      builder.onPositive((dialog, which) -> {
        noteTmp.setLatitude("");
        noteTmp.setLongitude("");
        fade(binding.fragmentDetailContent.location, false);
      });
      MaterialDialog dialog = builder.build();
      dialog.show();
      return true;
    });
  }
  private void getLocation(OnGeoUtilResultListener onGeoUtilResultListener) {
    PermissionsHelper
        .requestPermission(this, Manifest.permission.ACCESS_FINE_LOCATION, R.string
                .permission_coarse_location, binding.snackbarPlaceholder,
            () -> GeocodeHelper.getLocation(onGeoUtilResultListener));
  }
  private void initViewAttachments() {
    // Attachments position based on preferences
    if (Prefs.getBoolean(PREF_ATTACHMENTS_ON_BOTTOM, false)) {
      binding.detailAttachmentsBelow.inflate();
    } else {
      binding.detailAttachmentsAbove.inflate();
    }
    mGridView = binding.detailRoot.findViewById(R.id.gridview);
    // Some fields can be filled by third party application and are always shown
    mAttachmentAdapter = new AttachmentAdapter(mainActivity, noteTmp.getAttachmentsList());
    // Initialzation of gridview for images
    mGridView.setAdapter(mAttachmentAdapter);
    mGridView.autoresize();
    // Click events for images in gridview (zooms image)
    mGridView.setOnItemClickListener((parent, v, position, id) -> {
      Attachment attachment = (Attachment) parent.getAdapter().getItem(position);
      Uri shareableAttachmentUri = mainActivity.getShareableAttachmentUri(attachment);
      if (shareableAttachmentUri == null) {
        return;
      }
      Intent attachmentIntent;
      if (MIME_TYPE_FILES.equals(attachment.getMime_type())) {
        attachmentIntent = new Intent(Intent.ACTION_VIEW);
        attachmentIntent.setDataAndType(shareableAttachmentUri, StorageHelper.getMimeType(mainActivity,
            shareableAttachmentUri));
        attachmentIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent
            .FLAG_GRANT_WRITE_URI_PERMISSION);
        if (IntentChecker
            .isAvailable(mainActivity.getApplicationContext(), attachmentIntent, null)) {
          startActivity(attachmentIntent);
        } else {
          mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.WARN);
        }
        // Media files will be opened in internal gallery
      } else if (MIME_TYPE_IMAGE.equals(attachment.getMime_type())
          || MIME_TYPE_SKETCH.equals(attachment.getMime_type())
          || MIME_TYPE_VIDEO.equals(attachment.getMime_type())) {
        // Title
        noteTmp.setTitle(getNoteTitle());
        noteTmp.setContent(getNoteContent());
        String title1 = TextHelper.parseTitleAndContent(mainActivity,
            noteTmp)[0].toString();
        // Images
        int clickedImage = 0;
        ArrayList<Attachment> images = new ArrayList<>();
        for (Attachment mAttachment : noteTmp.getAttachmentsList()) {
          if (MIME_TYPE_IMAGE.equals(mAttachment.getMime_type())
              || MIME_TYPE_SKETCH.equals(mAttachment.getMime_type())
              || MIME_TYPE_VIDEO.equals(mAttachment.getMime_type())) {
            images.add(mAttachment);
            if (mAttachment.equals(attachment)) {
              clickedImage = images.size() - 1;
            }
          }
        }
        // Intent
        attachmentIntent = new Intent(mainActivity, GalleryActivity.class);
        attachmentIntent.putExtra(GALLERY_TITLE, title1);
        attachmentIntent.putParcelableArrayListExtra(GALLERY_IMAGES, images);
        attachmentIntent.putExtra(GALLERY_CLICKED_IMAGE, clickedImage);
        startActivity(attachmentIntent);
      } else if (MIME_TYPE_AUDIO.equals(attachment.getMime_type())) {
        playback(v, attachment.getUri());
      }
    });
    mGridView.setOnItemLongClickListener((parent, v, position, id) -> {
      // To avoid deleting audio attachment during playback
      if (mPlayer != null) {
        return false;
      }
      List<String> items = Arrays
          .asList(getResources().getStringArray(R.array.attachments_actions));
      if (!MIME_TYPE_SKETCH.equals(mAttachmentAdapter.getItem(position).getMime_type())) {
        items = items.subList(0, items.size() - 1);
      }
      Attachment attachment = mAttachmentAdapter.getItem(position);
      new MaterialDialog.Builder(mainActivity)
          .title(attachment.getName() + " (" + AttachmentsHelper.getSize(attachment) + ")")
          .items(items.toArray(new String[items.size()]))
          .itemsCallback((materialDialog, view, i, charSequence) ->
              performAttachmentAction(position, i))
          .build()
          .show();
      return true;
    });
  }
  /**
   * Performs an action when long-click option is selected
   *
   * @param i item index
   */
  private void performAttachmentAction(int attachmentPosition, int i) {
    switch (getResources().getStringArray(R.array.attachments_actions_values)[i]) {
      case "share":
        Intent shareIntent = new Intent(Intent.ACTION_SEND);
        Attachment attachment = mAttachmentAdapter.getItem(attachmentPosition);
        Uri shareableAttachmentUri = mainActivity.getShareableAttachmentUri(attachment);
        if (shareableAttachmentUri == null) {
          Toast.makeText(getActivity(), R.string.error_saving_attachments, LENGTH_SHORT).show();
          break;
        }
        shareIntent.setType(StorageHelper.getMimeType(getAppContext(), attachment.getUri()));
        shareIntent.putExtra(Intent.EXTRA_STREAM, shareableAttachmentUri);
        if (IntentChecker.isAvailable(getAppContext(), shareIntent, null)) {
          startActivity(shareIntent);
        } else {
          mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.WARN);
        }
        break;
      case "delete":
        removeAttachment(attachmentPosition);
        mAttachmentAdapter.notifyDataSetChanged();
        mGridView.autoresize();
        break;
      case "delete all":
        new MaterialDialog.Builder(mainActivity)
            .title(R.string.delete_all_attachments)
            .positiveText(R.string.confirm)
            .onPositive((materialDialog, dialogAction) -> removeAllAttachments())
            .build()
            .show();
        break;
      case "edit":
        takeSketch(mAttachmentAdapter.getItem(attachmentPosition));
        break;
      default:
        LogDelegate.w("No action available");
    }
  }
  private void initViewTitle() {
    binding.detailTitle.setText(noteTmp.getTitle());
    binding.detailTitle.gatherLinksForText();
    binding.detailTitle.setOnTextLinkClickListener(textLinkClickListener);
    // To avoid dropping here the  dragged checklist items
    binding.detailTitle.setOnDragListener((v, event) -> true);
    //When editor action is pressed focus is moved to last character in content field
    binding.detailTitle.setOnEditorActionListener((v, actionId, event) -> {
      binding.fragmentDetailContent.detailContent.requestFocus();
      binding.fragmentDetailContent.detailContent
          .setSelection(binding.fragmentDetailContent.detailContent.getText().length());
      return false;
    });
    requestFocus(binding.detailTitle);
  }
  private void initViewContent() {
    binding.fragmentDetailContent.detailContent.setText(noteTmp.getContent());
    binding.fragmentDetailContent.detailContent.gatherLinksForText();
    binding.fragmentDetailContent.detailContent.setOnTextLinkClickListener(textLinkClickListener);
    // Avoids focused line goes under the keyboard
    binding.fragmentDetailContent.detailContent.addTextChangedListener(this);
    // Restore checklist
    toggleChecklistView = binding.fragmentDetailContent.detailContent;
    if (noteTmp.isChecklist()) {
      noteTmp.setChecklist(false);
      AlphaManager.setAlpha(toggleChecklistView, 0);
      toggleChecklist2();
    }
  }
  /**
   * Force focus and shows soft keyboard. Only happens if it's a new note, without shared content.
   * {@link showKeyboard} is used to check if the note is created from shared content.
   */
  @SuppressWarnings("JavadocReference")
  private void requestFocus(final EditText view) {
    if (note.get_id() == null && !noteTmp.isChanged(note) && showKeyboard) {
      KeyboardUtils.showKeyboard(view);
    }
  }
  /**
   * Colors tag marker in note's title and content elements
   */
  private void setTagMarkerColor(Category tag) {
    String colorsPref = Prefs.getString("settings_colors_app", PREF_COLORS_APP_DEFAULT);
    // Checking preference
    if (!"disabled".equals(colorsPref)) {
      // Choosing target view depending on another preference
      ArrayList<View> target = new ArrayList<>();
      if ("complete".equals(colorsPref)) {
        target.add(binding.titleWrapper);
        target.add(binding.contentWrapper);
      } else {
        target.add(binding.tagMarker);
      }
      // Coloring the target
      if (tag != null && tag.getColor() != null) {
        for (View view : target) {
          view.setBackgroundColor(parseInt(tag.getColor()));
        }
      } else {
        for (View view : target) {
          view.setBackgroundColor(Color.parseColor("#00000000"));
        }
      }
    }
  }
  private void displayLocationDialog() {
    getLocation(new OnGeoUtilResultListenerImpl(mainActivity, mFragment, noteTmp));
  }
  @Override
  public void onLocationRetrieved(Location location) {
    if (location == null) {
      mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
    }
    if (location != null) {
      noteTmp.setLatitude(location.getLatitude());
      noteTmp.setLongitude(location.getLongitude());
      if (!TextUtils.isEmpty(noteTmp.getAddress())) {
        binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
        binding.fragmentDetailContent.location.setText(noteTmp.getAddress());
      } else {
        GeocodeHelper.getAddressFromCoordinates(location, mFragment);
      }
    }
  }
  @Override
  public void onLocationUnavailable() {
    mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
  }
  public void onLocationNotEnabled(){
    mainActivity.showMessage(R.string.location_not_enabled, ONStyle.ALERT);
  }
  @Override
  public void onAddressResolved(String address) {
    if (TextUtils.isEmpty(address)) {
      if (!isNoteLocationValid()) {
        mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
        return;
      }
      address = noteTmp.getLatitude() + ", " + noteTmp.getLongitude();
    }
    if (!GeocodeHelper.areCoordinates(address)) {
      noteTmp.setAddress(address);
    }
    binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
    binding.fragmentDetailContent.location.setText(address);
    fade(binding.fragmentDetailContent.location, true);
  }
  @Override
  public void onCoordinatesResolved(Location location, String address) {
    if (location != null) {
      noteTmp.setLatitude(location.getLatitude());
      noteTmp.setLongitude(location.getLongitude());
      noteTmp.setAddress(address);
      binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
      binding.fragmentDetailContent.location.setText(address);
      fade(binding.fragmentDetailContent.location, true);
    } else {
      mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
    }
  }
  @Override
  public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
    inflater.inflate(R.menu.menu_detail, menu);
    super.onCreateOptionsMenu(menu, inflater);
  }
  @Override
  public void onPrepareOptionsMenu(Menu menu) {
    // Closes search view if left open in List fragment
    MenuItem searchMenuItem = menu.findItem(R.id.menu_search);
    if (searchMenuItem != null) {
      searchMenuItem.collapseActionView();
    }
    boolean newNote = noteTmp.get_id() == null;
    menu.findItem(R.id.menu_checklist_on).setVisible(!noteTmp.isChecklist());
    menu.findItem(R.id.menu_checklist_off).setVisible(noteTmp.isChecklist());
    menu.findItem(R.id.menu_checklist_moveToBottom)
        .setVisible(noteTmp.isChecklist() && mChecklistManager.getCheckedCount() > 0);
    menu.findItem(R.id.menu_lock).setVisible(!noteTmp.isLocked());
    menu.findItem(R.id.menu_unlock).setVisible(noteTmp.isLocked());
    // If note is trashed only this options will be available from menu
    if (noteTmp.isTrashed()) {
      menu.findItem(R.id.menu_untrash).setVisible(true);
      menu.findItem(R.id.menu_delete).setVisible(true);
      // Otherwise all other actions will be available
    } else {
      // Temporary removed until fixed on Oreo and following
      menu.findItem(R.id.menu_add_shortcut).setVisible(!newNote);
      menu.findItem(R.id.menu_pin_note).setVisible(!newNote);
      menu.findItem(R.id.menu_archive).setVisible(!newNote && !noteTmp.isArchived());
      menu.findItem(R.id.menu_unarchive).setVisible(!newNote && noteTmp.isArchived());
      menu.findItem(R.id.menu_trash).setVisible(!newNote);
    }
  }
  @SuppressLint("NewApi")
  private boolean goHome() {
    stopPlaying();
    // The activity has managed a shared intent from third party app and
    // performs a normal onBackPressed instead of returning back to ListActivity
    if (!afterSavedReturnsToList) {
      if (!TextUtils.isEmpty(exitMessage)) {
        mainActivity.showToast(exitMessage, LENGTH_SHORT);
      }
      mainActivity.finish();
    } else {
      if (!TextUtils.isEmpty(exitMessage) && exitCroutonStyle != null) {
        mainActivity.showMessage(exitMessage, exitCroutonStyle);
      }
      // Otherwise the result is passed to ListActivity
      if (mainActivity != null) {
        mainActivity.getSupportFragmentManager();
        mainActivity.getSupportFragmentManager().popBackStack();
        if (mainActivity.getSupportFragmentManager().getBackStackEntryCount() == 1) {
          mainActivity.getSupportActionBar().setDisplayShowTitleEnabled(true);
          if (mainActivity.getDrawerToggle() != null) {
            mainActivity.getDrawerToggle().setDrawerIndicatorEnabled(true);
          }
          EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.PARENT));
        }
      }
    }
    return true;
  }
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
    if (isOptionsItemFastClick()) {
      return true;
    }
    switch (item.getItemId()) {
      case R.id.menu_attachment:
        showAttachmentsPopup();
        break;
      case R.id.menu_tag:
        addTags();
        break;
      case R.id.menu_category:
        categorizeNote();
        break;
      case R.id.menu_share:
        shareNote();
        break;
      case R.id.menu_checklist_on:
      case R.id.menu_checklist_off:
        toggleChecklist();
        break;
      case R.id.menu_checklist_moveToBottom:
        moveCheckedItemsToBottom();
        break;
      case R.id.menu_lock:
      case R.id.menu_unlock:
        lockNote();
        break;
      case R.id.menu_pin_note:
        pinNote();
        break;
      case R.id.menu_add_shortcut:
        addShortcut();
        break;
      case R.id.menu_archive:
        archiveNote(true);
        break;
      case R.id.menu_unarchive:
        archiveNote(false);
        break;
      case R.id.menu_trash:
        trashNote(true);
        break;
      case R.id.menu_untrash:
        trashNote(false);
        break;
      case R.id.menu_discard_changes:
        discard();
        break;
      case R.id.menu_delete:
        deleteNote();
        break;
      case R.id.menu_note_info:
        showNoteInfo();
        break;
      default:
        LogDelegate.w("Invalid menu option selected");
    }
    return super.onOptionsItemSelected(item);
  }
  private void showNoteInfo() {
    noteTmp.setTitle(getNoteTitle());
    noteTmp.setContent(getNoteContent());
    Intent intent = new Intent(getContext(), NoteInfosActivity.class);
    intent.putExtra(INTENT_NOTE, (android.os.Parcelable) noteTmp);
    startActivity(intent);
  }
  private void navigateUp() {
    afterSavedReturnsToList = true;
    saveAndExit();
  }
  private void toggleChecklist() {
    // In case checklist is active a prompt will ask about many options
    // to decide hot to convert back to simple text
    if (Boolean.FALSE.equals(noteTmp.isChecklist())) {
      toggleChecklist2();
      return;
    }
    // If checklist is active but no items are checked the conversion in done automatically
    // without prompting user
    if (mChecklistManager.getCheckedCount() == 0) {
      toggleChecklist2(true, false);
      return;
    }
    // Inflate the popup_layout.XML
    LayoutInflater inflater = (LayoutInflater) mainActivity
        .getSystemService(LAYOUT_INFLATER_SERVICE);
    final View layout = inflater.inflate(R.layout.dialog_remove_checklist_layout,
        getView().findViewById(R.id.layout_root));
    // Retrieves options checkboxes and initialize their values
    final CheckBox keepChecked = layout.findViewById(R.id.checklist_keep_checked);
    final CheckBox keepCheckmarks = layout.findViewById(R.id.checklist_keep_checkmarks);
    keepChecked.setChecked(Prefs.getBoolean(PREF_KEEP_CHECKED, true));
    keepCheckmarks.setChecked(Prefs.getBoolean(PREF_KEEP_CHECKMARKS, true));
    new MaterialDialog.Builder(mainActivity)
        .customView(layout, false)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          Prefs.edit()
              .putBoolean(PREF_KEEP_CHECKED, keepChecked.isChecked())
              .putBoolean(PREF_KEEP_CHECKMARKS, keepCheckmarks.isChecked())
              .apply();
          toggleChecklist2();
        }).build().show();
  }
  private void toggleChecklist2() {
    boolean keepChecked = Prefs.getBoolean(PREF_KEEP_CHECKED, true);
    boolean showChecks = Prefs.getBoolean(PREF_KEEP_CHECKMARKS, true);
    toggleChecklist2(keepChecked, showChecks);
  }
  private void toggleChecklist2(final boolean keepChecked, final boolean showChecks) {
    mChecklistManager = mChecklistManager == null ? new ChecklistManager(mainActivity) : mChecklistManager;
    int checkedItemsBehavior = Integer
        .parseInt(Prefs.getString("settings_checked_items_behavior", String.valueOf
            (it.feio.android.checklistview.Settings.CHECKED_HOLD)));
    mChecklistManager
        .showCheckMarks(showChecks)
        .newEntryHint(getString(R.string.checklist_item_hint))
        .keepChecked(keepChecked)
        .undoBarContainerView(binding.contentWrapper)
        .moveCheckedOnBottom(checkedItemsBehavior);
    // Links parsing options
    mChecklistManager.setOnTextLinkClickListener(textLinkClickListener);
    mChecklistManager.addTextChangedListener(mFragment);
    mChecklistManager.setCheckListChangedListener(mFragment);
    // Switches the views
    View newView = null;
    try {
      newView = mChecklistManager.convert(toggleChecklistView);
    } catch (ViewNotSupportedException e) {
      LogDelegate.e("Error switching checklist view", e);
    }
    // Switches the views
    if (newView != null) {
      mChecklistManager.replaceViews(toggleChecklistView, newView);
      toggleChecklistView = newView;
      animate(toggleChecklistView).alpha(1).scaleXBy(0).scaleX(1).scaleYBy(0).scaleY(1);
      noteTmp.setChecklist(!noteTmp.isChecklist());
    }
  }
  private void moveCheckedItemsToBottom() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      mChecklistManager.moveCheckedToBottom();
    }
  }
  private void categorizeNote() {
    var currentCategory = noteTmp.getCategory() != null ? String.valueOf(noteTmp.getCategory().getId()) : null;
    var  originalCategory = noteOriginal.getCategory() != null ? String.valueOf(noteOriginal.getCategory().getId()) : null;
    final var categories = DbHelper.getInstance().getCategories().stream()
        .map(category -> {
          if (String.valueOf(category.getId()).equals(currentCategory) && currentCategory != originalCategory) {
            category.setCount(category.getCount() + 1);
          }
          if (String.valueOf(category.getId()).equals(originalCategory) && currentCategory != originalCategory) {
            category.setCount(category.getCount() - 1);
          }
          return category;
        }).collect(Collectors.toList());
    var dialogBuilder = new MaterialDialog.Builder(mainActivity)
        .title(R.string.categorize_as)
        .positiveText(R.string.add_category)
        .positiveColorRes(R.color.colorPrimary)
        .negativeText(R.string.remove_category)
        .negativeColorRes(R.color.colorAccent)
        .onPositive((dialog1, which) -> {
          Intent intent = new Intent(mainActivity, CategoryActivity.class);
          intent.putExtra("noHome", true);
          startActivityForResult(intent, CATEGORY);
        })
        .onNegative((dialog12, which) -> {
          noteTmp.setCategory(null);
          setTagMarkerColor(null);
        });
    if (CollectionUtils.isNotEmpty(categories)) {
      dialogBuilder.adapter(new CategoryRecyclerViewAdapter(mainActivity, categories), null);
    }
    final var dialog = dialogBuilder.build();
    if (CollectionUtils.isNotEmpty(categories)) {
      RecyclerViewItemClickSupport.addTo(dialog.getRecyclerView())
          .setOnItemClickListener((recyclerView, position, v) -> {
            noteTmp.setCategory(categories.get(position));
            setTagMarkerColor(categories.get(position));
            dialog.dismiss();
          });
    }
    dialog.show();
  }
  private void showAttachmentsPopup() {
    LayoutInflater inflater = mainActivity.getLayoutInflater();
    final View layout = inflater.inflate(R.layout.attachment_dialog, null);
    attachmentDialog = new MaterialDialog.Builder(mainActivity)
        .autoDismiss(false)
        .customView(layout, false)
        .build();
    attachmentDialog.show();
    // Camera
    android.widget.TextView cameraSelection = layout.findViewById(R.id.camera);
    cameraSelection.setOnClickListener(new AttachmentOnClickListener());
    // Audio recording
    android.widget.TextView recordingSelection = layout.findViewById(R.id.recording);
    toggleAudioRecordingStop(recordingSelection);
    recordingSelection.setOnClickListener(new AttachmentOnClickListener());
    // Video recording
    android.widget.TextView videoSelection = layout.findViewById(R.id.video);
    videoSelection.setOnClickListener(new AttachmentOnClickListener());
    // Files
    android.widget.TextView filesSelection = layout.findViewById(R.id.files);
    filesSelection.setOnClickListener(new AttachmentOnClickListener());
    // Sketch
    android.widget.TextView sketchSelection = layout.findViewById(R.id.sketch);
    sketchSelection.setOnClickListener(new AttachmentOnClickListener());
    // Location
    android.widget.TextView locationSelection = layout.findViewById(R.id.location);
    locationSelection.setOnClickListener(new AttachmentOnClickListener());
    // Time
    android.widget.TextView timeStampSelection = layout.findViewById(R.id.timestamp);
    timeStampSelection.setOnClickListener(new AttachmentOnClickListener());
    // Desktop note with PushBullet
    android.widget.TextView pushbulletSelection = layout.findViewById(R.id.pushbullet);
    pushbulletSelection.setVisibility(View.VISIBLE);
    pushbulletSelection.setOnClickListener(new AttachmentOnClickListener());
  }
  private void takePhoto() {
    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    if (!IntentChecker.isAvailable(mainActivity, intent, new String[]{FEATURE_CAMERA})) {
      mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.ALERT);
      return;
    }
    PermissionsHelper.requestPermission(this, CAMERA,
        R.string.permission_camera, binding.snackbarPlaceholder, () -> {
          // Checks for created file validity
          File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_IMAGE_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          attachmentUri = Uri.fromFile(f);
          intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
          intent.putExtra(MediaStore.EXTRA_OUTPUT, FileProviderHelper.getFileProvider(f));
          startActivityForResult(intent, TAKE_PHOTO);
        });
  }
  private void takeVideo() {
    var takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
    if (!IntentChecker.isAvailable(mainActivity, takeVideoIntent,
        new String[]{FEATURE_CAMERA})) {
      mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.ALERT);
      return;
    }
    PermissionsHelper.requestPermission(this, CAMERA,
        R.string.permission_camera, binding.snackbarPlaceholder, () -> {
          // File is stored in custom ON folder to speedup the attachment
          var f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_VIDEO_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          attachmentUri = Uri.fromFile(f);
          takeVideoIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
          takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, FileProviderHelper.getFileProvider(f));
          var maxVideoSizeStr = "".equals(Prefs.getString("settings_max_video_size", ""))
              ? "0" : Prefs.getString("settings_max_video_size", "");
          long maxVideoSize = parseLong(maxVideoSizeStr) * 1024L * 1024L;
          takeVideoIntent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, maxVideoSize);
          startActivityForResult(takeVideoIntent, TAKE_VIDEO);
        });
  }
  private void takeSketch(Attachment attachment) {
    File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_SKETCH_EXT);
    if (f == null) {
      mainActivity.showMessage(R.string.error, ONStyle.ALERT);
      return;
    }
    attachmentUri = Uri.fromFile(f);
    // Forces portrait orientation to this fragment only
    mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
    // Fragments replacing
    FragmentTransaction transaction = mainActivity.getSupportFragmentManager().beginTransaction();
    mainActivity.animateTransition(transaction, TRANSITION_HORIZONTAL);
    SketchFragment mSketchFragment = new SketchFragment();
    Bundle b = new Bundle();
    b.putParcelable(MediaStore.EXTRA_OUTPUT, attachmentUri);
    if (attachment != null) {
      b.putParcelable("base", attachment.getUri());
    }
    mSketchFragment.setArguments(b);
    transaction.replace(R.id.fragment_container, mSketchFragment, FRAGMENT_SKETCH_TAG)
        .addToBackStack(FRAGMENT_DETAIL_TAG).commit();
  }
  private void addTimestamp() {
    Editable editable = binding.fragmentDetailContent.detailContent.getText();
    int position = binding.fragmentDetailContent.detailContent.getSelectionStart();
    DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
    String dateStamp = dateFormat.format(new Date().getTime()) + " ";
    if (noteTmp.isChecklist()) {
      if (mChecklistManager.getFocusedItemView() != null) {
        editable = mChecklistManager.getFocusedItemView().getEditText().getEditableText();
        position = mChecklistManager.getFocusedItemView().getEditText().getSelectionStart();
      } else {
        ((CheckListView) toggleChecklistView)
            .addItem(dateStamp, false, mChecklistManager.getCount());
      }
    }
    String leadSpace = position == 0 ? "" : " ";
    dateStamp = leadSpace + dateStamp;
    editable.insert(position, dateStamp);
    Selection.setSelection(editable, position + dateStamp.length());
  }
  @SuppressLint("NewApi")
  @Override
  public void onActivityResult(int requestCode, int resultCode, Intent intent) {
    // Fetch uri from activities, store into adapter and refresh adapter
    Attachment attachment;
    if (resultCode == Activity.RESULT_OK) {
      switch (requestCode) {
        case TAKE_PHOTO:
          attachment = new Attachment(attachmentUri, MIME_TYPE_IMAGE);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case TAKE_VIDEO:
          attachment = new Attachment(attachmentUri, MIME_TYPE_VIDEO);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case FILES:
          onActivityResultManageReceivedFiles(intent);
          break;
        case SET_PASSWORD:
          noteTmp.setPasswordChecked(true);
          lockUnlock();
          break;
        case SKETCH:
          attachment = new Attachment(attachmentUri, MIME_TYPE_SKETCH);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case CATEGORY:
          mainActivity.showMessage(R.string.category_saved, ONStyle.CONFIRM);
          Category category = intent.getParcelableExtra("category");
          noteTmp.setCategory(category);
          setTagMarkerColor(category);
          break;
        case DETAIL:
          mainActivity.showMessage(R.string.note_updated, ONStyle.CONFIRM);
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + requestCode);
      }
    }
  }
  private void onActivityResultManageReceivedFiles(Intent intent) {
    List<Uri> uris = new ArrayList<>();
    if (intent.getClipData() != null) {
      for (int i = 0; i < intent.getClipData().getItemCount(); i++) {
        uris.add(intent.getClipData().getItemAt(i).getUri());
      }
    } else {
      uris.add(intent.getData());
    }
    for (Uri uri : uris) {
      String name = FileHelper.getNameFromUri(mainActivity, uri);
      new AttachmentTask(this, uri, name, this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }
  }
  /**
   * Discards changes done to the note and eventually delete new attachments
   */
  private void discard() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.undo_changes_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          if (!noteTmp.getAttachmentsList().equals(note.getAttachmentsList())) {
            for (Attachment newAttachment : noteTmp.getAttachmentsList()) {
              if (!note.getAttachmentsList().contains(newAttachment)) {
                StorageHelper.delete(mainActivity, newAttachment.getUri().getPath());
              }
            }
          }
          goBack = true;
          if (noteTmp.equals(noteOriginal)) {
            goHome();
          }
          if (noteOriginal.get_id() != null) {
            new SaveNoteTask(false).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteOriginal);
            BaseActivity.notifyAppWidgets(mainActivity);
          } else {
            goHome();
          }
        }).build().show();
  }
  @SuppressLint("NewApi")
  private void archiveNote(boolean archive) {
    // Simply go back if is a new note
    if (noteTmp.get_id() == null) {
      goHome();
      return;
    }
    noteTmp.setArchived(archive);
    goBack = true;
    exitMessage = archive ? getString(R.string.note_archived) : getString(R.string.note_unarchived);
    exitCroutonStyle = archive ? ONStyle.WARN : ONStyle.INFO;
    saveNote();
  }
  @SuppressLint("NewApi")
  private void trashNote(boolean trash) {
    // Simply go back if is a new note
    if (noteTmp.get_id() == null) {
      goHome();
      return;
    }
    noteTmp.setTrashed(trash);
    goBack = true;
    exitMessage = trash ? getString(R.string.note_trashed) : getString(R.string.note_untrashed);
    exitCroutonStyle = trash ? ONStyle.WARN : ONStyle.INFO;
    if (trash) {
      ShortcutHelper.removeShortcut(getAppContext(), noteTmp);
      ReminderHelper.removeReminder(getAppContext(), noteTmp);
    } else {
      ReminderHelper.addReminder(getAppContext(), note);
    }
    saveNote();
  }
  private void deleteNote() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.delete_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          mainActivity.deleteNote(noteTmp);
          LogDelegate.d("Deleted note with ID '" + noteTmp.get_id() + "'");
          mainActivity.showMessage(R.string.note_deleted, ONStyle.ALERT);
          goHome();
        }).build().show();
  }
  public void saveAndExit() {
    if (isAdded()) {
      exitMessage = getString(R.string.note_updated);
      exitCroutonStyle = ONStyle.CONFIRM;
      goBack = true;
      saveNote();
    }
  }
  /**
   * Save new notes, modify them or archive
   */
  void saveNote() {
    noteTmp.setTitle(getNoteTitle());
    noteTmp.setContent(getNoteContent());
    // Check if some text or attachments of any type have been inserted or is an empty note
    if (goBack && TextUtils.isEmpty(noteTmp.getTitle()) && TextUtils.isEmpty(noteTmp.getContent())
        && noteTmp.getAttachmentsList().isEmpty()) {
      LogDelegate.d("Empty note not saved");
      exitMessage = getString(R.string.empty_note_not_saved);
      exitCroutonStyle = ONStyle.INFO;
      goHome();
      return;
    }
    if (saveNotNeeded()) {
      exitMessage = "";
      if (goBack) {
        goHome();
      }
      return;
    }
    noteTmp.setAttachmentsListOld(note.getAttachmentsList());
    new SaveNoteTask(lastModificationUpdatedNeeded()).executeOnExecutor(AsyncTask
        .THREAD_POOL_EXECUTOR, noteTmp);
  }
  /**
   * Checks if nothing is changed to avoid committing if possible (check)
   */
  private boolean saveNotNeeded() {
    if (noteTmp.get_id() == null && Prefs.getBoolean(PREF_AUTO_LOCATION, false)) {
      note.setLatitude(noteTmp.getLatitude());
      note.setLongitude(noteTmp.getLongitude());
    }
    return !noteTmp.isChanged(note) || (noteTmp.isLocked() && !noteTmp.isPasswordChecked());
  }
  /**
   * Checks if only tag, archive or trash status have been changed and then force to not update last
   * modification date*
   */
  private boolean lastModificationUpdatedNeeded() {
    note.setCategory(noteTmp.getCategory());
    note.setArchived(noteTmp.isArchived());
    note.setTrashed(noteTmp.isTrashed());
    note.setLocked(noteTmp.isLocked());
    return noteTmp.isChanged(note);
  }
  private void deleteMergedNotes(List<String> mergedNotesIds) {
    ArrayList<Note> notesToDelete = new ArrayList<>();
    if (mergedNotesIds != null) {
      for (String mergedNoteId : mergedNotesIds) {
        Note noteToDelete = new Note();
        noteToDelete.set_id(Long.valueOf(mergedNoteId));
        notesToDelete.add(noteToDelete);
      }
      new NoteProcessorDelete(notesToDelete).process();
    }
  }
  private String getNoteTitle() {
    if (!TextUtils.isEmpty(binding.detailTitle.getText())) {
      return binding.detailTitle.getText().toString();
    } else {
      return "";
    }
  }
  private String getNoteContent() {
    String contentText = "";
    if (Boolean.FALSE.equals(noteTmp.isChecklist())) {
      // Due to checklist library introduction the returned EditText class is no more a
      // com.neopixl.pixlui.components.edittext.EditText but a standard android.widget.EditText
      View contentView = binding.detailRoot.findViewById(R.id.detail_content);
      if (contentView instanceof EditText) {
        contentText = ((EditText) contentView).getText().toString();
      } else if (contentView instanceof android.widget.EditText) {
        contentText = ((android.widget.EditText) contentView).getText().toString();
      }
    } else {
      if (mChecklistManager != null) {
        mChecklistManager.keepChecked(true).showCheckMarks(true);
        contentText = mChecklistManager.getText();
      }
    }
    return contentText;
  }
  /**
   * Updates share intent
   */
  private void shareNote() {
    Note sharedNote = new Note(noteTmp);
    sharedNote.setTitle(getNoteTitle());
    sharedNote.setContent(getNoteContent());
    mainActivity.shareNote(sharedNote);
  }
  /**
   * Notes locking with security password to avoid viewing, editing or deleting from unauthorized
   */
  private void lockNote() {
    LogDelegate.d("Locking or unlocking note " + note.get_id());
    // If security password is not set yes will be set right now
    if (Prefs.getString(PREF_PASSWORD, null) == null) {
      Intent passwordIntent = new Intent(mainActivity, PasswordActivity.class);
      startActivityForResult(passwordIntent, SET_PASSWORD);
      return;
    }
    // If password has already been inserted will not be asked again
    if (noteTmp.isPasswordChecked() || Prefs.getBoolean("settings_password_access", false)) {
      lockUnlock();
      return;
    }
    // Password will be requested here
    PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
      if (passwordConfirmed == Result.SUCCEED) {
        lockUnlock();
      }
    });
  }
  private void lockUnlock() {
    // Empty password has been set
    if (Prefs.getString(PREF_PASSWORD, null) == null) {
      mainActivity.showMessage(R.string.password_not_set, ONStyle.WARN);
      return;
    }
    mainActivity.showMessage(R.string.save_note_to_lock_it, ONStyle.INFO);
    mainActivity.supportInvalidateOptionsMenu();
    noteTmp.setLocked(!noteTmp.isLocked());
    noteTmp.setPasswordChecked(true);
  }
  /**
   * Used to set actual reminder state when initializing a note to be edited
   */
  private String initReminder(Note note) {
    if (noteTmp.getAlarm() == null) {
      return "";
    }
    long reminder = parseLong(note.getAlarm());
    String rrule = note.getRecurrenceRule();
    if (!TextUtils.isEmpty(rrule)) {
      return RecurrenceHelper.getNoteRecurrentReminderText(reminder, rrule);
    } else {
      return RecurrenceHelper.getNoteReminderText(reminder);
    }
  }
  /**
   * Audio recordings playback
   */
  private void playback(View v, Uri uri) {
    // Some recording is playing right now
    if (mPlayer != null && mPlayer.isPlaying()) {
      if (isPlayingView != v) {
        // If the audio actually played is NOT the one from the click view the last one is played
        stopPlaying();
        isPlayingView = v;
        startPlaying(uri);
        replacePlayingAudioBitmap(v);
      } else {
        // Otherwise just stops playing
        stopPlaying();
      }
    } else {
      // If nothing is playing audio just plays
      isPlayingView = v;
      startPlaying(uri);
      replacePlayingAudioBitmap(v);
    }
  }
  private void replacePlayingAudioBitmap(View v) {
    Drawable d = ((ImageView) v.findViewById(R.id.gridview_item_picture)).getDrawable();
    if (BitmapDrawable.class.isAssignableFrom(d.getClass())) {
      recordingBitmap = ((BitmapDrawable) d).getBitmap();
    } else {
      recordingBitmap = ((BitmapDrawable) d.getCurrent()).getBitmap();
    }
    ((ImageView) v.findViewById(R.id.gridview_item_picture)).setImageBitmap(ThumbnailUtils
        .extractThumbnail(BitmapFactory.decodeResource(mainActivity.getResources(),
            R.drawable.stop), THUMBNAIL_SIZE, THUMBNAIL_SIZE));
  }
  private void startPlaying(Uri uri) {
    if (mPlayer == null) {
      mPlayer = new MediaPlayer();
    }
    try {
      mPlayer.setDataSource(mainActivity, uri);
      mPlayer.prepare();
      mPlayer.start();
      mPlayer.setOnCompletionListener(mp -> {
        mPlayer = null;
        if (isPlayingView != null) {
          ((ImageView) isPlayingView.findViewById(R.id.gridview_item_picture)).setImageBitmap
              (recordingBitmap);
          recordingBitmap = null;
          isPlayingView = null;
        }
      });
    } catch (IOException e) {
      LogDelegate.e("prepare() failed", e);
      mainActivity.showMessage(R.string.error, ONStyle.ALERT);
    }
  }
  private void stopPlaying() {
    if (mPlayer != null) {
      if (isPlayingView != null) {
        ((ImageView) isPlayingView.findViewById(R.id.gridview_item_picture))
            .setImageBitmap(recordingBitmap);
      }
      isPlayingView = null;
      recordingBitmap = null;
      mPlayer.release();
      mPlayer = null;
    }
  }
  private void startRecording(View v) {
    PermissionsHelper.requestPermission(this, Manifest.permission.RECORD_AUDIO,
        R.string.permission_audio_recording, binding.snackbarPlaceholder, () -> {
          isRecording = true;
          toggleAudioRecordingStop(v);
          File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_AUDIO_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          if (mRecorder == null) {
            mRecorder = new MediaRecorder();
            mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
            mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
            mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);
            mRecorder.setAudioEncodingBitRate(96000);
            mRecorder.setAudioSamplingRate(44100);
          }
          recordName = f.getAbsolutePath();
          mRecorder.setOutputFile(recordName);
          try {
            audioRecordingTimeStart = Calendar.getInstance().getTimeInMillis();
            mRecorder.prepare();
            mRecorder.start();
          } catch (IOException | IllegalStateException e) {
            LogDelegate.e("prepare() failed", e);
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
          }
        });
  }
  private void toggleAudioRecordingStop(View v) {
    if (isRecording) {
      ((android.widget.TextView) v).setText(getString(R.string.stop));
      ((android.widget.TextView) v).setTextColor(Color.parseColor("#ff0000"));
    }
  }
  private void stopRecording() {
    isRecording = false;
    if (mRecorder != null) {
      mRecorder.stop();
      audioRecordingTime = Calendar.getInstance().getTimeInMillis() - audioRecordingTimeStart;
      mRecorder.release();
      mRecorder = null;
    }
  }
  private void fade(final View v, boolean fadeIn) {
    int anim = R.animator.fade_out_support;
    int visibilityTemp = View.GONE;
    if (fadeIn) {
      anim = R.animator.fade_in_support;
      visibilityTemp = View.VISIBLE;
    }
    final int visibility = visibilityTemp;
    // Checks if user has left the app
    if (mainActivity != null) {
      Animation mAnimation = AnimationUtils.loadAnimation(mainActivity, anim);
      mAnimation.setAnimationListener(new AnimationListener() {
        @Override
        public void onAnimationStart(Animation animation) {
          // Nothing to do
        }
        @Override
        public void onAnimationRepeat(Animation animation) {
          // Nothing to do
        }
        @Override
        public void onAnimationEnd(Animation animation) {
          v.setVisibility(visibility);
        }
      });
      v.startAnimation(mAnimation);
    }
  }
  /**
   * Pin note as ongoing notifications
   */
  private void pinNote() {
    if (!new NotificationsHelper(getAppContext()).checkNotificationsEnabled(getAppContext())) {
      mainActivity.showToast(getText(R.string.denied_notifications_permission), Toast.LENGTH_LONG);
      return;
    }
    
    PendingIntent notifyIntent = IntentHelper
        .getNotePendingIntent(getContext(), SnoozeActivity.class, ACTION_PINNED, note);
    Spanned[] titleAndContent = TextHelper.parseTitleAndContent(getContext(), note);
    String pinnedTitle = titleAndContent[0].toString();
    String pinnedContent = titleAndContent[1].toString();
    NotificationsHelper notificationsHelper = new NotificationsHelper(getContext());
    notificationsHelper
        .createOngoingNotification(NotificationChannelNames.PINNED, R.drawable.ic_stat_notification,
            pinnedTitle, notifyIntent).setMessage(pinnedContent);
    List<Attachment> attachments = note.getAttachmentsList();
    if (!attachments.isEmpty() && !attachments.get(0).getMime_type().equals(MIME_TYPE_FILES)) {
      Bitmap notificationIcon = BitmapHelper
          .getBitmapFromAttachment(getContext(), note.getAttachmentsList().get(0), 128,
              128);
      notificationsHelper.setLargeIcon(notificationIcon);
    }
    PendingIntent unpinIntent = IntentHelper
        .getNotePendingIntent(getContext(), SnoozeActivity.class, ACTION_DISMISS, note);
    notificationsHelper.getBuilder()
        .addAction(R.drawable.ic_material_reminder_time_light, getContext().getString(R.string.done), unpinIntent);
    notificationsHelper.show(note.get_id());
  }
  /**
   * Adding shortcut on Home screen
   */
  private void addShortcut() {
    ShortcutHelper.addShortcut(getAppContext(), noteTmp);
    mainActivity.showMessage(R.string.shortcut_added, ONStyle.INFO);
  }
  @SuppressLint("NewApi")
  @Override
  public boolean onTouch(View v, MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();
    switch (event.getAction()) {
      case MotionEvent.ACTION_DOWN:
        LogDelegate.v("MotionEvent.ACTION_DOWN");
        int w;
        Point displaySize = Display.getUsableSize(mainActivity);
        w = displaySize.x;
        if (x < SWIPE_MARGIN || x > w - SWIPE_MARGIN) {
          swiping = true;
          startSwipeX = x;
        }
        break;
      case MotionEvent.ACTION_UP:
        LogDelegate.v("MotionEvent.ACTION_UP");
        if (swiping) {
          swiping = false;
        }
        break;
      case MotionEvent.ACTION_MOVE:
        if (swiping) {
          LogDelegate.v("MotionEvent.ACTION_MOVE at position " + x + ", " + y);
          if (Math.abs(x - startSwipeX) > SWIPE_OFFSET) {
            swiping = false;
            FragmentTransaction transaction = mainActivity.getSupportFragmentManager()
                .beginTransaction();
            mainActivity.animateTransition(transaction, TRANSITION_VERTICAL);
            DetailFragment mDetailFragment = new DetailFragment();
            Bundle b = new Bundle();
            b.putParcelable(INTENT_NOTE, new Note());
            mDetailFragment.setArguments(b);
            transaction.replace(R.id.fragment_container, mDetailFragment, FRAGMENT_DETAIL_TAG)
                .addToBackStack(
                    FRAGMENT_DETAIL_TAG).commit();
          }
        }
        break;
      default:
        LogDelegate.e("Wrong element choosen: " + event.getAction());
    }
    return true;
  }
  @Override
  public void onAttachingFileErrorOccurred(Attachment mAttachment) {
    mainActivity.showMessage(R.string.error_saving_attachments, ONStyle.ALERT);
    if (noteTmp.getAttachmentsList().contains(mAttachment)) {
      removeAttachment(mAttachment);
      mAttachmentAdapter.notifyDataSetChanged();
      mGridView.autoresize();
    }
  }
  private void addAttachment(Attachment attachment) {
    noteTmp.addAttachment(attachment);
  }
  private void removeAttachment(Attachment mAttachment) {
    noteTmp.removeAttachment(mAttachment);
  }
  private void removeAttachment(int position) {
    noteTmp.removeAttachment(noteTmp.getAttachmentsList().get(position));
  }
  private void removeAllAttachments() {
    noteTmp.setAttachmentsList(new ArrayList<>());
    mAttachmentAdapter = new AttachmentAdapter(mainActivity, new ArrayList<>());
    mGridView.invalidateViews();
    mGridView.setAdapter(mAttachmentAdapter);
  }
  @Override
  public void onAttachingFileFinished(Attachment mAttachment) {
    addAttachment(mAttachment);
    mAttachmentAdapter.notifyDataSetChanged();
    mGridView.autoresize();
  }
  @Override
  public void onReminderPicked(long reminder) {
    noteTmp.setAlarm(reminder);
    if (mFragment.isAdded()) {
      binding.fragmentDetailContent.reminderIcon.setImageResource(R.drawable.ic_alarm_black_18dp);
      binding.fragmentDetailContent.datetime
          .setText(RecurrenceHelper.getNoteReminderText(reminder));
    }
  }
  @Override
  public void onRecurrenceReminderPicked(String recurrenceRule) {
    noteTmp.setRecurrenceRule(recurrenceRule);
    if (!TextUtils.isEmpty(recurrenceRule)) {
      LogDelegate.d("Recurrent reminder set: " + recurrenceRule);
      binding.fragmentDetailContent.datetime.setText(RecurrenceHelper
          .getNoteRecurrentReminderText(Long.parseLong(noteTmp.getAlarm()), recurrenceRule));
    }
  }
  @Override
  public void onTextChanged(CharSequence s, int start, int before, int count) {
    scrollContent();
  }
  @Override
  public void beforeTextChanged(CharSequence s, int start, int count, int after) {
    // Nothing to do
  }
  @Override
  public void afterTextChanged(Editable s) {
    // Nothing to do
  }
  @Override
  public void onCheckListChanged() {
    scrollContent();
  }
  private void scrollContent() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      if (mChecklistManager.getCount() > contentLineCounter) {
        binding.contentWrapper.scrollBy(0, 60);
      }
      contentLineCounter = mChecklistManager.getCount();
    } else {
      if (binding.fragmentDetailContent.detailContent.getLineCount() > contentLineCounter) {
        binding.contentWrapper.scrollBy(0, 60);
      }
      contentLineCounter = binding.fragmentDetailContent.detailContent.getLineCount();
    }
  }
  /**
   * Add previously created tags to content
   */
  private void addTags() {
    contentCursorPosition = getCursorIndex();
    final List<Tag> tags = TagsHelper.getAllTags();
    if (tags.isEmpty()) {
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    final Note currentNote = new Note();
    currentNote.setTitle(getNoteTitle());
    currentNote.setContent(getNoteContent());
    Integer[] preselectedTags = TagsHelper.getPreselectedTagsArray(currentNote, tags);
    // Dialog and events creation
    MaterialDialog dialog = new MaterialDialog.Builder(mainActivity)
        .title(R.string.select_tags)
        .positiveText(R.string.ok)
        .items(TagsHelper.getTagsArray(tags))
        .itemsCallbackMultiChoice(preselectedTags, (dialog1, which, text) -> {
          dialog1.dismiss();
          tagNote(tags, which, currentNote);
          return false;
        }).build();
    dialog.show();
  }
  private void tagNote(List<Tag> tags, Integer[] selectedTags, Note note) {
    var taggingResult = TagsHelper.addTagToNote(tags, selectedTags, note);
    if (!taggingResult.first.isEmpty()) {
      if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
        tagChecklistNote(taggingResult);
      } else {
        tagTextNote(taggingResult);
      }
    }
    eventuallyRemoveDeselectedTags(taggingResult.second);
  }
  private void tagTextNote(Pair<String, List<Tag>> taggingResult) {
    var sb = new StringBuilder(getNoteContent());
    var detailContent = binding.fragmentDetailContent.detailContent;
    if (detailContent.hasFocus()) {
      if (!taggingResult.first.isEmpty()) {
        sb.insert(contentCursorPosition, " " + taggingResult.first + " ");
      }
      detailContent.setText(sb.toString());
      detailContent.setSelection(contentCursorPosition + taggingResult.first.length() + 1);
    } else {
      if (!getNoteContent().trim().isEmpty()) {
        sb.append(System.getProperty("line.separator")).append(System.getProperty("line.separator"));
      }
      sb.append(taggingResult.first);
      detailContent.setText(sb.toString());
    }
  }
  private void tagChecklistNote(Pair<String, List<Tag>> taggingResult) {
    StringBuilder sb;
    var checkListItem = mChecklistManager.getFocusedItemView();
    if (checkListItem != null) {
      sb = new StringBuilder(checkListItem.getText());
      if (!taggingResult.first.isEmpty()) {
        sb.insert(contentCursorPosition, " " + taggingResult.first + " ");
      }
      checkListItem.setText(sb.toString());
      checkListItem.getEditText().setSelection(contentCursorPosition + taggingResult.first.length() + 1);
    } else {
      binding.detailTitle.append(" " + taggingResult.first);
    }
  }
  private void eventuallyRemoveDeselectedTags(List<Tag> tagsToRemove) {
    if (CollectionUtils.isEmpty(tagsToRemove)) {
      return;
    }
    boolean currentlyChecklist = Boolean.TRUE.equals(noteTmp.isChecklist());
    if (currentlyChecklist) {
      toggleChecklist2(true, true);
    }
    String titleWithoutTags = TagsHelper.removeTags(getNoteTitle(), tagsToRemove);
    binding.detailTitle.setText(titleWithoutTags);
    String contentWithoutTags = TagsHelper.removeTags(getNoteContent(), tagsToRemove);
    binding.fragmentDetailContent.detailContent.setText(contentWithoutTags);
    if (currentlyChecklist) {
      toggleChecklist2();
    }
  }
  private int getCursorIndex() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      CheckListViewItem mCheckListViewItem = mChecklistManager.getFocusedItemView();
      return mCheckListViewItem != null ? mCheckListViewItem.getEditText().getSelectionStart() : 0;
    } else {
      return binding.fragmentDetailContent.detailContent.getSelectionStart();
    }
  }
  /**
   * Used to check currently opened note from activity to avoid opening multiple times the same one
   */
  public Note getCurrentNote() {
    return note;
  }
  private boolean isNoteLocationValid() {
    return noteTmp.getLatitude() != null
        && noteTmp.getLatitude() != 0
        && noteTmp.getLongitude() != null
        && noteTmp.getLongitude() != 0;
  }
  public void startGetContentAction() {
    Intent filesIntent;
    filesIntent = new Intent(Intent.ACTION_GET_CONTENT);
    filesIntent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);
    filesIntent.addCategory(Intent.CATEGORY_OPENABLE);
    filesIntent.setType("*/*");
    startActivityForResult(filesIntent, FILES);
  }
  public void onEventMainThread(PushbulletReplyEvent pushbulletReplyEvent) {
    String text =
        getNoteContent() + System.getProperty("line.separator") + pushbulletReplyEvent.getMessage();
    binding.fragmentDetailContent.detailContent.setText(text);
  }
  public void onEvent(NotesUpdatedEvent event) {
    if (!activityPausing) {
      deleteMergedNotes(mergedNotesIds);
      if (noteTmp.getAlarm() != null && !noteTmp.getAlarm().equals(note.getAlarm())) {
        ReminderHelper.showReminderMessage(String.valueOf(noteTmp.getAlarm()));
      }
    }
    note = new Note(event.getNotes().get(0));
    if (goBack) {
      goHome();
    }
  }
  private static class OnGeoUtilResultListenerImpl implements OnGeoUtilResultListener {
    private final WeakReference<MainActivity> mainActivityWeakReference;
    private final WeakReference<DetailFragment> detailFragmentWeakReference;
    private final WeakReference<Note> noteTmpWeakReference;
    OnGeoUtilResultListenerImpl(MainActivity activity, DetailFragment mFragment, Note noteTmp) {
      mainActivityWeakReference = new WeakReference<>(activity);
      detailFragmentWeakReference = new WeakReference<>(mFragment);
      noteTmpWeakReference = new WeakReference<>(noteTmp);
    }
    @Override
    public void onAddressResolved(String address) {
      // Nothing to do
    }
    @Override
    public void onCoordinatesResolved(Location location, String address) {
      // Nothing to do
    }
    @Override
    public void onLocationUnavailable() {
      mainActivityWeakReference.get().showMessage(R.string.location_not_found, ONStyle.ALERT);
    }
    @Override
    public void onLocationNotEnabled(){
      mainActivityWeakReference.get().showMessage(R.string.location_not_enabled,ONStyle.ALERT);
    }
    @Override
    public void onLocationRetrieved(Location location) {
      if (!checkWeakReferences()) {
        return;
      }
      if (location == null) {
        return;
      }
      LayoutInflater inflater = mainActivityWeakReference.get().getLayoutInflater();
      View v = inflater.inflate(R.layout.dialog_location, null);
      final AutoCompleteTextView autoCompView = v.findViewById(R.id
          .auto_complete_location);
      autoCompView.setHint(mainActivityWeakReference.get().getString(R.string.search_location));
      autoCompView
          .setAdapter(new PlacesAutoCompleteAdapter(mainActivityWeakReference.get(), R.layout
              .simple_text_layout));
      final MaterialDialog dialog = new MaterialDialog.Builder(mainActivityWeakReference.get())
          .customView(autoCompView, false)
          .positiveText(R.string.use_current_location)
          .onPositive((dialog1, which) -> {
            if (TextUtils.isEmpty(autoCompView.getText().toString())) {
              noteTmpWeakReference.get().setLatitude(location.getLatitude());
              noteTmpWeakReference.get().setLongitude(location.getLongitude());
              GeocodeHelper.getAddressFromCoordinates(location, detailFragmentWeakReference.get());
            } else {
              GeocodeHelper.getCoordinatesFromAddress(autoCompView.getText().toString(),
                  detailFragmentWeakReference.get());
            }
          })
          .build();
      autoCompView.addTextChangedListener(new TextWatcher() {
        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
          // Nothing to do
        }
        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
          if (s.length() != 0) {
            dialog
                .setActionButton(DialogAction.POSITIVE, mainActivityWeakReference.get().getString(R
                    .string.confirm));
          } else {
            dialog
                .setActionButton(DialogAction.POSITIVE, mainActivityWeakReference.get().getString(R
                    .string
                    .use_current_location));
          }
        }
        @Override
        public void afterTextChanged(Editable s) {
          // Nothing to do
        }
      });
      dialog.show();
    }
    private boolean checkWeakReferences() {
      return mainActivityWeakReference.get() != null && !mainActivityWeakReference.get()
          .isFinishing()
          && detailFragmentWeakReference.get() != null && noteTmpWeakReference.get() != null;
    }
  }
  /**
   * Manages clicks on attachment dialog
   */
  @SuppressLint("InlinedApi")
  private class AttachmentOnClickListener implements OnClickListener {
    @Override
    public void onClick(View v) {
      switch (v.getId()) {
        case R.id.camera:
//          requestCameraPermission(TAKE_PHOTO);
          takePhoto();
          break;
        case R.id.recording:
          if (!isRecording) {
            startRecording(v);
          } else {
            stopRecording();
            Attachment attachment = new Attachment(Uri.fromFile(new File(recordName)),
                MIME_TYPE_AUDIO);
            attachment.setLength(audioRecordingTime);
            addAttachment(attachment);
            mAttachmentAdapter.notifyDataSetChanged();
            mGridView.autoresize();
          }
          break;
        case R.id.video:
          takeVideo();
          break;
        case R.id.files:
          startGetContentAction();
          break;
        case R.id.sketch:
          takeSketch(null);
          break;
        case R.id.location:
          displayLocationDialog();
          break;
        case R.id.timestamp:
          addTimestamp();
          break;
        case R.id.pushbullet:
          MessagingExtension.mirrorMessage(mainActivity, getString(R.string.app_name),
              getString(R.string.pushbullet),
              getNoteContent(), BitmapFactory.decodeResource(getResources(),
                  R.drawable.ic_stat_literal_icon),
              null, 0);
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + v.getId());
      }
      if (!isRecording) {
        attachmentDialog.dismiss();
      }
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import static android.text.Html.fromHtml;
import static android.text.TextUtils.isEmpty;
import static androidx.core.view.ViewCompat.animate;
import static it.feio.android.omninotes.helpers.BuildHelper.isDebugBuild;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_FAB_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_MERGE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_POSTPONE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SEARCH_UNCOMPLETE_CHECKLISTS;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_SHOW_LIST;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_CATEGORY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.MENU_SORT_GROUP_ID;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_ENABLE_SWIPE;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_EXPANDED_VIEW;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FAB_EXPANSION_BEHAVIOR;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FILTER_ARCHIVED_IN_CATEGORIES;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FILTER_PAST_REMINDERS;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_SORTING_COLUMN;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_WIDGET_PREFIX;
import static it.feio.android.omninotes.utils.Navigation.checkNavigation;
import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.drawable.AnimationDrawable;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Parcelable;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MenuItem.OnActionExpandListener;
import android.view.MotionEvent;
import android.view.SubMenu;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.EditorInfo;
import android.widget.ImageView;
import android.widget.LinearLayout;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.view.ActionMode;
import androidx.appcompat.widget.SearchView;
import androidx.appcompat.widget.SearchView.OnQueryTextListener;
import androidx.core.util.Pair;
import androidx.core.view.GravityCompat;
import androidx.recyclerview.widget.DefaultItemAnimator;
import androidx.recyclerview.widget.DividerItemDecoration;
import androidx.recyclerview.widget.ItemTouchHelper;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import com.afollestad.materialdialogs.MaterialDialog;
import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Crouton;
import de.keyboardsurfer.android.widget.crouton.Style;
import it.feio.android.omninotes.async.bus.CategoriesUpdatedEvent;
import it.feio.android.omninotes.async.bus.NavigationUpdatedNavDrawerClosedEvent;
import it.feio.android.omninotes.async.bus.NotesLoadedEvent;
import it.feio.android.omninotes.async.bus.NotesMergeEvent;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import it.feio.android.omninotes.async.bus.PasswordRemovedEvent;
import it.feio.android.omninotes.async.notes.NoteLoaderTask;
import it.feio.android.omninotes.async.notes.NoteProcessorArchive;
import it.feio.android.omninotes.async.notes.NoteProcessorCategorize;
import it.feio.android.omninotes.async.notes.NoteProcessorDelete;
import it.feio.android.omninotes.async.notes.NoteProcessorTrash;
import it.feio.android.omninotes.databinding.FragmentListBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.NotesHelper;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.PasswordValidator;
import it.feio.android.omninotes.models.Tag;
import it.feio.android.omninotes.models.UndoBarController;
import it.feio.android.omninotes.models.adapters.CategoryRecyclerViewAdapter;
import it.feio.android.omninotes.models.adapters.NoteAdapter;
import it.feio.android.omninotes.models.listeners.OnViewTouchedListener;
import it.feio.android.omninotes.models.listeners.RecyclerViewItemClickSupport;
import it.feio.android.omninotes.models.views.Fab;
import it.feio.android.omninotes.utils.AnimationsHelper;
import it.feio.android.omninotes.utils.IntentChecker;
import it.feio.android.omninotes.utils.KeyboardUtils;
import it.feio.android.omninotes.utils.Navigation;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.TagsHelper;
import it.feio.android.omninotes.utils.TextHelper;
import it.feio.android.pixlui.links.UrlCompleter;
import it.feio.android.simplegallery.util.BitmapUtils;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.stream.IntStream;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.ObjectUtils;
public class ListFragment extends BaseFragment implements OnViewTouchedListener,
    UndoBarController.UndoListener {
  private static final int REQUEST_CODE_CATEGORY = 1;
  private static final int REQUEST_CODE_CATEGORY_NOTES = 2;
  private static final int REQUEST_CODE_ADD_ALARMS = 3;
  public static final String LIST_VIEW_POSITION = "listViewPosition";
  public static final String LIST_VIEW_POSITION_OFFSET = "listViewPositionOffset";
  private FragmentListBinding binding;
  private final List<Note> selectedNotes = new ArrayList<>();
  private SearchView searchView;
  private MenuItem searchMenuItem;
  private Menu menu;
  private AnimationDrawable jinglesAnimation;
  private int listViewPosition;
  private int listViewPositionOffset = 16;
  private boolean sendToArchive;
  private ListFragment mFragment;
  private ActionMode actionMode;
  private boolean keepActionMode = false;
  // Undo archive/trash
  private boolean undoTrash = false;
  private boolean undoArchive = false;
  private boolean undoCategorize = false;
  private Category undoCategorizeCategory = null;
  private final SortedMap<Integer, Note> undoNotesMap = new TreeMap<>();
  // Used to remember removed categories from notes
  private final Map<Note, Category> undoCategoryMap = new HashMap<>();
  // Used to remember archived state from notes
  private final Map<Note, Boolean> undoArchivedMap = new HashMap<>();
  // Search variables
  private String searchQuery;
  private String searchQueryInstant;
  private String searchTags;
  private boolean searchUncompleteChecklists;
  private boolean goBackOnToggleSearchLabel = false;
  private boolean searchLabelActive = false;
  private NoteAdapter listAdapter;
  private UndoBarController ubc;
  private Fab fab;
  private MainActivity mainActivity;
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mFragment = this;
    setHasOptionsMenu(true);
    setRetainInstance(true);
    EventBus.getDefault().register(this, 1);
  }
  @Override
  public void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
  }
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
      Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      if (savedInstanceState.containsKey(LIST_VIEW_POSITION)) {
        listViewPosition = savedInstanceState.getInt(LIST_VIEW_POSITION);
        listViewPositionOffset = savedInstanceState.getInt(LIST_VIEW_POSITION_OFFSET);
        searchQuery = savedInstanceState.getString("searchQuery");
        searchTags = savedInstanceState.getString("searchTags");
      }
      keepActionMode = false;
    }
    binding = FragmentListBinding.inflate(inflater, container, false);
    View view = binding.getRoot();
    binding.list.setHasFixedSize(true);
    LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getContext());
    binding.list.setLayoutManager(linearLayoutManager);
    DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(
        binding.list.getContext(),
        linearLayoutManager.getOrientation());
    dividerItemDecoration
        .setDrawable(getResources().getDrawable(R.drawable.fragment_list_item_divider));
    binding.list.addItemDecoration(dividerItemDecoration);
    RecyclerView.ItemAnimator itemAnimator = new DefaultItemAnimator();
    itemAnimator.setAddDuration(1000);
    itemAnimator.setRemoveDuration(1000);
    binding.list.setItemAnimator(itemAnimator);
    // Replace listview with Mr. Jingles if it is empty
    binding.list.setEmptyView(binding.emptyList);
    return view;
  }
  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    mainActivity = (MainActivity) getActivity();
    if (mainActivity!= null && savedInstanceState != null) {
      mainActivity.navigationTmp = savedInstanceState.getString("navigationTmp");
    }
    init();
  }
  private void init() {
    initEasterEgg();
    initListView();
    ubc = new UndoBarController(binding.undobar.getRoot(), this);
    initNotesList(mainActivity.getIntent());
    initFab();
    initTitle();
  }
  private void initFab() {
    fab = new Fab(binding.fab.getRoot(), binding.list,
        Prefs.getBoolean(PREF_FAB_EXPANSION_BEHAVIOR, false));
    fab.setOnFabItemClickedListener(id -> {
      View v = mainActivity.findViewById(id);
      switch (id) {
        case R.id.fab_camera:
          Intent i = mainActivity.getIntent();
          i.setAction(ACTION_FAB_TAKE_PHOTO);
          mainActivity.setIntent(i);
          editNote(new Note(), v);
          break;
        case R.id.fab_checklist:
          Note note = new Note();
          note.setChecklist(true);
          editNote(note, v);
          break;
        default:
          editNote(new Note(), v);
      }
    });
  }
  boolean closeFab() {
    if (fab != null && fab.isExpanded()) {
      fab.performToggle();
      return true;
    }
    return false;
  }
  /**
   * Activity title initialization based on navigation
   */
  private void initTitle() {
    String[] navigationList = getResources().getStringArray(R.array.navigation_list);
    String[] navigationListCodes = getResources().getStringArray(R.array.navigation_list_codes);
    String navigation = mainActivity.navigationTmp != null
        ? mainActivity.navigationTmp
        : Prefs.getString (PREF_NAVIGATION, navigationListCodes[0]);
    int index = Arrays.asList(navigationListCodes).indexOf(navigation);
    String title;
    // If is a traditional navigation item
    if (index >= 0 && index < navigationListCodes.length) {
      title = navigationList[index];
    } else {
      Category category = DbHelper.getInstance().getCategory(Long.parseLong(navigation));
      title = category != null ? category.getName() : "";
    }
    title = title == null ? getString(R.string.title_activity_list) : title;
    mainActivity.setActionBarTitle(title);
  }
  /**
   * Starts a little animation on Mr.Jingles!
   */
  private void initEasterEgg() {
    binding.emptyList.setOnClickListener(v -> {
      if (jinglesAnimation == null) {
        jinglesAnimation = (AnimationDrawable) binding.emptyList.getCompoundDrawables()[1];
        binding.emptyList.post(() -> {
          if (jinglesAnimation != null) {
            jinglesAnimation.start();
          }
        });
      } else {
        stopJingles();
      }
    });
  }
  private void stopJingles() {
    if (jinglesAnimation != null) {
      jinglesAnimation.stop();
      jinglesAnimation = null;
      binding.emptyList
          .setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.jingles_animation, 0, 0);
    }
  }
  @Override
  public void onPause() {
    super.onPause();
    searchQueryInstant = searchQuery;
    stopJingles();
    Crouton.cancelAllCroutons();
    closeFab();
    if (!keepActionMode) {
      commitPending();
      if (getActionMode() != null) {
        getActionMode().finish();
      }
    }
  }
  @Override
  public void onSaveInstanceState(@NonNull Bundle outState) {
    super.onSaveInstanceState(outState);
    refreshListScrollPosition();
    outState.putInt("listViewPosition", listViewPosition);
    outState.putInt(LIST_VIEW_POSITION_OFFSET, listViewPositionOffset);
    outState.putString("searchQuery", searchQuery);
    outState.putString("searchTags", searchTags);
  }
  private void refreshListScrollPosition() {
    if(binding != null) {
      listViewPosition = ((LinearLayoutManager) binding.list.getLayoutManager())
          .findFirstVisibleItemPosition();
      View v = binding.list.getChildAt(0);
      listViewPositionOffset =
          (v == null) ? (int) getResources().getDimension(R.dimen.vertical_margin) : v.getTop();
    }
  }
  @Override
  public void onResume() {
    super.onResume();
    if (mainActivity.prefsChanged) {
      mainActivity.prefsChanged = false;
      init();
    } else if (Intent.ACTION_SEARCH.equals(mainActivity.getIntent().getAction())) {
      initNotesList(mainActivity.getIntent());
    }
  }
  private final class ModeCallback implements ActionMode.Callback {
    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
      // Inflate the menu for the CAB
      MenuInflater inflater = mode.getMenuInflater();
      inflater.inflate(R.menu.menu_list, menu);
      actionMode = mode;
      fab.setAllowed(isFabAllowed());
      fab.hideFab();
      return true;
    }
    @Override
    public void onDestroyActionMode(ActionMode mode) {
      // Here you can make any necessary updates to the activity when
      // the CAB is removed. By default, selected items are
      // deselected/unchecked.
      for (int i = 0; i < listAdapter.getSelectedItems().size(); i++) {
        int key = listAdapter.getSelectedItems().keyAt(i);
      }
      selectedNotes.clear();
      listAdapter.clearSelectedItems();
      listAdapter.notifyDataSetChanged();
      fab.setAllowed(isFabAllowed(true));
      if (undoNotesMap.size() == 0) {
        fab.showFab();
      }
      actionMode = null;
      LogDelegate.d("Closed multiselection contextual menu");
    }
    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
      prepareActionModeMenu();
      return true;
    }
    @Override
    public boolean onActionItemClicked(final ActionMode mode, final MenuItem item) {
      Integer[] protectedActions = {R.id.menu_select_all, R.id.menu_merge};
      if (!Arrays.asList(protectedActions).contains(item.getItemId())) {
        mainActivity.requestPassword(mainActivity, getSelectedNotes(),
            passwordConfirmed -> {
              if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                performAction(item, mode);
              }
            });
      } else {
        performAction(item, mode);
      }
      return true;
    }
  }
  public void finishActionMode() {
    if (getActionMode() != null) {
      getActionMode().finish();
    }
  }
  /**
   * Manage check/uncheck of notes in list during multiple selection phase
   */
  private void toggleListViewItem(View view, int position) {
    Note note = listAdapter.getItem(position);
    LinearLayout cardLayout = view.findViewById(R.id.card_layout);
    if (!getSelectedNotes().contains(note)) {
      getSelectedNotes().add(note);
      listAdapter.addSelectedItem(position);
      cardLayout.setBackgroundColor(getResources().getColor(R.color.list_bg_selected));
    } else {
      getSelectedNotes().remove(note);
      listAdapter.removeSelectedItem(position);
      listAdapter.restoreDrawable(note, cardLayout);
    }
    prepareActionModeMenu();
    if (getSelectedNotes().isEmpty()) {
      finishActionMode();
    }
  }
  /**
   * Notes list initialization. Data, actions and callback are defined here.
   */
  private void initListView() {
    // Note long click to start CAB mode
    RecyclerViewItemClickSupport.addTo(binding.list)
        // Note single click listener managed by the activity itself
        .setOnItemClickListener((recyclerView, position, view) -> {
          if (getActionMode() == null) {
            editNote(listAdapter.getItem(position), view);
            return;
          }
          // If in CAB mode
          toggleListViewItem(view, position);
          setCabTitle();
        }).setOnItemLongClickListener((recyclerView, position, view) -> {
      if (getActionMode() != null) {
        return false;
      }
      // Start the CAB using the ActionMode.Callback defined above
      mainActivity.startSupportActionMode(new ModeCallback());
      toggleListViewItem(view, position);
      setCabTitle();
      return true;
    });
    binding.listRoot.setOnViewTouchedListener(this);
  }
  /**
   * Retrieves from the single listview note item the element to be zoomed when opening a note
   */
  private ImageView getZoomListItemView(View view, Note note) {
    View targetView = null;
    if (!note.getAttachmentsList().isEmpty()) {
      targetView = view.findViewById(R.id.attachmentThumbnail);
    }
    if (targetView == null && note.getCategory() != null) {
      targetView = view.findViewById(R.id.category_marker);
    }
    if (targetView == null) {
      targetView = new ImageView(mainActivity);
      targetView.setBackgroundColor(Color.WHITE);
    }
    targetView.setDrawingCacheEnabled(true);
    targetView.buildDrawingCache();
    Bitmap bmp = targetView.getDrawingCache();
    binding.expandedImage.setBackgroundColor(BitmapUtils.getDominantColor(bmp));
    return binding.expandedImage;
  }
  /**
   * Listener that fires note opening once the zooming animation is finished
   */
  private AnimatorListenerAdapter buildAnimatorListenerAdapter(final Note note) {
    return new AnimatorListenerAdapter() {
      @Override
      public void onAnimationEnd(Animator animation) {
        editNote2(note);
      }
    };
  }
  @Override
  public void onViewTouchOccurred(MotionEvent ev) {
    LogDelegate.v("Notes list: onViewTouchOccurred " + ev.getAction());
    commitPending();
  }
  @Override
  public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
    inflater.inflate(R.menu.menu_list, menu);
    super.onCreateOptionsMenu(menu, inflater);
    this.menu = menu;
    initSearchView(menu);
  }
  private void initSortingSubmenu() {
    final String[] arrayDb = getResources().getStringArray(R.array.sortable_columns);
    final String[] arrayDialog = getResources()
        .getStringArray(R.array.sortable_columns_human_readable);
    int selected = Arrays.asList(arrayDb).indexOf(Prefs.getString(PREF_SORTING_COLUMN, arrayDb[0]));
    SubMenu sortMenu = this.menu.findItem(R.id.menu_sort).getSubMenu();
    for (int i = 0; i < arrayDialog.length; i++) {
      if (sortMenu.findItem(i) == null) {
        sortMenu.add(MENU_SORT_GROUP_ID, i, i, arrayDialog[i]);
      }
      if (i == selected) {
        sortMenu.getItem(i).setChecked(true);
      }
    }
    sortMenu.setGroupCheckable(MENU_SORT_GROUP_ID, true, true);
  }
  @Override
  public void onPrepareOptionsMenu(Menu menu) {
    setActionItemsVisibility(menu, false);
  }
  private void prepareActionModeMenu() {
    Menu menu = getActionMode().getMenu();
    int navigation = Navigation.getNavigation();
    boolean showArchive =
        navigation == Navigation.NOTES || navigation == Navigation.REMINDERS || navigation ==
            Navigation.UNCATEGORIZED || navigation == Navigation.CATEGORY;
    boolean showUnarchive =
        navigation == Navigation.ARCHIVE || navigation == Navigation.UNCATEGORIZED ||
            navigation == Navigation.CATEGORY;
    if (navigation == Navigation.TRASH) {
      menu.findItem(R.id.menu_untrash).setVisible(true);
      menu.findItem(R.id.menu_delete).setVisible(true);
    } else {
      if (getSelectedCount() == 1) {
        menu.findItem(R.id.menu_share).setVisible(true);
        menu.findItem(R.id.menu_merge).setVisible(false);
        menu.findItem(R.id.menu_archive)
            .setVisible(showArchive && !getSelectedNotes().get(0).isArchived
                ());
        menu.findItem(R.id.menu_unarchive)
            .setVisible(showUnarchive && getSelectedNotes().get(0).isArchived
                ());
      } else {
        menu.findItem(R.id.menu_share).setVisible(false);
        menu.findItem(R.id.menu_merge).setVisible(true);
        menu.findItem(R.id.menu_archive).setVisible(showArchive);
        menu.findItem(R.id.menu_unarchive).setVisible(showUnarchive);
      }
      menu.findItem(R.id.menu_add_reminder).setVisible(true);
      menu.findItem(R.id.menu_category).setVisible(true);
      menu.findItem(R.id.menu_uncomplete_checklists).setVisible(false);
      menu.findItem(R.id.menu_tags).setVisible(true);
      menu.findItem(R.id.menu_trash).setVisible(true);
    }
    menu.findItem(R.id.menu_select_all).setVisible(true);
    setCabTitle();
  }
  private int getSelectedCount() {
    return getSelectedNotes().size();
  }
  private void setCabTitle() {
    if (getActionMode() != null) {
      int title = getSelectedCount();
      getActionMode().setTitle(String.valueOf(title));
    }
  }
  /**
   * SearchView initialization. It's a little complex because it's not using SearchManager but is
   * implementing on its own.
   */
  @SuppressLint("NewApi")
  private void initSearchView(final Menu menu) {
    // Prevents some mysterious NullPointer on app fast-switching
    if (mainActivity == null) {
      return;
    }
    // Save item as class attribute to make it collapse on drawer opening
    searchMenuItem = menu.findItem(R.id.menu_search);
    Bundle args = getArguments();
    if (args != null && args.getBoolean("setSearchFocus")) {
      searchMenuItem.expandActionView();
      KeyboardUtils.hideKeyboard(this.getView());
    }
    // Associate searchable configuration with the SearchView
    SearchManager searchManager = (SearchManager) mainActivity
        .getSystemService(Context.SEARCH_SERVICE);
    searchView = (SearchView) menu.findItem(R.id.menu_search).getActionView();
    searchView.setSearchableInfo(searchManager.getSearchableInfo(mainActivity.getComponentName()));
    searchView.setImeOptions(EditorInfo.IME_ACTION_SEARCH);
    // Expands the widget hiding other actionbar icons
    searchView.setOnQueryTextFocusChangeListener(
        (v, hasFocus) -> setActionItemsVisibility(menu, hasFocus));
    searchMenuItem.setOnActionExpandListener(new OnActionExpandListener() {
          boolean searchPerformed = false;
          @Override
          public boolean onMenuItemActionCollapse(MenuItem item) {
            // Reinitialize notes list to all notes when search is collapsed
            searchQuery = null;
            if (binding.searchLayout.getVisibility() == View.VISIBLE) {
              toggleSearchLabel(false);
            }
            mainActivity.getIntent().setAction(Intent.ACTION_MAIN);
            initNotesList(mainActivity.getIntent());
            mainActivity.supportInvalidateOptionsMenu();
            return true;
          }
          @Override
          public boolean onMenuItemActionExpand(MenuItem item) {
            commitPending();
            searchView.setOnQueryTextListener(new OnQueryTextListener() {
              @Override
              public boolean onQueryTextSubmit(String arg0) {
                return Prefs.getBoolean("settings_instant_search", false);
              }
              @Override
              public boolean onQueryTextChange(String pattern) {
                if (Prefs.getBoolean("settings_instant_search", false)
                    && searchPerformed && mFragment.isAdded()) {
                  searchTags = null;
                  searchQuery = pattern;
                  NoteLoaderTask.getInstance().execute("getNotesByPattern", pattern);
                  return true;
                } else {
                  searchPerformed = true;
                  return false;
                }
              }
            });
            return true;
          }
        });
  }
  private void setActionItemsVisibility(Menu menu, boolean searchViewHasFocus) {
    boolean drawerOpen = mainActivity.getDrawerLayout() != null
        && mainActivity.getDrawerLayout().isDrawerOpen(GravityCompat.START);
    boolean expandedView = Prefs.getBoolean(PREF_EXPANDED_VIEW, true);
    int navigation = Navigation.getNavigation();
    boolean navigationReminders = navigation == Navigation.REMINDERS;
    boolean navigationTrash = navigation == Navigation.TRASH;
    boolean navigationCategory = navigation == Navigation.CATEGORY;
    boolean filterPastReminders = Prefs.getBoolean(PREF_FILTER_PAST_REMINDERS, true);
    boolean filterArchivedInCategory = navigationCategory && Prefs
        .getBoolean(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), false);
    if (isFabAllowed()) {
      fab.setAllowed(true);
      fab.showFab();
    } else {
      fab.setAllowed(false);
      fab.hideFab();
    }
    menu.findItem(R.id.menu_search).setVisible(!drawerOpen);
    menu.findItem(R.id.menu_filter)
        .setVisible(!drawerOpen && !filterPastReminders && navigationReminders &&
            !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_remove)
        .setVisible(!drawerOpen && filterPastReminders && navigationReminders
            && !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_category).setVisible(!drawerOpen && !filterArchivedInCategory &&
        navigationCategory && !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_category_remove)
        .setVisible(!drawerOpen && filterArchivedInCategory && navigationCategory && !searchViewHasFocus);
    menu.findItem(R.id.menu_sort)
        .setVisible(!drawerOpen && !navigationReminders && !searchViewHasFocus);
    menu.findItem(R.id.menu_expanded_view)
        .setVisible(!drawerOpen && !expandedView && !searchViewHasFocus);
    menu.findItem(R.id.menu_contracted_view)
        .setVisible(!drawerOpen && expandedView && !searchViewHasFocus);
    menu.findItem(R.id.menu_empty_trash).setVisible(!drawerOpen && navigationTrash);
    menu.findItem(R.id.menu_uncomplete_checklists).setVisible(searchViewHasFocus);
    menu.findItem(R.id.menu_tags).setVisible(searchViewHasFocus);
  }
  @Override
  public boolean onOptionsItemSelected(final MenuItem item) {
    Integer[] protectedActions = {R.id.menu_empty_trash};
    if (Arrays.asList(protectedActions).contains(item.getItemId())) {
      mainActivity.requestPassword(mainActivity, getSelectedNotes(), passwordConfirmed -> {
        if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
          performAction(item, null);
        }
      });
    } else {
      performAction(item, null);
    }
    return super.onOptionsItemSelected(item);
  }
  /**
   * Performs one of the ActionBar button's actions after checked notes protection
   */
  public void performAction(MenuItem item, ActionMode actionMode) {
    if (isOptionsItemFastClick()) {
      return;
    }
    if (actionMode == null) {
      switch (item.getItemId()) {
        case android.R.id.home:
          if (mainActivity.getDrawerLayout().isDrawerOpen(GravityCompat.START)) {
            mainActivity.getDrawerLayout().closeDrawer(GravityCompat.START);
          } else {
            mainActivity.getDrawerLayout().openDrawer(GravityCompat.START);
          }
          break;
        case R.id.menu_filter:
          filterReminders(true);
          break;
        case R.id.menu_filter_remove:
          filterReminders(false);
          break;
        case R.id.menu_filter_category:
          filterCategoryArchived(true);
          break;
        case R.id.menu_filter_category_remove:
          filterCategoryArchived(false);
          break;
        case R.id.menu_uncomplete_checklists:
          item.setVisible(false);
          filterByUncompleteChecklists();
          break;
        case R.id.menu_tags:
          filterByTags();
          break;
        case R.id.menu_sort:
          initSortingSubmenu();
          break;
        case R.id.menu_expanded_view:
          switchNotesView();
          break;
        case R.id.menu_contracted_view:
          switchNotesView();
          break;
        case R.id.menu_empty_trash:
          emptyTrash();
          break;
        case R.id.menu_search:
          // Nothing to do, it's all managed by SearchView component
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + item.getItemId());
      }
    } else {
      switch (item.getItemId()) {
        case R.id.menu_category:
          categorizeNotes();
          break;
        case R.id.menu_tags:
          tagNotes();
          break;
        case R.id.menu_share:
          share();
          break;
        case R.id.menu_merge:
          merge();
          break;
        case R.id.menu_archive:
          archiveNotes(true);
          break;
        case R.id.menu_unarchive:
          archiveNotes(false);
          break;
        case R.id.menu_trash:
          trashNotes(true);
          break;
        case R.id.menu_untrash:
          trashNotes(false);
          break;
        case R.id.menu_delete:
          deleteNotes();
          break;
        case R.id.menu_select_all:
          selectAllNotes();
          break;
        case R.id.menu_add_reminder:
          addReminders();
          break;
//                case R.ID.menu_synchronize:
//                    synchronizeSelectedNotes();
//                    break;
        default:
          LogDelegate.e("Wrong element choosen: " + item.getItemId());
      }
    }
    checkSortActionPerformed(item);
  }
  private void addReminders() {
    Intent intent = new Intent(OmniNotes.getAppContext(), SnoozeActivity.class);
    intent.setAction(ACTION_POSTPONE);
    intent.putExtra(INTENT_NOTE, selectedNotes.toArray(new Note[selectedNotes.size()]));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivityForResult(intent, REQUEST_CODE_ADD_ALARMS);
  }
  private void switchNotesView() {
    boolean expandedView = Prefs.getBoolean(PREF_EXPANDED_VIEW, true);
    Prefs.edit().putBoolean(PREF_EXPANDED_VIEW, !expandedView).apply();
    searchQueryInstant = searchQuery;
    // Change list view
    initNotesList(mainActivity.getIntent());
    // Called to switch menu voices
    mainActivity.supportInvalidateOptionsMenu();
  }
  void editNote(final Note note, final View view) {
    if (note.isLocked() && !Prefs.getBoolean("settings_password_access", false)) {
      PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
        if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
          note.setPasswordChecked(true);
          AnimationsHelper.zoomListItem(mainActivity, view, getZoomListItemView(view, note),
              binding.listRoot, buildAnimatorListenerAdapter(note));
        }
      });
    } else {
      AnimationsHelper.zoomListItem(mainActivity, view, getZoomListItemView(view, note),
          binding.listRoot, buildAnimatorListenerAdapter(note));
    }
  }
  void editNote2(Note note) {
    if (note.get_id() == null) {
      LogDelegate.d("Adding new note");
      // if navigation is a category it will be set into note
      try {
        if (checkNavigation(Navigation.CATEGORY) || !isEmpty(mainActivity.navigationTmp)) {
          String categoryId = ObjectUtils.defaultIfNull(mainActivity.navigationTmp,
              Navigation.getCategory().toString());
          note.setCategory(DbHelper.getInstance().getCategory(Long.parseLong(categoryId)));
        }
      } catch (NumberFormatException e) {
        LogDelegate.v("Maybe was not a category!");
      }
    } else {
      LogDelegate.d("Editing note with ID: " + note.get_id());
    }
    // Current list scrolling position is saved to be restored later
    refreshListScrollPosition();
    // Fragments replacing
    mainActivity.switchToDetail(note);
  }
  @Override
  public// Used to show a Crouton dialog after saved (or tried to) a note
  void onActivityResult(int requestCode, final int resultCode, Intent intent) {
    super.onActivityResult(requestCode, resultCode, intent);
    switch (requestCode) {
      case REQUEST_CODE_CATEGORY:
        // Dialog retarded to give time to activity's views of being completely initialized
        // The dialog style is choosen depending on result code
        switch (resultCode) {
          case Activity.RESULT_OK:
            mainActivity.showMessage(R.string.category_saved, ONStyle.CONFIRM);
            EventBus.getDefault().post(new CategoriesUpdatedEvent());
            break;
          case Activity.RESULT_FIRST_USER:
            mainActivity.showMessage(R.string.category_deleted, ONStyle.ALERT);
            break;
          default:
            break;
        }
        break;
      case REQUEST_CODE_CATEGORY_NOTES:
        if (intent != null) {
          Category tag = intent.getParcelableExtra(INTENT_CATEGORY);
          categorizeNotesExecute(tag);
        }
        break;
      case REQUEST_CODE_ADD_ALARMS:
        selectedNotes.clear();
        finishActionMode();
        break;
      default:
        break;
    }
  }
  private void checkSortActionPerformed(MenuItem item) {
    if (item.getGroupId() == MENU_SORT_GROUP_ID) {
      final String[] arrayDb = getResources().getStringArray(R.array.sortable_columns);
      Prefs.edit().putString(PREF_SORTING_COLUMN, arrayDb[item.getOrder()]).apply();
      initNotesList(mainActivity.getIntent());
      // Resets list scrolling position
      listViewPositionOffset = 16;
      listViewPosition = 0;
      restoreListScrollPosition();
      toggleSearchLabel(false);
      // Updates app widgets
      mainActivity.updateWidgets();
    }
  }
  /**
   * Empties trash deleting all the notes
   */
  private void emptyTrash() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.empty_trash_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          boolean mustDeleteLockedNotes = false;
          for (int i = 0; i < listAdapter.getItemCount(); i++) {
            selectedNotes.add(listAdapter.getItem(i));
            mustDeleteLockedNotes = mustDeleteLockedNotes || listAdapter.getItem(i).isLocked();
          }
          if (mustDeleteLockedNotes) {
            mainActivity.requestPassword(mainActivity, getSelectedNotes(),
                passwordConfirmed -> {
                  if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                    deleteNotesExecute();
                  }
                });
          } else {
            deleteNotesExecute();
          }
        }).build().show();
  }
  /**
   * Notes list adapter initialization and association to view
   *
   * @FIXME: This method is a divine disgrace and MUST be refactored. I'm ashamed by myself.
   */
  void initNotesList(Intent intent) {
    LogDelegate.d("initNotesList intent: " + intent.getAction());
    binding.progressWheel.setAlpha(1);
    binding.list.setAlpha(0);
    // Search for a tag
    // A workaround to simplify it's to simulate normal search
    if (Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getCategories() != null
        && intent.getCategories().contains(Intent.CATEGORY_BROWSABLE)) {
      searchTags = intent.getDataString().replace(UrlCompleter.HASHTAG_SCHEME, "");
      goBackOnToggleSearchLabel = true;
    }
    if (ACTION_SHORTCUT_WIDGET.equals(intent.getAction())) {
      return;
    }
    // Searching
    searchQuery = searchQueryInstant;
    searchQueryInstant = null;
    if (searchTags != null || searchQuery != null || searchUncompleteChecklists
        || IntentChecker
        .checkAction(intent, Intent.ACTION_SEARCH, ACTION_SEARCH_UNCOMPLETE_CHECKLISTS)) {
      // Using tags
      if (searchTags != null && intent.getStringExtra(SearchManager.QUERY) == null) {
        searchQuery = searchTags;
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByTag",
                searchQuery);
      } else if (searchUncompleteChecklists || ACTION_SEARCH_UNCOMPLETE_CHECKLISTS.equals(
          intent.getAction())) {
        searchQuery = getContext().getResources().getString(R.string.uncompleted_checklists);
        searchUncompleteChecklists = true;
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByUncompleteChecklist");
      } else {
        // Get the intent, verify the action and get the query
        if (intent.getStringExtra(SearchManager.QUERY) != null) {
          searchQuery = intent.getStringExtra(SearchManager.QUERY);
          searchTags = null;
        }
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByPattern",
                searchQuery);
      }
      toggleSearchLabel(true);
    } else {
      // Check if is launched from a widget with categories
      if ((ACTION_WIDGET_SHOW_LIST.equals(intent.getAction()) && intent.hasExtra(INTENT_WIDGET))
          || !isEmpty(mainActivity.navigationTmp)) {
        String widgetId =
            intent.hasExtra(INTENT_WIDGET) ? intent.getExtras().get(INTENT_WIDGET).toString()
                : null;
        if (widgetId != null) {
          String sqlCondition = Prefs.getString(PREF_WIDGET_PREFIX + widgetId, "");
          String categoryId = TextHelper.checkIntentCategory(sqlCondition);
          mainActivity.navigationTmp = !isEmpty(categoryId) ? categoryId : null;
        }
        intent.removeExtra(INTENT_WIDGET);
        if (mainActivity.navigationTmp != null) {
          Long categoryId = Long.parseLong(mainActivity.navigationTmp);
          NoteLoaderTask.getInstance().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,
              "getNotesByCategory", categoryId);
        } else {
          NoteLoaderTask.getInstance()
              .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getAllNotes", true);
        }
      } else {
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getAllNotes", true);
      }
    }
  }
  public void toggleSearchLabel(boolean activate) {
    if (activate) {
      binding.searchQuery.setText(fromHtml(getString(R.string.search) + ":<b> " + searchQuery + "</b>"));
      binding.searchLayout.setVisibility(View.VISIBLE);
      binding.searchCancel.setOnClickListener(v -> toggleSearchLabel(false));
      searchLabelActive = true;
    } else {
      if (searchLabelActive) {
        searchLabelActive = false;
        AnimationsHelper.expandOrCollapse(binding.searchLayout, false);
        searchTags = null;
        searchQuery = null;
        searchUncompleteChecklists = false;
        if (!goBackOnToggleSearchLabel) {
          mainActivity.getIntent().setAction(Intent.ACTION_MAIN);
          if (searchView != null) {
            searchMenuItem.collapseActionView();
          }
          initNotesList(mainActivity.getIntent());
        } else {
          mainActivity.onBackPressed();
        }
        goBackOnToggleSearchLabel = false;
        if (Intent.ACTION_VIEW.equals(mainActivity.getIntent().getAction())) {
          mainActivity.getIntent().setAction(null);
        }
      }
    }
  }
  public void onEvent(NavigationUpdatedNavDrawerClosedEvent navigationUpdatedNavDrawerClosedEvent) {
    listViewPosition = 0;
    listViewPositionOffset = 16;
    initNotesList(mainActivity.getIntent());
    setActionItemsVisibility(menu, false);
  }
  public void onEvent(CategoriesUpdatedEvent categoriesUpdatedEvent) {
    initNotesList(mainActivity.getIntent());
  }
  public void onEvent(NotesLoadedEvent notesLoadedEvent) {
    listAdapter = new NoteAdapter(mainActivity, Prefs.getBoolean(PREF_EXPANDED_VIEW, true),
        notesLoadedEvent.getNotes());
    initSwipeGesture();
    binding.list.setAdapter(listAdapter);
    // Restores listview position when turning back to list or when navigating reminders
    if (!notesLoadedEvent.getNotes().isEmpty()) {
      if (checkNavigation(Navigation.REMINDERS)) {
        listViewPosition = listAdapter.getClosestNotePosition();
      }
      restoreListScrollPosition();
    }
    animateListView();
    closeFab();
  }
  public void onEvent(NotesUpdatedEvent notesUpdatedEvent) {
    notesUpdatedEvent.getNotes().stream().forEach(updatedNote ->
        IntStream.range(0, listAdapter.getNotes().size() - 1)
            .filter(i -> listAdapter.getItem(i).get_id().equals(updatedNote.get_id()))
            .forEach(i -> {
              listAdapter.getNotes().set(i, updatedNote);
              listAdapter.notifyItemChanged(i);
            }));
  }
  private void initSwipeGesture() {
    ItemTouchHelper.SimpleCallback simpleItemTouchCallback = new ItemTouchHelper.SimpleCallback(0,
        ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT) {
      @Override
      public boolean onMove(@NonNull RecyclerView recyclerView,
          @NonNull RecyclerView.ViewHolder viewHolder,
          @NonNull RecyclerView.ViewHolder target) {
        return false;
      }
      @Override
      public void onSwiped(RecyclerView.ViewHolder viewHolder, int swipeDir) {
        int swipedPosition = viewHolder.getAdapterPosition();
        finishActionMode();
        swipeNote(swipedPosition);
      }
    };
    ItemTouchHelper itemTouchHelper = new ItemTouchHelper(simpleItemTouchCallback);
    if (Navigation.getNavigation() != Navigation.UNCATEGORIZED && Prefs
        .getBoolean(PREF_ENABLE_SWIPE, true)) {
      itemTouchHelper.attachToRecyclerView(binding.list);
    } else {
      itemTouchHelper.attachToRecyclerView(null);
    }
  }
  private void swipeNote(int swipedPosition) {
    try {
      Note note = listAdapter.getItem(swipedPosition);
      if (note.isLocked()) {
        PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
          if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
            onNoteSwipedPerformAction(note);
          } else {
            onUndo(null);
          }
        });
      } else {
        onNoteSwipedPerformAction(note);
      }
    } catch (IndexOutOfBoundsException e) {
      LogDelegate.d("Please stop swiping in the zone beneath the last card");
    }
  }
  private void onNoteSwipedPerformAction(Note note) {
    getSelectedNotes().add(note);
    // Depending on settings and note status this action will...
    // ...restore
    if (checkNavigation(Navigation.TRASH)) {
      trashNotes(false);
    }
    // ...removes category
    else if (checkNavigation(Navigation.CATEGORY)) {
      categorizeNotesExecute(null);
    } else {
      // ...trash
      if (Prefs.getBoolean("settings_swipe_to_trash", false)
          || checkNavigation(Navigation.ARCHIVE)) {
        trashNotes(true);
        // ...archive
      } else {
        archiveNotes(true);
      }
    }
  }
  public void onEvent(PasswordRemovedEvent passwordRemovedEvent) {
    initNotesList(mainActivity.getIntent());
  }
  private void animateListView() {
    if (!isDebugBuild()) {
      animate(binding.progressWheel)
          .setDuration(getResources().getInteger(R.integer.list_view_fade_anim)).alpha(0);
      animate(binding.list).setDuration(getResources().getInteger(R.integer.list_view_fade_anim))
          .alpha(1);
    } else {
      binding.progressWheel.setVisibility(View.INVISIBLE);
      binding.list.setAlpha(1);
    }
  }
  private void restoreListScrollPosition() {
    if (listAdapter.getItemCount() > listViewPosition) {
      binding.list.getLayoutManager().scrollToPosition(listViewPosition);
      new Handler().postDelayed(fab::showFab, 150);
    } else {
      binding.list.getLayoutManager().scrollToPosition(0);
    }
  }
  /**
   * Batch note trashing
   */
  public void trashNotes(boolean trash) {
    int selectedNotesSize = getSelectedNotes().size();
    // Restore is performed immediately, otherwise undo bar is shown
    if (trash) {
      trackModifiedNotes(getSelectedNotes());
      for (Note note : getSelectedNotes()) {
        listAdapter.remove(note);
        ReminderHelper.removeReminder(OmniNotes.getAppContext(), note);
      }
    } else {
      trashNote(getSelectedNotes(), false);
    }
    listAdapter.notifyDataSetChanged();
    finishActionMode();
    // Advice to user
    if (trash) {
      mainActivity.showMessage(R.string.note_trashed, ONStyle.WARN);
    } else {
      mainActivity.showMessage(R.string.note_untrashed, ONStyle.INFO);
    }
    // Creation of undo bar
    if (trash) {
      ubc.showUndoBar(false, selectedNotesSize + " " + getString(R.string.trashed), null);
      fab.hideFab();
      undoTrash = true;
    } else {
      getSelectedNotes().clear();
    }
  }
  private ActionMode getActionMode() {
    return actionMode;
  }
  private List<Note> getSelectedNotes() {
    return selectedNotes;
  }
  /**
   * Single note logical deletion
   */
  @SuppressLint("NewApi")
  protected void trashNote(List<Note> notes, boolean trash) {
    listAdapter.remove(notes);
    new NoteProcessorTrash(notes, trash).process();
  }
  /**
   * Selects all notes in list
   */
  private void selectAllNotes() {
    for (int i = 0; i < binding.list.getChildCount(); i++) {
      LinearLayout v = binding.list.getChildAt(i).findViewById(R.id.card_layout);
      v.setBackgroundColor(getResources().getColor(R.color.list_bg_selected));
    }
    selectedNotes.clear();
    for (int i = 0; i < listAdapter.getItemCount(); i++) {
      selectedNotes.add(listAdapter.getItem(i));
      listAdapter.addSelectedItem(i);
    }
    prepareActionModeMenu();
    setCabTitle();
  }
  /**
   * Batch note permanent deletion
   */
  private void deleteNotes() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.delete_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive(
            (dialog, which) -> mainActivity.requestPassword(mainActivity, getSelectedNotes(),
                passwordConfirmed -> {
                  if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                    deleteNotesExecute();
                  }
                }))
        .build()
        .show();
  }
  /**
   * Performs notes permanent deletion after confirmation by the user
   */
  private void deleteNotesExecute() {
    listAdapter.remove(getSelectedNotes());
    new NoteProcessorDelete(getSelectedNotes()).process();
    selectedNotes.clear();
    finishActionMode();
    mainActivity.showMessage(R.string.note_deleted, ONStyle.ALERT);
  }
  /**
   * Batch note archiviation
   */
  public void archiveNotes(boolean archive) {
    int selectedNotesSize = getSelectedNotes().size();
    // Used in undo bar commit
    sendToArchive = archive;
    if (!archive) {
      archiveNote(getSelectedNotes(), false);
    } else {
      trackModifiedNotes(getSelectedNotes());
    }
    for (Note note : getSelectedNotes()) {
      // If is restore it will be done immediately, otherwise the undo bar will be shown
      if (archive) {
        // Saves archived state to eventually undo
        undoArchivedMap.put(note, note.isArchived());
      }
      // If actual navigation is not "Notes" the item will not be removed but replaced to fit the new state
      if (checkNavigation(Navigation.NOTES)
          || (checkNavigation(Navigation.ARCHIVE) && !archive)
          || (checkNavigation(Navigation.CATEGORY) && Prefs.getBoolean(
          PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), false))) {
        listAdapter.remove(note);
      } else {
        note.setArchived(archive);
        listAdapter.replace(note, listAdapter.getPosition(note));
      }
    }
    listAdapter.notifyDataSetChanged();
    finishActionMode();
    // Advice to user
    int msg = archive ? R.string.note_archived : R.string.note_unarchived;
    Style style = archive ? ONStyle.WARN : ONStyle.INFO;
    mainActivity.showMessage(msg, style);
    // Creation of undo bar
    if (archive) {
      ubc.showUndoBar(false, selectedNotesSize + " " + getString(R.string.archived), null);
      fab.hideFab();
      undoArchive = true;
    } else {
      getSelectedNotes().clear();
    }
  }
  /**
   * Saves notes to be eventually restored at right position
   */
  private void trackModifiedNotes(List<Note> modifiedNotesToTrack) {
    for (Note note : modifiedNotesToTrack) {
      undoNotesMap.put(listAdapter.getPosition(note), note);
    }
  }
  private void archiveNote(List<Note> notes, boolean archive) {
    new NoteProcessorArchive(notes, archive).process();
    if (!checkNavigation(Navigation.CATEGORY)) {
      listAdapter.remove(notes);
    }
    LogDelegate.d("Notes" + (archive ? "archived" : "restored from archive"));
  }
  /**
   * Categories addition and editing
   */
  void editCategory(Category category) {
    Intent categoryIntent = new Intent(mainActivity, CategoryActivity.class);
    categoryIntent.putExtra(INTENT_CATEGORY, category);
    startActivityForResult(categoryIntent, REQUEST_CODE_CATEGORY);
  }
  /**
   * Associates to or removes categories
   */
  private void categorizeNotes() {
    var categories = DbHelper.getInstance().getCategories();
    var dialogBuilder = new MaterialDialog.Builder(mainActivity)
        .title(R.string.categorize_as)
        .positiveText(R.string.add_category)
        .positiveColorRes(R.color.colorPrimary)
        .negativeText(R.string.remove_category)
        .negativeColorRes(R.color.colorAccent)
        .onPositive((dialog1, which) -> {
          keepActionMode = true;
          Intent intent = new Intent(mainActivity, CategoryActivity.class);
          intent.putExtra("noHome", true);
          startActivityForResult(intent, REQUEST_CODE_CATEGORY_NOTES);
        }).onNegative((dialog12, which) -> categorizeNotesExecute(null));
    if (CollectionUtils.isNotEmpty(categories)) {
      dialogBuilder.adapter(new CategoryRecyclerViewAdapter(mainActivity, categories), null);
    }
    final var dialog = dialogBuilder.build();
    if (CollectionUtils.isNotEmpty(categories)) {
      RecyclerViewItemClickSupport.addTo(dialog.getRecyclerView())
          .setOnItemClickListener((recyclerView, position, v) -> {
            dialog.dismiss();
            categorizeNotesExecute(categories.get(position));
          });
    }
    dialog.show();
  }
  private void categorizeNotesExecute(Category category) {
    if (category != null) {
      categorizeNote(getSelectedNotes(), category);
    } else {
      trackModifiedNotes(getSelectedNotes());
    }
    for (Note note : getSelectedNotes()) {
      // If is restore it will be done immediately, otherwise the undo bar
      // will be shown
      if (category == null) {
        // Saves categories associated to eventually undo
        undoCategoryMap.put(note, note.getCategory());
      }
      // Update adapter content if actual navigation is the category
      // associated with actually cycled note
      if ((checkNavigation(Navigation.CATEGORY) && !Navigation
          .checkNavigationCategory(category)) ||
          checkNavigation(Navigation.UNCATEGORIZED)) {
        listAdapter.remove(note);
      } else {
        note.setCategory(category);
        listAdapter.replace(note, listAdapter.getPosition(note));
      }
    }
    finishActionMode();
    // Advice to user
    String msg;
    if (category != null) {
      msg = getResources().getText(R.string.notes_categorized_as) + " '" + category.getName() + "'";
    } else {
      msg = getResources().getText(R.string.notes_category_removed).toString();
    }
    mainActivity.showMessage(msg, ONStyle.INFO);
    // Creation of undo bar
    if (category == null) {
      ubc.showUndoBar(false, getString(R.string.notes_category_removed), null);
      fab.hideFab();
      undoCategorize = true;
      undoCategorizeCategory = null;
    } else {
      getSelectedNotes().clear();
    }
  }
  private void categorizeNote(List<Note> notes, Category category) {
    new NoteProcessorCategorize(notes, category).process();
  }
  /**
   * Bulk tag selected notes
   */
  private void tagNotes() {
    // Retrieves all available tags
    final List<Tag> tags = DbHelper.getInstance().getTags();
    // If there is no tag a message will be shown
    if (tags.isEmpty()) {
      finishActionMode();
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    final Integer[] preSelectedTags = TagsHelper.getPreselectedTagsArray(selectedNotes, tags);
    new MaterialDialog.Builder(mainActivity)
        .title(R.string.select_tags)
        .items(TagsHelper.getTagsArray(tags))
        .positiveText(R.string.ok)
        .itemsCallbackMultiChoice(preSelectedTags, (dialog, which, text) -> {
          dialog.dismiss();
          tagNotesExecute(tags, which, preSelectedTags);
          return false;
        }).build().show();
  }
  private void tagNotesExecute(List<Tag> tags, Integer[] selectedTags, Integer[] preSelectedTags) {
    for (Note note : getSelectedNotes()) {
      tagNote(tags, selectedTags, note);
    }
    if (getActionMode() != null) {
      getActionMode().finish();
    }
    mainActivity.showMessage(R.string.tags_added, ONStyle.INFO);
  }
  private void tagNote(List<Tag> tags, Integer[] selectedTags, Note note) {
    Pair<String, List<Tag>> taggingResult = TagsHelper.addTagToNote(tags, selectedTags, note);
    if (note.isChecklist()) {
      note.setTitle(note.getTitle() + System.getProperty("line.separator") + taggingResult.first);
    } else {
      StringBuilder sb = new StringBuilder(note.getContent());
      if (sb.length() > 0) {
        sb.append(System.getProperty("line.separator"))
            .append(System.getProperty("line.separator"));
      }
      sb.append(taggingResult.first);
      note.setContent(sb.toString());
    }
    eventuallyRemoveDeselectedTags(note, taggingResult.second);
    DbHelper.getInstance().updateNote(note, false);
  }
  private void eventuallyRemoveDeselectedTags(Note note, List<Tag> tagsToRemove) {
    if (CollectionUtils.isNotEmpty(tagsToRemove)) {
      String titleWithoutTags = TagsHelper.removeTags(note.getTitle(), tagsToRemove);
      note.setTitle(titleWithoutTags);
      String contentWithoutTags = TagsHelper.removeTags(note.getContent(), tagsToRemove);
      note.setContent(contentWithoutTags);
    }
  }
//	private void synchronizeSelectedNotes() {
//		new DriveSyncTask(mainActivity).execute(new ArrayList<Note>(getSelectedNotes()));
//		// Clears data structures
//		listAdapter.clearSelectedItems();
//		list.clearChoices();
//		finishActionMode();
//	}
  @Override
  public void onUndo(Parcelable undoToken) {
    // Cycles removed items to re-insert into adapter
    for (Integer notePosition : undoNotesMap.keySet()) {
      Note currentNote = undoNotesMap.get(notePosition);
      //   Manages uncategorize or archive  undo
      if ((undoCategorize && !Navigation.checkNavigationCategory(undoCategoryMap.get(currentNote)))
          || undoArchive && !checkNavigation(Navigation.NOTES)) {
        if (undoCategorize) {
          currentNote.setCategory(undoCategoryMap.get(currentNote));
        } else if (undoArchive) {
          currentNote.setArchived(undoArchivedMap.get(currentNote));
        }
        listAdapter.replace(currentNote, listAdapter.getPosition(currentNote));
        // Manages trash undo
      } else {
        listAdapter.add(notePosition, currentNote);
      }
    }
    listAdapter.notifyDataSetChanged();
    selectedNotes.clear();
    undoNotesMap.clear();
    undoTrash = false;
    undoArchive = false;
    undoCategorize = false;
    undoNotesMap.clear();
    undoCategoryMap.clear();
    undoArchivedMap.clear();
    undoCategorizeCategory = null;
    Crouton.cancelAllCroutons();
    if (getActionMode() != null) {
      getActionMode().finish();
    }
    ubc.hideUndoBar(false);
    fab.showFab();
  }
  void commitPending() {
    if (undoTrash || undoArchive || undoCategorize) {
      List<Note> notesList = new ArrayList<>(undoNotesMap.values());
      if (undoTrash) {
        trashNote(notesList, true);
      } else if (undoArchive) {
        archiveNote(notesList, sendToArchive);
      } else if (undoCategorize) {
        categorizeNote(notesList, undoCategorizeCategory);
      }
      undoTrash = false;
      undoArchive = false;
      undoCategorize = false;
      undoCategorizeCategory = null;
      // Clears data structures
      selectedNotes.clear();
      undoNotesMap.clear();
      undoCategoryMap.clear();
      undoArchivedMap.clear();
      ubc.hideUndoBar(false);
      fab.showFab();
      LogDelegate.d("Changes committed");
    }
    mainActivity.updateWidgets();
  }
  /**
   * Shares the selected note from the list
   */
  private void share() {
    // Only one note should be selected to perform sharing but they'll be cycled anyhow
    for (final Note note : getSelectedNotes()) {
      mainActivity.shareNote(note);
    }
    getSelectedNotes().clear();
    if (getActionMode() != null) {
      getActionMode().finish();
    }
  }
  public void merge() {
    EventBus.getDefault().post(new NotesMergeEvent(false));
  }
  /**
   * Merges all the selected notes
   */
  public void onEventAsync(NotesMergeEvent notesMergeEvent) {
    final Note finalMergedNote = NotesHelper
        .mergeNotes(getSelectedNotes(), notesMergeEvent.keepMergedNotes);
    new Handler(Looper.getMainLooper()).post(() -> {
      if (!notesMergeEvent.keepMergedNotes) {
        ArrayList<String> notesIds = new ArrayList<>();
        for (Note selectedNote : getSelectedNotes()) {
          notesIds.add(String.valueOf(selectedNote.get_id()));
        }
        mainActivity.getIntent().putExtra("merged_notes", notesIds);
      }
      getSelectedNotes().clear();
      if (getActionMode() != null) {
        getActionMode().finish();
      }
      mainActivity.getIntent().setAction(ACTION_MERGE);
      mainActivity.switchToDetail(finalMergedNote);
    });
  }
  /**
   * Excludes past reminders
   */
  private void filterReminders(boolean filter) {
    Prefs.edit().putBoolean(PREF_FILTER_PAST_REMINDERS, filter).apply();
    // Change list view
    initNotesList(mainActivity.getIntent());
    // Called to switch menu voices
    mainActivity.supportInvalidateOptionsMenu();
  }
  /**
   * Excludes archived notes in categories navigation
   */
  private void filterCategoryArchived(boolean filter) {
    if (filter) {
      Prefs.edit().putBoolean(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), true)
          .apply();
    } else {
      Prefs.edit().remove(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory()).apply();
    }
    // Change list view
    initNotesList(mainActivity.getIntent());
    // Called to switch menu voices
    mainActivity.supportInvalidateOptionsMenu();
  }
  private void filterByUncompleteChecklists() {
    initNotesList(new Intent(ACTION_SEARCH_UNCOMPLETE_CHECKLISTS));
  }
  private void filterByTags() {
    final List<Tag> tags = TagsHelper.getAllTags();
    if (tags.isEmpty()) {
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    var tagsDialog = new MaterialAlertDialogBuilder(mainActivity)
        .setTitle(R.string.select_tags)
        .setPositiveButton(R.string.ok, (dialog, which) -> {
          var items = ((AlertDialog) dialog).getListView().getCheckedItemPositions();
          var selectedTags = new ArrayList<String>();
          for(int i = 0; i < tags.size(); i++) {
            if (items.get(i)) {
              selectedTags.add(tags.get(i).getText());
            }
          }
          // Saved here to allow persisting search
          searchTags = selectedTags.toString().substring(1, selectedTags.toString().length() - 1)
              .replace(" ", "");
          // Hides keyboard
          searchView.clearFocus();
          KeyboardUtils.hideKeyboard(searchView);
          var intent = mainActivity.getIntent();
          intent.removeExtra(SearchManager.QUERY);
          initNotesList(intent);
        })
        .setMultiChoiceItems(TagsHelper.getTagsArray(tags), null, (dialog, which, isChecked) ->
            ((AlertDialog) dialog).getButton(BUTTON_POSITIVE)
            .setEnabled(((AlertDialog) dialog).getListView().getCheckedItemCount() > 0)
        ).create();
    tagsDialog.show();
    tagsDialog.getButton(BUTTON_POSITIVE).setEnabled(false);
  }
  public MenuItem getSearchMenuItem() {
    return searchMenuItem;
  }
  private boolean isFabAllowed() {
    return isFabAllowed(false);
  }
  private boolean isFabAllowed(boolean actionModeFinishing) {
    boolean isAllowed = true;
    // Actionmode check
    isAllowed = isAllowed && (getActionMode() == null || actionModeFinishing);
    // Navigation check
    int navigation = Navigation.getNavigation();
    isAllowed = isAllowed && navigation != Navigation.ARCHIVE && navigation != Navigation.REMINDERS
        && navigation
        != Navigation.TRASH;
    // Navigation drawer check
    isAllowed =
        isAllowed && mainActivity.getDrawerLayout() != null && !mainActivity.getDrawerLayout()
            .isDrawerOpen
                (GravityCompat.START);
    return isAllowed;
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.async.notes;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.ShortcutHelper;
import java.util.List;
public class NoteProcessorTrash extends NoteProcessor {
  boolean trash;
  public NoteProcessorTrash(List<Note> notes, boolean trash) {
    super(notes);
    this.trash = trash;
  }
  @Override
  protected void processNote(Note note) {
    if (trash) {
      ShortcutHelper.removeShortcut(OmniNotes.getAppContext(), note);
      ReminderHelper.removeReminder(OmniNotes.getAppContext(), note);
    } else {
      ReminderHelper.addReminder(OmniNotes.getAppContext(), note);
    }
    DbHelper.getInstance().trashNote(note, trash);
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.async;
import android.content.Context;
import android.content.Intent;
import android.os.Build.VERSION_CODES;
import androidx.annotation.NonNull;
import androidx.core.app.JobIntentService;
import it.feio.android.omninotes.BaseActivity;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.BuildHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.utils.ReminderHelper;
import java.util.List;
/**
 * Verify version code and add wake lock in manifest is important to avoid crash
 */
public class AlarmRestoreOnRebootService extends JobIntentService {
  public static final int JOB_ID = 0x01;
  public static void enqueueWork(Context context, Intent work) {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.O)) {
      enqueueWork(context, AlarmRestoreOnRebootService.class, JOB_ID, work);
    } else {
      Intent jobIntent = new Intent(context, AlarmRestoreOnRebootService.class);
      context.startService(jobIntent);
    }
  }
  @Override
  protected void onHandleWork(@NonNull Intent intent) {
    LogDelegate.i("System rebooted: service refreshing reminders");
    Context mContext = getApplicationContext();
    BaseActivity.notifyAppWidgets(mContext);
    List<Note> notes = DbHelper.getInstance().getNotesWithReminderNotFired();
    LogDelegate.d("Found " + notes.size() + " reminders");
    for (Note note : notes) {
      ReminderHelper.addReminder(OmniNotes.getAppContext(), note);
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_DISMISS;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_NOTIFICATION_CLICK;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_PINNED;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_POSTPONE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SNOOZE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_KEY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_SNOOZE_DEFAULT;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import androidx.appcompat.app.AppCompatActivity;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.async.notes.SaveNoteTask;
import it.feio.android.omninotes.helpers.date.RecurrenceHelper;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.listeners.OnReminderPickedListener;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.date.DateUtils;
import it.feio.android.omninotes.utils.date.ReminderPickers;
import java.util.Arrays;
import java.util.Calendar;
public class SnoozeActivity extends AppCompatActivity implements OnReminderPickedListener {
  private Note note;
  private Note[] notes;
  public static void setNextRecurrentReminder(Note note) {
    long nextReminder = RecurrenceHelper.nextReminderFromRecurrenceRule(note);
    if (nextReminder > 0) {
      updateNoteReminder(nextReminder, note, true);
    } else {
      new SaveNoteTask(false).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, note);
    }
  }
  private static void updateNoteReminder(long reminder, Note note) {
    updateNoteReminder(reminder, note, false);
  }
  private static void updateNoteReminder(long reminder, Note noteToUpdate, boolean updateNote) {
    if (updateNote) {
      noteToUpdate.setAlarm(reminder);
      new SaveNoteTask(false).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteToUpdate);
    } else {
      ReminderHelper.addReminder(OmniNotes.getAppContext(), noteToUpdate, reminder);
      ReminderHelper.showReminderMessage(noteToUpdate.getAlarm());
    }
  }
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (getIntent().getParcelableExtra(INTENT_NOTE) != null) {
      note = getIntent().getParcelableExtra(INTENT_NOTE);
      manageNotification();
    } else {
      Object[] notesObjs = (Object[]) getIntent().getExtras().get(INTENT_NOTE);
      notes = Arrays.copyOf(notesObjs, notesObjs.length, Note[].class);
      postpone(DateUtils.getNextMinute(), null);
    }
  }
  private void manageNotification() {
    if (ACTION_DISMISS.equals(getIntent().getAction())) {
      setNextRecurrentReminder(note);
      finish();
    } else if (ACTION_SNOOZE.equals(getIntent().getAction())) {
      String snoozeDelay = Prefs.getString("settings_notification_snooze_delay", PREF_SNOOZE_DEFAULT);
      long newReminder =
          Calendar.getInstance().getTimeInMillis() + Integer.parseInt(snoozeDelay) * 60 * 1000;
      updateNoteReminder(newReminder, note);
      finish();
    } else if (ACTION_POSTPONE.equals(getIntent().getAction())) {
      postpone(Long.parseLong(note.getAlarm()), note.getRecurrenceRule());
    } else {
      Intent intent = new Intent(this, MainActivity.class);
      intent.putExtra(INTENT_KEY, note.get_id());
      intent.setAction(ACTION_NOTIFICATION_CLICK);
      startActivity(intent);
      finish();
    }
    if (!ACTION_PINNED.equals(getIntent().getAction())) {
      removeNotification(note);
    }
  }
  private void postpone(Long alarm, String recurrenceRule) {
    ReminderPickers reminderPicker = new ReminderPickers(this, this);
    reminderPicker.pick(alarm, recurrenceRule);
  }
  private void removeNotification(Note note) {
    NotificationManager manager = (NotificationManager) getSystemService(
        Context.NOTIFICATION_SERVICE);
    manager.cancel(String.valueOf(note.get_id()), 0);
  }
  @Override
  public void onReminderPicked(long reminder) {
    if (note != null) {
      note.setAlarm(reminder);
    } else {
      for (Note currentNote : notes) {
        currentNote.setAlarm(reminder);
      }
    }
  }
  @Override
  public void onRecurrenceReminderPicked(String recurrenceRule) {
    if (note != null) {
      note.setRecurrenceRule(recurrenceRule);
      setNextRecurrentReminder(note);
    } else {
      for (Note processedNotes : notes) {
        processedNotes.setRecurrenceRule(recurrenceRule);
        setNextRecurrentReminder(processedNotes);
      }
      setResult(RESULT_OK, getIntent());
    }
    finish();
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.helpers;
import static android.app.PendingIntent.FLAG_IMMUTABLE;
import static android.app.PendingIntent.FLAG_MUTABLE;
import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.os.Build.VERSION_CODES;
import android.os.Bundle;
import androidx.annotation.NonNull;
import it.feio.android.omninotes.models.Note;
import lombok.experimental.UtilityClass;
@UtilityClass
public class IntentHelper {
  public static Intent getNoteIntent(@NonNull Context context, @NonNull Class target, String action,
      Note note) {
    Intent intent = new Intent(context, target);
    intent.setAction(action);
    Bundle bundle = new Bundle();
    bundle.putParcelable(INTENT_NOTE, note);
    intent.putExtras(bundle);
//    // Sets the Activity to start in a new, empty task
//    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
//    // Workaround to fix problems with multiple notifications
//    intent.setAction(ACTION_NOTIFICATION_CLICK + System.currentTimeMillis());
    return intent;
  }
  public static PendingIntent getNotePendingIntent(@NonNull Context context, @NonNull Class target,
      String action,
      Note note) {
    Intent intent = getNoteIntent(context, target, action, note);
    return PendingIntent.getActivity(context, getUniqueRequestCode(note), intent,
        immutablePendingIntentFlag(FLAG_UPDATE_CURRENT));
  }
  public static int immutablePendingIntentFlag(final int flag) {
    int pIntentFlags = flag;
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.M)) {
      pIntentFlags = pIntentFlags | FLAG_IMMUTABLE;
    }
    return pIntentFlags;
  }
  public static int mutablePendingIntentFlag(final int flag) {
    int pIntentFlags = flag;
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.S)) {
      pIntentFlags = pIntentFlags | FLAG_MUTABLE;
    }
    return pIntentFlags;
  }
  static int getUniqueRequestCode(Note note) {
    return note.get_id().intValue();
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.async.notes;
import android.content.Context;
import android.os.AsyncTask;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.StorageHelper;
import it.feio.android.omninotes.utils.date.DateUtils;
import java.util.List;
public class SaveNoteTask extends AsyncTask<Note, Void, Note> {
  private Context context;
  private boolean updateLastModification = true;
  public SaveNoteTask(boolean updateLastModification) {
    super();
    this.context = OmniNotes.getAppContext();
    this.updateLastModification = updateLastModification;
  }
  @Override
  protected Note doInBackground(Note... params) {
    Note note = params[0];
    purgeRemovedAttachments(note);
    boolean reminderMustBeSet = DateUtils.isFuture(note.getAlarm());
    if (reminderMustBeSet) {
      note.setReminderFired(false);
    }
    note = DbHelper.getInstance().updateNote(note, updateLastModification);
    if (reminderMustBeSet) {
      ReminderHelper.addReminder(context, note);
    }
    return note;
  }
  private void purgeRemovedAttachments(Note note) {
    List<Attachment> deletedAttachments = note.getAttachmentsListOld();
    for (Attachment attachment : note.getAttachmentsList()) {
      if (attachment.getId() != null) {
        // Workaround to prevent deleting attachments if instance is changed (app restart)
        if (!deletedAttachments.contains(attachment)) {
          attachment = getFixedAttachmentInstance(deletedAttachments, attachment);
        }
        deletedAttachments.remove(attachment);
      }
    }
    // Remove from database deleted attachments
    for (Attachment deletedAttachment : deletedAttachments) {
      StorageHelper.delete(context, deletedAttachment.getUri().getPath());
      LogDelegate.d("Removed attachment " + deletedAttachment.getUri());
    }
  }
  private Attachment getFixedAttachmentInstance(List<Attachment> deletedAttachments,
      Attachment attachment) {
    for (Attachment deletedAttachment : deletedAttachments) {
      if (deletedAttachment.getId().equals(attachment.getId())) {
        return deletedAttachment;
      }
    }
    return attachment;
  }
  @Override
  protected void onPostExecute(Note note) {
    super.onPostExecute(note);
    EventBus.getDefault().post(new NotesUpdatedEvent(List.of(note)));
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.receiver;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_POSTPONE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SNOOZE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_FILES;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.text.Spanned;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.SnoozeActivity;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.IntentHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.notifications.NotificationChannels.NotificationChannelNames;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.services.NotificationListener;
import it.feio.android.omninotes.utils.BitmapHelper;
import it.feio.android.omninotes.utils.ParcelableUtil;
import it.feio.android.omninotes.utils.TextHelper;
import java.util.List;
public class AlarmReceiver extends BroadcastReceiver {
  @Override
  public void onReceive(Context mContext, Intent intent) {
    try {
      if (intent.hasExtra(INTENT_NOTE)) {
        Note note = ParcelableUtil.unmarshall(intent.getExtras().getByteArray(INTENT_NOTE), Note
            .CREATOR);
        createNotification(mContext, note);
        SnoozeActivity.setNextRecurrentReminder(note);
        updateNote(note);
      }
    } catch (Exception e) {
      LogDelegate.e("Error on receiving reminder", e);
    }
  }
  private void updateNote(Note note) {
    note.setArchived(false);
    if (!NotificationListener.isRunning()) {
      note.setReminderFired(true);
    }
    DbHelper.getInstance().updateNote(note, false);
  }
  private void createNotification(Context mContext, Note note) {
    PendingIntent piSnooze = IntentHelper
        .getNotePendingIntent(mContext, SnoozeActivity.class, ACTION_SNOOZE, note);
    PendingIntent piPostpone = IntentHelper
        .getNotePendingIntent(mContext, SnoozeActivity.class, ACTION_POSTPONE, note);
    PendingIntent notifyIntent = IntentHelper
        .getNotePendingIntent(mContext, SnoozeActivity.class, null, note);
    Spanned[] titleAndContent = TextHelper.parseTitleAndContent(mContext, note);
    String title = TextHelper.getAlternativeTitle(mContext, note, titleAndContent[0]);
    String text = titleAndContent[1].toString();
    NotificationsHelper notificationsHelper = new NotificationsHelper(mContext);
    notificationsHelper.createStandardNotification(NotificationChannelNames.REMINDERS,
        R.drawable.ic_stat_notification,
        title, notifyIntent).setLedActive().setMessage(text);
    List<Attachment> attachments = note.getAttachmentsList();
    if (!attachments.isEmpty() && !attachments.get(0).getMime_type().equals(MIME_TYPE_FILES)) {
      Bitmap notificationIcon = BitmapHelper
          .getBitmapFromAttachment(mContext, note.getAttachmentsList().get(0), 128,
              128);
      notificationsHelper.setLargeIcon(notificationIcon);
    }
    String snoozeDelay = Prefs.getString("settings_notification_snooze_delay", "10");
    notificationsHelper.getBuilder()
        .addAction(R.drawable.ic_material_reminder_time_light,
            TextHelper.capitalize(mContext.getString(R.string.snooze)) + ": " + snoozeDelay,
            piSnooze)
        .addAction(R.drawable.ic_remind_later_light,
            TextHelper.capitalize(mContext.getString(R.string
                .add_reminder)), piPostpone);
    setRingtone(notificationsHelper);
    setVibrate(notificationsHelper);
    notificationsHelper.show(note.get_id());
  }
  private void setRingtone(NotificationsHelper notificationsHelper) {
    String ringtone = Prefs.getString("settings_notification_ringtone", null);
    notificationsHelper.setRingtone(ringtone);
  }
  private void setVibrate(NotificationsHelper notificationsHelper) {
    if (Prefs.getBoolean("settings_notification_vibration", true)) {
      notificationsHelper.setVibration();
    }
  }
}
/*
 * Copyright (C) 2013-2024 Federico Iosue (federico@iosue.it)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.feio.android.omninotes.utils;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertEquals;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import it.feio.android.omninotes.models.Note;
import java.util.Calendar;
import org.junit.Test;
import org.junit.runner.RunWith;
@RunWith(AndroidJUnit4.class)
public class ReminderHelperTest {
  @Test
  public void shouldGetRequestCode() {
    Long now = Calendar.getInstance().getTimeInMillis();
    Note note = new Note();
    note.setAlarm(now);
    int requestCode = ReminderHelper.getRequestCode(note);
    int requestCode2 = ReminderHelper.getRequestCode(note);
    assertEquals(requestCode, requestCode2);
    assertTrue(String.valueOf(now).startsWith(String.valueOf(requestCode)));
  }
  @Test
  public void shouldAddReminder() {
    Note note = buildNote();
    ReminderHelper
        .addReminder(InstrumentationRegistry.getInstrumentation().getTargetContext(), note);
    boolean reminderActive = ReminderHelper
        .checkReminder(InstrumentationRegistry.getInstrumentation().getTargetContext(), note);
    assertTrue(reminderActive);
  }
  @Test
  public void shouldNotAddReminderWithPassedTime() {
    Note note = buildNote();
    note.setAlarm(Calendar.getInstance().getTimeInMillis());
    ReminderHelper
        .addReminder(InstrumentationRegistry.getInstrumentation().getTargetContext(), note);
    boolean reminderActive = ReminderHelper
        .checkReminder(InstrumentationRegistry.getInstrumentation().getTargetContext(), note);
    assertFalse(reminderActive);
  }
  @Test
  public void shouldRemoveReminder() {
    Note note = buildNote();
    ReminderHelper
        .addReminder(InstrumentationRegistry.getInstrumentation().getTargetContext(), note);
    boolean reminderActive = ReminderHelper
        .checkReminder(InstrumentationRegistry.getInstrumentation().getTargetContext(), note);
    ReminderHelper
        .removeReminder(InstrumentationRegistry.getInstrumentation().getTargetContext(), note);
    boolean reminderRemoved = ReminderHelper
        .checkReminder(InstrumentationRegistry.getInstrumentation().getTargetContext(), note);
    assertTrue(reminderActive);
    assertFalse(reminderRemoved);
  }
  private Note buildNote() {
    long now = Calendar.getInstance().getTimeInMillis();
    Note note = new Note();
    note.setCreation(now);
    note.setAlarm(now + 1000);
    return note;
  }
}