package org.openmrs.api;
import org.openmrs.ProgramAttributeType;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import org.openmrs.Cohort;
import org.openmrs.Concept;
import org.openmrs.ConceptStateConversion;
import org.openmrs.Patient;
import org.openmrs.PatientProgram;
import org.openmrs.PatientProgramAttribute;
import org.openmrs.PatientState;
import org.openmrs.Program;
import org.openmrs.ProgramWorkflow;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.annotation.Authorized;
import org.openmrs.api.db.ProgramWorkflowDAO;
import org.openmrs.util.PrivilegeConstants;
import org.springframework.transaction.annotation.Transactional;
public interface ProgramWorkflowService extends OpenmrsService {
	public void setProgramWorkflowDAO(ProgramWorkflowDAO dao);
	@Authorized( { PrivilegeConstants.MANAGE_PROGRAMS })
	public Program saveProgram(Program program) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PROGRAMS })
	public Program getProgram(Integer programId) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PROGRAMS })
	public Program getProgramByName(String name) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PROGRAMS })
	public List<Program> getAllPrograms() throws APIException;
	@Authorized( { PrivilegeConstants.GET_PROGRAMS })
	public List<Program> getAllPrograms(boolean includeRetired) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PROGRAMS })
	public List<Program> getPrograms(String nameFragment) throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_PROGRAMS })
	public void purgeProgram(Program program) throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_PROGRAMS })
	public void purgeProgram(Program program, boolean cascade) throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_PROGRAMS })
	public Program retireProgram(Program program, String reason) throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_PROGRAMS })
	public Program unretireProgram(Program program) throws APIException;
	public Program getProgramByUuid(String uuid);
	public PatientState getPatientStateByUuid(String uuid);
	@Authorized( { PrivilegeConstants.ADD_PATIENT_PROGRAMS, PrivilegeConstants.EDIT_PATIENT_PROGRAMS })
	public PatientProgram savePatientProgram(PatientProgram patientProgram) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENT_PROGRAMS })
	public PatientProgram getPatientProgram(Integer patientProgramId) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENT_PROGRAMS })
	public List<PatientProgram> getPatientPrograms(Patient patient, Program program, Date minEnrollmentDate,
	        Date maxEnrollmentDate, Date minCompletionDate, Date maxCompletionDate, boolean includeVoided)
	        throws APIException;
	@Authorized( { PrivilegeConstants.PURGE_PATIENT_PROGRAMS })
	public void purgePatientProgram(PatientProgram patientProgram) throws APIException;
	@Authorized( { PrivilegeConstants.PURGE_PATIENT_PROGRAMS })
	public void purgePatientProgram(PatientProgram patientProgram, boolean cascade) throws APIException;
	@Authorized( { PrivilegeConstants.DELETE_PATIENT_PROGRAMS })
	public PatientProgram voidPatientProgram(PatientProgram patientProgram, String reason) throws APIException;
	@Authorized( { PrivilegeConstants.DELETE_PATIENT_PROGRAMS })
	public PatientProgram unvoidPatientProgram(PatientProgram patientProgram) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PROGRAMS })
	public List<Concept> getPossibleOutcomes(Integer programId);
	public ProgramWorkflow getWorkflow(Integer workflowId);
	public ProgramWorkflow getWorkflowByUuid(String uuid);
	@Authorized( { PrivilegeConstants.ADD_PATIENT_PROGRAMS, PrivilegeConstants.EDIT_PATIENT_PROGRAMS })
	public ConceptStateConversion saveConceptStateConversion(ConceptStateConversion conceptStateConversion)
	        throws APIException;
	@Authorized( { PrivilegeConstants.GET_PROGRAMS })
	public ConceptStateConversion getConceptStateConversion(Integer conceptStateConversionId) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PROGRAMS })
	public List<ConceptStateConversion> getAllConceptStateConversions() throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_PROGRAMS })
	public void purgeConceptStateConversion(ConceptStateConversion conceptStateConversion) throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_PROGRAMS })
	public void purgeConceptStateConversion(ConceptStateConversion conceptStateConversion, boolean cascade)
	        throws APIException;
	public ConceptStateConversion getConceptStateConversion(ProgramWorkflow workflow, Concept trigger) throws APIException;
	public ProgramWorkflowState getState(Integer stateId);
	public ProgramWorkflowState getStateByUuid(String uuid);
	public PatientProgram getPatientProgramByUuid(String uuid);
	@Authorized( { PrivilegeConstants.GET_PATIENT_PROGRAMS })
	public List<PatientProgram> getPatientPrograms(Cohort cohort, Collection<Program> programs);
	@Authorized( { PrivilegeConstants.GET_PATIENT_PROGRAMS })
	public List<Program> getProgramsByConcept(Concept concept);
	@Authorized( { PrivilegeConstants.GET_PATIENT_PROGRAMS })
	public List<ProgramWorkflow> getProgramWorkflowsByConcept(Concept concept);
	@Authorized( { PrivilegeConstants.GET_PATIENT_PROGRAMS })
	public List<ProgramWorkflowState> getProgramWorkflowStatesByConcept(Concept concept);
	public ConceptStateConversion getConceptStateConversionByUuid(String uuid);
        @Transactional(readOnly = true)
        @Authorized({"Get Patient Program Attribute Types"})
        public List<ProgramAttributeType> getAllProgramAttributeTypes();
        @Transactional(readOnly = true)
        @Authorized({"Get Patient Program Attribute Types"})
        public ProgramAttributeType getProgramAttributeType(Integer var1);
        @Transactional(readOnly = true)
        @Authorized({"Get Patient Program Attribute Types"})
        public ProgramAttributeType getProgramAttributeTypeByUuid(String var1);
        @Authorized({"Manage Patient Program Attribute Types"})
        public ProgramAttributeType saveProgramAttributeType(ProgramAttributeType var1);
        @Authorized({"Purge Patient Program Attribute Types"})
        public void purgeProgramAttributeType(ProgramAttributeType var1);
        @Transactional(readOnly = true)
        @Authorized({"Get Patient Programs"})
        public PatientProgramAttribute getPatientProgramAttributeByUuid(String var1);
        public Map<Object, Object> getPatientProgramAttributeByAttributeName(List<Integer> patients, String attributeName);
        @Transactional(readOnly = true)
        @Authorized({"Get Patient Programs"})
        public List<PatientProgram> getPatientProgramByAttributeNameAndValue(String attributeName, String attributeValue);       
}
package org.openmrs;
import org.hibernate.envers.Audited;
@Audited
public class ProgramWorkflowState extends BaseChangeableOpenmrsMetadata {
	private static final long serialVersionUID = 1L;
	private Integer programWorkflowStateId;
	private ProgramWorkflow programWorkflow;
	private Concept concept;
	private Boolean initial;
	private Boolean terminal;
	public ProgramWorkflowState() {
	}
	public ProgramWorkflowState(Integer programWorkflowStateId) {
		setProgramWorkflowStateId(programWorkflowStateId);
	}
	@Override
	public String toString() {
		return "State " + getConcept().toString() + " initial=" + getInitial() + " terminal=" + getTerminal();
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		this.concept = concept;
	}
	public Boolean getInitial() {
		return initial;
	}
	public void setInitial(Boolean initial) {
		this.initial = initial;
	}
	public Boolean getTerminal() {
		return terminal;
	}
	public void setTerminal(Boolean terminal) {
		this.terminal = terminal;
	}
	public ProgramWorkflow getProgramWorkflow() {
		return programWorkflow;
	}
	public void setProgramWorkflow(ProgramWorkflow programWorkflow) {
		this.programWorkflow = programWorkflow;
	}
	public Integer getProgramWorkflowStateId() {
		return programWorkflowStateId;
	}
	public void setProgramWorkflowStateId(Integer programWorkflowStateId) {
		this.programWorkflowStateId = programWorkflowStateId;
	}
	@Override
	public Integer getId() {
		return getProgramWorkflowStateId();
	}
	@Override
	public void setId(Integer id) {
		setProgramWorkflowStateId(id);
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.openmrs.attribute.Attribute;
import org.openmrs.attribute.BaseAttribute;
@Audited
public class PatientProgramAttribute extends BaseAttribute<ProgramAttributeType, PatientProgram> implements Attribute<ProgramAttributeType, PatientProgram> {
    private Integer patientProgramAttributeId;
    @Override
    public Integer getId() {
        return getPatientProgramAttributeId();
    }
    @Override
    public void setId(Integer id) {
        setPatientProgramAttributeId(id);
    }
    public PatientProgram getPatientProgram() {
        return getOwner();
    }
    public void setPatientProgram(PatientProgram patientProgram) {
        setOwner(patientProgram);
    }
    public Integer getPatientProgramAttributeId() {
        return patientProgramAttributeId;
    }
    public void setPatientProgramAttributeId(Integer id) {
        this.patientProgramAttributeId = id;
    }
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.Customizable;
import org.openmrs.util.OpenmrsUtil;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
@Audited
public class PatientProgram extends BaseChangeableOpenmrsData implements Customizable<PatientProgramAttribute>{
	public static final long serialVersionUID = 0L;
	private Integer patientProgramId;
	private Patient patient;
	private Program program;
	private Location location;
	private Date dateEnrolled;
	private Date dateCompleted;
	private Concept outcome;
	private Set<PatientState> states = new HashSet<>();
	private Set<PatientProgramAttribute> attributes = new LinkedHashSet<>();
	public PatientProgram() {
	}
	public PatientProgram(Integer patientProgramId) {
		setPatientProgramId(patientProgramId);
	}
	public PatientProgram copy() {
		return copyHelper(new PatientProgram());
	}
	protected PatientProgram copyHelper(PatientProgram target) {
		target.setPatient(this.getPatient());
		target.setProgram(this.getProgram());
		target.setLocation(this.getLocation());
		target.setDateEnrolled(this.getDateEnrolled());
		target.setDateCompleted(target.getDateCompleted());
		Set<PatientState> statesCopy = new HashSet<>();
		if (this.getStates() != null) {
			for (PatientState s : this.getStates()) {
				PatientState stateCopy = s.copy();
				stateCopy.setPatientProgram(target);
				statesCopy.add(stateCopy);
			}
		}
		target.setStates(statesCopy);
		target.setCreator(this.getCreator());
		target.setDateCreated(this.getDateCreated());
		target.setChangedBy(this.getChangedBy());
		target.setDateChanged(this.getDateChanged());
		target.setVoided(this.getVoided());
		target.setVoidedBy(this.getVoidedBy());
		target.setDateVoided(this.getDateVoided());
		target.setVoidReason(this.getVoidReason());
		return target;
	}
	public boolean getActive(Date onDate) {
		if (onDate == null) {
			onDate = new Date();
		}
		return !getVoided() && (getDateEnrolled() == null || OpenmrsUtil.compare(getDateEnrolled(), onDate) <= 0)
		        && (getDateCompleted() == null || OpenmrsUtil.compare(getDateCompleted(), onDate) > 0);
	}
	public boolean getActive() {
		return getActive(null);
	}
	public PatientState getPatientState(Integer patientStateId) {
		for (PatientState s : getStates()) {
			if (s.getPatientStateId() != null && s.getPatientStateId().equals(patientStateId)) {
				return s;
			}
		}
		return null;
	}
	public void transitionToState(ProgramWorkflowState programWorkflowState, Date onDate) {
		PatientState lastState = getCurrentState(programWorkflowState.getProgramWorkflow());
		if (lastState != null && onDate == null) {
			throw new IllegalArgumentException("You can't change from a non-null state without giving a change date");
		}
		if (lastState != null && lastState.getEndDate() != null) {
			throw new IllegalArgumentException("You can't change out of a state that has an end date already");
		}
		if (lastState != null && lastState.getStartDate() != null
		        && OpenmrsUtil.compare(lastState.getStartDate(), onDate) > 0) {
			throw new IllegalArgumentException("You can't change out of a state before that state started");
		}
		if (lastState != null
		        && !programWorkflowState.getProgramWorkflow().isLegalTransition(lastState.getState(), programWorkflowState)) {
			throw new IllegalArgumentException("You can't change from state " + lastState.getState() + " to "
			        + programWorkflowState);
		}
		if (lastState != null) {
			lastState.setEndDate(onDate);
		}
		PatientState newState = new PatientState();
		newState.setPatientProgram(this);
		newState.setState(programWorkflowState);
		newState.setStartDate(onDate);
		if (newState.getPatientProgram() != null && newState.getPatientProgram().getDateCompleted() != null) {
			newState.setEndDate(newState.getPatientProgram().getDateCompleted());
		}
		if (programWorkflowState.getTerminal()) {
			setDateCompleted(onDate);
		}
		getStates().add(newState);
	}
	public void voidLastState(ProgramWorkflow workflow, User voidBy, Date voidDate, String voidReason) {
		List<PatientState> states = statesInWorkflow(workflow, false);
		if (voidDate == null) {
			voidDate = new Date();
		}
		PatientState last = null;
		PatientState nextToLast = null;
		if (!states.isEmpty()) {
			last = states.get(states.size() - 1);
		}
		if (states.size() > 1) {
			nextToLast = states.get(states.size() - 2);
		}
		if (last != null) {
			last.setVoided(true);
			last.setVoidedBy(voidBy);
			last.setDateVoided(voidDate);
			last.setVoidReason(voidReason);
		}
		if (nextToLast != null && nextToLast.getEndDate() != null) {
			nextToLast.setEndDate(nextToLast.getPatientProgram() != null
			        && nextToLast.getPatientProgram().getDateCompleted() != null ? nextToLast.getPatientProgram()
			        .getDateCompleted() : null);
			nextToLast.setDateChanged(voidDate);
			nextToLast.setChangedBy(voidBy);
		}
	}
	public PatientState getCurrentState(ProgramWorkflow programWorkflow) {
		Date now = new Date();
		PatientState currentState = null;
		for (PatientState state : getSortedStates()) {
			if ((programWorkflow == null || state.getState().getProgramWorkflow().equals(programWorkflow))
			        && state.getActive(now)) {
				currentState = state;
			}
		}
		return currentState;
	}
	public Set<PatientState> getCurrentStates() {
		Set<PatientState> ret = new HashSet<>();
		Date now = new Date();
		for (PatientState state : getStates()) {
			if (state.getActive(now)) {
				ret.add(state);
			}
		}
		return ret;
	}
	public Set<PatientState> getMostRecentStateInEachWorkflow() {
		HashMap<ProgramWorkflow,PatientState> map = new HashMap<>();
		for (PatientState state : getSortedStates()) {
			if (!state.isVoided()) {
				ProgramWorkflow workflow = state.getState().getProgramWorkflow();
				map.put(workflow,state);
			}
		}
		Set<PatientState> ret = new HashSet<>();
		for (Map.Entry<ProgramWorkflow, PatientState> entry : map.entrySet()) {
			ret.add(entry.getValue());
		}
		return ret;
	}
	public List<PatientState> statesInWorkflow(ProgramWorkflow programWorkflow, boolean includeVoided) {
		List<PatientState> ret = new ArrayList<>();
		for (PatientState st : getSortedStates()) {
			if (st.getState().getProgramWorkflow().equals(programWorkflow) && (includeVoided || !st.getVoided())) {
				ret.add(st);
			}
		}
		return ret;
	}
	@Override
	public String toString() {
		return "PatientProgram(id=" + getPatientProgramId() + ", patient=" + getPatient() + ", program=" + getProgram()
		        + ")";
	}
	public Concept getOutcome() {
		return outcome;
	}
	public void setOutcome(Concept concept) {
		this.outcome = concept;
	}
	public Date getDateCompleted() {
		return dateCompleted;
	}
	public void setDateCompleted(Date dateCompleted) {
		this.dateCompleted = dateCompleted;
	}
	public Date getDateEnrolled() {
		return dateEnrolled;
	}
	public void setDateEnrolled(Date dateEnrolled) {
		this.dateEnrolled = dateEnrolled;
	}
	public Patient getPatient() {
		return patient;
	}
	public void setPatient(Patient patient) {
		this.patient = patient;
	}
	public Integer getPatientProgramId() {
		return patientProgramId;
	}
	public void setPatientProgramId(Integer patientProgramId) {
		this.patientProgramId = patientProgramId;
	}
	public Program getProgram() {
		return program;
	}
	public void setProgram(Program program) {
		this.program = program;
	}
	public Set<PatientState> getStates() {
		return states;
	}
	public void setStates(Set<PatientState> states) {
		this.states = states;
	}
	@Override
	public Integer getId() {
		return getPatientProgramId();
	}
	@Override
	public void setId(Integer id) {
		setPatientProgramId(id);
	}
	public Location getLocation() {
		return location;
	}
	public void setLocation(Location location) {
		this.location = location;
	}
	private List<PatientState> getSortedStates() {
		List<PatientState> sortedStates = new ArrayList<>(getStates());
		Collections.sort(sortedStates);
		return sortedStates;
	}
        @Override
        public Set<PatientProgramAttribute> getAttributes() {
            return attributes;
        }
        @Override
        public Collection<PatientProgramAttribute> getActiveAttributes() {
            ArrayList<PatientProgramAttribute> ret = new ArrayList<>();
            if (this.getAttributes() != null) {
                for (PatientProgramAttribute attr : this.getAttributes()) {
                    if (!attr.isVoided()) {
                        ret.add(attr);
                    }
                }
            }
            return ret;
        }
        @Override
        public List<PatientProgramAttribute> getActiveAttributes(CustomValueDescriptor ofType) {
            ArrayList<PatientProgramAttribute> ret = new ArrayList<>();
            if (this.getAttributes() != null) {
                for (PatientProgramAttribute attr : this.getAttributes()) {
                    if (attr.getAttributeType().equals(ofType) && !attr.isVoided()) {
                        ret.add(attr);
                    }
                }
            }
            return ret;
        }
        @Override
        public void addAttribute(PatientProgramAttribute attribute) {
            if (this.getAttributes() == null) {
                this.setAttributes(new LinkedHashSet<>());
            }
            this.getAttributes().add(attribute);
            attribute.setOwner(this);
        }
        public void setAttributes(Set<PatientProgramAttribute> attributes) {
            this.attributes = attributes;
        }
        public void setAttribute(PatientProgramAttribute attribute) {
            if (this.getAttributes() == null) {
                this.addAttribute(attribute);
            } else {
                if (this.getActiveAttributes(attribute.getAttributeType()).size() == 1) {
                    PatientProgramAttribute patientProgramAttribute = this.getActiveAttributes(attribute.getAttributeType()).get(0);
                    if (!patientProgramAttribute.getValue().equals(attribute.getValue())) {
                        if (patientProgramAttribute.getId() != null) {
                            patientProgramAttribute.setVoided(Boolean.TRUE);
                        } else {
                            this.getAttributes().remove(patientProgramAttribute);
                        }
                        this.getAttributes().add(attribute);
                        attribute.setOwner(this);
                    }
                } else {
                    for (PatientProgramAttribute existing : this.getActiveAttributes(attribute.getAttributeType())) {
                        if (existing.getAttributeType().equals(attribute.getAttributeType())) {
                            if (existing.getId() != null) {
                                existing.setVoided(Boolean.TRUE);
                            } else {
                                this.getAttributes().remove(existing);
                            }
                        }
                    }
                    this.getAttributes().add(attribute);
                    attribute.setOwner(this);
                }
            }
        }
}
package org.openmrs;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.Parameter;
import org.hibernate.envers.Audited;
import org.openmrs.attribute.AttributeType;
import org.openmrs.attribute.BaseAttributeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;
@Entity
@Table(name = "program_attribute_type")
@Audited
public class ProgramAttributeType extends BaseAttributeType<PatientProgram> implements AttributeType<PatientProgram> {
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "program_attribute_type_id_seq")
	@GenericGenerator(
		name = "program_attribute_type_id_seq",
		strategy = "native",
		parameters = @Parameter(name = "sequence", value = "program_attribute_type_program_attribute_type_id_seq")
	)
	@Column(name = "program_attribute_type_id")
    private Integer programAttributeTypeId;
    @Override
    public Integer getId() {
        return getProgramAttributeTypeId();
    }
    @Override
    public void setId(Integer id) {
        setProgramAttributeTypeId(id);
    }
    public Integer getProgramAttributeTypeId() {
        return programAttributeTypeId;
    }
    public void setProgramAttributeTypeId(Integer programAttributeTypeId) {
        this.programAttributeTypeId = programAttributeTypeId;
    }
}
package org.openmrs.attribute;
import javax.persistence.Column;
import javax.persistence.MappedSuperclass;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.Field;
import org.openmrs.BaseChangeableOpenmrsData;
import org.openmrs.customdatatype.CustomDatatypeUtil;
import org.openmrs.customdatatype.Customizable;
import org.openmrs.customdatatype.InvalidCustomValueException;
import org.openmrs.customdatatype.NotYetPersistedException;
import org.openmrs.util.OpenmrsUtil;
@SuppressWarnings("rawtypes")
@MappedSuperclass
@Audited
public abstract class BaseAttribute<AT extends AttributeType, OwningType extends Customizable<?>> extends BaseChangeableOpenmrsData implements Attribute<AT, OwningType>, Comparable<Attribute> {
	private OwningType owner;
	private AT attributeType;
	@Field
	@Column(name = "value_reference", nullable = false, length = 65535)
	private String valueReference;
	private transient Object value;
	private transient boolean dirty = false;
	@Override
	public OwningType getOwner() {
		return owner;
	}
	@Override
	public void setOwner(OwningType owner) {
		this.owner = owner;
	}
	public void setAttributeType(AT attributeType) {
		this.attributeType = attributeType;
	}
	@Override
	public AT getAttributeType() {
		return attributeType;
	}
	@Override
	public AT getDescriptor() {
		return getAttributeType();
	}
	@Override
	public String getValueReference() {
		if (valueReference == null) {
			throw new NotYetPersistedException();
		} else {
			return valueReference;
		}
	}
	@Override
	public void setValueReferenceInternal(String valueReference) throws InvalidCustomValueException {
		this.valueReference = valueReference;
		this.dirty = false;
	}
	@Override
	public Object getValue() throws InvalidCustomValueException {
		if (value == null) {
			value = CustomDatatypeUtil.getDatatype(getAttributeType()).fromReferenceString(getValueReference());
		}
		return value;
	}
	@Override
	public <T> void setValue(T typedValue) throws InvalidCustomValueException {
		dirty = true;
		value = typedValue;
	}
	@Override
	public boolean isDirty() {
		return dirty;
	}
	@SuppressWarnings("squid:S1210")
	@Override
	public int compareTo(Attribute other) {
		if (other == null) {
			return -1;
		}
		int retValue = getVoided().compareTo(other.getVoided());
		if (retValue == 0) {
			retValue = OpenmrsUtil.compareWithNullAsGreatest(getAttributeType().getId(), other.getAttributeType().getId());
		}
		if (retValue == 0) {
			retValue = OpenmrsUtil.compareWithNullAsGreatest(getValueReference(), other.getValueReference());
		}
		if (retValue == 0) {
			retValue = OpenmrsUtil.compareWithNullAsGreatest(getId(), other.getId());
		}
		return retValue;
	}
}
package org.openmrs.api.impl;
import java.util.ArrayList;
import java.util.Set;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import org.openmrs.Cohort;
import org.openmrs.Concept;
import org.openmrs.ConceptAnswer;
import org.openmrs.ConceptStateConversion;
import org.openmrs.Patient;
import org.openmrs.PatientProgram;
import org.openmrs.PatientProgramAttribute;
import org.openmrs.PatientState;
import org.openmrs.Program;
import org.openmrs.ProgramAttributeType;
import org.openmrs.ProgramWorkflow;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.api.APIException;
import org.openmrs.api.ProgramNameDuplicatedException;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.ProgramWorkflowDAO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
@Transactional
public class ProgramWorkflowServiceImpl extends BaseOpenmrsService implements ProgramWorkflowService {
	private static final Logger log = LoggerFactory.getLogger(ProgramWorkflowServiceImpl.class);
	protected ProgramWorkflowDAO dao;
	public ProgramWorkflowServiceImpl() {
	}
	@Override
	public void setProgramWorkflowDAO(ProgramWorkflowDAO dao) {
		this.dao = dao;
	}
	@Override
	public Program saveProgram(Program program) throws APIException {
		if (program.getConcept() == null) {
			throw new APIException("Program.concept.required", (Object[]) null);
		}
		for (ProgramWorkflow workflow : program.getAllWorkflows()) {
			if (workflow.getConcept() == null) {
				throw new APIException("ProgramWorkflow.concept.required", (Object[]) null);
			}			
			ensureProgramIsSet(workflow, program);						
			for (ProgramWorkflowState state : workflow.getStates()) {
				if (state.getConcept() == null || state.getInitial() == null || state.getTerminal() == null) {
					throw new APIException("ProgramWorkflowState.requires", (Object[]) null);
				}				
				ensureProgramWorkflowIsSet(state, workflow);
			}
		}
		return dao.saveProgram(program);
	}
	private void ensureProgramIsSet(ProgramWorkflow workflow, Program program) {		
		if (workflow.getProgram() == null) {
			workflow.setProgram(program);
		} else if (!workflow.getProgram().equals(program)) {
			throw new APIException("Program.error.contains.ProgramWorkflow", new Object[] { workflow.getProgram() });
		}
	}
	private void ensureProgramWorkflowIsSet(ProgramWorkflowState state, ProgramWorkflow workflow) {
		if (state.getProgramWorkflow() == null) {
			state.setProgramWorkflow(workflow);
		} else if (!state.getProgramWorkflow().equals(workflow)) {
			throw new APIException("ProgramWorkflow.error.contains.state", new Object[] { workflow.getProgram() });
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Program getProgram(Integer id) {
		return dao.getProgram(id);
	}
	@Transactional(readOnly = true)
	public Program getProgram(String name) {
		return Context.getProgramWorkflowService().getProgramByName(name);
	}
	@Override
	@Transactional(readOnly = true)
	public Program getProgramByName(String name) throws APIException {
		List<Program> programs = dao.getProgramsByName(name, false);
		if (programs.isEmpty()) {
			programs = dao.getProgramsByName(name, true);
		}
		if (programs.size() > 1) {
			throw new ProgramNameDuplicatedException(name);
		}
		return programs.isEmpty() ? null : programs.get(0);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Program> getAllPrograms() throws APIException {
		return Context.getProgramWorkflowService().getAllPrograms(true);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Program> getAllPrograms(boolean includeRetired) throws APIException {
		return dao.getAllPrograms(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Program> getPrograms(String nameFragment) throws APIException {
		return dao.findPrograms(nameFragment);
	}
	@Override
	public void purgeProgram(Program program) throws APIException {
		Context.getProgramWorkflowService().purgeProgram(program, false);
	}
	@Override
	public void purgeProgram(Program program, boolean cascade) throws APIException {
		if (cascade && !program.getAllWorkflows().isEmpty()) {
			throw new APIException("Program.cascade.purging.not.implemented", (Object[]) null);
		}
		for (PatientProgram patientProgram : Context.getProgramWorkflowService().getPatientPrograms(null, program, null,
		    null, null, null, true)) {
			purgePatientProgram(patientProgram);
		}
		dao.deleteProgram(program);
	}
	@Override
	public Program retireProgram(Program program, String reason) throws APIException {
		for (ProgramWorkflow workflow : program.getWorkflows()) {
			workflow.setRetired(true);
			for (ProgramWorkflowState state : workflow.getStates()) {
				state.setRetired(true);
			}
		}
		return saveProgram(program);
	}
	@Override
	public Program unretireProgram(Program program) throws APIException {
		Date lastModifiedDate = program.getDateChanged();
		program.setRetired(false);
		for (ProgramWorkflow workflow : program.getAllWorkflows()) {
			if (lastModifiedDate != null && lastModifiedDate.equals(workflow.getDateChanged())) {
				workflow.setRetired(false);
				for (ProgramWorkflowState state : workflow.getStates()) {
					if (lastModifiedDate.equals(state.getDateChanged())) {
						state.setRetired(false);
					}
				}
			}
		}
		return saveProgram(program);
	}
	@Override
	public PatientProgram savePatientProgram(PatientProgram patientProgram) throws APIException {
		if (patientProgram.getPatient() == null || patientProgram.getProgram() == null) {
			throw new APIException("PatientProgram.requires", (Object[]) null);
		}
		for (PatientState state : patientProgram.getStates()) {
			if (state.getState() == null) {
				throw new APIException("PatientState.requires", (Object[]) null);
			}
			if (state.getPatientProgram() == null) {
				state.setPatientProgram(patientProgram);
			} else if (!state.getPatientProgram().equals(patientProgram)) {
				throw new APIException("PatientProgram.already.assigned", new Object[] { state.getPatientProgram() });
			}
			if (patientProgram.getVoided() || state.getVoided()) {
				state.setVoided(true);
				if (state.getVoidReason() == null && patientProgram.getVoidReason() != null) {
					state.setVoidReason(patientProgram.getVoidReason());
				}
			}
		}
		if (patientProgram.getDateCompleted() != null) {
			for (PatientState state : patientProgram.getMostRecentStateInEachWorkflow()) {
				if (state.getEndDate() == null) {
					state.setEndDate(patientProgram.getDateCompleted());
				}
			}
		}
		return dao.savePatientProgram(patientProgram);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientProgram getPatientProgram(Integer patientProgramId) {
		return dao.getPatientProgram(patientProgramId);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientProgram> getPatientPrograms(Patient patient, Program program, Date minEnrollmentDate,
	        Date maxEnrollmentDate, Date minCompletionDate, Date maxCompletionDate, boolean includeVoided)
	                throws APIException {
		return dao.getPatientPrograms(patient, program, minEnrollmentDate, maxEnrollmentDate, minCompletionDate,
		    maxCompletionDate, includeVoided);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientProgram> getPatientPrograms(Cohort cohort, Collection<Program> programs) {
		if (cohort.getMemberIds().isEmpty()) {
			return dao.getPatientPrograms(null, programs);
		} else {
			return dao.getPatientPrograms(cohort, programs);
		}
	}
	@Override
	public void purgePatientProgram(PatientProgram patientProgram) throws APIException {
		Context.getProgramWorkflowService().purgePatientProgram(patientProgram, false);
	}
	@Override
	public void purgePatientProgram(PatientProgram patientProgram, boolean cascade) throws APIException {
		if (cascade && !patientProgram.getStates().isEmpty()) {
			throw new APIException("PatientProgram.cascade.purging.not.implemented", (Object[]) null);
		}
		dao.deletePatientProgram(patientProgram);
	}
	@Override
	public PatientProgram voidPatientProgram(PatientProgram patientProgram, String reason) {
		patientProgram.setVoided(true);
		patientProgram.setVoidReason(reason);
		return Context.getProgramWorkflowService().savePatientProgram(patientProgram); 
	}
	@Override
	public PatientProgram unvoidPatientProgram(PatientProgram patientProgram) {
		Date voidDate = patientProgram.getDateVoided();
		patientProgram.setVoided(false);
		for (PatientState state : patientProgram.getStates()) {
			if (voidDate != null && voidDate.equals(state.getDateVoided())) {
				state.setVoided(false);
				state.setVoidedBy(null);
				state.setDateVoided(null);
				state.setVoidReason(null);
			}
		}
		return Context.getProgramWorkflowService().savePatientProgram(patientProgram); 
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getPossibleOutcomes(Integer programId) {
		List<Concept> possibleOutcomes = new ArrayList<>();
		Program program = Context.getProgramWorkflowService().getProgram(programId);
		if (program == null) {
			return possibleOutcomes;
		}
		Concept outcomesConcept = program.getOutcomesConcept();
		if (outcomesConcept == null) {
			return possibleOutcomes;
		}
		if (!outcomesConcept.getAnswers().isEmpty()) {
			for (ConceptAnswer conceptAnswer : outcomesConcept.getAnswers()) {
				possibleOutcomes.add(conceptAnswer.getAnswerConcept());
			}
			return possibleOutcomes;
		}
		if (!outcomesConcept.getSetMembers().isEmpty()) {
			return outcomesConcept.getSetMembers();
		}
		return possibleOutcomes;
	}
	@Override
	public ConceptStateConversion saveConceptStateConversion(ConceptStateConversion csc) throws APIException {
		if (csc.getConcept() == null || csc.getProgramWorkflow() == null || csc.getProgramWorkflowState() == null) {
			throw new APIException("ConceptStateConversion.requires", (Object[]) null);
		}
		return dao.saveConceptStateConversion(csc);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptStateConversion getConceptStateConversion(Integer id) {
		return dao.getConceptStateConversion(id);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptStateConversion> getAllConceptStateConversions() throws APIException {
		return dao.getAllConceptStateConversions();
	}
	@Override
	public void purgeConceptStateConversion(ConceptStateConversion conceptStateConversion) throws APIException {
		Context.getProgramWorkflowService().purgeConceptStateConversion(conceptStateConversion, false);
	}
	@Override
	public void purgeConceptStateConversion(ConceptStateConversion conceptStateConversion, boolean cascade)
	        throws APIException {
		dao.deleteConceptStateConversion(conceptStateConversion);
	}
	public void triggerStateConversion(Patient patient, Concept trigger, Date dateConverted) {
		if (patient == null) {
			throw new APIException("convert.state.invalid.patient", (Object[]) null);
		}
		if (trigger == null) {
			throw new APIException("convert.state.patient.without.valid.trigger", (Object[]) null);
		}
		if (dateConverted == null) {
			throw new APIException("convert.state.invalid.date", (Object[]) null);
		}
		for (PatientProgram patientProgram : getPatientPrograms(patient, null, null, null, null, null, false)) {
			if (patientProgram.getDateCompleted() == null) {
				Set<ProgramWorkflow> workflows = patientProgram.getProgram().getWorkflows();
				for (ProgramWorkflow workflow : workflows) {
					PatientState patientState = patientProgram.getCurrentState(workflow);
					ProgramWorkflowState currentState = (patientState != null) ? patientState.getState() : null;
					ProgramWorkflowState transitionState = workflow.getState(trigger);
					log.debug("Transitioning from current state [" + currentState + "]");
					log.debug("|---> Transitioning to final state [" + transitionState + "]");
					if (transitionState != null && workflow.isLegalTransition(currentState, transitionState)) {
						patientProgram.transitionToState(transitionState, dateConverted);
						log.debug("State Conversion Triggered: patientProgram=" + patientProgram + " transition from "
						        + currentState + " to " + transitionState + " on " + dateConverted);
					}
				}
				Context.getProgramWorkflowService().savePatientProgram(patientProgram);
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptStateConversion getConceptStateConversion(ProgramWorkflow workflow, Concept trigger) {
		return dao.getConceptStateConversion(workflow, trigger);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Program> getProgramsByConcept(Concept concept) {
		return dao.getProgramsByConcept(concept);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ProgramWorkflow> getProgramWorkflowsByConcept(Concept concept) {
		return dao.getProgramWorkflowsByConcept(concept);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ProgramWorkflowState> getProgramWorkflowStatesByConcept(Concept concept) {
		return dao.getProgramWorkflowStatesByConcept(concept);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptStateConversion getConceptStateConversionByUuid(String uuid) {
		return dao.getConceptStateConversionByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientProgram getPatientProgramByUuid(String uuid) {
		return dao.getPatientProgramByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public Program getProgramByUuid(String uuid) {
		return dao.getProgramByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ProgramWorkflowState getState(Integer stateId) {
		return dao.getState(stateId);
	}
	@Override
	@Transactional(readOnly = true)
	public ProgramWorkflowState getStateByUuid(String uuid) {
		return dao.getStateByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientState getPatientStateByUuid(String uuid) {
		return dao.getPatientStateByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ProgramWorkflow getWorkflow(Integer workflowId) {
		return dao.getWorkflow(workflowId);
	}
	@Override
	@Transactional(readOnly = true)
	public ProgramWorkflow getWorkflowByUuid(String uuid) {
		return dao.getWorkflowByUuid(uuid);
	}
        @Override
        public List<ProgramAttributeType> getAllProgramAttributeTypes() {
            return dao.getAllProgramAttributeTypes();
        }
        @Override
        public ProgramAttributeType getProgramAttributeType(Integer id) {
            return dao.getProgramAttributeType(id);
        }
        @Override
        public ProgramAttributeType getProgramAttributeTypeByUuid(String uuid) {
            return dao.getProgramAttributeTypeByUuid(uuid);
        }
        @Override
        public ProgramAttributeType saveProgramAttributeType(ProgramAttributeType type) {
            return dao.saveProgramAttributeType(type);
        }
        @Override
        public void purgeProgramAttributeType(ProgramAttributeType type) {
            dao.purgeProgramAttributeType(type);
        }
        @Override
        public PatientProgramAttribute getPatientProgramAttributeByUuid(String uuid) {
            return dao.getPatientProgramAttributeByUuid(uuid);
        }
        @Override
        public Map<Object, Object> getPatientProgramAttributeByAttributeName(List<Integer> patients, String attributeName){
            return dao.getPatientProgramAttributeByAttributeName(patients, attributeName);
        }
        @Override
        public List<PatientProgram> getPatientProgramByAttributeNameAndValue(String attributeName, String attributeValue) {
            return dao.getPatientProgramByAttributeNameAndValue(attributeName, attributeValue);
        }	
}
package org.openmrs;
import java.util.Date;
import javax.persistence.Column;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.MappedSuperclass;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.Field;
@MappedSuperclass
@Audited
public abstract class BaseOpenmrsData extends BaseOpenmrsObject implements OpenmrsData {
	@ManyToOne(optional = false)
	@JoinColumn(name = "creator", updatable = false)
	protected User creator;
	@Column(name = "date_created", nullable = false, updatable = false)
	private Date dateCreated;
	@ManyToOne
	@JoinColumn(name = "changed_by")
	private User changedBy;
	@Column(name = "date_changed")
	private Date dateChanged;
	@Column(name = "voided", nullable = false)
	@Field
	private Boolean voided = Boolean.FALSE;
	@Column(name = "date_voided")
	private Date dateVoided;
	@ManyToOne
	@JoinColumn(name = "voided_by")
	private User voidedBy;
	@Column(name = "void_reason", length = 255)
	private String voidReason;
	public BaseOpenmrsData() {
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	@Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	@Override
	@Deprecated
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	@Deprecated
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	@Override
	@Deprecated
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	@Deprecated
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	@Deprecated
	@JsonIgnore
	public Boolean isVoided() {
		return getVoided();
	}
	@Override
	public Boolean getVoided() {
		return voided;
	}
	@Override
	public void setVoided(Boolean voided) {
		this.voided = voided;
	}
	@Override
	public Date getDateVoided() {
		return dateVoided;
	}
	@Override
	public void setDateVoided(Date dateVoided) {
		this.dateVoided = dateVoided;
	}
	@Override
	public User getVoidedBy() {
		return voidedBy;
	}
	@Override
	public void setVoidedBy(User voidedBy) {
		this.voidedBy = voidedBy;
	}
	@Override
	public String getVoidReason() {
		return voidReason;
	}
	@Override
	public void setVoidReason(String voidReason) {
		this.voidReason = voidReason;
	}
}
package org.openmrs;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.MapKeyColumn;
import javax.persistence.Table;
import javax.persistence.Transient;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
import org.hibernate.annotations.Cascade;
import org.hibernate.annotations.CascadeType;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.LazyCollection;
import org.hibernate.annotations.LazyCollectionOption;
import org.hibernate.annotations.Parameter;
import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.openmrs.api.context.Context;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.RoleConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@Entity
@Table(name = "users")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@Audited
public class User extends BaseOpenmrsObject implements java.io.Serializable, Attributable<User>, Auditable, Retireable {
	public static final long serialVersionUID = 2L ;
	private static final Logger log = LoggerFactory.getLogger(User.class);
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "users_user_id_seq")
	@GenericGenerator(
		name = "users_user_id_seq",
		strategy = "native",
		parameters = @Parameter(name = "sequence", value = "users_user_id_seq")
	)
	@Column(name = "user_id")
	private Integer userId;
	@ManyToOne
	@JoinColumn(name = "person_id", nullable = false)
	@LazyCollection(LazyCollectionOption.FALSE)
	@Cascade(CascadeType.SAVE_UPDATE)
	private Person person;
	@Column(name = "system_id", nullable = false, length = 50)
	private String systemId;
	@Column(name = "username", length = 50)
	private String username;
	@Column(name = "email", length = 255, unique = true)
	private String email;
	@ManyToMany
	@JoinTable(name = "user_role", joinColumns = @JoinColumn(name = "user_id"), inverseJoinColumns = @JoinColumn(name = "role"))
	@LazyCollection(LazyCollectionOption.FALSE)
	@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
	@Cascade({ CascadeType.SAVE_UPDATE, CascadeType.MERGE, CascadeType.EVICT })
	private Set<Role> roles;
	@ElementCollection
	@CollectionTable(name = "user_property", joinColumns = @JoinColumn(name = "user_id", nullable = false))
	@MapKeyColumn(name = "property", length = 255)
	@Column(name = "property_value", length = Integer.MAX_VALUE)
	@Cascade({ CascadeType.SAVE_UPDATE, CascadeType.MERGE, CascadeType.EVICT })
	@NotAudited
	private Map<String, String> userProperties;
	@Transient
	private List<Locale> proficientLocales = null;
	@Transient
	private String parsedProficientLocalesProperty = "";
	@ManyToOne
	@JoinColumn(name = "creator", nullable = false)
	private User creator;
	@Column(name = "date_created", nullable = false, length = 19)
	private Date dateCreated;
	@ManyToOne
	@JoinColumn(name = "changed_by")
	private User changedBy;
	@Column(name = "date_changed", length = 19)
	private Date dateChanged;
	@Column(name = "retired", nullable = false, length = 1)
	private boolean retired;
	@ManyToOne
	@JoinColumn(name = "retired_by")
	private User retiredBy;
	@Column(name = "date_retired", length = 19)
	private Date dateRetired;
	@Column(name = "retire_reason", length = 255)
	private String retireReason;
	public User() {
	}
	public User(Integer userId) {
		this.userId = userId;
	}
	public User(Person person) {
		this.person = person;
	}
	public boolean isSuperUser() {
		return containsRole(RoleConstants.SUPERUSER);
	}
	public boolean hasPrivilege(String privilege) {
		if (StringUtils.isEmpty(privilege)) {
			return true;
		}
		if (isSuperUser()) {
			return true;
		}
		Set<Role> tmproles = getAllRoles();
		for (Role tmprole : tmproles) {
			if (tmprole.hasPrivilege(privilege)) {
				return true;
			}
		}
		return false;
	}
	public boolean hasRole(String r) {
		return hasRole(r, false);
	}
	public boolean hasRole(String r, boolean ignoreSuperUser) {
		if (!ignoreSuperUser && isSuperUser()) {
			return true;
		}
		if (roles == null) {
			return false;
		}
		Set<Role> tmproles = getAllRoles();
		log.debug("User # {} has roles: {}", userId, tmproles);
		return containsRole(r);
	}
	public boolean containsRole(String roleName) {
		for (Role role : getAllRoles()) {
			if (role.getRole().equalsIgnoreCase(roleName)) {
				return true;
			}
		}
		return false;
	}
	public Collection<Privilege> getPrivileges() {
		Set<Privilege> privileges = new HashSet<>();
		Set<Role> tmproles = getAllRoles();
		Role role;
		for (Role tmprole : tmproles) {
			role = tmprole;
			Collection<Privilege> privs = role.getPrivileges();
			if (privs != null) {
				privileges.addAll(privs);
			}
		}
		return privileges;
	}
	public Set<Role> getAllRoles() {
		Set<Role> baseRoles = new HashSet<>();
		Set<Role> totalRoles = new HashSet<>();
		if (getRoles() != null) {
			baseRoles.addAll(getRoles());
			totalRoles.addAll(getRoles());
		}
		log.debug("User's base roles: {}", baseRoles);
		try {
			for (Role r : baseRoles) {
				totalRoles.addAll(r.getAllParentRoles());
			}
		}
		catch (ClassCastException e) {
			log.error("Error converting roles for user: " + this);
			log.error("baseRoles.class: " + baseRoles.getClass().getName());
			log.error("baseRoles: " + baseRoles.toString());
			for (Role baseRole : baseRoles) {
				log.error("baseRole: '" + baseRole + "'");
			}
		}
		return totalRoles;
	}
	public Set<Role> getRoles() {
		return roles;
	}
	public void setRoles(Set<Role> roles) {
		this.roles = roles;
	}
	public User addRole(Role role) {
		if (roles == null) {
			roles = new HashSet<>();
		}
		if (!roles.contains(role) && role != null) {
			roles.add(role);
		}
		return this;
	}
	public User removeRole(Role role) {
		if (roles != null) {
			roles.remove(role);
		}
		return this;
	}
	@Override
	@Deprecated
	public List<User> findPossibleValues(String searchText) {
		try {
			return Context.getUserService().getUsersByName(searchText, "", false);
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	@Override
	@Deprecated
	public List<User> getPossibleValues() {
		try {
			return Context.getUserService().getAllUsers();
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	@Override
	public User hydrate(String userId) {
		try {
			return Context.getUserService().getUser(Integer.valueOf(userId));
		}
		catch (Exception e) {
			return new User();
		}
	}
	@Override
	public String serialize() {
		if (getUserId() != null) {
			return "" + getUserId();
		} else {
			return "";
		}
	}
	@Override
	public String getDisplayString() {
		String returnString = "";
		if (getPersonName() != null) {
			returnString += getPersonName().getFullName() + " ";
		}
		returnString += "(" + getUsername() + ")";
		return returnString;
	}
	public String getSystemId() {
		return systemId;
	}
	public void setSystemId(String systemId) {
		this.systemId = systemId;
	}
	public Integer getUserId() {
		return userId;
	}
	public void setUserId(Integer userId) {
		this.userId = userId;
	}
	public Person getPerson() {
		return person;
	}
	private Person getPersonMaybeCreate() {
		if (person == null) {
			person = new Person();
		}
		return person;
	}
	public void setPerson(Person person) {
		this.person = person;
	}
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	@Override
	public String toString() {
		return StringUtils.isNotBlank(username) ? username : systemId;
	}
	public Map<String, String> getUserProperties() {
		if (userProperties == null) {
			userProperties = new HashMap<>();
		}
		return userProperties;
	}
	public void setUserProperties(Map<String, String> userProperties) {
		this.userProperties = userProperties;
	}
	public void setUserProperty(String prop, String value) {
		getUserProperties().put(prop, value);
	}
	public void removeUserProperty(String prop) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			userProperties.remove(prop);
		}
	}
	public String getUserProperty(String prop) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			return userProperties.get(prop);
		}
		return "";
	}
	public String getUserProperty(String prop, String defaultValue) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			return userProperties.get(prop);
		}
		return defaultValue;
	}
	public void addName(PersonName name) {
		getPersonMaybeCreate().addName(name);
	}
	public PersonName getPersonName() {
		return getPerson() == null ? null : getPerson().getPersonName();
	}
	public String getGivenName() {
		return getPerson() == null ? null : getPerson().getGivenName();
	}
	public String getFamilyName() {
		return getPerson() == null ? null : getPerson().getFamilyName();
	}
	public Set<PersonName> getNames() {
		return person.getNames();
	}
	public List<Locale> getProficientLocales() {
		String proficientLocalesProperty = getUserProperty(OpenmrsConstants.USER_PROPERTY_PROFICIENT_LOCALES);
		if ((proficientLocales == null)
		        || (!OpenmrsUtil.nullSafeEquals(parsedProficientLocalesProperty, proficientLocalesProperty))) {
			parsedProficientLocalesProperty = proficientLocalesProperty;
			proficientLocales = new ArrayList<>();
			if (proficientLocalesProperty != null) {
				String[] proficientLocalesArray = proficientLocalesProperty.split(",");
				for (String proficientLocaleSpec : proficientLocalesArray) {
					if (proficientLocaleSpec.length() > 0) {
						Locale proficientLocale = LocaleUtility.fromSpecification(proficientLocaleSpec);
						if (!proficientLocales.contains(proficientLocale)) {
							proficientLocales.add(proficientLocale);
							if (StringUtils.isNotEmpty(proficientLocale.getCountry())) {
								Locale languageOnlyLocale = LocaleUtility.fromSpecification(proficientLocale.getLanguage());
								if (!proficientLocales.contains(languageOnlyLocale)) {
									proficientLocales.add(LocaleUtility.fromSpecification(proficientLocale.getLanguage()));
								}
							}
						}
					}
				}
			}
		}
		return new ArrayList<>(proficientLocales);
	}
	@Override
	public Integer getId() {
		return getUserId();
	}
	@Override
	public void setId(Integer id) {
		setUserId(id);
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
    @Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	@Override
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	@Override
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	public Boolean isRetired() {
		return retired;
	}
    @Override
	public Boolean getRetired() {
		return retired;
	}
	@Override
	public void setRetired(Boolean retired) {
		this.retired = retired;
	}
	@Override
	public User getRetiredBy() {
		return retiredBy;
	}
	@Override
	public void setRetiredBy(User retiredBy) {
		this.retiredBy = retiredBy;
	}
	@Override
	public Date getDateRetired() {
		return dateRetired;
	}
	@Override
	public void setDateRetired(Date dateRetired) {
		this.dateRetired = dateRetired;
	}
	@Override
	public String getRetireReason() {
		return retireReason;
	}
	@Override
	public void setRetireReason(String retireReason) {
		this.retireReason = retireReason;
	}
}
package org.openmrs;
import java.io.Serializable;
import java.util.UUID;
import javax.persistence.Column;
import javax.persistence.MappedSuperclass;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.hibernate.Hibernate;
import org.hibernate.envers.Audited;
@MappedSuperclass
@Audited
public abstract class BaseOpenmrsObject implements Serializable, OpenmrsObject {
	@Column(name = "uuid", unique = true, nullable = false, length = 38, updatable = false)
	private String uuid = UUID.randomUUID().toString();
	@Override
	public String getUuid() {
		return uuid;
	}
	@Override
	public void setUuid(String uuid) {
		this.uuid = uuid;
	}
	@Override
	public int hashCode() {
		if (getUuid() == null) {
			return super.hashCode();
		}
		return getUuid().hashCode();
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof BaseOpenmrsObject)) {
			return false;
		}
		BaseOpenmrsObject other = (BaseOpenmrsObject) obj;
		if (getUuid() == null) {
			return false;
		}
		Class<?> thisClass = Hibernate.getClass(this);
		Class<?> objClass = Hibernate.getClass(obj);
		if (!(thisClass.isAssignableFrom(objClass) || objClass.isAssignableFrom(thisClass))){
			return false;
		}
		return getUuid().equals(other.getUuid());
	}
	@Override
	public String toString() {
		return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE).append("hashCode",
		    Integer.toHexString(hashCode())).append("uuid", getUuid()).build();
	}
}
package org.openmrs.util;
import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Random;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import javax.activation.MimetypesFileTypeMap;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Cohort;
import org.openmrs.Concept;
import org.openmrs.ConceptNumeric;
import org.openmrs.ConceptReferenceRange;
import org.openmrs.Drug;
import org.openmrs.EncounterType;
import org.openmrs.Form;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.PersonAttributeType;
import org.openmrs.Program;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.User;
import org.openmrs.annotation.AddOnStartup;
import org.openmrs.annotation.HasAddOnStartupPrivileges;
import org.openmrs.annotation.Logging;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.ConceptService;
import org.openmrs.api.InvalidCharactersPasswordException;
import org.openmrs.api.PasswordException;
import org.openmrs.api.ShortPasswordException;
import org.openmrs.api.WeakPasswordException;
import org.openmrs.api.context.Context;
import org.openmrs.logging.OpenmrsLoggingUtil;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.propertyeditor.CohortEditor;
import org.openmrs.propertyeditor.ConceptEditor;
import org.openmrs.propertyeditor.DrugEditor;
import org.openmrs.propertyeditor.EncounterTypeEditor;
import org.openmrs.propertyeditor.FormEditor;
import org.openmrs.propertyeditor.LocationEditor;
import org.openmrs.propertyeditor.PersonAttributeTypeEditor;
import org.openmrs.propertyeditor.ProgramEditor;
import org.openmrs.propertyeditor.ProgramWorkflowStateEditor;
import org.openmrs.validator.ObsValidator;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.propertyeditors.CustomDateEditor;
import org.springframework.context.NoSuchMessageException;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
public class OpenmrsUtil {
	private OpenmrsUtil() {
	}
	private static volatile MimetypesFileTypeMap mimetypesFileTypeMap = null;
	private static org.slf4j.Logger log = LoggerFactory.getLogger(OpenmrsUtil.class);
	private static Map<Locale, SimpleDateFormat> dateFormatCache = new HashMap<>();
	private static Map<Locale, SimpleDateFormat> timeFormatCache = new HashMap<>();
	public static <E> Collection<Collection<E>> compareLists(Collection<E> origList, Collection<E> newList) {	
		Collection<Collection<E>> returnList = new ArrayList<>();
		Collection<E> toAdd = new LinkedList<>();
		Collection<E> toDel = new LinkedList<>();
		for (E currentNewListObj : newList) {
			boolean foundInList = false;
			for (E currentOrigListObj : origList) {
				if (currentNewListObj.equals(currentOrigListObj)) {
					foundInList = true;
					origList.remove(currentOrigListObj);
					break;
				}
			}
			if (!foundInList) {
				toAdd.add(currentNewListObj);
			}
			toDel = origList;
		}
		returnList.add(toAdd);
		returnList.add(toDel);
		return returnList;
	}
	public static boolean isStringInArray(String str, String[] arr) {
		if (str != null && arr != null) {
			for (String anArr : arr) {
				if (str.equals(anArr)) {
					return true;
				}
			}
		}
		return false;
	}
	public static Boolean isInNormalNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiNormal() == null || concept.getLowNormal() == null) {
			return false;
		}
		return (value <= concept.getHiNormal() && value >= concept.getLowNormal());
	}
	public static Boolean isInCriticalNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiCritical() == null || concept.getLowCritical() == null) {
			return false;
		}
		return (value <= concept.getHiCritical() && value >= concept.getLowCritical());
	}
	public static Boolean isInAbsoluteNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiAbsolute() == null || concept.getLowAbsolute() == null) {
			return false;
		}
		return (value <= concept.getHiAbsolute() && value >= concept.getLowAbsolute());
	}
	public static Boolean isValidNumericValue(Float value, ConceptNumeric concept) {
		if (concept.getHiAbsolute() == null || concept.getLowAbsolute() == null) {
			return true;
		}
		return (value <= concept.getHiAbsolute() && value >= concept.getLowAbsolute());
	}
	public static String getFileAsString(File file) throws IOException {
		StringBuilder fileData = new StringBuilder(1000);
		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8));
		char[] buf = new char[1024];
		int numRead;
		while ((numRead = reader.read(buf)) != -1) {
			String readData = String.valueOf(buf, 0, numRead);
			fileData.append(readData);
			buf = new char[1024];
		}
		reader.close();
		return fileData.toString();
	}
	public static byte[] getFileAsBytes(File file) throws IOException {
		FileInputStream fileInputStream = null;
		try {
			fileInputStream = new FileInputStream(file);
			byte[] b = new byte[fileInputStream.available()];
			fileInputStream.read(b);
			return b;
		}
		catch (Exception e) {
			log.error("Unable to get file as byte array", e);
		}
		finally {
			if (fileInputStream != null) {
				try {
					fileInputStream.close();
				}
				catch (IOException io) {
					log.warn("Couldn't close fileInputStream: " + io);
				}
			}
		}
		return null;
	}
	public static void copyFile(InputStream inputStream, OutputStream outputStream) throws IOException {
		if (inputStream == null || outputStream == null) {
			if (outputStream != null) {
				IOUtils.closeQuietly(outputStream);
			}
			return;
		}
		try {
			IOUtils.copy(inputStream, outputStream);
		}
		finally {
			IOUtils.closeQuietly(outputStream);
		}
	}
	public static String getFileMimeType(File file) {
		if (mimetypesFileTypeMap == null) {
			synchronized (OpenmrsUtil.class) {
				mimetypesFileTypeMap = new MimetypesFileTypeMap();
			}
		}
		return mimetypesFileTypeMap.getContentType(file);
	}
	public static boolean folderContains(File folder, String filename) {
		if (folder == null) {
			return false;
		}
		if (!folder.isDirectory()) {
			return false;
		}
		File[] files = folder.listFiles();
		if (files == null) {
			return false;
		}
		for (File f : files) {
			if (f.getName().equals(filename)) {
				return true;
			}
		}
		return false;
	}
	public static Map<String, String> getCorePrivileges() {
		Map<String, String> corePrivileges = new HashMap<>();
		Set<Class<?>> classes = OpenmrsClassScanner.getInstance().getClassesWithAnnotation(HasAddOnStartupPrivileges.class);
		for (Class cls : classes) {
			Field[] flds = cls.getDeclaredFields();
			for (Field fld : flds) {
				String fieldValue = null;
				AddOnStartup privilegeAnnotation = fld.getAnnotation(AddOnStartup.class);
				if (null == privilegeAnnotation) {
					continue;
				}
				if (!privilegeAnnotation.core()) {
					continue;
				}
				try {
					fieldValue = (String) fld.get(null);
				}
				catch (IllegalAccessException e) {
					log.error("Field is inaccessible.", e);
				}
				corePrivileges.put(fieldValue, privilegeAnnotation.description());
			}
		}
		for (org.openmrs.Privilege privilege : ModuleFactory.getPrivileges()) {
			corePrivileges.put(privilege.getPrivilege(), privilege.getDescription());
		}
		return corePrivileges;
	}
	public static Map<String, String> getCoreRoles() {
		Map<String, String> roles = new HashMap<>();
		Field[] flds = RoleConstants.class.getDeclaredFields();
		for (Field fld : flds) {
			String fieldValue = null;
			AddOnStartup roleAnnotation = fld.getAnnotation(AddOnStartup.class);
			if (null == roleAnnotation) {
				continue;
			}
			if (!roleAnnotation.core()) {
				continue;
			}
			try {
				fieldValue = (String) fld.get(null);
			}
			catch (IllegalAccessException e) {
				log.error("Field is inaccessible.", e);
			}
			roles.put(fieldValue, roleAnnotation.description());
		}
		return roles;
	}
	public static void startup(Properties p) {
		String val = p.getProperty("obscure_patients", null);
		if (val != null && "true".equalsIgnoreCase(val)) {
			OpenmrsConstants.OBSCURE_PATIENTS = true;
		}
		val = p.getProperty("obscure_patients.family_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_FAMILY_NAME = val;
		}
		val = p.getProperty("obscure_patients.given_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_GIVEN_NAME = val;
		}
		val = p.getProperty("obscure_patients.middle_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_MIDDLE_NAME = val;
		}
		val = p.getProperty("connection.database_name", null);
		if (val == null) {
			val = p.getProperty("connection.url", null);
			if (val != null) {
				try {
					int endIndex = val.lastIndexOf("?");
					if (endIndex == -1) {
						endIndex = val.length();
					}
					int startIndex = val.lastIndexOf("/", endIndex);
					val = val.substring(startIndex + 1, endIndex);
					OpenmrsConstants.DATABASE_NAME = val;
				}
				catch (Exception e) {
					log.error(MarkerFactory.getMarker("FATAL"), "Database name cannot be configured from 'connection.url' ."
					        + "Either supply 'connection.database_name' or correct the url",
					    e);
				}
			}
		}
		val = p.getProperty("connection.database_business_name", null);
		if (val == null) {
			val = OpenmrsConstants.DATABASE_NAME;
		}
		OpenmrsConstants.DATABASE_BUSINESS_NAME = val;
	}
	@Deprecated
	public static MemoryAppender getMemoryAppender() {
		return new MemoryAppender(OpenmrsLoggingUtil.getMemoryAppender());
	}
	@Logging(ignore = true)
	@Deprecated
	public static void applyLogLevels() {
		OpenmrsLoggingUtil.applyLogLevels();
	}
	@Deprecated
	public static void setupLogAppenders() {
		OpenmrsLoggingUtil.reloadLoggingConfiguration();
	}
	@Deprecated
	public static void applyLogLevel(String logClass, String logLevel) {
		OpenmrsLoggingUtil.applyLogLevel(logClass, logLevel);
	}
	public static Map<String, String> parseParameterList(String paramList) {
		Map<String, String> ret = new HashMap<>();
		if (paramList != null && paramList.length() > 0) {
			String[] args = paramList.split("\\|");
			for (String s : args) {
				int ind = s.indexOf('=');
				if (ind <= 0) {
					throw new IllegalArgumentException(
					        "Misformed argument in dynamic page specification string: '" + s + "' is not 'key=value'.");
				}
				String name = s.substring(0, ind);
				String value = s.substring(ind + 1);
				ret.put(name, value);
			}
		}
		return ret;
	}
	public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) {
		if (d1 == null) {
			return d2 == null;
		} else if (d2 == null) {
			return false;
		}
		return (d1 instanceof Date && d2 instanceof Date) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2);
	}
	public static int compare(Date d1, Date d2) {
		if (d1 instanceof Timestamp && d2 instanceof Timestamp) {
			return d1.compareTo(d2);
		}
		if (d1 instanceof Timestamp) {
			d1 = new Date(d1.getTime());
		}
		if (d2 instanceof Timestamp) {
			d2 = new Date(d2.getTime());
		}
		return d1.compareTo(d2);
	}
	public static int compareWithNullAsEarliest(Date d1, Date d2) {
		if (d1 == null && d2 == null) {
			return 0;
		}
		if (d1 == null) {
			return -1;
		} else if (d2 == null) {
			return 1;
		} else {
			return compare(d1, d2);
		}
	}
	public static int compareWithNullAsLatest(Date d1, Date d2) {
		if (d1 == null && d2 == null) {
			return 0;
		}
		if (d1 == null) {
			return 1;
		} else if (d2 == null) {
			return -1;
		} else {
			return compare(d1, d2);
		}
	}
	public static <E extends Comparable<E>> int compareWithNullAsLowest(E c1, E c2) {
		if (c1 == null && c2 == null) {
			return 0;
		}
		if (c1 == null) {
			return -1;
		} else if (c2 == null) {
			return 1;
		} else {
			return c1.compareTo(c2);
		}
	}
	public static <E extends Comparable<E>> int compareWithNullAsGreatest(E c1, E c2) {
		if (c1 == null && c2 == null) {
			return 0;
		}
		if (c1 == null) {
			return 1;
		} else if (c2 == null) {
			return -1;
		} else {
			return c1.compareTo(c2);
		}
	}
	@Deprecated
	public static <E> String join(Collection<E> c, String separator) {
		if (c == null) {
			return "";
		}
		StringBuilder ret = new StringBuilder();
		for (Iterator<E> i = c.iterator(); i.hasNext();) {
			ret.append(i.next());
			if (i.hasNext()) {
				ret.append(separator);
			}
		}
		return ret.toString();
	}
	public static Set<Concept> conceptSetHelper(String descriptor) {
		Set<Concept> ret = new HashSet<>();
		if (descriptor == null || descriptor.length() == 0) {
			return ret;
		}
		ConceptService cs = Context.getConceptService();
		for (StringTokenizer st = new StringTokenizer(descriptor, "|"); st.hasMoreTokens();) {
			String s = st.nextToken().trim();
			boolean isSet = s.startsWith("set:");
			if (isSet) {
				s = s.substring(4).trim();
			}
			Concept c = null;
			if (s.startsWith("name:")) {
				String name = s.substring(5).trim();
				c = cs.getConceptByName(name);
			} else {
				try {
					c = cs.getConcept(Integer.valueOf(s.trim()));
				}
				catch (Exception ex) {}
			}
			if (c != null) {
				if (isSet) {
					List<Concept> inSet = cs.getConceptsByConceptSet(c);
					ret.addAll(inSet);
				} else {
					ret.add(c);
				}
			}
		}
		return ret;
	}
	public static List<Concept> delimitedStringToConceptList(String delimitedString, String delimiter) {
		List<Concept> ret = null;
		if (delimitedString != null) {
			String[] tokens = delimitedString.split(delimiter);
			for (String token : tokens) {
				Integer conceptId;
				try {
					conceptId = Integer.valueOf(token);
				}
				catch (NumberFormatException nfe) {
					conceptId = null;
				}
				Concept c;
				if (conceptId != null) {
					c = Context.getConceptService().getConcept(conceptId);
				} else {
					c = Context.getConceptService().getConceptByName(token);
				}
				if (c != null) {
					if (ret == null) {
						ret = new ArrayList<>();
					}
					ret.add(c);
				}
			}
		}
		return ret;
	}
	public static Map<String, Concept> delimitedStringToConceptMap(String delimitedString, String delimiter) {
		Map<String, Concept> ret = null;
		if (delimitedString != null) {
			String[] tokens = delimitedString.split(delimiter);
			for (String token : tokens) {
				Concept c = Context.getConceptService().getConcept(token);
				if (c != null) {
					if (ret == null) {
						ret = new HashMap<>();
					}
					ret.put(token, c);
				}
			}
		}
		return ret;
	}
	public static List<Concept> conceptListHelper(String descriptor) {
		Set<Concept> ret = new LinkedHashSet<>();
		if (descriptor == null || descriptor.length() == 0) {
			return Collections.emptyList();
		}
		ConceptService cs = Context.getConceptService();
		for (StringTokenizer st = new StringTokenizer(descriptor, "|"); st.hasMoreTokens();) {
			String s = st.nextToken().trim();
			boolean isSet = s.startsWith("set:");
			if (isSet) {
				s = s.substring(4).trim();
			}
			Concept c = null;
			if (s.startsWith("name:")) {
				String name = s.substring(5).trim();
				c = cs.getConceptByName(name);
			} else {
				try {
					c = cs.getConcept(Integer.valueOf(s.trim()));
				}
				catch (Exception ex) {}
			}
			if (c != null) {
				if (isSet) {
					List<Concept> inSet = cs.getConceptsByConceptSet(c);
					ret.addAll(inSet);
				} else {
					ret.add(c);
				}
			}
		}
		return new ArrayList<>(ret);
	}
	public static Date getLastMomentOfDay(Date day) {
		Calendar calender = Calendar.getInstance();
		calender.setTime(day);
		calender.set(Calendar.HOUR_OF_DAY, 23);
		calender.set(Calendar.MINUTE, 59);
		calender.set(Calendar.SECOND, 59);
		calender.set(Calendar.MILLISECOND, 999);
		return calender.getTime();
	}
	public static Date firstSecondOfDay(Date date) {
		if (date == null) {
			return null;
		}
		Calendar c = Calendar.getInstance();
		c.setTime(date);
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		return c.getTime();
	}
	public static Date safeDate(Date d1) {
		return new Date(d1.getTime());
	}
	public static boolean deleteDirectory(File dir) throws IOException {
		if (!dir.exists() || !dir.isDirectory()) {
			throw new IOException("Could not delete directory '" + dir.getAbsolutePath() + "' (not a directory)");
		}
		log.debug("Deleting directory {}", dir.getAbsolutePath());
		File[] fileList = dir.listFiles();
		if (fileList == null) {
			return false;
		}
		for (File f : fileList) {
			if (f.isDirectory()) {
				deleteDirectory(f);
			}
			boolean success = f.delete();
			if (log.isDebugEnabled()) {
				log.debug("   deleting " + f.getName() + " : " + (success ? "ok" : "failed"));
			}
			if (!success) {
				f.deleteOnExit();
			}
		}
		boolean success = dir.delete();
		if (!success) {
			log.warn("   ...could not remove directory: " + dir.getAbsolutePath());
			dir.deleteOnExit();
		}
		if (success && log.isDebugEnabled()) {
			log.debug("   ...and directory itself");
		}
		return success;
	}
	public static File url2file(final URL url) {
		if (url == null || !"file".equalsIgnoreCase(url.getProtocol())) {
			return null;
		}
		return new File(url.getFile().replaceAll("%20", " "));
	}
	public static InputStream getResourceInputStream(final URL url) throws IOException {
		File file = url2file(url);
		if (file != null) {
			return new BufferedInputStream(new FileInputStream(file));
		}
		if (!"jar".equalsIgnoreCase(url.getProtocol())) {
			return url.openStream();
		}
		String urlStr = url.toExternalForm();
		if (urlStr.endsWith("!/")) {
			throw new FileNotFoundException(url.toExternalForm());
		}
		int p = urlStr.indexOf("!/");
		if (p == -1) {
			throw new MalformedURLException(url.toExternalForm());
		}
		String path = urlStr.substring(p + 2);
		file = url2file(new URL(urlStr.substring(4, p)));
		if (file == null) {
			return url.openStream();
		}
		try (JarFile jarFile = new JarFile(file)) {
			ZipEntry entry = jarFile.getEntry(path);
			if (entry == null) {
				throw new FileNotFoundException(url.toExternalForm());
			}
			try (InputStream in = jarFile.getInputStream(entry)) {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				copyFile(in, out);
				return new ByteArrayInputStream(out.toByteArray());
			}
		}
	}
	public static String getApplicationDataDirectory() {
		return getApplicationDataDirectoryAsFile().toString();
	}
	public static File getApplicationDataDirectoryAsFile() {
		String filepath = null;
		final String openmrsDir = "OpenMRS";
		String systemProperty = System.getProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY);
		if (StringUtils.isNotBlank(systemProperty)) {
			filepath = systemProperty;
		} else {
			String runtimeProperty = Context.getRuntimeProperties()
				.getProperty(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY, null);
			if (StringUtils.isNotBlank(runtimeProperty)) {
				filepath = runtimeProperty;
			}
		}
		if (filepath == null) {
			if (OpenmrsConstants.UNIX_BASED_OPERATING_SYSTEM) {
				filepath = Paths.get(System.getProperty("user.home"), "." + openmrsDir).toString();
				if (!canWrite(new File(filepath))) {
					log.warn("Unable to write to users home dir, fallback to: "
						+ OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_UNIX);
					filepath = Paths.get(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_UNIX, openmrsDir).toString();
				}
			} else {
				filepath = Paths.get(System.getProperty("user.home"), "Application Data", "OpenMRS").toString();
				if (!new File(filepath).exists()) {
					filepath = Paths.get(System.getenv("appdata"), "OpenMRS").toString();
				}
				if (!canWrite(new File(filepath))) {
					log.warn("Unable to write to users home dir, fallback to: "
						+ OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_WIN);
					filepath = OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_WIN + File.separator + openmrsDir;
				}
			}
			filepath = filepath + File.separator;
		}
		File folder = new File(filepath);
		if (!folder.exists()) {
			folder.mkdirs();
		}
		return folder;
	}
	public static void setApplicationDataDirectory(String path) {
		if (StringUtils.isBlank(path)) {
			System.clearProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY);
		} else {
			System.setProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY, path);
		}
	}
	private static boolean canWrite(File folder) {
		try {
			if (!folder.exists()) {
				folder.mkdirs();
			}
			return folder.canWrite();
		}
		catch (SecurityException ex) {
		}
		return false;
	}
	@Deprecated
	public static String getOpenmrsLogLocation() {
		return OpenmrsLoggingUtil.getOpenmrsLogLocation();
	}
	public static void validateJavaVersion() {
		if (System.getProperty("java.version").matches("1\\.[0-7]\\.(.*)")) {
			throw new APIException(
				"OpenMRS " + OpenmrsConstants.OPENMRS_VERSION_SHORT + " requires Java 8 and above, but is running under " + 
					System.getProperty("java.version"));
		}
	}
	public static File getDirectoryInApplicationDataDirectory(String folderName) throws APIException {
		File folder = new File(folderName);
		if (!folder.isAbsolute()) {
			folder = new File(getApplicationDataDirectoryAsFile(), folderName);
		}
		if (!folder.exists()) {
			log.warn("'" + folder.getAbsolutePath() + "' doesn't exist.  Creating directories now.");
			folder.mkdirs();
		}
		if (!folder.isDirectory()) {
			throw new APIException("should.be.directory", new Object[] { folder.getAbsolutePath() });
		}
		return folder;
	}
	public static void saveDocument(Document doc, File outFile) {
		OutputStream outStream = null;
		try {
			outStream = new FileOutputStream(outFile);
			TransformerFactory tFactory = TransformerFactory.newInstance();
			Transformer transformer = tFactory.newTransformer();
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			DocumentType doctype = doc.getDoctype();
			if (doctype != null) {
				transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctype.getPublicId());
				transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctype.getSystemId());
			}
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(outStream);
			transformer.transform(source, result);
		}
		catch (TransformerException e) {
			throw new ModuleException("Error while saving dwrmodulexml back to dwr-modules.xml", e);
		}
		catch (FileNotFoundException e) {
			throw new ModuleException(outFile.getAbsolutePath() + " file doesn't exist.", e);
		}
		finally {
			try {
				if (outStream != null) {
					outStream.close();
				}
			}
			catch (Exception e) {
				log.warn("Unable to close outstream", e);
			}
		}
	}
	public static List<Integer> delimitedStringToIntegerList(String delimitedString, String delimiter) {
		List<Integer> ret = new ArrayList<>();
		String[] tokens = delimitedString.split(delimiter);
		for (String token : tokens) {
			token = token.trim();
			if (token.length() != 0) {
				ret.add(Integer.valueOf(token));
			}
		}
		return ret;
	}
	public static boolean stringStartsWith(String str, String[] prefixes) {
		for (String prefix : prefixes) {
			if (StringUtils.startsWith(str, prefix)) {
				return true;
			}
		}
		return false;
	}
	public static boolean isConceptInList(Concept concept, List<Concept> list) {
		boolean ret = false;
		if (concept != null && list != null) {
			for (Concept c : list) {
				if (c.equals(concept)) {
					ret = true;
					break;
				}
			}
		}
		return ret;
	}
	public static Date fromDateHelper(Date comparisonDate, Integer withinLastDays, Integer withinLastMonths,
	        Integer untilDaysAgo, Integer untilMonthsAgo, Date sinceDate, Date untilDate) {
		Date ret = null;
		if (withinLastDays != null || withinLastMonths != null) {
			Calendar gc = Calendar.getInstance();
			gc.setTime(comparisonDate != null ? comparisonDate : new Date());
			if (withinLastDays != null) {
				gc.add(Calendar.DAY_OF_MONTH, -withinLastDays);
			}
			if (withinLastMonths != null) {
				gc.add(Calendar.MONTH, -withinLastMonths);
			}
			ret = gc.getTime();
		}
		if (sinceDate != null && (ret == null || sinceDate.after(ret))) {
			ret = sinceDate;
		}
		return ret;
	}
	public static Date toDateHelper(Date comparisonDate, Integer withinLastDays, Integer withinLastMonths,
	        Integer untilDaysAgo, Integer untilMonthsAgo, Date sinceDate, Date untilDate) {
		Date ret = null;
		if (untilDaysAgo != null || untilMonthsAgo != null) {
			Calendar gc = Calendar.getInstance();
			gc.setTime(comparisonDate != null ? comparisonDate : new Date());
			if (untilDaysAgo != null) {
				gc.add(Calendar.DAY_OF_MONTH, -untilDaysAgo);
			}
			if (untilMonthsAgo != null) {
				gc.add(Calendar.MONTH, -untilMonthsAgo);
			}
			ret = gc.getTime();
		}
		if (untilDate != null && (ret == null || untilDate.before(ret))) {
			ret = untilDate;
		}
		return ret;
	}
	public static <T> boolean containsAny(Collection<T> collection, Collection<T> elements) {
		for (T obj : elements) {
			if (collection.contains(obj)) {
				return true;
			}
		}
		return false;
	}
	public static <K, V> void addToSetMap(Map<K, Set<V>> map, K key, V obj) {
		Set<V> set = map.computeIfAbsent(key, k -> new HashSet<>());
		set.add(obj);
	}
	public static <K, V> void addToListMap(Map<K, List<V>> map, K key, V obj) {
		List<V> list = map.computeIfAbsent(key, k -> new ArrayList<>());
		list.add(obj);
	}
	public static SimpleDateFormat getDateFormat(Locale locale) {
		if (dateFormatCache.containsKey(locale)) {
			return (SimpleDateFormat) dateFormatCache.get(locale).clone();
		}
		SimpleDateFormat sdf = new OpenmrsDateFormat((SimpleDateFormat) DateFormat.getDateInstance(DateFormat.SHORT, locale),
		        locale);
		String pattern = sdf.toPattern();
		if (!pattern.contains("yyyy")) {
			String regex = "yy";
			if (!pattern.contains("yy")) {
				regex = "y";
			}
			pattern = pattern.replaceFirst(regex, "yyyy");
			sdf.applyPattern(pattern);
		}
		if (!pattern.contains("MM")) {
			pattern = pattern.replaceFirst("M", "MM");
			sdf.applyPattern(pattern);
		}
		if (!pattern.contains("dd")) {
			pattern = pattern.replaceFirst("d", "dd");
			sdf.applyPattern(pattern);
		}
		dateFormatCache.put(locale, sdf);
		return (SimpleDateFormat) sdf.clone();
	}
	public static SimpleDateFormat getTimeFormat(Locale locale) {
		if (timeFormatCache.containsKey(locale)) {
			return (SimpleDateFormat) timeFormatCache.get(locale).clone();
		}
		SimpleDateFormat sdf = (SimpleDateFormat) DateFormat.getTimeInstance(DateFormat.SHORT, locale);
		String pattern = sdf.toPattern();
		if (!(pattern.contains("hh") || pattern.contains("HH"))) {
			pattern = pattern.replaceFirst("h", "hh").replaceFirst("H", "HH");
			sdf.applyPattern(pattern);
		}
		timeFormatCache.put(locale, sdf);
		return (SimpleDateFormat) sdf.clone();
	}
	public static SimpleDateFormat getDateTimeFormat(Locale locale) {
		SimpleDateFormat dateFormat;
		SimpleDateFormat timeFormat;
		dateFormat = getDateFormat(locale);
		timeFormat = getTimeFormat(locale);
		String pattern = dateFormat.toPattern() + " " + timeFormat.toPattern();
		SimpleDateFormat sdf = new SimpleDateFormat();
		sdf.applyPattern(pattern);
		return sdf;
	}
	@SuppressWarnings("unchecked")
	public static Object parse(String string, Class clazz) {
		try {
			Method valueOfMethod = null;
			try {
				valueOfMethod = clazz.getMethod("valueOf", String.class);
			}
			catch (NoSuchMethodException ex) {}
			if (valueOfMethod != null) {
				return valueOfMethod.invoke(null, string);
			} else if (clazz.isEnum()) {
				List<Enum> constants = Arrays.asList((Enum[]) clazz.getEnumConstants());
				for (Enum e : constants) {
					if (e.toString().equals(string)) {
						return e;
					}
				}
				throw new IllegalArgumentException(string + " is not a legal value of enum class " + clazz);
			} else if (String.class.equals(clazz)) {
				return string;
			} else if (Location.class.equals(clazz)) {
				try {
					Integer.parseInt(string);
					LocationEditor ed = new LocationEditor();
					ed.setAsText(string);
					return ed.getValue();
				}
				catch (NumberFormatException ex) {
					return Context.getLocationService().getLocation(string);
				}
			} else if (Concept.class.equals(clazz)) {
				ConceptEditor ed = new ConceptEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Program.class.equals(clazz)) {
				ProgramEditor ed = new ProgramEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (ProgramWorkflowState.class.equals(clazz)) {
				ProgramWorkflowStateEditor ed = new ProgramWorkflowStateEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (EncounterType.class.equals(clazz)) {
				EncounterTypeEditor ed = new EncounterTypeEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Form.class.equals(clazz)) {
				FormEditor ed = new FormEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Drug.class.equals(clazz)) {
				DrugEditor ed = new DrugEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (PersonAttributeType.class.equals(clazz)) {
				PersonAttributeTypeEditor ed = new PersonAttributeTypeEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Cohort.class.equals(clazz)) {
				CohortEditor ed = new CohortEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Date.class.equals(clazz)) {
				CustomDateEditor ed = new CustomDateEditor(Context.getDateFormat(), true, 10);
				ed.setAsText(string);
				return ed.getValue();
			} else if (Object.class.equals(clazz)) {
				return string;
			} else {
				throw new IllegalArgumentException("Don't know how to handle class: " + clazz);
			}
		}
		catch (Exception ex) {
			log.error("error converting \"" + string + "\" to " + clazz, ex);
			throw new IllegalArgumentException(ex);
		}
	}
	public static boolean collectionContains(Collection<?> objects, Object obj) {
		if (obj == null || objects == null) {
			return false;
		}
		for (Object o : objects) {
			if (o != null && o.equals(obj)) {
				return true;
			}
		}
		return false;
	}
	public static File getOutFile(File dir, Date date, User user) {
		Random gen = new Random();
		File outFile;
		do {
			DateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd-HHmm-ssSSS");
			if (date == null) {
				date = new Date();
			}
			StringBuilder filename = new StringBuilder();
			filename.append(dateFormat.format(date));
			if (user != null) {
				filename.append("-");
				filename.append(user.getUserId());
				filename.append("-");
			}
			filename.append(gen.nextInt() * 10000);
			filename.append(".xml");
			outFile = new File(dir, filename.toString());
			date = null;
		} while (outFile.exists());
		return outFile;
	}
	public static String generateUid(Integer size) {
		Random gen = new Random();
		StringBuilder sb = new StringBuilder(size);
		for (int i = 0; i < size; i++) {
			int ch = gen.nextInt() * 62;
			if (ch < 10) {
				sb.append(ch);
			} else if (ch < 36) {
				sb.append((char) (ch - 10 + 'a'));
			} else {
				sb.append((char) (ch - 36 + 'A'));
			}
		}
		return sb.toString();
	}
	public static String generateUid() {
		return generateUid(20);
	}
	public static void storeProperties(Properties properties, File file, String comment) {
		OutputStream outStream = null;
		try {
			outStream = new FileOutputStream(file, true);
			storeProperties(properties, outStream, comment);
		}
		catch (IOException ex) {
			log.error("Unable to create file " + file.getAbsolutePath() + " in storeProperties routine.");
		}
		finally {
			try {
				if (outStream != null) {
					outStream.close();
				}
			}
			catch (IOException ioe) {
			}
		}
	}
	public static void storeProperties(Properties properties, OutputStream outStream, String comment) {
		try {
			Charset utf8 = StandardCharsets.UTF_8;
			properties.store(new OutputStreamWriter(outStream, utf8), comment);
		}
		catch (FileNotFoundException fnfe) {
			log.error("target file not found" + fnfe);
		}
		catch (UnsupportedEncodingException ex) { 
			log.error("unsupported encoding error hit" + ex);
		}
		catch (IOException ioex) {
			log.error("IO exception encountered trying to append to properties file" + ioex);
		}
	}
	public static void loadProperties(Properties props, InputStream inputStream) {
		InputStreamReader reader = null;
		try {
			reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);
			props.load(reader);
		}
		catch (FileNotFoundException fnfe) {
			log.error("Unable to find properties file" + fnfe);
		}
		catch (UnsupportedEncodingException uee) {
			log.error("Unsupported encoding used in properties file" + uee);
		}
		catch (IOException ioe) {
			log.error("Unable to read properties from properties file" + ioe);
		}
		finally {
			try {
				if (reader != null) {
					reader.close();
				}
			}
			catch (IOException ioe) {
				log.error("Unable to close properties file " + ioe);
			}
		}
	}
	public static void loadProperties(Properties props, File propertyFile) {
		try {
			loadProperties(props, new FileInputStream(propertyFile));
		}
		catch (FileNotFoundException fnfe) {
			log.error("Unable to find properties file" + fnfe);
		}
	}
	public static String getMessage(String code, Object... args) {
		Locale l = Context.getLocale();
		try {
			String translation = Context.getMessageSourceService().getMessage(code, args, l);
			if (translation != null) {
				return translation;
			}
		}
		catch (NoSuchMessageException e) {
			log.warn("Message code <" + code + "> not found for locale " + l);
		}
		catch (APIException apiEx) {
			log.debug("Unable to get code: " + code, apiEx);
			return code;
		}
		return code;
	}
	public static void validatePassword(String username, String password, String systemId) throws PasswordException {
		String userGp = "true";
		String lengthGp = "8";
		String caseGp = "true";
		String digitGp = "true";
		String nonDigitGp = "true";
		String regexGp = null;
		AdministrationService svc = null;
		try {
			svc = Context.getAdministrationService();
		}
		catch (APIException apiEx) {
			log.debug("Unable to get global properties", apiEx);
		}
		if (svc != null && Context.isSessionOpen()) {
			userGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_CANNOT_MATCH_USERNAME_OR_SYSTEMID, userGp);
			lengthGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_MINIMUM_LENGTH, lengthGp);
			caseGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_UPPER_AND_LOWER_CASE, caseGp);
			digitGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_DIGIT, digitGp);
			nonDigitGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_NON_DIGIT, nonDigitGp);
			regexGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_CUSTOM_REGEX, regexGp);
		}
		if (password == null) {
			throw new WeakPasswordException();
		}
		if ("true".equals(userGp) && (password.equals(username) || password.equals(systemId))) {
			throw new WeakPasswordException();
		}
		if (StringUtils.isNotEmpty(lengthGp)) {
			try {
				int minLength = Integer.parseInt(lengthGp);
				if (password.length() < minLength) {
					throw new ShortPasswordException(getMessage("error.password.length", lengthGp));
				}
			}
			catch (NumberFormatException nfe) {
				log.warn(
				    "Error in global property <" + OpenmrsConstants.GP_PASSWORD_MINIMUM_LENGTH + "> must be an Integer");
			}
		}
		if ("true".equals(caseGp) && !containsUpperAndLowerCase(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireMixedCase"));
		}
		if ("true".equals(digitGp) && !containsDigit(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireNumber"));
		}
		if ("true".equals(nonDigitGp) && containsOnlyDigits(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireLetter"));
		}
		if (StringUtils.isNotEmpty(regexGp)) {
			try {
				Pattern pattern = Pattern.compile(regexGp);
				Matcher matcher = pattern.matcher(password);
				if (!matcher.matches()) {
					throw new InvalidCharactersPasswordException(getMessage("error.password.different"));
				}
			}
			catch (PatternSyntaxException pse) {
				log.warn("Invalid regex of " + regexGp + " defined in global property <"
				        + OpenmrsConstants.GP_PASSWORD_CUSTOM_REGEX + ">.");
			}
		}
	}
	public static boolean containsUpperAndLowerCase(String test) {
		if (test != null) {
			Pattern pattern = Pattern.compile("^(?=.*?[A-Z])(?=.*?[a-z])[\\w|\\W]*$");
			Matcher matcher = pattern.matcher(test);
			return matcher.matches();
		}
		return false;
	}
	public static boolean containsOnlyDigits(String test) {
		if (test != null) {
			for (char c : test.toCharArray()) {
				if (!Character.isDigit(c)) {
					return false;
				}
			}
		}
		return StringUtils.isNotEmpty(test);
	}
	public static boolean containsDigit(String test) {
		if (test != null) {
			for (char c : test.toCharArray()) {
				if (Character.isDigit(c)) {
					return true;
				}
			}
		}
		return false;
	}
	public static void closeStream(Closeable closableStream) {
		if (closableStream != null) {
			try {
				closableStream.close();
			}
			catch (IOException io) {
				log.trace("Error occurred while closing stream", io);
			}
		}
	}
	public static String shortenedStackTrace(String stackTrace) {
		if (stackTrace == null) {
			return null;
		}
		List<String> results = new ArrayList<>();
		final Pattern exclude = Pattern.compile("(org.springframework.|java.lang.reflect.Method.invoke|sun.reflect.)");
		boolean found = false;
		for (String line : stackTrace.split("\n")) {
			Matcher m = exclude.matcher(line);
			if (m.find()) {
				found = true;
			} else {
				if (found) {
					found = false;
					results.add("\tat [ignored] ...");
				}
				results.add(line);
			}
		}
		return StringUtils.join(results, "\n");
	}
	public static Properties getRuntimeProperties(String applicationName) {
		if (applicationName == null) {
			applicationName = "openmrs";
		}
		String pathName;
		pathName = getRuntimePropertiesFilePathName(applicationName);
		FileInputStream propertyStream = null;
		try {
			if (pathName != null) {
				propertyStream = new FileInputStream(pathName);
			}
		}
		catch (FileNotFoundException e) {
			log.warn("Unable to find a runtime properties file at " + new File(pathName).getAbsolutePath());
		}
		try {
			if (propertyStream == null) {
				throw new IOException("Could not find a runtime properties file named " + pathName
				        + " in the OpenMRS application data directory, or the current directory");
			}
			Properties props = new Properties();
			OpenmrsUtil.loadProperties(props, propertyStream);
			propertyStream.close();
			log.info("Using runtime properties file: " + pathName);
			return props;
		}
		catch (Exception ex) {
			log.info("Got an error while attempting to load the runtime properties", ex);
			log.warn(
			    "Unable to find a runtime properties file. Initial setup is needed. View the webapp to run the setup wizard.");
			return null;
		}
	}
	public static boolean isTestMode() {
		return "true".equalsIgnoreCase(System.getProperty("FUNCTIONAL_TEST_MODE"));
	}
	public static String getRuntimePropertiesFilePathName(String applicationName) {
		if (applicationName == null) {
			applicationName = "openmrs";
		}
		String defaultFileName = applicationName + "-runtime.properties";
		String fileNameInTestMode = getRuntimePropertiesFileNameInTestMode();
		String pathName = fileNameInTestMode != null ? fileNameInTestMode : defaultFileName;
		log.debug("Attempting to look for properties file in current directory: " + pathName);
		if (new File(pathName).exists()) {
			return pathName;
		} else {
			log.warn("Unable to find a runtime properties file at " + new File(pathName).getAbsolutePath());
		}
		String envVarName = applicationName.toUpperCase() + "_RUNTIME_PROPERTIES_FILE";
		String envFileName = System.getenv(envVarName);
		if (envFileName != null) {
			log.debug("Atempting to look for runtime properties from: " + pathName);
			if (new File(envFileName).exists()) {
				return envFileName;
			} else {
				log.warn("Unable to find properties file with path: " + pathName + ". (derived from environment variable "
				        + envVarName + ")");
			}
		} else {
			log.info("Couldn't find an environment variable named " + envVarName);
			if (log.isDebugEnabled()) {
				log.debug("Available environment variables are named: " + System.getenv().keySet());
			}
		}
		File file = new File(getApplicationDataDirectory(), pathName);
		pathName = file.getAbsolutePath();
		log.debug("Attempting to look for property file from: " + pathName);
		if (file.exists()) {
			return pathName;
		} else {
			log.warn("Unable to find properties file: " + pathName);
		}
		return null;
	}
	public static String getRuntimePropertiesFileNameInTestMode() {
		String filename = null;
		if (isTestMode()) {
			log.info("In functional testing mode. Ignoring the existing runtime properties file");
			filename = getOpenMRSVersionInTestMode() + "-test-runtime.properties";
		}
		return filename;
	}
	public static String getOpenMRSVersionInTestMode() {
		return System.getProperty("OPENMRS_VERSION", "openmrs");
	}
	public static boolean nullSafeEqualsIgnoreCase(String s1, String s2) {
		if (s1 == null) {
			return s2 == null;
		} else if (s2 == null) {
			return false;
		}
		return s1.equalsIgnoreCase(s2);
	}
	public static Integer convertToInteger(Long longValue) {
		if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {
			throw new IllegalArgumentException(longValue + " cannot be cast to Integer without changing its value.");
		}
		return longValue.intValue();
	}
	public static boolean isYesterday(Date date) {
		if (date == null) {
			return false;
		}
		Calendar c1 = Calendar.getInstance();
		c1.add(Calendar.DAY_OF_YEAR, -1); 
		Calendar c2 = Calendar.getInstance();
		c2.setTime(date);
		return (c1.get(Calendar.ERA) == c2.get(Calendar.ERA) && c1.get(Calendar.YEAR) == c2.get(Calendar.YEAR)
		        && c1.get(Calendar.DAY_OF_YEAR) == c2.get(Calendar.DAY_OF_YEAR));
	}
	public static Set<String> getDeclaredFields(Class<?> clazz) {
		return Arrays.stream(clazz.getDeclaredFields()).map(Field::getName).collect(Collectors.toSet());
	}
	public static String isValidNumericValue(Float value, Concept concept, Obs obs) {
		ConceptReferenceRange conceptReferenceRange = new ObsValidator().getReferenceRange(concept, obs);
		if (conceptReferenceRange == null) {
			return "";
		}
		if ((conceptReferenceRange.getHiAbsolute() != null && conceptReferenceRange.getHiAbsolute() < value) ||
			(conceptReferenceRange.getLowAbsolute() != null && conceptReferenceRange.getLowAbsolute() > value)) {
			return String.format("Expected value between %s and %s", conceptReferenceRange.getLowAbsolute(), conceptReferenceRange.getHiAbsolute());
		} else {
			return "";
		}
	}
}
package org.openmrs;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;
import org.hibernate.envers.Audited;
import org.openmrs.annotation.AllowDirectAccess;
@Audited
public class Program extends BaseChangeableOpenmrsMetadata {
	public static final long serialVersionUID = 3214567L;
	private Integer programId;
	private Concept concept;
	private Concept outcomesConcept;
	@AllowDirectAccess
	private Set<ProgramWorkflow> allWorkflows = new HashSet<>();
	public Program() {
	}
	public Program(Integer programId) {
		setProgramId(programId);
	}
	public Program(String name) {
		setName(name);
	}
	public void addWorkflow(ProgramWorkflow workflow) {
		workflow.setProgram(this);
		getAllWorkflows().add(workflow);
	}
	public void removeWorkflow(ProgramWorkflow workflow) {
		if (getAllWorkflows().contains(workflow)) {
			getAllWorkflows().remove(workflow);
			workflow.setProgram(null);
		}
	}
	public void retireWorkflow(ProgramWorkflow workflow) {
		workflow.setRetired(true);
	}
	public ProgramWorkflow getWorkflowByName(String name) {
		for (ProgramWorkflow pw : getAllWorkflows()) {
			if (pw.getConcept().isNamed(name)) {
				return pw;
			}
		}
		return null;
	}
	@Override
	public String toString() {
		return "Program(id=" + getProgramId() + ", concept=" + getConcept() + ", workflows=" + getWorkflows() + ")";
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		this.concept = concept;
	}
	public Concept getOutcomesConcept() {
		return outcomesConcept;
	}
	public void setOutcomesConcept(Concept concept) {
		this.outcomesConcept = concept;
	}
	public Integer getProgramId() {
		return programId;
	}
	public void setProgramId(Integer programId) {
		this.programId = programId;
	}
	public Set<ProgramWorkflow> getWorkflows() {
		Set<ProgramWorkflow> ret = new HashSet<>();
		for (ProgramWorkflow workflow : getAllWorkflows()) {
			if (!workflow.getRetired()) {
				ret.add(workflow);
			}
		}
		return ret;
	}
	public ProgramWorkflow getWorkflow(Integer programWorkflowId) {
		if (getWorkflows() != null) {
			for (ProgramWorkflow wf : getWorkflows()) {
				if (wf.getId().equals(programWorkflowId)) {
					return wf;
				}
			}
		}
		return null;
	}
	public Set<ProgramWorkflow> getAllWorkflows() {
		if (allWorkflows == null) {
			allWorkflows = new HashSet<>();
		}
		return allWorkflows;
	}
	public void setAllWorkflows(Set<ProgramWorkflow> allWorkflows) {
		this.allWorkflows = allWorkflows;
	}
	@Override
	public Integer getId() {
		return getProgramId();
	}
	@Override
	public void setId(Integer id) {
		setProgramId(id);
	}
}
package org.openmrs;
import org.hibernate.annotations.BatchSize;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
import org.hibernate.envers.Audited;
import org.openmrs.annotation.Independent;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import javax.persistence.AttributeOverride;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OrderBy;
import javax.persistence.Table;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
@Entity
@Table(name = "location")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@AttributeOverride(name = "attributes", column = @Column(name = "location_id"))
@Audited
public class Location extends BaseCustomizableMetadata<LocationAttribute> implements java.io.Serializable, Attributable<Location>, Address {
	public static final long serialVersionUID = 455634L;
	public static final int LOCATION_UNKNOWN = 1;
	@Id
	@Column(name = "location_id")
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer locationId;
	@ManyToOne
	@JoinColumn(name = "location_type_concept_id")
	private Concept type;
	@Column(name = "address1")
	private String address1;
	@Column(name = "address2")
	private String address2;
	@Column(name = "city_village")
	private String cityVillage;
	@Column(name = "state_province")
	private String stateProvince;
	@Column(name = "country", length = 50)
	private String country;
	@Column(name = "postal_code", length = 50)
	private String postalCode;
	@Column(name = "latitude", length = 50)
	private String latitude;
	@Column(name = "longitude", length = 50)
	private String longitude;
	@Column(name = "county_district")
	private String countyDistrict;
	@Column(name = "address3")
	private String address3;
	@Column(name = "address4")
	private String address4;
	@Column(name = "address6")
	private String address6;
	@Column(name = "address5")
	private String address5;
	@Column(name = "address7")
	private String address7;
	@Column(name = "address8")
	private String address8;
	@Column(name = "address9")
	private String address9;
	@Column(name = "address10")
	private String address10;
	@Column(name = "address11")
	private String address11;
	@Column(name = "address12")
	private String address12;
	@Column(name = "address13")
	private String address13;
	@Column(name = "address14")
	private String address14;
	@Column(name = "address15")
	private String address15;
	@ManyToOne
	@JoinColumn(name = "parent_location")
	private Location parentLocation;
	@OneToMany(mappedBy = "parentLocation", cascade = CascadeType.ALL, orphanRemoval = true)
	@BatchSize(size = 100)
	@OrderBy("name")
	private Set<Location> childLocations;
	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(
		name = "location_tag_map",
		joinColumns = @JoinColumn(name = "location_id"),
		inverseJoinColumns = @JoinColumn(name = "location_tag_id"))
	@Independent
	private Set<LocationTag> tags;
	public Location() {
	}
	public Location(Integer locationId) {
		this.locationId = locationId;
	}
	@Override
	public String getAddress1() {
		return address1;
	}
	@Override
	public void setAddress1(String address1) {
		this.address1 = address1;
	}
	@Override
	public String getAddress2() {
		return address2;
	}
	@Override
	public void setAddress2(String address2) {
		this.address2 = address2;
	}
	@Override
	public String getCityVillage() {
		return cityVillage;
	}
	@Override
	public void setCityVillage(String cityVillage) {
		this.cityVillage = cityVillage;
	}
	@Override
	public String getCountry() {
		return country;
	}
	@Override
	public void setCountry(String country) {
		this.country = country;
	}
	@Override
	public String getLatitude() {
		return latitude;
	}
	@Override
	public void setLatitude(String latitude) {
		this.latitude = latitude;
	}
	public Integer getLocationId() {
		return locationId;
	}
	public void setLocationId(Integer locationId) {
		this.locationId = locationId;
	}
	@Override
	public String getLongitude() {
		return longitude;
	}
	@Override
	public void setLongitude(String longitude) {
		this.longitude = longitude;
	}
	@Override
	public String getPostalCode() {
		return postalCode;
	}
	@Override
	public void setPostalCode(String postalCode) {
		this.postalCode = postalCode;
	}
	@Override
	public String getStateProvince() {
		return stateProvince;
	}
	@Override
	public void setStateProvince(String stateProvince) {
		this.stateProvince = stateProvince;
	}
	@Override
	public String toString() {
		if (getName() != null) {
			return getName();
		}
		if (getId() != null) {
			return getId().toString();
		}
		return "";
	}
	@Override
	public String getCountyDistrict() {
		return countyDistrict;
	}
	@Override
	public void setCountyDistrict(String countyDistrict) {
		this.countyDistrict = countyDistrict;
	}
	public Concept getType() {
		return type;
	}
	public void setType(Concept type) {
		this.type = type;
	}
	@Override
	@Deprecated
	public List<Location> findPossibleValues(String searchText) {
		try {
			return Context.getLocationService().getLocations(searchText);
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	@Override
	@Deprecated
	public List<Location> getPossibleValues() {
		try {
			return Context.getLocationService().getAllLocations();
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	@Override
	public Location hydrate(String locationId) {
		try {
			return Context.getLocationService().getLocation(Integer.valueOf(locationId));
		}
		catch (Exception e) {
			return new Location();
		}
	}
	@Override
	public String serialize() {
		if (getLocationId() != null) {
			return "" + getLocationId();
		} else {
			return "";
		}
	}
	@Override
	public String getDisplayString() {
		return getName();
	}
	public Location getParentLocation() {
		return parentLocation;
	}
	public void setParentLocation(Location parentLocationId) {
		this.parentLocation = parentLocationId;
	}
	public Set<Location> getChildLocations() {
		return childLocations;
	}
	public Set<Location> getChildLocations(boolean includeRetired) {
		Set<Location> ret = new HashSet<>();
		if (includeRetired) {
			ret = getChildLocations();
		} else if (getChildLocations() != null) {
			for (Location l : getChildLocations()) {
				if (!l.getRetired()) {
					ret.add(l);
				}
			}
		}
		return ret;
	}
	public Set<Location> getDescendantLocations(boolean includeRetired) {
		Set<Location> result = new HashSet<>();
		for (Location childLocation : getChildLocations()) {
			if (!childLocation.getRetired() || includeRetired) {
				result.add(childLocation);
				result.addAll(childLocation.getDescendantLocations(includeRetired));
			}
		}
		return result;
	}
	public void setChildLocations(Set<Location> childLocations) {
		this.childLocations = childLocations;
	}
	public void addChildLocation(Location child) {
		if (child == null) {
			return;
		}
		if (getChildLocations() == null) {
			childLocations = new HashSet<>();
		}
		if (child.equals(this)) {
			throw new APIException("Location.cannot.be.its.own.child", (Object[]) null);
		}
		Location root = this;
		while (root.getParentLocation() != null) {
			root = root.getParentLocation();
		}
		if (isInHierarchy(child, root)) {
			throw new APIException("Location.hierarchy.loop", new Object[] { child, this });
		}
		child.setParentLocation(this);
		childLocations.add(child);
	}
	public static Boolean isInHierarchy(Location location, Location root) {
		if (root == null) {
			return false;
		}
		while (true) {
			if (location == null) {
				return false;
			} else if (root.equals(location)) {
				return true;
			}
			location = location.getParentLocation();
		}
	}
	public void removeChildLocation(Location child) {
		if (getChildLocations() != null) {
			childLocations.remove(child);
		}
	}
	public Set<LocationTag> getTags() {
		return tags;
	}
	public void setTags(Set<LocationTag> tags) {
		this.tags = tags;
	}
	public void addTag(LocationTag tag) {
		if (getTags() == null) {
			tags = new HashSet<>();
		}
		if (tag != null && !tags.contains(tag)) {
			tags.add(tag);
		}
	}
	public void removeTag(LocationTag tag) {
		if (getTags() != null) {
			tags.remove(tag);
		}
	}
	public Boolean hasTag(String tagToFind) {
		if (tagToFind != null && getTags() != null) {
			for (LocationTag locTag : getTags()) {
				if (locTag.getName().equals(tagToFind)) {
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public String getAddress3() {
		return address3;
	}
	@Override
	public void setAddress3(String address3) {
		this.address3 = address3;
	}
	@Override
	public String getAddress4() {
		return address4;
	}
	@Override
	public void setAddress4(String address4) {
		this.address4 = address4;
	}
	@Override
	public String getAddress6() {
		return address6;
	}
	@Override
	public void setAddress6(String address6) {
		this.address6 = address6;
	}
	@Override
	public String getAddress5() {
		return address5;
	}
	@Override
	public void setAddress5(String address5) {
		this.address5 = address5;
	}
	@Override
	public Integer getId() {
		return getLocationId();
	}
	@Override
	public void setId(Integer id) {
		setLocationId(id);
	}
	@Override
	public String getAddress7() {
		return address7;
	}
	@Override
	public void setAddress7(String address7) {
		this.address7 = address7;
	}
	@Override
	public String getAddress8() {
		return address8;
	}
	@Override
	public void setAddress8(String address8) {
		this.address8 = address8;
	}
	@Override
	public String getAddress9() {
		return address9;
	}
	@Override
	public void setAddress9(String address9) {
		this.address9 = address9;
	}
	@Override
	public String getAddress10() {
		return address10;
	}
	@Override
	public void setAddress10(String address10) {
		this.address10 = address10;
	}
	@Override
	public String getAddress11() {
		return address11;
	}
	@Override
	public void setAddress11(String address11) {
		this.address11 = address11;
	}
	@Override
	public String getAddress12() {
		return address12;
	}
	@Override
	public void setAddress12(String address12) {
		this.address12 = address12;
	}
	@Override
	public String getAddress13() {
		return address13;
	}
	@Override
	public void setAddress13(String address13) {
		this.address13 = address13;
	}
	@Override
	public String getAddress14() {
		return address14;
	}
	@Override
	public void setAddress14(String address14) {
		this.address14 = address14;
	}
	@Override
	public String getAddress15() {
		return address15;
	}
	@Override
	public void setAddress15(String address15) {
		this.address15 = address15;
	}
}
package org.openmrs;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.ContainedIn;
@Audited
public class Patient extends Person {
	public static final long serialVersionUID = 93123L;
	private Integer patientId;
	private String allergyStatus = Allergies.UNKNOWN;
	@ContainedIn
	private Set<PatientIdentifier> identifiers;
	public Patient() {
		setPatient(true);
	}
	public Patient(Person person) {
		super(person);
		if (person != null) {
			this.patientId = person.getPersonId();
			if (person.getUuid() != null) {
				this.setUuid(person.getUuid());
			}
		}
		setPatient(true);
	}
	public Patient(Integer patientId) {
		super(patientId);
		this.patientId = patientId;
		setPatient(true);
	}
	public Patient(Patient patient) {
		super(patient);
		this.patientId = patient.getPatientId();
		this.allergyStatus = patient.getAllergyStatus();
		Set<PatientIdentifier> newIdentifiers = new TreeSet<>();
		for (PatientIdentifier pid : patient.getIdentifiers()) {
			PatientIdentifier identifierClone = (PatientIdentifier) pid.clone();
			identifierClone.setPatient(this);
			newIdentifiers.add(identifierClone);
		}
		this.identifiers = newIdentifiers;
	}
	public Integer getPatientId() {
		if (this.patientId == null) {
			this.patientId = getPersonId();
		}
		return this.patientId;
	}
	public void setPatientId(Integer patientId) {
		super.setPersonId(patientId);
		this.patientId = patientId;
	}
	public String getAllergyStatus() {
		return this.allergyStatus;
	}
	public void setAllergyStatus(String allergyStatus) {
		this.allergyStatus = allergyStatus;
	}
	@Override
	public void setPersonId(Integer personId) {
		super.setPersonId(personId);
		this.patientId = personId;
	}
	public Set<PatientIdentifier> getIdentifiers() {
		if (identifiers == null) {
			identifiers = new TreeSet<>();
		}
		return this.identifiers;
	}
	public void setIdentifiers(Set<PatientIdentifier> identifiers) {
		this.identifiers = identifiers;
	}
	public void addIdentifiers(Collection<PatientIdentifier> patientIdentifiers) {
		for (PatientIdentifier identifier : patientIdentifiers) {
			addIdentifier(identifier);
		}
	}
	public void addIdentifier(PatientIdentifier patientIdentifier) {
		if (patientIdentifier != null) {
			patientIdentifier.setPatient(this);
			for (PatientIdentifier currentId : getActiveIdentifiers()) {
				if (currentId.equalsContent(patientIdentifier)) {
					return;
				}
			}
		}
		getIdentifiers().add(patientIdentifier);
	}
	public void removeIdentifier(PatientIdentifier patientIdentifier) {
		if (patientIdentifier != null) {
			getIdentifiers().remove(patientIdentifier);
		}
	}
	public PatientIdentifier getPatientIdentifier() {
		if (!getIdentifiers().isEmpty()) {
			for (PatientIdentifier id : getIdentifiers()) {
				if (id.getPreferred() && !id.getVoided()) {
					return id;
				}
			}
			for (PatientIdentifier id : getIdentifiers()) {
				if (!id.getVoided()) {
					return id;
				}
			}
			return null;
		}
		return null;
	}
	public PatientIdentifier getPatientIdentifier(PatientIdentifierType pit) {
		if (!getIdentifiers().isEmpty()) {
			for (PatientIdentifier id : getIdentifiers()) {
				if (id.getPreferred() && !id.getVoided() && pit.equals(id.getIdentifierType())) {
					return id;
				}
			}
			for (PatientIdentifier id : getIdentifiers()) {
				if (!id.getVoided() && pit.equals(id.getIdentifierType())) {
					return id;
				}
			}
			return null;
		}
		return null;
	}
	public PatientIdentifier getPatientIdentifier(Integer identifierTypeId) {
		if (!getIdentifiers().isEmpty()) {
			for (PatientIdentifier id : getIdentifiers()) {
				if (id.getPreferred() && !id.getVoided()
				        && identifierTypeId.equals(id.getIdentifierType().getPatientIdentifierTypeId())) {
					return id;
				}
			}
			for (PatientIdentifier id : getIdentifiers()) {
				if (!id.getVoided() && identifierTypeId.equals(id.getIdentifierType().getPatientIdentifierTypeId())) {
					return id;
				}
			}
			return null;
		}
		return null;
	}
	public PatientIdentifier getPatientIdentifier(String identifierTypeName) {
		if (!getIdentifiers().isEmpty()) {
			for (PatientIdentifier id : getIdentifiers()) {
				if (id.getPreferred() && !id.getVoided() && identifierTypeName.equals(id.getIdentifierType().getName())) {
					return id;
				}
			}
			for (PatientIdentifier id : getIdentifiers()) {
				if (!id.getVoided() && identifierTypeName.equals(id.getIdentifierType().getName())) {
					return id;
				}
			}
			return null;
		}
		return null;
	}
	public List<PatientIdentifier> getActiveIdentifiers() {
		List<PatientIdentifier> ids = new ArrayList<>();
		List<PatientIdentifier> nonPreferred = new LinkedList<>();
		for (PatientIdentifier pi : getIdentifiers()) {
			if (!pi.getVoided()) {
				if (pi.getPreferred()) {
					ids.add(pi);
				} else {
					nonPreferred.add(pi);
				}
			}
		}
		ids.addAll(nonPreferred);
		return ids;
	}
	public List<PatientIdentifier> getPatientIdentifiers(PatientIdentifierType pit) {
		List<PatientIdentifier> ids = new ArrayList<>();
		for (PatientIdentifier pi : getIdentifiers()) {
			if (!pi.getVoided() && pit.equals(pi.getIdentifierType())) {
				ids.add(pi);
			}
		}
		return ids;
	}
	@Override
	public String toString() {
		return "Patient#" + patientId;
	}
	@Override
	public Integer getId() {
		return getPatientId();
	}
	@Override
	public void setId(Integer id) {
		setPatientId(id);
	}
	public Person getPerson() {
		return this;
	}
}
package org.openmrs;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.ContainedIn;
import org.hibernate.search.annotations.DocumentId;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.FullTextFilterDef;
import org.hibernate.search.annotations.FullTextFilterDefs;
import org.hibernate.search.annotations.IndexedEmbedded;
import org.openmrs.annotation.AllowDirectAccess;
import org.openmrs.api.APIException;
import org.openmrs.api.ConceptNameType;
import org.openmrs.api.ConceptService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.hibernate.search.TermsFilterFactory;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.Customizable;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.ObjectUtils;
@FullTextFilterDefs( { @FullTextFilterDef(name = "termsFilterFactory", impl = TermsFilterFactory.class) })
@Audited
public class Concept extends BaseOpenmrsObject implements Auditable, Retireable, Serializable, Attributable<Concept>,Customizable<ConceptAttribute> {
	public static final long serialVersionUID = 57332L;
	private static final Logger log = LoggerFactory.getLogger(Concept.class);
	private static final String CONCEPT_NAME_LOCALE_NULL = "Concept.name.locale.null";
	@DocumentId
	private Integer conceptId;
	@Field
	private Boolean retired = false;
	private User retiredBy;
	private Date dateRetired;
	private String retireReason;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private ConceptDatatype datatype;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private ConceptClass conceptClass;
	private Boolean set = false;
	private String version;
	private User creator;
	private Date dateCreated;
	private User changedBy;
	private Date dateChanged;
	@AllowDirectAccess
	@ContainedIn
	private Collection<ConceptName> names;
	@AllowDirectAccess
	private Collection<ConceptAnswer> answers;
	private Collection<ConceptSet> conceptSets;
	private Collection<ConceptDescription> descriptions;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private Collection<ConceptMap> conceptMappings;
	private Map<Locale, List<ConceptName>> compatibleCache;
	private Set<ConceptAttribute> attributes = new LinkedHashSet<>();
	public Concept() {
		names = new HashSet<>();
		answers = new HashSet<>();
		conceptSets = new TreeSet<>();
		descriptions = new HashSet<>();
		conceptMappings = new HashSet<>();
	}
	public Concept(Integer conceptId) {
		this();
		this.conceptId = conceptId;
	}
	public Collection<ConceptAnswer> getAnswers() {
		if (answers == null) {
			answers = new HashSet<>();
		}
		return answers;
	}
	public Collection<ConceptAnswer> getAnswers(boolean includeRetired) {
		if (includeRetired) {
			return getAnswers();
		} else {
			return getAnswers().stream()
					.filter(a -> !a.getAnswerConcept().getRetired())
					.collect(Collectors.toSet());
		}
	}
	public void setAnswers(Collection<ConceptAnswer> answers) {
		this.answers = answers;
	}
	public void addAnswer(ConceptAnswer conceptAnswer) {
		if (conceptAnswer != null) {
			if (!getAnswers().contains(conceptAnswer)) {
				conceptAnswer.setConcept(this);
				getAnswers().add(conceptAnswer);
			}
			if ((conceptAnswer.getSortWeight() == null) || (conceptAnswer.getSortWeight() <= 0)) {
				ConceptAnswer a = Collections.max(answers);
				Double sortWeight = (a == null) ? 1d : ((a.getSortWeight() == null) ? 1d : a.getSortWeight() + 1d);
				conceptAnswer.setSortWeight(sortWeight);
			}
		}
	}
	public boolean removeAnswer(ConceptAnswer conceptAnswer) {
		return getAnswers().remove(conceptAnswer);
	}
	@Override
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	public ConceptClass getConceptClass() {
		return conceptClass;
	}
	public void setConceptClass(ConceptClass conceptClass) {
		this.conceptClass = conceptClass;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isSet() {
		return getSet();
	}
	public void setSet(Boolean set) {
		this.set = set;
	}
	public Boolean getSet() {
		return set;
	}
	public ConceptDatatype getDatatype() {
		return datatype;
	}
	public void setDatatype(ConceptDatatype conceptDatatype) {
		this.datatype = conceptDatatype;
	}
	public Integer getConceptId() {
		return conceptId;
	}
	public void setConceptId(Integer conceptId) {
		this.conceptId = conceptId;
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	@Override
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	public void setPreferredName(ConceptName preferredName) {
		if (preferredName == null || preferredName.getVoided() || preferredName.isIndexTerm()) {
			throw new APIException("Concept.error.preferredName.null", (Object[]) null);
		} else if (preferredName.getLocale() == null) {
			throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
		}
		ConceptName oldPreferredName = getPreferredName(preferredName.getLocale(), true);
		if (oldPreferredName != null) {
			oldPreferredName.setLocalePreferred(false);
		}
		preferredName.setLocalePreferred(true);
		if (preferredName.getConceptNameId() == null || !getNames().contains(preferredName)) {
			addName(preferredName);
		}
	}
	public ConceptName findNameTaggedWith(ConceptNameTag conceptNameTag) {
		ConceptName taggedName = null;
		for (ConceptName possibleName : getNames()) {
			if (possibleName.hasTag(conceptNameTag)) {
				taggedName = possibleName;
				break;
			}
		}
		return taggedName;
	}
	public ConceptName getName(Locale locale) {
		return getName(locale, false);
	}
	public ConceptName getName() {
		if (getNames().isEmpty()) {
			log.debug("there are no names defined for: {}", conceptId);
			return null;
		}
		for (Locale currentLocale : LocaleUtility.getLocalesInOrder()) {
			ConceptName preferredName = getPreferredName(currentLocale);
			if (preferredName != null) {
				return preferredName;
			}
			ConceptName fullySpecifiedName = getFullySpecifiedName(currentLocale);
			if (fullySpecifiedName != null) {
				return fullySpecifiedName;
			}
			if (!StringUtils.isBlank(currentLocale.getCountry()) || !StringUtils.isBlank(currentLocale.getVariant())) {
				Locale broaderLocale = new Locale(currentLocale.getLanguage());
				ConceptName prefNameInBroaderLoc = getPreferredName(broaderLocale);
				if (prefNameInBroaderLoc != null) {
					return prefNameInBroaderLoc;
				}
				ConceptName fullySpecNameInBroaderLoc = getFullySpecifiedName(broaderLocale);
				if (fullySpecNameInBroaderLoc != null) {
					return fullySpecNameInBroaderLoc;
				}
			}
		}
		for (ConceptName cn : getNames()) {
			if (cn.isFullySpecifiedName()) {
				return cn;
			}
		}
		if (!getSynonyms().isEmpty()) {
			return getSynonyms().iterator().next();
		}
		return null;
	}
	public boolean hasName(String name, Locale locale) {
		if (name == null) {
			return false;
		}
		Collection<ConceptName> currentNames;
		if (locale == null) {
			currentNames = getNames();
		} else {
			currentNames = getNames(locale);
		}
		for (ConceptName currentName : currentNames) {
			if (name.equalsIgnoreCase(currentName.getName())) {
				return true;
			}
		}
		return false;
	}
	public ConceptName getName(Locale locale, ConceptNameType ofType, ConceptNameTag havingTag) {
		Collection<ConceptName> namesInLocale = getNames(locale);
		if (!namesInLocale.isEmpty()) {
			List<ConceptName> matches = namesInLocale.stream().filter(
				c->(ofType==null || ofType.equals(c.getConceptNameType())) && (havingTag==null || c.hasTag(havingTag))
			).collect(Collectors.toList());
			if (matches.size() == 1) {
				return matches.get(0);
			} else if (matches.size() > 1) {
				for (ConceptName match : matches) {
					if (match.getLocalePreferred()) {
						return match;
					}
				}
				return matches.get(0);
			}
		}
		Locale parent = new Locale(locale.getLanguage());
		if (!parent.equals(locale)) {
			return getName(parent, ofType, havingTag);
		} else {
			return null;
		}
	}
	public ConceptName getName(Locale locale, boolean exact) {
		if (getNames().isEmpty()) {
			log.debug("there are no names defined for: {}", conceptId);
			return null;
		}
		log.debug("Getting conceptName for locale: {}", locale);
		ConceptName exactName = getNameInLocale(locale);
		if (exactName != null) {
			return exactName;
		}
		if (!exact) {
			Locale broaderLocale = new Locale(locale.getLanguage());
			ConceptName name = getNameInLocale(broaderLocale);
			return name != null ? name : getName();
		}
		return null;
	}
	private ConceptName getNameInLocale(Locale locale) {
		ConceptName preferredName = getPreferredName(locale);
		if (preferredName != null) {
			return preferredName;
		}
		ConceptName fullySpecifiedName = getFullySpecifiedName(locale);
		if (fullySpecifiedName != null) {
			return fullySpecifiedName;
		} else if (!getSynonyms(locale).isEmpty()) {
			return getSynonyms(locale).iterator().next();
		}
		return null;
	}
	public ConceptName getPreferredName(Locale forLocale) {
		return getPreferredName(forLocale, false);
	}
	public ConceptName getPreferredName(Locale forLocale, Boolean exact) {
		if (log.isDebugEnabled()) {
			log.debug("Getting preferred conceptName for locale: " + forLocale);
		}
		if (forLocale == null) {
			log.warn("Locale cannot be null");
			return null;
		}
		for (ConceptName nameInLocale : getNames(forLocale)) {
			if (ObjectUtils.nullSafeEquals(nameInLocale.getLocalePreferred(), true)) {
				return nameInLocale;
			}
		}
		if (exact) {
			return null;
		} else {
			ConceptName bestMatch = null;
			for (ConceptName nameInLocale : getPartiallyCompatibleNames(forLocale)) {
				if (ObjectUtils.nullSafeEquals(nameInLocale.getLocalePreferred(), true)) {
					Locale nameLocale = nameInLocale.getLocale();
					if (forLocale.getLanguage().equals(nameLocale.getLanguage())) {
						return nameInLocale;
					} else {
						bestMatch = nameInLocale;
					}
				}
			}
			if (bestMatch != null) {
				return bestMatch;
			}
			return getFullySpecifiedName(forLocale);
		}
	}
	public ConceptName getFullySpecifiedName(Locale locale) {
		if (locale != null && !getNames(locale).isEmpty()) {
			for (ConceptName conceptName : getNames(locale)) {
				if (ObjectUtils.nullSafeEquals(conceptName.isFullySpecifiedName(), true)) {
					return conceptName;
				}
			}
			ConceptName bestMatch = null;
			for (ConceptName conceptName : getPartiallyCompatibleNames(locale)) {
				if (ObjectUtils.nullSafeEquals(conceptName.isFullySpecifiedName(), true)) {
					Locale nameLocale = conceptName.getLocale();
					if (locale.getLanguage().equals(nameLocale.getLanguage())) {
						return conceptName;
					}
					bestMatch = conceptName;
				}
			}
			return bestMatch;
		}
		return null;
	}
	public Collection<ConceptName> getNames(Locale locale) {
		return getNames().stream()
				.filter(n -> n.getLocale().equals(locale))
				.collect(Collectors.toSet());
	}
	private Collection<ConceptName> getPartiallyCompatibleNames(Locale locale) {
		String language = locale.getLanguage();
		String country = locale.getCountry();
		return getNames().stream()
				.filter(n -> language.equals(n.getLocale().getLanguage()) || 
							StringUtils.isNotBlank(country) && country.equals(n.getLocale().getCountry()))
				.collect(Collectors.toSet());
	}
	public List<ConceptName> getCompatibleNames(Locale desiredLocale) {
		List<ConceptName> compatibleNames = null;
		if (compatibleCache == null) {
			compatibleCache = new HashMap<>();
		} else {
			compatibleNames = compatibleCache.get(desiredLocale);
		}
		if (compatibleNames == null) {
			compatibleNames = new ArrayList<>();
			for (ConceptName possibleName : getNames()) {
				if (LocaleUtility.areCompatible(possibleName.getLocale(), desiredLocale)) {
					compatibleNames.add(possibleName);
				}
			}
			compatibleCache.put(desiredLocale, compatibleNames);
		}
		return compatibleNames;
	}
	public void setFullySpecifiedName(ConceptName fullySpecifiedName) {
		if (fullySpecifiedName == null || fullySpecifiedName.getLocale() == null) {
			throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
		} else if (fullySpecifiedName.getVoided()) {
			throw new APIException("Concept.error.fullySpecifiedName.null", (Object[]) null);
		}
		ConceptName oldFullySpecifiedName = getFullySpecifiedName(fullySpecifiedName.getLocale());
		if (oldFullySpecifiedName != null) {
			oldFullySpecifiedName.setConceptNameType(null);
		}
		fullySpecifiedName.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
		if (fullySpecifiedName.getConceptNameId() == null || !getNames().contains(fullySpecifiedName)) {
			addName(fullySpecifiedName);
		}
	}
	public void setShortName(ConceptName shortName) {
		if (shortName != null) {
			if (shortName.getLocale() == null) {
				throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
			}
			ConceptName oldShortName = getShortNameInLocale(shortName.getLocale());
			if (oldShortName != null) {
				oldShortName.setConceptNameType(null);
			}
			shortName.setConceptNameType(ConceptNameType.SHORT);
			if (StringUtils.isNotBlank(shortName.getName())
			        && (shortName.getConceptNameId() == null || !getNames().contains(shortName))) {
				addName(shortName);
			}
		} else {
			throw new APIException("Concept.error.shortName.null", (Object[]) null);
		}
	}
	public ConceptName getShortNameInLocale(Locale locale) {
		ConceptName bestMatch = null;
		if (locale != null && !getShortNames().isEmpty()) {
			for (ConceptName shortName : getShortNames()) {
				Locale nameLocale = shortName.getLocale();
				if (nameLocale.equals(locale)) {
					return shortName;
				}
				if (OpenmrsUtil.nullSafeEquals(locale.getLanguage(), nameLocale.getLanguage())) {
					bestMatch = shortName;
				} else if (bestMatch == null && StringUtils.isNotBlank(locale.getCountry())
				        && locale.getCountry().equals(nameLocale.getCountry())) {
					bestMatch = shortName;
				}
			}
		}
		return bestMatch;
	}
	public Collection<ConceptName> getShortNames() {
		List<ConceptName> shortNames = new ArrayList<>();
		if (getNames().isEmpty()) {
			if (log.isDebugEnabled()) {
				log.debug("The Concept with id: " + conceptId + " has no names");
			}
		} else {
			shortNames = getNames().stream()
							.filter(ConceptName::isShort)
							.collect(Collectors.toList());
		}
		return shortNames;
	}
	public ConceptName getShortestName(Locale locale, Boolean exact) {
		if (log.isDebugEnabled()) {
			log.debug("Getting shortest conceptName for locale: " + locale);
		}
		ConceptName shortNameInLocale = getShortNameInLocale(locale);
		if (shortNameInLocale != null) {
			return shortNameInLocale;
		}
		ConceptName shortestNameForLocale = null;
		ConceptName shortestNameForConcept = null;
		if (locale != null) {
			for (ConceptName possibleName : getNames()) {
				if (possibleName.getLocale().equals(locale)
				        && ((shortestNameForLocale == null) || (possibleName.getName().length() < shortestNameForLocale
				                .getName().length()))) {
					shortestNameForLocale = possibleName;
				}
				if ((shortestNameForConcept == null)
				        || (possibleName.getName().length() < shortestNameForConcept.getName().length())) {
					shortestNameForConcept = possibleName;
				}
			}
		}
		if (exact) {
			if (shortestNameForLocale == null) {
				log.warn("No short concept name found for concept id " + conceptId + " for locale "
				        + locale.getDisplayName());
			}
			return shortestNameForLocale;
		}
		return shortestNameForConcept;
	}
	public boolean isNamed(String name) {
		return getNames().stream().anyMatch(cn -> name.equals(cn.getName()));
	}
	public Collection<ConceptName> getIndexTerms() {
		return getNames().stream()
				.filter(ConceptName::isIndexTerm)
				.collect(Collectors.toSet());		
	}
	public Collection<ConceptName> getIndexTermsForLocale(Locale locale) {
		return getIndexTerms().stream()
				.filter(n -> n.getLocale().equals(locale))
		        .collect(Collectors.toList());
	}
	public Collection<ConceptName> getNames() {
		return getNames(false);
	}
	public Collection<ConceptName> getNames(boolean includeVoided) {
		if (names == null) {
			names = new HashSet<>();
		}
		return names.stream()
				.filter(n -> includeVoided || !n.getVoided())
				.collect(Collectors.toSet());
	}
	public void setNames(Collection<ConceptName> names) {
		this.names = names;
	}
	public void addName(ConceptName conceptName) {
		if (conceptName != null) {
			conceptName.setConcept(this);
			if (names == null) {
				names = new HashSet<>();
			}
			if (!names.contains(conceptName)) {
				if (getNames().isEmpty()
				        && !ConceptNameType.FULLY_SPECIFIED.equals(conceptName.getConceptNameType())) {
					conceptName.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
				} else {
					if (conceptName.isPreferred() && !conceptName.isIndexTerm() && conceptName.getLocale() != null) {
						ConceptName prefName = getPreferredName(conceptName.getLocale(), true);
						if (prefName != null) {
							prefName.setLocalePreferred(false);
						}
					}
					if (conceptName.isFullySpecifiedName() && conceptName.getLocale() != null) {
						ConceptName fullySpecName = getFullySpecifiedName(conceptName.getLocale());
						if (fullySpecName != null) {
							fullySpecName.setConceptNameType(null);
						}
					} else if (conceptName.isShort() && conceptName.getLocale() != null) {
						ConceptName shortName = getShortNameInLocale(conceptName.getLocale());
						if (shortName != null) {
							shortName.setConceptNameType(null);
						}
					}
				}
				names.add(conceptName);
				if (compatibleCache != null) {
					compatibleCache.clear();
				}
			}
		}
	}
	public boolean removeName(ConceptName conceptName) {
		if (names != null) {
			return names.remove(conceptName);
		} else {
			return false;
		}
	}
	public ConceptDescription getDescription() {
		return getDescription(Context.getLocale());
	}
	public ConceptDescription getDescription(Locale locale) {
		return getDescription(locale, false);
	}
	public ConceptDescription getDescription(Locale locale, boolean exact) {
		log.debug("Getting ConceptDescription for locale: " + locale);
		ConceptDescription foundDescription = null;
		if (locale == null) {
			locale = LocaleUtility.getDefaultLocale();
		}
		Locale desiredLocale = locale;
		ConceptDescription defaultDescription = null;
		for (ConceptDescription availableDescription : getDescriptions()) {
			Locale availableLocale = availableDescription.getLocale();
			if (availableLocale.equals(desiredLocale)) {
				foundDescription = availableDescription;
				break;
			}
			if (!exact && LocaleUtility.areCompatible(availableLocale, desiredLocale)) {
				foundDescription = availableDescription;
			}
			if (availableLocale.equals(LocaleUtility.getDefaultLocale())) {
				defaultDescription = availableDescription;
			}
		}
		if (foundDescription == null) {
			if (exact) {
				log.debug("No concept description found for concept id " + conceptId + " for locale "
				        + desiredLocale.toString());
			} else {
				if (defaultDescription == null) {
					log.debug("No concept description found for default locale for concept id " + conceptId);
				} else {
					foundDescription = defaultDescription;
				}
			}
		}
		return foundDescription;
	}
	@Override
	public User getRetiredBy() {
		return retiredBy;
	}
	@Override
	public void setRetiredBy(User retiredBy) {
		this.retiredBy = retiredBy;
	}
	@Override
	public Date getDateRetired() {
		return dateRetired;
	}
	@Override
	public void setDateRetired(Date dateRetired) {
		this.dateRetired = dateRetired;
	}
	@Override
	public String getRetireReason() {
		return retireReason;
	}
	@Override
	public void setRetireReason(String retireReason) {
		this.retireReason = retireReason;
	}
	public Collection<ConceptDescription> getDescriptions() {
		if (descriptions == null) {
			descriptions = new HashSet<>();
		}
		return descriptions;
	}
	public void setDescriptions(Collection<ConceptDescription> descriptions) {
		this.descriptions = descriptions;
	}
	public void addDescription(ConceptDescription description) {
		if (description != null && StringUtils.isNotBlank(description.getDescription()) && !descriptions.contains(description)) {
			description.setConcept(this);
			descriptions.add(description);
		}
	}
	public boolean removeDescription(ConceptDescription description) {
		return descriptions.remove(description);
	}
	@Override
	@Deprecated
	@JsonIgnore
	public Boolean isRetired() {
		return getRetired();
	}
	@Override
	public Boolean getRetired() {
		return retired;
	}
	@Override
	public void setRetired(Boolean retired) {
		this.retired = retired;
	}
	public Collection<ConceptName> getSynonyms(Locale locale) {
		List<ConceptName> syns = new ArrayList<>();
		ConceptName preferredConceptName = null;
		for (ConceptName possibleSynonymInLoc : getSynonyms()) {
			if (locale.equals(possibleSynonymInLoc.getLocale())) {
				if (possibleSynonymInLoc.isPreferred()) {
					preferredConceptName = possibleSynonymInLoc;
				} else {
					syns.add(possibleSynonymInLoc);
				}
			}
		}
		if (preferredConceptName != null) {
			syns.add(0, preferredConceptName);
		}
		log.debug("returning: " + syns);
		return syns;
	}
	public Collection<ConceptName> getSynonyms() {
		return getNames().stream()
				.filter(ConceptName::isSynonym)
				.collect(Collectors.toSet());
	}
	public String getVersion() {
		return version;
	}
	public void setVersion(String version) {
		this.version = version;
	}
	public Collection<ConceptSet> getConceptSets() {
		return conceptSets;
	}
	public void setConceptSets(Collection<ConceptSet> conceptSets) {
		this.conceptSets = conceptSets;
	}
	public boolean isNumeric() {
		return false;
	}
	public Collection<ConceptMap> getConceptMappings() {
		if (conceptMappings == null) {
			conceptMappings = new HashSet<>();
		}
		return conceptMappings;
	}
	public void setConceptMappings(Collection<ConceptMap> conceptMappings) {
		this.conceptMappings = conceptMappings;
	}
	public void addConceptMapping(ConceptMap newConceptMap) {
		if (newConceptMap != null) {
			newConceptMap.setConcept(this);
		}
		if (newConceptMap != null && !getConceptMappings().contains(newConceptMap)) {
			if (newConceptMap.getConceptMapType() == null) {
				newConceptMap.setConceptMapType(Context.getConceptService().getDefaultConceptMapType());
			}
			getConceptMappings().add(newConceptMap);
		}
	}
	public boolean isComplex() {
		return false;
	}
	public boolean removeConceptMapping(ConceptMap conceptMap) {
		return getConceptMappings().remove(conceptMap);
	}
	@Override
	public String toString() {
		return "Concept #" + conceptId;
	}
	@Override
	@Deprecated
	public List<Concept> findPossibleValues(String searchText) {
		List<Concept> concepts = new ArrayList<>();
		try {
			for (ConceptSearchResult searchResult : Context.getConceptService().getConcepts(searchText,
			    Collections.singletonList(Context.getLocale()), false, null, null, null, null, null, null, null)) {
				concepts.add(searchResult.getConcept());
			}
		}
		catch (Exception e) {
		}
		return concepts;
	}
	@Override
	@Deprecated
	public List<Concept> getPossibleValues() {
		try {
			return Context.getConceptService().getConceptsByName("");
		}
		catch (Exception e) {
		}
		return Collections.emptyList();
	}
	@Override
	public Concept hydrate(String reference) {
		try {
			return Context.getConceptService().getConceptByReference(reference);
		}
		catch (Exception e) {
		}
		return null;
	}
	@Override
	public String serialize() {
		if (this.getConceptId() == null) {
			return "";
		}
		return "" + this.getConceptId();
	}
	@Override
	public String getDisplayString() {
		if (getName() == null) {
			return toString();
		} else {
			return getName().getName();
		}
	}
	public Set<Locale> getAllConceptNameLocales() {
		if (getNames().isEmpty()) {
			if (log.isDebugEnabled()) {
				log.debug("The Concept with id: " + conceptId + " has no names");
			}
			return null;
		}
		Set<Locale> locales = new HashSet<>();
		for (ConceptName cn : getNames()) {
			locales.add(cn.getLocale());
		}
		return locales;
	}
	@Override
	public Integer getId() {
		return getConceptId();
	}
	@Override
	public void setId(Integer id) {
		setConceptId(id);
	}
	private List<ConceptSet> getSortedConceptSets() {
		List<ConceptSet> cs = new ArrayList<>();
		if (conceptSets != null) {
			cs.addAll(conceptSets);
			Collections.sort(cs);
		}
		return cs;
	}
	public List<Concept> getSetMembers() {
		List<Concept> conceptMembers = new ArrayList<>();
		Collection<ConceptSet> sortedConceptSet = getSortedConceptSets();
		for (ConceptSet conceptSet : sortedConceptSet) {
			conceptMembers.add(conceptSet.getConcept());
		}
		return Collections.unmodifiableList(conceptMembers);
	}
	public List<Concept> getSetMembers(boolean includeRetired) {
		if (includeRetired) {
			return getSetMembers();
		} else {
			return getSetMembers().stream()
				.filter(a -> !a.getRetired())
				.collect(Collectors.toList());
		}
	}
	public void addSetMember(Concept setMember) {
		addSetMember(setMember, -1);
	}
	public void addSetMember(Concept setMember, int index) {
		List<ConceptSet> sortedConceptSets = getSortedConceptSets();
		int setsSize = sortedConceptSets.size();
		double weight = 990.0;
		for (ConceptSet conceptSet : sortedConceptSets) {
			weight += 10.0;
			conceptSet.setSortWeight(weight);
		}
		if (sortedConceptSets.isEmpty()) {
			weight = 1000.0;
		} else if (index == -1 || index >= setsSize) {
			weight = sortedConceptSets.get(setsSize - 1).getSortWeight() + 10.0;
		} else if (index == 0) {
			weight = sortedConceptSets.get(0).getSortWeight() - 10.0;
		} else {
			double prevSortWeight = sortedConceptSets.get(index - 1).getSortWeight();
			double nextSortWeight = sortedConceptSets.get(index).getSortWeight();
			weight = (prevSortWeight + nextSortWeight) / 2;
		}
		ConceptSet conceptSet = new ConceptSet(setMember, weight);
		conceptSet.setConceptSet(this);
		conceptSets.add(conceptSet);
	}
	@Override
	public Set<ConceptAttribute> getAttributes() {
		if (attributes == null) {
			attributes = new LinkedHashSet<>();
		}
		return attributes;
	}
	@Override
	public Collection<ConceptAttribute> getActiveAttributes() {
		return getAttributes().stream()
				.filter(attr -> !attr.getVoided())
				.collect(Collectors.toList());
	}
	@Override
	public List<ConceptAttribute> getActiveAttributes(CustomValueDescriptor ofType) {
		return getAttributes().stream()
				.filter(attr -> attr.getAttributeType().equals(ofType) && !attr.getVoided())
				.collect(Collectors.toList());
	}
	public void setAttributes(Set<ConceptAttribute> attributes) {
		this.attributes = attributes;
	}
	@Override
	public void addAttribute(ConceptAttribute attribute) {
		getAttributes().add(attribute);
		attribute.setOwner(this);
	}
}
package org.openmrs;
import java.util.Date;
public abstract class BaseChangeableOpenmrsData extends BaseOpenmrsData {}
package org.openmrs.api.db;
import org.openmrs.ProgramAttributeType;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import org.openmrs.Cohort;
import org.openmrs.Concept;
import org.openmrs.ConceptStateConversion;
import org.openmrs.Patient;
import org.openmrs.PatientProgram;
import org.openmrs.PatientProgramAttribute;
import org.openmrs.PatientState;
import org.openmrs.Program;
import org.openmrs.ProgramWorkflow;
import org.openmrs.ProgramWorkflowState;
public interface ProgramWorkflowDAO {
	public Program saveProgram(Program program) throws DAOException;
	public Program getProgram(Integer programId) throws DAOException;
	public List<Program> getAllPrograms(boolean includeRetired) throws DAOException;
	public List<Program> findPrograms(String nameFragment) throws DAOException;
	public void deleteProgram(Program program) throws DAOException;
	public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException;
	public PatientProgram getPatientProgram(Integer id);
	public List<PatientProgram> getPatientPrograms(Cohort cohort, Collection<Program> programs);
	public List<PatientProgram> getPatientPrograms(Patient patient, Program program, Date minEnrollmentDate,
	        Date maxEnrollmentDate, Date minCompletionDate, Date maxCompletionDate, boolean includeVoided)
	        throws DAOException;
	public void deletePatientProgram(PatientProgram patientProgram) throws DAOException;
	public ConceptStateConversion saveConceptStateConversion(ConceptStateConversion csc) throws DAOException;
	public List<ConceptStateConversion> getAllConceptStateConversions() throws DAOException;
	public ConceptStateConversion getConceptStateConversion(Integer id);
	public void deleteConceptStateConversion(ConceptStateConversion csc);
	public ConceptStateConversion getConceptStateConversion(ProgramWorkflow workflow, Concept trigger);
	public ConceptStateConversion getConceptStateConversionByUuid(String uuid);
	public PatientProgram getPatientProgramByUuid(String uuid);
	public Program getProgramByUuid(String uuid);
	public List<Program> getProgramsByName(String name, boolean includeRetired);
	public ProgramWorkflowState getState(Integer stateId);
	public ProgramWorkflowState getStateByUuid(String uuid);
	public PatientState getPatientStateByUuid(String uuid);
	public ProgramWorkflow getWorkflow(Integer workflowId);
	public ProgramWorkflow getWorkflowByUuid(String uuid);
	public List<Program> getProgramsByConcept(Concept concept);
	public List<ProgramWorkflow> getProgramWorkflowsByConcept(Concept concept);
	public List<ProgramWorkflowState> getProgramWorkflowStatesByConcept(Concept concept);
        public List<ProgramAttributeType> getAllProgramAttributeTypes();
        public ProgramAttributeType getProgramAttributeType(Integer var1);
        public ProgramAttributeType getProgramAttributeTypeByUuid(String var1);
        public ProgramAttributeType saveProgramAttributeType(ProgramAttributeType var1);
        public PatientProgramAttribute getPatientProgramAttributeByUuid(String var1);
        public void purgeProgramAttributeType(ProgramAttributeType var1);
        public List<PatientProgram> getPatientProgramByAttributeNameAndValue(String attributeName, String attributeValue);
        public Map<Object, Object> getPatientProgramAttributeByAttributeName(List<Integer> patientIds, String attributeName);
}
package org.openmrs;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.TreeSet;
import org.hibernate.envers.Audited;
import org.openmrs.util.NaturalStrings;
@Audited
public class ProgramWorkflow extends BaseChangeableOpenmrsMetadata {
	private static final long serialVersionUID = 1L;
	private Integer programWorkflowId;
	private Program program;
	private Concept concept;
	private Set<ProgramWorkflowState> states = new HashSet<>();
	public ProgramWorkflow() {
	}
	public ProgramWorkflow(Integer programWorkflowId) {
		setProgramWorkflowId(programWorkflowId);
	}
	public void addState(ProgramWorkflowState state) {
		state.setProgramWorkflow(this);
		getStates().add(state);
	}
	public void removeState(ProgramWorkflowState state) {
		if (getStates().contains(state)) {
			getStates().remove(state);
			state.setProgramWorkflow(null);
		}
	}
	public void retireState(ProgramWorkflowState state) {
		state.setRetired(true);
	}
	public ProgramWorkflowState getState(Integer programWorkflowStateId) {
		for (ProgramWorkflowState s : getStates()) {
			if (s.getProgramWorkflowStateId().equals(programWorkflowStateId)) {
				return s;
			}
		}
		return null;
	}
	public ProgramWorkflowState getState(Concept concept) {
		for (ProgramWorkflowState s : getStates()) {
			if (s.getConcept().equals(concept)) {
				return s;
			}
		}
		return null;
	}
	public ProgramWorkflowState getState(String name) {
		for (ProgramWorkflowState s : getStates()) {
			if (s.getConcept().isNamed(name)) {
				return s;
			}
		}
		return null;
	}
	public ProgramWorkflowState getStateByName(String name) {
		for (ProgramWorkflowState s : getStates()) {
			if (s.getConcept().isNamed(name)) {
				return s;
			}
		}
		return null;
	}
	public Set<ProgramWorkflowState> getStates(boolean includeRetired) {
		Set<ProgramWorkflowState> ret = new HashSet<>();
		for (ProgramWorkflowState s : getStates()) {
			if (includeRetired || !s.getRetired()) {
				ret.add(s);
			}
		}
		return ret;
	}
	public Set<ProgramWorkflowState> getSortedStates() {
		final Comparator<String> naturalComparator = NaturalStrings.getNaturalComparator();
		Comparator<ProgramWorkflowState> stateComparator = (o1, o2) -> naturalComparator.compare(o1.getConcept().getName().getName(), o2.getConcept().getName().getName());
		Set<ProgramWorkflowState> sorted = new TreeSet<>(stateComparator);
		if (getStates() != null) {
			sorted.addAll(getStates());
		}
		return sorted;
	}
	public List<ProgramWorkflowState> getPossibleNextStates(PatientProgram patientProgram) {
		List<ProgramWorkflowState> ret = new ArrayList<>();
		PatientState currentState = patientProgram.getCurrentState(this);
		for (ProgramWorkflowState st : getSortedStates()) {
			if (isLegalTransition(currentState == null ? null : currentState.getState(), st)) {
				ret.add(st);
			}
		}
		return ret;
	}
	public boolean isLegalTransition(ProgramWorkflowState fromState, ProgramWorkflowState toState) {
		if (fromState == null) {
			return toState.getInitial();
		}
		return !fromState.equals(toState);
	}
	@Override
	public String toString() {
		return "ProgramWorkflow(id=" + getProgramWorkflowId() + ")";
	}
	public Set<ProgramWorkflowState> getStates() {
		return states;
	}
	public void setStates(Set<ProgramWorkflowState> states) {
		this.states = states;
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		this.concept = concept;
	}
	public Program getProgram() {
		return program;
	}
	public void setProgram(Program program) {
		this.program = program;
	}
	public Integer getProgramWorkflowId() {
		return programWorkflowId;
	}
	public void setProgramWorkflowId(Integer programWorkflowId) {
		this.programWorkflowId = programWorkflowId;
	}
	@Override
	public Integer getId() {
		return getProgramWorkflowId();
	}
	@Override
	public void setId(Integer id) {
		setProgramWorkflowId(id);
	}
	public int getNonRetiredStateCount() {
		return getStates(false).size();
	}
}
package org.openmrs.validator;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import org.openmrs.PatientProgram;
import org.openmrs.PatientState;
import org.openmrs.ProgramWorkflow;
import org.openmrs.annotation.Handler;
import org.openmrs.api.context.Context;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;
@Handler(supports = { PatientProgram.class }, order = 50)
public class PatientProgramValidator implements Validator {
	private static final Logger log = LoggerFactory.getLogger(PatientProgramValidator.class);
	@Override
	public boolean supports(Class<?> c) {
		return PatientProgram.class.isAssignableFrom(c);
	}
	@Override
	public void validate(Object obj, Errors errors) {
		log.debug("{}.validate...", this.getClass().getName());
		if (obj == null) {
			throw new IllegalArgumentException("The parameter obj should not be null");
		}
		MessageSourceService mss = Context.getMessageSourceService();
		PatientProgram patientProgram = (PatientProgram) obj;
		ValidationUtils.rejectIfEmpty(errors, "patient", "error.required",
		    new Object[] { mss.getMessage("general.patient") });
		ValidationUtils.rejectIfEmpty(errors, "program", "error.required",
		    new Object[] { mss.getMessage("Program.program") });
		if (errors.hasErrors()) {
			return;
		}
		ValidationUtils.rejectIfEmpty(errors, "dateEnrolled", "error.patientProgram.enrolledDateEmpty");
		Date today = new Date();
		if (patientProgram.getDateEnrolled() != null && today.before(patientProgram.getDateEnrolled())) {
			errors.rejectValue("dateEnrolled", "error.patientProgram.enrolledDateDateCannotBeInFuture");
		}
		if (patientProgram.getDateCompleted() != null && today.before(patientProgram.getDateCompleted())) {
			errors.rejectValue("dateCompleted", "error.patientProgram.completionDateCannotBeInFuture");
		}
		if (patientProgram.getDateEnrolled() != null
		        && OpenmrsUtil.compareWithNullAsLatest(patientProgram.getDateCompleted(), patientProgram.getDateEnrolled()) < 0) {
			errors.rejectValue("dateCompleted", "error.patientProgram.enrolledDateShouldBeBeforecompletionDate");
		}
		Set<ProgramWorkflow> workFlows = patientProgram.getProgram().getWorkflows();
		for (ProgramWorkflow workFlow : workFlows) {
			Set<PatientState> patientStates = patientProgram.getStates();
			if (patientStates != null) {
				Set<String> statesAndStartDates = new HashSet<>();
				PatientState latestState = null;
				boolean foundCurrentPatientState = false;
				boolean foundStateWithNullStartDate = false;
				for (PatientState patientState : patientStates) {
					if (patientState.getVoided()) {
						continue;
					}
					String missingRequiredFieldCode = null;
					if (patientState.getStartDate() == null) {
						if (foundStateWithNullStartDate) {
							missingRequiredFieldCode = "general.dateStart";
						} else {
							foundStateWithNullStartDate = true;
						}
					} else if (patientState.getState() == null) {
						missingRequiredFieldCode = "State.state";
					}
					if (missingRequiredFieldCode != null) {
						errors.rejectValue("states", "PatientState.error.requiredField", new Object[] { mss
						        .getMessage(missingRequiredFieldCode) }, null);
						return;
					}
					boolean isValidPatientState = false;
					for (ProgramWorkflow wf : patientProgram.getProgram().getAllWorkflows()) {
						if (wf.getStates().contains(patientState.getState())) {
							isValidPatientState = true;
							break;
						}
					}
					if (!isValidPatientState) {
						errors.rejectValue("states", "PatientState.error.invalidPatientState",
						    new Object[] { patientState }, null);
						return;
					}
					if (!patientState.getState().getProgramWorkflow().equals(workFlow)) {
						continue;
					}
					if (OpenmrsUtil.compareWithNullAsLatest(patientState.getEndDate(), patientState.getStartDate()) < 0) {
						errors.rejectValue("states", "PatientState.error.endDateCannotBeBeforeStartDate");
						return;
					} else if (statesAndStartDates.contains(patientState.getState().getUuid() + ""
					        + patientState.getStartDate())) {
						errors.rejectValue("states", "PatientState.error.duplicatePatientStates");
						return;
					}
					if (!foundCurrentPatientState && patientState.getEndDate() == null) {
						foundCurrentPatientState = true;
					} else if (foundCurrentPatientState && patientState.getEndDate() == null) {
						errors.rejectValue("states", "PatientProgram.error.cannotBeInMultipleStates");
						return;
					}
					if (latestState == null) {
						latestState = patientState;
					} else {
						if (patientState.compareTo(latestState) > 0) {
							if (latestState.getEndDate() == null) {
								errors.rejectValue("states", "PatientProgram.error.cannotBeInMultipleStates");
								return;
							} else if (OpenmrsUtil.compareWithNullAsEarliest(patientState.getStartDate(), latestState
							        .getEndDate()) < 0) {
								errors.rejectValue("states", "PatientProgram.error.foundOverlappingStates", new Object[] {
								        patientState.getStartDate(), latestState.getEndDate() }, null);
								return;
							}
							latestState = patientState;
						} else if (patientState.compareTo(latestState) < 0) {
							if (patientState.getEndDate() == null) {
								errors.rejectValue("states", "PatientProgram.error.cannotBeInMultipleStates");
								return;
							} else if (OpenmrsUtil.compareWithNullAsEarliest(latestState.getStartDate(), patientState
							        .getEndDate()) < 0) {
								errors.rejectValue("states", "PatientProgram.error.foundOverlappingStates");
								return;
							}
						}
					}
					statesAndStartDates.add(patientState.getState().getUuid() + "" + patientState.getStartDate());
				}
			}
		}
		ValidateUtil.validateFieldLengths(errors, obj.getClass(), "voidReason");
	}
}
package org.openmrs;
import java.util.Date;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.Parameter;
import org.hibernate.envers.Audited;
import org.openmrs.util.OpenmrsUtil;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
@Entity
@Table(name = "patient_state")
@Audited
public class PatientState extends BaseFormRecordableOpenmrsData implements java.io.Serializable, Comparable<PatientState> {
	public static final long serialVersionUID = 0L;
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "patient_state_id_seq")
	@GenericGenerator(
		name = "patient_state_id_seq",
		strategy = "native",
		parameters = @Parameter(name = "sequence", value = "patient_state_patient_state_id_seq")
	)
	@Column(name = "patient_state_id")
	private Integer patientStateId;
	@ManyToOne
	@JoinColumn(name = "patient_program_id", nullable = false)
	private PatientProgram patientProgram;
	@ManyToOne
	@JoinColumn(name = "state", nullable = false)
	private ProgramWorkflowState state;
	@Column(name = "start_date", length = 19)
	private Date startDate;
	@Column(name = "end_date", length = 19)
	private Date endDate;
	@ManyToOne
	@JoinColumn(name = "encounter_id")
	private Encounter encounter;
	public PatientState() {
	}
	public PatientState(Integer patientStateId) {
		setPatientStateId(patientStateId);
	}
	public PatientState copy() {
		return copyHelper(new PatientState());
	}
	protected PatientState copyHelper(PatientState target) {
		target.setPatientProgram(this.getPatientProgram());
		target.setState(this.getState());
		target.setStartDate(this.getStartDate());
		target.setEndDate(this.getEndDate());
		target.setEncounter(this.getEncounter());
		target.setCreator(this.getCreator());
		target.setDateCreated(this.getDateCreated());
		target.setChangedBy(this.getChangedBy());
		target.setDateChanged(this.getDateChanged());
		target.setVoided(this.getVoided());
		target.setVoidedBy(this.getVoidedBy());
		target.setDateVoided(this.getDateVoided());
		target.setVoidReason(this.getVoidReason());
		return target;
	}
	public boolean getActive(Date onDate) {
		if (onDate == null) {
			onDate = new Date();
		}
		return !getVoided() && (OpenmrsUtil.compareWithNullAsEarliest(startDate, onDate) <= 0)
		        && (OpenmrsUtil.compareWithNullAsLatest(endDate, onDate) > 0);
	}
	public boolean getActive() {
		return getActive(null);
	}
	@Override
	public String toString() {
		return "id=" + getPatientStateId() + ", patientProgram=" + getPatientProgram() + ", state=" + getState()
		        + ", startDate=" + getStartDate() + ", endDate=" + getEndDate() + ", encounter=" + getEncounter() + ", dateCreated=" + getDateCreated()
		        + ", dateChanged=" + getDateChanged();
	}
	public PatientProgram getPatientProgram() {
		return patientProgram;
	}
	public void setPatientProgram(PatientProgram patientProgram) {
		this.patientProgram = patientProgram;
	}
	public Integer getPatientStateId() {
		return patientStateId;
	}
	public void setPatientStateId(Integer patientStatusId) {
		this.patientStateId = patientStatusId;
	}
	public ProgramWorkflowState getState() {
		return state;
	}
	public void setState(ProgramWorkflowState state) {
		this.state = state;
	}
	public Date getEndDate() {
		return endDate;
	}
	public void setEndDate(Date endDate) {
		this.endDate = endDate;
	}
	public Date getStartDate() {
		return startDate;
	}
	public void setStartDate(Date startDate) {
		this.startDate = startDate;
	}
	public Encounter getEncounter() {
		return encounter;
	}
	public void setEncounter(Encounter encounter) {
		this.encounter = encounter;
	}
	@Override
	public Integer getId() {
		return getPatientStateId();
	}
	@Override
	public void setId(Integer id) {
		setPatientStateId(id);
	}
	@SuppressWarnings("squid:S1210")
	@Override
	public int compareTo(PatientState o) {
		int result = OpenmrsUtil.compareWithNullAsEarliest(getStartDate(), o.getStartDate());
		if (result == 0) {
			result = OpenmrsUtil.compareWithNullAsLatest(getEndDate(), o.getEndDate());
		}
		if (result == 0) {
			result = OpenmrsUtil.compareWithNullAsGreatest(getUuid(), o.getUuid());
		}
		return result;
	}
}
package org.openmrs.api.db;
import java.util.List;
import org.openmrs.Allergies;
import org.openmrs.Allergy;
import org.openmrs.Location;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientProgram;
import org.openmrs.api.PatientService;
public interface PatientDAO {
	public Patient savePatient(Patient patient) throws DAOException;
	public Patient getPatient(Integer patientId) throws DAOException;
	public void deletePatient(Patient patient) throws DAOException;
	public List<Patient> getAllPatients(boolean includeVoided) throws DAOException;
	public List<Patient> getPatients(String query, Integer start, Integer length) throws DAOException;
	public List<Patient> getPatients(String query, boolean includeVoided, Integer start, Integer length) throws DAOException;
	public List<Patient> getPatients(String name, List<PatientIdentifierType> identifierTypes,
		boolean matchIdentifierExactly, Integer start, Integer length) throws DAOException;
	public List<PatientIdentifier> getPatientIdentifiers(String identifier,
	        List<PatientIdentifierType> patientIdentifierTypes, List<Location> locations, List<Patient> patients,
	        Boolean isPreferred) throws DAOException;
	public PatientIdentifierType savePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws DAOException;
	public List<PatientIdentifierType> getAllPatientIdentifierTypes(boolean includeRetired) throws DAOException;
	public List<PatientIdentifierType> getPatientIdentifierTypes(String name, String format, Boolean required,
	        Boolean hasCheckDigit) throws DAOException;
	public PatientIdentifierType getPatientIdentifierType(Integer patientIdentifierTypeId) throws DAOException;
	public void deletePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws DAOException;
	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws DAOException;
	public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier);
	public Patient getPatientByUuid(String uuid);
	public PatientIdentifier getPatientIdentifierByUuid(String uuid);
	public PatientIdentifierType getPatientIdentifierTypeByUuid(String uuid);
	public PatientIdentifier getPatientIdentifier(Integer patientIdentifierId) throws DAOException;
	public PatientIdentifier savePatientIdentifier(PatientIdentifier patientIdentifier);
	public void deletePatientIdentifier(PatientIdentifier patientIdentifier) throws DAOException;
	public Long getCountOfPatients(String query);
	public Long getCountOfPatients(String query, boolean includeVoided);
	public List<Allergy> getAllergies(Patient patient);
	public String getAllergyStatus(Patient patient);
	public Allergies saveAllergies(Patient patient, Allergies allergies);
	public Allergy getAllergy(Integer allergyId);
	public Allergy getAllergyByUuid(String uuid);
	public Allergy saveAllergy(Allergy allergy);
	public List getPatientIdentifierByProgram(PatientProgram patientProgram);
}
package org.openmrs;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Comparator;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.Analyzer;
import org.hibernate.search.annotations.Boost;
import org.hibernate.search.annotations.DocumentId;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.Fields;
import org.hibernate.search.annotations.Indexed;
import org.hibernate.search.annotations.IndexedEmbedded;
import org.hibernate.search.annotations.SortableField;
import org.openmrs.api.db.hibernate.search.LuceneAnalyzers;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@Indexed
@Audited
public class PatientIdentifier extends BaseChangeableOpenmrsData implements java.io.Serializable, Cloneable, Comparable<PatientIdentifier> {
	public static final long serialVersionUID = 1123121L;
	private static final Logger log = LoggerFactory.getLogger(PatientIdentifier.class);
	@DocumentId
	private Integer patientIdentifierId;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private Patient patient;
	@Fields({
			@Field(name = "identifierPhrase", analyzer = @Analyzer(definition = LuceneAnalyzers.PHRASE_ANALYZER), boost = @Boost(8f)),
			@Field(name = "identifierExact", analyzer = @Analyzer(definition = LuceneAnalyzers.EXACT_ANALYZER), boost = @Boost(4f)),
			@Field(name = "identifierStart", analyzer = @Analyzer(definition = LuceneAnalyzers.START_ANALYZER), boost = @Boost(2f)),
			@Field(name = "identifierAnywhere", analyzer = @Analyzer(definition = LuceneAnalyzers.ANYWHERE_ANALYZER))
	})
	@SortableField(forField = "identifierExact")
	private String identifier;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private PatientIdentifierType identifierType;
	private Location location;
	private PatientProgram patientProgram;
	@Field
	private Boolean preferred = false;
	public PatientIdentifier() {
	}
	public PatientIdentifier(String identifier, PatientIdentifierType type, Location location) {
		this.identifier = identifier;
		this.identifierType = type;
		this.location = location;
	}
	public boolean equalsContent(PatientIdentifier otherIdentifier) {
		boolean returnValue = true;
		String[] methods = { "getIdentifier", "getIdentifierType", "getLocation" };
		Class<? extends PatientIdentifier> identifierClass = this.getClass();
		for (String methodName : methods) {
			try {
				Method method = identifierClass.getMethod(methodName);
				Object thisValue = method.invoke(this);
				Object otherValue = method.invoke(otherIdentifier);
				if (otherValue != null) {
					returnValue &= otherValue.equals(thisValue);
				}
			}
			catch (NoSuchMethodException e) {
				log.warn("No such method for comparison " + methodName, e);
			}
			catch (IllegalAccessException | InvocationTargetException e) {
				log.error("Error while comparing identifiers", e);
			}
		}
		return returnValue;
	}
	public String getIdentifier() {
		return identifier;
	}
	public void setIdentifier(String identifier) {
		this.identifier = identifier;
	}
	public PatientIdentifierType getIdentifierType() {
		return identifierType;
	}
	public void setIdentifierType(PatientIdentifierType identifierType) {
		this.identifierType = identifierType;
	}
	public Location getLocation() {
		return location;
	}
	public void setLocation(Location location) {
		this.location = location;
	}
	public Patient getPatient() {
		return patient;
	}
	public void setPatient(Patient patient) {
		this.patient = patient;
	}
	@Override
	public String toString() {
		return this.identifier;
	}
	public Boolean getPreferred() {
		return preferred;
	}
	public void setPreferred(Boolean preferred) {
		this.preferred = preferred;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isPreferred() {
		return getPreferred();
	}
	@Deprecated
	@Override
	@SuppressWarnings("squid:S1210")
	public int compareTo(PatientIdentifier other) {
		DefaultComparator piDefaultComparator = new DefaultComparator();
		return piDefaultComparator.compare(this, other);
	}
	@Override
	public Integer getId() {
		return getPatientIdentifierId();
	}
	@Override
	public void setId(Integer id) {
		setPatientIdentifierId(id);
	}
	public Integer getPatientIdentifierId() {
		return patientIdentifierId;
	}
	public void setPatientIdentifierId(Integer patientIdentifierId) {
		this.patientIdentifierId = patientIdentifierId;
	}
	@Override
	public Object clone() {
		try {
			return super.clone();
		}
		catch (CloneNotSupportedException e) {
			throw new InternalError("PatientIdentifier should be cloneable");
		}
	}
	public static class DefaultComparator implements Comparator<PatientIdentifier>, Serializable {
		private static final long serialVersionUID = 1L;
		@Override
		public int compare(PatientIdentifier pi1, PatientIdentifier pi2) {
			int retValue = 0;
			if (pi2 != null) {
				retValue = pi1.getVoided().compareTo(pi2.getVoided());
				if (retValue == 0) {
					retValue = pi1.getPreferred().compareTo(pi2.getPreferred());
				}
				if (retValue == 0) {
					retValue = OpenmrsUtil.compareWithNullAsLatest(pi1.getDateCreated(), pi2.getDateCreated());
				}
				if (pi1.getIdentifierType() == null && pi2.getIdentifierType() == null) {
					return 0;
				}
				if (pi1.getIdentifierType() == null && pi2.getIdentifierType() != null) {
					retValue = 1;
				}
				if (pi1.getIdentifierType() == null && pi2.getIdentifierType() != null) {
					retValue = -1;
				}
				if (retValue == 0) {
					retValue = OpenmrsUtil.compareWithNullAsGreatest(pi1.getIdentifierType().getPatientIdentifierTypeId(),
					    pi2.getIdentifierType().getPatientIdentifierTypeId());
				}
				if (retValue == 0) {
					retValue = OpenmrsUtil.compareWithNullAsGreatest(pi1.getIdentifier(), pi2.getIdentifier());
				}
				if (retValue == 0 && !pi1.equalsContent(pi2)) {
					retValue = 1;
				}
			}
			return retValue;
		}
	}
	public PatientProgram getPatientProgram() {
		return patientProgram;
	}
	public void setPatientProgram(PatientProgram patientProgram) {
		this.patientProgram = patientProgram;
	}
}
package org.openmrs.customdatatype;
import java.util.Collection;
import java.util.List;
import org.openmrs.attribute.Attribute;
@SuppressWarnings("rawtypes")
public interface Customizable<A extends Attribute> {
	Collection<A> getAttributes();
	Collection<A> getActiveAttributes();
	List<A> getActiveAttributes(CustomValueDescriptor ofType);
	void addAttribute(A attribute);
}
package org.openmrs.api;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import org.openmrs.Allergies;
import org.openmrs.Allergy;
import org.openmrs.Concept;
import org.openmrs.Location;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientProgram;
import org.openmrs.annotation.Authorized;
import org.openmrs.api.db.PatientDAO;
import org.openmrs.comparator.PatientIdentifierTypeDefaultComparator;
import org.openmrs.patient.IdentifierValidator;
import org.openmrs.person.PersonMergeLogData;
import org.openmrs.serialization.SerializationException;
import org.openmrs.util.PrivilegeConstants;
public interface PatientService extends OpenmrsService {
	public void setPatientDAO(PatientDAO dao);
	@Authorized( { PrivilegeConstants.ADD_PATIENTS, PrivilegeConstants.EDIT_PATIENTS })
	public Patient savePatient(Patient patient) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public Patient getPatient(Integer patientId) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	Patient getPatientOrPromotePerson(Integer patientOrPersonId) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public Patient getPatientByUuid(String uuid) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENT_IDENTIFIERS })
	public PatientIdentifier getPatientIdentifierByUuid(String uuid) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public List<Patient> getAllPatients() throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public List<Patient> getAllPatients(boolean includeVoided) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly) throws APIException;
	@Authorized( { PrivilegeConstants.DELETE_PATIENTS })
	public Patient voidPatient(Patient patient, String reason) throws APIException;
	@Authorized( { PrivilegeConstants.DELETE_PATIENTS })
	public Patient unvoidPatient(Patient patient) throws APIException;
	@Authorized( { PrivilegeConstants.PURGE_PATIENTS })
	public void purgePatient(Patient patient) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENT_IDENTIFIERS })
	public List<PatientIdentifier> getPatientIdentifiers(String identifier,
	        List<PatientIdentifierType> patientIdentifierTypes, List<Location> locations, List<Patient> patients,
	        Boolean isPreferred) throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_IDENTIFIER_TYPES })
	public PatientIdentifierType savePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException;
	@Authorized( { PrivilegeConstants.GET_IDENTIFIER_TYPES })
	public List<PatientIdentifierType> getAllPatientIdentifierTypes() throws APIException;
	@Authorized( { PrivilegeConstants.GET_IDENTIFIER_TYPES })
	public List<PatientIdentifierType> getAllPatientIdentifierTypes(boolean includeRetired) throws APIException;
	@Authorized( { PrivilegeConstants.GET_IDENTIFIER_TYPES })
	public List<PatientIdentifierType> getPatientIdentifierTypes(String name, String format, Boolean required,
	        Boolean hasCheckDigit) throws APIException;
	@Authorized( { PrivilegeConstants.GET_IDENTIFIER_TYPES })
	public PatientIdentifierType getPatientIdentifierType(Integer patientIdentifierTypeId) throws APIException;
	@Authorized( { PrivilegeConstants.GET_IDENTIFIER_TYPES })
	public PatientIdentifierType getPatientIdentifierTypeByUuid(String uuid) throws APIException;
	@Authorized( { PrivilegeConstants.GET_IDENTIFIER_TYPES })
	public PatientIdentifierType getPatientIdentifierTypeByName(String name) throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_IDENTIFIER_TYPES })
	public PatientIdentifierType retirePatientIdentifierType(PatientIdentifierType patientIdentifierType, String reason)
	        throws APIException;
	@Authorized( { PrivilegeConstants.MANAGE_IDENTIFIER_TYPES })
	public PatientIdentifierType unretirePatientIdentifierType(PatientIdentifierType patientIdentifierType)
	        throws APIException;
	@Authorized( { PrivilegeConstants.PURGE_IDENTIFIER_TYPES })
	public void purgePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENT_IDENTIFIERS })
	public void checkPatientIdentifiers(Patient patient) throws PatientIdentifierException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public List<Patient> getPatients(String query) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public List<Patient> getPatients(String query, Integer start, Integer length) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public List<Patient> getPatients(String query, boolean includeVoided, Integer start, Integer length) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public Patient getPatientByExample(Patient patientToMatch) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws APIException;
	@Authorized( { PrivilegeConstants.EDIT_PATIENTS })
	public void mergePatients(Patient preferred, Patient notPreferred) throws APIException, SerializationException;
	public void mergePatients(Patient preferred, List<Patient> notPreferred) throws APIException, SerializationException;
	@Authorized( { PrivilegeConstants.EDIT_PATIENTS })
	public void processDeath(Patient patient, Date dateDied, Concept causeOfDeath, String otherReason) throws APIException;
	@Authorized(value = { PrivilegeConstants.GET_PATIENTS, PrivilegeConstants.EDIT_OBS }, requireAll = true)
	public void saveCauseOfDeathObs(Patient patient, Date dateDied, Concept causeOfDeath, String otherReason)
	        throws APIException;
	public IdentifierValidator getIdentifierValidator(Class<IdentifierValidator> clazz);
	public IdentifierValidator getIdentifierValidator(String pivClassName);
	public IdentifierValidator getDefaultIdentifierValidator();
	public Collection<IdentifierValidator> getAllIdentifierValidators();
	@Authorized(PrivilegeConstants.GET_PATIENTS)
	public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier);
	@Authorized( { PrivilegeConstants.GET_PATIENT_IDENTIFIERS })
	public PatientIdentifier getPatientIdentifier(Integer patientIdentifierId) throws APIException;
	@Authorized( { PrivilegeConstants.DELETE_PATIENT_IDENTIFIERS })
	public PatientIdentifier voidPatientIdentifier(PatientIdentifier patientIdentifier, String reason) throws APIException;
	@Authorized( { PrivilegeConstants.ADD_PATIENT_IDENTIFIERS, PrivilegeConstants.EDIT_PATIENT_IDENTIFIERS })
	public PatientIdentifier savePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException;
	@Authorized( { PrivilegeConstants.PURGE_PATIENT_IDENTIFIERS })
	public void purgePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException;
	Allergies getAllergies(Patient patient);
	Allergies setAllergies(Patient patient, Allergies allergies);
	@Authorized( { PrivilegeConstants.GET_ALLERGIES })
	public Allergy getAllergy(Integer allergyListId) throws APIException;
	@Authorized( { PrivilegeConstants.GET_ALLERGIES })
	public Allergy getAllergyByUuid(String uuid) throws APIException;
	@Authorized( { PrivilegeConstants.ADD_ALLERGIES, PrivilegeConstants.EDIT_ALLERGIES })
	public void saveAllergy(Allergy allergy) throws APIException;
	@Authorized( { PrivilegeConstants.EDIT_ALLERGIES })
	public void removeAllergy(Allergy allergy, String reason) throws APIException;
	@Authorized( { PrivilegeConstants.DELETE_ALLERGIES })
	public void voidAllergy(Allergy allergy, String reason) throws APIException;
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public Integer getCountOfPatients(String query);
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public Integer getCountOfPatients(String query, boolean includeVoided);
	@Authorized( { PrivilegeConstants.GET_PATIENTS })
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly, Integer start, Integer length) throws APIException;
	public void checkIfPatientIdentifierTypesAreLocked() throws PatientIdentifierTypeLockedException;
	@Authorized({PrivilegeConstants.GET_PATIENT_IDENTIFIERS})
	public List<PatientIdentifier> getPatientIdentifiersByPatientProgram(PatientProgram patientProgram);
}
package org.openmrs.migration;
import java.io.IOException;
import java.io.StringReader;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.openmrs.Location;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientProgram;
import org.openmrs.PatientState;
import org.openmrs.Person;
import org.openmrs.PersonName;
import org.openmrs.Program;
import org.openmrs.ProgramWorkflow;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.Relationship;
import org.openmrs.RelationshipType;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.LocationService;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.UserService;
import org.openmrs.api.context.Context;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
@Deprecated
public class MigrationHelper {
	private MigrationHelper() {
	}
	private static final String DATE_TIME_PATTERN = "yyyy-MM-dd HH:mm:ss";
	private static final Logger log = LoggerFactory.getLogger(MigrationHelper.class);
	static DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
	@Deprecated
	public static Date parseDate(String s) throws ParseException {
		if (s == null || s.length() == 0) {
			return null;
		} else {
			if (s.length() == 10) {
				s += " 00:00:00";
			}
			DateFormat df = new SimpleDateFormat(DATE_TIME_PATTERN);
			return df.parse(s);
		}
	}
	@Deprecated
	public static Document parseXml(String xml) throws ParserConfigurationException {
		DocumentBuilder builder = factory.newDocumentBuilder();
		try {
			builder.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
			return builder.parse(new InputSource(new StringReader(xml)));
		}
		catch (IOException | SAXException ex) {
			return null;
		}
	}
	private static void findNodesNamed(Node node, String lookForName, Collection<Node> ret) {
		if (node.getNodeName().equals(lookForName)) {
			ret.add(node);
		} else {
			NodeList list = node.getChildNodes();
			for (int i = 0; i < list.getLength(); ++i) {
				findNodesNamed(list.item(i), lookForName, ret);
			}
		}
	}
	@Deprecated
	public static int importUsers(Document document) throws ParseException {
		int ret = 0;
		Random rand = new Random();
		UserService us = Context.getUserService();
		List<Node> toAdd = new ArrayList<>();
		findNodesNamed(document, "user", toAdd);
		for (Node node : toAdd) {
			Element e = (Element) node;
			String username = e.getAttribute("username");
			if (username == null || username.length() == 0) {
				throw new IllegalArgumentException("each <user /> element must define a user_name attribute");
			}
			if (us.getUserByUsername(username) != null) {
				continue;
			}
			User user = new User();
			user.setPerson(new Person());
			PersonName pn = new PersonName(e.getAttribute("first_name"), "", e.getAttribute("last_name"));
			user.addName(pn);
			user.setUsername(username);
			user.setDateCreated(parseDate(e.getAttribute("date_created")));
			user.setDateChanged(parseDate(e.getAttribute("date_changed")));
			String pass;
			{
				int length = rand.nextInt(4) + 8;
				char[] password = new char[length];
				for (int x = 0; x < length; x++) {
					int randDecimalAsciiVal = rand.nextInt(93) + 33;
					password[x] = (char) randDecimalAsciiVal;
				}
				pass = new String(password);
			}
			us.createUser(user, pass);
			++ret;
		}
		return ret;
	}
	@Deprecated
	public static int importLocations(Document document) {
		int ret = 0;
		LocationService ls = Context.getLocationService();
		List<Node> toAdd = new ArrayList<>();
		findNodesNamed(document, "location", toAdd);
		for (Node node : toAdd) {
			Element e = (Element) node;
			String name = e.getAttribute("name");
			if (name == null || name.length() == 0) {
				throw new IllegalArgumentException("each <location /> element must define a name attribute");
			}
			if (ls.getLocation(name) != null) {
				continue;
			}
			Location location = new Location();
			location.setName(name);
			ls.saveLocation(location);
			++ret;
		}
		return ret;
	}
	@Deprecated
	public static int importRelationships(Collection<String> relationships, boolean autoCreateUsers, boolean autoAddRole) {
		PatientService ps = Context.getPatientService();
		UserService us = Context.getUserService();
		PersonService personService = Context.getPersonService();
		List<Relationship> relsToAdd = new ArrayList<>();
		Random rand = new Random();
		for (String s : relationships) {
			if (s.contains(":")) {
				s = s.substring(s.indexOf(":") + 1);
			}
			String[] ss = s.split(",");
			if (ss.length < 5) {
				throw new IllegalArgumentException("The line '" + s + "' is in the wrong format");
			}
			String userLastName = ss[0];
			String userFirstName = ss[1];
			String username = (userFirstName + userLastName).replaceAll(" ", "");
			String relationshipType = ss[2];
			String identifierType = ss[3];
			String identifier = ss[4];
			User user = null;
			{ 
				List<User> users = us.getUsersByName(userFirstName, userLastName, false);
				if (users.size() == 1) {
					user = users.get(0);
				} else if (users.size() > 1) {
					throw new IllegalArgumentException("Found " + users.size() + " users named '" + userLastName + ", "
					        + userFirstName + "'");
				}
			}
			if (user == null) {
				List<User> users = us.getUsersByName(userFirstName, userLastName, false);
				if (users.size() == 1) {
					user = users.get(0);
				} else if (users.size() > 1) {
					throw new IllegalArgumentException("Found " + users.size() + " voided users named '" + userLastName
					        + ", " + userFirstName + "'");
				}
			}
			if (user == null && autoCreateUsers) {
				user = new User();
				user.setPerson(new Person());
				PersonName pn = new PersonName(userFirstName, "", userLastName);
				user.addName(pn);
				user.setUsername(username);
				String pass;
				{
					int length = rand.nextInt(4) + 8;
					char[] password = new char[length];
					for (int x = 0; x < length; x++) {
						int randDecimalAsciiVal = rand.nextInt(93) + 33;
						password[x] = (char) randDecimalAsciiVal;
					}
					pass = new String(password);
				}
				if (autoAddRole) {
					Role role = us.getRole(relationshipType);
					if (role != null) {
						user.addRole(role);
					}
				}
				us.createUser(user, pass);
			}
			if (user == null) {
				throw new IllegalArgumentException("Can't find user '" + userLastName + ", " + userFirstName + "'");
			}
			Person person = personService.getPerson(user.getUserId());
			RelationshipType relationship = personService.getRelationshipTypeByName(relationshipType);
			PatientIdentifierType pit = ps.getPatientIdentifierTypeByName(identifierType);
			List<PatientIdentifier> found = ps.getPatientIdentifiers(identifier, Collections.singletonList(pit), null, null,
			    null);
			if (found.size() != 1) {
				throw new IllegalArgumentException("Found " + found.size() + " patients with identifier '" + identifier
				        + "' of type " + identifierType);
			}
			Person relative = personService.getPerson(found.get(0).getPatient().getPatientId());
			Relationship rel = new Relationship();
			rel.setPersonA(person);
			rel.setRelationshipType(relationship);
			rel.setPersonB(relative);
			relsToAdd.add(rel);
		}
		int addedSoFar = 0;
		for (Relationship rel : relsToAdd) {
			personService.saveRelationship(rel);
			++addedSoFar;
		}
		return addedSoFar;
	}
	@Deprecated
	public static int importProgramsAndStatuses(List<String> programWorkflow) throws ParseException {
		ProgramWorkflowService pws = Context.getProgramWorkflowService();
		PatientService ps = Context.getPatientService();
		List<PatientProgram> patientPrograms = new ArrayList<>();
		Map<String, PatientProgram> knownPatientPrograms = new HashMap<>();
		Map<String, Program> programsByName = new HashMap<>();
		for (Program program : pws.getAllPrograms()) {
			programsByName.put(program.getConcept().getName(Context.getLocale(), false).getName(), program);
		}
		for (String s : programWorkflow) {
			log.debug(s);
			if (s.startsWith("ENROLLMENT:")) {
				s = s.substring(s.indexOf(":") + 1);
				String[] temp = s.split(",");
				PatientIdentifierType pit = ps.getPatientIdentifierTypeByName(temp[0]);
				String identifier = temp[1];
				List<PatientIdentifier> pis = ps.getPatientIdentifiers(identifier, Collections.singletonList(pit), null,
				    null, null);
				if (pis.size() != 1) {
					throw new IllegalArgumentException("Found " + pis.size() + " instances of identifier " + identifier
					        + " of type " + pit);
				}
				Patient p = pis.get(0).getPatient();
				Program program = programsByName.get(temp[2]);
				if (program == null) {
					throw new RuntimeException("Couldn't find program \"" + temp[2] + "\" in " + programsByName);
				}
				Date enrollmentDate = temp.length < 4 ? null : parseDate(temp[3]);
				Date completionDate = temp.length < 5 ? null : parseDate(temp[4]);
				PatientProgram pp = new PatientProgram();
				pp.setPatient(p);
				pp.setProgram(program);
				pp.setDateEnrolled(enrollmentDate);
				pp.setDateCompleted(completionDate);
				patientPrograms.add(pp);
				knownPatientPrograms.put(temp[0] + "," + temp[1] + "," + temp[2], pp); 
			} else if (s.startsWith("STATUS:")) {
				s = s.substring(s.indexOf(":") + 1);
				String[] temp = s.split(",");
				Program program = programsByName.get(temp[2]);
				if (program == null) {
					throw new RuntimeException("Couldn't find program \"" + temp[2] + "\" in " + programsByName);
				}
				ProgramWorkflow wf = program.getWorkflowByName(temp[3]);
				if (wf == null) {
					throw new RuntimeException("Couldn't find workflow \"" + temp[3] + "\" for program " + program + " (in "
					        + program.getAllWorkflows() + ")");
				}
				ProgramWorkflowState st = wf.getStateByName(temp[4]);
				if (st == null) {
					throw new RuntimeException("Couldn't find state \"" + temp[4] + "\" for workflow " + wf + " (in "
					        + wf.getStates() + ")");
				}
				Date startDate = temp.length < 6 ? null : parseDate(temp[5]);
				Date endDate = temp.length < 7 ? null : parseDate(temp[6]);
				PatientState state = new PatientState();
				PatientProgram pp = knownPatientPrograms.get(temp[0] + "," + temp[1] + "," + temp[2]);
				state.setPatientProgram(pp);
				state.setState(st);
				state.setStartDate(startDate);
				state.setEndDate(endDate);
				pp.getStates().add(state);
			}
		}
		int numAdded = 0;
		for (PatientProgram pp : knownPatientPrograms.values()) {
			pws.savePatientProgram(pp);
			++numAdded;
		}
		return numAdded;
	}
}
package org.openmrs.api.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Allergen;
import org.openmrs.Allergies;
import org.openmrs.Allergy;
import org.openmrs.BaseOpenmrsMetadata;
import org.openmrs.Concept;
import org.openmrs.Encounter;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientProgram;
import org.openmrs.Person;
import org.openmrs.PersonAddress;
import org.openmrs.PersonAttribute;
import org.openmrs.PersonName;
import org.openmrs.Relationship;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.api.APIException;
import org.openmrs.api.BlankIdentifierException;
import org.openmrs.api.DuplicateIdentifierException;
import org.openmrs.api.EncounterService;
import org.openmrs.api.InsufficientIdentifiersException;
import org.openmrs.api.MissingRequiredIdentifierException;
import org.openmrs.api.ObsService;
import org.openmrs.api.PatientIdentifierException;
import org.openmrs.api.PatientIdentifierTypeLockedException;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.PatientDAO;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.parameter.EncounterSearchCriteria;
import org.openmrs.parameter.EncounterSearchCriteriaBuilder;
import org.openmrs.patient.IdentifierValidator;
import org.openmrs.patient.impl.LuhnIdentifierValidator;
import org.openmrs.person.PersonMergeLog;
import org.openmrs.person.PersonMergeLogData;
import org.openmrs.serialization.SerializationException;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.validator.PatientIdentifierValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
@Transactional
public class PatientServiceImpl extends BaseOpenmrsService implements PatientService {
	private static final Logger log = LoggerFactory.getLogger(PatientServiceImpl.class);
	private PatientDAO dao;
	private static Map<Class<? extends IdentifierValidator>, IdentifierValidator> identifierValidators = null;
	@Override
	public void setPatientDAO(PatientDAO dao) {
		this.dao = dao;
	}
	@Override
	public void onShutdown() {
		setIdentifierValidators(null);
	}
	@Override
	public Patient savePatient(Patient patient) throws APIException {
		requireAppropriatePatientModificationPrivilege(patient);
		if (!patient.getVoided() && patient.getIdentifiers().size() == 1) {
			patient.getPatientIdentifier().setPreferred(true);
		}
		if (!patient.getVoided()) {
			checkPatientIdentifiers(patient);
		}
		setPreferredPatientIdentifier(patient);
		setPreferredPatientName(patient);
		setPreferredPatientAddress(patient);
		return dao.savePatient(patient);
	}
	private void requireAppropriatePatientModificationPrivilege(Patient patient) {
		if (patient.getPatientId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_PATIENTS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_PATIENTS);
		}
		if (patient.getVoided()) {
			Context.requirePrivilege(PrivilegeConstants.DELETE_PATIENTS);
		}
	}
	private void setPreferredPatientIdentifier(Patient patient) {
		PatientIdentifier preferredIdentifier = null;
		PatientIdentifier possiblePreferredId = patient.getPatientIdentifier();
		if (possiblePreferredId != null && possiblePreferredId.getPreferred() && !possiblePreferredId.getVoided()) {
			preferredIdentifier = possiblePreferredId;
		}
		for (PatientIdentifier id : patient.getIdentifiers()) {
			if (preferredIdentifier == null && !id.getVoided()) {
				id.setPreferred(true);
				preferredIdentifier = id;
				continue;
			}
			if (!id.equals(preferredIdentifier)) {
				id.setPreferred(false);
			}
		}
	}
	private void setPreferredPatientName(Patient patient) {
		PersonName preferredName = null;
		PersonName possiblePreferredName = patient.getPersonName();
		if (possiblePreferredName != null && possiblePreferredName.getPreferred() && !possiblePreferredName.getVoided()) {
			preferredName = possiblePreferredName;
		}
		for (PersonName name : patient.getNames()) {
			if (preferredName == null && !name.getVoided()) {
				name.setPreferred(true);
				preferredName = name;
				continue;
			}
			if (!name.equals(preferredName)) {
				name.setPreferred(false);
			}
		}
	}
	private void setPreferredPatientAddress(Patient patient) {
		PersonAddress preferredAddress = null;
		PersonAddress possiblePreferredAddress = patient.getPersonAddress();
		if (possiblePreferredAddress != null && possiblePreferredAddress.getPreferred()
				&& !possiblePreferredAddress.getVoided()) {
			preferredAddress = possiblePreferredAddress;
		}
		for (PersonAddress address : patient.getAddresses()) {
			if (preferredAddress == null && !address.getVoided()) {
				address.setPreferred(true);
				preferredAddress = address;
				continue;
			}
			if (!address.equals(preferredAddress)) {
				address.setPreferred(false);
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatient(Integer patientId) throws APIException {
		return dao.getPatient(patientId);
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientOrPromotePerson(Integer patientOrPersonId) {
		Person person = Context.getPersonService().getPerson(patientOrPersonId);
		if (person == null) {
			return null;
		}
		person = HibernateUtil.getRealObjectFromProxy(person);
		if (person instanceof Patient) {
			return (Patient)person;
		}
		else {
			return new Patient(person);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getAllPatients() throws APIException {
		return Context.getPatientService().getAllPatients(false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getAllPatients(boolean includeVoided) throws APIException {
		return dao.getAllPatients(includeVoided);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly) throws APIException {
		return Context.getPatientService().getPatients(name, identifier, identifierTypes, matchIdentifierExactly, 0, null);
	}
	@Override
	@Transactional(readOnly = true)
	public void checkPatientIdentifiers(Patient patient) throws PatientIdentifierException {
		if (!patient.getVoided() && patient.getActiveIdentifiers().isEmpty()) {
			throw new InsufficientIdentifiersException("At least one nonvoided Patient Identifier is required");
		}
		final List<PatientIdentifier> patientIdentifiers = new ArrayList<>(patient.getIdentifiers());
		final Set<String> uniqueIdentifiers = new HashSet<>();
		patientIdentifiers.stream()
			.filter(pi -> !pi.getVoided())
			.forEach(pi -> {
				try {
					PatientIdentifierValidator.validateIdentifier(pi);
				}
				catch (BlankIdentifierException bie) {
					patient.removeIdentifier(pi);
					throw bie;
				}
				String compareString = pi.getIdentifier() + " id type #: " + pi.getIdentifierType().getPatientIdentifierTypeId();
				if(! uniqueIdentifiers.add(compareString)) {
					throw new DuplicateIdentifierException("This patient has two identical identifiers of type "
							+ compareString, pi);
				}
			});
		checkForMissingRequiredIdentifiers(patientIdentifiers);
	}
	private void checkForMissingRequiredIdentifiers(List<PatientIdentifier> patientIdentifiers) {
		final Set<PatientIdentifierType> patientIdentifierTypes =
				patientIdentifiers.stream()
						.map(PatientIdentifier::getIdentifierType)
						.collect(Collectors.toSet());
		final List<PatientIdentifierType> requiredTypes = this.getPatientIdentifierTypes(null, null, true, null);
		final Set<String> missingRequiredTypeNames =
				requiredTypes.stream()
						.filter(requiredType -> !patientIdentifierTypes.contains(requiredType))
						.map(BaseOpenmrsMetadata::getName)
						.collect(Collectors.toSet());
		if(! missingRequiredTypeNames.isEmpty()) {
			throw new MissingRequiredIdentifierException(
					"Patient is missing the following required identifier(s): " + String.join(", ", missingRequiredTypeNames));
		}
	}
	@Override
	public Patient voidPatient(Patient patient, String reason) throws APIException {
		if (patient == null) {
			return null;
		}
		return dao.savePatient(patient);
	}
	@Override
	public Patient unvoidPatient(Patient patient) throws APIException {
		if (patient == null) {
			return null;
		}
		return Context.getPatientService().savePatient(patient);
	}
	@Override
	public void purgePatient(Patient patient) throws APIException {
		dao.deletePatient(patient);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifier> getPatientIdentifiers(String identifier,
	        List<PatientIdentifierType> patientIdentifierTypes, List<Location> locations, List<Patient> patients,
	        Boolean isPreferred) throws APIException {
		if (patientIdentifierTypes == null) {
			patientIdentifierTypes = new ArrayList<>();
		}
		if (locations == null) {
			locations = new ArrayList<>();
		}
		if (patients == null) {
			patients = new ArrayList<>();
		}
		return dao.getPatientIdentifiers(identifier, patientIdentifierTypes, locations, patients, isPreferred);
	}
	@Override
	public PatientIdentifierType savePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		return dao.savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getAllPatientIdentifierTypes() throws APIException {
		return Context.getPatientService().getAllPatientIdentifierTypes(false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getAllPatientIdentifierTypes(boolean includeRetired) throws APIException {
		return dao.getAllPatientIdentifierTypes(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getPatientIdentifierTypes(String name, String format, Boolean required,
	        Boolean hasCheckDigit) throws APIException {
		List<PatientIdentifierType> patientIdentifierTypes = dao.getPatientIdentifierTypes(name, format, required, hasCheckDigit);
		if (patientIdentifierTypes == null) {
			return new ArrayList<>();
		}
		return patientIdentifierTypes;
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierType(Integer patientIdentifierTypeId) throws APIException {
		return dao.getPatientIdentifierType(patientIdentifierTypeId);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierTypeByName(String name) throws APIException {
		List<PatientIdentifierType> types = getPatientIdentifierTypes(name, null, null, null);
		if (!types.isEmpty()) {
			return types.get(0);
		}
		return null;
	}
	@Override
	public PatientIdentifierType retirePatientIdentifierType(PatientIdentifierType patientIdentifierType, String reason)
	        throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		if (reason == null || reason.length() < 1) {
			throw new APIException("Patient.identifier.retire.reason", (Object[]) null);
		}
		patientIdentifierType.setRetired(true);
		patientIdentifierType.setRetiredBy(Context.getAuthenticatedUser());
		patientIdentifierType.setDateRetired(new Date());
		patientIdentifierType.setRetireReason(reason);
		return Context.getPatientService().savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	public PatientIdentifierType unretirePatientIdentifierType(PatientIdentifierType patientIdentifierType)
	        throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		patientIdentifierType.setRetired(false);
		patientIdentifierType.setRetiredBy(null);
		patientIdentifierType.setDateRetired(null);
		patientIdentifierType.setRetireReason(null);
		return Context.getPatientService().savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	public void purgePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		dao.deletePatientIdentifierType(patientIdentifierType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query) throws APIException {
		return Context.getPatientService().getPatients(query, 0, null);
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientByExample(Patient patientToMatch) throws APIException {
		if (patientToMatch == null || patientToMatch.getPatientId() == null) {
			return null;
		}
		return Context.getPatientService().getPatient(patientToMatch.getPatientId());
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws APIException {
		if (attributes == null || attributes.isEmpty()) {
			throw new APIException("Patient.no.attribute", (Object[]) null);
		}
		return dao.getDuplicatePatientsByAttributes(attributes);
	}
	private String relationshipHash(Relationship rel, Person primary) {
		boolean isA = rel.getPersonA().equals(primary);
		return rel.getRelationshipType().getRelationshipTypeId().toString() + (isA ? "A" : "B")
		        + (isA ? rel.getPersonB().getPersonId().toString() : rel.getPersonA().getPersonId().toString());
	}
	@Override
	public void mergePatients(Patient preferred, Patient notPreferred) throws APIException, SerializationException {
		log.debug("Merging patients: (preferred)" + preferred.getPatientId() + ", (notPreferred) "
		        + notPreferred.getPatientId());
		if (preferred.getPatientId().equals(notPreferred.getPatientId())) {
			log.debug("Merge operation cancelled: Cannot merge user" + preferred.getPatientId() + " to self");
			throw new APIException("Patient.merge.cancelled", new Object[] { preferred.getPatientId() });
		}
		requireNoActiveOrderOfSameType(preferred,notPreferred);
		PersonMergeLogData mergedData = new PersonMergeLogData();
		mergeVisits(preferred, notPreferred, mergedData);
		mergeEncounters(preferred, notPreferred, mergedData);
		mergeProgramEnrolments(preferred, notPreferred, mergedData);
		mergeRelationships(preferred, notPreferred, mergedData);
		mergeObservationsNotContainedInEncounters(preferred, notPreferred, mergedData);
		mergeIdentifiers(preferred, notPreferred, mergedData);
		mergeNames(preferred, notPreferred, mergedData);
		mergeAddresses(preferred, notPreferred, mergedData);
		mergePersonAttributes(preferred, notPreferred, mergedData);
		mergeGenderInformation(preferred, notPreferred, mergedData);
		mergeDateOfBirth(preferred, notPreferred, mergedData);
		mergeDateOfDeath(preferred, notPreferred, mergedData);
		Context.getPatientService().voidPatient(notPreferred, "Merged with patient #" + preferred.getPatientId());
		Context.getPersonService().voidPerson(notPreferred,
		    "The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
		changeUserAssociations(preferred, notPreferred, mergedData);
		savePatient(preferred);
		PersonMergeLog personMergeLog = new PersonMergeLog();
		personMergeLog.setWinner(preferred);
		personMergeLog.setLoser(notPreferred);
		personMergeLog.setPersonMergeLogData(mergedData);
		Context.getPersonService().savePersonMergeLog(personMergeLog);
	}
	private void requireNoActiveOrderOfSameType(Patient patient1, Patient patient2) {
		String messageKey = "Patient.merge.cannotHaveSameTypeActiveOrders";
		List<Order> ordersByPatient1 = Context.getOrderService().getAllOrdersByPatient(patient1);
		List<Order> ordersByPatient2 = Context.getOrderService().getAllOrdersByPatient(patient2);
		ordersByPatient1.forEach((Order order1) -> ordersByPatient2.forEach((Order order2) -> {
			if (order1.isActive() && order2.isActive() && order1.getOrderType().equals(order2.getOrderType())) {
				Object[] parameters = { patient1.getPatientId(), patient2.getPatientId(), order1.getOrderType() };
				String message = Context.getMessageSourceService().getMessage(messageKey, parameters,
						Context.getLocale());
				log.debug(message);
				throw new APIException(message);
			}
		}));
	}
	private void mergeProgramEnrolments(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		ProgramWorkflowService programService = Context.getProgramWorkflowService();
		for (PatientProgram pp : programService.getPatientPrograms(notPreferred, null, null, null, null, null, false)) {
			if (!pp.getVoided()) {
				pp.setPatient(preferred);
				log.debug("Moving patientProgram {} to {}", pp.getPatientProgramId(), preferred.getPatientId());
				PatientProgram persisted = programService.savePatientProgram(pp);
				mergedData.addMovedProgram(persisted.getUuid());
			}
		}
	}
	private void mergeVisits(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		VisitService visitService = Context.getVisitService();
		for (Visit visit : visitService.getVisitsByPatient(notPreferred, true, true)) {
			log.debug("Merging visit {} to {}", visit.getVisitId(), preferred.getPatientId());
			visit.setPatient(preferred);
			Visit persisted = visitService.saveVisit(visit);
			mergedData.addMovedVisit(persisted.getUuid());
		}
	}
	private void mergeEncounters(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		EncounterService es = Context.getEncounterService();
		EncounterSearchCriteria notPreferredPatientEncounterSearchCriteria = new EncounterSearchCriteriaBuilder()
				.setIncludeVoided(true)
				.setPatient(notPreferred)
				.createEncounterSearchCriteria();
		for (Encounter e : es.getEncounters(notPreferredPatientEncounterSearchCriteria)) {
			e.setPatient(preferred);
			log.debug("Merging encounter " + e.getEncounterId() + " to " + preferred.getPatientId());
			Encounter persisted = es.saveEncounter(e);
			mergedData.addMovedEncounter(persisted.getUuid());
		}
	}
	private void mergeRelationships(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		PersonService personService = Context.getPersonService();
		Set<String> existingRelationships = new HashSet<>();
		for (Relationship rel : personService.getRelationshipsByPerson(preferred)) {
			existingRelationships.add(relationshipHash(rel, preferred));
		}
		for (Relationship rel : personService.getRelationshipsByPerson(notPreferred)) {
			if (!rel.getVoided()) {
				boolean personAisPreferred = rel.getPersonA().equals(preferred);
				boolean personAisNotPreferred = rel.getPersonA().equals(notPreferred);
				boolean personBisPreferred = rel.getPersonB().equals(preferred);
				boolean personBisNotPreferred = rel.getPersonB().equals(notPreferred);
				String relHash = relationshipHash(rel, notPreferred);
				if ((personAisPreferred && personBisNotPreferred) || (personBisPreferred && personAisNotPreferred)) {
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged to person " + (personAisPreferred ? "A" : "B"));
				} else if (existingRelationships.contains(relHash)) {
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged and a relationship already exists");
				} else {
					Relationship tmpRel = rel.copy();
					if (personAisNotPreferred) {
						tmpRel.setPersonA(preferred);
					}
					if (personBisNotPreferred) {
						tmpRel.setPersonB(preferred);
					}
					log.debug("Copying relationship " + rel.getRelationshipId() + " to " + preferred.getPatientId());
					Relationship persisted = personService.saveRelationship(tmpRel);
					mergedData.addCreatedRelationship(persisted.getUuid());
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged, relationship copied to #" + tmpRel.getRelationshipId());
					existingRelationships.add(relHash);
				}
				mergedData.addVoidedRelationship(rel.getUuid());
			}
		}
	}
	private void mergeObservationsNotContainedInEncounters(Patient preferred, Patient notPreferred,
	        PersonMergeLogData mergedData) {
		ObsService obsService = Context.getObsService();
		for (Obs obs : obsService.getObservationsByPerson(notPreferred)) {
			if (obs.getEncounter() == null && !obs.getVoided()) {
				obs.setPerson(preferred);
				Obs persisted = obsService.saveObs(obs, "Merged from patient #" + notPreferred.getPatientId());
				mergedData.addMovedIndependentObservation(persisted.getUuid());
			}
		}
	}
	private void mergeIdentifiers(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PatientIdentifier pi : notPreferred.getActiveIdentifiers()) {
			PatientIdentifier tmpIdentifier = new PatientIdentifier();
			tmpIdentifier.setIdentifier(pi.getIdentifier());
			tmpIdentifier.setIdentifierType(pi.getIdentifierType());
			tmpIdentifier.setLocation(pi.getLocation());
			tmpIdentifier.setPatient(preferred);
			boolean found = false;
			for (PatientIdentifier preferredIdentifier : preferred.getIdentifiers()) {
				if (preferredIdentifier.getIdentifier() != null
				        && preferredIdentifier.getIdentifier().equals(tmpIdentifier.getIdentifier())
				        && preferredIdentifier.getIdentifierType() != null
				        && preferredIdentifier.getIdentifierType().equals(tmpIdentifier.getIdentifierType())) {
					found = true;
				}
			}
			if (!found) {
				tmpIdentifier.setIdentifierType(pi.getIdentifierType());
				tmpIdentifier.setCreator(Context.getAuthenticatedUser());
				tmpIdentifier.setDateCreated(new Date());
				tmpIdentifier.setVoided(false);
				tmpIdentifier.setVoidedBy(null);
				tmpIdentifier.setVoidReason(null);
				tmpIdentifier.setUuid(UUID.randomUUID().toString());
				tmpIdentifier.setPreferred(false);
				preferred.addIdentifier(tmpIdentifier);
				mergedData.addCreatedIdentifier(tmpIdentifier.getUuid());
				log.debug("Merging identifier " + tmpIdentifier.getIdentifier() + " to " + preferred.getPatientId());
			}
		}
	}
	private void mergeDateOfDeath(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorDateOfDeath(preferred.getDeathDate());
		if (preferred.getDeathDate() == null) {
			preferred.setDeathDate(notPreferred.getDeathDate());
		}
		if (preferred.getCauseOfDeath() != null) {
			mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
		}
		if (preferred.getCauseOfDeath() == null) {
			preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
		}
	}
	private void mergeDateOfBirth(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorDateOfBirth(preferred.getBirthdate());
		mergedData.setPriorDateOfBirthEstimated(preferred.getBirthdateEstimated());
		if (preferred.getBirthdate() == null || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
			preferred.setBirthdate(notPreferred.getBirthdate());
			preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
		}
	}
	private void mergePersonAttributes(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PersonAttribute attr : notPreferred.getAttributes()) {
			if (!attr.getVoided()) {
				PersonAttribute tmpAttr = attr.copy();
				tmpAttr.setPerson(null);
				tmpAttr.setUuid(UUID.randomUUID().toString());
				preferred.addAttribute(tmpAttr);
				mergedData.addCreatedAttribute(tmpAttr.getUuid());
			}
		}
	}
	private void mergeGenderInformation(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorGender(preferred.getGender());
		if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender())) {
			preferred.setGender(notPreferred.getGender());
		}
	}
	private void mergeNames(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PersonName newName : notPreferred.getNames()) {
			boolean containsName = false;
			for (PersonName currentName : preferred.getNames()) {
				containsName = currentName.equalsContent(newName);
				if (containsName) {
					break;
				}
			}
			if (!containsName) {
				PersonName tmpName = constructTemporaryName(newName);
				preferred.addName(tmpName);
				mergedData.addCreatedName(tmpName.getUuid());
				log.debug("Merging name " + newName.getGivenName() + " to " + preferred.getPatientId());
			}
		}
	}
	private PersonName constructTemporaryName(PersonName newName) {
		PersonName tmpName = PersonName.newInstance(newName);
		tmpName.setPersonNameId(null);
		tmpName.setVoided(false);
		tmpName.setVoidedBy(null);
		tmpName.setVoidReason(null);
		tmpName.setPreferred(false);
		tmpName.setUuid(UUID.randomUUID().toString());
		return tmpName;
	}
	private void mergeAddresses(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData)
	        throws SerializationException {
		for (PersonAddress newAddress : notPreferred.getAddresses()) {
			boolean containsAddress = false;
			for (PersonAddress currentAddress : preferred.getAddresses()) {
				containsAddress = currentAddress.equalsContent(newAddress);
				if (containsAddress) {
					break;
				}
			}
			if (!containsAddress) {
				PersonAddress tmpAddress = (PersonAddress) newAddress.clone();
				tmpAddress.setPersonAddressId(null);
				tmpAddress.setVoided(false);
				tmpAddress.setVoidedBy(null);
				tmpAddress.setVoidReason(null);
				tmpAddress.setPreferred(false); 
				tmpAddress.setUuid(UUID.randomUUID().toString());
				preferred.addAddress(tmpAddress);
				mergedData.addCreatedAddress(tmpAddress.getUuid());
				log.debug("Merging address " + newAddress.getPersonAddressId() + " to " + preferred.getPatientId());
			}
		}
		for (PersonAttribute attr : notPreferred.getAttributes()) {
			if (!attr.getVoided()) {
				PersonAttribute tmpAttr = attr.copy();
				tmpAttr.setPerson(null);
				tmpAttr.setUuid(UUID.randomUUID().toString());
				preferred.addAttribute(tmpAttr);
				mergedData.addCreatedAttribute(tmpAttr.getUuid());
			}
		}
		mergedData.setPriorGender(preferred.getGender());
		if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender())) {
			preferred.setGender(notPreferred.getGender());
		}
		mergedData.setPriorDateOfBirth(preferred.getBirthdate());
		mergedData.setPriorDateOfBirthEstimated(preferred.getBirthdateEstimated());
		if (preferred.getBirthdate() == null || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
			preferred.setBirthdate(notPreferred.getBirthdate());
			preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
		}
		mergedData.setPriorDateOfDeathEstimated(preferred.getDeathdateEstimated());
		if (preferred.getDeathdateEstimated() == null) {
			preferred.setDeathdateEstimated(notPreferred.getDeathdateEstimated());
		}
		mergedData.setPriorDateOfDeath(preferred.getDeathDate());
		if (preferred.getDeathDate() == null) {
			preferred.setDeathDate(notPreferred.getDeathDate());
		}
		if (preferred.getCauseOfDeath() != null) {
			mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
		}
		if (preferred.getCauseOfDeath() == null) {
			preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
		}
		Context.getPatientService().voidPatient(notPreferred, "Merged with patient #" + preferred.getPatientId());
		Context.getPersonService().voidPerson(notPreferred,
		    "The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
		changeUserAssociations(preferred, notPreferred, mergedData);
		savePatient(preferred);
		PersonMergeLog personMergeLog = new PersonMergeLog();
		personMergeLog.setWinner(preferred);
		personMergeLog.setLoser(notPreferred);
		personMergeLog.setPersonMergeLogData(mergedData);
		Context.getPersonService().savePersonMergeLog(personMergeLog);
	}
	private void changeUserAssociations(Patient preferred, Person notPreferred, PersonMergeLogData mergedData) {
		UserService userService = Context.getUserService();
		List<User> users = userService.getUsersByPerson(notPreferred, true);
		for (User user : users) {
			user.setPerson(preferred);
			User persisted = userService.saveUser(user);
			if (mergedData != null) {
				mergedData.addMovedUser(persisted.getUuid());
			}
		}
	}
	public void exitFromCare(Patient patient, Date dateExited, Concept reasonForExit) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.invalid.care", (Object[]) null);
		}
		if (dateExited == null) {
			throw new APIException("Patient.no.valid.dateExited", (Object[]) null);
		}
		if (reasonForExit == null) {
			throw new APIException("Patient.no.valid.reasonForExit", (Object[]) null);
		}
		saveReasonForExitObs(patient, dateExited, reasonForExit);
	}
	private void saveReasonForExitObs(Patient patient, Date exitDate, Concept cause) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.null", (Object[]) null);
		}
		if (exitDate == null) {
			throw new APIException("Patient.exit.date.null", (Object[]) null);
		}
		if (cause == null) {
			throw new APIException("Patient.cause.null", (Object[]) null);
		}
		log.debug("Patient is exiting, so let's make sure there's an Obs for it");
		String codProp = Context.getAdministrationService().getGlobalProperty("concept.reasonExitedCare");
		Concept reasonForExit = Context.getConceptService().getConcept(codProp);
		if (reasonForExit != null) {
			List<Obs> obssExit = Context.getObsService().getObservationsByPersonAndConcept(patient, reasonForExit);
			if (obssExit != null) {
				if (obssExit.size() > 1) {
					log.error("Multiple reasons for exit (" + obssExit.size() + ")?  Shouldn't be...");
				} else {
					Obs obsExit;
					if (obssExit.size() == 1) {
						log.debug("Already has a reason for exit, so changing it");
						obsExit = obssExit.iterator().next();
					} else {
						log.debug("No reason for exit yet, let's create one.");
						obsExit = new Obs();
						obsExit.setPerson(patient);
						obsExit.setConcept(reasonForExit);
						Location loc = Context.getLocationService().getDefaultLocation();
						if (loc != null) {
							obsExit.setLocation(loc);
						} else {
							log.error("Could not find a suitable location for which to create this new Obs");
						}
					}
					if (obsExit != null) {
						obsExit.setValueCoded(cause);
						obsExit.setValueCodedName(cause.getName()); 
						obsExit.setObsDatetime(exitDate);
						Context.getObsService().saveObs(obsExit, "updated by PatientService.saveReasonForExit");
					}
				}
			}
		} else {
			log.debug("Reason for exit is null - should not have gotten here without throwing an error on the form.");
		}
	}
	@Override
	public void processDeath(Patient patient, Date dateDied, Concept causeOfDeath, String otherReason) throws APIException {
		if (patient != null && dateDied != null && causeOfDeath != null) {
			patient.setDead(true);
			patient.setDeathDate(dateDied);
			patient.setCauseOfDeath(causeOfDeath);
			this.savePatient(patient);
			saveCauseOfDeathObs(patient, dateDied, causeOfDeath, otherReason);
			String strPatientDied = Context.getAdministrationService().getGlobalProperty("concept.patientDied");
			Concept conceptPatientDied = Context.getConceptService().getConcept(strPatientDied);
			if (conceptPatientDied == null) {
				log.debug("ConceptPatientDied is null");
			}
			exitFromCare(patient, dateDied, conceptPatientDied);
		} else {
			if (patient == null) {
				throw new APIException("Patient.invalid.dead", (Object[]) null);
			}
			if (dateDied == null) {
				throw new APIException("Patient.no.valid.dateDied", (Object[]) null);
			}
			if (causeOfDeath == null) {
				throw new APIException("Patient.no.valid.causeOfDeath", (Object[]) null);
			}
		}
	}
	@Override
	public void saveCauseOfDeathObs(Patient patient, Date deathDate, Concept cause, String otherReason) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.null", (Object[]) null);
		}
		if (deathDate == null) {
			throw new APIException("Patient.death.date.null", (Object[]) null);
		}
		if (cause == null) {
			throw new APIException("Patient.cause.null", (Object[]) null);
		}
		if (!patient.getDead()) {
			patient.setDead(true);
			patient.setDeathDate(deathDate);
			patient.setCauseOfDeath(cause);
		}
		log.debug("Patient is dead, so let's make sure there's an Obs for it");
		String codProp = Context.getAdministrationService().getGlobalProperty("concept.causeOfDeath");
		Concept causeOfDeath = Context.getConceptService().getConcept(codProp);
		if (causeOfDeath != null) {
			List<Obs> obssDeath = Context.getObsService().getObservationsByPersonAndConcept(patient, causeOfDeath);
			if (obssDeath != null) {
				if (obssDeath.size() > 1) {
					log.error("Multiple causes of death (" + obssDeath.size() + ")?  Shouldn't be...");
				} else {
					Obs obsDeath;
					if (obssDeath.size() == 1) {
						log.debug("Already has a cause of death, so changing it");
						obsDeath = obssDeath.iterator().next();
					} else {
						log.debug("No cause of death yet, let's create one.");
						obsDeath = new Obs();
						obsDeath.setPerson(patient);
						obsDeath.setConcept(causeOfDeath);
						Location location = Context.getLocationService().getDefaultLocation();
						if (location != null) {
							obsDeath.setLocation(location);
						} else {
							log.error("Could not find a suitable location for which to create this new Obs");
						}
					}
					Concept currCause = patient.getCauseOfDeath();
					if (currCause == null) {
						log.debug("Current cause is null, attempting to set to NONE");
						String noneConcept = Context.getAdministrationService().getGlobalProperty("concept.none");
						currCause = Context.getConceptService().getConcept(noneConcept);
					}
					if (currCause != null) {
						log.debug("Current cause is not null, setting to value_coded");
						obsDeath.setValueCoded(currCause);
						obsDeath.setValueCodedName(currCause.getName()); 
						Date dateDeath = patient.getDeathDate();
						if (dateDeath == null) {
							dateDeath = new Date();
						}
						obsDeath.setObsDatetime(dateDeath);
						String otherConcept = Context.getAdministrationService().getGlobalProperty("concept.otherNonCoded");
						Concept conceptOther = Context.getConceptService().getConcept(otherConcept);
						if (conceptOther != null) {
							if (conceptOther.equals(currCause)) {
								log.debug("Setting value_text as " + otherReason);
								obsDeath.setValueText(otherReason);
							} else {
								log.debug("New concept is NOT the OTHER concept, so setting to blank");
								obsDeath.setValueText("");
							}
						} else {
							log.debug("Don't seem to know about an OTHER concept, so deleting value_text");
							obsDeath.setValueText("");
						}
						Context.getObsService().saveObs(obsDeath, "updated by PatientService.saveCauseOfDeathObs");
					} else {
						log.debug("Current cause is still null - aborting mission");
					}
				}
			}
		} else {
			log.debug("Cause of death is null - should not have gotten here without throwing an error on the form.");
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientByUuid(String uuid) throws APIException {
		return dao.getPatientByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifier getPatientIdentifierByUuid(String uuid) throws APIException {
		return dao.getPatientIdentifierByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierTypeByUuid(String uuid) throws APIException {
		return dao.getPatientIdentifierTypeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public IdentifierValidator getDefaultIdentifierValidator() {
		String defaultPIV = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR, "");
		try {
			return identifierValidators.get(Class.forName(defaultPIV));
		}
		catch (ClassNotFoundException e) {
			log.error("Global Property " + OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR
			        + " not set to an actual class.", e);
			return identifierValidators.get(LuhnIdentifierValidator.class);
		}
	}
	@Override
	public IdentifierValidator getIdentifierValidator(Class<IdentifierValidator> identifierValidator) {
		return identifierValidators.get(identifierValidator);
	}
	public Map<Class<? extends IdentifierValidator>, IdentifierValidator> getIdentifierValidators() {
		if (identifierValidators == null) {
			identifierValidators = new LinkedHashMap<>();
		}
		return identifierValidators;
	}
	public void setIdentifierValidators(Map<Class<? extends IdentifierValidator>, IdentifierValidator> identifierValidators) {
		if (identifierValidators == null) {
			PatientServiceImpl.setStaticIdentifierValidators(null);
			return;
		}
		for (Map.Entry<Class<? extends IdentifierValidator>, IdentifierValidator> entry : identifierValidators.entrySet()) {
			getIdentifierValidators().put(entry.getKey(), entry.getValue());
		}
	}
	private static void setStaticIdentifierValidators(
	        Map<Class<? extends IdentifierValidator>, IdentifierValidator> currentIdentifierValidators) {
		PatientServiceImpl.identifierValidators = currentIdentifierValidators;
	}
	@Override
	public Collection<IdentifierValidator> getAllIdentifierValidators() {
		return identifierValidators.values();
	}
	@Override
	@SuppressWarnings("unchecked")
	@Transactional(readOnly = true)
	public IdentifierValidator getIdentifierValidator(String pivClassName) {
		if (StringUtils.isBlank(pivClassName)) {
			return null;
		}
		try {
			return getIdentifierValidator((Class<IdentifierValidator>) Context.loadClass(pivClassName));
		}
		catch (ClassNotFoundException e) {
			throw new PatientIdentifierException("Could not find patient identifier validator " + pivClassName, e);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier) {
		return dao.isIdentifierInUseByAnotherPatient(patientIdentifier);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifier getPatientIdentifier(Integer patientIdentifierId) throws APIException {
		return dao.getPatientIdentifier(patientIdentifierId);
	}
	@Override
	public PatientIdentifier voidPatientIdentifier(PatientIdentifier patientIdentifier, String reason) throws APIException {
		if (patientIdentifier == null || StringUtils.isBlank(reason)) {
			throw new APIException("Patient.identifier.cannot.be.null", (Object[]) null);
		}
		return Context.getPatientService().savePatientIdentifier(patientIdentifier);
	}
	@Override
	public void mergePatients(Patient preferred, List<Patient> notPreferred) throws APIException, SerializationException {
		for (Patient nonPreferred : notPreferred) {
			mergePatients(preferred, nonPreferred);
		}
	}
	@Override
	public PatientIdentifier savePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException {
		PatientIdentifierType.LocationBehavior locationBehavior = null;
		if (patientIdentifier != null) {
			locationBehavior = patientIdentifier.getIdentifierType().getLocationBehavior();
		}
		if (patientIdentifier == null
		        || patientIdentifier.getPatient() == null
		        || patientIdentifier.getIdentifierType() == null
		        || StringUtils.isBlank(patientIdentifier.getIdentifier())
		        || (locationBehavior == PatientIdentifierType.LocationBehavior.REQUIRED && patientIdentifier.getLocation() == null)) {
			throw new APIException("Patient.identifier.null", (Object[]) null);
		}
		if (patientIdentifier.getPatientIdentifierId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_PATIENT_IDENTIFIERS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_PATIENT_IDENTIFIERS);
		}
		return dao.savePatientIdentifier(patientIdentifier);
	}
	@Override
	public void purgePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException {
		dao.deletePatientIdentifier(patientIdentifier);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergies getAllergies(Patient patient) {
		if (patient == null) {
			throw new IllegalArgumentException("An existing (NOT NULL) patient is required to get allergies");
		}
		Allergies allergies = new Allergies();
		List<Allergy> allergyList = dao.getAllergies(patient);
		if (!allergyList.isEmpty()) {
			allergies.addAll(allergyList);
		} else {
			String status = dao.getAllergyStatus(patient);
			if (Allergies.NO_KNOWN_ALLERGIES.equals(status)) {
				allergies.confirmNoKnownAllergies();
			}
		}
		return allergies;
	}
	@Override
	public Allergies setAllergies(Patient patient, Allergies allergies) {
		List<Allergy> dbAllergyList = getAllergies(patient);
		for (Allergy originalAllergy : dbAllergyList) {
			if (allergies.contains(originalAllergy)) {
				Allergy potentiallyEditedAllergy = allergies.getAllergy(originalAllergy.getAllergyId());
				if (!potentiallyEditedAllergy.hasSameValues(originalAllergy)) {
					Allergy newAllergy = new Allergy();
					try {
						allergies.remove(potentiallyEditedAllergy);
						newAllergy.copy(potentiallyEditedAllergy);
						allergies.add(newAllergy);
						voidAllergy(originalAllergy);
					}
					catch (Exception ex) {
						throw new APIException("Failed to copy edited values", ex);
					}
				}
				continue;
			}
			voidAllergy(originalAllergy);
		}
		for (Allergy allergy : allergies) {
			if (allergy.getAllergyId() == null && allergy.getAllergen().getCodedAllergen() == null
			        && StringUtils.isNotBlank(allergy.getAllergen().getNonCodedAllergen())) {
				Concept otherNonCoded = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid());
				if (otherNonCoded == null) {
					throw new APIException("Can't find concept with uuid:" + Allergen.getOtherNonCodedConceptUuid());
				}
				allergy.getAllergen().setCodedAllergen(otherNonCoded);
			}
		}
		return dao.saveAllergies(patient, allergies);
	}
	private void voidAllergy(Allergy allergy) {
		allergy.setVoided(true);
		allergy.setVoidedBy(Context.getAuthenticatedUser());
		allergy.setDateVoided(new Date());
		allergy.setVoidReason("Voided by API");
		dao.saveAllergy(allergy);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergy getAllergy(Integer allergyId) throws APIException {
		return dao.getAllergy(allergyId);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergy getAllergyByUuid(String uuid) throws APIException {
		return dao.getAllergyByUuid(uuid);
	}
	@Override
	public void saveAllergy(Allergy allergy) throws APIException {
		dao.saveAllergy(allergy);
	}
	@Override
	public void removeAllergy(Allergy allergy, String reason) throws APIException {
		voidAllergy(allergy, reason);
	}
	@Override
	public void voidAllergy(Allergy allergy, String reason) throws APIException {
		allergy.setVoided(true);
		allergy.setVoidedBy(Context.getAuthenticatedUser());
		allergy.setDateVoided(new Date());
		allergy.setVoidReason(reason);
		dao.saveAllergy(allergy);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfPatients(String query) {
		int count = 0;
		if (StringUtils.isBlank(query)) {
			return count;
		}
		return OpenmrsUtil.convertToInteger(dao.getCountOfPatients(query));
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfPatients(String query, boolean includeVoided) {
		int count = 0;
		if (StringUtils.isBlank(query)) {
			return count;
		}
		return OpenmrsUtil.convertToInteger(dao.getCountOfPatients(query, includeVoided));
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query, Integer start, Integer length) throws APIException {
		List<Patient> patients = new ArrayList<>();
		if (StringUtils.isBlank(query)) {
			return patients;
		}
		return dao.getPatients(query, start, length);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query, boolean includeVoided, Integer start, Integer length) throws APIException {
		if (StringUtils.isBlank(query)) {
			return Collections.emptyList();
		}
		return dao.getPatients(query, includeVoided, start, length);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly, Integer start, Integer length) throws APIException {
		if(identifierTypes == null) {
			return dao.getPatients(name != null ? name : identifier, start, length);
		}
		else {
			return dao.getPatients(name != null ? name : identifier, identifierTypes, matchIdentifierExactly, start, length);
		}
	}
	@Override
	public void checkIfPatientIdentifierTypesAreLocked() {
		String locked = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_IDENTIFIER_TYPES_LOCKED, "false");
		if ("true".equalsIgnoreCase(locked)) {
			throw new PatientIdentifierTypeLockedException();
		}
	}
	public List<PatientIdentifier> getPatientIdentifiersByPatientProgram(PatientProgram patientProgram) {
		return dao.getPatientIdentifierByProgram(patientProgram);
	}
}
package org.openmrs.api.db.hibernate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.Criteria;
import org.hibernate.Query;
import org.hibernate.SQLQuery;
import org.hibernate.SessionFactory;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Restrictions;
import org.hibernate.persister.entity.AbstractEntityPersister;
import org.openmrs.Allergies;
import org.openmrs.Allergy;
import org.openmrs.Location;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientIdentifierType.UniquenessBehavior;
import org.openmrs.PatientProgram;
import org.openmrs.Person;
import org.openmrs.PersonAttribute;
import org.openmrs.PersonName;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.DAOException;
import org.openmrs.api.db.PatientDAO;
import org.openmrs.api.db.hibernate.search.LuceneQuery;
import org.openmrs.collection.ListPart;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class HibernatePatientDAO implements PatientDAO {
	private static final Logger log = LoggerFactory.getLogger(HibernatePatientDAO.class);
	private SessionFactory sessionFactory;
	public void setSessionFactory(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}
        @Override
	public Patient getPatient(Integer patientId) {
		return (Patient) sessionFactory.getCurrentSession().get(Patient.class, patientId);
	}
        @Override
	public Patient savePatient(Patient patient) throws DAOException {
		if (patient.getPatientId() == null) {
			sessionFactory.getCurrentSession().saveOrUpdate(patient);
			return patient;
		} else {
			insertPatientStubIfNeeded(patient);
			sessionFactory.getCurrentSession().saveOrUpdate(patient);
			return patient;
		}
	}
	private void insertPatientStubIfNeeded(Patient patient) {
		boolean stubInsertNeeded = false;
		if (patient.getPatientId() != null) {
			String sql = "SELECT 1 FROM patient WHERE patient_id = :patientId";
			Query query = sessionFactory.getCurrentSession().createSQLQuery(sql);
			query.setInteger("patientId", patient.getPatientId());
			stubInsertNeeded = (query.uniqueResult() == null);
		}
		if (stubInsertNeeded) {
			if (patient.getCreator() == null) {
				patient.setCreator(Context.getAuthenticatedUser());
			}
			if (patient.getDateCreated() == null) {
				patient.setDateCreated(new Date());
			}
			String insert = "INSERT INTO patient (patient_id, creator, voided, date_created) VALUES (:patientId, :creator, :voided, :dateCreated)";
			Query query = sessionFactory.getCurrentSession().createSQLQuery(insert);
			query.setInteger("patientId", patient.getPatientId());
			query.setInteger("creator", patient.getCreator().getUserId());
			query.setBoolean("voided", false);
			query.setDate("dateCreated", patient.getDateCreated());
			query.executeUpdate();
			Person person = (Person) sessionFactory.getCurrentSession().get(Person.class, patient.getPersonId());
			sessionFactory.getCurrentSession().evict(person);
		}
	}
	public List<Patient> getPatients(String query, List<PatientIdentifierType> identifierTypes,
		boolean matchIdentifierExactly, Integer start, Integer length) throws DAOException{
		if (StringUtils.isBlank(query) || (length != null && length < 1) || identifierTypes == null || identifierTypes.isEmpty())  {
			return Collections.emptyList();
		}
		Integer tmpStart = start;
		if (tmpStart == null || tmpStart < 0) {
			tmpStart = 0;
		}
		Integer tmpLength = length;
		if (tmpLength == null) {
			tmpLength = HibernatePersonDAO.getMaximumSearchResults();
		}
		return findPatients(query, identifierTypes, matchIdentifierExactly, tmpStart, tmpLength);
	}
	@Override
	public List<Patient> getPatients(String query, boolean includeVoided, Integer start, Integer length) throws DAOException {
		if (StringUtils.isBlank(query) || (length != null && length < 1)) {
			return Collections.emptyList();
		}
		Integer tmpStart = start;
		if (tmpStart == null || tmpStart < 0) {
			tmpStart = 0;
		}
		Integer tmpLength = length;
		if (tmpLength == null) {
			tmpLength = HibernatePersonDAO.getMaximumSearchResults();
		}
		List<Patient> patients = findPatients(query, includeVoided, tmpStart, tmpLength);
		return new ArrayList<>(patients);
	}
	@Override
	public List<Patient> getPatients(String query, Integer start, Integer length) throws DAOException {
		return getPatients(query, false, start, length);
	}
	private void setFirstAndMaxResult(Criteria criteria, Integer start, Integer length) {
		if (start != null) {
			criteria.setFirstResult(start);
		}
		int maximumSearchResults = HibernatePersonDAO.getMaximumSearchResults();
		if (length != null && length < maximumSearchResults) {
			criteria.setMaxResults(length);
		} else {
			log.debug("Limiting the size of the number of matching patients to {}", maximumSearchResults);
			criteria.setMaxResults(maximumSearchResults);
		}
	}
	@SuppressWarnings("unchecked")
        @Override
	public List<Patient> getAllPatients(boolean includeVoided) throws DAOException {
		Criteria criteria = sessionFactory.getCurrentSession().createCriteria(Patient.class);
		if (!includeVoided) {
			criteria.add(Restrictions.eq("voided", false));
		}
		return criteria.list();
	}
        @Override
	public void deletePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws DAOException {
		sessionFactory.getCurrentSession().delete(patientIdentifierType);
	}
	@SuppressWarnings("unchecked")
        @Override
	public List<PatientIdentifier> getPatientIdentifiers(String identifier,
	        List<PatientIdentifierType> patientIdentifierTypes, List<Location> locations, List<Patient> patients,
	        Boolean isPreferred) throws DAOException {
		Criteria criteria = sessionFactory.getCurrentSession().createCriteria(PatientIdentifier.class);
		criteria.createAlias("patient", "patient");
		criteria.add(Restrictions.eq("patient.voided", false));
		criteria.add(Restrictions.eq("voided", false));
		if (identifier != null) {
			criteria.add(Restrictions.eq("identifier", identifier));
		}
		if (!patientIdentifierTypes.isEmpty()) {
			criteria.add(Restrictions.in("identifierType", patientIdentifierTypes));
		}
		if (!locations.isEmpty()) {
			criteria.add(Restrictions.in("location", locations));
		}
		if (!patients.isEmpty()) {
			criteria.add(Restrictions.in("patient", patients));
		}
		if (isPreferred != null) {
			criteria.add(Restrictions.eq("preferred", isPreferred));
		}
		return criteria.list();
	}
        @Override
	public PatientIdentifierType savePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws DAOException {
		sessionFactory.getCurrentSession().saveOrUpdate(patientIdentifierType);
		return patientIdentifierType;
	}
        @Override
	public void deletePatient(Patient patient) throws DAOException {
		HibernatePersonDAO.deletePersonAndAttributes(sessionFactory, patient);
	}
        @Override
	public PatientIdentifierType getPatientIdentifierType(Integer patientIdentifierTypeId) throws DAOException {
		return (PatientIdentifierType) sessionFactory.getCurrentSession().get(PatientIdentifierType.class,
		    patientIdentifierTypeId);
	}
	@SuppressWarnings("unchecked")
        @Override
	public List<PatientIdentifierType> getAllPatientIdentifierTypes(boolean includeRetired) throws DAOException {
		Criteria criteria = sessionFactory.getCurrentSession().createCriteria(PatientIdentifierType.class);
		if (!includeRetired) {
			criteria.add(Restrictions.eq("retired", false));
		} else {
			criteria.addOrder(Order.asc("retired"));
		}
		criteria.addOrder(Order.desc("required"));
		criteria.addOrder(Order.asc("name"));
		criteria.addOrder(Order.asc("patientIdentifierTypeId"));
		return criteria.list();
	}
	@SuppressWarnings("unchecked")
        @Override
	public List<PatientIdentifierType> getPatientIdentifierTypes(String name, String format, Boolean required,
	        Boolean hasCheckDigit) throws DAOException {
		Criteria criteria = sessionFactory.getCurrentSession().createCriteria(PatientIdentifierType.class);
		if (name != null) {
			criteria.add(Restrictions.eq("name", name));
		}
		if (format != null) {
			criteria.add(Restrictions.eq("format", format));
		}
		if (required != null) {
			criteria.add(Restrictions.eq("required", required));
		}
		if (hasCheckDigit != null) {
			criteria.add(Restrictions.eq("checkDigit", hasCheckDigit));
		}
		criteria.add(Restrictions.eq("retired", false));
		criteria.addOrder(Order.desc("required"));
		criteria.addOrder(Order.asc("name"));
		criteria.addOrder(Order.asc("patientIdentifierTypeId"));
		return criteria.list();
	}
	@SuppressWarnings("unchecked")
        @Override
	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) {
		List<Patient> patients = new ArrayList<>();
		List<Integer> patientIds = new ArrayList<>();
		if (!attributes.isEmpty()) {
			String sqlString = getDuplicatePatientsSQLString(attributes);
			if(sqlString != null) {
				SQLQuery sqlquery = sessionFactory.getCurrentSession().createSQLQuery(sqlString);
				patientIds = sqlquery.list();
				if (!patientIds.isEmpty()) {
					Query query = sessionFactory.getCurrentSession().createQuery(
							"from Patient p1 where p1.patientId in (:ids)");
					query.setParameterList("ids", patientIds);
					patients = query.list();
				}
			}
		}
		sortDuplicatePatients(patients, patientIds);
		return patients;
	}
	private String getDuplicatePatientsSQLString(List<String> attributes) {
		StringBuilder outerSelect = new StringBuilder("select distinct t1.patient_id from patient t1 ");
		final String t5 = " = t5.";
		Set<String> patientFieldNames = OpenmrsUtil.getDeclaredFields(Patient.class);
		Set<String> personFieldNames = OpenmrsUtil.getDeclaredFields(Person.class);
		Set<String> personNameFieldNames = OpenmrsUtil.getDeclaredFields(PersonName.class);
		Set<String> identifierFieldNames = OpenmrsUtil.getDeclaredFields(PatientIdentifier.class);
		List<String> whereConditions = new ArrayList<>();
		List<String> innerFields = new ArrayList<>();
		StringBuilder innerSelect = new StringBuilder(" from patient p1 ");
		for (String attribute : attributes) {
			if (attribute != null) {
				attribute = attribute.trim();
			}
			if (patientFieldNames.contains(attribute)) {
				AbstractEntityPersister aep = (AbstractEntityPersister) sessionFactory.getClassMetadata(Patient.class);
				String[] properties = aep.getPropertyColumnNames(attribute);
				if (properties.length >= 1) {
					attribute = properties[0];
				}
				whereConditions.add(" t1." + attribute + t5 + attribute);
				innerFields.add("p1." + attribute);
			} else if (personFieldNames.contains(attribute)) {
				if (!Arrays.asList(outerSelect.toString().split("\\s+")).contains("person")) {
					outerSelect.append("inner join person t2 on t1.patient_id = t2.person_id ");
					innerSelect.append("inner join person person1 on p1.patient_id = person1.person_id ");
				}
				AbstractEntityPersister aep = (AbstractEntityPersister) sessionFactory.getClassMetadata(Person.class);
				if (aep != null) {
					String[] properties = aep.getPropertyColumnNames(attribute);
					if (properties != null && properties.length >= 1) {
						attribute = properties[0];
					}
				}
				whereConditions.add(" t2." + attribute + t5 + attribute);
				innerFields.add("person1." + attribute);
			} else if (personNameFieldNames.contains(attribute)) {
				if (!outerSelect.toString().contains("person_name")) {
					outerSelect.append("inner join person_name t3 on t1.patient_id = t3.person_id ");
					innerSelect.append("inner join person_name pn1 on p1.patient_id = pn1.person_id ");
				}
				AbstractEntityPersister aep = (AbstractEntityPersister) sessionFactory
						.getClassMetadata(PersonName.class);
				if (aep != null) {
					String[] properties = aep.getPropertyColumnNames(attribute);
					if (properties != null && properties.length >= 1) {
						attribute = properties[0];
					}
				}
				whereConditions.add(" t3." + attribute + t5 + attribute);
				innerFields.add("pn1." + attribute);
			} else if (identifierFieldNames.contains(attribute)) {
				if (!outerSelect.toString().contains("patient_identifier")) {
					outerSelect.append("inner join patient_identifier t4 on t1.patient_id = t4.patient_id ");
					innerSelect.append("inner join patient_identifier pi1 on p1.patient_id = pi1.patient_id ");
				}
				AbstractEntityPersister aep = (AbstractEntityPersister) sessionFactory
						.getClassMetadata(PatientIdentifier.class);
				if (aep != null) {
					String[] properties = aep.getPropertyColumnNames(attribute);
					if (properties != null && properties.length >= 1) {
						attribute = properties[0];
					}
				}
				whereConditions.add(" t4." + attribute + t5 + attribute);
				innerFields.add("pi1." + attribute);
			} else {
				log.warn("Unidentified attribute: " + attribute);
			}
		}
		if(CollectionUtils.isNotEmpty(innerFields) || CollectionUtils.isNotEmpty(whereConditions)) {
			String innerFieldsJoined = StringUtils.join(innerFields, ", ");
			String whereFieldsJoined = StringUtils.join(whereConditions, " and ");
			String innerWhereCondition = "";
			if (!attributes.contains("includeVoided")) {
				innerWhereCondition = " where p1.voided = false ";
			}
			String innerQuery = "(Select " + innerFieldsJoined + innerSelect + innerWhereCondition + " group by "
					+ innerFieldsJoined + " having count(*) > 1" + " order by " + innerFieldsJoined + ") t5";
			return outerSelect + ", " + innerQuery + " where " + whereFieldsJoined + ";";
		}
		return null;
	}
	private void sortDuplicatePatients(List<Patient> patients, List<Integer> patientIds) {
		Map<Integer, Integer> patientIdOrder = new HashMap<>();
		int startPos = 0;
		for (Integer id : patientIds) {
			patientIdOrder.put(id, startPos++);
		}
		class PatientIdComparator implements Comparator<Patient> {
			private Map<Integer, Integer> sortOrder;
			public PatientIdComparator(Map<Integer, Integer> sortOrder) {
				this.sortOrder = sortOrder;
			}
			@Override
			public int compare(Patient patient1, Patient patient2) {
				Integer patPos1 = sortOrder.get(patient1.getPatientId());
				if (patPos1 == null) {
					throw new IllegalArgumentException("Bad patient encountered: " + patient1.getPatientId());
				}
				Integer patPos2 = sortOrder.get(patient2.getPatientId());
				if (patPos2 == null) {
					throw new IllegalArgumentException("Bad patient encountered: " + patient2.getPatientId());
				}
				return patPos1.compareTo(patPos2);
			}
		}
		patients.sort(new PatientIdComparator(patientIdOrder));
	}
        @Override
	public Patient getPatientByUuid(String uuid) {
		Patient p;
		p = (Patient) sessionFactory.getCurrentSession().createQuery("from Patient p where p.uuid = :uuid").setString(
		    "uuid", uuid).uniqueResult();
		return p;
	}
        @Override
	public PatientIdentifier getPatientIdentifierByUuid(String uuid) {
		return (PatientIdentifier) sessionFactory.getCurrentSession().createQuery(
		    "from PatientIdentifier p where p.uuid = :uuid").setString("uuid", uuid).uniqueResult();
	}
        @Override
	public PatientIdentifierType getPatientIdentifierTypeByUuid(String uuid) {
		return (PatientIdentifierType) sessionFactory.getCurrentSession().createQuery(
		    "from PatientIdentifierType pit where pit.uuid = :uuid").setString("uuid", uuid).uniqueResult();
	}
        @Override
	public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier) {
		boolean checkPatient = patientIdentifier.getPatient() != null
		        && patientIdentifier.getPatient().getPatientId() != null;
		boolean checkLocation = patientIdentifier.getLocation() != null
		        && patientIdentifier.getIdentifierType().getUniquenessBehavior() == UniquenessBehavior.LOCATION;
		String hql = "select count(*) from PatientIdentifier pi, Patient p where pi.patient.patientId = p.patientId "
		        + "and p.voided = false and pi.voided = false and pi.identifier = :identifier and pi.identifierType = :idType";
		if (checkPatient) {
			hql += " and p.patientId != :ptId";
		}
		if (checkLocation) {
			hql += " and pi.location = :locationId";
		}
		Query query = sessionFactory.getCurrentSession().createQuery(hql);
		query.setString("identifier", patientIdentifier.getIdentifier());
		query.setInteger("idType", patientIdentifier.getIdentifierType().getPatientIdentifierTypeId());
		if (checkPatient) {
			query.setInteger("ptId", patientIdentifier.getPatient().getPatientId());
		}
		if (checkLocation) {
			query.setInteger("locationId", patientIdentifier.getLocation().getLocationId());
		}
		return !"0".equals(query.uniqueResult().toString());
	}
        @Override
	public PatientIdentifier getPatientIdentifier(Integer patientIdentifierId) throws DAOException {
		return (PatientIdentifier) sessionFactory.getCurrentSession().get(PatientIdentifier.class, patientIdentifierId);
	}
        @Override
	public PatientIdentifier savePatientIdentifier(PatientIdentifier patientIdentifier) {
		sessionFactory.getCurrentSession().saveOrUpdate(patientIdentifier);
		return patientIdentifier;
	}
        @Override
	public void deletePatientIdentifier(PatientIdentifier patientIdentifier) throws DAOException {
		sessionFactory.getCurrentSession().delete(patientIdentifier);
	}
        @Override
	public Long getCountOfPatients(String query) {
		return getCountOfPatients(query, false);
	}
	@Override
	public Long getCountOfPatients(String query, boolean includeVoided) {
		if (StringUtils.isBlank(query)) {
			return 0L;
		}
		String tmpQuery = LuceneQuery.escapeQuery(query);
		LuceneQuery<PatientIdentifier> identifierQuery = getPatientIdentifierLuceneQuery(tmpQuery, includeVoided, false);
		PersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);
		LuceneQuery<PersonName> nameQuery = personLuceneQuery.getPatientNameQuery(tmpQuery, includeVoided, identifierQuery);
		LuceneQuery<PersonAttribute> attributeQuery = personLuceneQuery.getPatientAttributeQuery(tmpQuery, includeVoided, nameQuery);
		return identifierQuery.resultSize() + nameQuery.resultSize() + attributeQuery.resultSize();
	}
    private List<Patient> findPatients(String query, boolean includeVoided) {
		return findPatients(query, includeVoided, null, null);
	}
	private List<Patient> findPatients(String query, List<PatientIdentifierType> identifierTypes, boolean matchExactly, Integer start, Integer length) {
		String tmpQuery = query;
		Integer tmpStart = start;
		if (tmpStart == null) {
			tmpStart = 0;
		}
		Integer maxLength = HibernatePersonDAO.getMaximumSearchResults();
		Integer tmpLength = length;
		if (tmpLength == null || tmpLength > maxLength) {
			tmpLength = maxLength;
		}
		tmpQuery = LuceneQuery.escapeQuery(tmpQuery);
		List<Patient> patients = new LinkedList<>();
		String minChars = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_MIN_SEARCH_CHARACTERS);
		if (minChars == null || !StringUtils.isNumeric(minChars)) {
			minChars = "" + OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_MIN_SEARCH_CHARACTERS;
		}
		if (tmpQuery.length() < Integer.valueOf(minChars)) {
			return patients;
		}
		LuceneQuery<PatientIdentifier> identifierQuery = getPatientIdentifierLuceneQuery(tmpQuery, identifierTypes, matchExactly);
		long identifiersSize = identifierQuery.resultSize();
		if (identifiersSize > tmpStart) {
			ListPart<Object[]> patientIdentifiers = identifierQuery.listPartProjection(tmpStart, tmpLength, "patient.personId");
			patientIdentifiers.getList().forEach(patientIdentifier -> patients.add(getPatient((Integer) patientIdentifier[0])));
			tmpLength -= patientIdentifiers.getList().size();
			tmpStart = 0;
		} else {
			tmpStart -= (int) identifiersSize;
		}
		if (tmpLength == 0) {
			return patients;
		}
		return patients;
	}
	public List<Patient> findPatients(String query, boolean includeVoided, Integer start, Integer length){
		Integer tmpStart = start;
		if (tmpStart == null) {
			tmpStart = 0;
		}
		Integer maxLength = HibernatePersonDAO.getMaximumSearchResults();
		Integer tmpLength = length;
		if (tmpLength == null || tmpLength > maxLength) {
			tmpLength = maxLength;
		}
		query = LuceneQuery.escapeQuery(query);
		List<Patient> patients = new LinkedList<>();
		String minChars = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_MIN_SEARCH_CHARACTERS);
		if (minChars == null || !StringUtils.isNumeric(minChars)) {
			minChars = "" + OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_MIN_SEARCH_CHARACTERS;
		}
		if (query.length() < Integer.valueOf(minChars)) {
			return patients;
		}
		LuceneQuery<PatientIdentifier> identifierQuery = getPatientIdentifierLuceneQuery(query, includeVoided, false);
		long identifiersSize = identifierQuery.resultSize();
		if (identifiersSize > tmpStart) {
			ListPart<Object[]> patientIdentifiers = identifierQuery.listPartProjection(tmpStart, tmpLength, "patient.personId");
			patientIdentifiers.getList().forEach(patientIdentifier -> patients.add(getPatient((Integer) patientIdentifier[0])));
			tmpLength -= patientIdentifiers.getList().size();
			tmpStart = 0;
		} else {
			tmpStart -= (int) identifiersSize;
		}
		if (tmpLength == 0) {
			return patients;
		}
		PersonLuceneQuery personLuceneQuery = new PersonLuceneQuery(sessionFactory);
		LuceneQuery<PersonName> nameQuery = personLuceneQuery.getPatientNameQuery(query, includeVoided, identifierQuery);
		long namesSize = nameQuery.resultSize();
		if (namesSize > tmpStart) {
			ListPart<Object[]> personNames = nameQuery.listPartProjection(tmpStart, tmpLength, "person.personId");
			personNames.getList().forEach(personName -> patients.add(getPatient((Integer) personName[0])));
			tmpLength -= personNames.getList().size();
			tmpStart = 0;
		} else {
			tmpStart -= (int) namesSize;
		}
		if (tmpLength == 0) {
			return patients;
		}
		LuceneQuery<PersonAttribute> attributeQuery = personLuceneQuery.getPatientAttributeQuery(query, includeVoided, nameQuery);
		long attributesSize = attributeQuery.resultSize();
		if (attributesSize > tmpStart) {
			ListPart<Object[]> personAttributes = attributeQuery.listPartProjection(tmpStart, tmpLength, "person.personId");
			personAttributes.getList().forEach(personAttribute -> patients.add(getPatient((Integer) personAttribute[0])));
		}
		return patients;
	}
	private LuceneQuery<PatientIdentifier> getPatientIdentifierLuceneQuery(String query, List<PatientIdentifierType> identifierTypes, boolean matchExactly) {
		LuceneQuery<PatientIdentifier> patientIdentifierLuceneQuery = getPatientIdentifierLuceneQuery(query, matchExactly);
		List<Integer> identifierTypeIds = new ArrayList<Integer>();
		for(PatientIdentifierType identifierType : identifierTypes) {
			identifierTypeIds.add(identifierType.getId());
		}
		patientIdentifierLuceneQuery.include("identifierType.patientIdentifierTypeId", identifierTypeIds);
		patientIdentifierLuceneQuery.include("patient.isPatient", true);
		patientIdentifierLuceneQuery.skipSame("patient.personId");
		return patientIdentifierLuceneQuery;
	}
	private LuceneQuery<PatientIdentifier> getPatientIdentifierLuceneQuery(String paramQuery, boolean matchExactly) {
		String query = removeIdentifierPadding(paramQuery);
		List<String> tokens = tokenizeIdentifierQuery(query);
		query = StringUtils.join(tokens, " OR ");
		List<String> fields = new ArrayList<>();
		fields.add("identifierPhrase");
		fields.add("identifierType");
		String matchMode = Context.getAdministrationService()
			.getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_MATCH_MODE);
		if (matchExactly) {
			fields.add("identifierExact");
		}
		else if (OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_SEARCH_MATCH_START.equals(matchMode)) {
			fields.add("identifierStart");
		} 
		else  {
			fields.add("identifierAnywhere");
		}
		return LuceneQuery.newQuery(PatientIdentifier.class, sessionFactory.getCurrentSession(), query, fields);
	}		
	private LuceneQuery<PatientIdentifier> getPatientIdentifierLuceneQuery(String query, boolean includeVoided, boolean matchExactly) {
	    LuceneQuery<PatientIdentifier> luceneQuery = getPatientIdentifierLuceneQuery(query, matchExactly);
		if(!includeVoided){
        	luceneQuery.include("voided", false);
			luceneQuery.include("patient.voided", false);
        }
        luceneQuery.include("patient.isPatient", true);
		luceneQuery.skipSame("patient.personId");
        return luceneQuery;
    }
	private String removeIdentifierPadding(String query) {
		String regex = Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_IDENTIFIER_REGEX, "");
		if (Pattern.matches("^\\^.{1}\\*.*$", regex)) {
			String padding = regex.substring(regex.indexOf("^") + 1, regex.indexOf("*"));
			Pattern pattern = Pattern.compile("^" + padding + "+");
			query = pattern.matcher(query).replaceFirst("");
		}
		return query;
	}
	private List<String> tokenizeIdentifierQuery(String query) {
		List<String> searchPatterns = new ArrayList<>();
		String patternSearch = Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_IDENTIFIER_SEARCH_PATTERN, "");
		if (StringUtils.isBlank(patternSearch)) {
			searchPatterns.add(query);
		} else {
			for (String pattern : patternSearch.split(",")) {
				searchPatterns.add(replaceSearchString(pattern, query));
			}
		}
		return searchPatterns;
	}
	private String replaceSearchString(String regex, String identifierSearched) {
		String returnString = regex.replaceAll("@SEARCH@", identifierSearched);
		if (identifierSearched.length() > 1) {
			returnString = returnString.replaceAll("@SEARCH-1@", identifierSearched.substring(0,
					identifierSearched.length() - 1));
			returnString = returnString.replaceAll("@CHECKDIGIT@", identifierSearched
					.substring(identifierSearched.length() - 1));
		} else {
			returnString = returnString.replaceAll("@SEARCH-1@", "");
			returnString = returnString.replaceAll("@CHECKDIGIT@", "");
		}
		return returnString;
	}
        @Override
	public List<Allergy> getAllergies(Patient patient) {
		Criteria criteria = sessionFactory.getCurrentSession().createCriteria(Allergy.class);
		criteria.add(Restrictions.eq("patient", patient));
		criteria.add(Restrictions.eq("voided", false));
		return criteria.list();
	}
        @Override
	public String getAllergyStatus(Patient patient) {
		return (String) sessionFactory.getCurrentSession().createSQLQuery(
			    "select allergy_status from patient where patient_id = :patientId").setInteger("patientId", patient.getPatientId()).uniqueResult();
	}
	@Override
	public Allergies saveAllergies(Patient patient, Allergies allergies) {
		sessionFactory.getCurrentSession().createSQLQuery(
			    "update patient set allergy_status = :allergyStatus where patient_id = :patientId")
			    .setInteger("patientId", patient.getPatientId())
			    .setString("allergyStatus", allergies.getAllergyStatus())
			    .executeUpdate();
		for (Allergy allergy : allergies) {
			sessionFactory.getCurrentSession().save(allergy);
		}
		return allergies;
	}
        @Override
	public Allergy getAllergy(Integer allergyId) {
		return (Allergy) sessionFactory.getCurrentSession().createQuery("from Allergy a where a.allergyId = :allergyId")
				.setInteger("allergyId", allergyId).uniqueResult();
	}
        @Override
	public Allergy getAllergyByUuid(String uuid) {
		return (Allergy) sessionFactory.getCurrentSession().createQuery("from Allergy a where a.uuid = :uuid")
				.setString("uuid", uuid).uniqueResult();
	}
    @Override
    public Allergy saveAllergy(Allergy allergy) {
    	sessionFactory.getCurrentSession().save(allergy);
    	return allergy;
    }
    public List<PatientIdentifier> getPatientIdentifierByProgram(PatientProgram patientProgram) {
        Criteria criteria = sessionFactory.getCurrentSession().createCriteria(PatientIdentifier.class);
        criteria.add(Restrictions.eq("patientProgram", patientProgram));
        return criteria.list();
    }
}
package org.openmrs.api.db.hibernate;
import javax.persistence.Query;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.FlushMode;
import org.hibernate.type.StandardBasicTypes;
import org.openmrs.Cohort;
import org.openmrs.Concept;
import org.openmrs.ConceptStateConversion;
import org.openmrs.Patient;
import org.openmrs.PatientProgram;
import org.openmrs.PatientProgramAttribute;
import org.openmrs.PatientState;
import org.openmrs.Program;
import org.openmrs.ProgramAttributeType;
import org.openmrs.ProgramWorkflow;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.api.db.DAOException;
import org.openmrs.api.db.ProgramWorkflowDAO;
import org.openmrs.customdatatype.CustomDatatypeUtil;
public class HibernateProgramWorkflowDAO implements ProgramWorkflowDAO {
	private SessionFactory sessionFactory;
	public HibernateProgramWorkflowDAO() {
	}
	public void setSessionFactory(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}
	@Override
	public Program saveProgram(Program program) throws DAOException {
		sessionFactory.getCurrentSession().saveOrUpdate(program);
		return program;
	}
	@Override
	public Program getProgram(Integer programId) throws DAOException {
		return sessionFactory.getCurrentSession().get(Program.class, programId);
	}
	@Override
	public List<Program> getAllPrograms(boolean includeRetired) throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Program> cq = cb.createQuery(Program.class);
		Root<Program> root = cq.from(Program.class);
		if (!includeRetired) {
			cq.where(cb.isFalse(root.get("retired")));
		}
		return session.createQuery(cq).getResultList();
	}
	@Override
	public List<Program> getProgramsByName(String programName, boolean includeRetired) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Program> cq = cb.createQuery(Program.class);
		Root<Program> root = cq.from(Program.class);
		List<Predicate> predicates = new ArrayList<>();
		predicates.add(cb.equal(root.get("name"), programName));
		if (!includeRetired) {
			predicates.add(cb.isFalse(root.get("retired")));
		}
		cq.where(cb.and(predicates.toArray(new Predicate[]{})));
		return session.createQuery(cq).getResultList();
	}
	@Override
	public List<Program> findPrograms(String nameFragment) throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Program> cq = cb.createQuery(Program.class);
		Root<Program> root = cq.from(Program.class);
		Predicate nameLike = cb.like(cb.lower(root.get("name")), MatchMode.ANYWHERE.toLowerCasePattern(nameFragment));
		cq.where(nameLike).orderBy(cb.asc(root.get("name")));
		return session.createQuery(cq).getResultList();
	}
	@Override
	public void deleteProgram(Program program) throws DAOException {
		sessionFactory.getCurrentSession().delete(program);
	}
	@Override
	public PatientProgram savePatientProgram(PatientProgram patientProgram) throws DAOException {
                CustomDatatypeUtil.saveAttributesIfNecessary(patientProgram);
		if (patientProgram.getPatientProgramId() == null) {
			sessionFactory.getCurrentSession().save(patientProgram);
		} else {
			sessionFactory.getCurrentSession().merge(patientProgram);
		}
		return patientProgram;
	}
	@Override
	public PatientProgram getPatientProgram(Integer patientProgramId) throws DAOException {
		return sessionFactory.getCurrentSession().get(PatientProgram.class, patientProgramId);
	}
	@Override
	public List<PatientProgram> getPatientPrograms(Patient patient, Program program, Date minEnrollmentDate,
												   Date maxEnrollmentDate, Date minCompletionDate, Date maxCompletionDate, boolean includeVoided)
		throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<PatientProgram> cq = cb.createQuery(PatientProgram.class);
		Root<PatientProgram> root = cq.from(PatientProgram.class);
		List<Predicate> predicates = new ArrayList<>();
		if (patient != null) {
			predicates.add(cb.equal(root.get("patient"), patient));
		}
		if (program != null) {
			predicates.add(cb.equal(root.get("program"), program));
		}
		if (minEnrollmentDate != null) {
			predicates.add(cb.greaterThanOrEqualTo(root.get("dateEnrolled"), minEnrollmentDate));
		}
		if (maxEnrollmentDate != null) {
			predicates.add(cb.lessThanOrEqualTo(root.get("dateEnrolled"), maxEnrollmentDate));
		}
		if (minCompletionDate != null) {
			predicates.add(cb.or(
				cb.isNull(root.get("dateCompleted")),
				cb.greaterThanOrEqualTo(root.get("dateCompleted"), minCompletionDate)
			));
		}
		if (maxCompletionDate != null) {
			predicates.add(cb.lessThanOrEqualTo(root.get("dateCompleted"), maxCompletionDate));
		}
		if (!includeVoided) {
			predicates.add(cb.isFalse(root.get("voided")));
		}
		cq.where(cb.and(predicates.toArray(new Predicate[]{})))
			.orderBy(cb.asc(root.get("dateEnrolled")));
		return session.createQuery(cq).getResultList();
	}
	@Override
	@SuppressWarnings("unchecked")
	public List<PatientProgram> getPatientPrograms(Cohort cohort, Collection<Program> programs) {
		String hql = "from PatientProgram ";
		if (cohort != null || programs != null) {
			hql += "where ";
		}
		if (cohort != null) {
			hql += "patient.patientId in (:patientIds) ";
		}
		if (programs != null) {
			if (cohort != null) {
				hql += "and ";
			}
			hql += " program in (:programs)";
		}
		hql += " order by patient.patientId, dateEnrolled";
		Query query = sessionFactory.getCurrentSession().createQuery(hql);
		if (cohort != null) {
			query.setParameter("patientIds", cohort.getMemberIds());
		}
		if (programs != null) {
			query.setParameter("programs", programs);
		}
		return query.getResultList();
	}
	@Override
	public void deletePatientProgram(PatientProgram patientProgram) throws DAOException {
		sessionFactory.getCurrentSession().delete(patientProgram);
	}
	@Override
	public ConceptStateConversion saveConceptStateConversion(ConceptStateConversion csc) throws DAOException {
		if (csc.getConceptStateConversionId() == null) {
			sessionFactory.getCurrentSession().save(csc);
		} else {
			sessionFactory.getCurrentSession().merge(csc);
		}
		return csc;
	}
	@Override
	public List<ConceptStateConversion> getAllConceptStateConversions() throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<ConceptStateConversion> cq = cb.createQuery(ConceptStateConversion.class);
		cq.from(ConceptStateConversion.class);
		return session.createQuery(cq).getResultList();
	}
	@Override
	public ConceptStateConversion getConceptStateConversion(Integer conceptStateConversionId) {
		return sessionFactory.getCurrentSession().get(ConceptStateConversion.class,
		    conceptStateConversionId);
	}
	@Override
	public void deleteConceptStateConversion(ConceptStateConversion csc) {
		sessionFactory.getCurrentSession().delete(csc);
	}
	@Override
	public ConceptStateConversion getConceptStateConversion(ProgramWorkflow workflow, Concept trigger) {
		if (workflow == null || trigger == null) {
			return null;
		}
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<ConceptStateConversion> cq = cb.createQuery(ConceptStateConversion.class);
		Root<ConceptStateConversion> root = cq.from(ConceptStateConversion.class);
		cq.where(cb.and(
			cb.equal(root.get("programWorkflow"), workflow),
			cb.equal(root.get("concept"), trigger)
		));
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public ConceptStateConversion getConceptStateConversionByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, ConceptStateConversion.class, uuid);
	}
	@Override
	public PatientProgram getPatientProgramByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, PatientProgram.class, uuid);
	}
	@Override
	public Program getProgramByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, Program.class, uuid);
	}
	@Override
	public ProgramWorkflowState getState(Integer stateId) {
		return sessionFactory.getCurrentSession().get(ProgramWorkflowState.class, stateId);
	}
	@Override
	public ProgramWorkflowState getStateByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, ProgramWorkflowState.class, uuid);
	}
	@Override
	public PatientState getPatientStateByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, PatientState.class, uuid);
	}
	@Override
	public ProgramWorkflow getWorkflow(Integer workflowId) {
		return sessionFactory.getCurrentSession().get(ProgramWorkflow.class, workflowId);
	}
	@Override
	public ProgramWorkflow getWorkflowByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, ProgramWorkflow.class, uuid);
	}
	@Override
	public List<Program> getProgramsByConcept(Concept concept) {
		String pq = "select distinct p from Program p where p.concept = :concept";
		Query pquery = sessionFactory.getCurrentSession().createQuery(pq);
		pquery.setParameter("concept", concept);
		return pquery.getResultList();
	}
	@Override
	public List<ProgramWorkflow> getProgramWorkflowsByConcept(Concept concept) {
		String wq = "select distinct w from ProgramWorkflow w where w.concept = :concept";
		Query wquery = sessionFactory.getCurrentSession().createQuery(wq);
		wquery.setParameter("concept", concept);
		return wquery.getResultList();
	}
	@Override
	public List<ProgramWorkflowState> getProgramWorkflowStatesByConcept(Concept concept) {
		String sq = "select distinct s from ProgramWorkflowState s where s.concept = :concept";
		Query squery = sessionFactory.getCurrentSession().createQuery(sq);
		squery.setParameter("concept", concept);
		return squery.getResultList();
	}
	@Override
	public List<ProgramAttributeType> getAllProgramAttributeTypes() {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<ProgramAttributeType> cq = cb.createQuery(ProgramAttributeType.class);
		cq.from(ProgramAttributeType.class);
		return session.createQuery(cq).getResultList();
	}
	@Override
	public ProgramAttributeType getProgramAttributeType(Integer id) {
		return sessionFactory.getCurrentSession().get(ProgramAttributeType.class, id);
	}
	@Override
	public ProgramAttributeType getProgramAttributeTypeByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, ProgramAttributeType.class, uuid);
	}
	@Override
	public ProgramAttributeType saveProgramAttributeType(ProgramAttributeType programAttributeType) {
		sessionFactory.getCurrentSession().saveOrUpdate(programAttributeType);
		return programAttributeType;
	}
	@Override
	public PatientProgramAttribute getPatientProgramAttributeByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, PatientProgramAttribute.class, uuid);
	}
	@Override
	public void purgeProgramAttributeType(ProgramAttributeType type) {
		sessionFactory.getCurrentSession().delete(type);
	}
	@Override
	public List<PatientProgram> getPatientProgramByAttributeNameAndValue(String attributeName, String attributeValue) {
		FlushMode flushMode = sessionFactory.getCurrentSession().getHibernateFlushMode();
		sessionFactory.getCurrentSession().setHibernateFlushMode(FlushMode.MANUAL);
		Query query;
		try {
			query = sessionFactory.getCurrentSession().createQuery(
					"SELECT pp FROM patient_program pp " +
							"INNER JOIN pp.attributes attr " +
							"INNER JOIN attr.attributeType attr_type " +
							"WHERE attr.valueReference = :attributeValue " +
							"AND attr_type.name = :attributeName " +
							"AND pp.voided = 0")
					.setParameter("attributeName", attributeName)
					.setParameter("attributeValue", attributeValue);
			return query.getResultList();
		} finally {
			sessionFactory.getCurrentSession().setHibernateFlushMode(flushMode);
		}
	}
	@Override
	public Map<Object, Object> getPatientProgramAttributeByAttributeName(List<Integer> patientIds, String attributeName) {
		Map<Object, Object> patientProgramAttributes = new HashMap<>();
		if (patientIds.isEmpty() || attributeName == null) {
			return patientProgramAttributes;
		}
		String commaSeperatedPatientIds = StringUtils.join(patientIds, ",");
		List<Object> list = sessionFactory.getCurrentSession().createSQLQuery(
				"SELECT p.patient_id as person_id, " +
						" concat('{',group_concat(DISTINCT (coalesce(concat('\"',ppt.name,'\":\"', COALESCE (cn.name, ppa.value_reference),'\"'))) SEPARATOR ','),'}') AS patientProgramAttributeValue  " +
						" from patient p " +
						" join patient_program pp on p.patient_id = pp.patient_id and p.patient_id in (" + commaSeperatedPatientIds + ")" +
						" join patient_program_attribute ppa on pp.patient_program_id = ppa.patient_program_id and ppa.voided=0" +
						" join program_attribute_type ppt on ppa.attribute_type_id = ppt.program_attribute_type_id and ppt.name ='" + attributeName + "' "+
						" LEFT OUTER JOIN concept_name cn on ppa.value_reference = cn.concept_id and cn.concept_name_type= 'FULLY_SPECIFIED' and cn.voided=0 and ppt.datatype like '%ConceptDataType%'" +
						" group by p.patient_id")
				.addScalar("person_id", StandardBasicTypes.INTEGER)
				.addScalar("patientProgramAttributeValue", StandardBasicTypes.STRING)
				.list();
		for (Object o : list) {
			Object[] arr = (Object[]) o;
			patientProgramAttributes.put(arr[0], arr[1]);
		}
		return patientProgramAttributes;
	}
}