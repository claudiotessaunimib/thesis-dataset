package com.jcabi.github;import com.google.common.base.Optional;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.text.ParseException;import java.util.Date;import javax.json.JsonObject;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@SuppressWarnings("PMD.TooManyMethods")public interface Event extends Comparable<Event>, JsonReadable {    String CLOSED = "closed";    String REOPENED = "reopened";    String SUBSCRIBED = "subscribed";    String MERGED = "merged";    String REFERENCED = "referenced";    String MENTIONED = "mentioned";    String ASSIGNED = "assigned";    String UNASSIGNED = "unassigned";    String LABELED = "labeled";    String UNLABELED = "unlabeled";    String MILESTONED = "milestoned";    String DEMILESTONED = "demilestoned";    String RENAMED = "renamed";    String LOCKED = "locked";    String UNLOCKED = "unlocked";    String HEAD_REF_DELETED = "head_ref_deleted";    String HEAD_REF_RESTORED = "head_ref_restored";    Repo repo();    int number();    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = { "event", "jsn" })    final class Smart implements Event {        private final transient Event event;        private final transient SmartJson jsn;        public Smart(final Event evt) {            this.event = evt;            this.jsn = new SmartJson(evt);        }        public boolean hasAuthor() throws IOException {            return !this.event.json().isNull("actor");        }        public User author() throws IOException {            return this.event.repo().github().users().get(                this.event.json().getJsonObject("actor").getString("login")            );        }        public String type() throws IOException {            return this.jsn.text("event");        }        public URL url() throws IOException {            try {                return new URI(this.jsn.text("url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public Date createdAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("created_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public Optional<Label> label() throws IOException {            Optional<Label> lab = Optional.absent();            final JsonObject lbl = this.jsn.json().getJsonObject("label");            if (lbl != null) {                lab = Optional.of(                    this.event.repo()                        .labels()                        .get(lbl.getString("name"))                );            }            return lab;        }        @Override        public Repo repo() {            return this.event.repo();        }        @Override        public int number() {            return this.event.number();        }        @Override        public JsonObject json() throws IOException {            return this.event.json();        }        @Override        public int compareTo(final Event obj) {            return this.event.compareTo(obj);        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.text.ParseException;import java.util.Date;import javax.json.JsonObject;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@SuppressWarnings({"PMD.TooManyMethods", "PMD.ExcessivePublicCount",    "PMD.GodClass" })public interface User extends JsonReadable, JsonPatchable {    Github github();    String login() throws IOException;    UserOrganizations organizations();    PublicKeys keys();    UserEmails emails();    Notifications notifications() throws IOException;    void markAsRead(final Date lastread) throws IOException;    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = { "user", "jsn" })    final class Smart implements User {        private final transient User user;        private final transient SmartJson jsn;        public Smart(final User usr) {            this.user = usr;            this.jsn = new SmartJson(usr);        }        public boolean exists() throws IOException {            return new Existence(this.user).check();        }        @SuppressWarnings("PMD.ShortMethodName")        public int id() throws IOException {            return this.user.json().getJsonNumber("id").intValue();        }        public URL avatarUrl() throws IOException {            try {                return new URI(this.jsn.text("avatar_url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public URL url() throws IOException {            try {                return new URI(this.jsn.text("url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public String name() throws IOException {            final JsonObject json = this.json();            if (!json.containsKey("name")) {                throw new IllegalStateException(                    String.format(                        "User %s doesn't have a name specified in his/her Github account; use #hasName() first.",                        this.login()                    )                );            }            return json.getString("name");        }        public boolean hasName() throws IOException {            return this.json().containsKey("name");        }        public String company() throws IOException {            return this.jsn.text("company");        }        public String location() throws IOException {            return this.jsn.text("location");        }        public String email() throws IOException {            return this.jsn.text("email");        }        @Override        public Github github() {            return this.user.github();        }        @Override        public String login() throws IOException {            return this.user.login();        }        @Override        public UserOrganizations organizations() {            return this.user.organizations();        }        @Override        public PublicKeys keys() {            return this.user.keys();        }        @Override        public UserEmails emails() {            return this.user.emails();        }        @Override        public Notifications notifications() throws IOException {            return this.user.notifications();        }        @Override        public void markAsRead(final Date lastread) throws IOException {            this.user.markAsRead(lastread);        }        @Override        public JsonObject json() throws IOException {            return this.user.json();        }        @Override        public void patch(            final JsonObject json        ) throws IOException {            this.user.patch(json);        }        public String htmlUrl() throws IOException {            return this.jsn.text("html_url");        }        public String followersUrl() throws IOException {            return this.jsn.text("followers_url");        }        public String followingUrl() throws IOException {            return this.jsn.text("following_url");        }        public String gistsUrl() throws IOException {            return this.jsn.text("gists_url");        }        public String starredUrl() throws IOException {            return this.jsn.text("starred_url");        }        public String subscriptionsUrl() throws IOException {            return this.jsn.text("subscriptions_url");        }        public String organizationsUrl() throws IOException {            return this.jsn.text("organizations_url");        }        public String reposUrl() throws IOException {            return this.jsn.text("repos_url");        }        public String eventsUrl() throws IOException {            return this.jsn.text("events_url");        }        public String receivedEventsUrl() throws IOException {            return this.jsn.text("received_events_url");        }        public String type() throws IOException {            return this.jsn.text("type");        }        public boolean siteAdmin() throws IOException {            return "true".equals(this.jsn.text("site_admin"));        }        public String blog() throws IOException {            return this.jsn.text("blog");        }        public boolean hireable() throws IOException {            return "true".equals(this.jsn.text("hireable"));        }        public String bio() throws IOException {            return this.jsn.text("bio");        }        public int publicRepos() throws IOException {            return Integer.parseInt(this.jsn.text("public_repos"));        }        public int publicGists() throws IOException {            return Integer.parseInt(this.jsn.text("public_gists"));        }        public int followersCount() throws IOException {            return Integer.parseInt(this.jsn.text("followers"));        }        public int followingCount() throws IOException {            return Integer.parseInt(this.jsn.text("following"));        }        public Github.Time created() throws IOException {            try {                return new Github.Time(this.jsn.text("created_at"));            } catch (final ParseException ex) {                throw new IllegalArgumentException(                    "Cannot parse value of 'created_at' property",                    ex                );            }        }        public Github.Time updated() throws IOException {            try {                return new Github.Time(this.jsn.text("updated_at"));            } catch (final ParseException ex) {                throw new IllegalArgumentException(                    "Cannot parse value of 'updated_at' property",                    ex                );            }        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import java.io.StringReader;import javax.json.Json;import javax.json.JsonObject;import lombok.EqualsAndHashCode;import lombok.ToString;import org.apache.commons.lang3.builder.CompareToBuilder;@Immutable@SuppressWarnings("PMD.TooManyMethods")public interface Label extends Comparable<Label>, JsonReadable, JsonPatchable {    Repo repo();    String name();    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = { "label", "jsn" })    final class Smart implements Label {        private final transient Label label;        private final transient SmartJson jsn;        public Smart(final Label lbl) {            this.label = lbl;            this.jsn = new SmartJson(lbl);        }        public String color() throws IOException {            return this.jsn.text("color");        }        public void color(final String color) throws IOException {            this.label.patch(                Json.createObjectBuilder().add("color", color).build()            );        }        @Override        public Repo repo() {            return this.label.repo();        }        @Override        public String name() {            return this.label.name();        }        @Override        public int compareTo(final Label lbl) {            return this.label.compareTo(lbl);        }        @Override        public void patch(final JsonObject json) throws IOException {            this.label.patch(json);        }        @Override        public JsonObject json() throws IOException {            return this.label.json();        }    }    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = { "repo", "obj" })    final class Unmodified implements Label {        private final transient Repo repo;        private final transient String obj;        public Unmodified(            final Repo rep, final String object        ) {            this.repo = rep;            this.obj = object;        }        @Override        public Repo repo() {            return this.repo;        }        @Override        public String name() {            return this.json().getString("name");        }        @Override        public int compareTo(final Label label) {            return new CompareToBuilder()                .append(this.repo().coordinates(), label.repo().coordinates())                .append(this.obj, label.name())                .build();        }        @Override        public void patch(final JsonObject json) {            throw new UnsupportedOperationException("#patch()");        }        @Override        public JsonObject json() {            return Json.createReader(new StringReader(this.obj)).readObject();        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import java.util.EnumMap;@Immutable@SuppressWarnings("PMD.AvoidDuplicateLiterals")public interface Search {    Github github();    Iterable<Repo> repos(        String keywords,        String sort,        Order order    );    Iterable<Issue> issues(        String keywords,        String sort,        Order order,        EnumMap<Qualifier, String> qualifiers);    Iterable<User> users(        String keywords,        String sort,        Order order);    Iterable<Content> codes(        String keywords,        String sort,        Order order);    enum Qualifier implements StringEnum {        TYPE("type"),        IN("in"),        AUTHOR("author"),        ASSIGNEE("assignee"),        MENTIONS("mentions"),        COMMENTER("commenter"),        INVOLVES("involves"),        TEAM("team"),        STATE("state"),        LABEL("label"),        NO("no"),        LANGUAGE("language"),        IS("is"),        CREATED("created"),        UPDATED("updated"),        MERGED("merged"),        CLOSED("closed"),        COMMENTS("comments"),        USER("user"),        REPO("repo");        private final transient String qualifier;        Qualifier(final String key) {            this.qualifier = key;        }        @Override        public String identifier() {            return this.qualifier;        }    }    enum Order implements StringEnum {        ASC("asc"),        DESC("desc");        private final transient String order;        Order(final String key) {            this.order = key;        }        @Override        public String identifier() {            return this.order;        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.http.Request;import java.io.IOException;import java.text.DateFormat;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Locale;import java.util.TimeZone;import javax.json.JsonObject;import lombok.EqualsAndHashCode;@Immutable@SuppressWarnings("PMD.TooManyMethods")public interface Github {    Request entry();    Repos repos();    Gists gists();    Users users();    Organizations organizations();    Markdown markdown();    Limits limits();    Search search();    Gitignores gitignores();    JsonObject meta() throws IOException;    JsonObject emojis() throws IOException;    @Immutable    @EqualsAndHashCode(of = { "msec" })    final class Time {        public static final String FORMAT_ISO = "yyyy-MM-dd'T'HH:mm:ss'Z'";        public static final TimeZone TIMEZONE = TimeZone.getTimeZone("UTC");        private final transient long msec;        public Time() {            this(new Date());        }        public Time(final String text) throws ParseException {            this(Github.Time.format().parse(text));        }        public Time(final Date date) {            this(date.getTime());        }        public Time(final long millis) {            this.msec = millis;        }        @Override        public String toString() {            return Github.Time.format().format(this.date());        }        public Date date() {            return new Date(this.msec);        }        private static DateFormat format() {            final DateFormat fmt = new SimpleDateFormat(                Github.Time.FORMAT_ISO, Locale.ENGLISH            );            fmt.setTimeZone(Github.Time.TIMEZONE);            return fmt;        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import javax.json.JsonObject;import javax.json.JsonValue;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@SuppressWarnings({"PMD.TooManyMethods", "PMD.ExcessivePublicCount"})public interface Repo extends JsonReadable, JsonPatchable, Comparable<Repo> {    Github github();    Coordinates coordinates();    Issues issues();    Milestones milestones();    Pulls pulls();    Hooks hooks();    IssueEvents issueEvents();    Labels labels();    Assignees assignees();    Releases releases();    DeployKeys keys();    Forks forks();    RepoCommits commits();    Branches branches();    Contents contents();    Collaborators collaborators();    Git git();    Stars stars();    Notifications notifications();    Iterable<Language> languages() throws IOException;    Branch defaultBranch() throws IOException;    Stargazers stargazers();    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = {"repo", "jsn"})    final class Smart implements Repo {        private final transient Repo repo;        private final transient SmartJson jsn;        public Smart(            final Repo rep        ) {            this.repo = rep;            this.jsn = new SmartJson(rep);        }        public boolean exists() throws IOException {            return new Existence(this.repo).check();        }        public boolean hasDescription() throws IOException {            return this.jsn.hasNotNull("description");        }        public String description() throws IOException {            return this.jsn.text("description");        }        public boolean isPrivate() throws IOException {            return Boolean.parseBoolean(                this.json()                    .getOrDefault("private", JsonValue.FALSE)                    .toString().replace("\"", "")            );        }        @Override        public Github github() {            return this.repo.github();        }        @Override        public Coordinates coordinates() {            return this.repo.coordinates();        }        @Override        public Issues issues() {            return this.repo.issues();        }        @Override        public Milestones milestones() {            return this.repo.milestones();        }        @Override        public Pulls pulls() {            return this.repo.pulls();        }        @Override        public Hooks hooks() {            return this.repo.hooks();        }        @Override        public IssueEvents issueEvents() {            return this.repo.issueEvents();        }        @Override        public Labels labels() {            return this.repo.labels();        }        @Override        public Assignees assignees() {            return this.repo.assignees();        }        @Override        public Releases releases() {            return this.repo.releases();        }        @Override        public DeployKeys keys() {            return this.repo.keys();        }        @Override        public Forks forks() {            return this.repo.forks();        }        @Override        public Contents contents() {            return this.repo.contents();        }        @Override        public Collaborators collaborators() {            return this.repo.collaborators();        }        @Override        public Git git() {            return this.repo.git();        }        @Override        public Stars stars() {            return this.repo.stars();        }        @Override        public Notifications notifications() {            return this.repo.notifications();        }        @Override        public Iterable<Language> languages() throws IOException {            return this.repo.languages();        }        @Override        public Branch defaultBranch() throws IOException {            return this.repo.defaultBranch();        }        @Override        public Stargazers stargazers() {            throw new UnsupportedOperationException(                "stargazers() not yet implemented"            );        }        @Override        public void patch(            final JsonObject json        ) throws IOException {            this.repo.patch(json);        }        @Override        public RepoCommits commits() {            return this.repo.commits();        }        @Override        public Branches branches() {            return this.repo.branches();        }        @Override        public JsonObject json() throws IOException {            return this.repo.json();        }        @Override        public int compareTo(final Repo repos) {            return this.repo.compareTo(repos);        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.text.ParseException;import java.util.Date;import javax.json.Json;import javax.json.JsonObject;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@SuppressWarnings("PMD.TooManyMethods")public interface Pull extends Comparable<Pull>, JsonReadable, JsonPatchable {    Repo repo();    int number();    PullRef base() throws IOException;    PullRef head() throws IOException;    Iterable<Commit> commits() throws IOException;    Iterable<JsonObject> files() throws IOException;    void merge(String msg)        throws IOException;    MergeState merge(String msg,        String sha    ) throws IOException;    PullComments comments() throws IOException;    Checks checks() throws IOException;    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = {"pull", "jsn"})    final class Smart implements Pull {        private final transient Pull pull;        private final transient SmartJson jsn;        public Smart(            final Pull pll        ) {            this.pull = pll;            this.jsn = new SmartJson(pll);        }        public boolean isOpen() throws IOException {            return Issue.OPEN_STATE.equals(this.state());        }        public String state() throws IOException {            return this.jsn.text("state");        }        public void state(            final String state        ) throws IOException {            this.pull.patch(                Json.createObjectBuilder().add("state", state).build()            );        }        public String title() throws IOException {            return this.jsn.text("title");        }        public void title(            final String text        ) throws IOException {            this.pull.patch(                Json.createObjectBuilder().add("title", text).build()            );        }        public String body() throws IOException {            return this.jsn.text("body");        }        public void body(            final String text        ) throws IOException {            this.pull.patch(                Json.createObjectBuilder().add("body", text).build()            );        }        public URL url() throws IOException {            try {                return new URI(this.jsn.text("url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public URL htmlUrl() throws IOException {            try {                return new URI(this.jsn.text("html_url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public Date createdAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("created_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public Date updatedAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("updated_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public Date closedAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("closed_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public Date mergedAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("merged_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public User author() throws IOException {            return this.pull.repo().github().users().get(                this.jsn.value(                    "user", JsonObject.class                ).getString("login")            );        }        public Issue issue() {            return this.pull.repo().issues().get(this.pull.number());        }        public int commentsCount() throws IOException {            return this.jsn.number("comments");        }        @Override        public Repo repo() {            return this.pull.repo();        }        @Override        public int number() {            return this.pull.number();        }        @Override        public Iterable<Commit> commits() throws IOException {            return this.pull.commits();        }        @Override        public Iterable<JsonObject> files() throws IOException {            return this.pull.files();        }        @Override        public void merge(            final String msg        ) throws IOException {            this.pull.merge(msg);        }        @Override        public MergeState merge(            final String msg,            final String sha        )            throws IOException {            return this.pull.merge(msg, sha);        }        @Override        public PullComments comments() throws IOException {            return this.pull.comments();        }        @Override        public Checks checks() throws IOException {            return this.pull.checks();        }        @Override        public JsonObject json() throws IOException {            return this.pull.json();        }        @Override        public void patch(            final JsonObject json        ) throws IOException {            this.pull.patch(json);        }        @Override        public int compareTo(            final Pull obj        ) {            return this.pull.compareTo(obj);        }        @Override        public PullRef base() throws IOException {            return this.pull.base();        }        @Override        public PullRef head() throws IOException {            return this.pull.head();        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import javax.json.JsonNumber;import javax.json.JsonObject;import javax.json.JsonString;import javax.json.JsonValue;import javax.json.JsonValue.ValueType;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@ToString@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = "object")@SuppressWarnings("PMD.AvoidDuplicateLiterals")final class SmartJson {    private final transient JsonReadable object;    SmartJson(final JsonReadable obj) {        this.object = obj;    }    public String text(        final String name    ) throws IOException {        return this.value(name, JsonString.class).getString();    }    public int number(        final String name    ) throws IOException {        return this.value(name, JsonNumber.class).intValue();    }    public JsonObject json() throws IOException {        return this.object.json();    }    public <T> T value(        final String name,        final Class<T> type    ) throws IOException {        final JsonObject json = this.json();        if (!json.containsKey(name)) {            throw new IllegalStateException(                String.format(                    "'%s' is absent in JSON: %s", name, json                )            );        }        final JsonValue value = json.get(name);        if (value == null) {            throw new IllegalStateException(                String.format(                    "'%s' is NULL in %s", name, json                )            );        }        if (value.getClass().isAssignableFrom(type)) {            throw new IllegalStateException(                String.format(                    "'%s' is not of type %s", name, type                )            );        }        return type.cast(value);    }    public boolean hasNotNull(        final String name    ) throws IOException {        final JsonValue value = this.object.json().get(name);        return value != null            && !ValueType.NULL.equals(value.getValueType());    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.text.ParseException;import java.util.ArrayList;import java.util.Collection;import java.util.Date;import javax.json.Json;import javax.json.JsonArray;import javax.json.JsonObject;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@SuppressWarnings    (        {            "PMD.TooManyMethods", "PMD.GodClass", "PMD.ExcessivePublicCount"        }    )public interface Issue extends Comparable<Issue>, JsonReadable, JsonPatchable {    String OPEN_STATE = "open";    String CLOSED_STATE = "closed";    Repo repo();    int number();    Comments comments();    IssueLabels labels();    Iterable<Event> events() throws IOException;    boolean exists() throws IOException;    void react(Reaction reaction) throws IOException;    Iterable<Reaction> reactions();    void lock(String reason);    void unlock();    boolean isLocked();    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = {"issue", "jsn"})    final class Smart implements Issue {        private final transient Issue issue;        private final transient SmartJson jsn;        public Smart(final Issue iss) {            this.issue = iss;            this.jsn = new SmartJson(iss);        }        public User author() throws IOException {            return this.issue.repo().github().users().get(                this.jsn.value(                    "user", JsonObject.class                ).getString("login")            );        }        public boolean isOpen() throws IOException {            return Issue.OPEN_STATE.equals(this.state());        }        public void open() throws IOException {            this.state(Issue.OPEN_STATE);        }        public void close() throws IOException {            this.state(Issue.CLOSED_STATE);        }        public String state() throws IOException {            return this.jsn.text("state");        }        public void state(final String state) throws IOException {            this.issue.patch(                Json.createObjectBuilder().add("state", state).build()            );        }        public String title() throws IOException {            return this.jsn.text("title");        }        public void title(final String text) throws IOException {            this.issue.patch(                Json.createObjectBuilder().add("title", text).build()            );        }        public String body() throws IOException {            return this.jsn.text("body");        }        public void body(final String text) throws IOException {            this.issue.patch(                Json.createObjectBuilder().add("body", text).build()            );        }        public boolean hasBody() throws IOException {            return this.jsn.hasNotNull("body");        }        public boolean hasAssignee() throws IOException {            return this.jsn.hasNotNull("assignee");        }        public User assignee() throws IOException {            if (!this.hasAssignee()) {                throw new IllegalArgumentException(                    String.format(                        "issue #%d doesn't have an assignee, use hasAssignee()",                        this.number()                    )                );            }            return this.issue.repo().github().users().get(                this.jsn.value(                    "assignee", JsonObject.class                ).getString("login")            );        }        public void assign(final String login) throws IOException {            this.issue.patch(                Json.createObjectBuilder().add("assignee", login).build()            );        }        public URL url() throws IOException {            try {                return new URI(this.jsn.text("url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public URL htmlUrl() throws IOException {            try {                return new URI(this.jsn.text("html_url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public Date createdAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("created_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public Date closedAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("closed_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public Date updatedAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("updated_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public boolean isPull() throws IOException {            return this.json().containsKey("pull_request")                && !this.jsn.value("pull_request", JsonObject.class)                .isNull("html_url");        }        public Pull pull() throws IOException {            final String url = this.jsn.value(                "pull_request", JsonObject.class            ).getString("html_url");            return this.issue.repo().pulls().get(                Integer.parseInt(url.substring(url.lastIndexOf('/') + 1))            );        }        public Event latestEvent(final String type) throws IOException {            final Iterable<Event.Smart> events = new Smarts<>(                this.issue.events()            );            Event found = null;            for (final Event.Smart event : events) {                if (event.type().equals(type) && (found == null                    || found.number() < event.number())) {                    found = event;                }            }            if (found == null) {                throw new IllegalStateException(                    String.format(                        "event of type '%s' not found in issue #%d",                        type, this.issue.number()                    )                );            }            return found;        }        public IssueLabels roLabels() throws IOException {            final Collection<JsonObject> array =                this.jsn.value("labels", JsonArray.class)                    .getValuesAs(JsonObject.class);            final Collection<Label> labels = new ArrayList<>(array.size());            for (final JsonObject obj : array) {                labels.add(                    new Label.Unmodified(                        this.repo(),                        obj.toString()                    )                );            }            return new IssueLabels() {                @Override                public Issue issue() {                    return Issue.Smart.this;                }                @Override                public void add(                    final Iterable<String> labels) {                    throw new UnsupportedOperationException(                        "The issue is read-only."                    );                }                @Override                public void replace(                    final Iterable<String> labels) {                    throw new UnsupportedOperationException(                        "The issue is read-only."                    );                }                @Override                public Iterable<Label> iterate() {                    return labels;                }                @Override                public void remove(                    final String name) {                    throw new UnsupportedOperationException(                        "This issue is read-only."                    );                }                @Override                public void clear() {                    throw new UnsupportedOperationException(                        "This issue is read-only."                    );                }            };        }        public boolean hasMilestone() throws IOException {            return this.jsn.hasNotNull("milestone");        }        public Milestone milestone() throws IOException {            return this.repo().milestones().get(                this.jsn.value("milestone", JsonObject.class)                    .getInt("number")            );        }        public void milestone(final Milestone milestone) throws IOException {            this.patch(                Json.createObjectBuilder().add(                    "milestone", milestone.number()                ).build()            );        }        @Override        public Repo repo() {            return this.issue.repo();        }        @Override        public int number() {            return this.issue.number();        }        @Override        public Comments comments() {            return this.issue.comments();        }        @Override        public IssueLabels labels() {            return this.issue.labels();        }        @Override        public Iterable<Event> events() throws IOException {            return this.issue.events();        }        @Override        public JsonObject json() throws IOException {            return this.issue.json();        }        @Override        public void patch(final JsonObject json) throws IOException {            this.issue.patch(json);        }        @Override        public int compareTo(final Issue obj) {            return this.issue.compareTo(obj);        }        @Override        public boolean exists() throws IOException {            return new Existence(this.issue).check();        }        @Override        public void react(final Reaction reaction) {            throw new UnsupportedOperationException("react() not implemented");        }        @Override        public Collection<Reaction> reactions() {            throw new UnsupportedOperationException(                "reactions() not implemented"            );        }        @Override        public void lock(final String reason) {            throw new UnsupportedOperationException("lock not implemented");        }        @Override        public void unlock() {            throw new UnsupportedOperationException("unlock not implemented");        }        @Override        public boolean isLocked() {            throw new UnsupportedOperationException("isLocked not implemented");        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import java.util.Collection;import java.util.Collections;import java.util.LinkedList;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@SuppressWarnings("PMD.TooManyMethods")public interface IssueLabels {    Issue issue();    void add(Iterable<String> labels) throws IOException;    void replace(Iterable<String> labels) throws IOException;    Iterable<Label> iterate();    void remove(String name) throws IOException;    void clear() throws IOException;    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = "labels")    final class Smart implements IssueLabels {        private final transient IssueLabels labels;        public Smart(final IssueLabels lbl) {            this.labels = lbl;        }        public boolean contains(final String name) {            boolean contains = false;            for (final Label label : this.labels.iterate()) {                if (label.name().equals(name)) {                    contains = true;                    break;                }            }            return contains;        }        public Label get(final String name) {            Label label = null;            int count = 0;            for (final Label opt : this.labels.iterate()) {                if (opt.name().equals(name)) {                    label = opt;                    break;                }                ++count;            }            if (label == null) {                throw new IllegalArgumentException(                    String.format(                        "label '%s' not found among %d others, use #contains() first",                        name, count                    )                );            }            return label;        }        public boolean addIfAbsent(final String name) throws IOException {            final boolean added;            if (this.contains(name)) {                added = false;            } else {                new Labels.Smart(this.labels.issue().repo().labels())                    .createOrGet(name);                this.labels.add(Collections.singletonList(name));                added = true;            }            return added;        }        public boolean addIfAbsent(            final String name, final String color        ) throws IOException {            Label label = null;            for (final Label opt : new Bulk<>(this.labels.iterate())) {                if (opt.name().equals(name)) {                    label = opt;                    break;                }            }            boolean added = false;            if (label == null) {                added = true;                label = new Labels.Smart(this.labels.issue().repo().labels())                    .createOrGet(name, color);                this.labels.add(Collections.singletonList(name));            }            final Label.Smart smart = new Label.Smart(label);            if (!smart.color().equals(color)) {                smart.color(color);            }            return added;        }        public Collection<Label> findByColor(final String color)            throws IOException {            final Collection<Label> found = new LinkedList<>();            for (final Label label : this.labels.iterate()) {                if (new Label.Smart(label).color().equals(color)) {                    found.add(label);                }            }            return found;        }        public boolean removeIfExists(final String name)            throws IOException {            boolean removed = false;            for (final Label label : this.labels.iterate()) {                if (label.name().equals(name)) {                    this.remove(name);                    removed = true;                    break;                }            }            return removed;        }        @Override        public Issue issue() {            return this.labels.issue();        }        @Override        public void add(final Iterable<String> names) throws IOException {            this.labels.add(names);        }        @Override        public void replace(final Iterable<String> names) throws IOException {            this.labels.replace(names);        }        @Override        public Iterable<Label> iterate() {            return this.labels.iterate();        }        @Override        public void remove(final String name) throws IOException {            this.labels.remove(name);        }        @Override        public void clear() throws IOException {            this.labels.clear();        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import java.io.IOException;import java.util.Date;@Immutablepublic interface Comments {    Issue issue();    Comment get(long number);    Iterable<Comment> iterate(Date since);    Comment post(String text) throws IOException;}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.text.ParseException;import java.util.Collection;import java.util.Date;import javax.json.Json;import javax.json.JsonObject;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@SuppressWarnings("PMD.TooManyMethods")public interface Comment    extends Comparable<Comment>, JsonReadable, JsonPatchable {    Issue issue();    long number();    void remove() throws IOException;    void react(Reaction reaction) throws IOException;    Iterable<Reaction> reactions();    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = { "comment", "jsn" })    final class Smart implements Comment {        private final transient Comment comment;        private final transient SmartJson jsn;        public Smart(final Comment cmt) {            this.comment = cmt;            this.jsn = new SmartJson(cmt);        }        public User author() throws IOException {            return this.comment.issue().repo().github().users().get(                this.comment.json().getJsonObject("user").getString("login")            );        }        public String body() throws IOException {            return this.jsn.text("body");        }        public void body(final String text) throws IOException {            this.comment.patch(                Json.createObjectBuilder().add("body", text).build()            );        }        public URL url() throws IOException {            try {                return new URI(this.jsn.text("url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public Date createdAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("created_at")                ).date();            } catch (final ParseException ex) {                throw new IOException(ex);            }        }        public Date updatedAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("updated_at")                ).date();            } catch (final ParseException ex) {                throw new IOException(ex);            }        }        @Override        public Issue issue() {            return this.comment.issue();        }        @Override        public long number() {            return this.comment.number();        }        @Override        public void remove() throws IOException {            this.comment.remove();        }        @Override        public void react(final Reaction reaction) {            throw new UnsupportedOperationException("react() not implemented");        }        @Override        public Collection<Reaction> reactions() {            throw new UnsupportedOperationException(                "reactions() not implemented"            );        }        @Override        public JsonObject json() throws IOException {            return this.comment.json();        }        @Override        public void patch(final JsonObject json) throws IOException {            this.comment.patch(json);        }        @Override        public int compareTo(final Comment obj) {            return this.comment.compareTo(obj);        }    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.http.Request;import com.jcabi.http.response.JsonResponse;import com.jcabi.http.response.RestResponse;import java.io.IOException;import java.net.HttpURLConnection;import java.util.Date;import javax.json.Json;import javax.json.JsonStructure;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = { "request", "owner" })final class RtComments implements Comments {    private final transient Request entry;    private final transient Request request;    private final transient Issue owner;    RtComments(final Request req, final Issue issue) {        this.entry = req;        final Coordinates coords = issue.repo().coordinates();        this.request = this.entry.uri()            .path("/repos")            .path(coords.user())            .path(coords.repo())            .path("/issues")            .path(Integer.toString(issue.number()))            .path("/comments")            .back();        this.owner = issue;    }    @Override    public String toString() {        return this.request.uri().get().toString();    }    @Override    public Issue issue() {        return this.owner;    }    @Override    public Comment get(final long number) {        return new RtComment(this.entry, this.owner, number);    }    @Override    public Comment post(final String text) throws IOException {        final JsonStructure json = Json.createObjectBuilder()            .add("body", text)            .build();        return this.get(            this.request.method(Request.POST)                .body().set(json).back()                .fetch()                .as(RestResponse.class)                .assertStatus(HttpURLConnection.HTTP_CREATED)                .as(JsonResponse.class)                .json().readObject().getJsonNumber("id").longValue()        );    }    @Override    public Iterable<Comment> iterate(final Date since) {        return new RtPagination<>(            this.request.uri()                .queryParam("since", new Github.Time(since))                .back(),            object -> this.get(object.getJsonNumber("id").longValue())        );    }}package com.jcabi.github.safe;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Comment;import com.jcabi.github.Issue;import com.jcabi.github.Reaction;import com.jcabi.github.mock.MkGithub;import com.jcabi.log.Logger;import java.io.IOException;import javax.json.JsonObject;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = "origin")public final class SfComment implements Comment {    private final transient Comment origin;    public SfComment(final Comment cmt) {        this.origin = cmt;    }    @Override    public String toString() {        return this.origin.toString();    }    @Override    public Issue issue() {        return this.origin.issue();    }    @Override    public long number() {        return this.origin.number();    }    @Override    public void remove() throws IOException {        try {            this.origin.remove();        } catch (final AssertionError ex) {            Logger.warn(this, "Failed to remove comment: %[exception]s", ex);        }    }    @Override    public void react(final Reaction reaction) throws IOException {        this.origin.react(reaction);    }    @Override    public Iterable<Reaction> reactions() {        return this.origin.reactions();    }    @Override    public int compareTo(final Comment cmt) {        return this.origin.compareTo(cmt);    }    @Override    public void patch(final JsonObject json) throws IOException {        try {            this.origin.patch(json);        } catch (final AssertionError ex) {            Logger.warn(this, "Failed to path comment: %[exception]s", ex);        }    }    @Override    public JsonObject json() throws IOException {        JsonObject json;        try {            json = this.origin.json();        } catch (final AssertionError ex) {            final String author = new Issue.Smart(                new SfIssue(this.origin.issue())            ).author().login();            json = new MkGithub(author).randomRepo()                .issues().create("", "")                .comments().post("deleted comment").json();            Logger.warn(this, "failed to fetch comment: %[exception]s", ex);        }        return json;    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.http.Request;import com.jcabi.http.response.RestResponse;import java.io.IOException;import java.net.HttpURLConnection;import javax.json.Json;import javax.json.JsonObject;import javax.json.JsonStructure;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = { "request", "owner", "num" })final class RtComment implements Comment {    private static final String CONTENT = "content";    private final transient Request request;    private final transient Issue owner;    private final transient long num;    RtComment(final Request req, final Issue issue, final long number) {        final Coordinates coords = issue.repo().coordinates();        this.request = req.uri()            .path("/repos")            .path(coords.user())            .path(coords.repo())            .path("/issues")            .path("/comments")            .path(Long.toString(number))            .back();        this.owner = issue;        this.num = number;    }    @Override    public String toString() {        return this.request.uri().get().toString();    }    @Override    public Issue issue() {        return this.owner;    }    @Override    public long number() {        return this.num;    }    @Override    public void remove() throws IOException {        this.request.method(Request.DELETE).fetch()            .as(RestResponse.class)            .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);    }    @Override    public JsonObject json() throws IOException {        return new RtJson(this.request).fetch();    }    @Override    public void patch(final JsonObject json) throws IOException {        new RtJson(this.request).patch(json);    }    @Override    public int compareTo(        final Comment comment    ) {        return Long.compare(this.number(), comment.number());    }    @Override    public void react(final Reaction reaction) throws IOException {        final JsonStructure json = Json.createObjectBuilder()            .add(RtComment.CONTENT, reaction.type())            .build();        this.request.method(Request.POST)            .body().set(json).back()            .fetch().as(RestResponse.class)            .assertStatus(HttpURLConnection.HTTP_OK);    }    @Override    public Iterable<Reaction> reactions() {        return new RtPagination<>(            this.request.uri().path("/reactions").back(),            object -> new Reaction.Simple(object.getString(RtComment.CONTENT))        );    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import java.io.IOException;import java.util.EnumMap;import java.util.Map;@Immutablepublic interface Issues {    Repo repo();    Issue get(int number);    Issue create(String title, String body) throws IOException;    Iterable<Issue> iterate(Map<String, String> params);    Iterable<Issue> search(        Sort sort, Search.Order direction,        EnumMap<Qualifier, String> qualifiers);    enum Qualifier implements StringEnum {        MILESTONE("milestone"),        STATE("state"),        ASSIGNEE("assignee"),        CREATOR("creator"),        MENTIONED("mentioned"),        LABELS("labels"),        SINCE("since");        private final transient String qualifier;        Qualifier(final String key) {            this.qualifier = key;        }        @Override        public String identifier() {            return this.qualifier;        }    }    enum Sort implements StringEnum {        CREATED("created"),        UPDATED("updated"),        COMMENTS("comments");        private final transient String sort;        Sort(final String field) {            this.sort = field;        }        @Override        public String identifier() {            return this.sort;        }    }}package com.jcabi.github.safe;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Comments;import com.jcabi.github.Event;import com.jcabi.github.Issue;import com.jcabi.github.IssueLabels;import com.jcabi.github.Reaction;import com.jcabi.github.Repo;import com.jcabi.github.mock.MkGithub;import com.jcabi.log.Logger;import java.io.IOException;import javax.json.JsonObject;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = "origin")@SuppressWarnings("PMD.TooManyMethods")public final class SfIssue implements Issue {    private final transient Issue origin;    public SfIssue(final Issue issue) {        this.origin = issue;    }    @Override    public String toString() {        return this.origin.toString();    }    @Override    public JsonObject json() throws IOException {        JsonObject json;        try {            json = this.origin.json();        } catch (final AssertionError ex) {            json = new MkGithub().randomRepo()                .issues().create("", "").json();            Logger.warn(this, "failed to fetch issue: %[exception]s", ex);        }        return json;    }    @Override    public void patch(final JsonObject json) throws IOException {        try {            this.origin.patch(json);        } catch (final AssertionError ex) {            Logger.warn(this, "failed to patch issue: %[exception]s", ex);        }    }    @Override    public Repo repo() {        return this.origin.repo();    }    @Override    public int number() {        return this.origin.number();    }    @Override    public Comments comments() {        return new SfComments(this.origin.comments());    }    @Override    public IssueLabels labels() {        return this.origin.labels();    }    @Override    public Iterable<Event> events() throws IOException {        return this.origin.events();    }    @Override    public boolean exists() throws IOException {        return this.origin.exists();    }    @Override    public int compareTo(final Issue issue) {        return this.origin.compareTo(issue);    }    @Override    public void react(final Reaction reaction) throws IOException {        this.origin.react(reaction);    }    @Override    public Iterable<Reaction> reactions() {        return this.origin.reactions();    }    @Override    public void lock(final String reason) {        this.origin.lock(reason);    }    @Override    public void unlock() {        this.origin.unlock();    }    @Override    public boolean isLocked() {        return this.origin.isLocked();    }}package com.jcabi.github.safe;import com.google.common.collect.Iterables;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Comment;import com.jcabi.github.Comments;import com.jcabi.github.Issue;import com.jcabi.github.mock.MkGithub;import com.jcabi.log.Logger;import java.io.IOException;import java.util.Date;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = "origin")public final class SfComments implements Comments {    private final transient Comments origin;    public SfComments(final Comments cmt) {        this.origin = cmt;    }    @Override    public String toString() {        return this.origin.toString();    }    @Override    public Issue issue() {        return this.origin.issue();    }    @Override    public Comment get(final long number) {        return new SfComment(this.origin.get(number));    }    @Override    public Iterable<Comment> iterate(final Date since) {        return Iterables.transform(            this.origin.iterate(since),            input -> new SfComment(input)        );    }    @Override    public Comment post(final String text) throws IOException {        Comment cmt;        try {            cmt = this.origin.post(text);        } catch (final AssertionError ex) {            Logger.warn(this, "Failed to post to GitHub: %[exception]s", ex);            cmt = new MkGithub().randomRepo()                .issues().create("", "")                .comments().post(text);        }        return cmt;    }}package com.jcabi.github.mock;import com.google.common.base.Optional;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Comments;import com.jcabi.github.Coordinates;import com.jcabi.github.Event;import com.jcabi.github.Issue;import com.jcabi.github.IssueLabels;import com.jcabi.github.Label;import com.jcabi.github.Reaction;import com.jcabi.github.Repo;import com.jcabi.xml.XML;import java.io.IOException;import java.util.Collection;import java.util.Map;import javax.json.Json;import javax.json.JsonArrayBuilder;import javax.json.JsonObject;import javax.json.JsonObjectBuilder;import javax.json.JsonValue;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = { "storage", "self", "coords", "num" })@SuppressWarnings("PMD.TooManyMethods")final class MkIssue implements Issue {    private final transient MkStorage storage;    private final transient String self;    private final transient Coordinates coords;    private final transient int num;    MkIssue(        final MkStorage stg,        final String login,        final Coordinates rep,        final int number    ) {        this.storage = stg;        this.self = login;        this.coords = rep;        this.num = number;    }    @Override    public String toString() {        return Integer.toString(this.num);    }    @Override    public Repo repo() {        return new MkRepo(this.storage, this.self, this.coords);    }    @Override    public int number() {        return this.num;    }    @Override    public Comments comments() {        try {            return new MkComments(                this.storage, this.self, this.coords, this.num            );        } catch (final IOException ex) {            throw new IllegalStateException(ex);        }    }    @Override    public IssueLabels labels() {        try {            return new MkIssueLabels(                this.storage, this.self, this.coords, this.num            );        } catch (final IOException ex) {            throw new IllegalStateException(ex);        }    }    @Override    public Iterable<Event> events() throws IOException {        return new MkIterable<>(            this.storage,            String.format(                "/github/repos/repo[@coords='%s']/issue-events/issue-event[issue='%s']",                this.coords,                this.num            ),            new MkIssueEventMapping(this)        );    }    @Override    public boolean exists() throws IOException {        return this.storage.xml().xpath(            String.format("%s/number/text()", this.xpath())        ).size() == 1;    }    @Override    public int compareTo(        final Issue issue    ) {        return this.number() - issue.number();    }    @Override    public void patch(        final JsonObject json    ) throws IOException {        final Issue.Smart smart = new Issue.Smart(this);        final boolean was = smart.isOpen();        new JsonPatch(this.storage).patch(this.xpath(), json);        final boolean now = smart.isOpen();        if (now != was) {            final String type;            if (now) {                type = Event.REOPENED;            } else {                type = Event.CLOSED;            }            new MkIssueEvents(this.storage, this.self, this.coords)                .create(type, this.num, this.self, Optional.<String>absent());        }    }    @Override    public JsonObject json() throws IOException {        final XML xml = this.storage.xml();        final JsonObject obj = new JsonNode(            xml.nodes(this.xpath()).get(0)        ).json();        final JsonObjectBuilder json = Json.createObjectBuilder();        for (final Map.Entry<String, JsonValue> val: obj.entrySet()) {            json.add(val.getKey(), val.getValue());        }        final JsonArrayBuilder array = Json.createArrayBuilder();        for (final Label label : this.labels().iterate()) {            array.add(                Json.createObjectBuilder().add("name", label.name()).build()            );        }        final JsonObjectBuilder res = json            .add("labels", array)            .add(                "assignee",                Json.createObjectBuilder().add(                    "login", obj.getString("assignee", "")                ).build()            );        final JsonObjectBuilder pull = Json.createObjectBuilder();        final String html = "html_url";        if (xml.nodes(                String.format(                    "/github/repos/repo[@coords='%s']/pulls/pull/number[text() = '%d']",                    this.coords,                    this.num                )            ).isEmpty()) {            pull.addNull(html);        } else {            pull.add(                html,                String.format(                    "https:                    this.coords,                    this.num                )            );        }        return res.add("pull_request", pull.build()).build();    }    @Override    public void react(final Reaction reaction) {        throw new UnsupportedOperationException("react() not implemented");    }    @Override    public Collection<Reaction> reactions() {        throw new UnsupportedOperationException("reactions() not implemented");    }    @Override    public void lock(final String reason) {        throw new UnsupportedOperationException("lock not implemented");    }    @Override    public void unlock() {        throw new UnsupportedOperationException("unlock not implemented");    }    @Override    public boolean isLocked() {        throw new UnsupportedOperationException("isLocked not implemented");    }    private String xpath() {        return String.format(            "/github/repos/repo[@coords='%s']/issues/issue[number='%d']",            this.coords, this.num        );    }    private static class MkIssueEventMapping        implements MkIterable.Mapping<Event> {        private final transient MkIssueEvents evts;        public MkIssueEventMapping(            final MkIssue issue        ) throws IOException {            this.evts = new MkIssueEvents(                issue.storage,                issue.self,                issue.coords            );        }        @Override        public Event map(            final XML xml        ) {            return this.evts.get(                Integer.parseInt(xml.xpath("number/text()").get(0))            );        }    }}package com.jcabi.github.mock;import com.google.common.base.Optional;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Coordinates;import com.jcabi.github.Event;import com.jcabi.github.Issue;import com.jcabi.github.IssueLabels;import com.jcabi.github.Label;import java.io.IOException;import java.util.Collection;import java.util.HashSet;import java.util.Set;import lombok.EqualsAndHashCode;import lombok.ToString;import org.xembly.Directives;@Immutable@Loggable(Loggable.DEBUG)@ToString@EqualsAndHashCode(of = { "storage", "repo", "ticket" })final class MkIssueLabels implements IssueLabels {    private final transient MkStorage storage;    private final transient String self;    private final transient Coordinates repo;    private final transient int ticket;    MkIssueLabels(        final MkStorage stg,        final String login,        final Coordinates rep,        final int issue    ) throws IOException {        this.storage = stg;        this.self = login;        this.repo = rep;        this.ticket = issue;        this.storage.apply(            new Directives().xpath(                String.format(                    "/github/repos/repo[@coords='%s']/issues/issue[number='%d']",                    rep, this.ticket                )            ).addIf("labels")        );    }    @Override    public Issue issue() {        return new MkIssue(this.storage, this.self, this.repo, this.ticket);    }    @Override    public void add(final Iterable<String> labels    ) throws IOException {        final Collection<String> existing = this.labels();        final Set<String> added = new HashSet<>();        final Directives dirs = new Directives().xpath(this.xpath());        for (final String label : labels) {            dirs.add("label").set(label).up();            if (!existing.contains(label)) {                added.add(label);            }        }        this.storage.apply(dirs);        if (!added.isEmpty()) {            final MkIssueEvents events = new MkIssueEvents(                this.storage,                this.self,                this.repo            );            for (final String label : added) {                events.create(                    Event.LABELED,                    this.ticket,                    this.self,                    Optional.of(label)                );            }        }    }    @Override    public void replace(final Iterable<String> labels    ) throws IOException {        this.clear();        this.add(labels);    }    @Override    public Iterable<Label> iterate() {        return new MkIterable<>(            this.storage,            String.format("%s    private String xpath() {        return String.format(            "/github/repos/repo[@coords='%s']/issues/issue[number='%d']/labels",            this.repo, this.ticket        );    }    private Collection<String> labels() {        final Set<String> labels = new HashSet<>();        for (final Label label : this.iterate()) {            labels.add(label.name());        }        return labels;    }}package com.jcabi.github.mock;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Comment;import com.jcabi.github.Comments;import com.jcabi.github.Coordinates;import com.jcabi.github.Github;import com.jcabi.github.Issue;import com.jcabi.log.Logger;import java.io.IOException;import java.util.Date;import lombok.EqualsAndHashCode;import lombok.ToString;import org.xembly.Directives;@Immutable@Loggable(Loggable.DEBUG)@ToString@EqualsAndHashCode(of = { "storage", "self", "repo", "ticket" })final class MkComments implements Comments {    private final transient MkStorage storage;    private final transient String self;    private final transient Coordinates repo;    private final transient int ticket;    MkComments(        final MkStorage stg,        final String login,        final Coordinates rep,        final int issue    ) throws IOException {        this.storage = stg;        this.self = login;        this.repo = rep;        this.ticket = issue;        this.storage.apply(            new Directives().xpath(                String.format(                    "/github/repos/repo[@coords='%s']/issues/issue[number='%d']",                    this.repo, this.ticket                )            ).addIf("comments")        );    }    @Override    public Issue issue() {        return new MkIssue(this.storage, this.self, this.repo, this.ticket);    }    @Override    public Comment get(final long number) {        return new MkComment(            this.storage, this.self, this.repo, this.ticket, number        );    }    @Override    public Iterable<Comment> iterate(final Date since) {        return new MkIterable<>(            this.storage,            String.format("%s/comment", this.xpath()),            xml -> this.get(                Long.parseLong(xml.xpath("number/text()").get(0))            )        );    }    @Override    public Comment post(        final String text    ) throws IOException {        this.storage.lock();        final long number;        try {            final String timestamp = new Github.Time().toString();            number = 1 + this.storage.xml()                .nodes("            this.storage.apply(                new Directives().xpath(this.xpath()).add("comment")                    .add("number").set(Long.toString(number)).up()                    .add("url")                    .set(                        String.format(                            "https:                            this.repo.user(),                            this.repo.repo(),                            number                    )                )                    .up()                    .add("body").set(text).up()                    .add("user")                        .add("login").set(this.self).up()                    .up()                    .add("created_at").set(timestamp).up()                    .add("updated_at").set(timestamp)            );        } finally {            this.storage.unlock();        }        Logger.info(            this, "comment #%d posted to issue #%d by %s: %[text]s",            number, this.issue().number(), this.self, text        );        return this.get(number);    }    private String xpath() {        return String.format(            "/github/repos/repo[@coords='%s']/issues/issue[number='%d']/comments",            this.repo, this.ticket        );    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = "readable")final class Existence {    private final transient JsonReadable readable;    Existence(final JsonReadable rdbl) {        this.readable = rdbl;    }    public boolean check() throws IOException {        boolean exists = true;        try {            this.readable.json();        } catch (final AssertionError ex) {            exists = false;        } catch (final IndexOutOfBoundsException ex) {            exists = false;        }        return exists;    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.net.URL;import java.text.ParseException;import java.util.Date;import javax.json.Json;import javax.json.JsonObject;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@SuppressWarnings("PMD.TooManyMethods")public interface Milestone extends Comparable<Milestone>,    JsonReadable, JsonPatchable {    String OPEN_STATE = "open";    String CLOSED_STATE = "closed";    Repo repo();    int number();    @Immutable    @ToString    @Loggable(Loggable.DEBUG)    @EqualsAndHashCode(of = { "milestone", "jsn" })    final class Smart implements Milestone {        private static final String STATE = "state";        private static final String DESCRIPTION = "description";        private static final String TITLE = "title";        private static final String DUE_ON = "due_on";        private final transient Milestone milestone;        private final transient SmartJson jsn;        public Smart(            final Milestone mls        ) {            this.milestone = mls;            this.jsn = new SmartJson(mls);        }        public User creator() throws IOException {            return this.milestone.repo().github().users().get(                this.jsn.value(                    "creator", JsonObject.class                ).getString("login")            );        }        public boolean isOpen() throws IOException {            return Milestone.OPEN_STATE.equals(this.state());        }        public void open() throws IOException {            this.state(Milestone.OPEN_STATE);        }        public void close() throws IOException {            this.state(Milestone.CLOSED_STATE);        }        public String state() throws IOException {            return this.jsn.text(STATE);        }        public void state(            final String state        ) throws IOException {            this.milestone.patch(                Json.createObjectBuilder().add(STATE, state).build()            );        }        public String title() throws IOException {            return this.jsn.text(TITLE);        }        public void title(            final String title        ) throws IOException {            this.milestone.patch(                Json.createObjectBuilder().add(TITLE, title).build()            );        }        public String description() throws IOException {            return this.jsn.text(DESCRIPTION);        }        public void description(            final String description        ) throws IOException {            this.milestone.patch(                Json.createObjectBuilder()                    .add(DESCRIPTION, description).build()            );        }        public URL url() throws IOException {            try {                return new URI(this.jsn.text("url")).toURL();            } catch (final URISyntaxException ex) {                throw new IllegalArgumentException(ex);            }        }        public Date createdAt() throws IOException {            try {                return new Github.Time(                    this.jsn.text("created_at")                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public Date dueOn() throws IOException {            try {                return new Github.Time(                    this.jsn.text(DUE_ON)                ).date();            } catch (final ParseException ex) {                throw new IllegalStateException(ex);            }        }        public void dueOn(            final Date dueon        ) throws IOException {            this.milestone.patch(                Json.createObjectBuilder()                    .add(DUE_ON, new Github.Time(dueon).toString()).build()            );        }        public int openIssues() throws IOException {            return this.jsn.number("open_issues");        }        public int closedIssues() throws IOException {            return this.jsn.number("closed_issues");        }        @Override        public Repo repo() {            return this.milestone.repo();        }        @Override        public int number() {            return this.milestone.number();        }        @Override        public JsonObject json() throws IOException {            return this.milestone.json();        }        @Override        public void patch(            final JsonObject json        ) throws IOException {            this.milestone.patch(json);        }        @Override        public int compareTo(            final Milestone obj        ) {            return this.milestone.compareTo(obj);        }    }}package com.jcabi.github.mock;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Coordinates;import com.jcabi.github.Github;import com.jcabi.github.Issue;import com.jcabi.github.Issues;import com.jcabi.github.Repo;import com.jcabi.github.Search;import com.jcabi.log.Logger;import java.io.IOException;import java.util.EnumMap;import java.util.HashMap;import java.util.Map;import lombok.EqualsAndHashCode;import lombok.ToString;import org.xembly.Directives;@Immutable@Loggable(Loggable.DEBUG)@ToString@EqualsAndHashCode(of = { "storage", "self", "coords" })final class MkIssues implements Issues {    private final transient MkStorage storage;    private final transient String self;    private final transient Coordinates coords;    MkIssues(        final MkStorage stg,        final String login,        final Coordinates rep    ) throws IOException {        this.storage = stg;        this.self = login;        this.coords = rep;        this.storage.apply(            new Directives().xpath(                String.format(                    "/github/repos/repo[@coords='%s']",                    this.coords                )            ).addIf("issues")        );    }    @Override    public Repo repo() {        return new MkRepo(this.storage, this.self, this.coords);    }    @Override    public Issue get(final int number) {        return new MkIssue(this.storage, this.self, this.coords, number);    }    @Override    public Issue create(final String title,        final String body    )        throws IOException {        this.storage.lock();        final int number;        try {            number = 1 + this.storage.xml().xpath(                String.format("%s/issue/number/text()", this.xpath())            ).size();            this.storage.apply(                new Directives().xpath(this.xpath()).add("issue")                    .add("number").set(Integer.toString(number)).up()                    .add("state").set(Issue.OPEN_STATE).up()                    .add("title").set(title).up()                    .add("body").set(body).up()                    .add("created_at").set(new Github.Time().toString()).up()                    .add("updated_at").set(new Github.Time().toString()).up()                    .add("url").set("http:                    .add("html_url").set("http:                    .add("user").add("login").set(this.self).up().up()            );        } finally {            this.storage.unlock();        }        Logger.info(            this, "issue #%d created in %s by %s: %[text]s",            number, this.repo().coordinates(), this.self, title        );        return this.get(number);    }    @Override    public Iterable<Issue> iterate(final Map<String, String> params    ) {        return new MkIterable<>(            this.storage,            String.format("%s/issue", this.xpath()),            xml -> this.get(                Integer.parseInt(xml.xpath("number/text()").get(0))            )        );    }    @Override    @SuppressWarnings("PMD.UseConcurrentHashMap")    public Iterable<Issue> search(        final Sort sort,        final Search.Order direction,        final EnumMap<Qualifier, String> qualifiers) {        final Map<String, String> params = new HashMap<>();        for (final EnumMap.Entry<Qualifier, String> entry : qualifiers            .entrySet()) {            params.put(entry.getKey().identifier(), entry.getValue());        }        params.put("sort", sort.identifier());        params.put("direction", direction.identifier());        return this.iterate(params);    }    private String xpath() {        return String.format(            "/github/repos/repo[@coords='%s']/issues",            this.coords        );    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.http.Request;import com.jcabi.http.response.JsonResponse;import com.jcabi.http.response.RestResponse;import java.io.IOException;import java.net.HttpURLConnection;import java.util.EnumMap;import java.util.HashMap;import java.util.Map;import javax.json.Json;import javax.json.JsonStructure;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = { "entry", "request", "owner" })final class RtIssues implements Issues {    private final transient Request entry;    private final transient Request request;    private final transient Repo owner;    RtIssues(final Request req, final Repo repo) {        this.entry = req;        final Coordinates coords = repo.coordinates();        this.request = this.entry.uri()            .path("/repos")            .path(coords.user())            .path(coords.repo())            .path("/issues")            .back();        this.owner = repo;    }    @Override    public String toString() {        return this.request.uri().get().toString();    }    @Override    public Repo repo() {        return this.owner;    }    @Override    public Issue get(final int number) {        return new RtIssue(this.entry, this.owner, number);    }    @Override    public Issue create(        final String title,        final String body)        throws IOException {        final JsonStructure json = Json.createObjectBuilder()            .add("title", title)            .add("body", body)            .build();        return this.get(            this.request.method(Request.POST)                .body().set(json).back()                .fetch().as(RestResponse.class)                .assertStatus(HttpURLConnection.HTTP_CREATED)                .as(JsonResponse.class)                .json().readObject().getInt("number")        );    }    @Override    public Iterable<Issue> iterate(        final Map<String, String> params) {        return new RtPagination<>(            this.request.uri().queryParams(params).back(),            object -> this.get(object.getInt("number"))        );    }    @Override    @SuppressWarnings("PMD.UseConcurrentHashMap")    public Iterable<Issue> search(        final Sort sort,        final Search.Order direction,        final EnumMap<Qualifier, String> qualifiers) {        final Map<String, String> params = new HashMap<>();        for (final EnumMap.Entry<Qualifier, String> pair : qualifiers            .entrySet()) {            params.put(pair.getKey().identifier(), pair.getValue());        }        params.put("sort", sort.identifier());        params.put("direction", direction.identifier());        return this.iterate(params);    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.http.Request;import com.jcabi.http.response.RestResponse;import java.io.IOException;import java.net.HttpURLConnection;import javax.json.Json;import javax.json.JsonObject;import javax.json.JsonStructure;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = { "request", "owner", "num" })@SuppressWarnings("PMD.TooManyMethods")final class RtIssue implements Issue {    private static final String CONTENT = "content";    private final transient Request entry;    private final transient Request request;    private final transient Repo owner;    private final transient int num;    RtIssue(final Request req, final Repo repo, final int number) {        this.entry = req;        final Coordinates coords = repo.coordinates();        this.request = this.entry.uri()            .path("/repos")            .path(coords.user())            .path(coords.repo())            .path("/issues")            .path(Integer.toString(number))            .back();        this.owner = repo;        this.num = number;    }    @Override    public String toString() {        return this.request.uri().get().toString();    }    @Override    public Repo repo() {        return this.owner;    }    @Override    public int number() {        return this.num;    }    @Override    public Comments comments() {        return new RtComments(this.entry, this);    }    @Override    public IssueLabels labels() {        return new RtIssueLabels(this.entry, this);    }    @Override    public Iterable<Event> events() {        return new RtPagination<>(            this.request.uri().path("/events").back(),            object -> new RtEvent(                this.entry,                this.owner,                object.getInt("id")            )        );    }    @Override    public boolean exists() throws IOException {        return new Existence(this).check();    }    @Override    public void react(final Reaction reaction) throws IOException {        final JsonStructure json = Json.createObjectBuilder()            .add(RtIssue.CONTENT, reaction.type())            .build();        this.request.method(Request.POST)            .body().set(json).back()            .fetch().as(RestResponse.class)            .assertStatus(HttpURLConnection.HTTP_OK);    }    @Override    public Iterable<Reaction> reactions() {        return new RtPagination<>(            this.request.uri().path("/reactions").back(),            object -> new Reaction.Simple(object.getString(RtIssue.CONTENT))        );    }    @Override    public void lock(final String reason) {        final JsonStructure json = Json.createObjectBuilder()            .add("lock_reason", reason)            .build();        try {            this.request.method(Request.PUT).uri().path("/lock").back()                .body().set(json).back()                .fetch()                .as(RestResponse.class)                .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);        } catch (final IOException error) {            throw new IllegalStateException(error);        }    }    @Override    public void unlock() {        try {            this.request.method(Request.DELETE).uri().path("/lock").back()                .fetch()                .as(RestResponse.class)                .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);        } catch (final IOException error) {            throw new IllegalStateException(error);        }    }    @Override    public boolean isLocked() {        boolean locked = false;        try {            locked ^=                this.request.method(Request.PUT).uri().path("/lock").back()                .fetch()                .as(RestResponse.class)                .assertStatus(HttpURLConnection.HTTP_NO_CONTENT).back().body()                .get().isEmpty();        } catch (final IOException error) {            locked = false;        }        return locked;    }    @Override    public JsonObject json() throws IOException {        return new RtJson(this.request).fetch();    }    @Override    public void patch(final JsonObject json) throws IOException {        new RtJson(this.request).patch(json);    }    @Override    public int compareTo(        final Issue issue    ) {        return this.number() - issue.number();    }}package com.jcabi.github.mock;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Comment;import com.jcabi.github.Coordinates;import com.jcabi.github.Issue;import com.jcabi.github.Reaction;import java.io.IOException;import java.util.Collection;import javax.json.JsonObject;import lombok.EqualsAndHashCode;import lombok.ToString;import org.xembly.Directives;@Immutable@Loggable(Loggable.DEBUG)@ToString@EqualsAndHashCode(of = { "storage", "self", "repo", "ticket", "num" })final class MkComment implements Comment {    private final transient MkStorage storage;    private final transient String self;    private final transient Coordinates repo;    private final transient int ticket;    private final transient long num;    MkComment(        final MkStorage stg,        final String login,        final Coordinates rep,        final int issue,        final long number    ) {        this.storage = stg;        this.self = login;        this.repo = rep;        this.ticket = issue;        this.num = number;    }    @Override    public Issue issue() {        return new MkIssue(this.storage, this.self, this.repo, this.ticket);    }    @Override    public long number() {        return this.num;    }    @Override    public void remove() throws IOException {        this.storage.apply(            new Directives().xpath(this.xpath()).strict(1).remove()        );    }    @Override    public int compareTo(        final Comment comment    ) {        return Long.compare(this.number(), comment.number());    }    @Override    public void patch(        final JsonObject json    ) throws IOException {        new JsonPatch(this.storage).patch(this.xpath(), json);    }    @Override    public JsonObject json() throws IOException {        return new JsonNode(            this.storage.xml().nodes(this.xpath()).get(0)        ).json();    }    @Override    public void react(final Reaction reaction) {        throw new UnsupportedOperationException("react() not implemented");    }    @Override    public Collection<Reaction> reactions() {        throw new UnsupportedOperationException("reactions() not implemented");    }    private String xpath() {        return String.format(            "/github/repos/repo[@coords='%s']/issues/issue[number='%d']/comments/comment[number='%d']",            this.repo, this.ticket, this.num        );    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.http.Request;import com.jcabi.http.response.JsonResponse;import com.jcabi.http.response.RestResponse;import java.io.IOException;import java.net.HttpURLConnection;import javax.json.Json;import javax.json.JsonArrayBuilder;import javax.json.JsonStructure;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = "entry")final class RtIssueLabels implements IssueLabels {    private final transient Request entry;    private final transient Request request;    private final transient Issue owner;    RtIssueLabels(final Request req, final Issue issue) {        this.owner = issue;        final Coordinates coords = issue.repo().coordinates();        this.entry = req;        this.request = req.uri()            .path("/repos")            .path(coords.user())            .path(coords.repo())            .path("/issues")            .path(Integer.toString(issue.number()))            .path("/labels")            .back();    }    @Override    public String toString() {        return this.request.uri().get().toString();    }    @Override    public Issue issue() {        return this.owner;    }    @Override    public void add(final Iterable<String> labels) throws IOException {        JsonArrayBuilder builder = Json.createArrayBuilder();        for (final String label : labels) {            builder = builder.add(label);        }        final JsonStructure json = builder.build();        this.request.method(Request.POST)            .body().set(json).back()            .fetch()            .as(RestResponse.class)            .assertStatus(HttpURLConnection.HTTP_OK)            .as(JsonResponse.class)            .json().readArray();    }    @Override    public void replace(final Iterable<String> labels) throws IOException {        JsonArrayBuilder builder = Json.createArrayBuilder();        for (final String label : labels) {            builder = builder.add(label);        }        final JsonStructure json = builder.build();        this.request.method(Request.PUT)            .body().set(json).back()            .fetch()            .as(RestResponse.class)            .assertStatus(HttpURLConnection.HTTP_OK)            .as(JsonResponse.class)            .json().readArray();    }    @Override    public void remove(final String name) throws IOException {        this.request.method(Request.DELETE)            .uri().path(name).back()            .fetch()            .as(RestResponse.class)            .assertStatus(HttpURLConnection.HTTP_OK);    }    @Override    public void clear() throws IOException {        this.request.method(Request.DELETE)            .fetch()            .as(RestResponse.class)            .assertStatus(HttpURLConnection.HTTP_NO_CONTENT);    }    @Override    public Iterable<Label> iterate() {        return new RtPagination<>(            this.request,            object -> new RtLabel(                this.entry,                this.owner.repo(),                object.getString("name")            )        );    }}package com.jcabi.github.mock;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Coordinates;import com.jcabi.github.Issue;import com.jcabi.github.Pull;import com.jcabi.github.Pulls;import com.jcabi.github.Repo;import java.io.IOException;import java.util.Map;import lombok.EqualsAndHashCode;import lombok.ToString;import org.xembly.Directives;@Immutable@Loggable(Loggable.DEBUG)@ToString@EqualsAndHashCode(of = { "storage", "self", "coords" })final class MkPulls implements Pulls {    private static final String USER_BRANCH_SEP = ":";    private final transient MkStorage storage;    private final transient String self;    private final transient Coordinates coords;    MkPulls(        final MkStorage stg,        final String login,        final Coordinates rep    ) throws IOException {        this.storage = stg;        this.self = login;        this.coords = rep;        this.storage.apply(            new Directives().xpath(                String.format(                    "/github/repos/repo[@coords='%s']",                    this.coords                )            ).addIf("pulls")        );    }    @Override    public Repo repo() {        return new MkRepo(this.storage, this.self, this.coords);    }    @Override    public Pull get(final int number) {        return new MkPull(this.storage, this.self, this.coords, number);    }    @Override    public Pull create(        final String title,        final String head,        final String base    ) throws IOException {        if (head.isEmpty()) {            throw new IllegalArgumentException("head cannot be empty!");        }        if (base.isEmpty()) {            throw new IllegalArgumentException("base cannot be empty!");        }        final String canonical;        if (head.contains(MkPulls.USER_BRANCH_SEP)) {            canonical = head;        } else {            canonical = String.format(                "%s%s%s",                this.coords.user(),                MkPulls.USER_BRANCH_SEP,                head            );        }        this.storage.lock();        final int number;        try {            final Issue issue = this.repo().issues().create(title, "some body");            number = issue.number();            this.storage.apply(                new Directives().xpath(this.xpath()).add("pull")                    .add("number").set(Integer.toString(number)).up()                    .add("head").set(canonical).up()                    .add("base").set(base).up()                    .add("checks").up()                    .add("user")                    .add("login").set(this.self)                    .up()            );        } finally {            this.storage.unlock();        }        return this.get(number);    }    @Override    public Iterable<Pull> iterate(final Map<String, String> params) {        return new MkIterable<>(            this.storage,            String.format("%s/pull", this.xpath()),            xml -> this.get(                Integer.parseInt(xml.xpath("number/text()").get(0))            )        );    }    private String xpath() {        return String.format(            "/github/repos/repo[@coords='%s']/pulls",            this.coords        );    }}package com.jcabi.github;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.http.Request;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.util.EnumMap;import java.util.regex.Pattern;import lombok.EqualsAndHashCode;@Immutable@Loggable(Loggable.DEBUG)@EqualsAndHashCode(of = "ghub")@SuppressWarnings("PMD.AvoidDuplicateLiterals")final class RtSearch implements Search {    private static final Pattern SLASH = Pattern.compile("/");    private static final Pattern QUERY = Pattern.compile("=");    private final transient Github ghub;    private final transient Request request;    RtSearch(final Github github, final Request req) {        this.ghub = github;        this.request = req.uri().path("/search").back();    }    @Override    public Github github() {        return this.ghub;    }    @Override    public Iterable<Repo> repos(        final String keywords,        final String sort,        final Order order) {        return new RtSearchPagination<>(            this.request, "repositories", keywords, sort, order.identifier(),            object -> this.github().repos().get(                new Coordinates.Simple(object.getString("full_name"))            )        );    }    @Override    public Iterable<Issue> issues(final String keywords, final String sort,        final Order order, final EnumMap<Qualifier, String> qualifiers) {        final StringBuilder keyword = new StringBuilder(keywords);        for (final EnumMap.Entry<Qualifier, String> entry : qualifiers            .entrySet()) {            keyword.append('+').append(entry.getKey().identifier())                .append(':').append(entry.getValue());        }        return new RtSearchPagination<>(            this.request,            "issues",            keyword.toString(),            sort,            order.identifier(),            object -> {                try {                    final String[] parts = RtSearch.SLASH.split(                        new URI(object.getString("url")).getPath()                    );                    return this.ghub.repos().get(                        new Coordinates.Simple(parts[2], parts[3])                    ).issues().get(object.getInt("number"));                } catch (final URISyntaxException ex) {                    throw new IllegalStateException(ex);                }            }        );    }    @Override    public Iterable<User> users(        final String keywords,        final String sort,        final Order order) {        return new RtSearchPagination<>(            this.request, "users", keywords, sort, order.identifier(),            object -> this.ghub.users().get(                object.getString("login")            )        );    }    @Override    public Iterable<Content> codes(        final String keywords,        final String sort,        final Order order) {        return new RtSearchPagination<>(            this.request, "code", keywords, sort, order.identifier(),            object -> {                try {                    final URI uri = new URI(object.getString("url"));                    final String[] parts = RtSearch.SLASH.split(                        uri.getPath()                    );                    final String ref = RtSearch.QUERY.split(                        uri.getQuery()                    )[1];                    return this.ghub.repos().get(                        new Coordinates.Simple(parts[2], parts[3])                    ).contents().get(object.getString("path"), ref);                } catch (final URISyntaxException ex) {                    throw new IllegalStateException(ex);                } catch (final IOException ex) {                    throw new IllegalStateException(ex);                }            }        );    }}package com.jcabi.github.mock;import com.jcabi.aspects.Immutable;import com.jcabi.aspects.Loggable;import com.jcabi.github.Content;import com.jcabi.github.Coordinates;import com.jcabi.github.Github;import com.jcabi.github.Issue;import com.jcabi.github.Repo;import com.jcabi.github.Search;import com.jcabi.github.User;import java.util.EnumMap;import lombok.EqualsAndHashCode;import lombok.ToString;@Immutable@Loggable(Loggable.DEBUG)@ToString@EqualsAndHashCode(of = { "storage", "self" })final class MkSearch implements Search {    private final transient MkStorage storage;    private final transient String self;    MkSearch(        final MkStorage stg,        final String login    ) {        this.storage = stg;        this.self = login;    }    @Override    public Github github() {        return new MkGithub(this.storage, this.self);    }    @Override    public Iterable<Repo> repos(        final String keywords,        final String sort,        final Order order    ) {        return new MkIterable<>(            this.storage,            "/github/repos/repo",            xml -> new MkRepo(                this.storage, this.self,                new Coordinates.Simple(xml.xpath("@coords").get(0))            )        );    }    @Override    public Iterable<Issue> issues(final String keywords, final String sort,        final Order order, final EnumMap<Qualifier, String> qualifiers    ) {        return new MkIterable<>(            this.storage,            "/github/repos/repo/issues/issue",            xml -> new MkIssue(                this.storage, this.self,                new Coordinates.Simple(                    xml.xpath("../../@coords").get(0)                ),                Integer.parseInt(xml.xpath("number/text()").get(0))            )        );    }    @Override    public Iterable<User> users(        final String keywords,        final String sort,        final Order order    ) {        return new MkIterable<>(            this.storage,            "/github/users/user",            xml -> new MkUser(                this.storage,                xml.xpath("login/text()").get(0)            )        );    }    @Override    public Iterable<Content> codes(        final String keywords,        final String sort,        final Order order    ) {        return new MkIterable<>(            this.storage,            "/github/repos/repo/name",            xml -> new MkContent(                this.storage,                this.self,                new Coordinates.Simple(this.self, "repo"),                "/path/to/search",                "master"            )        );    }}