package inet.ipaddr.format.util;
import java.util.Iterator;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import inet.ipaddr.Address;
import inet.ipaddr.AddressSegmentSeries;
import inet.ipaddr.HostIdentifierException;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.format.util.AddressTrieOps.AddressTrieAddOps;
import inet.ipaddr.format.util.BinaryTreeNode.KeyIterator;
abstract class AbstractTree<E extends Address> implements AddressTrieAddOps<E> {
	private static final long serialVersionUID = 1L;
	static ResourceBundle bundle;
	static {
		String propertyFileName = "IPAddressResources";
		String name = HostIdentifierException.class.getPackage().getName() + '.' + propertyFileName;
		try {
			bundle = ResourceBundle.getBundle(name);
		} catch (MissingResourceException e) {
			System.err.println("bundle " + name + " is missing");
		}
	}
	static String getMessage(String key) {
		if(bundle != null) {
			try {
				return bundle.getString(key);
			} catch (MissingResourceException e1) {}
		}
		return key;
	}
	BinaryTreeNode<E> root;
	protected AbstractTree(BinaryTreeNode<E> root) {
		this.root = root;
	}
	public BinaryTreeNode<E> getRoot() {
		return root;
	}
	public int size() {
		return getRoot().size();
	}
	public int nodeSize() {
		return getRoot().nodeSize();
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> E checkBlockOrAddress(E addr, boolean thro) {
		if(!addr.isMultiple()) {
			if(!addr.isPrefixed()) {
				return addr;
			}
			return (E) addr.withoutPrefixLength();
		} else if(addr.isSinglePrefixBlock()) {
			return addr;
		} else {
			AddressSegmentSeries series;
			if(addr instanceof IPAddressSegmentSeries) {
				series = ((IPAddressSegmentSeries) addr).assignPrefixForSingleBlock();
			} else {
				Integer newPrefix = addr.getPrefixLengthForSingleBlock();
				series = newPrefix == null ? null : addr.setPrefixLength(newPrefix, false);
			}
			if(series != null) {
				return (E) series;
			}
		}
		if(thro) {
			throw new IllegalArgumentException(getMessage("ipaddress.error.address.not.block"));
		}
		return null;
	}
	public void clear() {
		getRoot().clear();
	}
	@Override
	public Iterator<E> iterator() {
		return new KeyIterator<E>(nodeIterator(true));
	}
	@Override
	public Iterator<E> descendingIterator() {
		return new KeyIterator<E>(nodeIterator(false));
	}
	@Override
	public int hashCode() {
		int hashCode = 0;
		Iterator<? extends BinaryTreeNode<E>> these = nodeIterator(true);
		while(these.hasNext()) {
			BinaryTreeNode<?> node = these.next();
			hashCode += node.hashCode();
		}
	    return hashCode;
	}
	@Override
	public boolean equals(Object o) {
		if (o == this) {
			return true;
		}
		if(o instanceof AbstractTree) {
			AbstractTree<?> other = (AbstractTree<?>) o;
			if(other.size() != size()) {
				return false;
			}
			Iterator<? extends BinaryTreeNode<?>> these = nodeIterator(true),
					others = other.nodeIterator(true);
			while(these.hasNext()) {
				BinaryTreeNode<?> node = these.next(), otherNode = others.next();
				if(!node.equals(otherNode)) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	public boolean isEmpty() {
		return size() == 0;
	}
	@Override
	public String toString() {
		return toString(true);
	}
	public String toString(boolean withNonAddedKeys) {
		return getRoot().toTreeString(withNonAddedKeys, true);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AbstractTree<E> clone() {
		try {
			return (AbstractTree<E>) super.clone();
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}
}
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.Comparator;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;
import java.util.Spliterator;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
import inet.ipaddr.ipv6.IPv6Address;
public class BinaryTreeNode<E> implements TreeOps<E> {
	private static final long serialVersionUID = 1L;
	static String getMessage(String key) {
		return AbstractTree.getMessage(key);
	}
	static class Bounds<E> implements Serializable {
		private static final long serialVersionUID = 1L;
		final Comparator<? super E> comparator;
		final E lowerBound, upperBound;
		final boolean lowerInclusive, upperInclusive;
		Bounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			if(comparator == null) {
				throw new NullPointerException();
			}
			this.comparator = comparator;
			this.lowerBound = lowerBound;
			this.upperBound = upperBound;
			this.lowerInclusive = lowerInclusive;
			this.upperInclusive = upperInclusive;
			if(upperBound != null) {
				if(isBelowLowerBound(upperBound)) {
					throw new IllegalArgumentException(getMessage("ipaddress.error.address.lower.exceeds.upper") + " " + lowerBound + ", " + upperBound);
				}
			}
		}
		Bounds<E> restrict(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			return restrict(lowerBound, lowerInclusive, upperBound, upperInclusive, true);
		}
		Bounds<E> restrict(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, boolean thro) {
			if(lowerBound != null) {
				BoundsCheck check = compareToLowerBound(lowerBound, lowerInclusive);
				if(check.isLessRestrictive()) {
					if(thro) {
						throw new IllegalArgumentException(getMessage("ipaddress.error.lower.below.range") + " " + lowerBound);
					}
					lowerBound = null;
				} else if(!check.isMoreRestrictive()) {
					if(check != BoundsCheck.EQUIVALENT_TO_INCLUSIVE) {
						lowerBound = null;
					} 
				}
			}
			if(upperBound != null) {
				BoundsCheck check = compareToUpperBound(upperBound, upperInclusive);
				if(check.isLessRestrictive()) {
					if(thro) {
						throw new IllegalArgumentException(getMessage("ipaddress.error.lower.above.range") + " " + upperBound);
					}
					upperBound = null;
				} else if(!check.isMoreRestrictive()) {
					if(check != BoundsCheck.EQUIVALENT_TO_INCLUSIVE) {
						upperBound = null;
					}
				}
			}
			if(lowerBound == null) {
				if(upperBound == null) {
					return null;
				}
				lowerBound = this.lowerBound;
				lowerInclusive = this.lowerInclusive;
			}
			if(upperBound == null) {
				upperBound = this.upperBound;
				upperInclusive = this.upperInclusive;
			}
			return createBounds(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		Bounds<E> intersect(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			Bounds<E> newBounds = restrict(lowerBound, lowerInclusive, upperBound, upperInclusive, false);
			if(newBounds == null) {
				return this;
			}
			return newBounds;
		}
		Bounds<E> createBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			return new Bounds<E>(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		public boolean isInBounds(E addr) {
			return isWithinLowerBound(addr) && isWithinUpperBound(addr);
		}
		public E getLowerBound() {
			return lowerBound;
		}
		public E getUpperBound() {
			return upperBound;
		}
		public boolean lowerIsInclusive() {
			return lowerInclusive;
		}
		public boolean upperIsInclusive() {
			return upperInclusive;
		}
		public boolean isLowerBounded() {
			return lowerBound != null;
		}
		public boolean isUpperBounded() {
			return upperBound != null;
		}
		public boolean isUnbounded() {
			return !isLowerBounded() && !isUpperBounded();
		}
		private int compare(E one, E two) {
			return comparator.compare(one, two);
		}
		public boolean isBelowLowerBound(E addr) {
			return isLowerBounded() && 
					(lowerInclusive ? compare(addr, lowerBound) < 0 :
						compare(addr, lowerBound) <= 0);
		}
		public boolean isWithinLowerBound(E addr) {
			return !isBelowLowerBound(addr);					
		}
		public boolean isAboveUpperBound(E addr) {
			return isUpperBounded() && 
					(upperInclusive ? compare(addr, upperBound) > 0 :
						compare(addr, upperBound) >= 0);
		}
		public boolean isWithinUpperBound(E addr) {
			return !isAboveUpperBound(addr);
		}
		BoundsCheck compareToLowerBound(E addr, boolean inclusive) {
			if(isLowerBounded()) {
				if(inclusive) {
					if(lowerInclusive) {
						return BoundsCheck.convertEquivBoundaryComparison(compare(lowerBound, addr));
					}
					int comp = compare(lowerBound, addr);
					if(comp >= 0) {
						return BoundsCheck.OUTSIDE;
					} else if(isAdjacentAboveLowerBound(addr)) {
						return BoundsCheck.EQUIVALENT_TO_EXCLUSIVE;
					}
					return BoundsCheck.INSIDE;
				} else if(lowerInclusive) {
					int comp = compare(lowerBound, addr);
					if(comp <= 0) {
						return BoundsCheck.INSIDE;
					} else if(isAdjacentBelowLowerBound(addr)) {
						return BoundsCheck.EQUIVALENT_TO_INCLUSIVE;
					}
					return BoundsCheck.OUTSIDE;
				}
				return BoundsCheck.convertEquivBoundaryComparison(compare(lowerBound, addr));
			}
			if(inclusive && isMin(addr)) {
				return BoundsCheck.EQUIVALENT_TO_UNBOUNDED;
			}
			return BoundsCheck.INSIDE;
		}
		BoundsCheck compareToUpperBound(E addr, boolean inclusive) {
			if(isUpperBounded()) {
				if(inclusive) {
					if(upperInclusive) {
						return BoundsCheck.convertEquivBoundaryComparison(compare(addr, upperBound)); 
					}
					int comp = compare(addr, upperBound);
					if(comp >= 0) {
						return BoundsCheck.OUTSIDE;
					} else if(isAdjacentBelowUpperBound(addr)) {
						return BoundsCheck.EQUIVALENT_TO_EXCLUSIVE;
					}
					return BoundsCheck.INSIDE;
				} else if(upperInclusive) {
					int comp = compare(addr, upperBound);
					if(comp <= 0) {
						return BoundsCheck.INSIDE;
					} else if(isAdjacentAboveUpperBound(addr)) {
						return BoundsCheck.EQUIVALENT_TO_INCLUSIVE;
					}
					return BoundsCheck.OUTSIDE;
				}
				return BoundsCheck.convertEquivBoundaryComparison(compare(addr, upperBound));
			}
			if(inclusive && isMax(addr)) {
				return BoundsCheck.EQUIVALENT_TO_UNBOUNDED;
			}
			return BoundsCheck.INSIDE;
		}
		static enum BoundsCheck {
			INSIDE(false, true), 
			EQUIVALENT_TO_UNBOUNDED(false, false), 
			EQUIVALENT_TO_EXCLUSIVE(false, false), 
			EQUIVALENT_TO_INCLUSIVE(false, false), 
			SAME(false, false), 
			OUTSIDE(true, false);
			private boolean less, more;
			BoundsCheck(boolean lessRestrictive, boolean moreRestrictive) {
				less = lessRestrictive;
				more = moreRestrictive;
			}
			boolean isLessRestrictive() {
				return less;
			}
			boolean isMoreRestrictive() {
				return more;
			}
			static BoundsCheck convertEquivBoundaryComparison(int comparison) {
				if(comparison > 0) {
					return OUTSIDE;
				} else if(comparison < 0) {
					return INSIDE;
				}
				return SAME;
			}
		}
		boolean isMax(E addr) {
			return false;
		}
		boolean isMin(E addr) {
			return false;
		}
		boolean isAdjacentAboveUpperBound(E addr) {
			return false;
		}
		boolean isAdjacentBelowUpperBound(E addr) {
			return false;
		}
		boolean isAdjacentAboveLowerBound(E addr) {
			return false;
		}
		boolean isAdjacentBelowLowerBound(E addr) {
			return false;
		}
		public String toCanonicalString() {
			return toCanonicalString(" -> ");
		}
		public String toCanonicalString(String separator) {
			Function<? super E, String> stringer = Object::toString;
			return toString(stringer, separator, stringer);
		}
		public String toString(Function<? super E, String> lowerStringer, String separator, Function<? super E, String> upperStringer) {
			return toString(getLowerBound(), lowerIsInclusive(), getUpperBound(), upperIsInclusive(),
					lowerStringer, separator, upperStringer);
		}
		static <E> String toString(
				E lower,
				boolean lowerIsInclusive,
				E upper,
				boolean upperIsInclusive,
				Function<? super E, String> lowerStringer,
				String separator,
				Function<? super E, String> upperStringer) {
			String lowerStr;
			if(lower == null) {
				lowerStr = "";
			} else {
				lowerStr = lowerStringer.apply(lower);
				if(lowerIsInclusive) {
					lowerStr = '[' + lowerStr;
				} else {
					lowerStr = '(' + lowerStr;
				}
			}
			String upperStr;
			if(upper == null) {
				upperStr = "";
			} else {
				upperStr = upperStringer.apply(upper);
				if(upperIsInclusive) {
					upperStr += ']';
				} else {
					upperStr += ')';
				}
			}
			return lowerStr + separator + upperStr;
		}
		@Override
		public String toString() {
			return toCanonicalString();
		}
	}
	static class ChangeTracker implements Serializable {
		private static final long serialVersionUID = 1L;
		static class Change implements Cloneable, Serializable {
			private static final long serialVersionUID = 1L;
			boolean shared;
			private BigInteger big = BigInteger.ZERO;
			private int small;
			void increment() {
				if(++small == 0) {
					big = big.add(BigInteger.ONE);
				}
			}
			@Override
			public boolean equals(Object o) {
				return o instanceof Change && equalsChange((Change) o);
			}
			public boolean equalsChange(Change change) {
				return small == change.small && big.equals(change.big);
			}
			@Override
			public Change clone() {
				try {
					return (Change) super.clone();
				} catch (CloneNotSupportedException cannotHappen) {
					return null;
				}
			}
			@Override
			public String toString() {
				return big + " " + small;
			}
		}
		ChangeTracker() {}
		private Change currentChange = new Change();
		void changedSince(Change change) throws ConcurrentModificationException {
			if(isChangedSince(change)) {
				throw new ConcurrentModificationException();
			}
		}
		boolean isChangedSince(Change otherChange) {
			return !currentChange.equalsChange(otherChange);
		}
		Change getCurrent() {
			Change change = this.currentChange;
			change.shared = true;
			return change;
		}
		void changed() {
			Change change = this.currentChange;
			if(change.shared) {
				change = change.clone();
				change.shared = false;
				change.increment();
				this.currentChange = change;
			} 
		}
		@Override
		public String toString() {
			return "current change: " + currentChange;
		}
	}
	protected static boolean FREEZE_ROOT = true;
	static final int SIZE_UNKNOWN = -1;
	private E item;
	private BinaryTreeNode<E> parent, lower, upper;
	int size;
	ChangeTracker changeTracker;
	private boolean added;
	protected BinaryTreeNode(E item) { 
		this.item = item;
	}
	protected void setKey(E item) {
		this.item = item;
	}
	public E getKey() {
		return item;
	}
	public boolean isRoot() {
		return parent == null;
	}
	public BinaryTreeNode<E> getParent() {
		return parent;
	}
	void setParent(BinaryTreeNode<E> parent) {
		this.parent = parent;
	}
	public BinaryTreeNode<E> getUpperSubNode() {
		return upper;
	}
	public BinaryTreeNode<E> getLowerSubNode() {
		return lower;
	}
	protected void setUpper(BinaryTreeNode<E> upper) {
		this.upper = upper;
		if(upper != null) {
			upper.setParent(this);
		}
	}
	protected void setLower(BinaryTreeNode<E> lower) {
		this.lower = lower;
		if(lower != null) {
			lower.setParent(this);
		}
	}
	public boolean isAdded() {
		return added;
	}
	public void setAdded() {
		if(!added) {
			setNodeAdded(true);
			adjustCount(1);
		}
	}
	protected void setNodeAdded(boolean added) {
		this.added = added;
	}
	public int size() {
		int storedSize = size;
		if(storedSize == SIZE_UNKNOWN) {
			Iterator<? extends BinaryTreeNode<E>> iterator = containedFirstAllNodeIterator(true);
			while(iterator.hasNext()) {
				BinaryTreeNode<E> next = iterator.next();
				int nodeSize = next.isAdded() ? 1 : 0;
				BinaryTreeNode<E> lower = next.getLowerSubNode();
				if(lower != null) {
					nodeSize += lower.size;
				}
				BinaryTreeNode<E> upper = next.getUpperSubNode();
				if(upper != null) {
					nodeSize += upper.size;
				}
				next.size = nodeSize;
			}
			storedSize = size;
		}
		return storedSize;
	}
	public int nodeSize() {
		int totalCount = 0;
		Iterator<? extends BinaryTreeNode<E>> iterator = iterator(true, false);
		while(iterator.hasNext()) {
			totalCount++;
			iterator.next();
		}
		return totalCount;
	}
	void adjustCount(int delta) {
		if(delta != 0) {
			BinaryTreeNode<E> node = this;
			do {
				node.size += delta;
				node = node.getParent();
			} while(node != null);
		}
	}
	public void remove() {
		if(!isAdded()) {
			return;
		}
		if(FREEZE_ROOT && isRoot()) {
			removed();
		} else if(getUpperSubNode() == null) {
			replaceThis(getLowerSubNode()); 
		} else if(getLowerSubNode() == null) {
			replaceThis(getUpperSubNode());
		} else { 
			removed();
		}
	}
	void removed() {
		adjustCount(-1);
		setNodeAdded(false);
		changeTracker.changed();
	}
	void replaceThis(BinaryTreeNode<E> replacement) {
		replaceThisRecursive(replacement, 0);
		changeTracker.changed();
	}
	void replaceThisRecursive(BinaryTreeNode<E> replacement, int additionalSizeAdjustment) {
		if(isRoot()) {
			replaceThisRoot(replacement);
			return;
		}
		BinaryTreeNode<E> parent = getParent();
		if(parent.getUpperSubNode() == this) {
			adjustTree(parent, replacement, additionalSizeAdjustment, true);
			parent.setUpper(replacement);
		} else if(parent.getLowerSubNode() == this) {
			adjustTree(parent, replacement, additionalSizeAdjustment, false);
			parent.setLower(replacement);
		} else {
			throw new Error(); 
		}
	}
	private void adjustTree(BinaryTreeNode<E> parent, BinaryTreeNode<E> replacement, int additionalSizeAdjustment, boolean replacedUpper) {
		int sizeAdjustment = -size;
		if(replacement == null) {
			if(!parent.isAdded() && (!FREEZE_ROOT || !parent.isRoot())) {
				parent.size += sizeAdjustment;
				BinaryTreeNode<E> parentReplacement = 
						replacedUpper ? parent.getLowerSubNode() : parent.getUpperSubNode();
				parent.replaceThisRecursive(parentReplacement, sizeAdjustment);
			} else {
				parent.adjustCount(sizeAdjustment + additionalSizeAdjustment);
			}
		} else {
			parent.adjustCount(replacement.size + sizeAdjustment + additionalSizeAdjustment);
		}
		setParent(null);
	}
	protected void replaceThisRoot(BinaryTreeNode<E> replacement) {
		if(replacement == null) {
			setNodeAdded(false);
			setUpper(null);
			setLower(null);
			if(!FREEZE_ROOT) {
				setKey(null);
			}
			size = 0;
		} else {
			setNodeAdded(replacement.isAdded());
			setUpper(replacement.getUpperSubNode());
			setLower(replacement.getLowerSubNode());
			setKey(replacement.getKey());
			size = replacement.size;
		}
	}
	public void clear() {
		replaceThis(null);
	}
	public boolean isEmpty() {
		return !isAdded() && getUpperSubNode() == null && getLowerSubNode() == null;
	}
	public boolean isLeaf() {
		return isAdded() && getUpperSubNode() == null && getLowerSubNode() == null;
	}
	public BinaryTreeNode<E> firstNode() {
		BinaryTreeNode<E> first = this;
		while(true) {
			BinaryTreeNode<E> lower = first.getLowerSubNode();
			if(lower == null) {
				return first;
			}
			first = lower;
		}
	}
	public BinaryTreeNode<E> firstAddedNode() {
		BinaryTreeNode<E> first = firstNode();
		if(first.isAdded()) {
			return first;
		}
		return first.nextAddedNode();
	}
	public BinaryTreeNode<E> lastNode() {
		BinaryTreeNode<E> last = this;
		while(true) {
			BinaryTreeNode<E> upper = last.getUpperSubNode();
			if(upper == null) {
				return last;
			}
			last = upper;
		}
	}
	public BinaryTreeNode<E> lastAddedNode() {
		BinaryTreeNode<E> last = lastNode();
		if(last.isAdded()) {
			return last;
		}
		return last.previousAddedNode();
	}
	BinaryTreeNode<E> firstPostOrderNode() {
		BinaryTreeNode<E> next = this, nextNext;
		while(true) {
			nextNext = next.getLowerSubNode();
			if(nextNext == null) {
				nextNext = next.getUpperSubNode();
				if(nextNext == null) {
					return next;
				}
			} 
			next = nextNext;
		}
	}
	BinaryTreeNode<E> lastPreOrderNode() {
		BinaryTreeNode<E> next = this, nextNext;
		while(true) {
			nextNext = next.getUpperSubNode();
			if(nextNext == null) {
				nextNext = next.getLowerSubNode();
				if(nextNext == null) {
					return next;
				}
			} 
			next = nextNext;
		}
	}
	public BinaryTreeNode<E> nextNode() {
		return nextNode(null);
	}
	BinaryTreeNode<E> nextNode(BinaryTreeNode<E> bound) {
		BinaryTreeNode<E> next = getUpperSubNode();
		if(next != null) {
			while(true) {
				BinaryTreeNode<E> nextLower = next.getLowerSubNode();
				if(nextLower == null) {
					return next;
				}
				next = nextLower;
			}
		} else {
			next = getParent();
			if(next == bound) {
				return null;
			}
			BinaryTreeNode<E> current = this;
			while(next != null && current == next.getUpperSubNode()) {
				current = next;
				next = next.getParent();
				if(next == bound) {
					return null;
				}
			}
		}
		return next;
	}
	public BinaryTreeNode<E> previousNode() {
		return previousNode(null);
	}
	BinaryTreeNode<E> previousNode(BinaryTreeNode<E> bound) {
		BinaryTreeNode<E> previous = getLowerSubNode();
		if(previous != null) {
			while(true) {
				BinaryTreeNode<E> previousUpper = previous.getUpperSubNode();
				if(previousUpper == null) {
					break;
				}
				previous = previousUpper;
			}
		} else {
			previous = getParent();
			if(previous == bound) {
				return null;
			}
			BinaryTreeNode<E> current = this;
			while(previous != null && current == previous.getLowerSubNode()) {
				current = previous;
				previous = previous.getParent();
				if(previous == bound) {
					return null;
				}
			}
		}
		return previous;
	}
	BinaryTreeNode<E> nextPreOrderNode(BinaryTreeNode<E> end) {
		BinaryTreeNode<E> next = getLowerSubNode();
		if(next == null) {
			next = getUpperSubNode();
			if(next == null) {
				BinaryTreeNode<E> current = this;
				next = getParent();
				while(next != null) {
					if(next == end) {
						return null;
					}
					if(current == next.getLowerSubNode()) {
						BinaryTreeNode<E> nextNext = next.getUpperSubNode();
						if(nextNext != null) {
							return nextNext;
						}
					}
					current = next;
					next = next.getParent();
				}
			}
		}
		return next;
	}
	BinaryTreeNode<E> previousPostOrderNode(BinaryTreeNode<E> end) {
		BinaryTreeNode<E> next = getUpperSubNode();
		if(next == null) {
			next = getLowerSubNode();
			if(next == null) {
				BinaryTreeNode<E> current = this;
				next = getParent();
				while(next != null) {
					if(next == end) {
						return null;
					}
					if(current == next.getUpperSubNode()) {
						BinaryTreeNode<E> nextNext = next.getLowerSubNode();
						if(nextNext != null) {
							next = nextNext;
							break;
						}
					}
					current = next;
					next = next.getParent();
				}
			}
		}
		return next;
	}
	BinaryTreeNode<E> previousPreOrderNode(BinaryTreeNode<E> end) {
		BinaryTreeNode<E> next = getParent();
		if(next == null || next == end) {
			return null;
		}
		if(next.getLowerSubNode() == this) {
			return next;
		}
		BinaryTreeNode<E> nextNext = next.getLowerSubNode();
		if(nextNext == null) {
			return next;
		}
		next = nextNext;
		while(true) {
			nextNext = next.getUpperSubNode();
			if(nextNext == null) {
				nextNext = next.getLowerSubNode();
				if(nextNext == null) {
					return next;
				}
			}
			next = nextNext;
		}
	}
	BinaryTreeNode<E> nextPostOrderNode(BinaryTreeNode<E> end) {
		BinaryTreeNode<E> next = getParent();
		if(next == null || next == end) {
			return null;
		}
		if(next.getUpperSubNode() == this) {
			return next;
		}
		BinaryTreeNode<E> nextNext = next.getUpperSubNode();
		if(nextNext == null) {
			return next;
		}
		next = nextNext;
		while(true) {
			nextNext = next.getLowerSubNode();
			if(nextNext == null) {
				nextNext = next.getUpperSubNode();
				if(nextNext == null) {
					return next;
				}
			} 
				next = nextNext;
		}
	}
	public BinaryTreeNode<E> nextAddedNode() {
		return nextAdded(null, BinaryTreeNode<E>::nextNode);
	}
	public BinaryTreeNode<E> previousAddedNode() {
		return nextAdded(null, BinaryTreeNode<E>::previousNode);
	}
	private static <E> BinaryTreeNode<E> nextTest(BinaryTreeNode<E> current, BinaryTreeNode<E> end, BinaryOperator<BinaryTreeNode<E>> nextOperator, Predicate<BinaryTreeNode<E>> tester) {
		do {
			current = nextOperator.apply(current, end);
			if(current == end || current == null) {
				return null;
			}
		} while(!tester.test(current));
		return current;
	}
	private BinaryTreeNode<E> nextAdded(BinaryTreeNode<E> end, BinaryOperator<BinaryTreeNode<E>> nextOperator) {
		return nextTest(this, end, nextOperator, BinaryTreeNode<E>::isAdded);
	}
	private BinaryTreeNode<E> nextInBounds(BinaryTreeNode<E> end, BinaryOperator<BinaryTreeNode<E>> nextOperator, Bounds<E> bounds) {
		return nextTest(this, end, nextOperator, node -> bounds.isInBounds(node.getKey()));
	}
	@Override
	public Iterator<E> iterator() {
		return new KeyIterator<E>(nodeIterator(true));
	}
	@Override
	public Iterator<E> descendingIterator() {
		return new KeyIterator<E>(nodeIterator(false));
	}
	@Override
	public Iterator<? extends BinaryTreeNode<E>> nodeIterator(boolean forward) {
		return iterator(forward, true);
	}
	@Override
	public Iterator<? extends BinaryTreeNode<E>> allNodeIterator(boolean forward) {
		return iterator(forward, false);
	}
	<C> CachingIterator<? extends BinaryTreeNode<E>, E, C> blockSizeCachingAllNodeIterator() {
		return new BlockSizeCachingNodeIterator<E, C>(this, false, changeTracker);
	}
	Iterator<? extends BinaryTreeNode<E>> blockSizeNodeIterator(boolean lowerSubNodeFirst, boolean addedNodesOnly) {
		return new BlockSizeNodeIterator<E>(
				addedNodesOnly ? size() : 0,
				addedNodesOnly,
				this,
				!lowerSubNodeFirst,
				changeTracker);
	}
	@Override
	public Iterator<? extends BinaryTreeNode<E>> containingFirstIterator(boolean forwardSubNodeOrder)  {
		return containingFirstIterator(forwardSubNodeOrder, true);
	}
	@Override
	public <C> CachingIterator<? extends BinaryTreeNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder)  {
		return containingFirstIterator(forwardSubNodeOrder, false);
	}
	private <C> CachingIterator<? extends BinaryTreeNode<E>, E, C> containingFirstIterator(boolean forwardSubNodeOrder, boolean addedNodesOnly)  {
		if(forwardSubNodeOrder) {
			return new PreOrderNodeIterator<E, C>(
					true, 
					addedNodesOnly, 
					this,
					getParent(),
					changeTracker);
		} else {
			return new PostOrderNodeIterator<E, C>(
					false, 
					addedNodesOnly, 
					this,
					getParent(),
					changeTracker);
		}
	}
	@Override
	public Iterator<? extends BinaryTreeNode<E>> containedFirstIterator(boolean forwardSubNodeOrder)  {
		return containedFirstIterator(forwardSubNodeOrder, true);
	}
	@Override
	public Iterator<? extends BinaryTreeNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder)  {
		return containedFirstIterator(forwardSubNodeOrder, false);
	}
	private Iterator<? extends BinaryTreeNode<E>> containedFirstIterator(boolean forwardSubNodeOrder, boolean addedNodesOnly)  {
		if(forwardSubNodeOrder) {
			return new PostOrderNodeIterator<E, Object>(
					true,
					addedNodesOnly, 
					firstPostOrderNode(),
					getParent(),
					changeTracker);
		} else {
			return new PreOrderNodeIterator<E, Object>(
					false,
					addedNodesOnly, 
					lastPreOrderNode(),
					getParent(),
					changeTracker);
		}
	}
	private NodeIterator<E> iterator(boolean forward, boolean addedOnly) {
		return new NodeIterator<E>(
				forward,
				addedOnly,
				forward ? firstNode() : lastNode(),
				getParent(),
				changeTracker);
	}
	static class KeyIterator<E> implements Iterator<E> {
		private Iterator<? extends BinaryTreeNode<E>> iterator;
		KeyIterator(Iterator<? extends BinaryTreeNode<E>> iterator) {
			this.iterator = iterator;
		}
		@Override
		public boolean hasNext() {
			return iterator.hasNext();
		}
		@Override
		public E next() {
			return iterator.next().getKey();
		}
		@Override
		public void remove() {
			iterator.remove();
		}
	}
	public static interface CachingIterator<N extends BinaryTreeNode<E>, E, C> extends Iterator<N> {
		C getCached();
		boolean cacheWithLowerSubNode(C object);
		public boolean cacheWithUpperSubNode(C object);
	}
	static class BlockSizeNodeIterator<E> extends AbstractNodeIterator<E> {
		static class Comp<E extends Address> implements Comparator<BinaryTreeNode<E>> {
			private final boolean reverseBlocksEqualSize;
			Comp(boolean reverseBlocksEqualSize) {
				this.reverseBlocksEqualSize = reverseBlocksEqualSize;
			}
			@Override
			public int compare(BinaryTreeNode<E> node1, BinaryTreeNode<E> node2) {
				E addr1 = node1.getKey();
				E addr2 = node2.getKey();
				if(addr1 == addr2) {
					return 0;
				}
				if(addr1.isPrefixed()) {
					if(addr2.isPrefixed()) {
						int val = addr1.getPrefixLength() - addr2.getPrefixLength();
						if(val == 0) {
							int compVal = compareLowValues(addr1, addr2);
							return reverseBlocksEqualSize ? -compVal : compVal;
						}
						return val;
					}
					return -1;
				}
				if(addr2.isPrefixed()) {
					return 1;
				}
				int compVal = compareLowValues(addr1, addr2);
				return reverseBlocksEqualSize ? -compVal : compVal;
			}
		};
		private static final Comparator<?> COMP = new Comp<>(false), REVERSE_COMP = new Comp<>(true);
		PriorityQueue<BinaryTreeNode<E>> queue;
		private final boolean addedOnly;
		private final Bounds<E> bounds;
		BlockSizeNodeIterator(
				int treeSize, 
				boolean addedOnly,
				BinaryTreeNode<E> start,
				boolean reverseBlocksEqualSize,
				ChangeTracker changeTracker) {
			this(treeSize, null, addedOnly, start, reverseBlocksEqualSize, changeTracker);
		}
		@SuppressWarnings("unchecked")
		BlockSizeNodeIterator(
				int treeSize, 
				Bounds<E> bounds,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				boolean reverseBlocksEqualSize,
				ChangeTracker changeTracker) {
			super(start, null, changeTracker);
			this.addedOnly = addedOnly;
			this.bounds = bounds;
			Comparator<BinaryTreeNode<E>> comp = 
					(Comparator<BinaryTreeNode<E>>) (reverseBlocksEqualSize ? REVERSE_COMP : COMP);
			if(treeSize > 0) {
				int initialCapacity = treeSize >> 1;
				if(initialCapacity == 0) {
					initialCapacity = 1;
				}
				queue = new PriorityQueue<>(initialCapacity, comp);
			} else {
				queue = new PriorityQueue<>(comp);
			}
			next = getStart(start, null, bounds, addedOnly);
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = (currentNode, endNode) -> {
					BinaryTreeNode<E> lower = currentNode.getLowerSubNode();
					if(lower != null) {
						queue.add(lower);
					}
					BinaryTreeNode<E> upper = currentNode.getUpperSubNode();
					if(upper != null) {
						queue.add(upper);
					}
					BinaryTreeNode<E> node = queue.poll();
					return node == endNode ? null : node;
				};
				if(addedOnly) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextAdded(endNode, wrappedOp);
				}
				if(bounds != null) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextInBounds(endNode, wrappedOp, bounds);
				}
				operator = op;
			}
			return op;
		}
	}
	static int compareLowValues(Address one, Address two) {
		return Address.ADDRESS_LOW_VALUE_COMPARATOR.compare(one, two);
	}
	static class BlockSizeCachingNodeIterator<E, C> extends AbstractNodeIterator<E> implements CachingIterator<BinaryTreeNode<E>, E, C> {
		static class Comp<E extends Address> implements Comparator<Cached<E, ?>> {
			private final boolean reverseBlocksEqualSize;
			Comp(boolean reverseBlocksEqualSize) {
				this.reverseBlocksEqualSize = reverseBlocksEqualSize;
			}
			@Override
			public int compare(Cached<E, ?> o1, Cached<E, ?> o2) {
				BinaryTreeNode<E> node1 = o1.node, node2 = o2.node;
				E addr1 = node1.getKey(), addr2 = node2.getKey();
				if(addr1 == addr2) {
					return 0;
				}
				if(addr1.isPrefixed()) {
					if(addr2.isPrefixed()) {
						int val = addr1.getPrefixLength() - addr2.getPrefixLength();
						if(val == 0) {
							int compVal = compareLowValues(addr1, addr2);
							return reverseBlocksEqualSize ? -compVal : compVal;
						}
						return val;
					}
					return -1;
				}
				if(addr2.isPrefixed()) {
					return 1;
				}
				int compVal = compareLowValues(addr1, addr2);
				return reverseBlocksEqualSize ? -compVal : compVal;
			}
		};
		static class Cached<E, C> {
			BinaryTreeNode<E> node;
			C cached;
		}
		private static final Comparator<?> COMP = new Comp<>(false), REVERSE_COMP = new Comp<>(true);
		private PriorityQueue<Cached<E, C>> queue;
		private C cacheItem;
		private Cached<E, C> nextCachedItem;
		private Cached<E, C> lowerCacheObj, upperCacheObj;
		BlockSizeCachingNodeIterator(
				int treeSize,
				BinaryTreeNode<E> start,
				boolean reverseBlocksEqualSize,
				ChangeTracker changeTracker) {
			super(start, null, changeTracker);
			@SuppressWarnings("unchecked")
			Comparator<Cached<E, C>> comp = (Comparator<Cached<E, C>>) (reverseBlocksEqualSize ? REVERSE_COMP : COMP);
			if(treeSize == 0) {
				queue = new PriorityQueue<>(comp);
			} else {
				queue = new PriorityQueue<>(treeSize >> 1, comp);
			}
			next = getStart(start, null, null, false);
		}
		BlockSizeCachingNodeIterator(
				BinaryTreeNode<E> start,
				boolean reverseBlocksEqualSize,
				ChangeTracker changeTracker) {
			this(0, start, reverseBlocksEqualSize, changeTracker);
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = (currentNode, endNode) -> {
					BinaryTreeNode<E> lower = currentNode.getLowerSubNode();
					if(lower != null) {
						Cached<E, C> cached = new Cached<>();
						cached.node = lower;
						lowerCacheObj = cached;
						queue.add(cached);
					} else {
						lowerCacheObj = null;
					}
					BinaryTreeNode<E> upper = currentNode.getUpperSubNode();
					if(upper != null) {
						Cached<E, C> cached = new Cached<>();
						cached.node = upper;
						upperCacheObj = cached;
						queue.add(cached);
					} else {
						upperCacheObj = null;
					}
					if(nextCachedItem != null) {
						cacheItem = nextCachedItem.cached;
					}
					Cached<E, C> cached =  queue.poll();
					if(cached != null) {
						BinaryTreeNode<E> node = cached.node;
						if(node != endNode) {
							nextCachedItem = cached;
							return node;
						}
					}
					nextCachedItem = null;
					return null;
				};
				operator = op;
			}
			return op;
		}
		@Override
		public C getCached() {
			return cacheItem;
		}
		@Override
		public boolean cacheWithLowerSubNode(C object) {
			if(lowerCacheObj != null) {
				lowerCacheObj.cached = object;
				return true;
			}
			return false;
		}
		@Override
		public boolean cacheWithUpperSubNode(C object) {
			if(upperCacheObj != null) {
				upperCacheObj.cached = object;
				return true;
			}
			return false;
		}
	}
	static class PostOrderNodeIterator<E, C> extends SubNodeCachingIterator<E, C> {
		PostOrderNodeIterator(
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> bound,
				ChangeTracker changeTracker) {
			this(null, isForward, addedOnly, start, bound, changeTracker);
		}
		PostOrderNodeIterator(
				Bounds<E> bounds,
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> end,
				ChangeTracker changeTracker) {
			super(bounds, isForward, addedOnly, start, end, changeTracker);
		}
		@Override
		void checkCaching() {
			if(isForward) {
				throw new Error();
			}
		}
		@Override
		void populateCacheItem() {
			if(!isForward) {
				super.populateCacheItem();
			}
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = isForward ? BinaryTreeNode<E>::nextPostOrderNode : BinaryTreeNode<E>::previousPostOrderNode;
				if(addedOnly) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextAdded(endNode, wrappedOp);
				}
				if(bounds != null) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextInBounds(endNode, wrappedOp, bounds);
				}
				operator = op;
			}
			return op;
		}
		@Override
		public void remove() {
			if(!isForward || addedOnly) {
				super.remove();
				return;
			}
			throw new UnsupportedOperationException();
		}
	}
	static class PreOrderNodeIterator<E, C> extends SubNodeCachingIterator<E, C> {
		PreOrderNodeIterator(
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> bound,
				ChangeTracker changeTracker) {
			this(null, isForward, addedOnly, start, bound, changeTracker);
		}
		PreOrderNodeIterator(
				Bounds<E> bounds,
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> end,
				ChangeTracker changeTracker) {
			super(bounds, isForward, addedOnly, start, end, changeTracker);
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = isForward ? BinaryTreeNode<E>::nextPreOrderNode : BinaryTreeNode<E>::previousPreOrderNode;
				if(addedOnly) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextAdded(endNode, wrappedOp);
				}
				if(bounds != null) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextInBounds(endNode, wrappedOp, bounds);
				}
				operator = op;
			}
			return op;
		}
		@Override
		void checkCaching() {
			if(!isForward) {
				throw new Error();
			}
		}
		@Override
		void populateCacheItem() {
			if(isForward) {
				super.populateCacheItem();
			}
		}
		@Override
		public void remove() {
			if(isForward || addedOnly) {
				super.remove();
				return;
			}
			throw new UnsupportedOperationException();
		}
	}
	static abstract class SubNodeCachingIterator<E, C> extends AbstractNodeIterator<E> implements CachingIterator<BinaryTreeNode<E>, E, C> {
		private static final int STACK_SIZE = IPv6Address.BIT_COUNT + 2; 
		private C cacheItem;
		private E nextKey;
		private C nextCached;
		private Object stack[];
		private int stackIndex = -1;
		final Bounds<E> bounds;
		final boolean addedOnly, isForward;
		SubNodeCachingIterator(
				Bounds<E> bounds,
				boolean isForward,
				boolean addedOnly,
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> end,
				ChangeTracker changeTracker) {
			super(start, end, changeTracker);
			this.isForward = isForward;
			this.addedOnly = addedOnly;
			this.bounds = bounds;
			next = getStart(start, end, bounds, addedOnly);
		}
		@Override
		BinaryTreeNode<E> doNext() {
			BinaryTreeNode<E> result = super.doNext();
			populateCacheItem();
			return result;
		}
		abstract void checkCaching();
		@Override
		public C getCached() {
			checkCaching();
			return cacheItem;
		}
		@SuppressWarnings("unchecked")
		void populateCacheItem() {
			E nextKey = this.nextKey;
			if(nextKey != null && current.getKey() == nextKey) {
				cacheItem = nextCached;
				nextCached = null;
				nextKey = null;
			} else {
				Object stack[] = this.stack;
				if(stack != null) {
					int stackIndex = this.stackIndex;
					if(stackIndex >= 0 && stack[stackIndex] == current.getKey()) {
						cacheItem = (C) stack[stackIndex + STACK_SIZE];
						stack[stackIndex + STACK_SIZE] = null;
						stack[stackIndex] = null;
						this.stackIndex--;
					} else {
						cacheItem = null;
					}
				} else {
					cacheItem = null;
				}
			}
		}
		@Override
		public boolean cacheWithLowerSubNode(C object) {
			return isForward ? cacheWithFirstSubNode(object) : cacheWithSecondSubNode(object);
		}
		@Override
		public boolean cacheWithUpperSubNode(C object) {
			return isForward ? cacheWithSecondSubNode(object) : cacheWithFirstSubNode(object);
		}
		private boolean cacheWithFirstSubNode(C object) {
			checkCaching();
			if(current != null) {
				BinaryTreeNode<E> firstNode = isForward ? current.getLowerSubNode() : current.getUpperSubNode();
				if(firstNode != null) {
					if((addedOnly && !firstNode.isAdded()) || (bounds != null && !bounds.isInBounds(firstNode.getKey()))) {
						firstNode = getToNextOperation().apply(firstNode, current);
					}
					if(firstNode != null) {
						nextKey = firstNode.getKey();
						nextCached = object;
						return true;
					}
				}
			}
			return false;
		}
		private boolean cacheWithSecondSubNode(C object) {
			checkCaching();
			if(current != null) {
				BinaryTreeNode<E> secondNode = isForward ? current.getUpperSubNode() : current.getLowerSubNode();
				if(secondNode != null) {
					if((addedOnly && !secondNode.isAdded()) || (bounds != null && !bounds.isInBounds(secondNode.getKey()))) {
						secondNode = getToNextOperation().apply(secondNode, current);
					}
					if(secondNode != null) {
						BinaryTreeNode<E> firstNode = isForward ? current.getLowerSubNode() : current.getUpperSubNode();
						if(firstNode == null) {
							nextKey = secondNode.getKey();
							nextCached = object;
						} else {
							if(stack == null) {
								stack = new Object[STACK_SIZE << 1];
							}
							stackIndex++;
							stack[stackIndex] = secondNode.getKey();
							stack[stackIndex + STACK_SIZE] = object;
						}
						return true;
					}
				}
			}
			return false;
		}
	}
	static class NodeIterator<E> extends AbstractNodeIterator<E> {
		final boolean forward, addedOnly;
		NodeIterator(
				boolean forward,
				boolean addedOnly,
				BinaryTreeNode<E> start, 
				BinaryTreeNode<E> end, 
				ChangeTracker changeTracker) {
			super(start, end, changeTracker);
			this.forward = forward;
			this.addedOnly = addedOnly;
			next = getStart(start, end, null, addedOnly);
		}
		@Override
		BinaryOperator<BinaryTreeNode<E>> getToNextOperation() {
			BinaryOperator<BinaryTreeNode<E>> op = operator;
			if(op == null) {
				op = forward ? BinaryTreeNode<E>::nextNode : BinaryTreeNode<E>::previousNode;
				if(addedOnly) {
					BinaryOperator<BinaryTreeNode<E>> wrappedOp = op;
					op = (currentNode, endNode) -> currentNode.nextAdded(endNode, wrappedOp);
				}
				operator = op;
			}
			return op;
		}
	}
	abstract static class AbstractNodeIterator<E> implements Iterator<BinaryTreeNode<E>> {
		private final ChangeTracker changeTracker;
		private Change currentChange;
		BinaryTreeNode<E> current, next;
		BinaryTreeNode<E> end; 
		BinaryOperator<BinaryTreeNode<E>> operator;
		AbstractNodeIterator(
				BinaryTreeNode<E> start, 
				BinaryTreeNode<E> end, 
				ChangeTracker changeTracker) {
			this.end = end;
			this.changeTracker = changeTracker;
			if(changeTracker != null) {
				currentChange = changeTracker.getCurrent();
			}
		}
		abstract BinaryOperator<BinaryTreeNode<E>> getToNextOperation();
		BinaryTreeNode<E> getStart(
				BinaryTreeNode<E> start,
				BinaryTreeNode<E> end,
				Bounds<E> bounds,
				boolean addedOnly) {
			if(start == end || start == null) {
				return null;
			}
			if(!addedOnly || start.isAdded()) {
				if(bounds == null || bounds.isInBounds(start.getKey())) {
					return start;
				}
			}
			return toNext(start);
		}
		@Override
		public boolean hasNext() {
			return next != null;
		}
		@Override
		public BinaryTreeNode<E> next() {
			if(!hasNext()) {
				throw new NoSuchElementException();
			}
			return doNext();
		}
		BinaryTreeNode<E> nextNoThrow() {
			if(!hasNext()) {
				return null;
			}
			return doNext();
		}
		BinaryTreeNode<E> doNext() {
			ChangeTracker changeTracker = this.changeTracker;
			if(changeTracker != null) {
				changeTracker.changedSince(currentChange);
			}
			current = next;
			next = toNext(next);
			return current;
		}
		BinaryTreeNode<E> toNext(BinaryTreeNode<E> current) {
			BinaryOperator<BinaryTreeNode<E>> op = getToNextOperation();
			BinaryTreeNode<E> result = op.apply(current, end);
			return result;
		}
		@Override
		public void remove() {
			if(current == null) {
                throw new IllegalStateException(getMessage("ipaddress.error.no.iterator.element.to.remove"));
			}
			ChangeTracker changeTracker = this.changeTracker;
			if(changeTracker != null) {
				changeTracker.changedSince(currentChange);
			}
			current.remove();
			current = null;
			if(changeTracker != null) {
				currentChange = changeTracker.getCurrent();
			}
		}
	}
	static class NodeSpliterator<E> implements Spliterator<BinaryTreeNode<E>> {
		private final ChangeTracker changeTracker;
		private Change currentChange;
		private final Comparator<? super BinaryTreeNode<E>> comparator;
		private static enum Side {
			ALL, BEGINNING, ENDING;
		}
		private Side position; 
		private BinaryTreeNode<E> begin, end, root;
		private NodeIterator<E> iterator;
		private long sizeEstimate;
		private final boolean addedOnly, forward;
		NodeSpliterator(
				boolean forward,
				Comparator<? super BinaryTreeNode<E>> comparator,
				BinaryTreeNode<E> root,
				BinaryTreeNode<E> begin,
				BinaryTreeNode<E> end,
				long size,
				ChangeTracker changeTracker,
				boolean addedOnly) {
			this(forward, comparator, Side.ALL, begin, end, size, changeTracker, addedOnly);
			this.root = root;
		}
		private NodeSpliterator(
				boolean forward,
				Comparator<? super BinaryTreeNode<E>> comparator,
				Side position,
				BinaryTreeNode<E> begin,
				BinaryTreeNode<E> end,
				long sizeEstimate,
				ChangeTracker changeTracker,
				boolean addedOnly) {
			this.comparator = comparator;
			this.sizeEstimate = sizeEstimate;
			this.end = end;
			this.begin = begin;
			this.position = position;
			this.changeTracker = changeTracker;
			this.addedOnly = addedOnly;
			this.forward = forward;
			currentChange = changeTracker.getCurrent();
		}
		@Override
		public String toString() {
			return "spliterator from " + begin + " to " + end;
		}
		private BinaryTreeNode<E> getMiddle()  {
			BinaryTreeNode<E> mid;
			if(position == Side.BEGINNING) {
				mid = forward ? end.getLowerSubNode() : end.getUpperSubNode();
			} else if(position == Side.ENDING) {
				mid = forward ? begin.getUpperSubNode() : begin.getLowerSubNode();
				if(mid != null && end != null && getComparator().compare(mid, end) >= 0) {
					return null;
				}
			} else {
				mid = root;
			}
			return mid;
		}
		private BinaryTreeNode<E> nextNode(BinaryTreeNode<E> current, BinaryTreeNode<E> bound) {
			return forward ? current.nextNode(bound) : current.previousNode(bound);
		}
		@Override
		public Spliterator<BinaryTreeNode<E>> trySplit() {
			if(begin == null) {
				return null;
			}
			changeTracker.changedSince(currentChange);
			BinaryTreeNode<E> mid = getMiddle();
			if(mid == null) {
				return null;
			}
			BinaryTreeNode<E> current;
			if(iterator == null) {
				current = begin;
			} else {
				current = iterator.next;
				if(current == null) {
					return null;
				}
			}
			if(current == end) {
				return null;
			}
			position = Side.ENDING;
			if((current == mid || getComparator().compare(current, mid) >= 0)) {
				begin = current;
				return trySplit();
			} else {
				begin = mid;
				if (addedOnly) while(!current.isAdded()) {
					current = nextNode(current, mid);
					if((current == mid || current == null)) {
						return trySplit();
					}
				}
			}
			BinaryTreeNode<E> next = mid;
			if (addedOnly) while(!next.isAdded()) {
				next = nextNode(next, end);
				if(next == end || next == null) {
					begin = current;
					end = mid;
					position = Side.BEGINNING;
					if(iterator != null) {
						iterator.end = mid;
					}
					return trySplit();
				}
			}
			long sizeEst = sizeEstimate;
			NodeSpliterator<E> lowerSplit = new NodeSpliterator<>(
					forward, comparator, Side.BEGINNING, current, mid, sizeEst >>> 1, changeTracker, addedOnly);
			sizeEstimate = (sizeEst + 1) >>> 1;
			if(iterator != null) {
				lowerSplit.iterator = iterator;
				iterator.end = mid;
			}
			iterator = null;
			return lowerSplit;
		}
		private NodeIterator<E> createIterator() {
			return new NodeIterator<E>(forward, addedOnly, begin, end, changeTracker);
		}
		private NodeIterator<E> provideIterator() {
			changeTracker.changedSince(currentChange);
			NodeIterator<E> iter = iterator;
			if(iter == null) {
				iter = createIterator();
				iterator = iter;
			}
			return iter;
		}
		@Override
		public boolean tryAdvance(Consumer<? super BinaryTreeNode<E>> action) {
			BinaryTreeNode<E> next = provideIterator().nextNoThrow();
			if(next != null) {
				action.accept(next);
				return true;
			} else if(action == null) {
				throw new NullPointerException();
			}
			return false;
		}
		@Override
		public void forEachRemaining(Consumer<? super BinaryTreeNode<E>> action) {
			BinaryTreeNode<E> next = provideIterator().nextNoThrow();
			if(next != null) {
				action.accept(next);
				while(true) {
					next = iterator.nextNoThrow();
					if(next == null) {
						break;
					}
					action.accept(next);
				}
			} else if(action == null) {
				throw new NullPointerException();
			}
	    }
		@Override
		public long estimateSize() {
			return sizeEstimate;
		}
		@Override
		public int characteristics() {
			int characteristics = Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED | Spliterator.NONNULL;
			if(position == Side.ALL) {
				characteristics |= Spliterator.SIZED;
			}
			return characteristics;
        }
        @Override
		public Comparator<? super BinaryTreeNode<E>> getComparator() {
        	return comparator;
        }
	}
	static class KeySpliterator<E> implements Spliterator<E> {
		private final Spliterator<? extends BinaryTreeNode<E>> wrapped;
		private final Comparator<? super E> comparator;
		KeySpliterator(Spliterator<? extends BinaryTreeNode<E>> wrapped,
				Comparator<? super E> comparator) {
			this.wrapped = wrapped;
			this.comparator = comparator;
		}
		private static <E> Consumer<? super BinaryTreeNode<E>> wrapAction(Consumer<? super E> action) {
			return node -> action.accept(node.getKey());
		}
		@Override
		public boolean tryAdvance(Consumer<? super E> action) {
			return wrapped.tryAdvance(wrapAction(action));
		}
		@Override
		public void forEachRemaining(Consumer<? super E> action) {
			wrapped.forEachRemaining(wrapAction(action));
	    }
		@Override
		public Comparator<? super E> getComparator() {
			return comparator;
	    }
		@Override
		public Spliterator<E> trySplit() {
			Spliterator<? extends BinaryTreeNode<E>> split = wrapped.trySplit();
			if(split == null) {
				return null;
			}
			return new KeySpliterator<E>(split, comparator);
		}
		@Override
		public long estimateSize() {
			return wrapped.estimateSize();
		}
		@Override
		public long getExactSizeIfKnown() {
			return wrapped.getExactSizeIfKnown();
		}
		@Override
		public int characteristics() {
			return wrapped.characteristics();
		}
		@Override
		public String toString() {
			return wrapped.toString();
		}
	}
	static final String NON_ADDED_NODE_CIRCLE = "\u25cb";
	static final String ADDED_NODE_CIRCLE = "\u25cf";
	static final String LEFT_ELBOW = "\u251C\u2500"; 	
	static final String IN_BETWEEN_ELBOWS = "\u2502 "; 	
	static final String RIGHT_ELBOW = "\u2514\u2500"; 	
	static final String BELOW_ELBOWS = "  ";
	static class Indents {
		final String nodeIndent, subNodeInd;
		Indents() {
			this("", "");
		}
		Indents(String nodeIndent, String subNodeIndent) {
			this.nodeIndent = nodeIndent;
			this.subNodeInd = subNodeIndent;
		}
	}
	public String toTreeString(boolean withNonAddedKeys, boolean withSizes) {
		StringBuilder builder = new StringBuilder("\n");
		printTree(builder, new Indents(), withNonAddedKeys, withSizes, this.<Indents>containingFirstAllNodeIterator(true));
		return builder.toString();
	}
	void printTree(StringBuilder builder, 
			Indents initialIndents,
			boolean withNonAdded, 
			boolean withSizes,
			CachingIterator<? extends BinaryTreeNode<E>, E, Indents> iterator) {
		while(iterator.hasNext()) {
			BinaryTreeNode<E> next = iterator.next();
			Indents cached = iterator.getCached();
			String nodeIndent, subNodeIndent;
			if(cached == null) {
				nodeIndent = initialIndents.nodeIndent;
				subNodeIndent = initialIndents.subNodeInd;
			} else {
				nodeIndent = cached.nodeIndent;
				subNodeIndent = cached.subNodeInd;
			}
			if(withNonAdded || next.isAdded()) {
				builder.append(nodeIndent).append(next); 
				if(withSizes) {
					builder.append(" (").append(next.size()).append(')');
				}
				builder.append('\n');
			} else {
				builder.append(nodeIndent).append(NON_ADDED_NODE_CIRCLE + "\n");
			}
			BinaryTreeNode<E> upper = next.getUpperSubNode(), lower = next.getLowerSubNode();
			if(upper != null) {
				if(lower != null) {
					Indents lowerIndents = new Indents(
							subNodeIndent + LEFT_ELBOW,
							subNodeIndent + IN_BETWEEN_ELBOWS);
					iterator.cacheWithLowerSubNode(lowerIndents);
				}
				Indents upperIndents = new Indents(
						subNodeIndent + RIGHT_ELBOW,
						subNodeIndent + BELOW_ELBOWS);
				iterator.cacheWithUpperSubNode(upperIndents);
			} else if(lower != null) {
				Indents lowerIndents = new Indents(
						subNodeIndent + RIGHT_ELBOW,
						subNodeIndent + BELOW_ELBOWS);
				iterator.cacheWithLowerSubNode(lowerIndents);
			}
		}
	}
	@Override
	public String toString() {
		return toNodeString(new StringBuilder(50), isAdded(), getKey(),  null).toString();
	}
	static <E, V> StringBuilder toNodeString(StringBuilder builder, boolean isAdded, E key, V value) {
		builder.append(isAdded ? ADDED_NODE_CIRCLE: NON_ADDED_NODE_CIRCLE).append(' ').append(key);
		if(value != null) {
			builder.append(" = ").append(value);
		}
		return builder;
	}
	@SuppressWarnings("unchecked")
	@Override
	public BinaryTreeNode<E> clone() {
		try {
			BinaryTreeNode<E> result = (BinaryTreeNode<E>) super.clone();
			result.setParent(null);
			result.setLower(null);
			result.setUpper(null);
			result.size = isAdded() ? 1 : 0;
			result.changeTracker = null;
			return result;
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}
	@SuppressWarnings("unchecked")
	BinaryTreeNode<E> cloneTreeNode(ChangeTracker changeTracker) {
		try {
			BinaryTreeNode<E> result = (BinaryTreeNode<E>) super.clone();
			result.setParent(null);
			result.changeTracker = changeTracker;
			return result;
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}
	@SuppressWarnings("unchecked")
	BinaryTreeNode<E> cloneTree(ChangeTracker changeTracker, Bounds<E> bounds) {
		BinaryTreeNode<E> rootClone = cloneTreeNode(changeTracker);
		BinaryTreeNode<E> clonedNode = rootClone;
		SubNodeCachingIterator<E, ?> iterator = (SubNodeCachingIterator<E, ?>) clonedNode.containingFirstAllNodeIterator(true);
		boolean recalculateSize = false;
		do {
			BinaryTreeNode<E> lower = clonedNode.getLowerSubNode();
			if(bounds != null) {
				while(true) {
					if(lower == null) {
						break;
					} else if(bounds.isWithinLowerBound(lower.getKey())) {
						if(!lower.isAdded()) {
							BinaryTreeNode<E> next = lower.getLowerSubNode();
							while(bounds.isBelowLowerBound(next.getKey())) {
								next = next.getUpperSubNode();
								if(next == null) {
									lower = lower.getUpperSubNode();
									recalculateSize = true;
									break;
								}
							}
						}
						break;
					}
					recalculateSize = true;
					lower = lower.getUpperSubNode();
				}
			}
			if(lower != null) {
				clonedNode.setLower(lower.cloneTreeNode(changeTracker));
			} else {
				clonedNode.setLower(null);
			}
			BinaryTreeNode<E> upper = clonedNode.getUpperSubNode();
			if(bounds != null) {
				while(true) {
					if(upper == null) {
						break;
					} else if(bounds.isWithinUpperBound(upper.getKey())) {
						if(!upper.isAdded()) {
							BinaryTreeNode<E> next = upper.getUpperSubNode();
							while(bounds.isAboveUpperBound(next.getKey())) {
								next = next.getLowerSubNode();
								if(next == null) {
									upper = upper.getLowerSubNode();
									recalculateSize = true;
									break;
								}
							}
						}
						break;
					}
					recalculateSize = true;
					upper = upper.getLowerSubNode();
				}
			}
			if(upper != null) {
				clonedNode.setUpper(upper.cloneTreeNode(changeTracker));
			} else {
				clonedNode.setUpper(null);
			}
			iterator.next(); 
			clonedNode = iterator.next;
		} while(iterator.hasNext() );
		if(!rootClone.isAdded() && !isRoot()) {
			BinaryTreeNode<E> lower = rootClone.getLowerSubNode();
			if(lower == null) {
				rootClone = rootClone.getUpperSubNode();
			} else if(rootClone.getUpperSubNode() == null) {
				rootClone = lower;
			}
		}
		if(recalculateSize && rootClone != null) {
			rootClone.size = SIZE_UNKNOWN;
			rootClone.size();
		}
		return rootClone;
	}
	BinaryTreeNode<E> cloneTreeBounds(Bounds<E> bounds) {
		return cloneTree(new ChangeTracker(), bounds);
	}
	public BinaryTreeNode<E> cloneTree() {
		return cloneTreeBounds(null);
	}
	@Override
	public int hashCode() {
		return getKey().hashCode();
    }
	public int treeHashCode()  {
		int hashCode = 0;
		Iterator<? extends BinaryTreeNode<?>> these = nodeIterator(true);
		while(these.hasNext()) {
			BinaryTreeNode<?> node = these.next();
			hashCode += node.hashCode();
		}
	    return hashCode;
	}
	@Override
	public boolean equals(Object o) {
		if (o == this) {
            return true;
		}
		if(o instanceof BinaryTreeNode<?>) {
			BinaryTreeNode<?> other = (BinaryTreeNode<?>) o;
			return getKey().equals(other.getKey());
		}
		return false;
	}
	public boolean treeEquals(BinaryTreeNode<?> other) {
		if (other == this) {
			return true;
		}
		if(other.size() != size()) {
			return false;
		}
		Iterator<? extends BinaryTreeNode<?>> these = nodeIterator(true),
				others = other.nodeIterator(true);
		while(these.hasNext()) {
			BinaryTreeNode<?> node = these.next(), otherNode = others.next();
			if(!node.equals(otherNode)) {
				return false;
			}
		}
		return true;
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Stream;
import inet.ipaddr.AddressComparator.CountComparator;
import inet.ipaddr.AddressComparator.ValueComparator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
public abstract class Address implements AddressSegmentSeries {
	private static final long serialVersionUID = 4L;
	public static interface AddressValueProvider {
		int getSegmentCount();
		SegmentValueProvider getValues();
		default SegmentValueProvider getUpperValues() {
			return getValues();
		}
	}
	@FunctionalInterface
	public static interface SegmentValueProvider {
		int getValue(int segmentIndex);
	}
	public static final String HEX_PREFIX = "0x";
	public static final String OCTAL_PREFIX = "0";
	public static final char RANGE_SEPARATOR = '-';
	public static final String RANGE_SEPARATOR_STR = String.valueOf(RANGE_SEPARATOR);
	public static final char ALTERNATIVE_RANGE_SEPARATOR = '\u00bb'; 
	public static final String ALTERNATIVE_RANGE_SEPARATOR_STR = String.valueOf(ALTERNATIVE_RANGE_SEPARATOR);
	public static final char SEGMENT_WILDCARD = '*';
	public static final String SEGMENT_WILDCARD_STR = String.valueOf(SEGMENT_WILDCARD);
	public static final String ALTERNATIVE_SEGMENT_WILDCARD_STR = "¿";
	public static final char SEGMENT_SQL_WILDCARD = '%';
	public static final String SEGMENT_SQL_WILDCARD_STR = String.valueOf(SEGMENT_SQL_WILDCARD);
	public static final char SEGMENT_SQL_SINGLE_WILDCARD = '_';
	public static final String SEGMENT_SQL_SINGLE_WILDCARD_STR = String.valueOf(SEGMENT_SQL_SINGLE_WILDCARD);
	public static final AddressComparator DEFAULT_ADDRESS_COMPARATOR = new CountComparator(true);
	public static final AddressComparator ADDRESS_LOW_VALUE_COMPARATOR = new ValueComparator(true, false);
	public static final AddressComparator ADDRESS_HIGH_VALUE_COMPARATOR = new ValueComparator(true, true);
	private static MACAddressNetwork macNetwork;
	private static IPv6AddressNetwork ipv6Network;
	private static IPv4AddressNetwork ipv4Network;
	final AddressSection addressSection;
	protected HostIdentifierString fromString;
	protected Address(AddressSection section) {
		addressSection = section;
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	protected Address(Function<Address, AddressSection> supplier) {
		addressSection = supplier.apply(this);
		if(!getNetwork().isCompatible(addressSection.getNetwork())) {
			throw new NetworkMismatchException(addressSection);
		}
	}
	public static IPv6AddressNetwork defaultIpv6Network() {
		if(ipv6Network == null) {
			synchronized(Address.class) {
				if(ipv6Network == null) {
					ipv6Network = new IPv6AddressNetwork();
				}
			}
		}
		return ipv6Network;
	}
	public static IPv4AddressNetwork defaultIpv4Network() {
		if(ipv4Network == null) {
			synchronized(Address.class) {
				if(ipv4Network == null) {
					ipv4Network = new IPv4AddressNetwork();
				}
			}
		}
		return ipv4Network;
	}
	public static MACAddressNetwork defaultMACNetwork() {
		if(macNetwork == null) {
			synchronized(Address.class) {
				if(macNetwork == null) {
					macNetwork = new MACAddressNetwork();
				}
			}
		}
		return macNetwork;
	}
	protected static String getMessage(String key) {
		return HostIdentifierException.getMessage(key);
	}
	@Override
	public int getSegmentCount() {
		return getSection().getSegmentCount();
	}
	@Override
	public int getDivisionCount() {
		return getSection().getDivisionCount();
	}
	@Override
	public int getBitCount() {
		return getSection().getBitCount();
	}
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	@Override
	public AddressSection getSection() {
		return addressSection;
	}
	@Override
	public void getSegments(AddressSegment segs[]) {
		getSection().getSegments(segs);
	}
	@Override
	public void getSegments(int start, int end, AddressSegment segs[], int index) {
		getSection().getSegments(start, end, segs, index);
	}
	@Override
	public abstract Iterable<? extends Address> getIterable();
	@Override
	public abstract Iterator<? extends Address> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> spliterator();
	@Override
	public abstract Stream<? extends Address> stream();
	@Override
	public abstract Iterator<? extends Address> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixStream();
	@Override
	public abstract Iterator<? extends Address> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends Address> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends Address> prefixBlockStream();
	@Override
	public abstract Address increment(long increment) throws AddressValueException;
	@Override
	public abstract Address incrementBoundary(long increment) throws AddressValueException;
	@Override
	public abstract Address getLower();
	@Override
	public abstract Address getUpper();
	@Override
	public boolean isMultiple() {
		return getSection().isMultiple();
	}
	@Override
	public boolean isPrefixed() {
		return getSection().isPrefixed();
	}
	public boolean isIPAddress() {
		return false;
	}
	public boolean isMACAddress() {
		return false;
	}
	public IPAddress toIPAddress() {
		return null;
	}
	public MACAddress toMACAddress() {
		return null;
	}
	@Override
	public Integer getPrefixLength() {
		return getSection().getPrefixLength();
	}
	@Override
	public int getMinPrefixLengthForBlock() {
		return getSection().getMinPrefixLengthForBlock();
	}
	@Override
	public Integer getPrefixLengthForSingleBlock() {
		return getSection().getPrefixLengthForSingleBlock();
	}
	public abstract boolean isMulticast();
	@Override
	public BigInteger getCount() {
		return getSection().getCount();
	}
	@Override
	public BigInteger getPrefixCount(int prefixLength) {
		return getSection().getPrefixCount(prefixLength);
	}
	@Override
	public BigInteger getPrefixCount() {
		return getSection().getPrefixCount();
	}
	@Override
	public BigInteger getBlockCount(int segmentCount) {
		return getSection().getBlockCount(segmentCount);
	}
	@Override
	public byte[] getBytes() {
		return getSection().getBytes();
	}
	@Override
	public byte[] getBytes(byte bytes[]) {
		return getSection().getBytes(bytes);
	}
	@Override
	public byte[] getBytes(byte bytes[], int index) {
		return getSection().getBytes(bytes, index);
	}
	@Override
	public byte[] getUpperBytes() {
		return getSection().getUpperBytes();
	}
	@Override
	public byte[] getUpperBytes(byte bytes[]) {
		return getSection().getUpperBytes(bytes);
	}
	@Override
	public byte[] getUpperBytes(byte bytes[], int index) {
		return getSection().getUpperBytes(bytes, index);
	}
	@Override
	public BigInteger getValue() {
		return getSection().getValue();
	}
	@Override
	public BigInteger getUpperValue() {
		return getSection().getUpperValue();
	}
	@Override
	public boolean isZero() {
		return getSection().isZero();
	}
	@Override
	public boolean includesZero() {
		return getSection().includesZero();
	}
	@Override
	public boolean isMax() {
		return getSection().isMax();
	}
	@Override
	public boolean includesMax() {
		return getSection().includesMax();
	}
	@Override
	public boolean isFullRange() {
		return getSection().isFullRange();
	}
	public abstract boolean isLocal();
	@Override
	public int hashCode() {
		return getSection().hashCode();
	}
	protected abstract boolean isFromSameString(HostIdentifierString otherString);
	public boolean isSameAddress(Address other) {
		return other == this || getSection().equals(other.getSection());
	}
	@Override
	public boolean equals(Object o) {
		if(o == this) {
			return true;
		}
		if(o instanceof Address) {
			Address other = (Address) o;
			if(isFromSameString(other.fromString)) {
				return true;
			}
			return isSameAddress(other);
		}
		return false;
	}
	public boolean prefixEquals(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixEquals(other.getSection());
	}
	public boolean overlaps(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().overlaps(other.getSection());
	}
	public boolean contains(Address other) {
		if(other == this) {
			return true;
		}
		return getSection().contains(other.getSection());
	}
	public abstract BigInteger enumerate(Address other);
	@Override
	public boolean isSequential() {
		return getSection().isSequential();
	}
	public HostIdentifierString toAddressString() {
		return fromString;
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		return getSection().toHexString(with0xPrefix);
	}
	@Override
	public String toNormalizedString() {
		return getSection().toNormalizedString();
	}
	@Override
	public String toCanonicalString() {
		return getSection().toCanonicalString();
	}
	@Override
	public String toCompressedString() {
		return getSection().toCompressedString();
	}
	@Override
	public String toString() {
		return toCanonicalString();
	}
	@Override
	public String[] getDivisionStrings() {
		return getSection().getDivisionStrings();
	}
	@Override
	public String[] getSegmentStrings() {
		return getSection().getSegmentStrings();
	}
	@Override
	public abstract Address reverseSegments();
	@Override
	public abstract Address reverseBits(boolean perByte);
	@Override
	public abstract Address reverseBytes();
	@Override
	public abstract Address reverseBytesPerSegment();
	@Override
	public boolean isPrefixBlock() {
		return getSection().isPrefixBlock();
	}
	@Override
	public boolean containsPrefixBlock(int prefixLength) {
		return getSection().containsPrefixBlock(prefixLength);
	}
	@Override
	public boolean isSinglePrefixBlock() {
		return getSection().isSinglePrefixBlock();
	}
	@Override
	public boolean containsSinglePrefixBlock(int prefixLength) {
		return getSection().containsSinglePrefixBlock(prefixLength);
	}
	@Override
	public abstract Address toPrefixBlock();
	@Override @Deprecated
	public abstract Address removePrefixLength();
	@Override
	public abstract Address withoutPrefixLength();
	@Override @Deprecated
	public abstract Address removePrefixLength(boolean zeroed);
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	public abstract Address adjustPrefixLength(int adjustment);
	@Override
	public abstract Address adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract Address setPrefixLength(int prefixLength);
	@Override
	public abstract Address setPrefixLength(int prefixLength, boolean zeroed);
	@Deprecated
	@Override
	public abstract Address applyPrefixLength(int networkPrefixLength);
	public static boolean matchUnordered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		boolean sameLen = len1 == len2;
		boolean result;
		if(len1 == 0 || len2 == 0) {
			result = sameLen;
		} else if(len1 == 1 && sameLen) {
			result = addrs1[0].equals(addrs2[0]);
		} else if(len1 == 2 && sameLen) {
			if(addrs1[0].equals(addrs2[0])) {
				result = addrs1[1].equals(addrs2[1]);
			} else if(result = addrs1[0].equals(addrs2[1])) {
				result = addrs1[1].equals(addrs2[0]);
			}
		} else {
			result = Objects.equals(asSet(addrs1), asSet(addrs2));
		}
		return result;
	}
	private static HashSet<Address> asSet(Address addrs[])  {
		int addrLen = addrs.length;
		if(addrLen > 0) {
			HashSet<Address> result = new HashSet<>();
			for(int i = 0; i < addrs.length; i++) {
				Address addr = addrs[i];
				result.add(addr);
			}
			return result;
		}
		return null;
	}
	public static boolean matchOrdered(Address addrs1[], Address addrs2[]) {
		int len1 = addrs1 == null ? 0 : addrs1.length;
		int len2 = addrs2 == null ? 0 : addrs2.length;
		if(len1 != len2) {
			return false;
		}
		for(int i = 0; i < len1; i++) {
			if(!addrs1[i].equals(addrs2[i])) {
				return false;
			}
		}
		return true;
	}
}
package inet.ipaddr.ipv6;
import java.util.Iterator;
import java.util.Spliterator;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.format.util.AddedTree;
import inet.ipaddr.format.util.AddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
public class IPv6AddressTrie extends AddressTrie<IPv6Address> {
	private static final long serialVersionUID = 1L;
	static final IPv6Address INIT_ROOT = new IPAddressString("::/0").getAddress().toIPv6();
	public IPv6AddressTrie() {
		super(new IPv6TrieNode());
	}
	protected IPv6AddressTrie(AddressBounds<IPv6Address> bounds) {
		super(new IPv6TrieNode(), bounds);
	}
	protected IPv6AddressTrie(IPv6TrieNode root, AddressBounds<IPv6Address> bounds) {
		super(root, bounds);
	}
	@Override
	protected IPv6TrieNode absoluteRoot() {
		return (IPv6TrieNode) super.absoluteRoot();
	}
	@Override
	protected IPv6AddressTrie createNew(AddressBounds<IPv6Address> bounds) {
		return new IPv6AddressTrie(bounds);
	}
	@Override
	protected IPv6AddressTrie createSubTrie(AddressBounds<IPv6Address> bounds) {
		return new IPv6AddressTrie(absoluteRoot(), bounds);
	}
	@Override
	public IPv6TrieNode getRoot() {
		return (IPv6TrieNode) super.getRoot();
	}
	public static class IPv6TrieNode extends TrieNode<IPv6Address> {
		private static final long serialVersionUID = 1L;
		protected IPv6TrieNode(IPv6Address addr) {
			super(addr);
		}
		public IPv6TrieNode() {
			super(INIT_ROOT);
		} 
		@Override
		protected void replaceThisRoot(BinaryTreeNode<IPv6Address> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		@Override
		public IPv6TrieNode getUpperSubNode() {
			return (IPv6TrieNode) super.getUpperSubNode();
		}
		@Override
		public IPv6TrieNode getLowerSubNode() {
			return (IPv6TrieNode) super.getLowerSubNode();
		}
		@Override
		public IPv6TrieNode getParent() {
			return (IPv6TrieNode) super.getParent();
		}
		@Override
		protected IPv6TrieNode createNewImpl(IPv6Address addr) {
			return new IPv6TrieNode(addr);
		}
		@Override
		public IPv6TrieNode removeElementsContainedBy(IPv6Address addr) {
			return (IPv6TrieNode) super.removeElementsContainedBy(addr);
		}
		@Override
		public IPv6TrieNode elementsContainedBy(IPv6Address addr) {
			return (IPv6TrieNode) super.elementsContainedBy(addr);
		}
		@Override
		public IPv6TrieNode elementsContaining(IPv6Address addr) {
			return (IPv6TrieNode) super.elementsContaining(addr);
		}
		@Override
		public IPv6TrieNode longestPrefixMatchNode(IPv6Address addr) {
			return (IPv6TrieNode) super.longestPrefixMatchNode(addr);
		}
		@Override
		public IPv6TrieNode getAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.getAddedNode(addr);
		}
		@Override
		public IPv6TrieNode getNode(IPv6Address addr) {
			return (IPv6TrieNode) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> nodeIterator(boolean forward) {
			return (Iterator<IPv6TrieNode>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> allNodeIterator(boolean forward) {
			return (Iterator<IPv6TrieNode>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv6TrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv6TrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv6TrieNode, IPv6Address, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<IPv6TrieNode, IPv6Address, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6TrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv6TrieNode, IPv6Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<IPv6TrieNode, IPv6Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6TrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6TrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6TrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv6TrieNode> nodeSpliterator(boolean forward) {
			return (Spliterator<IPv6TrieNode>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv6TrieNode> allNodeSpliterator(boolean forward) {
			return (Spliterator<IPv6TrieNode>) super.allNodeSpliterator(forward);
		}
		@Override
		public IPv6TrieNode previousAddedNode() {
			return (IPv6TrieNode) super.previousAddedNode();
		}
		@Override
		public IPv6TrieNode nextAddedNode() {
			return (IPv6TrieNode) super.nextAddedNode();
		}
		@Override
		public IPv6TrieNode nextNode() {
			return (IPv6TrieNode) super.nextNode();
		}
		@Override
		public IPv6TrieNode previousNode() {
			return (IPv6TrieNode) super.previousNode();
		}
		@Override
		public IPv6TrieNode lowerAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.lowerAddedNode(addr);
		}
		@Override
		public IPv6TrieNode floorAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.floorAddedNode(addr);
		}
		@Override
		public IPv6TrieNode higherAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.higherAddedNode(addr);
		}
		@Override
		public IPv6TrieNode ceilingAddedNode(IPv6Address addr) {
			return (IPv6TrieNode) super.ceilingAddedNode(addr);
		}
		@Override
		public IPv6TrieNode firstNode() {
			return (IPv6TrieNode) super.firstNode();
		}
		@Override
		public IPv6TrieNode lastNode() {
			return (IPv6TrieNode) super.lastNode();
		}
		@Override
		public IPv6TrieNode firstAddedNode() {
			return (IPv6TrieNode) super.firstAddedNode();
		}
		@Override
		public IPv6TrieNode lastAddedNode() {
			return (IPv6TrieNode) super.lastAddedNode();
		}
		@Override
		protected IPv6AddressTrie createNewTree() {
			return new IPv6AddressTrie();
		}
		@Override
		public IPv6AddressTrie asNewTrie() {
			return (IPv6AddressTrie) super.asNewTrie();
		}
		@Override
		public IPv6TrieNode cloneTree() {
			return (IPv6TrieNode) super.cloneTree();
		}
		@Override
		public IPv6TrieNode clone() {
			return (IPv6TrieNode) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6TrieNode && super.equals(o);
		}
		static class IPv6TrieKeyData extends TrieKeyData {
			long uint64HighVal, uint64LowVal, mask64HighVal, mask64LowVal, nextBitMask64Val;
			@Override
			public boolean is128Bits() {
				return true;
			}
			@Override
			public long getUint64LowVal() {
				return uint64LowVal;
			}
			@Override
			public long getUint64HighVal() {
				return uint64HighVal;
			}
			@Override
			public long getMask64HighVal() {
				return mask64HighVal;
			}
			@Override
			public long getMask64LowVal() {
				return mask64LowVal;
			}
			@Override
			public long getNextBitMask64Val() {
				return nextBitMask64Val;
			}
		}
		@Override
		protected IPv6TrieKeyData getTrieKeyCache(IPv6Address addr) {
			return addr.getTrieKeyCache();
		}
	}
	@Override
	public IPv6TrieNode removeElementsContainedBy(IPv6Address addr) {
		return (IPv6TrieNode) super.removeElementsContainedBy(addr);
	}
	@Override
	public IPv6TrieNode elementsContainedBy(IPv6Address addr) {
		return (IPv6TrieNode) super.elementsContainedBy(addr);
	}
	@Override
	public IPv6TrieNode elementsContaining(IPv6Address addr) {
		return (IPv6TrieNode) super.elementsContaining(addr);
	}
	@Override
	public IPv6TrieNode longestPrefixMatchNode(IPv6Address addr) {
		return (IPv6TrieNode) super.longestPrefixMatchNode(addr);
	}
	@Override
	public IPv6TrieNode getAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.getAddedNode(addr);
	}
	@Override
	public IPv6TrieNode getNode(IPv6Address addr) {
		return (IPv6TrieNode) super.getNode(addr);
	}
	@Override
	public IPv6TrieNode addNode(IPv6Address addr) {
		return (IPv6TrieNode) super.addNode(addr);
	}
	@Override
	public IPv6TrieNode addTrie(TrieNode<IPv6Address> trie) {
		return (IPv6TrieNode) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> nodeIterator(boolean forward) {
		return (Iterator<IPv6TrieNode>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> allNodeIterator(boolean forward) {
		return (Iterator<IPv6TrieNode>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv6TrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv6TrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv6TrieNode, IPv6Address, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<IPv6TrieNode, IPv6Address, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6TrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv6TrieNode, IPv6Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<IPv6TrieNode, IPv6Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6TrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6TrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6TrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv6TrieNode> nodeSpliterator(boolean forward) {
		return (Spliterator<IPv6TrieNode>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv6TrieNode> allNodeSpliterator(boolean forward) {
		return (Spliterator<IPv6TrieNode>) super.allNodeSpliterator(forward);
	}
	@Override
	public IPv6TrieNode lowerAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.lowerAddedNode(addr);
	}
	@Override
	public IPv6TrieNode floorAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.floorAddedNode(addr);
	}
	@Override
	public IPv6TrieNode higherAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.higherAddedNode(addr);
	}
	@Override
	public IPv6TrieNode ceilingAddedNode(IPv6Address addr) {
		return (IPv6TrieNode) super.ceilingAddedNode(addr);
	}
	@Override
	public IPv6TrieNode firstNode() {
		return (IPv6TrieNode) super.firstNode();
	}
	@Override
	public IPv6TrieNode lastNode() {
		return (IPv6TrieNode) super.lastNode();
	}
	@Override
	public IPv6TrieNode firstAddedNode() {
		return (IPv6TrieNode) super.firstAddedNode();
	}
	@Override
	public IPv6TrieNode lastAddedNode() {
		return (IPv6TrieNode) super.lastAddedNode();
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof IPv6AddressTrie && super.equals(o);
	}
	@Override
	public IPv6AddressTrie clone() {
		return (IPv6AddressTrie) super.clone();
	}
	@Override
	public AddedTree<IPv6Address> constructAddedNodesTree() {
		IPv6AddressAssociativeTrie<SubNodesMappingBasic<IPv6Address>> trie = new IPv6AddressAssociativeTrie<SubNodesMappingBasic<IPv6Address>>();
		contructAddedTree(trie);
		return new AddedTree<IPv6Address>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		IPv6AddressAssociativeTrie<SubNodesMappingBasic<IPv6Address>> trie = new IPv6AddressAssociativeTrie<SubNodesMappingBasic<IPv6Address>>();
		contructAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import inet.ipaddr.Address;
import inet.ipaddr.AddressSegment;
import inet.ipaddr.AddressSegmentSeries;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressSegment;
import inet.ipaddr.format.util.AddressTrie.TrieNode.FollowingBits;
import inet.ipaddr.format.util.AddressTrie.TrieNode.KeyCompareResult;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.format.util.BinaryTreeNode.BlockSizeNodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.Bounds;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
import inet.ipaddr.format.util.BinaryTreeNode.Indents;
import inet.ipaddr.format.util.BinaryTreeNode.KeySpliterator;
import inet.ipaddr.format.util.BinaryTreeNode.NodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.NodeSpliterator;
import inet.ipaddr.format.util.BinaryTreeNode.PostOrderNodeIterator;
import inet.ipaddr.format.util.BinaryTreeNode.PreOrderNodeIterator;
import inet.ipaddr.format.validate.ParsedAddressGrouping;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public abstract class AddressTrie<E extends Address> extends AbstractTree<E> {
	private static final long serialVersionUID = 1L;
	protected static class AddressBounds<E extends Address> extends Bounds<E> {
		private static final long serialVersionUID = 1L;
		E oneAboveUpperBound, oneBelowUpperBound, oneAboveLowerBound, oneBelowLowerBound;
		AddressBounds(E lowerBound, E upperBound, Comparator<? super E> comparator) {
			this(lowerBound, true, upperBound, false, comparator);
		}
		AddressBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			super(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
			if(lowerBound != null) {
				checkBlockOrAddress(lowerBound, true);
			}
			if(upperBound != null) {
				checkBlockOrAddress(upperBound, true);
			}
		}
		static <E extends Address> AddressBounds<E> createNewBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			if(lowerBound != null) {
				if(lowerInclusive && lowerBound.isZero()) {
					lowerBound = null;
				}
			}
			if(upperBound != null) {
				if(upperInclusive && upperBound.isMax()) {
					upperBound = null;
				}
			}
			if(lowerBound == null && upperBound == null) {
				return null;
			}
			return new AddressBounds<E>(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		@Override
		AddressBounds<E> createBounds(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive, Comparator<? super E> comparator) {
			return new AddressBounds<E>(lowerBound, lowerInclusive, upperBound, upperInclusive, comparator);
		}
		@Override
		AddressBounds<E> restrict(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			return (AddressBounds<E>) super.restrict(lowerBound, lowerInclusive, upperBound, upperInclusive);
		}
		@Override
		AddressBounds<E> intersect(E lowerBound, boolean lowerInclusive, E upperBound, boolean upperInclusive) {
			return (AddressBounds<E>) super.intersect(lowerBound, lowerInclusive, upperBound, upperInclusive);
		}
		@Override
		boolean isAdjacentAboveUpperBound(E addr) {
			E res = oneAboveUpperBound;
			if(res == null) {
				res = increment(upperBound);
				oneAboveUpperBound = res;
			}
			return res != null && res.equals(addr);
		}
		@Override
		boolean isAdjacentBelowLowerBound(E addr) {
			E res = oneBelowLowerBound;
			if(res == null) {
				res = decrement(lowerBound);
				oneBelowLowerBound = res;
			}
			return res != null && res.equals(addr);
		}
		@Override
		boolean isAdjacentBelowUpperBound(E addr) { 
			E res = oneBelowUpperBound;
			if(res == null) {
				res = decrement(upperBound);
				oneBelowUpperBound = res;
			}
			return res != null && res.equals(addr);
		}
		@Override
		boolean isAdjacentAboveLowerBound(E addr) {
			E res = oneAboveLowerBound;
			if(res == null) {
				res = increment(lowerBound);
				oneAboveLowerBound = res;
			}
			return res != null && res.equals(addr);
		}
		@Override
		boolean isMax(E addr) {
			return addr.isMax();
		}
		@Override
		boolean isMin(E addr) {
			return addr.isZero();
		}
		@Override
		public String toCanonicalString(String separator) {
			Function<? super E, String> stringer = Address::toCanonicalString;
			return toString(stringer, separator, stringer);
		}
	}
	protected static enum Operation {
	    INSERT, 
	    REMAP, 
	    LOOKUP, 
	    NEAR, 
	    CONTAINING, 
	    ALL_CONTAINING, 
	    INSERTED_DELETE, 
	    SUBTREE_DELETE 
	}
	protected static class OpResult<E extends Address> implements KeyCompareResult, FollowingBits, Serializable {
		private static final long serialVersionUID = 1L;
		E addr;
		boolean nearestFloor; 
		boolean nearExclusive;
		Operation op;
		OpResult() {}
		OpResult(E addr, Operation op) {
			this(addr, op, false, false);
		}
		OpResult(E addr, boolean floor, boolean exclusive) {
			this(addr, Operation.NEAR, floor, exclusive);
		}
		private OpResult(E addr, Operation op, boolean floor, boolean exclusive) {
			this.addr = addr;
			this.op = op;
			this.nearestFloor = floor;
			this.nearExclusive = exclusive;
		}
		OpResult<E> reset(E addr, Operation op) {
			this.addr = addr;
			this.op = op;
			return this;
		}
		OpResult<E> resetNear(E addr, boolean floor, boolean exclusive) {
			this.nearestFloor = floor;
			this.nearExclusive = exclusive;
			return reset(addr, Operation.NEAR);
		}
		void clean() {
			addr = null;
			op = null;
			exists = false;
			existingNode = containing = containingEnd = 
					smallestContaining = largestContaining = 
					containedBy = null;
			nearestFloor = nearExclusive = false;
			nearestNode = backtrackNode = null;
			deleted = null;
			newValue = existingValue = null;
			inserted = added = addedAlready = null;
			remapper = null;
		}
		boolean exists;
		TrieNode<E> existingNode;
		TrieNode<E> nearestNode;
		TrieNode<E> backtrackNode;
		TrieNode<E> containing, containingEnd;
		TrieNode<E> smallestContaining, largestContaining;
		TrieNode<E> containedBy;
		TrieNode<E> deleted;
		Object newValue, existingValue;
		TrieNode<E> inserted;
		TrieNode<E> added;
		TrieNode<E> addedAlready;
		Function<?, ?> remapper;
		static <E extends Address> TrieNode<E> getNextAdded(TrieNode<E> node) {
			while(node != null && !node.isAdded()) {
				TrieNode<E> next = node.getUpperSubNode();
				if(next == null) {
					node = node.getLowerSubNode();
				} else {
					node = next;
				}
			}
			return node;
		}
		TrieNode<E> getContaining() {
			TrieNode<E> containing = getNextAdded(this.containing);
			this.containing = containing;
			if(containing != null) {
				TrieNode<E> current = containing;
				do {
					TrieNode<E> next = current.getUpperSubNode();
					TrieNode<E> nextAdded;
					if(next == null) {
						next = current.getLowerSubNode();
						nextAdded = getNextAdded(next);
						if(next != nextAdded) {
							current.setLower(nextAdded);
						}
					} else {
						nextAdded = getNextAdded(next);
						if(next != nextAdded) {
							current.setUpper(nextAdded);
						}
					}
					current = nextAdded;
				} while(current != null);
			}
			return containing;
		}
		void addContaining(TrieNode<E> containingSub) {
			TrieNode<E> cloned = containingSub.clone();
			if(containing == null) {
				containing = cloned;
			} else {
				Comparator<BinaryTreeNode<E>> comp = nodeComparator();
				if(comp.compare(containingEnd, cloned) > 0) {
					containingEnd.setLower(cloned);
				} else {
					containingEnd.setUpper(cloned);
				}
				containingEnd.adjustCount(1);
			}
			containingEnd = cloned;
		}
		long followingBits;
		@Override
		public void setFollowingBits(long bits) {
			followingBits = bits;
		}
		TrieNode<E> node;
		@Override
		public void bitsMatch() {
			E existingAddr = node.getKey();
			Integer existingPref = existingAddr.getPrefixLength();
			Integer newPrefixLen = addr.getPrefixLength();
			containedBy = node;
			if(existingPref == null) {
				if(newPrefixLen == null) {
					node.handleMatch(this);
				} else if(newPrefixLen == existingAddr.getBitCount()) {
					node.handleMatch(this);
				} else  {
					node.handleContained(this, newPrefixLen);
				}
			} else { 
				if(newPrefixLen.intValue() == existingPref.intValue()) {
					if(node.isAdded()) {
						node.handleMatch(this);
					} else {
						node.handleNodeMatch(this);
					}
				} else if(existingPref == existingAddr.getBitCount()) { 
					node.handleMatch(this);
				} else { 
					node.handleContained(this, newPrefixLen);
				}
			}
		}
		@Override
		public void bitsDoNotMatch(int matchedBits) {
			node.handleSplitNode(this, matchedBits);
		}
		@Override
		public FollowingBits bitsMatchPartially() {
			if(node.isAdded()) {
				node.handleContains(this);
				if(op == Operation.CONTAINING) {
					return null;
				}
			}
			return this;
		}
	}
	public static class AddressComparator<E extends Address> implements Comparator<E>, Serializable {
		private static final long serialVersionUID = 1L;
		@Override
		public int compare(E o1, E o2) {
			if(o1 == o2) {
				return 0;
			}
			int segmentCount = o1.getSegmentCount();
			int bitsPerSegment = o1.getBitsPerSegment();
			Integer o1Pref = o1.getPrefixLength();
			Integer o2Pref = o2.getPrefixLength();
			int bitsMatchedSoFar = 0;
			int i = 0;
			while(true) {
				AddressSegment segment1 = o1.getSegment(i);
				AddressSegment segment2 = o2.getSegment(i);
				Integer pref1 = getSegmentPrefLen(o1, o1Pref, bitsPerSegment, bitsMatchedSoFar, segment1);
				Integer pref2 = getSegmentPrefLen(o2, o2Pref, bitsPerSegment, bitsMatchedSoFar, segment2);
				int segmentPref2;
				if(pref1 != null) {
					int segmentPref1 = pref1;
					if(pref2 != null && (segmentPref2 = pref2) <= segmentPref1) {
						int matchingBits = getMatchingBits(segment1, segment2, segmentPref2, bitsPerSegment);
						if(matchingBits >= segmentPref2) {
							if(segmentPref2 == segmentPref1) {
								return 0;
							}
							return segment1.isOneBit(segmentPref2) ? 1 : -1;
						}
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					} else {
						int matchingBits = getMatchingBits(segment1, segment2, segmentPref1, bitsPerSegment);
						if(matchingBits >= segmentPref1) {
							if(segmentPref1 < bitsPerSegment) {
								return segment2.isOneBit(segmentPref1) ? -1 : 1;
							} else if(++i == segmentCount) {
								return 1; 
							} 
						} else {
							return segment1.getSegmentValue() - segment2.getSegmentValue();
						}
					}
				} else if(pref2 != null) {
					segmentPref2 = pref2;
					int matchingBits = getMatchingBits(segment1, segment2, segmentPref2, bitsPerSegment);
					if(matchingBits >= pref2) {
						if(segmentPref2 < bitsPerSegment) {
							return segment1.isOneBit(segmentPref2) ? 1 : -1;
						} else if(++i == segmentCount) {
							return -1; 
						} 
					} else {
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					}
				} else {
					int matchingBits = getMatchingBits(segment1, segment2, bitsPerSegment, bitsPerSegment);
					if(matchingBits < bitsPerSegment) { 
						return segment1.getSegmentValue() - segment2.getSegmentValue();
					} else if(++i == segmentCount) {
						return 0;
					} 
				}
				bitsMatchedSoFar += bitsPerSegment;
			}
		}
	}
	@SuppressWarnings("unchecked")
	public static <E extends Address> E increment(E addr) {
		if(addr.isMax()) {
			return null;
		}
		if(addr.isIPAddress()) {
			IPAddress ipaddr = addr.toIPAddress();
			if(addr.isPrefixed()) {
				return (E) ipaddr.getUpper().setPrefixLength(ipaddr.getPrefixLength() + 1).toZeroHost();
			}
			return (E) ipaddr.toPrefixBlock(ipaddr.getBitCount() - (ipaddr.getTrailingBitCount(false) + 1));
		}
		if(addr.isPrefixed()) {
			return (E) addr.getUpper().setPrefixLength(addr.getPrefixLength() + 1).toPrefixBlock().getLower();
		}
		int trailingBitCount = 0;
		for(int i = addr.getSegmentCount() - 1; i >= 0; i--) {
			AddressSegment seg = addr.getSegment(i);
			if(!seg.isMax()) {
				trailingBitCount += Integer.numberOfTrailingZeros(~seg.getSegmentValue());
				break;
			}
			trailingBitCount += seg.getBitCount();
		}
		return (E) addr.setPrefixLength(addr.getBitCount() - (trailingBitCount + 1)).toPrefixBlock();
	}
	@SuppressWarnings("unchecked")
	public static <E extends Address> E decrement(E addr) {
		if(addr.isZero()) {
			return null;
		}
		if(addr.isIPAddress()) {
			IPAddress ipaddr = addr.toIPAddress();
			if(addr.isPrefixed()) {
				return (E) ipaddr.getLower().setPrefixLength(ipaddr.getPrefixLength() + 1).toMaxHost();
			}
			return (E) ipaddr.toPrefixBlock(ipaddr.getBitCount() - (ipaddr.getTrailingBitCount(true) + 1));
		}
		if(addr.isPrefixed()) {
			return (E) addr.getLower().setPrefixLength(addr.getPrefixLength() + 1).toPrefixBlock().getUpper();
		}
		int trailingBitCount = 0;
		for(int i = addr.getSegmentCount() - 1; i >= 0; i--) {
			AddressSegment seg = addr.getSegment(i);
			if(!seg.isZero()) {
				trailingBitCount += Integer.numberOfTrailingZeros(seg.getSegmentValue());
				break;
			}
			trailingBitCount += seg.getBitCount();
		}
		return (E) addr.setPrefixLength(addr.getBitCount() - (trailingBitCount + 1)).toPrefixBlock();
	}
	public static class TrieComparator<E extends Address> implements Comparator<BinaryTreeNode<E>>, Serializable {
		private static final long serialVersionUID = 1L;
		Comparator<E> comparator;
		TrieComparator(Comparator<E> comparator) {
			this.comparator = comparator;
		}
		@Override
		public int compare(BinaryTreeNode<E> tree1, BinaryTreeNode<E> tree2) {
			E o1 = tree1.getKey();
			E o2 = tree2.getKey();
			return comparator.compare(o1, o2);
		}
	};
	public static abstract class TrieNode<E extends Address> extends BinaryTreeNode<E> implements AddressTrieOps<E> {
		private static final long serialVersionUID = 1L;
		protected TrieNode(E item) {
			super(item);
		}
		@Override
		public TrieNode<E> getParent() {
			return (TrieNode<E>) super.getParent();
		}
		@Override
		public TrieNode<E> getUpperSubNode() {
			return (TrieNode<E>) super.getUpperSubNode();
		}
		@Override
		public TrieNode<E> getLowerSubNode() {
			return (TrieNode<E>) super.getLowerSubNode();
		}
		private TrieNode<E> findNodeNear(E addr, boolean below, boolean exclusive) {
			addr = checkBlockOrAddress(addr, true);
			return findNodeNearNoCheck(addr, below, exclusive);
		}
		private TrieNode<E> findNodeNearNoCheck(E addr, boolean below, boolean exclusive) {
			OpResult<E> result = new OpResult<>(addr, below, exclusive);
			matchBits(result);
			TrieNode<E> backtrack = result.backtrackNode;
			if(backtrack != null) {
				TrieNode<E> parent = backtrack.getParent();
				while(parent != null && 
						(backtrack == (below ? parent.getLowerSubNode() : parent.getUpperSubNode()))) {
					backtrack = parent;
					parent = backtrack.getParent();
				}
				if(parent != null) {
					if(parent.isAdded()) {
						result.nearestNode = parent;
					} else {
						result.nearestNode = (below ? parent.previousAddedNode() : parent.nextAddedNode());
					}
				}
			}
			return result.nearestNode;
		}
		@Override
		public TrieNode<E> previousAddedNode() {
			return (TrieNode<E>) super.previousAddedNode();
		}
		@Override
		public TrieNode<E> nextAddedNode() {
			return (TrieNode<E>) super.nextAddedNode();
		}
		@Override
		public TrieNode<E> nextNode() {
			return (TrieNode<E>) super.nextNode();
		}
		@Override
		public TrieNode<E> previousNode() {
			return (TrieNode<E>) super.previousNode();
		}
		@Override
		public TrieNode<E> firstNode() {
			return (TrieNode<E>) super.firstNode();
		}
		@Override
		public TrieNode<E> firstAddedNode() {
			return (TrieNode<E>) super.firstAddedNode();
		}
		@Override
		public TrieNode<E> lastNode() {
			return (TrieNode<E>) super.lastNode();
		}
		@Override
		public TrieNode<E> lastAddedNode() {
			return (TrieNode<E>) super.lastAddedNode();
		}
		@Override
		public TrieNode<E> lowerAddedNode(E addr) {
			return findNodeNear(addr, true, true);
		}
		TrieNode<E> lowerNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, true, true);
		}
		@Override
		public E lower(E addr) {
			return getNodeKey(lowerAddedNode(addr));
		}
		@Override
		public TrieNode<E> floorAddedNode(E addr) {
			return findNodeNear(addr, true, false);
		}
		TrieNode<E> floorNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, true, false);
		}
		@Override
		public E floor(E addr) {
			return getNodeKey(floorAddedNode(addr));
		}
		@Override
		public TrieNode<E> higherAddedNode(E addr) {
			return findNodeNear(addr, false, true);
		}
		TrieNode<E> higherNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, false, true);
		}
		@Override
		public E higher(E addr) {
			return getNodeKey(higherAddedNode(addr));
		}
		@Override
		public TrieNode<E> ceilingAddedNode(E addr) {
			return findNodeNear(addr, false, false);
		}
		TrieNode<E> ceilingNodeNoCheck(E addr) {
			return findNodeNearNoCheck(addr, false, false);
		}
		@Override
		public E ceiling(E addr) {
			return getNodeKey(ceilingAddedNode(addr));
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> nodeIterator(boolean forward) {
			return (Iterator<? extends TrieNode<E>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> allNodeIterator(boolean forward) {
			return (Iterator<? extends TrieNode<E>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		public Iterator<? extends TrieNode<E>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends TrieNode<E>>) super.blockSizeNodeIterator(lowerSubNodeFirst, true);
		}
		@SuppressWarnings("unchecked")
		public Iterator<? extends TrieNode<E>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends TrieNode<E>>) super.blockSizeNodeIterator(lowerSubNodeFirst, false);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends TrieNode<E>, E, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<? extends TrieNode<E>, E, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends TrieNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<? extends TrieNode<E>, E, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends TrieNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends TrieNode<E>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@Override
		public Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, true);
		}
		@Override
		public Spliterator<? extends TrieNode<E>> allNodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, false);
		}
		@SuppressWarnings("unchecked")
		Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
			Comparator<BinaryTreeNode<E>> comp = forward ? nodeComparator() : reverseNodeComparator();
			Spliterator<? extends BinaryTreeNode<E>> spliterator = new NodeSpliterator<E>(
					forward,
					comp,
					this,
					forward ? firstNode() : lastNode(),
					getParent(),
					size(),
					changeTracker,
					addedNodesOnly );
			return (Spliterator<? extends TrieNode<E>>) spliterator;
		}
		@Override
		public Spliterator<E> spliterator() {
			return new KeySpliterator<E>(nodeSpliterator(true, true), comparator());
		}
		@Override
		public Spliterator<E> descendingSpliterator() {
			return new KeySpliterator<E>(nodeSpliterator(false, true), reverseComparator());
		}
		@Override
		public boolean contains(E addr) {
			return doLookup(addr).exists;
		}
		@Override
		public boolean remove(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.INSERTED_DELETE);
			matchBits(result);
			return result.exists;
		}
		@Override
		public TrieNode<E> getNode(E addr) {
			return doLookup(addr).existingNode;
		}
		@Override
		public TrieNode<E> removeElementsContainedBy(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.SUBTREE_DELETE);
			matchBits(result);
			return result.deleted;
		}
		@Override
		public TrieNode<E> elementsContainedBy(E addr) {
			return doLookup(addr).containedBy;
		}
		@Override
		public TrieNode<E> elementsContaining(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.ALL_CONTAINING);
			matchBits(result);
			return result.getContaining();
		}
		@Override
		public E longestPrefixMatch(E addr) {
			TrieNode<E> node = longestPrefixMatchNode(addr);
			return node == null ? null : node.getKey();
		}
		@Override
		public TrieNode<E> longestPrefixMatchNode(E addr) {
			return doLookup(addr).smallestContaining;
		}
		@Override
		public E shortestPrefixMatch(E addr) {
			TrieNode<E> node = shortestPrefixMatchNode(addr);
			return node == null ? null : node.getKey();
		}
		@Override
		public TrieNode<E> shortestPrefixMatchNode(E addr) {
			return doElementContains(addr);
		}
		@Override
		public boolean elementContains(E addr) {
			return doElementContains(addr) != null;
		}
		private TrieNode<E> doElementContains(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.CONTAINING);
			matchBits(result);
			return result.largestContaining;
		}
		protected OpResult<E> doLookup(E addr) {
			addr = checkBlockOrAddress(addr, true);
			OpResult<E> result = new OpResult<>(addr, Operation.LOOKUP);
			matchBits(result);
			return result;
		}
		private void removeSubtree(OpResult<E> result) {
			result.deleted = this;
			clear();
		}
		protected void removeOp(OpResult<E> result) {
			result.deleted = this;
			remove();
		}
		void matchBits(OpResult<E> result) {
			matchBitsFromIndex(0, result);
		}
		void matchBitsFromIndex(int bitIndex, OpResult<E> result) {
			TrieNode<E> matchNode = this; 
			E newAddr = result.addr;
			Operation op = result.op;
			TrieKeyData newKeyData = getTrieKeyCache(newAddr);
			boolean simpleMatch = newKeyData != null && op != Operation.INSERT && op != Operation.NEAR && op != Operation.REMAP;
			E existingAddr = getKey();
			while(true) {
				result.node = matchNode;
				boolean continueToNext = matchAddressBits(simpleMatch, newAddr, existingAddr, bitIndex, result, newKeyData);
				if(continueToNext) {
					int bits = existingAddr.getPrefixLength();
					matchNode = matchNode.matchSubNode(bits, result);
					if(matchNode == null) {
						break;
					}
					bitIndex = bits + 1;
					existingAddr = matchNode.getKey();
				} else {
					break;
				}
			}
			result.node = null;
		}
		static interface FollowingBits {
			void setFollowingBits(long bits);
		}
		static interface KeyCompareResult {
			void bitsMatch();
			void bitsDoNotMatch(int matchedBits);
			FollowingBits bitsMatchPartially();
		}
		protected static class TrieKeyData {
			public Integer prefixLength;
			public boolean is32Bits() {
				return false;
			}
			public int getUint32Val() {
				return 0;
			}
			public int getMask32Val() {
				return 0;
			}
			public int getNextBitMask32Val() {
				return 0;
			}
			public boolean is128Bits() {
				return false;
			}
			public long getUint64LowVal() {
				return 0;
			}
			public long getUint64HighVal() {
				return 0;
			}
			public long getMask64HighVal() {
				return 0;
			}
			public long getMask64LowVal() {
				return 0;
			}
			public long getNextBitMask64Val() {
				return 0;
			}
		}
		protected TrieKeyData getTrieKeyCache(E addr) {
			return null;
		}
		boolean matchAddressBits(boolean simpleSearch, E newAddr, E existingAddr, int bitIndex, TrieNode.KeyCompareResult handleMatch, TrieKeyData newTrieCache)  {
			if(simpleSearch) {
				TrieKeyData existingTrieCache = getTrieKeyCache(existingAddr);
				if(existingTrieCache != null) {
					if(existingTrieCache.is32Bits()) {
						if(newTrieCache.is32Bits()) {
							int existingVal = existingTrieCache.getUint32Val();
							Integer existingPrefLen = existingTrieCache.prefixLength;
							if(existingPrefLen == null) {
								int newVal = newTrieCache.getUint32Val();
								if(newVal == existingVal) {
									handleMatch.bitsMatch();
								} else {
									Integer newPrefLen = newTrieCache.prefixLength;
									if(newPrefLen != null) {
										int newMask = newTrieCache.getMask32Val();
										if((newVal & newMask) == (existingVal & newMask)) {
											handleMatch.bitsMatch();
										}
									}
								}
							} else {
								int existingPrefLenBits = existingPrefLen;
								Integer newPrefLen = newTrieCache.prefixLength;
								if(existingPrefLenBits == 0) {
									if(newPrefLen != null && newPrefLen == 0) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											followingBits.setFollowingBits(newTrieCache.getUint32Val() & 0x80000000);
											return true;
										}
									}
								} else if(existingPrefLenBits == bitIndex) { 
									if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											int nextBitMask = existingTrieCache.getNextBitMask32Val();
											followingBits.setFollowingBits(newTrieCache.getUint32Val() & nextBitMask);
											return true;
										}
									}
								} else {
									int existingMask = existingTrieCache.getMask32Val();
									int newVal = newTrieCache.getUint32Val();
									if((newVal & existingMask) == (existingVal & existingMask)) {
										if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												int nextBitMask = existingTrieCache.getNextBitMask32Val();
												followingBits.setFollowingBits(newVal & nextBitMask);
												return true;
											}
										}
									} else if(newPrefLen != null) {
										int newPrefLenBits = newPrefLen;
										if(existingPrefLenBits > newPrefLenBits) {
											int newMask = newTrieCache.getMask32Val();
											if((newTrieCache.getUint32Val() & newMask) == (existingVal & newMask)) {
												handleMatch.bitsMatch();
											}
										}
									} 
								}
							}
							return false;
						}
					} else if(existingTrieCache.is128Bits()) {
						if(newTrieCache != null && newTrieCache.is128Bits()) {
							Integer existingPrefLen = existingTrieCache.prefixLength;
							if(existingPrefLen == null) {
								long newLowVal = newTrieCache.getUint64LowVal();
								long existingLowVal = existingTrieCache.getUint64LowVal();
								if(newLowVal == existingLowVal &&
									newTrieCache.getUint64HighVal() == existingTrieCache.getUint64HighVal()) {
									handleMatch.bitsMatch();
								} else {
									Integer newPrefLen = newTrieCache.prefixLength;
									if(newPrefLen != null) {
										long newMaskLow = newTrieCache.getMask64LowVal();
										if((newLowVal & newMaskLow) == (existingLowVal & newMaskLow)) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												handleMatch.bitsMatch();
											}
										}
									} 
								}
							} else {
								int existingPrefLenBits = existingPrefLen;
								Integer newPrefLen = newTrieCache.prefixLength;
								if(existingPrefLenBits == 0) {
									if(newPrefLen != null && newPrefLen == 0) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											followingBits.setFollowingBits(newTrieCache.getUint64HighVal() & 0x8000000000000000L);
											return true;
										}
									}
								} else if(existingPrefLenBits == bitIndex) { 
									if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
										handleMatch.bitsMatch();
									} else {
										FollowingBits followingBits = handleMatch.bitsMatchPartially();
										if(followingBits != null) {
											long nextBitMask = existingTrieCache.getNextBitMask64Val();
											if(bitIndex > 63)  {
												followingBits.setFollowingBits(newTrieCache.getUint64LowVal() & nextBitMask);
											} else {
												followingBits.setFollowingBits(newTrieCache.getUint64HighVal() & nextBitMask);
											}
											return true;
										}
									}
								} else if(existingPrefLenBits > 64) {
									long existingMaskLow = existingTrieCache.getMask64LowVal();
									long newLowVal = newTrieCache.getUint64LowVal();
									if((newLowVal & existingMaskLow) == (existingTrieCache.getUint64LowVal() & existingMaskLow)) {
										long existingMaskHigh = existingTrieCache.getMask64HighVal();
										if((newTrieCache.getUint64HighVal() & existingMaskHigh) == (existingTrieCache.getUint64HighVal() & existingMaskHigh)) {
											if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
												handleMatch.bitsMatch();
											} else {
												FollowingBits followingBits = handleMatch.bitsMatchPartially();
												if(followingBits != null) {
													long nextBitMask = existingTrieCache.getNextBitMask64Val();
													followingBits.setFollowingBits(newLowVal & nextBitMask);
													return true;
												}
											}
										} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
											long newMaskLow = newTrieCache.getMask64LowVal();
											if((newTrieCache.getUint64LowVal() & newMaskLow) == (existingTrieCache.getUint64LowVal() & newMaskLow)) {
												long newMaskHigh = newTrieCache.getMask64HighVal();
												if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
													handleMatch.bitsMatch();
												}
											}
										} 
									} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
										long newMaskLow = newTrieCache.getMask64LowVal();
										if((newTrieCache.getUint64LowVal()&newMaskLow) == (existingTrieCache.getUint64LowVal()&newMaskLow)) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												handleMatch.bitsMatch();
											}
										}
									} 
								} else if(existingPrefLenBits == 64) {
									if(newTrieCache.getUint64HighVal() == existingTrieCache.getUint64HighVal()) {
										if(newPrefLen != null && newPrefLen <= 64) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												followingBits.setFollowingBits(newTrieCache.getUint64LowVal() & 0x8000000000000000L);
												return true;
											}
										}
									} else {
										if(newPrefLen != null && newPrefLen < 64) {
											long newMaskHigh = newTrieCache.getMask64HighVal();
											if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
												handleMatch.bitsMatch();
											}
										}
									} 
								} else { 
									long existingMaskHigh = existingTrieCache.getMask64HighVal();
									long newHighVal = newTrieCache.getUint64HighVal();
									if((newHighVal & existingMaskHigh) == (existingTrieCache.getUint64HighVal() & existingMaskHigh)) {
										if(newPrefLen != null && existingPrefLenBits >= newPrefLen) {
											handleMatch.bitsMatch();
										} else {
											FollowingBits followingBits = handleMatch.bitsMatchPartially();
											if(followingBits != null) {
												long nextBitMask = existingTrieCache.getNextBitMask64Val();
												followingBits.setFollowingBits(newHighVal & nextBitMask);
												return true;
											}
										}
									} else if(newPrefLen != null && existingPrefLenBits > newPrefLen) {
										long newMaskHigh = newTrieCache.getMask64HighVal();
										if((newTrieCache.getUint64HighVal() & newMaskHigh) == (existingTrieCache.getUint64HighVal() & newMaskHigh)) {
											handleMatch.bitsMatch();
										}
									} 
								}
							}
							return false;
						}
					}
				}
			}
			int bitsPerSegment = existingAddr.getBitsPerSegment();
			int bytesPerSegment = existingAddr.getBytesPerSegment();
			int segmentIndex = ParsedAddressGrouping.getHostSegmentIndex(bitIndex, bytesPerSegment, bitsPerSegment);
			int segmentCount = existingAddr.getSegmentCount();
			if(newAddr.getSegmentCount() != segmentCount || bitsPerSegment != newAddr.getBitsPerSegment()) {
				throw new IllegalArgumentException(getMessage("ipaddress.error.mismatched.bit.size"));
			}
			Integer existingPref = existingAddr.getPrefixLength();
			Integer newPrefLen = newAddr.getPrefixLength();
			if(segmentIndex >= segmentCount) {
				handleMatch.bitsMatch();
				return false;
			}
			int bitsMatchedSoFar = ParsedAddressGrouping.getTotalBits(segmentIndex, bytesPerSegment, bitsPerSegment);
			while(true) {
				AddressSegment existingSegment = existingAddr.getSegment(segmentIndex);
				AddressSegment newSegment = newAddr.getSegment(segmentIndex);
				Integer segmentPref = getSegmentPrefLen(existingAddr, existingPref, bitsPerSegment, bitsMatchedSoFar, existingSegment);
				Integer newSegmentPref = getSegmentPrefLen(newAddr, newPrefLen, bitsPerSegment, bitsMatchedSoFar, newSegment);
				int newPrefixLen;
				if(segmentPref != null) {	
					int segmentPrefLen = segmentPref;
					if(newSegmentPref != null && (newPrefixLen = newSegmentPref) <= segmentPrefLen) {
						int matchingBits = getMatchingBits(existingSegment, newSegment, newPrefixLen, bitsPerSegment);
						if(matchingBits >= newPrefixLen) { 
							handleMatch.bitsMatch();
						} else {
							handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
						}
					} else {
						int matchingBits = getMatchingBits(existingSegment, newSegment, segmentPrefLen, bitsPerSegment);
						if(matchingBits >= segmentPrefLen) { 
							FollowingBits followingBits = handleMatch.bitsMatchPartially();
							if(followingBits != null) {
								if(segmentPrefLen == bitsPerSegment) {
									segmentIndex++;
									if(segmentIndex == segmentCount) {
										return true;
									}
									newSegment = newAddr.getSegment(segmentIndex);
									segmentPrefLen = 0;
								}
								if(newSegment.isOneBit(segmentPrefLen)) {
									followingBits.setFollowingBits(0x8000000000000000L);
								}
								return true;
							}
							return false;
						}
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
					}
					return false;
				} else if(newSegmentPref != null) {
					newPrefixLen = newSegmentPref;
					int matchingBits = getMatchingBits(existingSegment, newSegment, newPrefixLen, bitsPerSegment);
					if(matchingBits >= newPrefixLen) { 
						handleMatch.bitsMatch();
					} else {
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
					}
					return false;
				} else {
					int matchingBits = getMatchingBits(existingSegment, newSegment, bitsPerSegment, bitsPerSegment);
					if(matchingBits < bitsPerSegment) { 
						handleMatch.bitsDoNotMatch(bitsMatchedSoFar + matchingBits);
						return false;
					} else if(++segmentIndex == segmentCount) { 
						handleMatch.bitsMatch();
						return false;
					}
					bitsMatchedSoFar += bitsPerSegment;
				}
			}
		}
		private void handleContained(OpResult<E> result, int newPref) {
			Operation op = result.op;
			if(op == Operation.INSERT) {
				replace(result, newPref);
			} else  if(op == Operation.SUBTREE_DELETE) {
				removeSubtree(result);
			} else if(op == Operation.NEAR) {
				findNearest(result, newPref);
			} else if(op == Operation.REMAP) {
				remapNonExistingReplace(result, newPref);
			} 
		}
		private boolean handleContains(OpResult<E> result) {
			if(result.op == Operation.CONTAINING) {
				result.largestContaining = this;
				return true;
			} else if(result.op == Operation.ALL_CONTAINING) {
				result.addContaining(this);
				return true;
			}
			result.smallestContaining = this;
			return false;
		}
		private void handleSplitNode(OpResult<E> result, int totalMatchingBits) {
			E newAddr = result.addr;
			Operation op = result.op;	
			if(op == Operation.INSERT) {
				split(result, totalMatchingBits, createNew(newAddr));
			} else if(op == Operation.NEAR) {
				findNearest(result, totalMatchingBits);
			} else if(op == Operation.REMAP) {
				remapNonExistingSplit(result, totalMatchingBits);
			} 
		}
		private void handleNodeMatch(OpResult<E> result) {
			Operation op = result.op;
			if(op == Operation.LOOKUP) {
				result.existingNode = this;
			} else if(op == Operation.INSERT) {
				existingAdded(result);
			} else if(op == Operation.SUBTREE_DELETE) {
				removeSubtree(result);
			} else if(op == Operation.NEAR) {
				findNearestFromMatch(result);
			} else if(op == Operation.REMAP) {
				remapNonAdded(result);
			}
		}
		private void handleMatch(OpResult<E> result) {
			result.exists = true;
			if(!handleContains(result)) {
				Operation op = result.op;
				if(op == Operation.LOOKUP) {
					matched(result);
				} else if(op == Operation.INSERT) {
					matchedInserted(result);
				} else if(op == Operation.INSERTED_DELETE) {
					removeOp(result);
				} else if(op == Operation.SUBTREE_DELETE) {
					removeSubtree(result);
				} else if(op == Operation.NEAR) {
					if(result.nearExclusive) {
						findNearestFromMatch(result);
					} else {
						matched(result);
					}
				} else if(op == Operation.REMAP) {
					remapMatch(result);
				}
			}
		}
		private void remapNonExistingReplace(OpResult<E> result, int totalMatchingBits) {
			if(remap(result, false)) {
				replace(result, totalMatchingBits);
			}
		}
		private void remapNonExistingSplit(OpResult<E> result, int totalMatchingBits) {
			if(remap(result, false)) {
				split(result, totalMatchingBits, createNew(result.addr));
			}
		}
		private TrieNode<E> remapNonExisting(OpResult<E> result) {
			if(remap(result, false)) {
				return createNew(result.addr);
			}
			return null;
		}
		private void remapNonAdded(OpResult<E> result) {
			if(remap(result, false)) {
				existingAdded(result);
			}
		}
		private void remapMatch(OpResult<E> result) {
			result.existingNode = this;
			if(remap(result, true)) {
				matchedInserted(result);
			}
		}
		boolean remap(OpResult<E> result, boolean isMatch) {
			return false;
		}
		private void matched(OpResult<E> result) {
			result.existingNode = this;
			result.nearestNode = this;
		}
		void matchedInserted(OpResult<E> result) {
			result.existingNode = this;
			result.addedAlready = this;
		}
		private void existingAdded(OpResult<E> result) {
			result.existingNode = this;
			result.added = this;
			added(result);
		}
		private void inserted(OpResult<E> result) {
			result.inserted = this;
			added(result);
		}
		void added(OpResult<E> result) {
			setNodeAdded(true);
			adjustCount(1);
			changeTracker.changed();
		}
		@SuppressWarnings("unchecked")
		private void split(OpResult<E> result, int totalMatchingBits, TrieNode<E> newSubNode) {
			E key = getKey();
			E newBlock;
			if(key.isIPAddress()) {
				newBlock = (E) key.toIPAddress().toPrefixBlock(totalMatchingBits);
			} else {
				newBlock = (E) key.setPrefixLength(totalMatchingBits).toPrefixBlock();
			}
			replaceToSub(newBlock, totalMatchingBits, newSubNode);
			newSubNode.inserted(result);
		}
		private void replace(OpResult<E> result, int totalMatchingBits) {
			result.containedBy = this;
			TrieNode<E> newNode = replaceToSub(result.addr, totalMatchingBits, null);
			newNode.inserted(result);
		}
		private TrieNode<E> replaceToSub(E newAssignedAddr, int totalMatchingBits, TrieNode<E> newSubNode) {
			TrieNode<E> newNode = createNew(newAssignedAddr);
			newNode.size = size;
			TrieNode<E> parent = getParent();
			if(parent.getUpperSubNode() == this) {
				parent.setUpper(newNode);
			} else if(parent.getLowerSubNode() == this) {
				parent.setLower(newNode);
			}
			E existingAddr = getKey();
			if(totalMatchingBits < existingAddr.getBitCount() && 
					existingAddr.isOneBit(totalMatchingBits)) {
				if(newSubNode != null) {
					newNode.setLower(newSubNode);
				}
				newNode.setUpper(this);
			} else {
				newNode.setLower(this);
				if(newSubNode != null) {
					newNode.setUpper(newSubNode);
				}
			}
			return newNode;
		}
		private void findNearestFromMatch(OpResult<E> result) {
			if(result.nearestFloor) {
				TrieNode<E> lower = getLowerSubNode();
				if(lower == null) {
					result.backtrackNode = this;
				} else {
					TrieNode<E> last;
					do {
						last = lower;
						lower = lower.getUpperSubNode();
					} while(lower != null);
					result.nearestNode = last;
				}
			} else {
				TrieNode<E> upper = getUpperSubNode();
				if(upper == null) {
					result.backtrackNode = this;
				} else {
					TrieNode<E> last;
					do {
						last = upper;
						upper = upper.getLowerSubNode();
					} while(upper != null);
					result.nearestNode = last;
				}
			}
		}
		private void findNearest(OpResult<E> result, int differingBitIndex) {
			E thisAddr = getKey();
			if(differingBitIndex < thisAddr.getBitCount() && thisAddr.isOneBit(differingBitIndex)) {
				if(result.nearestFloor) {
					result.backtrackNode = this;
				} else {
					TrieNode<E> lower = this, last;
					do {
						last = lower;
						lower = lower.getLowerSubNode();
					} while(lower != null);
					result.nearestNode = last;
				}
			} else {
				if(result.nearestFloor) {
					TrieNode<E> upper = this, last;
					do {
						last = upper;
						upper = upper.getUpperSubNode();
					} while(upper != null);
					result.nearestNode = last;
				} else {
					result.backtrackNode = this;
				}
			}
		}
		void init(TrieNode<E> node) {
			E newAddr = node.getKey();
			if(newAddr.getBitCount() > 0 && newAddr.isOneBit(0)) {
				setUpper(node);
			} else {
				setLower(node);
			}
			size = (isAdded() ? 1 : 0) + node.size;
		}
		private TrieNode<E> matchSubNode(int bitIndex, OpResult<E> result) {
			E newAddr = result.addr;
			if(!FREEZE_ROOT && isEmpty()) {
				if(result.op == Operation.REMAP) {
					remapNonAdded(result);
				} else if(result.op == Operation.INSERT) {
					setKey(newAddr);
					existingAdded(result);
				}
			} else if(bitIndex >= newAddr.getBitCount()) {
			} else if(result.followingBits != 0L) {
				result.setFollowingBits(0);
				TrieNode<E> upper = getUpperSubNode();
				if(upper == null) {
					Operation op = result.op;
					if(op == Operation.INSERT) {
						upper = createNew(newAddr);
						setUpper(upper);
						upper.inserted(result);
					} else if(op == Operation.NEAR) {
						if(result.nearestFloor) {
							if(isAdded()) {
								result.nearestNode = this;
							} else {
								TrieNode<E> lower = getLowerSubNode();
								if(lower != null) {
									TrieNode<E> res = lower;
									TrieNode<E> next = res.getUpperSubNode();
									while(next != null) {
										res = next;
										next = res.getUpperSubNode();
									}
									result.nearestNode = res;
								}
							}
						} else {
							result.backtrackNode = this;
						}
					} else if(op == Operation.REMAP) {
						upper = remapNonExisting(result);
						if(upper != null) {
							setUpper(upper);
							upper.inserted(result);
						}
					}
				} else {
					return upper;
				}
			} else {
				TrieNode<E> lower = getLowerSubNode();
				if(lower == null) {
					Operation op = result.op;
					if(op == Operation.INSERT) {
						lower = createNew(newAddr);
						setLower(lower);
						lower.inserted(result);
					} else if(op == Operation.NEAR) {
						if(result.nearestFloor) {
							result.backtrackNode = this;
						} else {
							if(isAdded()) {
								result.nearestNode = this;
							} else {
								TrieNode<E> upper = getUpperSubNode();
								if(upper != null) {
									TrieNode<E> res = upper;
									TrieNode<E> next = res.getLowerSubNode();
									while(next != null) {
										res = next;
										next = res.getLowerSubNode();
									}
									result.nearestNode = res;
								}
							}
						}
					} else if(op == Operation.REMAP) {
						lower = remapNonExisting(result);
						if(lower != null) {
							setLower(lower);
							lower.inserted(result);
						}
					} 
				} else {
					return lower;
				}
			}
			return null;
		}
		private TrieNode<E> createNew(E newAddr) {
			TrieNode<E> newNode = createNewImpl(newAddr);
			newNode.changeTracker = changeTracker;
			return newNode;
		}
		protected abstract TrieNode<E> createNewImpl(E newAddr);
		protected abstract AddressTrie<E> createNewTree();
		public AddressTrie<E> asNewTrie() {
			AddressTrie<E> newTrie = createNewTree();
			newTrie.addTrie(this);
			return newTrie;
		}
		@Override
		public TrieNode<E> cloneTree() {
			return (TrieNode<E>) super.cloneTree();
		}
		@Override
		public TrieNode<E> clone() {
			return (TrieNode<E>) super.clone();
		}
		@Override
		TrieNode<E> cloneTreeBounds(Bounds<E> bounds) {
			return (TrieNode<E>) super.cloneTreeBounds(bounds);
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof TrieNode && super.equals(o);
		}
	}
	static final TrieComparator<?> comparator = new TrieComparator<>(new AddressComparator<>());
	static final TrieComparator<?> reverseComparator = new TrieComparator<>(Collections.reverseOrder(new AddressComparator<>()));
	AddressTrieSet<E> set;
	AddressBounds<E> bounds;
	private TrieNode<E> subRoot; 
	private Change subRootChange; 
	protected AddressTrie(TrieNode<E> root) {
		super(root);
		root.changeTracker = new ChangeTracker();
	}
	protected AddressTrie(TrieNode<E> root, AddressBounds<E> bounds) {
		super(root);
		if(root.changeTracker == null) {
			root.changeTracker = new ChangeTracker();
		}
		this.bounds = bounds;
	}
	private static Integer getSegmentPrefLen(
			AddressSegmentSeries addr,
			Integer prefLen,
			int bitsPerSegment,
			int bitsMatchedSoFar,
			AddressSegment segment) {
		if(segment instanceof IPAddressSegment) {
			return ((IPAddressSegment) segment).getSegmentPrefixLength();
		} else if(prefLen != null) {
			Integer result = prefLen - bitsMatchedSoFar;
			if(result <= bitsPerSegment) {
				if(result < 0) {
					result = 0;
				}
				return result;
			}
		}
		return null;
	}
	private static int getMatchingBits(AddressSegment segment1, AddressSegment segment2, int maxBits, int bitsPerSegment) {
		if(maxBits == 0) {
			return 0;
		}
		int val1 = segment1.getSegmentValue();
		int val2 = segment2.getSegmentValue();
		int xor = val1 ^ val2;
		switch(bitsPerSegment) {
		case IPv4Address.BITS_PER_SEGMENT:
			return numberOfLeadingZerosByte(xor);
		case IPv6Address.BITS_PER_SEGMENT:
			return numberOfLeadingZerosShort(xor);
		default:
			return Integer.numberOfLeadingZeros(xor) + bitsPerSegment - Integer.SIZE;
		}
	}
	private static int numberOfLeadingZerosShort(int i) {
		int half = i >>> 8;
		if(half == 0) {
			return 8 + numberOfLeadingZerosByte(i & 0xff);
		}
		return numberOfLeadingZerosByte(half);
	}
	private static int numberOfLeadingZerosByte(int i) {
		if (i <= 0) {
			if(i == 0){
				return 8;
			}
			return 0;
		}
		int n = 1;
		if (i >>> 4 == 0) { n += 4; i <<= 4; }
		if (i >>> 6 == 0) { n += 2; i <<= 2; }
		n -= i >>> 7;
		return n;
	}
	@Override
	public boolean isEmpty() {
		if(bounds == null) {
			return super.isEmpty();
		}
		return firstAddedNode() == null;
    }
	@Override
	public int nodeSize() {
		if(bounds == null) {
			return super.nodeSize();
		}
		int totalCount = 0;
		Iterator<? extends TrieNode<E>> iterator = allNodeIterator(true);
		while(iterator.hasNext()) {
			totalCount++;
			iterator.next();
		}
		return totalCount;
	}
	@Override
	public int size() {
		if(bounds == null) {
			return super.size();
		}
		int totalCount = 0;
		Iterator<? extends TrieNode<E>> iterator = nodeIterator(true);
		while(iterator.hasNext()) {
			TrieNode<E> node = iterator.next();
			if(node.isAdded() && bounds.isInBounds(node.getKey())) {
				totalCount++;
			}
		}
		return totalCount;
	}
	@Override
	public boolean add(E addr) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		TrieNode<E> root = absoluteRoot();
		OpResult<E> result = new OpResult<>(addr, Operation.INSERT);
		root.matchBits(result);
		return !result.exists;
	}
	static void throwOutOfBounds() {
		throw new IllegalArgumentException(getMessage("ipaddress.error.address.out.of.range"));
	}
	protected void adjustRoot(E addr) {}
	@Override
	public TrieNode<E> addNode(E addr) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		TrieNode<E> root = absoluteRoot();
		OpResult<E> result = new OpResult<>(addr, Operation.INSERT);
		root.matchBits(result);
		TrieNode<E> node = result.existingNode;
		if(node == null) {
			node = result.inserted;
		}
		return node;
	}
	static abstract class SubNodesMapping<E extends Address, N extends SubNodesMapping<E, N>> {
		ArrayList<AssociativeTrieNode<E, N>> subNodes;
		abstract Object getUnderlyingValue();
	}
	protected static class SubNodesMappingBasic<E extends Address> extends SubNodesMapping<E, SubNodesMappingBasic<E>> {
		@Override
		Object getUnderlyingValue() {
			return null;
		}
	}
	public abstract AddedTreeBase<E, ? extends SubNodesMapping<E, ? extends SubNodesMapping<E, ?>>> constructAddedNodesTree(); 
	protected void contructAddedTree(AssociativeAddressTrie<E, SubNodesMappingBasic<E>> emptyTrie) {
		emptyTrie.addTrie(absoluteRoot()); 
		CachingIterator<? extends AssociativeTrieNode<E, SubNodesMappingBasic<E>>, E, 
				AssociativeTrieNode<E, SubNodesMappingBasic<E>>> cachingIterator =
				emptyTrie.containingFirstAllNodeIterator(true);
		while(cachingIterator.hasNext()) {
			AssociativeTrieNode<E, SubNodesMappingBasic<E>> newNext = cachingIterator.next(), parent;
			newNext.setValue(new SubNodesMappingBasic<E>());
			cachingIterator.cacheWithLowerSubNode(newNext);
			cachingIterator.cacheWithUpperSubNode(newNext);
			if(newNext.isAdded()) {
				parent = cachingIterator.getCached();
				if(parent != null) {
					while(!parent.isAdded()) {
						AssociativeTrieNode<E, SubNodesMappingBasic<E>> parentParent = parent.getParent();
						if(parentParent == null) {
							break;
						}
						parent = parentParent;
					}
					SubNodesMappingBasic<E> mappedNodes = parent.getValue();
					ArrayList<AssociativeTrieNode<E, SubNodesMappingBasic<E>>> addedSubs = mappedNodes.subNodes;
					if(addedSubs == null) {
						addedSubs = new ArrayList<AssociativeTrieNode<E, SubNodesMappingBasic<E>>>(newNext.size() - 1);
						mappedNodes.subNodes = addedSubs;
					}
					addedSubs.add(newNext);
				} 
			}
		}
		SubNodesMappingBasic<E> value = emptyTrie.getRoot().getValue();
		if(value != null && value.subNodes != null) {
			value.subNodes.trimToSize();
		}
		Iterator<? extends AssociativeTrieNode<E, SubNodesMappingBasic<E>>> iter = emptyTrie.allNodeIterator(true);
		while(iter.hasNext()) {
			SubNodesMappingBasic<E> list = iter.next().getValue();
			if(list != null && list.subNodes != null) {
				list.subNodes.trimToSize();
			}
		}
	}
	public abstract String toAddedNodesTreeString();
	protected static <E extends Address, N extends SubNodesMapping<E, N>> String toAddedNodesTreeString(AssociativeAddressTrie<E, N> addedTree) {
		AssociativeTrieNode<E, N> root = addedTree.absoluteRoot();
		return toAddedNodesTreeString(root);
	}
	protected static <E extends Address, N extends SubNodesMapping<E, N>> String toAddedNodesTreeString(AssociativeTrieNode<E, N> root) {
		class IndentsNode {
			Indents indents;
			AssociativeTrieNode<E, N> node;
			IndentsNode(Indents indents, AssociativeTrieNode<E, N> node) {
				this.indents = indents;
				this.node = node;
			}
		}
		Deque<IndentsNode> stack = null;
		StringBuilder builder = new StringBuilder();
		builder.append('\n');
		AssociativeTrieNode<E, N> nextNode = root;
		String nodeIndent = "", subNodeIndent = "";
		IndentsNode nextItem;
		while(true) {
			SubNodesMapping<E, N> nextNodeList = nextNode.getValue();
			TrieNode.toNodeString(builder.append(nodeIndent), nextNode.isAdded(), nextNode.getKey(), nextNodeList.getUnderlyingValue()).append('\n');
			ArrayList<AssociativeTrieNode<E, N>> nextNodes = nextNodeList.subNodes;
			if(nextNodes != null && nextNodes.size() > 0) {
				AssociativeTrieNode<E, N> nNode, next;
				int i = nextNodes.size() - 1;
				Indents lastIndents = new Indents(
						subNodeIndent + BinaryTreeNode.RIGHT_ELBOW,
						subNodeIndent + BinaryTreeNode.BELOW_ELBOWS);
				nNode = nextNodes.get(i);
				next = nNode;
				if(stack == null) {
					stack = new ArrayDeque<>(root.size());
				}
				stack.addFirst(new IndentsNode(lastIndents, next));
				if(nextNodes.size() > 1) {
					Indents firstIndents = new Indents(
							subNodeIndent + BinaryTreeNode.LEFT_ELBOW,
							subNodeIndent + BinaryTreeNode.IN_BETWEEN_ELBOWS);
					for(--i; i >= 0; i--) {
						nNode = nextNodes.get(i);
						next = nNode;
						stack.addFirst(new IndentsNode(firstIndents, next));
					}
				}
			}
			if(stack == null) {
				break;
			}
			nextItem = stack.pollFirst();
			if(nextItem == null) {
				break;
			}
			nextNode = nextItem.node;
			Indents nextIndents = nextItem.indents;
			nodeIndent = nextIndents.nodeIndent;
			subNodeIndent = nextIndents.subNodeInd;
		}
		return builder.toString();
	}
	TrieNode<E> addNode(OpResult<E> result, TrieNode<E> fromNode, TrieNode<E> nodeToAdd, boolean withValues) {
		fromNode.matchBitsFromIndex(fromNode.getKey().getPrefixLength(), result);
		TrieNode<E> node = result.existingNode;
		return node == null ? result.inserted : node;
	}
	TrieNode<E> addTrie(TrieNode<E> tree, boolean withValues) {
		CachingIterator<? extends TrieNode<E>, E, TrieNode<E>> iterator = 
				tree.containingFirstAllNodeIterator(true);
		TrieNode<E> toAdd = iterator.next();
		OpResult<E> result = new OpResult<>(toAdd.getKey(), Operation.INSERT);
		TrieNode<E> firstNode;
		TrieNode<E> root = absoluteRoot();
		boolean firstAdded = toAdd.isAdded();
		boolean addedOne = false;
		if(firstAdded) {
			addedOne = true;
			adjustRoot(toAdd.getKey());
			firstNode = addNode(result, root, toAdd, withValues);
		} else {
			firstNode = root;
		}
		TrieNode<E> lastAddedNode = firstNode;
		while(iterator.hasNext()) {
			iterator.cacheWithLowerSubNode(lastAddedNode);
			iterator.cacheWithUpperSubNode(lastAddedNode);
			toAdd = iterator.next();
			TrieNode<E> cachedNode = iterator.getCached();
			if(toAdd.isAdded()) {
				E addrNext = toAdd.getKey();
				if(!addedOne) {
					addedOne = true;
					adjustRoot(addrNext);
				}
				result.addr = addrNext;
				result.existingNode = null;
				result.inserted = null;
				result.setFollowingBits(0);
				lastAddedNode = addNode(result, cachedNode, toAdd, withValues);
			} else {
				lastAddedNode = cachedNode;
			}
		}
		if(!firstAdded) {
			firstNode = getNode(tree.getKey());
		}
		return firstNode;
	}
	@Override
	public TrieNode<E> addTrie(TrieNode<E> trie) {
		return addTrie(trie, false);
	}
	@Override
	public boolean contains(E addr) {
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return false;
			}
		}
		return absoluteRoot().contains(addr);
	}
	@Override
	public boolean remove(E addr) {
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return false;
			}
		}
		return absoluteRoot().remove(addr);
	}
	@Override
	public TrieNode<E> removeElementsContainedBy(E addr) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().removeElementsContainedBy(addr);
	}
	@Override
	public TrieNode<E> elementsContainedBy(E addr) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().elementsContainedBy(addr);
	}
	@Override
	public TrieNode<E> elementsContaining(E addr) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().elementsContaining(addr);
	}
	@Override
	public E longestPrefixMatch(E addr) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().longestPrefixMatch(addr);
	}
	@Override
	public TrieNode<E> longestPrefixMatchNode(E addr) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().longestPrefixMatchNode(addr);
	}
	@Override
	public E shortestPrefixMatch(E addr) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().shortestPrefixMatch(addr);
	}
	@Override
	public TrieNode<E> shortestPrefixMatchNode(E addr) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().shortestPrefixMatchNode(addr);
	}
	@Override
	public boolean elementContains(E addr) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().elementContains(addr);
	}
	@SuppressWarnings("unchecked")
	AddressTrie<E> elementsContainedByToSubTrie(E addr) {
		AddressBounds<E> newBounds;
		E lower = (E) addr.getLower().withoutPrefixLength();
		E upper = (E) addr.getUpper().withoutPrefixLength();
		if(bounds == null) {
			newBounds = AddressBounds.createNewBounds(lower, true, upper, true, comparator());
		} else {
			newBounds = bounds.intersect(lower, true, upper, true);
		}
		if(newBounds == bounds) {
			return this;
		}
		return createSubTrie(newBounds);
	}
	AddressTrie<E> elementsContainingToTrie(E addr) {
		if(isEmpty()) {
			return this;
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return createNew(bounds);
		}
		TrieNode<E> node = subRoot.elementsContaining(addr); 
		if(node == null) {
			return createNew(bounds);
		}
		if (size() == node.size()) {
			return this;
		}
		return createNewSameBoundsFromList(node);
	}
	boolean elementContainsBounds(E addr) {
		if(bounds == null) {
			return elementContains(addr);
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return false;
		}
		TrieNode<E> node = subRoot.elementsContaining(addr); 
		if(node == null) {
			return false;
		}
		return !createNewSameBoundsFromList(node).isEmpty();
	}
	TrieNode<E> smallestElementContainingBounds(E addr) {
		if(bounds == null) {
			return longestPrefixMatchNode(addr);
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		TrieNode<E> node = subRoot.longestPrefixMatchNode(addr);
		if(node == null) {
			return null;
		}
		if(!bounds.isInBounds(node.getKey())) {
			node = subRoot.elementsContaining(addr); 
			TrieNode<E> next, lastInBounds = bounds.isInBounds(node.getKey()) ? node : null;
			do {
				if((next = node.getLowerSubNode()) != null) {
					node = next;
					if(bounds.isInBounds(node.getKey())) {
						lastInBounds = node;
					}
				} else if((next = node.getUpperSubNode()) != null) {
					node = next;
					if(bounds.isInBounds(node.getKey())) {
						lastInBounds = node;
					}
				}
			} while(next != null);
			node = lastInBounds;
		}
		return node;
	}
	E longestPrefixMatchBounds(E addr) {
		TrieNode<E> node = smallestElementContainingBounds(addr);
		return node == null ? null : node.getKey();
	}
	protected abstract AddressTrie<E> createNew(AddressBounds<E> bounds);
	protected abstract AddressTrie<E> createSubTrie(AddressBounds<E> bounds);
	private AddressTrie<E> createNewSameBoundsFromList(TrieNode<E> node) {
		AddressTrie<E> newTrie = createNew(bounds);
		TrieNode<E> root = newTrie.absoluteRoot();
		if(node.getKey().equals(root.getKey())) {
			newTrie.root = node;
		} else {
			root.init(node);
		}
		ChangeTracker tracker = root.changeTracker;
		node.changeTracker = tracker;
		TrieNode<E> next = node;
		while(true) {
			TrieNode<E> lower = next.getLowerSubNode();
			if(lower == null) {
				next = next.getUpperSubNode();
				if(next == null) {
					break;
				}
			} else {
				next = lower;
			}
			next.changeTracker = tracker;
		}
		newTrie.root.size = BinaryTreeNode.SIZE_UNKNOWN;
		newTrie.root.size();
		return newTrie;
	}
	@Override
	public TrieNode<E> getNode(E addr) {
		TrieNode<E> subRoot;
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return null;
			}
			subRoot = getRoot();
			if(subRoot == null) {
				return null;
			}
		} else {
			subRoot = absoluteRoot();
		}
		return subRoot.getNode(addr);
	}
	@Override
	public Iterator<? extends TrieNode<E>> allNodeIterator(boolean forward) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	public Iterator<? extends TrieNode<E>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().blockSizeNodeIterator(lowerSubNodeFirst);
		} else {
			iterator = new BlockSizeNodeIterator<E>(
					size(),
					bounds,
					true,
					getRoot(),
					!lowerSubNodeFirst,
					absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@SuppressWarnings("unchecked")
	public Iterator<? extends TrieNode<E>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().blockSizeAllNodeIterator(lowerSubNodeFirst);
		} else { 
			iterator = new BlockSizeNodeIterator<E>(
					0,
					bounds,
					false,
					getRoot(),
					!lowerSubNodeFirst,
					absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	public <C> CachingIterator<? extends TrieNode<E>, E, C> blockSizeCachingAllNodeIterator() {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containingFirstIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containingFirstIterator(forwardSubNodeOrder);
		} else {
			if(forwardSubNodeOrder) {
				iterator = new PreOrderNodeIterator<E, Object>(
					bounds,
					true,
					true, 
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			} else {
				iterator = new PostOrderNodeIterator<E, Object>(
					bounds,
					false,
					true, 
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			}
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<? extends TrieNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		CachingIterator<? extends BinaryTreeNode<E>, E, C> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containingFirstAllNodeIterator(forwardSubNodeOrder);
		} else { 
			if(forwardSubNodeOrder) {
				iterator = new PreOrderNodeIterator<E, C>(
					bounds,
					true,
					false, 
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			} else {
				iterator = new PostOrderNodeIterator<E, C>(
					bounds,
					false,
					false, 
					absoluteRoot(),
					null,
					absoluteRoot().changeTracker);
			}
		}
		return (CachingIterator<? extends TrieNode<E>, E, C>) iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containedFirstIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containedFirstIterator(forwardSubNodeOrder);
		} else {
			iterator = containedFirstBoundedIterator(forwardSubNodeOrder, true);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	private Iterator<? extends BinaryTreeNode<E>> containedFirstBoundedIterator(boolean forwardSubNodeOrder, boolean addedNodesOnly) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(forwardSubNodeOrder) {
			BinaryTreeNode<E> startNode = absoluteRoot().firstPostOrderNode();
			iterator = new PostOrderNodeIterator<E, Object>(
					bounds,
					true, 
					addedNodesOnly, 
					startNode,
					null,
					absoluteRoot().changeTracker);
		} else {
			BinaryTreeNode<E> startNode = absoluteRoot().lastPreOrderNode();
			iterator = new PreOrderNodeIterator<E, Object>(
					bounds,
					false, 
					addedNodesOnly, 
					startNode,
					null,
					absoluteRoot().changeTracker);
		}
		return iterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().containedFirstAllNodeIterator(forwardSubNodeOrder);
		} else {
			iterator = containedFirstBoundedIterator(forwardSubNodeOrder, false);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@Override
	public Spliterator<E> spliterator() {
		return new KeySpliterator<E>(nodeSpliterator(true, true), comparator());
	}
	@Override
	public Spliterator<E> descendingSpliterator() {
		return new KeySpliterator<E>(nodeSpliterator(false, true), reverseComparator());
	}
	@Override
	public Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward) {
		return nodeSpliterator(forward, true);
	}
	@Override
	public Spliterator<? extends TrieNode<E>> allNodeSpliterator(boolean forward) {
		if(bounds != null) {
			throw new Error();
		}
		return absoluteRoot().nodeSpliterator(forward, false);
	}
	@SuppressWarnings("unchecked")
	Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
		Spliterator<? extends TrieNode<E>> spliterator;
		if(bounds == null) {
			spliterator = absoluteRoot().nodeSpliterator(forward, addedNodesOnly);
		} else {
			Comparator<BinaryTreeNode<E>> comp = forward ? nodeComparator() : reverseNodeComparator();
			Spliterator<? extends BinaryTreeNode<E>> split = new NodeSpliterator<E>(
					forward,
					comp,
					getRoot(),
					forward ? firstAddedNode() : lastAddedNode(),
					forward ? getIteratingUpperBoundary() : getIteratingLowerBoundary(),
					size(),
					absoluteRoot().changeTracker,
					addedNodesOnly);
			spliterator = (Spliterator<? extends TrieNode<E>>) split;
		}
		return spliterator;
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends TrieNode<E>> nodeIterator(boolean forward) {
		Iterator<? extends BinaryTreeNode<E>> iterator;
		if(bounds == null) {
			iterator = absoluteRoot().nodeIterator(forward);
		} else {
			iterator = new NodeIterator<E>(
				forward,
				true,
				forward ? firstAddedNode() : lastAddedNode(),
				forward ? getIteratingUpperBoundary() : getIteratingLowerBoundary(),
				absoluteRoot().changeTracker);
		}
		return (Iterator<? extends TrieNode<E>>) iterator;
	}
	@Override
	public TrieNode<E> firstNode() {
		return absoluteRoot().firstNode();
	}
	@Override
	public TrieNode<E> firstAddedNode() {
		if(bounds == null) {
			return absoluteRoot().firstAddedNode();
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isLowerBounded() ?
				(bounds.lowerInclusive ? subRoot.ceilingNodeNoCheck(bounds.lowerBound) : subRoot.higherNodeNoCheck(bounds.lowerBound)) :
					subRoot.firstAddedNode();
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	private TrieNode<E> getIteratingUpperBoundary() {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		if(bounds.isUpperBounded()) {
			return bounds.upperInclusive ? subRoot.higherNodeNoCheck(bounds.upperBound) : subRoot.ceilingNodeNoCheck(bounds.upperBound);
		}
		return subRoot.getParent();
	}
	@Override
	public TrieNode<E> lastNode() {
		return absoluteRoot().lastNode();
	}
	@Override
	public TrieNode<E> lastAddedNode() {
		if(bounds == null) {
			return absoluteRoot().lastAddedNode();
		}
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isUpperBounded() ?
					(bounds.upperInclusive ? 
							subRoot.floorNodeNoCheck(bounds.upperBound) : subRoot.lowerNodeNoCheck(bounds.upperBound)) : 
						subRoot.lastAddedNode();
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	private TrieNode<E> getIteratingLowerBoundary() {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return null;
		}
		if(bounds.isLowerBounded()) {
			return bounds.lowerInclusive ? subRoot.lowerNodeNoCheck(bounds.lowerBound) : subRoot.floorNodeNoCheck(bounds.lowerBound);
		}
		return subRoot.getParent();
	}
	public Comparator<E> getComparator() {
		return comparator();
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<E> comparator() {
		return (Comparator<E>) comparator.comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<BinaryTreeNode<E>> nodeComparator() {
		return (TrieComparator<E>) comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<E> reverseComparator() {
		return (Comparator<E>) reverseComparator.comparator;
	}
	@SuppressWarnings("unchecked")
	static <E extends Address> Comparator<BinaryTreeNode<E>> reverseNodeComparator() {
		return (TrieComparator<E>) reverseComparator;
	}
	public AddressTrieSet<E> asSet() {
		AddressTrieSet<E> set = this.set;
		if(set == null) {
			set = new AddressTrieSet<E>(this);
		}
		return set;
	}
	protected TrieNode<E> absoluteRoot() {
		return (TrieNode<E>) root;
	}
	@Override
	public TrieNode<E> getRoot() {
		if(bounds == null) {
			return absoluteRoot();
		}
		if(subRootChange != null && !absoluteRoot().changeTracker.isChangedSince(subRootChange)) {
			return subRoot;
		}
		TrieNode<E> current = absoluteRoot();
		do {
			E currentKey = current.getKey();
			if(bounds.isLowerBounded() && bounds.isBelowLowerBound(currentKey)) {
				current = current.getUpperSubNode();
			} else if(bounds.isUpperBounded() && bounds.isAboveUpperBound(currentKey)) {
				current = current.getLowerSubNode();
			} else {
				break;
			}
		} while(current != null);
		subRootChange = absoluteRoot().changeTracker.getCurrent();
		subRoot = current;
		return current;
	}
	@Override
	public TrieNode<E> lowerAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().lowerAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return lowerNodeBounded(addr);
	}
	private TrieNode<E> lowerNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isAboveUpperBound(addr) ? 
					lastAddedNode() : subRoot.lowerNodeNoCheck(addr);
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E lower(E addr) {
		return getNodeKey(lowerAddedNode(addr));
	}
	@Override
	public TrieNode<E> floorAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().floorAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return floorNodeBounded(addr);
	}
	private TrieNode<E> floorNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isAboveUpperBound(addr) ? 
					lastAddedNode() : subRoot.floorNodeNoCheck(addr);
			return (node == null || bounds.isBelowLowerBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E floor(E addr) {
		return getNodeKey(floorAddedNode(addr));
	}
	@Override
	public TrieNode<E> higherAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().higherAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return higherNodeBounded(addr);
	}
	private TrieNode<E> higherNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isBelowLowerBound(addr) ? 
					firstAddedNode() : subRoot.higherNodeNoCheck(addr);
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E higher(E addr) {
		return getNodeKey(higherAddedNode(addr));
	}
	@Override
	public TrieNode<E> ceilingAddedNode(E addr) {
		if(bounds == null) {
			return absoluteRoot().ceilingAddedNode(addr);
		}
		addr = checkBlockOrAddress(addr, true);
		return ceilingNodeBounded(addr);
	}
	private TrieNode<E> ceilingNodeBounded(E addr) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot != null) {
			TrieNode<E> node = bounds.isBelowLowerBound(addr) ? 
					firstAddedNode() : subRoot.ceilingNodeNoCheck(addr);
			return (node == null || bounds.isAboveUpperBound(node.getKey())) ? null : node;
		}
		return null;
	}
	@Override
	public E ceiling(E addr) {
		return getNodeKey(ceilingAddedNode(addr));
	}
	static <E extends Address> E getNodeKey(TrieNode<E> node) {
		return (node == null) ? null : node.getKey();
	}
	@Override
	public void clear() {
		if(bounds == null) {
			super.clear();
		} else {
			Iterator<? extends BinaryTreeNode<E>> iterator = nodeIterator(true);
			while(iterator.hasNext()) {
				BinaryTreeNode<E> node = iterator.next();
				if(bounds.isInBounds(node.getKey())) {
					iterator.remove();
				}
			}
		}
	}
	@Override
	public AddressTrie<E> clone() {
		AddressTrie<E> result = (AddressTrie<E>) super.clone();
		result.set = null;
		if(bounds == null) {
			result.root = getRoot().cloneTree();
		} else {
			TrieNode<E> root = absoluteRoot();
			if(bounds.isInBounds(root.getKey())) {
				result.root = root.cloneTreeBounds(bounds);
			} else {
				BinaryTreeNode<E> clonedRoot = root.cloneTreeNode(new ChangeTracker()); 
				result.root = clonedRoot;
				clonedRoot.setNodeAdded(false); 
				clonedRoot.setLower(null);
				clonedRoot.setUpper(null);
				TrieNode<E> subRoot = getRoot();
				if(subRoot != null) {
					TrieNode<E> subCloned = subRoot.cloneTreeBounds(bounds);
					if(subCloned != null) {
						result.absoluteRoot().init(subCloned);
					} else {
						clonedRoot.size = clonedRoot.isAdded() ? 1 : 0;
					}
				} else {
					clonedRoot.size = clonedRoot.isAdded() ? 1 : 0;
				}
			}
			result.bounds = null;
		}
		return result;
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof AddressTrie && super.equals(o);
	}
	@Override
	public String toString() {
		if(bounds == null) {
			return super.toString();
		}
		return toString(true);
	}
	String noBoundsString() { 
		return absoluteRoot().toTreeString(true, true);
	}
	@Override
	public String toString(boolean withNonAddedKeys) {
		if(bounds == null) {
			return super.toString(withNonAddedKeys);
		}
		StringBuilder builder = new StringBuilder("\n");
		printTree(builder, new Indents(), withNonAddedKeys);
		return builder.toString();
	}
	void printTree(StringBuilder builder, Indents indents, boolean withNonAddedKeys) {
		TrieNode<E> subRoot = getRoot();
		if(subRoot == null) {
			return;
		}
		subRoot.printTree(builder, indents, withNonAddedKeys, true, 
				this.<Indents>containingFirstAllNodeIterator(true));
	}
	public static String toString(boolean withNonAddedKeys, AddressTrie<?> ...tries) {
		int totalEntrySize = 0;
		for(int i=0; i < tries.length; i++) {
			totalEntrySize += tries[i].size();
		}
		StringBuilder builder = new StringBuilder(totalEntrySize * 120);
		builder.append('\n').append(BinaryTreeNode.NON_ADDED_NODE_CIRCLE);
		boolean isEmpty = tries == null;
		if(!isEmpty) {
			AddressTrie<?> lastTree = null;
			int lastTreeIndex;
			for(lastTreeIndex = tries.length - 1; lastTreeIndex >= 0; lastTreeIndex--) {
				if(tries[lastTreeIndex] != null) {
					lastTree = tries[lastTreeIndex];
					break;
				}
			}
			isEmpty = lastTree == null;
			if(!isEmpty) {
				int totalSize = lastTree.size();
				for(int i = 0; i < lastTreeIndex; i++) {
					AbstractTree<?> tree = tries[i];
					if(tree != null) {
						totalSize += tree.size();
					}
				}
				if(withNonAddedKeys) {
					builder.append(' ').append(Address.SEGMENT_WILDCARD_STR).append(" (").append(totalSize).append(')');
				}
				builder.append('\n');
				for(int i = 0; i < lastTreeIndex; i++) {
					AddressTrie<?> tree = tries[i];
					if(tree != null) {
						tree.printTree(builder, new Indents(BinaryTreeNode.LEFT_ELBOW, BinaryTreeNode.IN_BETWEEN_ELBOWS), withNonAddedKeys);
					}
				}
				lastTree.printTree(builder, new Indents(BinaryTreeNode.RIGHT_ELBOW, BinaryTreeNode.BELOW_ELBOWS), withNonAddedKeys);
			}
		}
		if(isEmpty) {
			if(withNonAddedKeys) {
				builder.append(' ').append(Address.SEGMENT_WILDCARD_STR).append(" (0)");
			}
			builder.append('\n');
		}
		return builder.toString();
	}
}
package inet.ipaddr.ipv6;
import java.io.Serializable;
import java.math.BigInteger;
import java.net.Inet6Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressPositionException;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.validate.Validator;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4Address.IPv4AddressConverter;
import inet.ipaddr.ipv4.IPv4AddressNetwork;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6AddressCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringBuilderOptions;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCache;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringCollection;
import inet.ipaddr.ipv6.IPv6AddressSection.IPv6StringOptions;
import inet.ipaddr.ipv6.IPv6AddressTrie.IPv6TrieNode.IPv6TrieKeyData;
import inet.ipaddr.mac.MACAddress;
import inet.ipaddr.mac.MACAddressNetwork;
import inet.ipaddr.mac.MACAddressNetwork.MACAddressCreator;
import inet.ipaddr.mac.MACAddressSection;
import inet.ipaddr.mac.MACAddressSegment;
public class IPv6Address extends IPAddress implements Iterable<IPv6Address> {
	private static final long serialVersionUID = 4L;
	public static final char SEGMENT_SEPARATOR = ':';
	public static final char ZONE_SEPARATOR = '%';
	public static final char ALTERNATIVE_ZONE_SEPARATOR = '\u00a7';
	public static final char UNC_SEGMENT_SEPARATOR = '-';
	public static final char UNC_ZONE_SEPARATOR = 's';
	public static final char UNC_RANGE_SEPARATOR = ALTERNATIVE_RANGE_SEPARATOR;
	public static final String UNC_RANGE_SEPARATOR_STR = String.valueOf(UNC_RANGE_SEPARATOR);
	public static final String UNC_SUFFIX = ".ipv6-literal.net";
	public static final String REVERSE_DNS_SUFFIX = ".ip6.arpa";
	public static final String REVERSE_DNS_SUFFIX_DEPRECATED = ".ip6.int";
	public static final int BITS_PER_SEGMENT = 16;
	public static final int BYTES_PER_SEGMENT = 2;
	public static final int SEGMENT_COUNT = 8;
	public static final int MIXED_REPLACED_SEGMENT_COUNT = 2; 
	public static final int MIXED_ORIGINAL_SEGMENT_COUNT = 6; 
	public static final int BYTE_COUNT = 16;
	public static final int BIT_COUNT = 128;
	public static final int DEFAULT_TEXTUAL_RADIX = 16;
	public static final int BASE_85_RADIX = 85;
	public static final int MAX_VALUE_PER_SEGMENT = 0xffff;
	private final IPv6Zone zone;
	public static class IPv6Zone implements Serializable {
		private static final long serialVersionUID = 1L;
		String zoneStr;
		private int scopeId;
		private transient NetworkInterface networkInterface;
		private Boolean referencesInterface;
		public IPv6Zone(String zoneStr) {
			if(zoneStr == null) {
				throw new NullPointerException();
			}
			this.zoneStr = zoneStr.trim();
			scopeId = -1;
		}
		public IPv6Zone(int scopeId) {
			if(scopeId < 0) {
				throw new IllegalArgumentException();
			}
			this.scopeId = scopeId;
			referencesInterface = Boolean.FALSE;
		}
		public IPv6Zone(NetworkInterface networkInterface) {
			if(networkInterface == null) {
				throw new NullPointerException();
			}
			this.networkInterface = networkInterface;
			referencesInterface = Boolean.TRUE;
			scopeId = -1;
			zoneStr = networkInterface.getName();
		}
		public boolean referencesIntf() {
			if(referencesInterface == null) {
				scopeId = checkIfScope(zoneStr);
				referencesInterface = scopeId < 0;
			}
			return referencesInterface;
		}
		public boolean referencesScopeId() {
			return !referencesIntf();
		}
		public NetworkInterface getAssociatedIntf() {
			try {
				if(referencesIntf()) {
					if(networkInterface == null) {
						networkInterface = NetworkInterface.getByName(zoneStr);
					}
				} else {
					if(networkInterface == null) {
						Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();
						top:
						while(interfaces.hasMoreElements()) {
							NetworkInterface nif = interfaces.nextElement();
							Enumeration<InetAddress> addrs = nif.getInetAddresses();
							while(addrs.hasMoreElements()) {
								InetAddress addr = addrs.nextElement();
								if(addr instanceof Inet6Address) {
									Inet6Address inetAddr = (Inet6Address) addr;
									if(inetAddr.getScopeId() == scopeId) {
										networkInterface = nif;
										break top;
									}
								}
							}
						}
					}
				}
			} catch(SocketException e) {}
			return networkInterface;
		}
		public MACAddress getAssociatedIntfMacAddr() {
			NetworkInterface intf = getAssociatedIntf();
			try {
				if(intf != null) {
					byte bytes[] = intf.getHardwareAddress();
					if(bytes != null) {
						return new MACAddress(bytes);
					}
				}
			} catch(SocketException e) {}
			return null;
		}
		public int getAssociatedScopeId() {
			if(referencesIntf()) {
				if(scopeId == -1) {
					NetworkInterface nif = getAssociatedIntf();
					if(nif != null) {
						Enumeration<InetAddress> addrs = nif.getInetAddresses();
						int newScopeId = -1;
						while(addrs.hasMoreElements()) {
							InetAddress addr = addrs.nextElement();
							if(addr instanceof Inet6Address) {
								Inet6Address inetAddr = (Inet6Address) addr;
								int sid = inetAddr.getScopeId();
								if(sid != 0) {
									if(newScopeId != -1 && sid != newScopeId) {
										newScopeId = -1;
										break;
									}
									newScopeId = sid;
								}
							}
						}
						if(newScopeId != -1) {
							this.scopeId = newScopeId;
						}
					}
				}
			}
			return scopeId;
		}
		@Override
		public int hashCode() {
			return toString().hashCode();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6Zone && toString().equals(o.toString());
		}
		public String getName() {
			if(zoneStr == null) {
				if(referencesIntf()) {
					zoneStr = networkInterface.getName();
				} else {
					zoneStr = IPv6AddressSegment.toUnsignedString(scopeId, 10,
							new StringBuilder(IPv6AddressSegment.toUnsignedStringLength(scopeId, 10))).toString();
				}
			}
			return zoneStr;
		}
		@Override
		public String toString() {
			return getName();
		}
		static int checkIfScope(String zoneStr) {
			long digits = 0;
			for(int i = 0, len = zoneStr.length(); i < len; i++) {
				char c = zoneStr.charAt(i);
				int digit = Character.digit(c, 10);
				if(digit < 0) {
					return -1;
				}
				digits = (digits * 10) + digit;
				if(digits > Integer.MAX_VALUE) {
					return -1;
				}
			}
			return (int) digits;
		}
	}
	private transient IPv6StringCache stringCache;
	private transient IPv6TrieKeyData cachedTrieKeyData;
	transient IPv6AddressCache addressCache;
	IPv6Address(IPv6AddressSection section, CharSequence zone, boolean checkZone) throws AddressValueException {
		this(section, checkZone ? 
					checkZone(zone) : 
					(zone != null && zone.length() > 0 ? 
							new IPv6Zone(zone.toString()) :
							null));
	}
	public IPv6Address(IPv6AddressSection section, IPv6Zone zone) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", section.getSegmentCount());
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section.addressSegmentIndex);
		}
		this.zone = zone;
	}
	@Deprecated
	public IPv6Address(IPv6AddressSection section, CharSequence zone) throws AddressValueException {
		this(section, zone, true);
	}
	public IPv6Address(IPv6AddressSection section) throws AddressValueException {
		this(section, (CharSequence) null);
	}
	public IPv6Address(IPv6AddressSegment[] segments) throws AddressValueException {
		this(segments, null, null);
	}
	public IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		this(segments, networkPrefixLength, null);
	}
	@Deprecated
	public IPv6Address(IPv6AddressSegment[] segments, CharSequence zone) throws AddressValueException {
		this(segments, checkZone(zone));
	}
	public IPv6Address(IPv6AddressSegment[] segments, IPv6Zone zone) throws AddressValueException {
		this(segments, null, zone);
	}
	private IPv6Address(IPv6AddressSegment[] segments, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(segments, networkPrefixLength));
		if(segments.length != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv6.invalid.segment.count", segments.length);
		}
		this.zone = zone;
	}
	public IPv6Address(Inet6Address inet6Address) {
		this(inet6Address, inet6Address.getAddress(), null, getZone(inet6Address));
	}
	public IPv6Address(Inet6Address inet6Address, Integer networkPrefixLength) {
		this(inet6Address, inet6Address.getAddress(), networkPrefixLength, getZone(inet6Address));
	}
	private IPv6Address(Inet6Address inet6Address, byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, 0, bytes.length, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
		getSection().setInetAddress(inet6Address);
	}
	@Deprecated
	public IPv6Address(byte[] bytes, CharSequence zone) throws AddressValueException {
		this(bytes, checkZone(zone));
	}
	public IPv6Address(byte[] bytes, IPv6Zone zone) throws AddressValueException {
		this(bytes, null, zone);
	}
	public IPv6Address(byte[] bytes) throws AddressValueException {
		this(bytes, null, null);
	}
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null, null);
	}
	public IPv6Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, networkPrefixLength, null);
	}
	public IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, networkPrefixLength, null);
	}
	public IPv6Address(BigInteger val) throws AddressValueException {
		this(val, null, (IPv6Zone) null);
	}
	public IPv6Address(BigInteger val, Integer networkPrefixLength) throws AddressValueException {
		this(val, networkPrefixLength, (IPv6Zone) null);
	}
	@Deprecated
	public IPv6Address(BigInteger val, CharSequence zone) throws AddressValueException {
		this(val, checkZone(zone));
	}
	public IPv6Address(BigInteger val, IPv6Zone zone) throws AddressValueException {
		this(val, null, zone);
	}
	@Deprecated
	public IPv6Address(BigInteger val, Integer networkPrefixLength, CharSequence zone) throws AddressValueException {	
		this(val, networkPrefixLength, checkZone(zone));
	}
	public IPv6Address(BigInteger val, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {	
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSectionInternal(val.toByteArray(), IPv6Address.SEGMENT_COUNT, networkPrefixLength, false));
		this.zone = zone;
	}
	private IPv6Address(byte[] bytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength, zone);
	}
	private IPv6Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(long highBytes, long lowBytes, IPv6Zone zone) throws AddressValueException {
		this(highBytes, lowBytes, null, zone);
	}
	public IPv6Address(long highBytes, long lowBytes) throws AddressValueException {
		this(highBytes, lowBytes, null, null);
	}
	public IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength) throws AddressValueException {
		this(highBytes, lowBytes, networkPrefixLength, null);
	}
	private IPv6Address(long highBytes, long lowBytes, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createSection(highBytes, lowBytes, IPv6Address.SEGMENT_COUNT, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, networkPrefixLength, null);
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null, null);
	}
	public IPv6Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	public IPv6Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	@Deprecated
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, CharSequence zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, checkZone(zone));
	}
	public IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, IPv6Zone zone) throws AddressValueException {
		this(lowerValueProvider, upperValueProvider, null, zone);
	}
	private IPv6Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength, IPv6Zone zone) throws AddressValueException {
		super(thisAddress -> ((IPv6Address) thisAddress).getDefaultCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
		this.zone = zone;
	}
	public IPv6Address(IPv6Address prefix, MACAddress eui) throws IncompatibleAddressException {
		this(prefix.getSection(), eui.getSection());
	}
	public IPv6Address(IPv6AddressSection section, MACAddress eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui.getSection());
	}
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, (IPv6Zone) null);
	}
	@Deprecated
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, CharSequence zone) throws IncompatibleAddressException, AddressValueException  {
		this(section, eui, checkZone(zone));
	}
	public IPv6Address(IPv6AddressSection section, MACAddressSection eui, IPv6Zone zone) throws IncompatibleAddressException, AddressValueException  {
		super(thisAddress -> toFullEUI64Section(section, eui, ((IPv6Address) thisAddress).getDefaultCreator(), ((IPv6Address) thisAddress).getMACNetwork().getAddressCreator()));
		this.zone = zone;
	}
	static IPv6Zone checkZone(CharSequence zone) throws AddressValueException {
		if(zone == null) {
			return null;
		}
		String zoneStr = zone.toString().trim();
		if(zone.length() == 0) {
			return null;
		}
		int invalidIndex = Validator.validateZone(zoneStr);
		if(invalidIndex >= 0) {
			throw new AddressValueException("ipaddress.error.invalid.zone", invalidIndex);
		}
		return new IPv6Zone(zoneStr);
	}
	IPv6AddressCreator getDefaultCreator() {
		return getNetwork().getAddressCreator();
	}
	IPv6AddressCreator getCreator() {
		IPv6AddressCreator defaultCreator = getDefaultCreator();
		if(!hasZone()) {
			return defaultCreator;
		}
		IPv6AddressCreator creator = new IPv6AddressCreator(getNetwork(), defaultCreator.cache) {
			private static final long serialVersionUID = 4L;
			@Override
			protected IPv6Address createAddressInternal(IPv6AddressSegment segments[]) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(segments, zone); 
			}
			@Override
			public IPv6Address createAddress(IPv6AddressSection section) {
				IPv6AddressCreator creator = getDefaultCreator();
				return creator.createAddress(section, zone); 
			}
		};
		creator.useSegmentCache = defaultCreator.useSegmentCache;
		return creator;
	}
	private static IPv6Zone getZone(Inet6Address inet6Address) {
		NetworkInterface networkInterface = inet6Address.getScopedInterface();
		if(networkInterface != null) {
			return new IPv6Zone(networkInterface);
		}
		int scopeId = inet6Address.getScopeId();
		if(scopeId != 0) {
			return new IPv6Zone(scopeId);
		}
		return null;
	}
	private static IPv6AddressSection toFullEUI64Section(IPv6AddressSection section, MACAddressSection eui, IPv6AddressCreator creator, MACAddressCreator macCreator) throws AddressValueException, IncompatibleAddressException {
		boolean euiIsExtended = eui.isExtended();
		if(eui.addressSegmentIndex != 0) {
			throw new AddressPositionException(eui, eui.addressSegmentIndex);
		}
		if(section.addressSegmentIndex != 0) {
			throw new AddressPositionException(section, section.addressSegmentIndex);
		}
		if(section.getSegmentCount() < 4) {
			throw new AddressValueException(section, "ipaddress.mac.error.not.eui.convertible");
		}
		if(eui.getSegmentCount() != (euiIsExtended ? MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT : MACAddress.EXTENDED_UNIQUE_IDENTIFIER_48_SEGMENT_COUNT)) {
			throw new AddressValueException(eui, "ipaddress.mac.error.not.eui.convertible");
		}
		IPv6AddressSegment segments[] = creator.createSegmentArray(8);
		section.getSegments(0, 4, segments, 0);
		Integer prefLength = section.getNetworkPrefixLength();
		Integer prefixLength = prefLength != null && (prefLength <= 64) ? prefLength : null;
		toEUI64Segments(segments, 4, eui, 0, eui.isExtended(), creator, macCreator, prefixLength);
		return creator.createSectionInternal(segments);
	}
	static IPv6AddressSegment[] toEUI64Segments(
			IPv6AddressSegment segments[],
			int ipv6StartIndex,
			MACAddressSection eui,
			int euiStartIndex,
			boolean isExtended,
			IPv6AddressCreator creator,
			MACAddressCreator macCreator,
			Integer prefixLength) 
					throws IncompatibleAddressException {
		int euiSegmentIndex = 0;
		int euiSegmentCount = eui.getSegmentCount();
		MACAddressSegment seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7;
		seg0 = (euiStartIndex == 0 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg1 = (euiStartIndex <= 1 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg2 = (euiStartIndex <= 2 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg3 = (euiStartIndex <= 3 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg4 = (euiStartIndex <= 4 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg5 = (euiStartIndex <= 5 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg6 = (euiStartIndex <= 6 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex++) : null;
		seg7 = (euiStartIndex <= 7 && euiSegmentIndex < euiSegmentCount) ? eui.getSegment(euiSegmentIndex) : null;
		boolean isNotNull;
		MACAddressSegment zeroSegment = macCreator.createSegment(0);
		MACAddressSegment ffSegment = macCreator.createSegment(0xff);
		MACAddressSegment feSegment = macCreator.createSegment(0xfe);
		Integer currentPrefix = null;
		if(prefixLength != null) {
			currentPrefix = 0;
		}
		if((isNotNull = (seg0 != null)) || seg1 != null) {
			if(isNotNull) {
				if(seg1 == null) {
					seg1 = zeroSegment;
				}
			} else {
				seg0 = zeroSegment;
			}
			segments[ipv6StartIndex++] = join(creator, seg0, seg1, true , currentPrefix);
		}
		if(isExtended) {
			if((isNotNull = (seg2 != null)) || seg3 != null) {
				if(!isNotNull) {
					seg2 = zeroSegment;
					if(!seg3.matches(0xff)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
				}
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(!seg4.matches(0xfe)) {
						throw new IncompatibleAddressException(eui, "ipaddress.mac.error.not.eui.convertible");
					}
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				}
				segments[ipv6StartIndex++] = join(creator, feSegment, seg5, currentPrefix);
			}
		} else {
			if(seg2 != null) {
				segments[ipv6StartIndex++] = join(creator, seg2, ffSegment, currentPrefix);
			}
			if(seg3 != null) {
				segments[ipv6StartIndex++] = join(creator, feSegment, seg3, currentPrefix);
			}
			if((isNotNull = (seg4 != null)) || seg5 != null) {
				if(isNotNull) {
					if(seg5 == null) {
						seg5 = zeroSegment;
					}
				} else {
					seg4 = zeroSegment;
				}
				segments[ipv6StartIndex++] = join(creator, seg4, seg5, currentPrefix);
			}
		}
		if((isNotNull = (seg6 != null)) || seg7 != null) {
			if(isNotNull) {
				if(seg7 == null) {
					seg7 = zeroSegment;
				}
			} else {
				seg6 = zeroSegment;
			}
			segments[ipv6StartIndex] = join(creator, seg6, seg7, currentPrefix);
		}
		return segments;
	} 
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, Integer prefixLength) {
		return join(creator, macSegment0, macSegment1, false, prefixLength);
	}
	private static IPv6AddressSegment join(IPv6AddressCreator creator, MACAddressSegment macSegment0, MACAddressSegment macSegment1, boolean flip, Integer prefixLength) {
		if(macSegment0.isMultiple()) {
			if(!macSegment1.isFullRange()) {
				throw new IncompatibleAddressException(macSegment0, macSegment1, "ipaddress.error.invalidMACIPv6Range");
			}
		}
		int lower0 = macSegment0.getSegmentValue();
		int upper0 = macSegment0.getUpperSegmentValue();
		if(flip) {
			int mask2ndBit = 0x2;
			if(!macSegment0.matchesWithMask(mask2ndBit & lower0, mask2ndBit)) {
				throw new IncompatibleAddressException(macSegment0, "ipaddress.mac.error.not.eui.convertible");
			}
			lower0 ^= mask2ndBit;
			upper0 ^= mask2ndBit;
		}
		return creator.createSegment(
				(lower0 << 8) | macSegment1.getSegmentValue(), 
				(upper0 << 8) | macSegment1.getUpperSegmentValue(),
				prefixLength);
	}
	@Override
	public IPv6AddressNetwork getNetwork() {
		return defaultIpv6Network();
	}
	public MACAddressNetwork getMACNetwork() {
		return defaultMACNetwork();
	}
	public IPv4AddressNetwork getIPv4Network() {
		return defaultIpv4Network();
	}
	@Override
	public IPv6AddressSection getSection() {
		return (IPv6AddressSection) super.getSection();
	}
	@Override
	public IPv6AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv6AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	@Override
	public IPv6AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	@Override
	public IPv6AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	@Override
	public IPv6AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	public boolean isEUI64() {
		return getSection().isEUI64();
	}
	public MACAddress toEUI(boolean extended) {
		MACAddressSection section = getSection().toEUI(extended);
		if(section == null) {
			return null;
		}
		MACAddressCreator creator = getMACNetwork().getAddressCreator();
		return creator.createAddress(section);
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv6StringBuilderOptions.from(options));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv6StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv4Address ipv4Addr = getConverted(options);
		if(ipv4Addr != null) {
			IPAddressStringDivisionSeries ipv4Parts[] = ipv4Addr.getParts(options.ipv4ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv4Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv4Parts,  0, parts, tmp.length, ipv4Parts.length);
		}
		return parts;
	}
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	void cache(IPv6Address lower, IPv6Address upper) {
		if((lower != null || upper != null) && getSection().getSingleLowestOrHighestSection() == null) {
			getSection().cache(lower != null ? lower.getSection() : null, upper != null ? upper.getSection() : null);
			IPv6AddressCache cache = addressCache;
			if(cache == null || (lower != null && cache.lower == null) || (upper != null && cache.upper == null)) {
				synchronized(this) {
					cache = addressCache;
					boolean create = (cache == null);
					if(create) {
						addressCache = cache = new IPv6AddressCache();
						cache.lower = lower;
						cache.upper = upper;
					} else {
						if(cache.lower == null) {
							cache.lower = lower;
						}
						if(cache.upper == null) {
							cache.upper = upper;
						}
					}
				}
			}
		}
	}
	private IPv6Address getLowestOrHighest(boolean lowest, boolean excludeZeroHost) {
		IPv6AddressSection currentSection = getSection();
		IPv6AddressSection sectionResult = currentSection.getLowestOrHighestSection(lowest, excludeZeroHost);
		if(sectionResult == currentSection) {
			return this;
		} else if(sectionResult == null) {
			return null;
		}
		IPv6Address result = null;
		IPv6AddressCache cache = addressCache;
		if(cache == null || 
			(result = lowest ? (excludeZeroHost ? cache.lowerNonZeroHost : cache.lower) : cache.upper) == null) {
			synchronized(this) {
				cache = addressCache;
				boolean create = (cache == null);
				if(create) {
					addressCache = cache = new IPv6AddressCache();
				} else {
					if(lowest) {
						if(excludeZeroHost) {
							create = (result = cache.lowerNonZeroHost) == null;
						} else {
							create = (result = cache.lower) == null;
						}
					} else {
						create = (result = cache.upper) == null;
					}
				}
				if(create) {
					result = getCreator().createAddress(sectionResult);
					if(lowest) {
						if(excludeZeroHost) {
							 cache.lowerNonZeroHost = result;
						} else {
							cache.lower = result;
						}
					} else {
						cache.upper = result;
					}
				}
			}
		}
		return result;
	}
	@Override
	public IPv6Address getLowerNonZeroHost() {
		return getLowestOrHighest(true, true);
	}
	@Override
	public IPv6Address getLower() {
		return getLowestOrHighest(true, false);
	}
	@Override
	public IPv6Address getUpper() {
		return getLowestOrHighest(false, false);
	}
	public long[] longValues() {
		return getSection().longValues();
	}
	public long[] upperLongValues() {
		return getSection().upperLongValues();
	}
	IPv6TrieKeyData getTrieKeyCache() {
		IPv6TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv6TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			long vals[] = longValues();
			keyData.uint64HighVal = vals[0];
			keyData.uint64LowVal = vals[1];
			if(prefLen != null) {
				int bits = prefLen;
				IPv6Address mask = getNetwork().getNetworkMask(bits, false);
				vals = mask.longValues();
				keyData.mask64HighVal = vals[0];
				keyData.mask64LowVal = vals[1];
				if(bits > 63) {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> (bits - 64);
				} else {
					keyData.nextBitMask64Val = 0x8000000000000000L >>> bits;
				}
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	public IPv6Address replace(int startIndex, int endIndex, IPv6Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	public IPv6Address replace(int startIndex, IPv6AddressSection replacement) {
		int replacementCount = Math.min(IPv6Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv6Address reverseBits(boolean perByte) {
		return getCreator().createAddress(getSection().reverseBits(perByte));
	}
	@Override
	public IPv6Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public IPv6Address reverseBytesPerSegment() {
		return checkIdentity(getSection().reverseBytesPerSegment());
	}
	@Override
	public IPv6Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv6AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<IPv6Address, IPv6AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getCreator());
	}
	@Override
	public Stream<IPv6AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), true);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator() {
		return getSection().prefixIterator(this, getCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv6Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv6Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getCreator(), segmentCount);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getCreator(), segmentCount);
	}
	@Override
	public Stream<IPv6Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6Address> sequentialBlockIterator() {
		return (Iterator<IPv6Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv6Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv6Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv6Address> sequentialBlockStream() {
		return (Stream<IPv6Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterator<IPv6Address> iterator() {
		return getSection().iterator(this, getCreator(), null);
	}
	@Override
	public AddressComponentSpliterator<IPv6Address> spliterator() {
		return getSection().spliterator(this, getCreator(), false);
	}
	@Override
	public Stream<IPv6Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv6Address> nonZeroHostIterator() {
		Predicate<IPv6AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = segments -> getSection().isZeroHost(segments, prefLength);
		}
		return getSection().iterator(this, getCreator(), excludeFunc);
	}
	@Override
	public Iterable<IPv6Address> getIterable() {
		return this;
	}
	public IPv6Address increment(BigInteger increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv6Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv6Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	@Override
	public IPv4Address toIPv4() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv4(this);
	}
	@Override
	public IPv6Address toIPv6() {
		return this;
	}
	@Override
	public boolean isIPv6() {
		return true;
	}
	@Override
	public boolean isIPv4Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv4Convertible(this);
	}
	@Override
	public boolean isIPv6Convertible() {
		return true;
	}
	public IPv4AddressSection toMappedIPv4Segments() {
		if(isIPv4Mapped()) {
			return getSection().getEmbeddedIPv4AddressSection();
		}
		return null;
	}
	public IPv4Address get6To4IPv4Address() {
		return getEmbeddedIPv4Address(2);
	}
	public IPv4Address getEmbeddedIPv4Address() {
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection()); 
	}
	public IPv4Address getEmbeddedIPv4Address(int byteIndex) {
		if(byteIndex == IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT * IPv6Address.BYTES_PER_SEGMENT) {
			return getEmbeddedIPv4Address();
		}
		IPv4AddressCreator creator = getIPv4Network().getAddressCreator();
		return creator.createAddress(getSection().getEmbeddedIPv4AddressSection(byteIndex, byteIndex + IPv4Address.BYTE_COUNT)); 
	}
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			IPv6AddressSegment firstSeg = getSegment(0);
			if(firstSeg.matchesWithMask(8, 0xf)) {
				return true;
			}
			if(firstSeg.getValueCount() <= 5 && 
					(firstSeg.getSegmentValue() & 0xf) >= 1 && (firstSeg.getUpperSegmentValue() & 0xf) <= 5) {
				return true;
			}
			if(firstSeg.matchesWithPrefixMask(0xff30, 12) && getSegment(6).matchesWithPrefixMask(0x8000, 1)) {
				return true;
			}
		}
		return isLinkLocal() || isSiteLocal() || isUniqueLocal() || isAnyLocal();
	}
	@Override
	public boolean isLinkLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(2, 0xf)) || 
				firstSeg.matchesWithPrefixMask(0xfe80, 10);
	}
	public boolean isSiteLocal() {
		IPv6AddressSegment firstSeg = getSegment(0);
		return (isMulticast() && firstSeg.matchesWithMask(5, 0xf)) ||  
				firstSeg.matchesWithPrefixMask(0xfec0, 10); 
	}
	public boolean isUniqueLocal() {
		return getSegment(0).matchesWithPrefixMask(0xfc00, 7);
	}
	public boolean isIPv4Mapped() {
		if(getSegment(5).matches(IPv6Address.MAX_VALUE_PER_SEGMENT)) {
			for(int i = 0; i < 5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	public boolean isIPv4Compatible() {
		return getSegment(0).isZero() && getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() && getSegment(5).isZero();
	}
	public boolean is6To4() {
		return getSegment(0).matches(0x2002);
	}
	public boolean is6Over4() {
		return getSegment(0).matches(0xfe80) && 
				getSegment(1).isZero() && getSegment(2).isZero() &&
				getSegment(3).isZero() && getSegment(4).isZero() &&
				getSegment(5).isZero();
	}
	public boolean isTeredo() {
		return getSegment(0).matches(0x2001) && getSegment(1).isZero();
	}
	public boolean isIsatap() {
		return getSegment(0).matches(0xfe80) &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero() &&
				(getSegment(4).isZero() || getSegment(4).matches(0x200)) && 
				getSegment(5).matches(0x5efe);
	}
	public boolean isIPv4Translatable() { 
		return getSegment(4).matches(0xffff) && 
				getSegment(5).isZero() &&
				getSegment(0).isZero() &&
				getSegment(1).isZero() &&
				getSegment(2).isZero() &&
				getSegment(3).isZero();
	}
	public boolean isWellKnownIPv4Translatable() { 
		if(getSegment(0).matches(0x64) && getSegment(1).matches(0xff9b)) {
			for(int i=2; i<=5; i++) {
				if(!getSegment(i).isZero()) {
					return false;
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public boolean isMulticast() {
		return getSegment(0).matchesWithPrefixMask(0xff00, 8);
	}
	@Override
	public boolean isLoopback() {
		int i=0;
		for(; i < getSegmentCount() - 1; i++) {
			if(!getSegment(i).isZero()) {
				return false;
			}
		}
		return getSegment(i).matches(1);
	}
	@Override
	public IPv6Address intersect(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6Address otherAddr = convertArg(other);
		IPv6AddressSection section = thisSection.intersect(otherAddr.getSection());
		if(section == null) {
			return null;
		}
		IPv6AddressCreator creator = isSameZone(otherAddr) ? getCreator() : getDefaultCreator();
		IPv6Address result = creator.createAddress(section);
		return result;
	}
	@Override
	public IPv6Address[] subtract(IPAddress other) throws AddressConversionException {
		IPv6AddressSection thisSection = getSection();
		IPv6AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv6Address result[] = new IPv6Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = getCreator().createAddress(sections[i]); 
		}
		return result;
	}
	private IPv6Address checkIdentity(IPv6AddressSection newSection) {
		if(newSection == getSection()) {
			return this;
		}
		return getCreator().createAddress(newSection);
	}
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	@Override
	public IPv6Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public IPv6Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength) throws PrefixLenException {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public IPv6Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv6Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv6Address removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public IPv6Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override @Deprecated
	public IPv6Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Override
	protected IPv6Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv6Address converted = arg.toIPv6();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	@Override
	public IPv6Address toZeroHost() {
		return toZeroHost(false);
	}
	@Override
	protected IPv6Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv6AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv6Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv6Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	@Override
	public IPv6Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv6Address toMaxHost() {
		if(!isPrefixed()) {
			IPv6Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return checkIdentity(getSection().createMaxHost());
	}
	@Override
	public IPv6Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	@Override
	public IPv6Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv6Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	@Override
	public IPv6Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv6Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv6Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	@Override
	public IPv6Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv6Address getHostMask() {
		return (IPv6Address) super.getHostMask();
	}
	@Override
	public IPv6Address getNetworkMask() {
		return (IPv6Address) super.getNetworkMask();
	}
	@Override
	public IPv6AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	@Override
	public IPv6AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	@Override
	public IPv6AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	@Override
	public IPv6AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	@Override
	public IPv6Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv6Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv6Address assignPrefixForSingleBlock() {
		return (IPv6Address) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv6Address assignMinPrefixForBlock() {
		return (IPv6Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv6Address coverWithPrefixBlock() {
		return (IPv6Address) IPv6AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv6Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv6AddressSection.coverWithPrefixBlock(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	@Override
	public IPv6Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(true);
		return list.toArray(new IPv6Address[list.size()]);
	}
	@Override
	public IPv6Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::assignPrefixForSingleBlock,
				IPv6Address::withoutPrefixLength,
				getCreator()::createAddressArray);
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv6Address[] { withoutPrefixLength().removeZone() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv6Address> list = (ArrayList<IPv6Address>) removeZone().spanWithBlocks(false);
		return list.toArray(new IPv6Address[list.size()]);
	}
	@Override
	public IPv6Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this.removeZone(),
				convertArg(other).removeZone(),
				IPv6Address::getLower,
				IPv6Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv6Address::withoutPrefixLength,
				getDefaultCreator());
	}
	@Override
	public IPv6AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv6Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]).removeZone();
		}
		converted[0] = removeZone();
		return converted;
	}
	@Override
	public IPv6Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv6Address[] {removeZone()};
			}
		}
		addresses = addresses.clone();
		for(int i = 0; i < addresses.length; i++) {
			addresses[i] = convertArg(addresses[i]).removeZone();
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getDefaultCreator());
		return blocks.toArray(new IPv6Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getDefaultCreator()::createSequentialBlockAddress;
	}
	public boolean hasZone() {
		return zone != null;
	}
	public String getZone() {
		return getZoneString();
	}
	public IPv6Address setZone(IPv6Zone newZone) {
		if(newZone == null) {
			return removeZone();
		}
		return getDefaultCreator().createAddress(getSection(), newZone); 
	}
	public IPv6Zone getIPv6Zone() {
		return zone;
	}
	public IPv6Address removeZone() {
		if(hasZone()) {
			return getDefaultCreator().createAddress(getSection()); 
		}
		return this;
	}
	protected boolean hasNoValueCache() {
		if(addressCache == null) {
			synchronized(this) {
				if(addressCache == null) {
					addressCache = new IPv6AddressCache();
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public Inet6Address toInetAddress() {
		if(hasZone()) {
			Inet6Address result;
			if(hasNoValueCache() || (result = addressCache.inetAddress) == null) {
				addressCache.inetAddress = result = (Inet6Address) toInetAddressImpl();
			}
			return result;
		}
		return (Inet6Address) super.toInetAddress();
	}
	@Override
	public Inet6Address toUpperInetAddress() {
		return (Inet6Address) super.toUpperInetAddress();
	}
	@Override
	protected Inet6Address toInetAddressImpl() {
		Inet6Address result;
		byte bytes[] = getSection().getBytesInternal();
		try {
			if(hasZone()) {
				if(zone.referencesScopeId()) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedScopeId());
				} else if(zone.referencesIntf() && zone.getAssociatedIntf() != null) {
					result = Inet6Address.getByAddress(null, bytes, zone.getAssociatedIntf());
				} else {
					IPv6Address adjusted = getLower().withoutPrefixLength();
					InetAddress resultIP = InetAddress.getByName(adjusted.toNormalizedString());
					if(resultIP instanceof Inet6Address) {
						result = (Inet6Address) resultIP;
					} else {
						result = Inet6Address.getByAddress(null, bytes, null);
					}
				}
			} else {
				result = Inet6Address.getByAddress(null, bytes, null);
			}
		} catch(UnknownHostException e) {
			result = null;
		}
		return result;
	}
	@Override
	@Deprecated
	public IPv6AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv6AddressSeqRange(this, convertArg(other));
	}
	@Override
	public IPv6AddressSeqRange toSequentialRange() {
		IPv6Address thiz = removeZone().withoutPrefixLength();
		return new IPv6AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	@Override
	public int hashCode() {
		int result = super.hashCode();
		if(hasZone()) {
			result *= zone.getName().hashCode();
		}
		return result;
	}
	@Override
	public boolean isSameAddress(Address other) {
		return other instanceof IPv6Address && super.isSameAddress(other) && isSameZone((IPv6Address) other);
	}
	private boolean isSameZone(IPv6Address otherIPv6Address) {
		return Objects.equals(zone, otherIPv6Address.zone);
	}
	@Override
	public boolean overlaps(Address other) {
		if(super.overlaps(other)) {
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public boolean contains(Address other) {
		if(super.contains(other)) {
			if(other != this) {
				IPv6Address otherAddr = (IPv6Address) other;
				if(hasZone() || otherAddr.hasZone()) {
					return isSameZone(otherAddr);
				}
			}
			return true;
		}
		return false;
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv6Address) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv6()) {
			return IPv6AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getIPv4Network()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().toParams();
	}
	private boolean hasNoStringCache() {
		if(stringCache == null) {
			synchronized(this) {
				if(stringCache == null) {
					if(hasZone()) {
						stringCache = new IPv6StringCache();
						return true;
					} else {
						IPv6AddressSection section = getSection();
						boolean result = section.hasNoStringCache();
						stringCache = section.getStringCache();
						return result;
					}
				}
			}
		}
		return false;
	}
	public String toMixedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.mixedString) == null) {
			if(hasZone()) {
				stringCache.mixedString = result = toNormalizedString(IPv6StringCache.mixedParams);
			} else {
				result = getSection().toMixedString();
			}
		}
		return result;
	}
	@Override
	public String toCanonicalString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalString) == null) {
			if(hasZone()) {
				stringCache.canonicalString = result = toNormalizedString(IPv6StringCache.canonicalParams);
			} else {
				result = getSection().toCanonicalString();
			}
		}
		return result;
	}
	@Override
	public String toFullString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.fullString) == null) {
			if(hasZone()) {
				stringCache.fullString = result = toNormalizedString(IPv6StringCache.fullParams);
			} else {
				result = getSection().toFullString();
			}
		}
		return result;
	}
	public static String toNormalizedString(IPv6AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength, CharSequence zone) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, zone);
	}
	@Override
	public String toNormalizedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedString) == null) {
			if(hasZone()) {
				stringCache.normalizedString = result = toNormalizedString(IPv6StringCache.normalizedParams);
			} else {
				result = getSection().toNormalizedString();
			}
		}
		return result;
	}
	@Override
	public String toCompressedString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedString) == null) {
			if(hasZone()) {
				stringCache.compressedString = result = toNormalizedString(IPv6StringCache.compressedParams);
			} else {
				result = getSection().toCompressedString();
			}
		}
		return result;
	}
	@Override
	public String toSubnetString() {
		return toPrefixLengthString();
	}
	@Override
	public String toNormalizedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.normalizedWildcardString) == null) {
			if(hasZone()) {
				stringCache.normalizedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardNormalizedParams);
			} else {
				result = getSection().toNormalizedWildcardString();
			}
		}
		return result;
	}
	public String toBase85String() throws IncompatibleAddressException {
		IPAddressString originator = getAddressfromString();
		if(originator != null && (!isPrefixed() || getNetworkPrefixLength() == IPv6Address.BIT_COUNT) && 
				originator.isBase85IPv6()) {
			return originator.toString();
		}
		String result;
		if(hasNoStringCache() || (result = stringCache.base85String) == null) {
			if(hasZone()) {
				stringCache.base85String = result = getSection().toBase85String(getZone());
			} else {
				result = getSection().toBase85String();
			}
		}
		return result;
	}
	@Override
	public String toCanonicalWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.canonicalWildcardString) == null) {
			if(hasZone()) {
				stringCache.canonicalWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCanonicalParams);
			} else {
				result = getSection().toCanonicalWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toCompressedWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.compressedWildcardString) == null) {
			if(hasZone()) {
				stringCache.compressedWildcardString = result = toNormalizedString(IPv6StringCache.wildcardCompressedParams);
			} else {
				result = getSection().toCompressedWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toSQLWildcardString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.sqlWildcardString) == null) {
			if(hasZone()) {
				stringCache.sqlWildcardString = result = toNormalizedString(IPv6StringCache.sqlWildcardParams);
			} else {
				result = getSection().toSQLWildcardString();
			}
		}
		return result;
	}
	@Override
	public String toHexString(boolean with0xPrefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0xPrefix ? stringCache.hexStringPrefixed : stringCache.hexString)) == null) {
			if(hasZone()) {
				result = getSection().toHexString(with0xPrefix, zone.getName());
				if(with0xPrefix) {
					stringCache.hexStringPrefixed = result;
				} else {
					stringCache.hexString = result;
				}
			} else {
				result = getSection().toHexString(with0xPrefix);
			}
		}
		return result;
	}
	private String getZoneString() {
		return hasZone() ? zone.getName() : null;
	}
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = stringCache.binaryString) == null) {
			if(hasZone()) {
				result = getSection().toBinaryString(zone.getName());
				stringCache.binaryString = result;
			} else {
				result = getSection().toBinaryString();
			}
		}
		return result;
	}
	@Override
	public String toSegmentedBinaryString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.segmentedBinaryString) == null) {
			if(hasZone()) {
				result = getSection().toSegmentedBinaryString(zone.getName());
				stringCache.segmentedBinaryString = result;
			} else {
				result = getSection().toSegmentedBinaryString();
			}
		}
		return result;
	}
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		String result;
		if(hasNoStringCache() || (result = (with0Prefix ? stringCache.octalStringPrefixed : stringCache.octalString)) == null) {
			if(hasZone()) {
				result = getSection().toOctalString(with0Prefix, zone.getName());
				if(with0Prefix) {
					stringCache.octalStringPrefixed = result;
				} else {
					stringCache.octalString = result;
				}
			} else {
				result = getSection().toOctalString(with0Prefix);
			}
		}
		return result;
	}
	@Override
	public String toPrefixLengthString() {
		String result;
		if(hasNoStringCache() || (result = stringCache.networkPrefixLengthString) == null) {
			if(hasZone()) {
				stringCache.networkPrefixLengthString = result = toNormalizedString(IPv6StringCache.networkPrefixLengthParams);
			} else {
				result = getSection().toPrefixLengthString();
			}
		}
		return result;
	}
	@Override
	public String toConvertedString() {
		if(isIPv4Convertible()) {
			return toMixedString();
		}
		return toNormalizedString();
	}
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	public String toNormalizedString(IPv6StringOptions params) {
		return getSection().toNormalizedString(params, getZoneString());
	}
	public String toNormalizedString(boolean keepMixed, IPv6StringOptions params) {
		if(keepMixed && fromString != null && getAddressfromString().isMixedIPv6() && !params.makeMixed()) {
			params = new IPv6StringOptions(
					params.base,
					params.expandSegments,
					params.wildcardOption,
					params.wildcards,
					params.segmentStrPrefix,
					true,
					params.ipv4Opts,
					params.compressOptions,
					params.separator,
					params.zoneSeparator,
					params.addrLabel,
					params.addrSuffix,
					params.reverse,
					params.splitDigits,
					params.uppercase);
		}
		return toNormalizedString(params);
	}
	@Override
	public String toUNCHostName() {
		String result;
		if(hasNoStringCache() || (result = stringCache.uncString) == null) {
			String newZone;
			if(hasZone()) {
				newZone = zone.getName().replace(IPv6Address.ZONE_SEPARATOR, IPv6Address.UNC_ZONE_SEPARATOR).replace(IPv6Address.SEGMENT_SEPARATOR, IPv6Address.UNC_SEGMENT_SEPARATOR);
			} else {
				newZone = null;
			}
			stringCache.uncString = result = getSection().toNormalizedString(IPv6StringCache.uncParams, newZone);
		}
		return result;
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv6StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv6StringBuilderOptions.from(opts));
	}
	private IPv4Address getConverted(IPv6StringBuilderOptions opts) {
		if(!hasZone() && opts.includes(IPv6StringBuilderOptions.IPV4_CONVERSIONS)) {
			IPv4AddressConverter converter = opts.converter;
			return converter.toIPv4(this);
		}
		return null;
	}
	public IPAddressPartStringCollection toStringCollection(IPv6StringBuilderOptions opts) {
		IPv6StringCollection coll = getSection().toStringCollection(opts, getZoneString());
		IPv4Address ipv4Addr = getConverted(opts);
		if(ipv4Addr != null) {
			IPAddressPartStringCollection ipv4StringCollection = ipv4Addr.toStringCollection(opts.ipv4ConverterOptions);
			coll.addAll(ipv4StringCollection);
		}
		return coll;
	}
	public interface IPv6AddressConverter {
		IPv6Address toIPv6(IPAddress address);
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.IPAddressConverter.DefaultAddressConverter;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSection.TriFunction;
import inet.ipaddr.format.IPAddressRange;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.format.util.sql.IPAddressSQLTranslator;
import inet.ipaddr.format.validate.IPAddressProvider;
import inet.ipaddr.format.validate.ParsedHost;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public abstract class IPAddress extends Address implements IPAddressSegmentSeries, IPAddressRange {
	private static final long serialVersionUID = 4L;
	public static enum IPVersion {
		IPV4,
		IPV6;
		public boolean isIPv4() {
			return this == IPV4;
		}
		public boolean isIPv6() {
			return this == IPV6;
		}
		@Override
		public String toString() {
			return isIPv4() ? "IPv4" : "IPv6";
		}
	}
	public static interface IPAddressValueProvider extends AddressValueProvider {
		IPVersion getIPVersion();
		default Integer getPrefixLength() {
			return null;
		}
		default String getZone() {
			return null;
		}
	}
	public static final char PREFIX_LEN_SEPARATOR = '/';
	public static final String BINARY_STR_PREFIX = "0b";
	public static final IPAddressConverter DEFAULT_ADDRESS_CONVERTER = new DefaultAddressConverter();
	HostName fromHost;
	private HostName canonicalHost;
	protected IPAddress(IPAddressSection section) {
		super(section);
	}
	protected IPAddress(Function<Address, AddressSection> supplier) {
		super(supplier);
	}
	@Override
	public IPAddressString toAddressString() {
		if(fromString == null) {
			IPAddressStringParameters params = createFromStringParams();
			fromString = new IPAddressString(toCanonicalString(), this, params); 
		}
		return getAddressfromString();
	}
	protected abstract IPAddressStringParameters createFromStringParams();
	protected IPAddressString getAddressfromString() {
		return (IPAddressString) fromString;
	}
	public HostName toHostName() {
		HostName host = fromHost;
		if(host == null) {
			fromHost = host = toCanonicalHostName();
		}
		return host;
	}
	void cache(HostIdentifierString string) {
		if(string instanceof HostName) {
			fromHost = (HostName) string;
			fromString = new IPAddressString(fromHost.toString(), this, fromHost.validationOptions.addressOptions);
		} else if(string instanceof IPAddressString) {
			fromString = (IPAddressString) string;
		}
	}
	protected IPAddressProvider getProvider() {
		if(isPrefixed()) {
			if(getNetwork().getPrefixConfiguration().prefixedSubnetsAreExplicit() || !isPrefixBlock()) {
				return IPAddressProvider.getProviderFor(this, withoutPrefixLength()); 
			}
			return IPAddressProvider.getProviderFor(this, toZeroHost(true).withoutPrefixLength());
		}
		return IPAddressProvider.getProviderFor(this, this);
	}
	public HostName toCanonicalHostName() {
		HostName host = canonicalHost;
		if(host == null) {
			if(isMultiple()) {
				throw new IncompatibleAddressException(this, "ipaddress.error.unavailable.numeric");
			}
			InetAddress inetAddress = toInetAddress();
			String hostStr = inetAddress.getCanonicalHostName();
			if(hostStr.equals(inetAddress.getHostAddress())) {
				host = new HostName(hostStr, new ParsedHost(hostStr, getProvider()));
				host.resolvedAddresses = new IPAddress[] {this};
			} else {
				host = new HostName(hostStr);
			}
		}
		return host;
	}
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	@Override
	public IPAddressSection getSection() {
		return (IPAddressSection) super.getSection();
	}
	@Override
	public IPAddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPAddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return new IPAddressStringDivisionSeries[] { getSection() };
	}
	@Override
	public int getMaxSegmentValue() {
		return IPAddressSegment.getMaxSegmentValue(getIPVersion());
	}
	static int getMaxSegmentValue(IPVersion version) {
		return IPAddressSegment.getMaxSegmentValue(version);
	}
	@Override
	public BigInteger getNonZeroHostCount() {
		return getSection().getNonZeroHostCount();
	}
	@Override
	public int getBytesPerSegment() {
		return IPAddressSegment.getByteCount(getIPVersion());
	}
	static int getBytesPerSegment(IPVersion version) {
		return IPAddressSegment.getByteCount(version);
	}
	@Override
	public int getBitsPerSegment() {
		return IPAddressSegment.getBitCount(getIPVersion());
	}
	static int getBitsPerSegment(IPVersion version) {
		return IPAddressSegment.getBitCount(version);
	}
	@Override
	public int getByteCount() {
		return getSection().getByteCount();
	}
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTE_COUNT : IPv6Address.BYTE_COUNT;
	}
	public static int getSegmentCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.SEGMENT_COUNT : IPv6Address.SEGMENT_COUNT;
	}
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BIT_COUNT : IPv6Address.BIT_COUNT;
	}
	protected abstract IPAddress convertArg(IPAddress arg) throws AddressConversionException;
	public <V> V applyToBounds(BiFunction<? super IPAddress, ? super IPAddress, V> func, IPAddress ...series) {
		AddressComparator lowComparator = Address.ADDRESS_LOW_VALUE_COMPARATOR;
		AddressComparator highComparator = Address.ADDRESS_HIGH_VALUE_COMPARATOR;
		IPAddress lowest = this;
		IPAddress highest = this;
		for(int i = 0; i < series.length; i++) {
			IPAddress next = series[i];
			if(next == null) {
				continue;
			}
			next = convertArg(next);
			if(lowComparator.compare(next, lowest) < 0) {
				lowest = next;
			}
			if(highComparator.compare(next, highest) > 0) {
				highest = next;
			}
		}
		return func.apply(lowest.getLower(), highest.getUpper());
	}
	@Override
	public abstract IPAddress getLowerNonZeroHost();
	@Override
	public abstract IPAddress getLower();
	@Override
	public abstract IPAddress getUpper();
	@Override
	public abstract IPAddress reverseBits(boolean perByte);
	@Override
	public abstract IPAddress reverseBytes();
	@Override
	public abstract IPAddress reverseBytesPerSegment();
	@Override
	public abstract IPAddress reverseSegments();
	@Override
	public abstract Iterator<? extends IPAddress> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> spliterator();
	@Override
	public abstract Stream<? extends IPAddress> stream();
	@Override
	public abstract Iterator<? extends IPAddress> nonZeroHostIterator();
	@Override
	public abstract Iterator<? extends IPAddress> prefixIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> prefixSpliterator();
	@Override
	public abstract Stream<? extends IPAddress> prefixStream();
	@Override
	public abstract Iterator<? extends IPAddress> prefixBlockIterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> prefixBlockSpliterator();
	@Override
	public abstract Stream<? extends IPAddress> prefixBlockStream();
	@Override
	public abstract Iterator<? extends IPAddress> blockIterator(int segmentCount);
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddress> blockSpliterator(int segmentCount);
	@Override
	public abstract Stream<? extends IPAddress> blockStream(int segmentCount);
	@Override
	public Iterator<? extends IPAddress> sequentialBlockIterator() {
		return blockIterator(getSequentialBlockIndex());
	}
	@Override
	public AddressComponentSpliterator<? extends IPAddress> sequentialBlockSpliterator() {
		return blockSpliterator(getSequentialBlockIndex());
	}
	@Override
	public Stream<? extends IPAddress> sequentialBlockStream() {
		return blockStream(getSequentialBlockIndex());
	}
	@Override
	public BigInteger getSequentialBlockCount() {
		return getSection().getSequentialBlockCount();
	}
	@Override
	public abstract Iterable<? extends IPAddress> getIterable();
	@Override
	public abstract IPAddress increment(long increment) throws AddressValueException;
	@Override
	public abstract IPAddress incrementBoundary(long increment) throws AddressValueException;
	@Override
	public boolean isIPAddress() {
		return true;
	}
	@Override
	public IPAddress toIPAddress() {
		return this;
	}
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6(){
		return false;
	}
	@Override
	public IPVersion getIPVersion() {
		return getSection().getIPVersion();
	}
	public IPv4Address toIPv4() {
		return null;
	}
	public IPv6Address toIPv6() {
		return null;
	}
	public abstract boolean isIPv4Convertible();
	public abstract boolean isIPv6Convertible();
	public abstract boolean isLinkLocal();
	@Override
	public abstract boolean isLocal();
	public boolean isUnspecified() {
		return isZero();
	}
	public boolean isAnyLocal() {
		return isZero();
	}
	public abstract boolean isLoopback();
	public InetAddress toUpperInetAddress() {
		return getUpper().toInetAddress();
	}
	public InetAddress toInetAddress() {
		return getSection().toInetAddress(this);
	}
	protected InetAddress toInetAddressImpl() {
		try {
			return InetAddress.getByAddress(getSection().getBytesInternal());
		} catch(UnknownHostException e) {  return null; }
	}
	@Override
	public abstract IPAddressSeqRange toSequentialRange();
	@Deprecated
	public abstract IPAddressSeqRange toSequentialRange(IPAddress other) throws AddressConversionException;
	public boolean matches(IPAddressString otherString) {
		if(isFromSameString(otherString)) {
			return true;
		}
		IPAddress otherAddr = otherString.getAddress();
		return otherAddr != null && isSameAddress(otherAddr);
	}
	@Override
	protected boolean isFromSameString(HostIdentifierString other) {
		if(fromString != null && other instanceof IPAddressString) {
			IPAddressString fromString = (IPAddressString) this.fromString;
			IPAddressString otherString = (IPAddressString) other;
			return (fromString == otherString || 
					(fromString.fullAddr.equals(otherString.fullAddr) &&
					fromString.validationOptions == otherString.validationOptions));
		}
		return false;
	}
	@Override
	public boolean overlaps(IPAddress other) {
		return super.overlaps(other);
	}
	@Override
	public boolean overlaps(IPAddressSeqRange other) {
		return other.overlaps(this);
	}
	@Override
	public boolean contains(IPAddress other) {
		return super.contains(other);
	}
	public boolean containsNonZeroHosts(IPAddress other) {
		if(other == this) {
			return true;
		}
		return getSection().containsNonZeroHosts(other.getSection());
	}
	@Override
	public abstract BigInteger enumerate(IPAddress other);
	public boolean prefixContains(IPAddress other) {
		if(other == this) {
			return true;
		}
		return getSection().prefixContains(other.getSection());
	}
	public boolean isZeroHost() {
		return getSection().isZeroHost();
	}
	public boolean isZeroHost(int networkPrefixLength) {
		return getSection().isZeroHost(networkPrefixLength);
	}
	@Override
	public boolean contains(IPAddressSeqRange otherRange) {
		return otherRange.isContainedBy(this);
	}
	public boolean matchesWithMask(IPAddress other, IPAddress mask) {
		return getSection().matchesWithMask(other.getSection(), mask.getSection());
	}
	public static void toNormalizedString(IPAddressValueProvider provider, StringBuilder builder) {
		IPVersion version = provider.getIPVersion();
		if(version.isIPv4()) {
			toNormalizedString(defaultIpv4Network().getPrefixConfiguration(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), IPv4Address.SEGMENT_COUNT,  IPv4Address.BYTES_PER_SEGMENT,  IPv4Address.BITS_PER_SEGMENT,  IPv4Address.MAX_VALUE_PER_SEGMENT,  IPv4Address.SEGMENT_SEPARATOR,  IPv4Address.DEFAULT_TEXTUAL_RADIX, null, builder);
		} else if(version.isIPv6()) {
			toNormalizedString(defaultIpv6Network().getPrefixConfiguration(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), IPv6Address.SEGMENT_COUNT, IPv6Address.BYTES_PER_SEGMENT, IPv6Address.BITS_PER_SEGMENT, IPv6Address.MAX_VALUE_PER_SEGMENT, IPv6Address.SEGMENT_SEPARATOR, IPv6Address.DEFAULT_TEXTUAL_RADIX, provider.getZone(), builder);
		} else {
			throw new IllegalArgumentException();
		}
	}
	public static String toNormalizedString(IPAddressValueProvider provider) {
		IPVersion version = provider.getIPVersion();
		if(version.isIPv4()) {
			return IPv4Address.toNormalizedString(defaultIpv4Network(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength());
		} else if(version.isIPv6()) {
			return IPv6Address.toNormalizedString(defaultIpv6Network(), provider.getValues(), provider.getUpperValues(), provider.getPrefixLength(), provider.getZone());
		}
		throw new IllegalArgumentException();
	}
	protected static String toNormalizedString(
			PrefixConfiguration prefixConfiguration,
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			Integer prefixLength,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			char separator,
			int radix,
			CharSequence zone) {
		int length = toNormalizedString(
				prefixConfiguration,
				lowerValueProvider,
				upperValueProvider,
				prefixLength,
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				segmentMaxValue,
				separator,
				radix,
				zone,
				null);
		StringBuilder builder = new StringBuilder(length);
		toNormalizedString(
				prefixConfiguration,
				lowerValueProvider,
				upperValueProvider,
				prefixLength,
				segmentCount,
				bytesPerSegment,
				bitsPerSegment,
				segmentMaxValue,
				separator,
				radix,
				zone,
				builder);
		IPAddressSection.checkLengths(length, builder);
		return builder.toString();
	}
	protected static int toNormalizedString(
			PrefixConfiguration prefixConfiguration,
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			Integer prefixLength,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			char separator,
			int radix,
			CharSequence zone,
			StringBuilder builder) {
		int segmentIndex, count;
		segmentIndex = count = 0;
		boolean adjustByPrefixLength;
		if(prefixLength != null && prefixConfiguration.allPrefixedAddressesAreSubnets()) {
			if(prefixLength <= 0) {
				adjustByPrefixLength = true;
			} else {
				int totalBitCount = (bitsPerSegment == 8) ? segmentCount << 3 : ((bitsPerSegment == 16) ? segmentCount << 4 : segmentCount * bitsPerSegment);
				adjustByPrefixLength = prefixLength < totalBitCount;
			}
		} else {
			adjustByPrefixLength = false;
		}
		while(true) {
			Integer segmentPrefixLength = IPAddressSection.getSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
			if(adjustByPrefixLength && segmentPrefixLength != null && segmentPrefixLength == 0) {
				if(builder == null) {
					count++;
				} else {
					builder.append('0');
				}
			} else {
				int value = 0, value2 = 0;
				if(lowerValueProvider == null) {
					value = upperValueProvider.getValue(segmentIndex);
				} else {
					value = lowerValueProvider.getValue(segmentIndex);
					if(upperValueProvider != null) {
						value2 = upperValueProvider.getValue(segmentIndex);
					}
				}
				if(lowerValueProvider == null || upperValueProvider == null) {
					if(adjustByPrefixLength && segmentPrefixLength != null) {
						value &= ~0 << (bitsPerSegment - segmentPrefixLength);
					}
					if(builder == null) {
						count += IPAddressSegment.toUnsignedStringLength(value, radix);
					} else {
						IPAddressSegment.toUnsignedString(value, radix, builder);
					}
				} else {
					if(adjustByPrefixLength && segmentPrefixLength != null) {
						int mask = ~0 << (bitsPerSegment - segmentPrefixLength);
						value &= mask;
						value2 &= mask;
					}
					if(value == value2) {
						if(builder == null) {
							count += IPAddressSegment.toUnsignedStringLength(value, radix);
						} else {
							IPAddressSegment.toUnsignedString(value, radix, builder);
						}
					} else {
						if(value > value2) {
							int tmp = value2;
							value2 = value;
							value = tmp;
						} 
						if(value == 0 && value2 == segmentMaxValue) {
							if(builder == null) {
								count += IPAddress.SEGMENT_WILDCARD_STR.length();
							} else {
								builder.append(IPAddress.SEGMENT_WILDCARD_STR);
							}
						} else {
							if(builder == null) {
								count += IPAddressSegment.toUnsignedStringLength(value, radix) + 
										IPAddressSegment.toUnsignedStringLength(value2, radix) + 
										IPAddress.RANGE_SEPARATOR_STR.length();
							} else {
								IPAddressSegment.toUnsignedString(value2, radix, IPAddressSegment.toUnsignedString(value, radix, builder).append(IPAddress.RANGE_SEPARATOR_STR));
							}
						}
					}
				}
			}
			if(++segmentIndex >= segmentCount) {
				break;
			}
			if(builder != null) {
				builder.append(separator);
			} 
		}
		if(builder == null) {
			count += segmentCount; 
			--count; 
		}
		if(zone != null && zone.length() > 0) {
			if(builder == null) {
				count += zone.length() + 1;
			} else {
				builder.append(IPv6Address.ZONE_SEPARATOR).append(zone);
			}
		}
		if(prefixLength != null) {
			if(builder == null) {
				count += IPAddressSegment.toUnsignedStringLength(prefixLength, 10) + 1;
			} else {
				builder.append(IPAddress.PREFIX_LEN_SEPARATOR).append(prefixLength);
			}
		} 
		return count;
	}
	@Override
	public String toFullString() {
		return getSection().toFullString();
	}
	protected void cacheNormalizedString(String str) {
		getSection().cacheNormalizedString(str);
	}
	@Override
	public String toSubnetString() {
		return getSection().toSubnetString();
	}
	@Override
	public String toNormalizedWildcardString() {
		return getSection().toNormalizedWildcardString();
	}
	@Override
	public String toCanonicalWildcardString() {
		return getSection().toCanonicalWildcardString();
	}
	@Override
	public String toCompressedWildcardString() {
		return getSection().toCompressedWildcardString();
	}
	@Override
	public String toSQLWildcardString() {
		 return getSection().toSQLWildcardString();
	}
	@Override
	public String toPrefixLengthString() {
		return getSection().toPrefixLengthString();
	}
	public String toConvertedString() {
		return toNormalizedString();
	}
	public abstract String toUNCHostName();
	@Override
	public String toReverseDNSLookupString() {
		return getSection().toReverseDNSLookupString();
	}
	@Override
	public String toBinaryString() throws IncompatibleAddressException {
		return getSection().toBinaryString();
	}
	@Override
	public String toOctalString(boolean with0Prefix) throws IncompatibleAddressException {
		return getSection().toOctalString(with0Prefix);
	}
	@Override
	public String toNormalizedString(IPStringOptions params) {
		return getSection().toNormalizedString(params);
	}
	public String[] toStandardStrings() {
		return toStandardStringCollection().toStrings();
	}
	public String[] toAllStrings() {
		return toAllStringCollection().toStrings();
	}
	public String[] toStrings(IPStringBuilderOptions options) {
		return toStringCollection(options).toStrings();
	}
	public IPAddressPartStringCollection toStandardStringCollection() {
		return getSection().toStandardStringCollection();
	}
	public IPAddressPartStringCollection toAllStringCollection() {
		return getSection().toAllStringCollection();
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions options) {
		return getSection().toStringCollection(options);
	}
	public static String toDelimitedSQLStrs(String strs[]) {
		if(strs.length == 0) {
			return "";
		}
		StringBuilder builder = new StringBuilder();
		for(String str : strs) {
			builder.append('\'').append(str).append('\'').append(',');
		}
		return builder.substring(0, builder.length() - 1);
	}
	@Override
	public Integer getNetworkPrefixLength() {
		return getSection().getNetworkPrefixLength();
	}
	@Override
	public IPAddress getHostMask() {
		Integer prefLength = getNetworkPrefixLength();
		return getNetwork().getHostMask(prefLength == null ? 0 : prefLength);
	}
	@Override
	public IPAddress getNetworkMask() {
		Integer prefLength = getNetworkPrefixLength();
		return getNetwork().getNetworkMask(prefLength == null ? getBitCount() : prefLength);
	}
	@Override
	public boolean includesZeroHost() {
		return getSection().includesZeroHost();
	}
	@Override
	public boolean includesZeroHost(int networkPrefixLength) {
		return getSection().includesZeroHost(networkPrefixLength);
	}
	@Override
	public abstract IPAddress toZeroHost(int prefixLength);
	@Override
	public abstract IPAddress toZeroHost();
	protected abstract IPAddress toZeroHost(boolean boundariesOnly);
	@Override
	public abstract IPAddress toZeroNetwork();
	@Override
	public abstract IPAddress toMaxHost(int prefixLength);
	@Override
	public abstract IPAddress toMaxHost();
	@Override
	public boolean includesMaxHost() {
		return getSection().includesMaxHost();
	}
	@Override
	public boolean includesMaxHost(int networkPrefixLength) {
		return getSection().includesMaxHost(networkPrefixLength);
	}
	public boolean isSingleNetwork() {
		return getSection().isSingleNetwork();
	}
	protected static <T extends IPAddress> T[] getSpanningPrefixBlocks(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator,
			UnaryOperator<T> prefixAdder,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		T result = checkPrefixBlockContainment(first, other, prefixAdder);
		if(result != null) {
			T resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		List<IPAddressSegmentSeries> blocks = 
				IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, (orig, one, two) -> IPAddressSection.splitIntoPrefixBlocks(one, two));
		return blocks.toArray(arrayProducer.apply(blocks.size()));
	}
	private static <T extends IPAddress> T checkPrefixBlockContainment(
			T first,
			T other,
			UnaryOperator<T> prefixAdder) {
		if(first.contains(other)) {
			return checkPrefixBlockFormat(first, other, true, prefixAdder);
		} else if(other.contains(first)) {
			return checkPrefixBlockFormat(other, first, false, prefixAdder);
		}
		return null;
	}
	static <T extends IPAddressSegmentSeries> T checkPrefixBlockFormat(
			T container,
			T contained,
			boolean checkEqual,
			UnaryOperator<T> prefixAdder) {
		T result = null;
		if(container.isPrefixed() && container.isSinglePrefixBlock()) {
			result = container;
		} else if(checkEqual && contained.isPrefixed() && container.isMore(contained) == 0 && contained.isSinglePrefixBlock()) {
			result = contained;
		} else {
			result = prefixAdder.apply(container); 
		}
		return result;
	}
	protected static <T extends IPAddress, S extends IPAddressSegment> T[] getSpanningSequentialBlocks(
			T first,
			T other,
			UnaryOperator<T> getLower,
			UnaryOperator<T> getUpper,
			Comparator<T> comparator,
			UnaryOperator<T> prefixRemover,
			IPAddressCreator<T, ?, ?, S, ?> creator) {
		T[] result = checkSequentialBlockContainment(first, other, prefixRemover, creator::createAddressArray);
		if(result != null) {
			return result;
		}
		SeriesCreator seriesCreator = creator::createSequentialBlockAddress;
		TriFunction<T, List<IPAddressSegmentSeries>> operatorFunctor = (orig, one, two) -> IPAddressSection.splitIntoSequentialBlocks(one, two, seriesCreator);
		List<IPAddressSegmentSeries> blocks = IPAddressSection.applyOperatorToLowerUpper(first, other, getLower, getUpper, comparator, prefixRemover, operatorFunctor);
		return blocks.toArray(creator.createAddressArray(blocks.size()));
	}
	private static <T extends IPAddress> T[] checkSequentialBlockContainment(
			T first,
			T other,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		if(first.contains(other)) {
			return checkSequentialBlockFormat(first, other, true, prefixRemover, arrayProducer);
		} else if(other.contains(first)) {
			return checkSequentialBlockFormat(other, first, false, prefixRemover, arrayProducer);
		}
		return null;
	}
	static <T extends IPAddressSegmentSeries> T[] checkSequentialBlockFormat(
			T container,
			T contained,
			boolean checkEqual,
			UnaryOperator<T> prefixRemover,
			IntFunction<T[]> arrayProducer) {
		T result = null;
		if(!container.isPrefixed()) {
			if(container.isSequential()) {
				result = container;
			}
		} else if(checkEqual && !contained.isPrefixed() && container.equals(contained)) {
			if(contained.isSequential()) {
				result = contained;
			}
		} else if(container.isSequential()) {
			result = prefixRemover.apply(container);
		}
		if(result != null) {
			T resultArray[] = arrayProducer.apply(1);
			resultArray[0] = result;
			return resultArray;
		}
		return null;
	}
	@Override
	public abstract IPAddress toPrefixBlock();
	@Override
	public abstract IPAddress toPrefixBlock(int networkPrefixLength) throws PrefixLenException;
	@Override
	public IPAddress assignPrefixForSingleBlock() {
		Integer newPrefix = getPrefixLengthForSingleBlock();
		return newPrefix == null ? null : setPrefixLength(newPrefix, false);
	}
	@Override
	public IPAddress assignMinPrefixForBlock() {
		return setPrefixLength(getMinPrefixLengthForBlock(), false);
	}
	public Integer getBlockMaskPrefixLength(boolean network) {
		return getSection().getBlockMaskPrefixLength(network);
	}
	public int getTrailingBitCount(boolean network) {
		return getSection().getTrailingBitCount(network);
	}
	public int getLeadingBitCount(boolean network) {
		return getSection().getLeadingBitCount(network);
	}
	public abstract IPAddress coverWithPrefixBlock(IPAddress other) throws AddressConversionException;
	public abstract IPAddress[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException;
	public abstract IPAddress[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException;
	protected List<? extends IPAddressSegmentSeries> spanWithBlocks(boolean prefixBlocks) {
		return spanWithBlocks(this, prefixBlocks);
	}
	static List<? extends IPAddressSegmentSeries> spanWithBlocks(IPAddressSegmentSeries orig, boolean prefixBlocks) {
		ArrayList<IPAddressSegmentSeries> list = new ArrayList<IPAddressSegmentSeries>();
		Iterator<? extends IPAddressSegmentSeries> iterator = orig.sequentialBlockIterator();
		while(iterator.hasNext()) {
			IPAddressSegmentSeries sequential = iterator.next();
			if(prefixBlocks) {
				Collections.addAll(list, sequential.spanWithPrefixBlocks());	
			} else {
				Collections.addAll(list, sequential);
			}
		}
		return list;
	}
	public abstract IPAddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException;
	public abstract IPAddress[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException;
	protected static List<IPAddressSegmentSeries> getMergedPrefixBlocks(IPAddressSegmentSeries sections[]) {
		return IPAddressSection.getMergedPrefixBlocks(sections);
	}
	private static final IPv6Address EMPTY_IPV6_ADDRESS[] = {};
	private static final IPv4Address EMPTY_IPV4_ADDRESS[] = {};
	public static class DualIPv4Pv6Arrays {
		public final IPv4Address addressesIPv4[];
		public final IPv6Address addressesIPv6[];
		DualIPv4Pv6Arrays(IPv4Address addressesIPv4[], IPv6Address addressesIPv6[]) {
			this.addressesIPv4 = addressesIPv4;
			this.addressesIPv6 = addressesIPv6;
		}
	}
	public static DualIPv4Pv6Arrays mergeToDualSequentialBlocks(IPAddress ...addresses) {
		Function<IPAddressSegmentSeries[], List<IPAddressSegmentSeries>> merger = (series) -> {
			SeriesCreator seriesCreator = ((IPAddress) series[0]).getSequentialSeriesCreator();
			return IPAddressSection.getMergedSequentialBlocks(series, seriesCreator);
		};
		return mergeToBlocks(addresses, merger);
	}
	protected abstract SeriesCreator getSequentialSeriesCreator();
	public static DualIPv4Pv6Arrays mergeToDualPrefixBlocks(IPAddress ...addresses) {
		return mergeToBlocks(addresses, IPAddressSection::getMergedPrefixBlocks);
	}
	private static DualIPv4Pv6Arrays mergeToBlocks(
			IPAddress addresses[], 
			Function<IPAddressSegmentSeries[], List<IPAddressSegmentSeries>> merger) {
		ArrayList<IPAddress> ipv4List = null;
		ArrayList<IPAddress> ipv6List = null;
		for(int i = 0; i < addresses.length; i++) {
			IPAddress addr = addresses[i];
			if(addr != null) {
				if(addr.isIPv4()) {
					if(ipv4List == null) {
						ipv4List = new ArrayList<IPAddress>(addresses.length);
					}
					ipv4List.add(addr);
				} else if(addr.isIPv6()) {
					if(ipv6List == null) {
						ipv6List = new ArrayList<IPAddress>(addresses.length);
					}
					ipv6List.add(addr);
				}
			}
		}
		IPv4Address addressesIPv4[];
		if(ipv4List != null){
			List<IPAddressSegmentSeries> blocks = merger.apply(ipv4List.toArray(new IPAddressSegmentSeries[ipv4List.size()]));
			addressesIPv4 = blocks.toArray(new IPv4Address[blocks.size()]);
		} else {
			addressesIPv4 = EMPTY_IPV4_ADDRESS;
		}
		IPv6Address addressesIPv6[];
		if(ipv6List != null){
			List<IPAddressSegmentSeries> blocks = merger.apply(ipv6List.toArray(new IPAddressSegmentSeries[ipv6List.size()]));
			addressesIPv6 = blocks.toArray(new IPv6Address[blocks.size()]);
		} else {
			addressesIPv6 = EMPTY_IPV6_ADDRESS;
		}
		return new DualIPv4Pv6Arrays(addressesIPv4, addressesIPv6);
	}
	public abstract IPAddress[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException;
	protected static <T extends IPAddress, S extends IPAddressSegment> List<IPAddressSegmentSeries> getMergedSequentialBlocks(IPAddressSegmentSeries sections[], IPAddressCreator<T, ?, ?, S, ?> creator) {
		return IPAddressSection.getMergedSequentialBlocks(sections, creator::createSequentialBlockAddress);
	}
	public abstract IPAddress intersect(IPAddress other) throws AddressConversionException;
	public abstract IPAddress[] subtract(IPAddress other) throws AddressConversionException;
	public abstract IPAddress mask(IPAddress mask) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress mask(IPAddress mask, boolean retainPrefix) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress maskNetwork(IPAddress mask, int networkPrefixLength) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress bitwiseOr(IPAddress mask) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress bitwiseOr(IPAddress mask, boolean retainPrefix) throws AddressConversionException, IncompatibleAddressException;
	public abstract IPAddress bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws AddressConversionException, IncompatibleAddressException;
	@Override @Deprecated
	public abstract IPAddress removePrefixLength();
	@Override @Deprecated
	public abstract IPAddress removePrefixLength(boolean zeroed);
	@Override
	public abstract IPAddress withoutPrefixLength();
	@Override
	public abstract IPAddress adjustPrefixBySegment(boolean nextSegment);
	@Override
	public abstract IPAddress adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	@Override
	public abstract IPAddress adjustPrefixLength(int adjustment);
	@Override
	public abstract IPAddress adjustPrefixLength(int adjustment, boolean zeroed);
	@Override
	public abstract IPAddress setPrefixLength(int prefixLength);
	@Override
	public abstract IPAddress setPrefixLength(int prefixLength, boolean zeroed);
	public abstract IPAddress setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock);
	@Deprecated
	@Override
	public abstract IPAddress applyPrefixLength(int networkPrefixLength);
	public void getMatchesSQLClause(StringBuilder builder, String sqlExpression) {
		getSection().getStartsWithSQLClause(builder, sqlExpression);
	}
	public void getMatchesSQLClause(StringBuilder builder, String sqlExpression, IPAddressSQLTranslator translator) {
		getSection().getStartsWithSQLClause(builder, sqlExpression, translator);
	}
	public IPAddress removeBitCountPrefixLength() {
		if(isPrefixed() && getNetworkPrefixLength() == getBitCount()) {
			return this.withoutPrefixLength();
		}
		return this;
	}
}
package inet.ipaddr.format.util;
import java.util.List;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.SubNodesMappingBasic;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
public class AddedTree<E extends Address> extends AddedTreeBase<E, SubNodesMappingBasic<E>> {
	public AddedTree(AssociativeAddressTrie<E, SubNodesMappingBasic<E>> wrapped) {
		super(wrapped);
	}
	public static class AddedTreeNode<E extends Address> extends AddedTreeNodeBase<E,SubNodesMappingBasic<E>> {
		public AddedTreeNode(AssociativeTrieNode<E, SubNodesMappingBasic<E>> node) {
			super(node);
		}
		@Override
		public AddedTreeNode<E>[] getSubNodes() {
			SubNodesMappingBasic<E> value = node.getValue();
			if(value == null) {
				return null;
			}
			List<AssociativeTrieNode<E, SubNodesMappingBasic<E>>> subNodes = value.subNodes;  
			if(subNodes == null || subNodes.size() == 0) {
				return null;
			}
			@SuppressWarnings("unchecked")
			AddedTreeNode<E>[] nodes = (AddedTreeNode<E>[]) new AddedTreeNode[subNodes.size()];
			for(int i = 0; i < nodes.length; i++) {
				nodes[i] = new AddedTreeNode<E>(subNodes.get(i));
			}
			return nodes;
		}
	}
	@Override
	public AddedTreeNode<E> getRoot()  {
		return new AddedTreeNode<E>(wrapped.getRoot());
	}
}
package inet.ipaddr.format.util;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.SubNodesMapping;
import inet.ipaddr.format.util.AddressTrie.TrieNode;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
abstract class AddedTreeBase<E extends Address, N extends SubNodesMapping<E, N>> {
	AssociativeAddressTrie<E, N> wrapped;
	AddedTreeBase(AssociativeAddressTrie<E, N> wrapped) {
		this.wrapped = wrapped;
	}
	static abstract class AddedTreeNodeBase<E extends Address, N extends SubNodesMapping<E, N>> {
		AssociativeTrieNode<E, N> node;
		public AddedTreeNodeBase(AssociativeTrieNode<E, N> node) {
			this.node = node;
		}
		abstract AddedTreeNodeBase<E,N>[] getSubNodes();
		public E getKey() {
			return node.getKey();
		}
		public boolean isAdded() {
			return node.isAdded();
		}
		@Override
		public String toString() {
			return TrieNode.toNodeString(new StringBuilder(50), node.isAdded(), getKey(), null).toString();
		}
		public String toTreeString() {
			return AddressTrie.toAddedNodesTreeString(node);
		}
	}
	public abstract AddedTreeNodeBase<E,N> getRoot();
	@Override
	public String toString() {
		return AddressTrie.toAddedNodesTreeString(wrapped.getRoot());
	}
}
package inet.ipaddr.format.util;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.Objects;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrieOps.AssociativeAddressTriePutOps;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
public abstract class AssociativeAddressTrie<K extends Address, V> extends AddressTrie<K> implements AssociativeAddressTriePutOps<K, V> {
	private static final long serialVersionUID = 1L;
	public static abstract class AssociativeTrieNode<K extends Address, V> extends TrieNode<K> implements Map.Entry<K, V>, AssociativeAddressTrieOps<K, V> {
		private static final long serialVersionUID = 1L;
		private V value;
		protected AssociativeTrieNode(K item) {
			super(item);
		}
		@Override
		public V getValue() {
			return value;
		}
		@Override
		public V setValue(V value) {
			V result = getValue();
			this.value = value;
			return result;
		}
		public void clearValue() {
			this.value = null;
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getUpperSubNode() {
			return (AssociativeTrieNode<K,V>) super.getUpperSubNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getLowerSubNode() {
			return (AssociativeTrieNode<K,V>) super.getLowerSubNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getParent() {
			return (AssociativeTrieNode<K,V>) super.getParent();
		}
		@SuppressWarnings("unchecked")
		@Override
		public V get(K addr) {
			AssociativeTrieNode<K,V> node = (AssociativeTrieNode<K,V>) doLookup(addr).existingNode;
			return node == null ? null : node.getValue();
		}
		@Override
		public int hashCode() {
			if(value == null) {
				return super.hashCode();
			}
			return super.hashCode() ^ value.hashCode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeAddressTrie<K,V> asNewTrie() {
			return (AssociativeAddressTrie<K, V>) super.asNewTrie();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> cloneTree() {
			return (AssociativeTrieNode<K,V>) super.cloneTree();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> clone() {
			return (AssociativeTrieNode<K,V>) super.clone();
		}
		@SuppressWarnings("unchecked")
		@Override
		public boolean equals(Object o) {
			if (o == this) {
				return true;
			} else if(o instanceof AssociativeTrieNode<?,?>) {
				AssociativeTrieNode<K,V> other = ((AssociativeTrieNode<K,V>) o);
				return super.equals(o) && Objects.equals(getValue(), other.getValue());
			}
			return false;
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> nodeIterator(boolean forward) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> allNodeIterator(boolean forward) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends AssociativeTrieNode<K,V>, K, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<? extends AssociativeTrieNode<K,V>, K, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<? extends AssociativeTrieNode<K,V>, K, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<? extends AssociativeTrieNode<K,V>, K, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<? extends AssociativeTrieNode<K,V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<? extends AssociativeTrieNode<K,V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@Override
		public Spliterator<? extends AssociativeTrieNode<K,V>> nodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, true);
		}
		@Override
		public Spliterator<? extends AssociativeTrieNode<K,V>> allNodeSpliterator(boolean forward) {
			return nodeSpliterator(forward, false);
		}
		@Override
		@SuppressWarnings("unchecked")
		Spliterator<? extends AssociativeTrieNode<K,V>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
			return (Spliterator<? extends AssociativeTrieNode<K, V>>) super.nodeSpliterator(forward, addedNodesOnly);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> previousAddedNode() {
			return (AssociativeTrieNode<K,V>) super.previousAddedNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> nextAddedNode() {
			return (AssociativeTrieNode<K,V>) super.nextAddedNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> nextNode() {
			return (AssociativeTrieNode<K,V>) super.nextNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> previousNode() {
			return (AssociativeTrieNode<K,V>) super.previousNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> firstNode() {
			return (AssociativeTrieNode<K,V>) super.firstNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> lastNode() {
			return (AssociativeTrieNode<K,V>) super.lastNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> firstAddedNode() {
			return (AssociativeTrieNode<K,V>) super.firstAddedNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> lastAddedNode() {
			return (AssociativeTrieNode<K,V>) super.lastAddedNode();
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> lowerAddedNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.lowerAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> floorAddedNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.floorAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> higherAddedNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.higherAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> ceilingAddedNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.ceilingAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getAddedNode(K addr) {
			return (AssociativeTrieNode<K,V>) super.getAddedNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> getNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> removeElementsContainedBy(K addr) {
			return (AssociativeTrieNode<K, V>) super.removeElementsContainedBy(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> elementsContainedBy(K addr) {
			return (AssociativeTrieNode<K, V>) super.elementsContainedBy(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> elementsContaining(K addr) {
			return (AssociativeTrieNode<K, V>) super.elementsContaining(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> longestPrefixMatchNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.longestPrefixMatchNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public AssociativeTrieNode<K,V> shortestPrefixMatchNode(K addr) {
			return (AssociativeTrieNode<K, V>) super.shortestPrefixMatchNode(addr);
		}
		@Override
		@SuppressWarnings("unchecked")
		void matchedInserted(OpResult<K> result) {
			super.matchedInserted(result);
			result.existingValue = getValue();
			setValue((V) result.newValue);
		}
		@Override
		@SuppressWarnings("unchecked")
		void added(OpResult<K> result) {
			super.added(result);
			setValue((V) result.newValue);
		}
		@Override
		@SuppressWarnings("unchecked")
		boolean remap(OpResult<K> result, boolean isMatch) {
			Function<? super V, ? extends Object> remapper = (Function<? super V, ? extends Object>) result.remapper;
			Object newValue;
			Change change = changeTracker.getCurrent();
			V existingValue = isMatch ? getValue() : null;
			result.existingValue = existingValue;
			newValue = remapper.apply(existingValue);
			if(newValue == REMAP_ACTION.DO_NOTHING) {
				return false;
			} else if(newValue == REMAP_ACTION.REMOVE_NODE) { 
				if(isMatch) {
					changeTracker.changedSince(change);
					clearValue();
					removeOp(result);
				}
				return false;
			} else if (isMatch) {
				if(newValue != existingValue) {
					changeTracker.changedSince(change);
					result.newValue = newValue;
					return true;
				} 
				return false;
			} else {
				result.newValue = newValue;
				return true;
			}
		}
		@Override
		void removed() {
			super.removed();
			clearValue();
		}
		@SuppressWarnings("unchecked")
		@Override
		protected void replaceThisRoot(BinaryTreeNode<K> replacement) {
			super.replaceThisRoot(replacement);
			if(replacement == null) {
				setValue(null);
			} else {
				setValue(((AssociativeTrieNode<K,V>) replacement).getValue());
			}
		}
		@Override
		public String toString() {
			return toNodeString(new StringBuilder(80), isAdded(), getKey(), getValue()).toString();
		}
	}
	static enum REMAP_ACTION { DO_NOTHING, REMOVE_NODE }
	AddressTrieMap<K,V> map;
	public AssociativeAddressTrie(AssociativeTrieNode<K, V> root) {
		super(root);
	}
	protected AssociativeAddressTrie(AssociativeTrieNode<K, V> root, AddressBounds<K> bounds) {
		super(root, bounds);
	}
	@SuppressWarnings("unchecked")
	@Override
	protected AssociativeTrieNode<K, V> absoluteRoot() {
		return (AssociativeTrieNode<K, V>) super.absoluteRoot();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> getRoot() {
		return (AssociativeTrieNode<K, V>) super.getRoot();
	}
	@SuppressWarnings("unchecked")
	@Override
	public V put(K addr, V value) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		AssociativeTrieNode<K, V> root = absoluteRoot();
		OpResult<K> result = new OpResult<>(addr, Operation.INSERT);
		result.newValue = value;
		root.matchBits(result);
		return (V) result.existingValue;
	}
	@Override
	public boolean putNew(K addr, V value) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		AssociativeTrieNode<K, V> root = absoluteRoot();
		OpResult<K> result = new OpResult<>(addr, Operation.INSERT);
		result.newValue = value;
		root.matchBits(result);
		return !result.exists;
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> addNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.addNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	TrieNode<K> addNode(OpResult<K> result, TrieNode<K> fromNode, TrieNode<K> nodeToAdd, boolean withValues) {
		if(withValues && nodeToAdd instanceof AssociativeTrieNode) {
			AssociativeTrieNode<K, V> node = (AssociativeTrieNode<K, V>) nodeToAdd;
			result.newValue = node.getValue();
		}
		return super.addNode(result, fromNode, nodeToAdd, withValues);
	}
	@Override
	public abstract AssociativeAddedTree<K, V> constructAddedNodesTree();
	protected static class SubNodesMappingAssociative<E extends Address, V> extends SubNodesMapping<E, SubNodesMappingAssociative<E, V>> {
		 V value;
		@Override
		Object getUnderlyingValue() {
			return value;
		}
	}
	protected void contructAssociativeAddedTree(AssociativeAddressTrie<K, SubNodesMappingAssociative<K,V>> emptyTrie) {
		emptyTrie.addTrie(absoluteRoot()); 
		CachingIterator<? extends AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>>, K, 
				AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>>> cachingIterator =
			emptyTrie.containingFirstAllNodeIterator(true);
		Iterator<? extends AssociativeTrieNode<K, V>> thisIterator = containingFirstAllNodeIterator(true);
		while(cachingIterator.hasNext()) {
			AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>> newNext = cachingIterator.next(), parent;
			AssociativeTrieNode<K, V> thisNext = thisIterator.next();
			SubNodesMappingAssociative<K,V> mapping = new SubNodesMappingAssociative<K,V>();
			mapping.value = thisNext.getValue();
			newNext.setValue(mapping);
			cachingIterator.cacheWithLowerSubNode(newNext);
			cachingIterator.cacheWithUpperSubNode(newNext);
			if(newNext.isAdded()) {
				parent = cachingIterator.getCached();
				if(parent != null) {
					while(!parent.isAdded()) {
						AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>> parentParent = parent.getParent();
						if(parentParent == null) {
							break;
						}
						parent = parentParent;
					}
					SubNodesMappingAssociative<K, V> mappedNodes = parent.getValue();
					ArrayList<AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>>> addedSubs = mappedNodes.subNodes;
					if(addedSubs == null) {
						addedSubs = new ArrayList<AssociativeTrieNode<K, SubNodesMappingAssociative<K,V>>>(newNext.size() - 1);
						mappedNodes.subNodes = addedSubs;
					}
					addedSubs.add(newNext);
				} 
			}
		}
		SubNodesMappingAssociative<K, V> value = emptyTrie.getRoot().getValue();
		if(value != null && value.subNodes != null) {
			value.subNodes.trimToSize();
		}
		Iterator<? extends AssociativeTrieNode<K, SubNodesMappingAssociative<K, V>>> iter = emptyTrie.allNodeIterator(true);
		while(iter.hasNext()) {
			SubNodesMappingAssociative<K, V> list = iter.next().getValue();
			if(list != null && list.subNodes != null) {
				list.subNodes.trimToSize();
			}
		}
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> putTrie(AssociativeTrieNode<K, V> trie) {
		return (AssociativeTrieNode<K, V>) addTrie(trie, true);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> putNode(K addr, V value) {
		addr = checkBlockOrAddress(addr, true);
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
		}
		adjustRoot(addr);
		AssociativeTrieNode<K, V> root = absoluteRoot();
		OpResult<K> result = new OpResult<>(addr, Operation.INSERT);
		result.newValue = value;
		root.matchBits(result);
		TrieNode<K> node = result.existingNode;
		if(node == null) {
			node = result.inserted;
		}
		return (AssociativeTrieNode<K, V>) node;
	}
	@Override
	public AssociativeTrieNode<K, V> remap(K addr, Function<? super V, ? extends V> remapper) {
		return remapImpl(addr, existingAddr -> {
			V result = remapper.apply(existingAddr);
			return result == null ? REMAP_ACTION.REMOVE_NODE : result;
		});
	}
	@Override
	public AssociativeTrieNode<K, V> remapIfAbsent(K addr, Supplier<? extends V> remapper, boolean insertNull) {
		return remapImpl(addr, existingVal -> {
			if(existingVal == null) {
				V result = remapper.get();
				if(result != null || insertNull) {
					return result;
				}
			}
			return REMAP_ACTION.DO_NOTHING;
		});
	}
	@SuppressWarnings("unchecked")
	private AssociativeTrieNode<K, V> remapImpl(K addr, Function<? super V, ? extends Object> remapper) {
		addr = checkBlockOrAddress(addr, true);
		AssociativeTrieNode<K, V> subRoot;
		if(bounds != null) {
			if(!bounds.isInBounds(addr)) {
				throwOutOfBounds();
			}
			subRoot = getRoot();
			if(subRoot == null) {
				subRoot = absoluteRoot();
			}
		} else {
			subRoot = absoluteRoot();
		}
		OpResult<K> result = new OpResult<>(addr, Operation.REMAP);
		result.remapper = remapper;
		subRoot.matchBits(result);
		TrieNode<K> node = result.existingNode;
		if(node == null) {
			node = result.inserted;
		}
		return (AssociativeTrieNode<K, V>) node;
	}
	@Override
	public V get(K addr) {
		AssociativeTrieNode<K,V> subRoot;
		if(bounds != null) {
			addr = checkBlockOrAddress(addr, true);
			if(!bounds.isInBounds(addr)) {
				return null;
			}
			subRoot = getRoot();
			if(subRoot == null) {
				return null;
			}
		} else {
			subRoot = absoluteRoot();
		}
		return subRoot.get(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> getAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.getAddedNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K, V> getNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.getNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	AssociativeTrieNode<K, V> smallestElementContainingBounds(K addr) {
		return (AssociativeTrieNode<K, V>) super.smallestElementContainingBounds(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> removeElementsContainedBy(K addr) {
		return (AssociativeTrieNode<K,V>) super.removeElementsContainedBy(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> elementsContainedBy(K addr) {
		return (AssociativeTrieNode<K,V>) super.elementsContainedBy(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> elementsContaining(K addr) {
		return (AssociativeTrieNode<K,V>) super.elementsContaining(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> longestPrefixMatchNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.longestPrefixMatchNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeTrieNode<K,V> shortestPrefixMatchNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.shortestPrefixMatchNode(addr);
	}
	public AddressTrieMap<K,V> asMap() {
		AddressTrieMap<K,V> map = this.map;
		if(map == null) {
			map = new AddressTrieMap<K,V>(this);
		}
		return map;
	}
	@Override
	@SuppressWarnings("unchecked")
	AssociativeAddressTrie<K,V> elementsContainedByToSubTrie(K addr) {
		return (AssociativeAddressTrie<K, V>) super.elementsContainedByToSubTrie(addr);
	}
	@Override
	@SuppressWarnings("unchecked")
	AssociativeAddressTrie<K,V> elementsContainingToTrie(K addr) {
		return (AssociativeAddressTrie<K, V>) super.elementsContainingToTrie(addr);
	}
	@Override
	protected abstract AssociativeAddressTrie<K,V> createNew(AddressBounds<K> bounds);
	@Override
	protected abstract AssociativeAddressTrie<K,V> createSubTrie(AddressBounds<K> bounds);
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> nodeIterator(boolean forward) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> allNodeIterator(boolean forward) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<? extends AssociativeTrieNode<K,V>, K, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<? extends AssociativeTrieNode<K, V>, K, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> containingFirstIterator(boolean lowerSubNodeFirst) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.containingFirstIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<? extends AssociativeTrieNode<K,V>, K, C> containingFirstAllNodeIterator(boolean lowerSubNodeFirst) {
		return (CachingIterator<? extends AssociativeTrieNode<K, V>, K, C>) super.containingFirstAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<? extends AssociativeTrieNode<K,V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<? extends AssociativeTrieNode<K, V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	Spliterator<? extends AssociativeTrieNode<K,V>> nodeSpliterator(boolean forward, boolean addedNodesOnly) {
		return (Spliterator<? extends AssociativeTrieNode<K, V>>) super.nodeSpliterator(forward, addedNodesOnly);
	}
	@Override
	public Spliterator<? extends AssociativeTrieNode<K,V>> nodeSpliterator(boolean forward) {
		return nodeSpliterator(forward, true);
	}
	@Override
	public Spliterator<? extends AssociativeTrieNode<K,V>> allNodeSpliterator(boolean forward) {
		return nodeSpliterator(forward, false);
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K,V> firstNode() {
		return (AssociativeTrieNode<K, V>) super.firstNode();
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K,V> lastNode() {
		return (AssociativeTrieNode<K, V>) super.lastNode();
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K,V> firstAddedNode() {
		return (AssociativeTrieNode<K, V>) super.firstAddedNode();
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K,V> lastAddedNode() {
		return (AssociativeTrieNode<K, V>) super.lastAddedNode();
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K, V> lowerAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.lowerAddedNode(addr);
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K, V> floorAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.floorAddedNode(addr);
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K, V> higherAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.higherAddedNode(addr);
	}
	@Override
	@SuppressWarnings("unchecked")
	public AssociativeTrieNode<K, V> ceilingAddedNode(K addr) {
		return (AssociativeTrieNode<K, V>) super.ceilingAddedNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AssociativeAddressTrie<K, V> clone() {
		AssociativeAddressTrie<K, V> result = (AssociativeAddressTrie<K, V>) super.clone();
		result.map = null;
		return result;
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof AssociativeAddressTrie && super.equals(o);
	}
}
package inet.ipaddr.ipv6;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.format.util.AssociativeAddedTree;
import inet.ipaddr.format.util.AssociativeAddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
import inet.ipaddr.ipv6.IPv6AddressTrie.IPv6TrieNode.IPv6TrieKeyData;
public class IPv6AddressAssociativeTrie<V> extends AssociativeAddressTrie<IPv6Address, V> {
	private static final long serialVersionUID = 1L;
	private static final IPv6Address INIT_ROOT = IPv6AddressTrie.INIT_ROOT;
	public IPv6AddressAssociativeTrie() {
		super(new IPv6AssociativeTrieNode<V>());
	}
	protected IPv6AddressAssociativeTrie(AddressBounds<IPv6Address> bounds) {
		super(new IPv6AssociativeTrieNode<V>(), bounds);
	}
	protected IPv6AddressAssociativeTrie(IPv6AssociativeTrieNode<V> root, AddressBounds<IPv6Address> bounds) {
		super(root, bounds);
	}
	@Override
	public IPv6AssociativeTrieNode<V> getRoot() {
		return (IPv6AssociativeTrieNode<V>) super.getRoot();
	}
	@Override
	protected IPv6AssociativeTrieNode<V> absoluteRoot() {
		return (IPv6AssociativeTrieNode<V>) super.absoluteRoot();
	}
	@Override
	protected IPv6AddressAssociativeTrie<V> createNew(AddressBounds<IPv6Address> bounds) {
		return new IPv6AddressAssociativeTrie<V>(bounds);
	}
	@Override
	protected IPv6AddressAssociativeTrie<V> createSubTrie(AddressBounds<IPv6Address> bounds) {
		return new IPv6AddressAssociativeTrie<V>(absoluteRoot(), bounds);
	}
	public static class IPv6AssociativeTrieNode<V> extends AssociativeTrieNode<IPv6Address, V> {
		private static final long serialVersionUID = 1L;
		protected IPv6AssociativeTrieNode(IPv6Address addr) {
			super(addr);
		}
		public IPv6AssociativeTrieNode() { 
			super(INIT_ROOT);
		}
		@Override
		protected void replaceThisRoot(BinaryTreeNode<IPv6Address> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		@Override
		public IPv6AssociativeTrieNode<V> getUpperSubNode() {
			return (IPv6AssociativeTrieNode<V>) super.getUpperSubNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> getLowerSubNode() {
			return (IPv6AssociativeTrieNode<V>) super.getLowerSubNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> getParent() {
			return (IPv6AssociativeTrieNode<V>) super.getParent();
		}
		@Override
		protected IPv6AssociativeTrieNode<V> createNewImpl(IPv6Address addr) {
			return new IPv6AssociativeTrieNode<V>(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> removeElementsContainedBy(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> elementsContainedBy(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.elementsContainedBy(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> elementsContaining(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.elementsContaining(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> longestPrefixMatchNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> getAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.getAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> getNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> nodeIterator(boolean forward) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> allNodeIterator(boolean forward) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv6AssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv6AssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv6AssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
			return (Spliterator<IPv6AssociativeTrieNode<V>>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv6AssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
			return (Spliterator<IPv6AssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
		}
		@Override
		public IPv6AssociativeTrieNode<V> previousAddedNode() {
			return (IPv6AssociativeTrieNode<V>) super.previousAddedNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> nextAddedNode() {
			return (IPv6AssociativeTrieNode<V>) super.nextAddedNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> nextNode() {
			return (IPv6AssociativeTrieNode<V>) super.nextNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> previousNode() {
			return (IPv6AssociativeTrieNode<V>) super.previousNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> lowerAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.lowerAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> floorAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.floorAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> higherAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.higherAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> ceilingAddedNode(IPv6Address addr) {
			return (IPv6AssociativeTrieNode<V>) super.ceilingAddedNode(addr);
		}
		@Override
		public IPv6AssociativeTrieNode<V> firstNode() {
			return (IPv6AssociativeTrieNode<V>) super.firstNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> lastNode() {
			return (IPv6AssociativeTrieNode<V>) super.lastNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> firstAddedNode() {
			return (IPv6AssociativeTrieNode<V>) super.firstAddedNode();
		}
		@Override
		public IPv6AssociativeTrieNode<V> lastAddedNode() {
			return (IPv6AssociativeTrieNode<V>) super.lastAddedNode();
		}
		@Override
		protected IPv6AddressAssociativeTrie<V> createNewTree() {
			return new IPv6AddressAssociativeTrie<V>();
		}
		@Override
		public IPv6AddressAssociativeTrie<V> asNewTrie() {
			return (IPv6AddressAssociativeTrie<V>) super.asNewTrie();
		}
		@Override
		public IPv6AssociativeTrieNode<V> cloneTree() {
			return (IPv6AssociativeTrieNode<V>) super.cloneTree();
		}
		@Override
		public IPv6AssociativeTrieNode<V> clone() {
			return (IPv6AssociativeTrieNode<V>) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv6AddressAssociativeTrie.IPv6AssociativeTrieNode && super.equals(o);
		}
		@Override
		protected IPv6TrieKeyData getTrieKeyCache(IPv6Address addr) {
			return addr.getTrieKeyCache();
		}
	}
	@Override
	public IPv6AssociativeTrieNode<V> removeElementsContainedBy(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> elementsContainedBy(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.elementsContainedBy(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> elementsContaining(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.elementsContaining(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> longestPrefixMatchNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> getAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.getAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> getNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.getNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> addNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.addNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public IPv6AssociativeTrieNode<V> addTrie(TrieNode<IPv6Address> trie) {
		return (IPv6AssociativeTrieNode<V>) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> nodeIterator(boolean forward) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> allNodeIterator(boolean forward) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<IPv6AssociativeTrieNode<V>, IPv6Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv6AssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv6AssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv6AssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
		return (Spliterator<IPv6AssociativeTrieNode<V>>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv6AssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
		return (Spliterator<IPv6AssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
	}
	@Override
	public IPv6AssociativeTrieNode<V> lowerAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.lowerAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> floorAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.floorAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> higherAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.higherAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> ceilingAddedNode(IPv6Address addr) {
		return (IPv6AssociativeTrieNode<V>) super.ceilingAddedNode(addr);
	}
	@Override
	public IPv6AssociativeTrieNode<V> firstNode() {
		return (IPv6AssociativeTrieNode<V>) super.firstNode();
	}
	@Override
	public IPv6AssociativeTrieNode<V> lastNode() {
		return (IPv6AssociativeTrieNode<V>) super.lastNode();
	}
	@Override
	public IPv6AssociativeTrieNode<V> firstAddedNode() {
		return (IPv6AssociativeTrieNode<V>) super.firstAddedNode();
	}
	@Override
	public IPv6AssociativeTrieNode<V> lastAddedNode() {
		return (IPv6AssociativeTrieNode<V>) super.lastAddedNode();
	}
	@Override
	public IPv6AssociativeTrieNode<V> putNode(IPv6Address addr, V value) {
		return (IPv6AssociativeTrieNode<V>) super.putNode(addr, value);
	}
	@Override
	public IPv6AssociativeTrieNode<V> putTrie(AssociativeTrieNode<IPv6Address, V> trie) {
		return (IPv6AssociativeTrieNode<V>) super.putTrie(trie);
	}
	@Override
	public IPv6AssociativeTrieNode<V> remap(IPv6Address addr, Function<? super V, ? extends V> remapper) {
		return (IPv6AssociativeTrieNode<V>) super.remap(addr, remapper);
	}
	@Override
	public IPv6AssociativeTrieNode<V> remapIfAbsent(IPv6Address addr, Supplier<? extends V> remapper, boolean insertNull) {
		return (IPv6AssociativeTrieNode<V>) super.remapIfAbsent(addr, remapper, insertNull);
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof IPv6AddressAssociativeTrie && super.equals(o);
	}
	@Override
	public IPv6AddressAssociativeTrie<V> clone() {
		return (IPv6AddressAssociativeTrie<V>) super.clone();
	}
	@Override
	public AssociativeAddedTree<IPv6Address, V> constructAddedNodesTree() {
		IPv6AddressAssociativeTrie<SubNodesMappingAssociative<IPv6Address, V>> trie = new IPv6AddressAssociativeTrie<SubNodesMappingAssociative<IPv6Address, V>>();
		contructAssociativeAddedTree(trie);
		return new AssociativeAddedTree<IPv6Address, V>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		IPv6AddressAssociativeTrie<SubNodesMappingAssociative<IPv6Address, V>> trie = new IPv6AddressAssociativeTrie<SubNodesMappingAssociative<IPv6Address, V>>();
		contructAssociativeAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
package inet.ipaddr.format;
import java.io.Serializable;
import java.math.BigInteger;
import inet.ipaddr.Address;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.standard.AddressDivisionGrouping;
import inet.ipaddr.format.string.AddressStringDivisionSeries;
public interface AddressItem extends Comparable<AddressItem>, Serializable {
	@Override
	default int compareTo(AddressItem other) {
		return Address.DEFAULT_ADDRESS_COMPARATOR.compare(this, other);
	}
	default BigInteger getCount() {
		return getUpperValue().subtract(getValue()).add(BigInteger.ONE);
	}
	default BigInteger getPrefixCount(int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(this, prefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= prefixLength) {
			return getCount();
		}
		int shiftAdjustment = bitCount - prefixLength;
		BigInteger lower = getValue(), upper = getUpperValue();
		return upper.shiftRight(shiftAdjustment).subtract(lower.shiftRight(shiftAdjustment)).add(BigInteger.ONE);
	}
	int getBitCount();
	default int getByteCount() {
		return (getBitCount() + (Byte.SIZE - 1)) >>> 3;
	}
	default boolean isMultiple() {
		return !getUpperValue().equals(getValue());
	}
	byte[] getBytes();
	byte[] getBytes(byte bytes[]);
	byte[] getBytes(byte bytes[], int index);
	byte[] getUpperBytes();
	byte[] getUpperBytes(byte bytes[]);
	byte[] getUpperBytes(byte bytes[], int index);
	BigInteger getValue();
	BigInteger getUpperValue();
	boolean isZero();
	boolean includesZero();
	boolean isMax();
	boolean includesMax();
	default boolean isFullRange() {
		return includesZero() && includesMax();
	}
	default boolean containsPrefixBlock(int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return isFullRange();
		}
		BigInteger upper = getUpperValue();
		return AddressDivisionBase.testRange(getValue(), upper, upper, getBitCount(), divisionPrefixLen);
	}
	default boolean containsSinglePrefixBlock(int divisionPrefixLen) {
		if(divisionPrefixLen == 0) {
			return isFullRange();
		}
		BigInteger lower = getValue(), upper = getUpperValue();
		return AddressDivisionBase.testRange(lower, lower, upper, getBitCount(), divisionPrefixLen);
	}
	default int getMinPrefixLengthForBlock() {
		int result = getBitCount();
		BigInteger lower = getValue(), upper = getUpperValue();
		if(!lower.equals(upper)) {
			int longBits = Long.SIZE;
			do {
				long low = lower.longValue();
				int lowerZeros = Long.numberOfTrailingZeros(low);
				if(lowerZeros == 0) {
					break;
				}
				long up = upper.longValue();
				int upperOnes = Long.numberOfTrailingZeros(~up);
				if(upperOnes == 0) {
					break;
				}
				int prefixedBitCount = Math.min(lowerZeros, upperOnes);
				result -= prefixedBitCount;
				if(prefixedBitCount < longBits) {
					break;
				}
				lower = lower.shiftRight(longBits);
				upper = upper.shiftRight(longBits);
			} while(upper.signum() != 0);
		}
		return result;
	}
	default Integer getPrefixLengthForSingleBlock() {
		int divPrefix = getMinPrefixLengthForBlock();
		BigInteger lower = getValue(), upper = getUpperValue();
		int bitCount = getBitCount();
		if(divPrefix == bitCount) {
			if(lower.equals(upper)) {
				return AddressDivisionGroupingBase.cacheBits(divPrefix);
			}
		} else {
			int shift = bitCount - divPrefix;
			if(lower.shiftRight(shift).equals(upper.shiftRight(shift))) {
				return AddressDivisionGroupingBase.cacheBits(divPrefix);
			}
		}
		return null;
	}
	public static BigInteger getBlockSize(int bitCount) {
		return BigInteger.ONE.shiftLeft(bitCount);
	}
	public static Integer getBitsForCount(long count) {
		if(count <= 0) {
			return null;
		}
		int logBase2 = (Long.SIZE - 1) - Long.numberOfLeadingZeros(count);
		if((~(-1L << logBase2) & count) != 0) {
			logBase2++;
		}
		return logBase2;
	}
}
package inet.ipaddr;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.format.AddressDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
public interface AddressSegmentSeries extends AddressDivisionSeries, AddressComponent {
	int getSegmentCount();
	int getBitsPerSegment();
	int getBytesPerSegment();
	int getMaxSegmentValue();
	AddressSection getSection();
	AddressSection getSection(int index);
	AddressSection getSection(int index, int endIndex);
	AddressSegment getSegment(int index);
	String[] getSegmentStrings();
	void getSegments(AddressSegment segs[]);
	void getSegments(int start, int end, AddressSegment segs[], int index);
	AddressSegment[] getSegments();
	@Override
	AddressSegmentSeries getLower();
	@Override
	AddressSegmentSeries getUpper();
	default boolean testBit(int n) {
		return isOneBit(getBitCount() - (n + 1));
	}
	default boolean isOneBit(int prefixBitIndex) {
		int bitsPerSegment = getBitsPerSegment();
		AddressSegment segment = getSegment(prefixBitIndex / bitsPerSegment);
		int segmentBitIndex = prefixBitIndex % bitsPerSegment;
		int value = segment.getSegmentValue();
		return (value & (1 << (bitsPerSegment - (segmentBitIndex + 1)))) != 0;
	}
	@Override
	Iterable<? extends AddressSegmentSeries> getIterable();
	@Override
	Iterator<? extends AddressSegmentSeries> iterator();
	@Override
	AddressComponentSpliterator<? extends AddressSegmentSeries> spliterator();
	@Override
	Stream<? extends AddressSegmentSeries> stream();
	Iterator<? extends AddressSegmentSeries> prefixIterator();
	AddressComponentSpliterator<? extends AddressSegmentSeries> prefixSpliterator();
	Iterator<? extends AddressSegmentSeries> prefixBlockIterator();
	Stream<? extends AddressSegmentSeries> prefixStream();
	AddressComponentSpliterator<? extends AddressSegmentSeries> prefixBlockSpliterator();
	Stream<? extends AddressSegmentSeries> prefixBlockStream();
	Iterator<? extends AddressSegment[]> segmentsIterator();
	AddressComponentRangeSpliterator<? extends AddressSegmentSeries, ? extends AddressSegment[]> segmentsSpliterator();
	Stream<? extends AddressSegment[]> segmentsStream();
	AddressSegmentSeries increment(long increment) throws AddressValueException;
	AddressSegmentSeries incrementBoundary(long increment) throws AddressValueException;
	String toCanonicalString();
	String toCompressedString();
	AddressSegmentSeries reverseSegments();
	@Override
	AddressSegmentSeries reverseBits(boolean perByte);
	@Override
	AddressSegmentSeries reverseBytes();
	AddressSegmentSeries reverseBytesPerSegment();
	AddressSegmentSeries toPrefixBlock();
	@Deprecated
	AddressSegmentSeries removePrefixLength();
	AddressSegmentSeries withoutPrefixLength();
	@Deprecated
	AddressSegmentSeries removePrefixLength(boolean zeroed);
	AddressSegmentSeries adjustPrefixBySegment(boolean nextSegment);
	AddressSegmentSeries adjustPrefixBySegment(boolean nextSegment, boolean zeroed);
	AddressSegmentSeries adjustPrefixLength(int adjustment);
	AddressSegmentSeries adjustPrefixLength(int adjustment, boolean zeroed);
	AddressSegmentSeries setPrefixLength(int prefixLength);
	AddressSegmentSeries setPrefixLength(int prefixLength, boolean zeroed);
	@Deprecated
	AddressSegmentSeries applyPrefixLength(int prefixLength);
}
package inet.ipaddr;
import java.util.Iterator;
import java.util.stream.Stream;
import inet.ipaddr.format.AddressGenericDivision;
import inet.ipaddr.format.util.AddressComponentSpliterator;
public interface AddressSegment extends AddressComponent, AddressGenericDivision {
	int getValueCount();
	int getPrefixValueCount(int segmentPrefixLength);
	int getSegmentValue();
	int getUpperSegmentValue();
	@Override
	AddressSegment getLower();
	@Override
	AddressSegment getUpper();
	@Override
	AddressSegment reverseBits(boolean perByte);
	@Override
	AddressSegment reverseBytes();
	@Override
	Iterable<? extends AddressSegment> getIterable();
	@Override
	Iterator<? extends AddressSegment> iterator();
	@Override
	AddressComponentSpliterator<? extends AddressSegment> spliterator();
	@Override
	Stream<? extends AddressSegment> stream();
	boolean matches(int value);
	boolean matchesWithMask(int value, int mask);
	boolean matchesWithMask(int lowerValue, int upperValue, int mask);
	boolean overlaps(AddressSegment other);
	boolean contains(AddressSegment other);
	@Override
	boolean equals(Object other);
	boolean prefixEquals(AddressSegment other, int prefixLength);
	default boolean testBit(int n) {
		int value = getSegmentValue();
		int bitCount = getBitCount();
		if(n < 0 || n >= bitCount) {
			throw new IndexOutOfBoundsException();
		}
		return (value & (1 << n)) != 0;
	}
	default boolean isOneBit(int segmentBitIndex) {
		int value = getSegmentValue();
		int bitCount = getBitCount();
		if(segmentBitIndex < 0 || segmentBitIndex >= bitCount) {
			throw new IndexOutOfBoundsException();
		}
		return (value & (1 << (bitCount - (segmentBitIndex + 1)))) != 0;
	}
	int getMaxSegmentValue();
}
package inet.ipaddr.ipv4;
import java.math.BigInteger;
import java.net.Inet4Address;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import inet.ipaddr.Address;
import inet.ipaddr.AddressConversionException;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.AddressValueException;
import inet.ipaddr.IPAddress;
import inet.ipaddr.IPAddressConverter;
import inet.ipaddr.IPAddressSection.IPStringBuilderOptions;
import inet.ipaddr.IPAddressSection.SeriesCreator;
import inet.ipaddr.IPAddressSegmentSeries;
import inet.ipaddr.IPAddressStringParameters;
import inet.ipaddr.IncompatibleAddressException;
import inet.ipaddr.PrefixLenException;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentRangeSpliterator;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressPartStringCollection;
import inet.ipaddr.ipv4.IPv4AddressNetwork.IPv4AddressCreator;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4AddressCache;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringBuilderOptions;
import inet.ipaddr.ipv4.IPv4AddressSection.IPv4StringCollection;
import inet.ipaddr.ipv4.IPv4AddressTrie.IPv4TrieNode.IPv4TrieKeyData;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6Address.IPv6AddressConverter;
import inet.ipaddr.ipv6.IPv6AddressNetwork;
import inet.ipaddr.ipv6.IPv6AddressNetwork.IPv6AddressCreator;
import inet.ipaddr.ipv6.IPv6AddressSection;
import inet.ipaddr.ipv6.IPv6AddressSegment;
public class IPv4Address extends IPAddress implements Iterable<IPv4Address> {
	private static final long serialVersionUID = 4L;
	public static final char SEGMENT_SEPARATOR = '.';
	public static final int BITS_PER_SEGMENT = 8;
	public static final int BYTES_PER_SEGMENT = 1;
	public static final int SEGMENT_COUNT = 4;
	public static final int BYTE_COUNT = 4;
	public static final int BIT_COUNT = 32;
	public static final int DEFAULT_TEXTUAL_RADIX = 10;
	public static final int MAX_VALUE_PER_SEGMENT = 0xff;
	public static final int MAX_VALUE = 0xffffffff;
	public static final String REVERSE_DNS_SUFFIX = ".in-addr.arpa";
	transient IPv4AddressCache addressCache;
	private transient IPv4TrieKeyData cachedTrieKeyData;
	public IPv4Address(IPv4AddressSegment[] segments) throws AddressValueException {
		this(segments, null);
	}
	public IPv4Address(IPv4AddressSegment[] segments, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(segments, networkPrefixLength));
		if(getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", getSegmentCount());
		}
	}
	public IPv4Address(IPv4AddressSection section) throws AddressValueException {
		super(section);
		if(section.getSegmentCount() != SEGMENT_COUNT) {
			throw new AddressValueException("ipaddress.error.ipv4.invalid.segment.count", section.getSegmentCount());
		}
	}
	public IPv4Address(int address) {
		this(address, null);
	}
	public IPv4Address(int address, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSectionInternal(address, networkPrefixLength));
	}
	public IPv4Address(Inet4Address inet4Address, Integer networkPrefixLength) {
		this(inet4Address, inet4Address.getAddress(), networkPrefixLength);
	}
	public IPv4Address(Inet4Address inet4Address) {
		this(inet4Address, inet4Address.getAddress(), null);
	}
	private IPv4Address(Inet4Address inet4Address, byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, 0, bytes.length, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
		getSection().setInetAddress(inet4Address);
	}
	public IPv4Address(byte[] bytes) throws AddressValueException {
		this(bytes, null);
	}
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex) throws AddressValueException {
		this(bytes, byteStartIndex, byteEndIndex, null);
	}
	public IPv4Address(byte[] bytes, Integer networkPrefixLength) throws AddressValueException {
		this(bytes, 0, bytes.length, networkPrefixLength);
	}
	public IPv4Address(byte[] bytes, int byteStartIndex, int byteEndIndex, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createSection(bytes, byteStartIndex, byteEndIndex, IPv4Address.SEGMENT_COUNT, networkPrefixLength));
	}
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer networkPrefixLength) throws AddressValueException {
		super(thisAddress -> ((IPv4Address) thisAddress).getAddressCreator().createFullSectionInternal(lowerValueProvider, upperValueProvider, networkPrefixLength));
	}
	public IPv4Address(SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider) {
		this(lowerValueProvider, upperValueProvider, null);
	}
	public IPv4Address(SegmentValueProvider valueProvider, Integer networkPrefixLength) throws AddressValueException {
		this(valueProvider, valueProvider, networkPrefixLength);
	}
	public IPv4Address(SegmentValueProvider valueProvider) {
		this(valueProvider, (Integer) null);
	}
	@Override
	public IPv4AddressSection getSection() {
		return (IPv4AddressSection) super.getSection();
	}
	@Override
	public IPv4AddressSection getSection(int index) {
		return getSection().getSection(index);
	}
	@Override
	public IPv4AddressSection getSection(int index, int endIndex) {
		return getSection().getSection(index, endIndex);
	}
	@Override
	public IPv4AddressSegment getDivision(int index) {
		return getSegment(index);
	}
	@Override
	public IPv4AddressSegment getSegment(int index) {
		return getSection().getSegment(index);
	}
	@Override
	public IPv4AddressSegment[] getSegments() {
		return getSection().getSegments();
	}
	@Override
	public IPAddressStringDivisionSeries[] getParts(IPStringBuilderOptions options) {
		return getParts(IPv4StringBuilderOptions.from(options));
	}
	public IPAddressStringDivisionSeries[] getParts(IPv4StringBuilderOptions options) {
		IPAddressStringDivisionSeries parts[] = getSection().getParts(options);
		IPv6Address ipv6Addr = getConverted(options);
		if(ipv6Addr != null) {
			IPAddressStringDivisionSeries ipv6Parts[] = ipv6Addr.getParts(options.ipv6ConverterOptions);
			IPAddressStringDivisionSeries tmp[] = parts;
			parts = new IPAddressStringDivisionSeries[tmp.length + ipv6Parts.length];
			System.arraycopy(tmp, 0, parts, 0, tmp.length);
			System.arraycopy(ipv6Parts,  0, parts, tmp.length, ipv6Parts.length);
		}
		return parts;
	}
	@Override
	public int getSegmentCount() {
		return SEGMENT_COUNT;
	}
	@Override
	public int getByteCount() {
		return BYTE_COUNT;
	}
	@Override
	public int getBitCount() {
		return BIT_COUNT;
	}
	@Override
	public boolean isIPv4() {
		return true;
	}
	@Override
	public IPv4Address toIPv4() {
		return this;
	}
	@Override
	public boolean isIPv4Convertible() {
		return true;
	}
	public IPv6Address getIPv6Address(IPv6AddressSegment segs[]) {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		return creator.createAddress(IPv6AddressSection.createSection(creator, segs, this)); 
	}
	public IPv6Address getIPv4MappedAddress() {
		IPv6AddressCreator creator = getIPv6Network().getAddressCreator();
		IPv6AddressSegment zero = creator.createSegment(0);
		IPv6AddressSegment segs[] = creator.createSegmentArray(IPv6Address.MIXED_ORIGINAL_SEGMENT_COUNT);
		segs[0] = segs[1] = segs[2] = segs[3] = segs[4] = zero;
		segs[5] = creator.createSegment(IPv6Address.MAX_VALUE_PER_SEGMENT);
		return getIPv6Address(segs);
	}
	@Override
	public boolean isIPv6Convertible() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.isIPv6Convertible(this);
	}
	@Override
	public IPv6Address toIPv6() {
		IPAddressConverter conv = DEFAULT_ADDRESS_CONVERTER;
		return conv.toIPv6(this);
	}
	public IPv4Address toBroadcastAddress() {
		return toMaxHost();
	}
	public IPv4Address toNetworkAddress() {
		return toZeroHost();
	}
	void cache(IPv4Address lower, IPv4Address upper) {
		getSection().cache(this, lower, upper);
	}
	@Override
	public IPv4Address getLowerNonZeroHost() {
		return getSection().getLowestOrHighest(this, true, true);
	}
	@Override
	public IPv4Address getLower() {
		return getSection().getLowestOrHighest(this, true, false);
	}
	@Override
	public IPv4Address getUpper() {
		return getSection().getLowestOrHighest(this, false, false);
	}
	public int intValue() {
		return getSection().intValue();
	}
	public int upperIntValue() {
		return getSection().upperIntValue();
	}
	public long longValue() {
		return getSection().longValue();
	}
	public long upperLongValue() {
		return getSection().upperLongValue();
	}
	IPv4TrieKeyData getTrieKeyCache() {
		IPv4TrieKeyData keyData = cachedTrieKeyData;
		if(keyData == null) {
			keyData = new IPv4TrieKeyData();
			Integer prefLen = getPrefixLength();
			keyData.prefixLength = prefLen;
			keyData.uint32Val = intValue();
			if(prefLen != null) {
				int bits = prefLen;
				keyData.nextBitMask32Val = 0x80000000 >>> bits;
				keyData.mask32Val = getNetwork().getNetworkMask(bits, false).intValue();
			}
			cachedTrieKeyData = keyData;
		}
		return keyData;
	}
	public IPv4Address replace(int startIndex, int endIndex, IPv4Address replacement, int replacementIndex) {
		return checkIdentity(getSection().replace(startIndex, endIndex, replacement.getSection(), replacementIndex, replacementIndex + (endIndex - startIndex)));
	}
	public IPv4Address replace(int startIndex, IPv4AddressSection replacement) {
		int replacementCount = Math.min(IPv4Address.SEGMENT_COUNT - startIndex, replacement.getSegmentCount());
		return checkIdentity(getSection().replace(startIndex, startIndex + replacementCount, replacement, 0, replacementCount));
	}
	@Override
	public IPv4Address reverseBits(boolean perByte) {
		return checkIdentity(getSection().reverseBits(perByte));
	}
	@Override
	public IPv4Address reverseBytes() {
		return checkIdentity(getSection().reverseBytes());
	}
	@Override
	public IPv4Address reverseBytesPerSegment() {
		return this;
	}
	@Override
	public IPv4Address reverseSegments() {
		return checkIdentity(getSection().reverseSegments());
	}
	private IPv4Address checkIdentity(IPv4AddressSection newSection) {
		IPv4AddressSection section = getSection();
		if(newSection == section) {
			return this;
		}
		return getAddressCreator().createAddress(newSection);
	}
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment));
	}
	@Override
	public IPv4Address adjustPrefixBySegment(boolean nextSegment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixBySegment(nextSegment, zeroed));
	}
	@Override
	public IPv4Address adjustPrefixLength(int adjustment) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment));
	}
	@Override
	public IPv4Address adjustPrefixLength(int adjustment, boolean zeroed) {
		return checkIdentity(getSection().adjustPrefixLength(adjustment, zeroed));
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength) {
		return setPrefixLength(prefixLength, true);
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed) {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed));
	}
	@Override
	public IPv4Address setPrefixLength(int prefixLength, boolean zeroed, boolean zeroHostIsBlock) throws PrefixLenException {
		return checkIdentity(getSection().setPrefixLength(prefixLength, zeroed, zeroHostIsBlock));
	}
	@Deprecated
	@Override
	public IPv4Address applyPrefixLength(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().applyPrefixLength(networkPrefixLength));
	}
	@Override @Deprecated
	public IPv4Address removePrefixLength(boolean zeroed) {
		return checkIdentity(getSection().removePrefixLength(zeroed));
	}
	@Override
	public IPv4Address withoutPrefixLength() {
		return removePrefixLength(false);
	}
	@Override
	@Deprecated
	public IPv4Address removePrefixLength() {
		return removePrefixLength(true);
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsNonZeroHostIterator() {
		return getSection().segmentsNonZeroHostIterator();
	}
	@Override
	public Iterator<IPv4AddressSegment[]> segmentsIterator() {
		return getSection().segmentsIterator();
	}
	@Override
	public AddressComponentRangeSpliterator<IPv4Address, IPv4AddressSegment[]> segmentsSpliterator() {
		return getSection().segmentsSpliterator(this, getAddressCreator());
	}
	@Override
	public Stream<IPv4AddressSegment[]> segmentsStream() {
		return StreamSupport.stream(segmentsSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> iterator() {
		return getSection().iterator(this, getAddressCreator(), null);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> spliterator() {
		return getSection().spliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> stream() {
		return StreamSupport.stream(spliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> nonZeroHostIterator() {
		Predicate<IPv4AddressSegment[]> excludeFunc = null;
		if(includesZeroHost()) {
			int prefLength = getNetworkPrefixLength();
			excludeFunc = s -> getSection().isZeroHost(s, prefLength);
		}
		return getSection().iterator(this, getAddressCreator(), excludeFunc);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), true);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), true);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream() {
		return StreamSupport.stream(prefixBlockSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixBlockIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), true, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixBlockSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), true, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixBlockStream(int prefixLength) {
		return StreamSupport.stream(prefixBlockSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator() {
		return getSection().prefixIterator(this, getAddressCreator(), false);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator() {
		return getSection().prefixSpliterator(this, getAddressCreator(), false);
	}
	@Override
	public Stream<IPv4Address> prefixStream() {
		return StreamSupport.stream(prefixSpliterator(), false);
	}
	@Override
	public Iterator<IPv4Address> prefixIterator(int prefixLength) {
		return getSection().prefixIterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> prefixSpliterator(int prefixLength) {
		return getSection().prefixSpliterator(this, getAddressCreator(), false, prefixLength);
	}
	@Override
	public Stream<IPv4Address> prefixStream(int prefixLength) {
		return StreamSupport.stream(prefixSpliterator(prefixLength), false);
	}
	@Override
	public Iterator<IPv4Address> blockIterator(int segmentCount) {
		return getSection().blockIterator(this, getAddressCreator(), segmentCount);
	}
	@Override
	public AddressComponentSpliterator<IPv4Address> blockSpliterator(int segmentCount) {
		return getSection().blockSpliterator(this, getAddressCreator(), segmentCount);
	}
	@Override
	public Stream<IPv4Address> blockStream(int segmentCount) {
		return StreamSupport.stream(blockSpliterator(segmentCount), false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4Address> sequentialBlockIterator() {
		return (Iterator<IPv4Address>) super.sequentialBlockIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressComponentSpliterator<IPv4Address> sequentialBlockSpliterator() {
		return (AddressComponentSpliterator<IPv4Address>) super.sequentialBlockSpliterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Stream<IPv4Address> sequentialBlockStream() {
		return (Stream<IPv4Address>) super.sequentialBlockStream();
	}
	@Override
	public Iterable<IPv4Address> getIterable() {
		return this;
	}
	@Override
	public IPv4Address increment(long increment) {
		return checkIdentity(getSection().increment(increment));
	}
	@Override
	public IPv4Address incrementBoundary(long increment) {
		return checkIdentity(getSection().incrementBoundary(increment));
	}
	public Long enumerateIPv4(IPv4Address other){
		return IPv4AddressSection.enumerateIPv4(getSection(), other.getSection());
	}
	@Override
	public BigInteger enumerate(Address other) {
		if(other instanceof IPv4Address) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	@Override
	public BigInteger enumerate(IPAddress other) {
		if(other.isIPv4()) {
			return IPv4AddressSection.enumerate(getSection(), other.getSection());
		}
		return null;
	}
	IPv4AddressCreator getAddressCreator() {
		return getNetwork().getAddressCreator();
	}
	@Override
	public IPv4AddressNetwork getNetwork() {
		return defaultIpv4Network();
	}
	public IPv6AddressNetwork getIPv6Network() {
		return defaultIpv6Network();
	}
	@Override
	protected IPv4Address convertArg(IPAddress arg) throws AddressConversionException {
		IPv4Address converted = arg.toIPv4();
		if(converted == null) {
			throw new AddressConversionException(this, arg);
		}
		return converted;
	}
	@Override
	public IPv4Address intersect(IPAddress other) throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection section = thisSection.intersect(convertArg(other).getSection());
		if(section == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result = creator.createAddress(section); 
		return result;
	}
	@Override
	public IPv4Address[] subtract(IPAddress other)  throws AddressConversionException {
		IPv4AddressSection thisSection = getSection();
		IPv4AddressSection sections[] = thisSection.subtract(convertArg(other).getSection());
		if(sections == null) {
			return null;
		}
		IPv4AddressCreator creator = getAddressCreator();
		IPv4Address result[] = new IPv4Address[sections.length];
		for(int i = 0; i < result.length; i++) {
			result[i] = creator.createAddress(sections[i]); 
		}
		return result;
	}
	@Override
	public IPv4Address toZeroHost() {
		return toZeroHost(false);
	}
	@Override
	protected IPv4Address toZeroHost(boolean boundariesOnly) {
		if(!isPrefixed()) {
			IPv4AddressNetwork network = getNetwork();
			PrefixConfiguration config = network.getPrefixConfiguration();
			IPv4Address addr = network.getNetworkMask(0, !config.allPrefixedAddressesAreSubnets());
			if(config.zeroHostsAreSubnets()) {
				addr = addr.getLower();
			}
			return addr;
		}
		if(includesZeroHost() && isSingleNetwork()) {
			return getLower();
		}
		return checkIdentity(getSection().createZeroHost(boundariesOnly));
	}
	@Override
	public IPv4Address toZeroHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toZeroHost();
		}
		return checkIdentity(getSection().toZeroHost(prefixLength));
	}
	@Override
	public IPv4Address toZeroNetwork() {
		if(!isPrefixed()) {
			return getNetwork().getHostMask(getBitCount());
		}
		return checkIdentity(getSection().createZeroNetwork());
	}
	@Override
	public IPv4Address toMaxHost() {
		if(!isPrefixed()) {
			IPv4Address resultNoPrefix = getNetwork().getHostMask(0);
			if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
				return resultNoPrefix;
			}
			return resultNoPrefix.setPrefixLength(0);
		}
		if(includesMaxHost() && isSingleNetwork()) {
			return getUpper();
		}
		return checkIdentity(getSection().createMaxHost());
	}
	@Override
	public IPv4Address toMaxHost(int prefixLength) {
		if(isPrefixed() && prefixLength == getNetworkPrefixLength()) {
			return toMaxHost();
		}
		return checkIdentity(getSection().toMaxHost(prefixLength));
	}
	@Override
	public IPv4Address mask(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().mask(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv4Address mask(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return mask(mask, false);
	}
	@Override
	public IPv4Address maskNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().maskNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address bitwiseOr(IPAddress mask, boolean retainPrefix) throws IncompatibleAddressException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOr(convertArg(mask).getSection(), retainPrefix));
	}
	@Override
	public IPv4Address bitwiseOr(IPAddress mask) throws IncompatibleAddressException, AddressConversionException {
		return bitwiseOr(mask, false);
	}
	@Override
	public IPv4Address bitwiseOrNetwork(IPAddress mask, int networkPrefixLength) throws IncompatibleAddressException, PrefixLenException, AddressConversionException {
		return checkIdentity(getSection().bitwiseOrNetwork(convertArg(mask).getSection(), networkPrefixLength));
	}
	@Override
	public IPv4Address getHostMask() {
		return (IPv4Address) super.getHostMask();
	}
	@Override
	public IPv4Address getNetworkMask() {
		return (IPv4Address) super.getNetworkMask();
	}
	@Override
	public IPv4AddressSection getNetworkSection() {
		return getSection().getNetworkSection();
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength);
	}
	@Override
	public IPv4AddressSection getNetworkSection(int networkPrefixLength, boolean withPrefixLength) throws PrefixLenException {
		return getSection().getNetworkSection(networkPrefixLength, withPrefixLength);
	}
	@Override
	public IPv4AddressSection getHostSection() {
		return getSection().getHostSection();
	}
	@Override
	public IPv4AddressSection getHostSection(int networkPrefixLength) throws PrefixLenException {
		return getSection().getHostSection(networkPrefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock() {
		Integer prefixLength = getNetworkPrefixLength();
		if(prefixLength == null || getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			return this;
		}
		return toPrefixBlock(prefixLength);
	}
	@Override
	public IPv4Address toPrefixBlock(int networkPrefixLength) throws PrefixLenException {
		return checkIdentity(getSection().toPrefixBlock(networkPrefixLength));
	}
	@Override
	public IPv4Address assignPrefixForSingleBlock() {
		return (IPv4Address) super.assignPrefixForSingleBlock();
	}
	@Override
	public IPv4Address assignMinPrefixForBlock() {
		return (IPv4Address) super.assignMinPrefixForBlock();
	}
	@Override
	public IPv4Address coverWithPrefixBlock() {
		return (IPv4Address) IPv4AddressSection.coverWithPrefixBlock(this, getLower(), getUpper());
	}
	@Override
	public IPv4Address coverWithPrefixBlock(IPAddress other) throws AddressConversionException {
		return IPv4AddressSection.coverWithPrefixBlock(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper, 
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare);
	}
	@Override
	public IPv4Address[] spanWithPrefixBlocks() {
		if(isSequential()) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
			return spanWithPrefixBlocks(this);
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(true);
		return list.toArray(new IPv4Address[list.size()]);
	}
	@Override
	public IPv4Address[] spanWithPrefixBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningPrefixBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::assignPrefixForSingleBlock,
				IPv4Address::withoutPrefixLength,
				getAddressCreator()::createAddressArray);
	}
	@Override
	public IPv4Address[] spanWithSequentialBlocks() throws AddressConversionException {
		if(isSequential()) {
			return new IPv4Address[] { withoutPrefixLength() };
		}
		@SuppressWarnings("unchecked")
		ArrayList<IPv4Address> list = (ArrayList<IPv4Address>) spanWithBlocks(false);
		return list.toArray(new IPv4Address[list.size()]);
	}
	@Override
	public IPv4Address[] spanWithSequentialBlocks(IPAddress other) throws AddressConversionException {
		return IPAddress.getSpanningSequentialBlocks(
				this,
				convertArg(other),
				IPv4Address::getLower,
				IPv4Address::getUpper,
				Address.ADDRESS_LOW_VALUE_COMPARATOR::compare,
				IPv4Address::withoutPrefixLength,
				getAddressCreator());
	}
	@Override
	public IPv4AddressSeqRange spanWithRange(IPAddress other) throws AddressConversionException {
		return toSequentialRange(other);
	}
	@Override
	public IPv4Address[] mergeToPrefixBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSinglePrefixBlock()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedPrefixBlocks(converted);
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	private IPAddress[] getConverted(IPAddress... addresses) {
		IPAddress converted[] = new IPAddress[addresses.length + 1];
		for(int i = 0, j = 1; i < addresses.length; i = j++) {
			converted[j] = convertArg(addresses[i]);
		}
		converted[0] = this;
		return converted;
	}
	@Override
	public IPv4Address[] mergeToSequentialBlocks(IPAddress ...addresses) throws AddressConversionException {
		if(addresses.length == 0) {
			if(isSequential()) {
				return new IPv4Address[] {this};
			}
		}
		IPAddress[] converted = getConverted(addresses);
		List<IPAddressSegmentSeries> blocks = getMergedSequentialBlocks(converted, getAddressCreator());
		return blocks.toArray(new IPv4Address[blocks.size()]);
	}
	@Override
	protected SeriesCreator getSequentialSeriesCreator() {
		return getAddressCreator()::createSequentialBlockAddress;
	}
	@Override
	public Inet4Address toUpperInetAddress() {
		return (Inet4Address) super.toUpperInetAddress();
	}
	@Override
	public Inet4Address toInetAddress() {
		return (Inet4Address) super.toInetAddress();
	}
	@Override
	@Deprecated
	public IPv4AddressSeqRange toSequentialRange(IPAddress other) {
		return new IPv4AddressSeqRange(this, convertArg(other));
	}
	@Override
	public IPv4AddressSeqRange toSequentialRange() {
		IPv4Address thiz = withoutPrefixLength();
		return new IPv4AddressSeqRange(thiz.getLower(), thiz.getUpper(), true);
	}
	@Override
	public boolean isLocal() {
		if(isMulticast()) {
			IPv4AddressSegment seg0 = getSegment(0);
			if(seg0.matches(239)) {
				return true;
			}
			IPv4AddressSegment seg1 = getSegment(1), seg2 = getSegment(2);
			return 
					(seg0.matches(224) && seg1.isZero() && seg2.isZero())
					|| (seg0.matches(232) && !(seg1.isZero() && seg2.isZero()));
		}
		return isLinkLocal() || isPrivate() || isAnyLocal();
	}
	@Override
	public boolean isLinkLocal() {
		if(isMulticast()) {
			return getSegment(0).matches(224) && getSegment(1).isZero() && getSegment(2).isZero() &&  getSegment(3).matches(252);
		}
		return getSegment(0).matches(169) && getSegment(1).matches(254);
	}
	public boolean isPrivate() {
		IPv4AddressSegment seg0 = getSegment(0);
		IPv4AddressSegment seg1 = getSegment(1);
		return seg0.matches(10)
			|| (seg0.matches(172) && seg1.matchesWithPrefixMask(16, 4))
			|| (seg0.matches(192) && seg1.matches(168));
	}
	@Override
	public boolean isMulticast() {
		return getSegment(0).matchesWithPrefixMask(0xe0, 4);
	}
	@Override
	public boolean isLoopback() {
		return getSegment(0).matches(127);
	}
	public interface IPv4AddressConverter {
		IPv4Address toIPv4(IPAddress address);
	}
	@Override
	protected IPAddressStringParameters createFromStringParams() {
		return new IPAddressStringParameters.Builder().
				getIPv4AddressParametersBuilder().setNetwork(getNetwork()).getParentBuilder().
				getIPv6AddressParametersBuilder().setNetwork(getIPv6Network()).getParentBuilder().toParams();
	}
	public static String toNormalizedString(IPv4AddressNetwork network, SegmentValueProvider lowerValueProvider, SegmentValueProvider upperValueProvider, Integer prefixLength) {
		return toNormalizedString(network.getPrefixConfiguration(), lowerValueProvider, upperValueProvider, prefixLength, SEGMENT_COUNT, BYTES_PER_SEGMENT, BITS_PER_SEGMENT, MAX_VALUE_PER_SEGMENT, SEGMENT_SEPARATOR, DEFAULT_TEXTUAL_RADIX, null);
	}
	public static enum inet_aton_radix {
		OCTAL, HEX, DECIMAL;
		int getRadix() {
			if(this == OCTAL) {
				return 8;
			} else if(this == HEX) {
				return 16;
			}
			return 10;
		}
		String getSegmentStrPrefix() {
			if(this == OCTAL) {
				return "0";
			} else if(this == HEX) {
				return "0x";
			}
			return null;
		}
		@Override
		public String toString() {
			if(this == OCTAL) {
				return "octal";
			} else if(this == HEX) {
				return "hexadecimal";
			}
			return "decimal";
		}
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix) {
		return getSection().toInetAtonString(radix);
	}
	public String toInetAtonString(IPv4Address.inet_aton_radix radix, int joinedCount) throws IncompatibleAddressException {
		return getSection().toInetAtonString(radix, joinedCount);
	}
	@Override
	public String toSegmentedBinaryString() {
		return getSection().toSegmentedBinaryString();
	}
	@Override
	public String toUNCHostName() {
		return super.toCanonicalString();
	}
	@Override
	public IPAddressPartStringCollection toStandardStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.STANDARD_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toAllStringCollection() {
		return toStringCollection(IPv4StringBuilderOptions.ALL_OPTS);
	}
	@Override
	public IPAddressPartStringCollection toStringCollection(IPStringBuilderOptions opts) {
		return toStringCollection(IPv4StringBuilderOptions.from(opts));
	}
	private IPv6Address getConverted(IPv4StringBuilderOptions opts) {
		if(opts.includes(IPv4StringBuilderOptions.IPV6_CONVERSIONS)) {
			IPv6AddressConverter converter = opts.converter;
			return converter.toIPv6(this);
		}
		return null;
	}
	public IPAddressPartStringCollection toStringCollection(IPv4StringBuilderOptions opts) {
		IPv4StringCollection coll = new IPv4StringCollection();
		IPAddressPartStringCollection sectionColl = getSection().toStringCollection(opts);
		coll.addAll(sectionColl);
		IPv6Address ipv6Addr = getConverted(opts);
		if(ipv6Addr != null) {
			IPAddressPartStringCollection ipv6StringCollection = ipv6Addr.toStringCollection(opts.ipv6ConverterOptions);
			coll.addAll(ipv6StringCollection);
		}
		return coll;
	}
}
package inet.ipaddr.format.util;
import java.util.List;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.format.util.AssociativeAddressTrie.SubNodesMappingAssociative;
public class AssociativeAddedTree<E extends Address, V> extends AddedTreeBase<E, SubNodesMappingAssociative<E,V>> {
	public AssociativeAddedTree(AssociativeAddressTrie<E, SubNodesMappingAssociative<E,V>> wrapped) {
		super(wrapped);
	}
	public static class AssociativeAddedTreeNode<E extends Address, V> extends AddedTreeNodeBase<E,SubNodesMappingAssociative<E,V>> {
		public AssociativeAddedTreeNode(AssociativeTrieNode<E, SubNodesMappingAssociative<E, V>> node) {
			super(node);
		}
		@Override
		public AssociativeAddedTreeNode<E,V>[] getSubNodes() {
			SubNodesMappingAssociative<E, V> value = node.getValue();
			if(value == null) {
				return null;
			}
			List<AssociativeTrieNode<E, SubNodesMappingAssociative<E, V>>> subNodes = value.subNodes;  
			if(subNodes == null || subNodes.size() == 0) {
				return null;
			}
			@SuppressWarnings("unchecked")
			AssociativeAddedTreeNode<E,V>[] nodes = (AssociativeAddedTreeNode<E,V>[]) new AssociativeAddedTreeNode[subNodes.size()];
			for(int i = 0; i < nodes.length; i++) {
				nodes[i] = new AssociativeAddedTreeNode<E,V>(subNodes.get(i));
			}
			return nodes;
		}
	}
	@Override
	public AssociativeAddedTreeNode<E,V> getRoot()  {
		return new AssociativeAddedTreeNode<E, V>(wrapped.getRoot());
	}
}
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.AbstractMap;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Objects;
import java.util.Queue;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.AddressBounds;
import inet.ipaddr.format.util.AddressTrieSet.Range;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
public class AddressTrieMap<K extends Address, V> extends AbstractMap<K, V> implements NavigableMap<K, V>, Cloneable, Serializable {
	private static final long serialVersionUID = 1L;
	private AssociativeAddressTrie<K, V> trie; 
	private final boolean isReverse;
	private final Range<K> bounds;
	private EntrySet<K,V> entrySet; 
	private AddressTrieSet<K> keySet; 
	private AddressTrieMap<K, V> descending; 
	public AddressTrieMap(AssociativeAddressTrie<K, V> trie) {
		this.trie = trie;
		this.isReverse = false;
		this.bounds = null;
		if(trie.map == null) {
			trie.map = this;
		}
	}
	public AddressTrieMap(AssociativeAddressTrie<K, V> trie, Map<? extends K, ? extends V> map) {
		this.trie = trie;
		this.isReverse = false;
		this.bounds = null;
		if(trie.map == null) {
			trie.map = this;
		}
		putAll(map);
	}
	AddressTrieMap(AssociativeAddressTrie<K, V> trie, Range<K> bounds, boolean isReverse) {
		this.trie = trie;
		this.bounds = bounds;
		this.isReverse = isReverse;
		if(trie.map == null && !isReverse && bounds == null) {
			trie.map = this;
		}
	}
	boolean isBounded() {
		return bounds != null;
	}
	@Override
	public AddressTrieMap<K, V> descendingMap() {
		AddressTrieMap<K, V> desc = descending;
		if(desc == null) {
			Range<K> reverseBounds = isBounded() ?  bounds.reverse() : null;
			desc = new AddressTrieMap<K, V>(trie, reverseBounds, !isReverse);
			descending = desc;
			desc.descending = this;
		}
		return desc;
	}
	@Override
	public AddressTrieSet<K> descendingKeySet() {
		return descendingMap().keySet();
	}
	public AssociativeAddressTrie<K, V> asTrie() {
		if(isBounded()) {
			return trie.clone();
		}
		if(!isReverse) {
			trie.map = this;
		}
		return trie;
	}
	public boolean hasRestrictedRange() {
		return isBounded();
	}
	public Range<K> getRange() {
		return bounds;
	}
	public static class EntrySet<K extends Address, V> extends AbstractSet<Entry<K,V>> implements Serializable {
		private static final long serialVersionUID = 1L;
		AssociativeAddressTrie<K, V> trie;
		private final boolean isReverse;
		EntrySet(AssociativeAddressTrie<K, V> trie, boolean isReverse) {
			this.trie = trie;
			this.isReverse = isReverse;
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<Entry<K,V>> iterator() {
			Iterator<? extends Entry<K, V>> result = trie.nodeIterator(!isReverse);
			return (Iterator<Entry<K, V>>) result;
		}
		@SuppressWarnings("unchecked")
		public Iterator<Entry<K,V>> containingFirstIterator() {
			Iterator<? extends Entry<K, V>> it = trie.containingFirstIterator(!isReverse);
			return (Iterator<Entry<K, V>>) it;
		}
		@SuppressWarnings("unchecked")
		public Iterator<Entry<K,V>> containedFirstIterator() {
			Iterator<? extends Entry<K, V>> it = trie.containedFirstIterator(!isReverse);
			return (Iterator<Entry<K, V>>) it;
		}
		@SuppressWarnings("unchecked")
		public Iterator<Entry<K,V>> blockSizeIterator() {
			Iterator<? extends Entry<K, V>> iterator = trie.blockSizeNodeIterator(!isReverse);
			return (Iterator<Entry<K, V>>) iterator;
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<Entry<K,V>> spliterator() {
			Spliterator<? extends Entry<K, V>> result = trie.nodeSpliterator(!isReverse);
			return (Spliterator<Entry<K, V>>) result;
		}
		@Override
		public int size() {
			return trie.size();
		}
		@Override
		public boolean isEmpty() {
			return trie.isEmpty();
	    }
		@SuppressWarnings("unchecked")
		@Override
		public boolean contains(Object o) {
			if (!(o instanceof Entry)) {
				return false;
			}
			Entry<K,?> entry = (Entry<K,?>) o;
			Entry<K,V> existingNode = trie.getAddedNode(entry.getKey());
			return existingNode != null && Objects.equals(existingNode.getValue(), entry.getValue());
		}
		@SuppressWarnings("unchecked")
		@Override
		public boolean remove(Object o) {
			if (!(o instanceof Entry)) {
				return false;
			}
			Entry<K,?> entry = (Entry<K,?>) o; 
			AssociativeTrieNode<K, V> existingNode = trie.getAddedNode(entry.getKey());
			if(existingNode != null && Objects.equals(existingNode.getValue(), entry.getValue())) {
				existingNode.remove();
				return true;
			}
			return false;
		}
		@Override
		public void clear() {
			trie.clear();
		}
		@Override
		public int hashCode() {
			return trie.hashCode();
		}
		@Override
		public boolean equals(Object o) {
			if(o instanceof AddressTrieMap.EntrySet) {
				EntrySet<?,?> other = (EntrySet<?,?>) o;
				return trie.equals(other.trie);
			} 
			return super.equals(o);
		}
		@Override
		public boolean removeAll(Collection<?> collection) {
			if(collection instanceof List || collection instanceof Queue || collection.size() < size()) {
				boolean result = false;
				for (Object object : collection) {
					if(remove(object)) {
						result = true;
					}
				}
				return result;
			}
			return removeIf(collection::contains);
	    }
	}
	@Override
	public AddressTrieSet<K> keySet() {
		AddressTrieSet<K> set = keySet;
		if(set == null) {
			set = new AddressTrieSet<K>(trie, bounds, isReverse);
			keySet = set;
		}
		return set;
	}
	@Override
	public AddressTrieSet<K> navigableKeySet() {
		return keySet();
	}
	@Override
	public EntrySet<K,V> entrySet() {
		EntrySet<K,V> set = entrySet;
		if(set == null) {
			set = new EntrySet<K,V>(trie, isReverse);
			entrySet = set;
		}
		return set;
	}
	@Override
	public V merge(K key, V suppliedValue,
            BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
		if(suppliedValue == null) {
			throw new NullPointerException();
		}
		AssociativeTrieNode<K, V> node = trie.remap(key, existingValue -> {
			V newValue =  (existingValue == null) ? suppliedValue : remappingFunction.apply(existingValue, suppliedValue);
			return newValue;
		});
		if(node != null) {
			return node.getValue();
		}
		return null;
	}
	@Override
	public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
		AssociativeTrieNode<K, V> node = trie.remap(key, existingValue -> {
			V newValue = remappingFunction.apply(key, existingValue);
			return newValue;
		});
		if(node != null) {
			return node.getValue();
		}
		return null;
	}
	@Override
	public V computeIfAbsent(K key, Function<? super K, ? extends V> remappingFunction) {
		AssociativeTrieNode<K, V> node = trie.remapIfAbsent(key, () -> remappingFunction.apply(key), false);
		if(node != null) {
			return node.getValue();
		}
		return null;
	}
	@Override
	public V putIfAbsent(K key, V value) {
		return trie.remapIfAbsent(key, () -> value, true).getValue();
	}
	@Override
	public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
		AssociativeTrieNode<K,V> node = getNode(key);
		if(node != null) {
			V prevValue = node.getValue();
			if(prevValue != null) {
				 V newValue = remappingFunction.apply(key, prevValue);
				 if (newValue != null) {
	                node.setValue(newValue);
	            } else {
	            	node.remove();
	            }
				return newValue;
			}
		}
		return null;
	}
	@SuppressWarnings("unchecked")
	@Override
	public boolean containsKey(Object key) {
		return trie.contains((K) key);
	}
	@Override
	public boolean containsValue(Object value) {
		Iterator<? extends AssociativeTrieNode<K, V>> iterator = trie.nodeIterator(true);
		while (iterator.hasNext()) {
			AssociativeTrieNode<K, V> node = iterator.next();
			if (value.equals(node.getValue())) {
				return true;
			}
		}
		return false;
	}
	@SuppressWarnings("unchecked")
	@Override
	public V get(Object key) {
		return trie.get((K) key);
	}
	@Override
	public V put(K key, V value) {
		return trie.put(key, value);
	}
	@SuppressWarnings("unchecked")
	@Override
	public V remove(Object key) {
		AssociativeTrieNode<K,V> node = getNode((K) key);
		if(node != null) {
			V result = node.getValue();
			node.remove();
			return result;
		}
		return null;
	}
	private AssociativeTrieNode<K,V> getNode(K key) {
		return (AssociativeTrieNode<K, V>) trie.getAddedNode(key);
	}
	@SuppressWarnings("unchecked")
	@Override
	public V getOrDefault(Object key, V defaultValue) {
		AssociativeTrieNode<K,V> node = getNode((K) key);
		return node == null ? defaultValue : node.getValue();
	}
	@Override
	public void forEach(BiConsumer<? super K, ? super V> action) {
		Iterator<? extends AssociativeTrieNode<K,V>> iterator = trie.nodeIterator(!isReverse);
		if(iterator.hasNext()) {
			AssociativeTrieNode<K,V> next = iterator.next();
			action.accept(next.getKey(), next.getValue());
			while(iterator.hasNext()) {
				next = iterator.next();
				action.accept(next.getKey(), next.getValue());
			}
		} else if(action == null) {
			throw new NullPointerException();
		}
	}
	@Override
	public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
		Iterator<? extends AssociativeTrieNode<K,V>> iterator = trie.nodeIterator(!isReverse);
		if(iterator.hasNext()) {
			AssociativeTrieNode<K,V> next = iterator.next();
			next.setValue(function.apply(next.getKey(), next.getValue()));
			while(iterator.hasNext()) {
				next = iterator.next();
				next.setValue(function.apply(next.getKey(), next.getValue()));
			}
		} else if(function == null) {
			throw new NullPointerException();
		}
	}
	@SuppressWarnings("unchecked")
	@Override
	public boolean remove(Object key, Object value) {
		AssociativeTrieNode<K,V> node = getNode((K) key);
		if(node != null) {
			V prevValue = node.getValue();
			if(Objects.equals(value, prevValue)) {
				node.remove();
				return true;
			}
		}
		return false;
	}
	@Override
	public boolean replace(K key, V oldValue, V newValue) {
		AssociativeTrieNode<K,V> node = getNode(key);
		if(node != null) {
			V prevValue = node.getValue();
			if(Objects.equals(oldValue, prevValue)) {
				node.setValue(newValue);
				return true;
			}
		}
		return false;
	}
	@Override
	public V replace(K key, V value) {
		AssociativeTrieNode<K,V> node = getNode(key);
		if(node != null) {
			V prevValue = node.getValue();
			node.setValue(value);
			return prevValue;
		}
		return null;
	}
	@Override
	public int size() {
		return trie.size();
	}
	@Override
	public boolean isEmpty() {
		return trie.isEmpty();
    }
	@Override
	public void clear() {
    	trie.clear();
	}
	@Override
	public int hashCode() {
		return trie.hashCode();
	}
	private AddressTrieMap<K,V> toSubMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
		if(isReverse) {
			K tmp = fromKey;
			boolean tmpInc = fromInclusive;
			fromKey = toKey;
			fromInclusive = toInclusive;
			toKey = tmp;
			toInclusive = tmpInc;
		}
		AddressBounds<K> bounds = trie.bounds, newBounds;
		if(bounds == null) {
			newBounds = AddressBounds.createNewBounds(fromKey, fromInclusive, toKey, toInclusive, trie.getComparator());
		} else {
			newBounds = bounds.restrict(fromKey, fromInclusive, toKey, toInclusive);
		}
		if(newBounds == null) {
			return this;
		}
		Range<K> newRange = new Range<K>(newBounds, isReverse);
		return new AddressTrieMap<K,V>(trie.createSubTrie(newBounds), newRange, isReverse);
	}
	@Override
	public AddressTrieMap<K,V> subMap(K fromKey, K toKey) {
		return subMap(fromKey, true, toKey, false);
	}
	@Override
	public AddressTrieMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) {
		if(fromKey == null || toKey == null) {
			throw new NullPointerException();
		}
		return toSubMap(fromKey, fromInclusive, toKey, toInclusive);
	}
	@Override
	public AddressTrieMap<K,V> headMap(K toKey) {
		return headMap(toKey, false);
	}
	@Override
	public AddressTrieMap<K, V> headMap(K toKey, boolean inclusive) {
		if(toKey == null) {
			throw new NullPointerException();
		}
		return toSubMap(null, true, toKey, inclusive);
	}
	@Override
	public AddressTrieMap<K,V> tailMap(K fromKey) {
		return tailMap(fromKey, true);
	}
	@Override
	public AddressTrieMap<K, V> tailMap(K fromKey, boolean inclusive) {
		if(fromKey == null) {
			throw new NullPointerException();
		}
		return toSubMap(fromKey, inclusive, null, false);
	}
	@Override
	public Entry<K, V> firstEntry() {
		return isReverse ? trie.lastAddedNode() : trie.firstAddedNode();
	}
	@Override
	public K firstKey() {
		return keySet().first();
	}
	@Override
	public Entry<K, V> lastEntry() {
		return isReverse ? trie.firstAddedNode() : trie.lastAddedNode();
	}
	@Override
	public K lastKey() {
		return keySet().last();
	}
	@Override
	public Entry<K, V> lowerEntry(K key) {
		return isReverse ? trie.higherAddedNode(key) : trie.lowerAddedNode(key);
	}
	@Override
	public K lowerKey(K key) {
		return keySet().lower(key);
	}
	@Override
	public Entry<K, V> floorEntry(K key) {
		return isReverse ? trie.ceilingAddedNode(key) : trie.floorAddedNode(key);
	}
	@Override
	public K floorKey(K key) {
		return keySet().floor(key);
	}
	@Override
	public Entry<K, V> ceilingEntry(K key) {
		return isReverse ? trie.floorAddedNode(key) : trie.ceilingAddedNode(key);
	}
	@Override
	public K ceilingKey(K key) {
		return keySet().ceiling(key);
	}
	@Override
	public Entry<K, V> higherEntry(K key) {
		return isReverse ? trie.lowerAddedNode(key) : trie.higherAddedNode(key);
	}
	@Override
	public K higherKey(K key) {
		return keySet().higher(key);
	}
	@Override
	public Entry<K, V> pollFirstEntry() {
		AssociativeTrieNode<K,V> first = isReverse ? trie.lastAddedNode() : trie.firstAddedNode();
    	if(first == null) {
    		return null;
    	}
    	first.remove();
    	return first;
	}
	@Override
	public Entry<K, V> pollLastEntry() {
		AssociativeTrieNode<K,V> last = isReverse ? trie.firstAddedNode() : trie.lastAddedNode();
    	if(last == null) {
    		return null;
    	}
    	last.remove();
    	return last;
	}
	@Override
	public boolean equals(Object o) {
		if(o instanceof AddressTrieMap<?,?>) {
			AddressTrieMap<?,?> other = (AddressTrieMap<?,?>) o;
			return trie.equals(other.trie);
		} 
		return super.equals(o);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressTrieMap<K,V> clone() {
		try {
			AddressTrieMap<K,V> clone = (AddressTrieMap<K,V>) super.clone();
			clone.trie = trie.clone();
			clone.trie.bounds = trie.bounds; 
			clone.keySet = null;
			clone.entrySet = null;
			clone.descending = null;
			return clone;
		} catch (CloneNotSupportedException cannotHappen) {
			return null;
		}
	}
	@Override
	public Comparator<K> comparator() {
		return isReverse ? AddressTrie.reverseComparator() : AddressTrie.comparator();
	}
	public String toTrieString() {
		return trie.toString();
	}
	public AddressTrieMap<K,V> subMapFromKeysContainedBy(K addr) {
		AssociativeAddressTrie<K,V> newTrie = trie.elementsContainedByToSubTrie(addr);
		if(trie == newTrie) {
			return this;
		}
		if(newTrie.bounds == null) {
			return new AddressTrieMap<K,V>(newTrie, null, isReverse);
		}
		Range<K> newRange = new Range<K>(newTrie.bounds, isReverse);
		return new AddressTrieMap<K,V>(newTrie, newRange, isReverse);
	}
	public AddressTrieMap<K,V> subMapFromKeysContaining(K addr) {
		AssociativeAddressTrie<K,V> newTrie = trie.elementsContainingToTrie(addr);
		if(trie == newTrie) {
			return this;
		}
		if(newTrie.bounds == null) {
			return new AddressTrieMap<K,V>(newTrie, null, isReverse);
		}
		Range<K> newRange = new Range<K>(newTrie.bounds, isReverse);
		return new AddressTrieMap<K,V>(newTrie, newRange, isReverse);
	}
	public boolean keyContains(K addr) {
		return trie.elementContainsBounds(addr);
	}
	public Entry<K,V> longestPrefixMatchEntry(K addr) {
		return trie.smallestElementContainingBounds(addr);
	}
}
package inet.ipaddr;
import java.math.BigInteger;
import java.util.Iterator;
import java.util.function.Supplier;
import java.util.stream.Stream;
import inet.ipaddr.AddressNetwork.AddressSegmentCreator;
import inet.ipaddr.IPAddress.IPVersion;
import inet.ipaddr.IPAddressNetwork.IPAddressCreator;
import inet.ipaddr.IPAddressSection.IPStringCache;
import inet.ipaddr.IPAddressSection.IPStringOptions;
import inet.ipaddr.format.standard.AddressDivision;
import inet.ipaddr.format.standard.IPAddressDivision;
import inet.ipaddr.format.string.IPAddressStringDivisionSeries;
import inet.ipaddr.format.util.AddressComponentSpliterator;
import inet.ipaddr.format.util.IPAddressStringWriter;
import inet.ipaddr.format.validate.ParsedIPAddress.BitwiseOrer;
import inet.ipaddr.format.validate.ParsedIPAddress.Masker;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public abstract class IPAddressSegment extends IPAddressDivision implements AddressSegment {
	private static final long serialVersionUID = 4L;
	private final int value; 
	private final int upperValue; 
	protected IPAddressSegment(int value) {
		if(value < 0) {
			throw new AddressValueException(value);
		}
		this.value = this.upperValue = value;
	}
	protected IPAddressSegment(int value, Integer segmentPrefixLength) {
		this(value, value, segmentPrefixLength);
	}
	protected IPAddressSegment(int lower, int upper, Integer segmentPrefixLength) {
		super(segmentPrefixLength);
		if(lower < 0 || upper < 0) {
			throw new AddressValueException(lower < 0 ? lower : upper);
		}
		if(lower > upper) {
			int tmp = lower;
			lower = upper;
			upper = tmp;
		}
		segmentPrefixLength = getSegmentPrefixLength();
		if(segmentPrefixLength == null || segmentPrefixLength >= getBitCount() || !getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) {
			this.value = lower;
			this.upperValue = upper;
		} else {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			this.value = lower & mask;
			this.upperValue = upper | getSegmentHostMask(segmentPrefixLength);
		}
	}
	@Override
	public abstract IPAddressNetwork<?, ?, ?, ?, ?> getNetwork();
	public boolean isIPv4() {
		return false;
	}
	public boolean isIPv6() {
		return false;
	}
	public abstract IPVersion getIPVersion();
	protected static Integer getSplitSegmentPrefix(int bitsPerSegment, Integer networkPrefixLength, int segmentIndex) {
		return IPAddressSection.getSegmentPrefixLength(bitsPerSegment, networkPrefixLength, segmentIndex);
	}
	@Override
	protected long getDivisionNetworkMask(int bits) {
		return getSegmentNetworkMask(bits);
	}
	@Override
	protected long getDivisionHostMask(int bits) {
		return getSegmentHostMask(bits);
	}
	protected abstract int getSegmentNetworkMask(int bits);
	protected abstract int getSegmentHostMask(int bits);
	@Override
	public int getMinPrefixLengthForBlock() {
		if(getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets() && isPrefixed() && getSegmentPrefixLength() == 0) {
			return 0;
		}
		return super.getMinPrefixLengthForBlock();
	}
	public static int getMaxSegmentValue(IPVersion version) {
		return version.isIPv4() ? IPv4Address.MAX_VALUE_PER_SEGMENT : IPv6Address.MAX_VALUE_PER_SEGMENT;
	}
	protected boolean isChangedByPrefix(Integer bits, boolean smallerOnly) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		if(smallerOnly) {
			if(isPrefixed()) {
				return hasBits && bits < getSegmentPrefixLength();
			}
		} else {
			if(isPrefixed()) {
				return !hasBits || bits != getSegmentPrefixLength().intValue();
			}
		}
		return hasBits;
	}
	protected <S extends IPAddressSegment> S toPrefixedSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		boolean hasBits = (segmentPrefixLength != null);
		if(lower != upper) {
			if(!hasBits) {
				return creator.createSegment(lower, upper, null);
			}
			return creator.createSegment(lower, upper, segmentPrefixLength);
		}
		return hasBits ? creator.createSegment(lower, segmentPrefixLength) : creator.createSegment(lower);
	}
	@Override
	public boolean isPrefixBlock() {
		return (isPrefixed() && getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets()) || super.isPrefixBlock();
	}
	protected boolean isNetworkChangedByPrefix(Integer bits, boolean withPrefixLength) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		withPrefixLength &= hasBits;
		boolean thisHasPrefix = isPrefixed();
		if(withPrefixLength != thisHasPrefix) {
			return true;
		}
		if(!hasBits || bits != getDivisionPrefixLength()) {
			return true;
		}
		return
			!containsPrefixBlock(bits);
	}
	protected boolean isNetworkChangedByPrefixNonNull(int prefixBitCount) {
		return !isPrefixed() || prefixBitCount != getDivisionPrefixLength() || !containsPrefixBlock(prefixBitCount);
	}
	public IPAddressSegment toNetworkSegment(Integer segmentPrefixLength) {
		return toNetworkSegment(segmentPrefixLength, true);
	}
	public abstract IPAddressSegment toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength);
	protected <S extends IPAddressSegment> S toNetworkSegment(Integer segmentPrefixLength, boolean withPrefixLength, AddressSegmentCreator<S> creator) {
		int newLower = getSegmentValue();
		int newUpper = getUpperSegmentValue();
		boolean hasPrefLen = segmentPrefixLength != null;
		if(hasPrefLen) {
			int mask = getSegmentNetworkMask(segmentPrefixLength);
			newLower &= mask;
			newUpper |= getSegmentHostMask(segmentPrefixLength);
		}
		withPrefixLength = withPrefixLength && hasPrefLen;
		if(newLower != newUpper) {
			if(!withPrefixLength) {
				return creator.createSegment(newLower, newUpper, null);
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		}
		return withPrefixLength ? creator.createSegment(newLower, segmentPrefixLength) : creator.createSegment(newLower);
	}
	public abstract IPAddressSegment toHostSegment(Integer segmentPrefixLength);
	protected <S extends IPAddressSegment> S toHostSegment(Integer segmentPrefixLength, AddressSegmentCreator<S> creator) {
		int mask = (segmentPrefixLength == null) ? 0 : getSegmentHostMask(segmentPrefixLength);
		int lower = getSegmentValue();
		int upper = getUpperSegmentValue();
		Masker masker = maskRange(lower, upper, mask, getMaxValue());
		int newLower = (int) masker.getMaskedLower(lower, mask);
		int newUpper = (int) masker.getMaskedUpper(upper, mask);
		if(newLower != newUpper) {
			return creator.createSegment(newLower, newUpper, null);
		}
		return creator.createSegment(newLower);
	}
	protected boolean isHostChangedByPrefix(Integer bits) {
		boolean hasBits = (bits != null);
		if(hasBits && (bits < 0 || bits > getBitCount())) {
			throw new PrefixLenException(this, bits);
		}
		if(isPrefixed()) {
			return true;
		}
		int mask = !hasBits ? 0 : getSegmentHostMask(bits);
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != (value & mask) || upperValue != (upperValue & mask);
	}
	protected boolean isChangedBy(int newValue, int newUpperValue, Integer segmentPrefixLength) throws IncompatibleAddressException {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		return value != newValue ||
				upperValue != newUpperValue ||
						(isPrefixed() ? !getSegmentPrefixLength().equals(segmentPrefixLength) : (segmentPrefixLength != null));
	}
	protected static Masker maskRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.maskRange(value, upperValue, maskValue, maxValue);
	}
	public MaskResult maskRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		Masker masker = AddressDivision.maskRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new MaskResult(value, upperValue, maskValue, masker);
	}
	protected static BitwiseOrer bitwiseOrRange(long value, long upperValue, long maskValue, long maxValue) {
		return AddressDivision.bitwiseOrRange(value, upperValue, maskValue, maxValue);
	}
	public BitwiseOrResult bitwiseOrRange(int maskValue) {
		int value = getSegmentValue();
		int upperValue = getUpperSegmentValue();
		BitwiseOrer orer = AddressDivision.bitwiseOrRange(value, upperValue, maskValue, getMaxSegmentValue());
		return new BitwiseOrResult(value, upperValue, maskValue, orer);
	}
	@Override
	public abstract IPAddressSegment getLower();
	@Override
	public abstract IPAddressSegment getUpper();
	protected static <S extends IPAddressSegment> S getLowestOrHighest(S original, AddressSegmentCreator<S> segmentCreator, boolean lowest) {
		boolean isAllSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
		if(!original.isMultiple() && !(isAllSubnets && original.isPrefixed())) {
			return original;
		}
		return segmentCreator.createSegment(lowest ? original.getSegmentValue() : original.getUpperSegmentValue(), 
				isAllSubnets ? null : original.getSegmentPrefixLength());
	}
	@Override
	public abstract Iterable<? extends IPAddressSegment> getIterable();
	@Override
	public abstract Iterator<? extends IPAddressSegment> iterator();
	@Override
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> spliterator();
	@Override
	public abstract Stream<? extends IPAddressSegment> stream();
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator();
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator();
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream();
	public abstract Iterator<? extends IPAddressSegment> prefixIterator();
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixSpliterator();
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		int originalValue = seg.getSegmentValue();
		int originalUpperValue = seg.getUpperSegmentValue();
		int originalValuePrefix = originalValue >>> shiftAdjustment;
		int originalUpperValuePrefix = originalUpperValue >>> shiftAdjustment;
		Integer segPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		IntBinaryIteratorProvider<S> subIteratorProvider = (isLowest, isHighest, value, upperValue) -> {
			if(isLowest || isHighest) {
				value = isLowest ? originalValue : value << shiftAdjustment;
				upperValue = isHighest ?  originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
				return iterator(null, value, upperValue, bitCount, creator, segPrefixLength, true, false);
			}
			return iterator(null, value << shiftAdjustment, upperValue << shiftAdjustment, bitCount, creator, segPrefixLength, true, true);
		};
		return createSegmentSpliterator(
				seg,
				originalValuePrefix,
				originalUpperValuePrefix,
				iteratorProvider,
				subIteratorProvider,
				(value, upperValue) -> {
					value = (value == originalValuePrefix) ? originalValue : value << shiftAdjustment;
					upperValue = (upperValue == originalUpperValuePrefix) ? 
							originalUpperValue : ((upperValue << shiftAdjustment) | upperShiftMask);
					return creator.createSegment(value, upperValue, segPrefLength);
				});
	}
	public abstract Stream<? extends IPAddressSegment> prefixStream();
	public abstract Iterator<? extends IPAddressSegment> prefixBlockIterator(int prefixLength);
	protected static <S extends IPAddressSegment> AddressComponentSpliterator<S> prefixBlockSpliterator(
			S seg, int segPrefLength,
			IPAddressCreator<?, ?, ?, S, ?> creator,
			Supplier<Iterator<S>> iteratorProvider) {
		int bitCount = seg.getBitCount();
		int shiftAdjustment = bitCount - segPrefLength;
		int shiftMask, upperShiftMask;
		if(shiftAdjustment > 0) {
			shiftMask = ~0 << shiftAdjustment;
			upperShiftMask = ~shiftMask;
		} else {
			shiftMask = ~0;
			upperShiftMask = 0;
		}
		Integer segmentPrefixLength = IPAddressSection.cacheBits(segPrefLength);
		return createSegmentSpliterator(
				seg,
				seg.getSegmentValue() >>> shiftAdjustment,
				seg.getUpperSegmentValue() >>> shiftAdjustment,
				iteratorProvider,
				(isLowest, isHighest, value, upperValue) -> iterator(
							null,
							value << shiftAdjustment,
							(upperValue << shiftAdjustment) | upperShiftMask,
							bitCount,
							creator,
							segmentPrefixLength,
							true,
							true),
				(value, upperValue) -> creator.createSegment(
						value << shiftAdjustment,
						(upperValue << shiftAdjustment) | upperShiftMask,
						segmentPrefixLength));
	}
	public abstract AddressComponentSpliterator<? extends IPAddressSegment> prefixBlockSpliterator(int prefixLength);
	public abstract Stream<? extends IPAddressSegment> prefixBlockStream(int prefixLength);
	public static int getBitCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BITS_PER_SEGMENT : IPv6Address.BITS_PER_SEGMENT;
	}
	public static int getByteCount(IPVersion version) {
		return version.isIPv4() ? IPv4Address.BYTES_PER_SEGMENT : IPv6Address.BYTES_PER_SEGMENT;
	}
	public static int getDefaultTextualRadix(IPVersion version) {
		return version.isIPv4() ? IPv4Address.DEFAULT_TEXTUAL_RADIX : IPv6Address.DEFAULT_TEXTUAL_RADIX;
	}
	@Override
	public boolean matches(int value) {
		return super.matches(value);
	}
	public boolean matchesWithPrefixMask(int value, Integer segmentPrefixLength) {
		return super.matchesWithPrefixMask(value, segmentPrefixLength);
	}
	@Override
	public boolean matchesWithMask(int value, int mask) {
		return super.matchesWithMask(value, mask);
	}
	@Override
	public boolean matchesWithMask(int lowerValue, int upperValue, int mask) {
		return super.matchesWithMask(lowerValue, upperValue, mask);
	}
	@Override
	public int getValueCount() {
		return getUpperSegmentValue() - getSegmentValue() + 1;
	}
	public int getPrefixValueCount() {
		Integer prefixLength = getSegmentPrefixLength();
		if(prefixLength == null) {
			return (int) getValueCount();
		}
		return getPrefixValueCount(this, prefixLength);
	}
	@Override
	public BigInteger getCount() {
		return BigInteger.valueOf(getValueCount());
	}
	@Override
	public BigInteger getPrefixCount(int segmentPrefixLength) {
		return BigInteger.valueOf(getPrefixValueCount(segmentPrefixLength));
	}
	@Override
	public int getPrefixValueCount(int segmentPrefixLength) {
		if(segmentPrefixLength < 0) {
			throw new PrefixLenException(this, segmentPrefixLength);
		}
		int bitCount = getBitCount();
		if(bitCount <= segmentPrefixLength) {
			return getValueCount();
		}
		int shiftAdjustment = bitCount - segmentPrefixLength;
		return (getUpperSegmentValue() >>> shiftAdjustment) - (getSegmentValue() >>> shiftAdjustment) + 1;
	}
	protected int highByte() {
		return highByte(getSegmentValue());
	}
	protected int lowByte() {
		return lowByte(getSegmentValue());
	}
	protected static int highByte(int value) {
		return value >> 8;
	}
	protected static int lowByte(int value) {
		return value & 0xff;
	}
	@Override
	public long getMaxValue() {
		return getMaxSegmentValue();
	}
	@Override
	public boolean isMultiple() {
		return getSegmentValue() != getUpperSegmentValue();
	}
	@Override
	public int getSegmentValue() {
		return value;
	}
	@Override
	public int getUpperSegmentValue() {
		return upperValue;
	}
	@Override
	public long getDivisionValue() {
		return getSegmentValue();
	}
	@Override
	public long getUpperDivisionValue() {
		return getUpperSegmentValue();
	}
	@Override
	public abstract IPAddressSegment reverseBits(boolean perByte);
	@Override
	public abstract IPAddressSegment reverseBytes();
	@Deprecated
	public abstract IPAddressSegment removePrefixLength();
	public abstract IPAddressSegment toZeroHost();
	@Deprecated
	public abstract IPAddressSegment removePrefixLength(boolean zeroed);
	public abstract IPAddressSegment withoutPrefixLength();
	protected static <S extends IPAddressSegment> S toZeroHost(S original, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			Integer segmentPrefixLength = original.getSegmentPrefixLength();
			int mask = original.getSegmentNetworkMask(segmentPrefixLength);
			int newLower = lower & mask;
			int newUpper = upper & mask;
			boolean allPrefsSubnets = original.getNetwork().getPrefixConfiguration().allPrefixedAddressesAreSubnets();
			if(allPrefsSubnets) {
				return creator.createSegment(newLower, newUpper, null);
			}
			if(newLower == lower && newUpper == upper) {
				return original;
			}
			return creator.createSegment(newLower, newUpper, segmentPrefixLength);
		} else if(original.isZero()) {
			return original;
		}
		return creator.createSegment(0, null);
	}
	protected static <S extends IPAddressSegment> S removePrefix(S original, boolean zeroed, AddressSegmentCreator<S> creator) {
		if(original.isPrefixed()) {
			int lower = original.getSegmentValue();
			int upper = original.getUpperSegmentValue();
			if(zeroed) {
				int maskBits = original.getSegmentNetworkMask(original.getSegmentPrefixLength());
				long value = original.getDivisionValue();
				long upperValue = original.getUpperDivisionValue();
				long maxValue = original.getMaxValue();
				Masker masker = maskRange(value, upperValue, maskBits, maxValue);
				if(!masker.isSequential()) {
					throw new IncompatibleAddressException(original, maskBits, "ipaddress.error.maskMismatch");
				}
				return creator.createSegment((int) masker.getMaskedLower(lower, maskBits), (int) masker.getMaskedUpper(upper, maskBits), null);
			}
			return creator.createSegment(lower, upper, null);
		}
		return original;
	}
	@Override
	public boolean isBoundedBy(int value) {
		return getUpperSegmentValue() < value;
	}
	public Integer getSegmentPrefixLength() {
		return getDivisionPrefixLength();
	}
	@Override
	public int hashCode() {
		return hash(getSegmentValue(), getUpperSegmentValue(), getBitCount());
	}
	static int hash(int lower, int upper, int bitCount) {
		return lower | (upper << bitCount);
	}
	protected boolean isSameValues(AddressSegment otherSegment) {
		return getSegmentValue() == otherSegment.getSegmentValue() && getUpperSegmentValue() == otherSegment.getUpperSegmentValue();
	}
	public boolean prefixEquals(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixEquals(other, prefLength);
	}
	@Override
	public boolean prefixEquals(AddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return isSameValues(other);
		}
		return (other.getSegmentValue() >>> shift) == (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) == (getUpperSegmentValue() >>> shift);
	}
	public boolean prefixContains(IPAddressSegment other) {
		Integer prefLength = getSegmentPrefixLength();
		if(prefLength == null) {
			return equals(other);
		}
		return prefixContains(other, prefLength);
	}
	public boolean prefixContains(IPAddressSegment other, int prefixLength) {
		if(prefixLength < 0) {
			throw new PrefixLenException(prefixLength);
		}
		int shift = getBitCount() - prefixLength;
		if(shift <= 0) {
			return contains(other);
		}
		return (other.getSegmentValue() >>> shift) >= (getSegmentValue() >>> shift) && 
				(other.getUpperSegmentValue() >>> shift) <= (getUpperSegmentValue() >>> shift);
	}
	protected boolean containsSeg(AddressSegment other) {
		return other.getSegmentValue() >= getSegmentValue() && other.getUpperSegmentValue() <= getUpperSegmentValue();
	}
	protected boolean overlapsSeg(AddressSegment other) {
		return other.getSegmentValue() <= getUpperSegmentValue() && other.getUpperSegmentValue() >= getSegmentValue();
	}
	@Override
	public boolean includesZero() {
		return getSegmentValue() == 0;
	}
	@Override
	public boolean includesMax() {
		return getUpperSegmentValue() == getMaxSegmentValue();
	}
	boolean containsPrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isPrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	boolean containsSinglePrefixBlock(int lowerVal, int upperVal, int divisionPrefixLen) {
		return isSinglePrefixBlock(lowerVal, upperVal, divisionPrefixLen);
	}
	@Override
	protected String getDefaultSegmentWildcardString() {
		return Address.SEGMENT_WILDCARD_STR;
	}
	@Override
	public String toHexString(boolean with0xPrefix) {
		return toNormalizedString(with0xPrefix ? IPStringCache.hexPrefixedParams : IPStringCache.hexParams);
	}
	@Override
	public String toNormalizedString() {
		return toNormalizedString(IPStringCache.canonicalSegmentParams);
	}
	public String toNormalizedString(IPStringOptions options) {
		IPAddressStringWriter<IPAddressStringDivisionSeries> params =  IPAddressSection.toIPParams(options);
		StringBuilder builder = new StringBuilder(params.getDivisionStringLength(this));
		return params.appendDivision(builder, this).toString();
	}
	protected static int toUnsignedStringLength(int value, int radix) {
		return AddressDivision.toUnsignedStringLength(value, radix);
	}
	protected static StringBuilder toUnsignedString(int value, int radix, StringBuilder appendable) {
		return toUnsignedStringCased(value, radix, 0, false, appendable);
	}
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int originalLowerValue) {
		if(cachedString == null && isStandardString && originalLowerValue == getDivisionValue()) {
			cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int lowerValue) {
		if(cachedWildcardString == null && isStandardString && lowerValue == getDivisionValue() && lowerValue == getUpperDivisionValue()) {
			cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
		}
	}
	void setStandardString(
			CharSequence addressStr, 
			boolean isStandardString,
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int lowerStringEndIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedString == null) {
			if(isSinglePrefixBlock()) {
				if(isStandardString && rangeLower == getDivisionValue()) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, lowerStringEndIndex).toString();
				}
			} else if(isFullRange()) {
				cachedString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue()) {
				long upper = getUpperDivisionValue();
				if(isPrefixed()) {
					upper &= getDivisionNetworkMask(getDivisionPrefixLength());
				}
				if(rangeUpper == upper) {
					cachedString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
				}
			}
		}
	}
	void setWildcardString(
			CharSequence addressStr, 
			boolean isStandardRangeString,
			int lowerStringStartIndex,
			int upperStringEndIndex,
			int rangeLower,
			int rangeUpper) {
		if(cachedWildcardString == null) {
			if(isFullRange()) {
				cachedWildcardString = IPAddress.SEGMENT_WILDCARD_STR;
			} else if(isStandardRangeString && rangeLower == getDivisionValue() && rangeUpper == getUpperDivisionValue()) {
				cachedWildcardString = addressStr.subSequence(lowerStringStartIndex, upperStringEndIndex).toString();
			}
		}
	}
}
package inet.ipaddr.format.util;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.TrieNode;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
public interface AddressTrieOps<E extends Address> extends TreeOps<E> {
	TrieNode<E> getNode(E addr);
	default TrieNode<E> getAddedNode(E addr) {
		TrieNode<E> ret = getNode(addr);
		return (ret == null || ret.isAdded()) ? ret : null;
	}
	boolean elementContains(E addr);
	boolean contains(E addr);
	boolean remove(E addr);
	TrieNode<E> removeElementsContainedBy(E addr);
	TrieNode<E> elementsContainedBy(E addr);
	TrieNode<E> elementsContaining(E addr);
	TrieNode<E> longestPrefixMatchNode(E addr);
	E longestPrefixMatch(E addr);
	TrieNode<E> shortestPrefixMatchNode(E addr);
	E shortestPrefixMatch(E addr);
	@Override
	Iterator<? extends TrieNode<E>> nodeIterator(boolean forward);
	@Override
	Iterator<? extends TrieNode<E>> allNodeIterator(boolean forward);
	@Override
	Iterator<? extends TrieNode<E>> containingFirstIterator(boolean forwardSubNodeOrder);
	@Override
	<C> CachingIterator<? extends TrieNode<E>, E, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder);
	@Override
	Iterator<? extends TrieNode<E>> containedFirstIterator(boolean forwardSubNodeOrder);
	@Override
	Iterator<? extends TrieNode<E>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder);
	@Override
	Spliterator<? extends TrieNode<E>> nodeSpliterator(boolean forward);
	@Override
	Spliterator<? extends TrieNode<E>> allNodeSpliterator(boolean forward);
	TrieNode<E> firstNode();
	TrieNode<E> lastNode();
	TrieNode<E> firstAddedNode();
	TrieNode<E> lastAddedNode();
	TrieNode<E> floorAddedNode(E addr);
	TrieNode<E> lowerAddedNode(E addr);
	TrieNode<E> ceilingAddedNode(E addr);
	TrieNode<E> higherAddedNode(E addr);
	E floor(E addr);
	E lower(E addr);
	E ceiling(E addr);
	E higher(E addr);
	public static interface AddressTrieAddOps<E extends Address> extends AddressTrieOps<E> {
		boolean add(E addr);
		TrieNode<E> addNode(E addr);
		TrieNode<E> addTrie(TrieNode<E> trie);
	}
	public static interface AssociativeAddressTrieOps<K extends Address, V> extends AddressTrieOps<K> {
		V get(K addr);
	}
	public static interface AssociativeAddressTriePutOps<K extends Address, V> extends AssociativeAddressTrieOps<K, V> {
		V put(K addr, V value);
		boolean putNew(K addr, V value);
		AssociativeTrieNode<K,V> putNode(K addr, V value);
		AssociativeTrieNode<K, V> remap(K addr, Function<? super V, ? extends V> remapper);
		AssociativeTrieNode<K, V> remapIfAbsent(K addr, Supplier<? extends V> remapper, boolean insertNull);
		AssociativeTrieNode<K, V> putTrie(AssociativeTrieNode<K, V> trie);
	}
}
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.AbstractSet;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.NavigableSet;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Spliterator;
import java.util.function.Function;
import inet.ipaddr.Address;
import inet.ipaddr.format.util.AddressTrie.AddressBounds;
import inet.ipaddr.format.util.BinaryTreeNode.KeyIterator;
public class AddressTrieSet<E extends Address> extends AbstractSet<E> implements NavigableSet<E>, Cloneable, Serializable {
	private static final long serialVersionUID = 1L;
	private AddressTrie<E> trie; 
	private final boolean isReverse;
	private final Range<E> bounds;
	private AddressTrieSet<E> descending; 
	public AddressTrieSet(AddressTrie<E> trie) {
		this.trie = trie;
		this.isReverse = false;
		this.bounds = null;
		if(trie.set == null) {
			trie.set = this;
		}
	}
	public AddressTrieSet(AddressTrie<E> trie, Collection<? extends E> collection) {
		this.trie = trie;
		this.isReverse = false;
		this.bounds = null;
		if(trie.set == null) {
			trie.set = this;
		}
        addAll(collection);
    }
	AddressTrieSet(AddressTrie<E> trie, Range<E> bounds, boolean isReverse) {
		this.trie = trie;
		this.bounds = bounds;
		this.isReverse = isReverse;
		if(trie.set == null && !isReverse && bounds == null) {
			trie.set = this;
		}
	}
	public static class Range<E extends Address> implements Serializable {
		private static final long serialVersionUID = 1L;
		final AddressBounds<E> wrapped;
		Range<E> reversed;
		final boolean isReverse;
		Range(AddressBounds<E> wrapped) {
			this(wrapped, false);
		}
		Range(AddressBounds<E> wrapped, boolean isReverse) {
			if(wrapped == null) {
				throw new NullPointerException();
			}
			this.wrapped = wrapped;
			this.isReverse = isReverse;
		}
		Range<E> reverse() {
			Range<E> result = reversed;
			if(result == null) {
				result = new Range<E>(wrapped, !isReverse);
				reversed = result;
				result.reversed = this;
			}
			return result;
		}
		public boolean isInBounds(E addr) {
			return isWithinLowerBound(addr) && isWithinUpperBound(addr);
		}
		public E getLowerBound() {
			return isReverse ? wrapped.getUpperBound() : wrapped.getLowerBound();
		}
		public E getUpperBound() {
			return isReverse ? wrapped.getLowerBound() : wrapped.getUpperBound();
		}
		public boolean lowerIsInclusive() {
			return isReverse ? wrapped.upperIsInclusive() : wrapped.lowerIsInclusive();
		}
		public boolean upperIsInclusive() {
			return isReverse ? wrapped.lowerIsInclusive() : wrapped.upperIsInclusive();
		}
		public boolean isLowerBounded() {
			return getLowerBound() != null;
		}
		public boolean isUpperBounded() {
			return getUpperBound() != null;
		}
		public boolean isBelowLowerBound(E addr) {
			return isReverse ? wrapped.isAboveUpperBound(addr) : wrapped.isBelowLowerBound(addr);
		}
		public boolean isAboveUpperBound(E addr) {
			return isReverse ? wrapped.isBelowLowerBound(addr) : wrapped.isAboveUpperBound(addr);
		}
		public boolean isWithinLowerBound(E addr) {
			return !isBelowLowerBound(addr);					
		}
		public boolean isWithinUpperBound(E addr) {
			return !isAboveUpperBound(addr);
		}
		@Override
		public String toString() {
			Function<? super E, String> stringer = Address::toCanonicalString;
			return AddressBounds.toString(
					getLowerBound(), lowerIsInclusive(), 
					getUpperBound(), upperIsInclusive(), stringer, " -> ", stringer);
		}
	}
	private boolean isBounded() {
		return bounds != null;
	}
	@Override
	public AddressTrieSet<E> descendingSet() {
		AddressTrieSet<E> desc = descending;
		if(desc == null) {
			Range<E> reverseBounds = isBounded() ?  bounds.reverse() : null;
			desc = new AddressTrieSet<E>(trie, reverseBounds, !isReverse);
			descending = desc;
			desc.descending = this;
		}
		return desc;
	}
	public AddressTrie<E> asTrie() {
		if(isBounded()) {
			return trie.clone();
		}
		if(!isReverse) {
			trie.set = this;
		}
		return trie;
	}
	public boolean hasRestrictedRange() {
		return isBounded();
	}
	public Range<E> getRange() {
		return bounds;
	}
	@Override
	public int size() {
		return trie.size();
	}
	@Override
	public boolean isEmpty() {
		return trie.isEmpty();
    }
	@SuppressWarnings("unchecked")
	@Override
	public boolean contains(Object o) {
		return trie.contains((E) o);
	}
	@Override
	public boolean add(E e) {
		return trie.add(e);
	}
	@SuppressWarnings("unchecked")
	@Override
	public boolean remove(Object o) {
		return trie.remove((E) o);
	}
	@Override
	public void clear() {
		trie.clear();
	}
	@Override
	public int hashCode() {
		return trie.hashCode();
	}
	@Override
	public boolean equals(Object o) {
		if(o instanceof AddressTrieSet<?>) {
			AddressTrieSet<?> other = (AddressTrieSet<?>) o;
			return trie.equals(other.trie);
		} 
		return super.equals(o);
	}
	@SuppressWarnings("unchecked")
	@Override
	public AddressTrieSet<E> clone() {
		try {
			AddressTrieSet<E> clone = (AddressTrieSet<E>) super.clone();
			clone.trie = trie.clone();
			clone.trie.bounds = trie.bounds; 
			clone.descending = null;
			return clone;
		} catch (CloneNotSupportedException cannotHappen) {
			return null;
		}
	}
	@Override
	public boolean removeAll(Collection<?> collection) {
		if(collection instanceof List || collection instanceof Queue || collection.size() < size()) {
			boolean result = false;
			for (Object object : collection) {
				if(remove(object)) {
					result = true;
				}
			}
			return result;
		}
		return removeIf(collection::contains);
    }
	@Override
	public Iterator<E> iterator() {
		return isReverse ? trie.descendingIterator() : trie.iterator();
	}
	@Override
	public Iterator<E> descendingIterator() {
		return isReverse ? trie.iterator() : trie.descendingIterator();
	}
	public Iterator<E> containingFirstIterator() {
		return new KeyIterator<E>(trie.containingFirstIterator(!isReverse));
	}
	public Iterator<E> containedFirstIterator() {
		return new KeyIterator<E>(trie.containedFirstIterator(!isReverse));
	}
	@Override
	public Spliterator<E> spliterator() {
		return isReverse ? trie.descendingSpliterator() : trie.spliterator();
    }
	@Override
	public Comparator<E> comparator() {
		return isReverse ? AddressTrie.reverseComparator() : AddressTrie.comparator();
	}
	public Iterator<E> blockSizeIterator() {
		return new KeyIterator<E>(trie.blockSizeNodeIterator(!isReverse));
	}
	private AddressTrieSet<E> toSubSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
		if(isReverse) {
			E tmp = fromElement;
			boolean tmpInc = fromInclusive;
			fromElement = toElement;
			fromInclusive = toInclusive;
			toElement = tmp;
			toInclusive = tmpInc;
		}
		Range<E> range = bounds;
		AddressBounds<E> bounds, newBounds;
		if(range != null) {
			bounds = range.wrapped;
		} else {
			bounds = null;
		}
		if(bounds == null) {
			newBounds = AddressBounds.createNewBounds(fromElement, fromInclusive, toElement,  toInclusive, trie.getComparator());
		} else {
			newBounds = bounds.restrict(fromElement, fromInclusive, toElement, toInclusive);
		}
		if(newBounds == null) {
			return this;
		}
		Range<E> newRange = new Range<E>(newBounds, isReverse);
		return new AddressTrieSet<E>(trie.createSubTrie(newBounds), newRange, isReverse);
	}
	@Override
	public AddressTrieSet<E> subSet(E fromElement, E toElement) {
		return subSet(fromElement, true, toElement, false);
    }
	@Override
	public AddressTrieSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
		if(fromElement == null || toElement == null) {
			throw new NullPointerException();
		}
		return toSubSet(fromElement, fromInclusive, toElement, toInclusive);
	}
	@Override
	public AddressTrieSet<E> headSet(E toElement) {
		return headSet(toElement, false);
    }
	@Override
	public AddressTrieSet<E> headSet(E toElement, boolean inclusive) {
		if(toElement == null) {
			throw new NullPointerException();
		}
		return toSubSet(null, true, toElement, inclusive);
	}
	@Override
	public AddressTrieSet<E> tailSet(E fromElement) {
		return tailSet(fromElement, true);
    }
	@Override
	public AddressTrieSet<E> tailSet(E fromElement, boolean inclusive) {
		if(fromElement == null) {
			throw new NullPointerException();
		}
		return toSubSet(fromElement, inclusive, null, false);
	}
	@Override
	public E first() {
		BinaryTreeNode<E> first = isReverse ? trie.lastAddedNode() : trie.firstAddedNode();
    	if(first == null) {
    		throw new NoSuchElementException();
    	}
    	return first.getKey();
    }
    @Override
	public E last() {
    	BinaryTreeNode<E> last = isReverse ? trie.firstAddedNode() : trie.lastAddedNode();
    	if(last == null) {
    		throw new NoSuchElementException();
    	}
    	return last.getKey();
    }
	@Override
	public E lower(E e) {
		return isReverse ? trie.higher(e) : trie.lower(e);
	}
	@Override
	public E floor(E e) {
		return isReverse ? trie.ceiling(e) : trie.floor(e);
	}
	@Override
	public E ceiling(E e) {
		return isReverse ? trie.floor(e) : trie.ceiling(e);
	}
	@Override
	public E higher(E e) {
		return isReverse ? trie.lower(e) : trie.higher(e);
	}
	@Override
	public E pollFirst() {
		BinaryTreeNode<E> first = isReverse ? trie.lastAddedNode() : trie.firstAddedNode();
    	if(first == null) {
    		return null;
    	}
    	first.remove();
    	return first.getKey();
	}
	@Override
	public E pollLast() {
		BinaryTreeNode<E> last = isReverse ? trie.firstAddedNode() : trie.lastAddedNode();
    	if(last == null) {
    		return null;
    	}
    	last.remove();
    	return last.getKey();
	}
	public String toTrieString() {
		return trie.toString();
	}
	public AddressTrieSet<E> elementsContainedBy(E addr) {
		AddressTrie<E> newTrie = trie.elementsContainedByToSubTrie(addr);
		if(trie == newTrie) {
			return this;
		}
		if(newTrie.bounds == null) {
			return new AddressTrieSet<E>(newTrie, null, isReverse);
		}
		Range<E> newRange = new Range<E>(newTrie.bounds, isReverse);
		return new AddressTrieSet<E>(newTrie, newRange, isReverse);
	}
	public AddressTrieSet<E> elementsContaining(E addr) {
		AddressTrie<E> newTrie = trie.elementsContainingToTrie(addr);
		if(trie == newTrie) {
			return this;
		}
		if(newTrie.bounds == null) {
			return new AddressTrieSet<E>(newTrie, null, isReverse);
		}
		Range<E> newRange = new Range<E>(newTrie.bounds, isReverse);
		return new AddressTrieSet<E>(newTrie, newRange, isReverse);
	}
	public boolean elementContains(E addr) {
		return trie.elementContainsBounds(addr);
	}
	public E longestPrefixMatch(E addr) {
		return trie.longestPrefixMatchBounds(addr);
	}
}
package inet.ipaddr.format.validate;
import inet.ipaddr.Address.SegmentValueProvider;
import inet.ipaddr.AddressNetwork.PrefixConfiguration;
import inet.ipaddr.format.standard.AddressDivisionGrouping.DivisionLengthProvider;
import inet.ipaddr.format.standard.AddressDivisionGrouping.DivisionValueProvider;
import inet.ipaddr.ipv6.IPv6Address;
public class ParsedAddressGrouping {
	public static int getNetworkSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment > 1) {
			if(bytesPerSegment == 2) {
				return (networkPrefixLength - 1) >> 4;
			}
			return (networkPrefixLength - 1) / bitsPerSegment;
		}
		return (networkPrefixLength - 1) >> 3;
	}
	public static int getHostSegmentIndex(int networkPrefixLength, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment > 1) {
			if(bytesPerSegment == 2) {
				return networkPrefixLength >> 4;
			}
			return networkPrefixLength / bitsPerSegment;
		}
		return networkPrefixLength >> 3;
	}
	public static int getTotalBits(int segmentCount, int bytesPerSegment, int bitsPerSegment) {
		if(bytesPerSegment != 1) {
			if(bytesPerSegment == 2) {
				return segmentCount << 4;
			}
			return segmentCount * bitsPerSegment;
		}
		return segmentCount << 3;
	}
	public static Integer getSegmentPrefixLength(int bitsPerSegment, Integer prefixLength, int segmentIndex) {
		if(prefixLength != null) {
			return getPrefixedSegmentPrefixLength(bitsPerSegment, prefixLength, segmentIndex);
		}
		return null;
	}
	public static Integer getPrefixedSegmentPrefixLength(int bitsPerSegment, int prefixLength, int segmentIndex) {
		int decrement = (bitsPerSegment == 8) ? segmentIndex << 3 : ((bitsPerSegment == 16) ? segmentIndex << 4 :  segmentIndex * bitsPerSegment);
		return getDivisionPrefixLength(bitsPerSegment, prefixLength - decrement);
	}
	public static Integer getDivisionPrefixLength(int divisionBits, int divisionPrefixedBits) {
		if(divisionPrefixedBits <= 0) {
			return cache(0); 
		} else if(divisionPrefixedBits <= divisionBits) {
			return cache(divisionPrefixedBits);
		}
		return null; 
	}
	public static Integer getNetworkPrefixLength(int bitsPerSegment, int segmentPrefixLength, int segmentIndex) {
		int increment = (bitsPerSegment == 8) ? segmentIndex << 3 : ((bitsPerSegment == 16) ? segmentIndex << 4 :  segmentIndex * bitsPerSegment);
		return cache(increment + segmentPrefixLength);
	}
	public static boolean isPrefixSubnet(
			DivisionValueProvider lowerValueProvider,
			DivisionValueProvider lowerExtendedValueProvider,
			DivisionValueProvider upperValueProvider,
			DivisionValueProvider upperExtendedValueProvider,
			DivisionLengthProvider bitLengthProvider,
			int divisionCount,
			Integer networkPrefixLength,
			PrefixConfiguration prefixConfiguration,
			boolean fullRangeOnly) {
		if(networkPrefixLength == null || prefixConfiguration.prefixedSubnetsAreExplicit()) {
			return false;
		}
		if(networkPrefixLength < 0) {
			networkPrefixLength = 0;
		}
		int totalBitLength = 0;
		topLoop:
		for(int i = 0; i < divisionCount; i++) {
			int divBitLength = bitLengthProvider.getLength(i);
			Integer divisionPrefLength = ParsedAddressGrouping.getDivisionPrefixLength(divBitLength, networkPrefixLength - totalBitLength);
			if(divBitLength == 0) {
				continue;
			}
			if(divisionPrefLength == null) {
				totalBitLength += divBitLength;
				continue;
			}
			int divisionPrefixLength = divisionPrefLength;
			int extendedPrefixLength, extendedDivBitLength;
			boolean isExtended, hasExtendedPrefixLength;
			boolean hasPrefLen = divisionPrefixLength != divBitLength;
			if(hasPrefLen) {
				if(isExtended = (divBitLength > Long.SIZE)) {
					extendedDivBitLength = divBitLength - Long.SIZE;
					divBitLength = Long.SIZE;
					if(hasExtendedPrefixLength = (divisionPrefixLength < extendedDivBitLength)) {
						extendedPrefixLength = divisionPrefixLength;
						divisionPrefixLength = 0;
					} else {
						isExtended = false;
						extendedPrefixLength = extendedDivBitLength;
						divisionPrefixLength -= extendedDivBitLength;
					}
				} else {
					extendedPrefixLength = extendedDivBitLength = 0;
					hasExtendedPrefixLength = false;
				}
			} else {
				extendedPrefixLength = extendedDivBitLength = 0;
				hasExtendedPrefixLength = isExtended = false;
			}
			while(true) {
				if(isExtended) {
					long extendedLower = lowerExtendedValueProvider.getValue(i);
					if(extendedPrefixLength == 0) {
						if(extendedLower != 0) {
							return false;
						}
						long extendedUpper = upperExtendedValueProvider.getValue(i);
						if(fullRangeOnly) {
							long maxVal = ~0L >>> (Long.SIZE - extendedDivBitLength);
							if(extendedUpper != maxVal) {
								return false;
							}
						} else {
							int upperOnes = Long.numberOfTrailingZeros(~extendedUpper);
							if(upperOnes > 0) {
								if(upperOnes < Long.SIZE && (extendedUpper >>> upperOnes) != 0) {
									return false;
								}
								fullRangeOnly = true;
							} else if(extendedUpper != 0) {
								return false;
							}
						}
					} else if(hasExtendedPrefixLength) {
						int divHostBits = extendedDivBitLength - extendedPrefixLength; 
						if(fullRangeOnly) {
							long hostMask = ~(~0L << divHostBits);
							if((hostMask & extendedLower) != 0) {
								return false;
							}
							long extendedUpper = upperExtendedValueProvider.getValue(i);
							if((hostMask & extendedUpper) != hostMask) {
								return false;
							}
						} else {
							int lowerZeros = Long.numberOfTrailingZeros(extendedLower);
							if(lowerZeros < divHostBits) {
								return false;
							}
							long extendedUpper = upperExtendedValueProvider.getValue(i);
							int upperOnes = Long.numberOfTrailingZeros(~extendedUpper);
							if(upperOnes < divHostBits) {
								int upperZeros = Long.numberOfTrailingZeros(extendedUpper >>> upperOnes);
								if(upperOnes + upperZeros < divHostBits) {
									return false;
								}
								fullRangeOnly = upperOnes > 0;
							} else {
								fullRangeOnly = true;
							}
						}
					}
				}
				if(divisionPrefixLength == 0) {
					long lower = lowerValueProvider.getValue(i);
					if(lower != 0) {
						return false;
					}
					long upper = upperValueProvider.getValue(i);
					if(fullRangeOnly) {	
						long maxVal = ~0L >>> (Long.SIZE - divBitLength);
						if(upper != maxVal) {
							return false;
						}
					} else {
						int upperOnes = Long.numberOfTrailingZeros(~upper);
						if(upperOnes > 0) {
							if(upperOnes < Long.SIZE && (upper >>> upperOnes) != 0) {
								return false;
							}
							fullRangeOnly = true;
						} else if(upper != 0) {
							return false;
						}
					}
				} else if(hasPrefLen){
					long lower = lowerValueProvider.getValue(i);
					int divHostBits = divBitLength - divisionPrefixLength; 
					if(fullRangeOnly) {
						long hostMask = ~(~0L << divHostBits);
						if((hostMask & lower) != 0) {
							return false;
						}
						long upper = upperValueProvider.getValue(i);
						if((hostMask & upper) != hostMask) {
							return false;
						}
					} else {
						int lowerZeros = Long.numberOfTrailingZeros(lower);
						if(lowerZeros < divHostBits) {
							return false;
						}
						long upper = upperValueProvider.getValue(i);
						int upperOnes = Long.numberOfTrailingZeros(~upper);
						if(upperOnes < divHostBits) {
							int upperZeros = Long.numberOfTrailingZeros(upper >>> upperOnes);
							if(upperOnes + upperZeros < divHostBits) {
								return false;
							}
							fullRangeOnly = upperOnes > 0;
						} else {
							fullRangeOnly = true;
						}
					}
				}
				if(++i == divisionCount) {
					break topLoop;
				}
				divBitLength = bitLengthProvider.getLength(i);
				if(hasExtendedPrefixLength = isExtended = (divBitLength > Long.SIZE)) {
					extendedDivBitLength = divBitLength - Long.SIZE;
					divBitLength = Long.SIZE;
				} else {
					extendedDivBitLength = 0;
				}
				extendedPrefixLength = divisionPrefixLength = 0;
			} 
		}
		return true;
	}
	public static boolean isPrefixSubnet(
			SegmentValueProvider lowerValueProvider,
			SegmentValueProvider upperValueProvider,
			int segmentCount,
			int bytesPerSegment,
			int bitsPerSegment,
			int segmentMaxValue,
			Integer networkPrefixLength,
			PrefixConfiguration prefixConfiguration,
			boolean fullRangeOnly) {
		if(networkPrefixLength == null || prefixConfiguration.prefixedSubnetsAreExplicit()) {
			return false;
		}
		if(networkPrefixLength < 0) {
			networkPrefixLength = 0;
		} else {
			int totalBitCount = (bitsPerSegment == 8) ? segmentCount << 3 : ((bitsPerSegment == 16) ? segmentCount << 4 : segmentCount * bitsPerSegment);
			if(networkPrefixLength >= totalBitCount) {
				return false;
			}
		}
		if(prefixConfiguration.allPrefixedAddressesAreSubnets()) {
			return true;
		}
		int prefixedSegment = getHostSegmentIndex(networkPrefixLength, bytesPerSegment, bitsPerSegment);
		int i = prefixedSegment;
		if(i < segmentCount) {
			int segmentPrefixLength = getPrefixedSegmentPrefixLength(bitsPerSegment, networkPrefixLength, i);
			do {
				int lower = lowerValueProvider.getValue(i);
				if(segmentPrefixLength == 0) {
					if(lower != 0) {
						return false;
					}
					int upper = upperValueProvider.getValue(i);
					if(fullRangeOnly) {
						if(upper != segmentMaxValue) {
							return false;
						}
					} else {
						int upperOnes = Integer.numberOfTrailingZeros(~upper);
						if(upperOnes > 0) {
							if((upper >>> upperOnes) != 0) {
								return false;
							}
							fullRangeOnly = true;
						} else if(upper != 0) {
							return false;
						}
					}
				} else if(segmentPrefixLength < bitsPerSegment) {
					int segHostBits = bitsPerSegment - segmentPrefixLength;
					if(fullRangeOnly) {
						int hostMask = ~(~0 << segHostBits);
						if((hostMask & lower) != 0) {
							return false;
						}
						int upper = upperValueProvider.getValue(i);
						if((hostMask & upper) != hostMask) {
							return false;
						}
					} else {
						int lowerZeros = Integer.numberOfTrailingZeros(lower);
						if(lowerZeros < segHostBits) {
							return false;
						}
						int upper = upperValueProvider.getValue(i);
						int upperOnes = Integer.numberOfTrailingZeros(~upper);
						if(upperOnes < segHostBits) {
							int upperZeros = Integer.numberOfTrailingZeros((upper | (~0 << bitsPerSegment)) >>> upperOnes);
							if(upperOnes + upperZeros < segHostBits) {
								return false;
							}
							fullRangeOnly = upperOnes > 0;
						} else {
							fullRangeOnly = true;
						}
					}
				}
				segmentPrefixLength = 0;
			} while(++i < segmentCount);
		}
		return true;
	}
	private static final Integer cache[] = new Integer[Short.MAX_VALUE]; static {
		for(int i = 0; i <= IPv6Address.BIT_COUNT; i++) {
			cache[i] = i;
		}
	}
	public static Integer cache(int i) {
		if(i >= 0 && i < cache.length) {
			Integer result = cache[i];
			if(result == null) {
				result = cache[i] = i;
			}
			return result;
		}
		return i;
	}
}
package inet.ipaddr.format.util;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.IPAddress;
import inet.ipaddr.format.util.AddressTrie.TrieNode;
import inet.ipaddr.format.util.AssociativeAddressTrie.AssociativeTrieNode;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv4.IPv4AddressAssociativeTrie;
import inet.ipaddr.ipv6.IPv6Address;
import inet.ipaddr.ipv6.IPv6AddressAssociativeTrie;
public class DualIPv4v6AssociativeTries<V> extends BaseDualIPv4v6Tries<IPv4AddressAssociativeTrie<V>, IPv6AddressAssociativeTrie<V>> {
	private static final long serialVersionUID = 1L;
	private IPv6AddressAssociativeTrie<V> ipv6Trie;
	private IPv4AddressAssociativeTrie<V> ipv4Trie;
	public DualIPv4v6AssociativeTries() {
		this(new IPv4AddressAssociativeTrie<V>(), new IPv6AddressAssociativeTrie<V>());
	}
	public DualIPv4v6AssociativeTries(IPv4AddressAssociativeTrie<V> ipv4Trie, IPv6AddressAssociativeTrie<V> ipv6Trie) {
		super(ipv4Trie, ipv6Trie);
		this.ipv4Trie = ipv4Trie;
		this.ipv6Trie = ipv6Trie;
	}
	@Override
	public DualIPv4v6AssociativeTries<V> clone() {
		DualIPv4v6AssociativeTries<V> result = (DualIPv4v6AssociativeTries<V>) super.clone();
		result.ipv4Trie = ipv4Trie.clone();
		result.ipv6Trie = ipv6Trie.clone();
		result.assignTrackers(result.ipv4Trie, result.ipv6Trie);
		return result;
	}
	@Override
	public IPv4AddressAssociativeTrie<V> getIPv4Trie() { 
		return ipv4Trie;
	}
	@Override
	public IPv6AddressAssociativeTrie<V> getIPv6Trie() {
		return ipv6Trie;
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> elementsContaining(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::elementsContaining, getIPv6Trie()::elementsContaining);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> elementsContainedBy(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::elementsContainedBy, getIPv6Trie()::elementsContainedBy);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> removeElementsContainedBy(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::removeElementsContainedBy, getIPv6Trie()::removeElementsContainedBy);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> getAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::getAddedNode, getIPv6Trie()::getAddedNode);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> longestPrefixMatchNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::longestPrefixMatchNode, getIPv6Trie()::longestPrefixMatchNode);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> addNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::addNode, getIPv6Trie()::addNode);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> addTrie(TrieNode<? extends IPAddress> trie) {
		return unaryOp(trie, getIPv4Trie()::addTrie, getIPv6Trie()::addTrie);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> floorAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::floorAddedNode, getIPv6Trie()::floorAddedNode);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> lowerAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::lowerAddedNode, getIPv6Trie()::lowerAddedNode);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> ceilingAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::ceilingAddedNode, getIPv6Trie()::ceilingAddedNode);
	}
	@Override
	public AssociativeTrieNode<? extends IPAddress, V> higherAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::higherAddedNode, getIPv6Trie()::higherAddedNode);
	}
	@Override
	public Iterator<AssociativeTrieNode<? extends IPAddress, V>> nodeIterator(boolean forward) {
		return combineNodeIterators(forward, getIPv4Trie().nodeIterator(forward), getIPv6Trie().nodeIterator(forward));
	}
	@Override
	public Iterator<AssociativeTrieNode<? extends IPAddress, V>> containingFirstIterator(boolean forwardSubNodeOrder) {
		return combineNodeIterators(forwardSubNodeOrder, getIPv4Trie().containingFirstIterator(forwardSubNodeOrder), getIPv6Trie().containingFirstIterator(forwardSubNodeOrder));
	}
	@Override
	public Iterator<AssociativeTrieNode<? extends IPAddress, V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return combineNodeIterators(forwardSubNodeOrder, getIPv4Trie().containedFirstIterator(forwardSubNodeOrder), getIPv6Trie().containedFirstIterator(forwardSubNodeOrder));
	}
	@Override
	public Iterator<AssociativeTrieNode<? extends IPAddress, V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return combineBlockSizeNodeIterators(lowerSubNodeFirst, getIPv4Trie().blockSizeNodeIterator(lowerSubNodeFirst), getIPv6Trie().blockSizeNodeIterator(lowerSubNodeFirst));
	}
	@Override
	public Spliterator<AssociativeTrieNode<? extends IPAddress, V>> nodeSpliterator(boolean forward) {
		return combineNodeSpliterators(forward, getIPv4Trie().nodeSpliterator(forward), getIPv6Trie().nodeSpliterator(forward));
	}
	public AssociativeTrieNode<? extends IPAddress, V> addTrie(AssociativeTrieNode<? extends IPAddress, V> trie) {
		return DualIPv4v6Tries.unaryOp(trie, getIPv4Trie()::addTrie, getIPv6Trie()::addTrie);
	}
	public V get(IPAddress addr) {
		return DualIPv4v6Tries.addressFuncOp(addr, getIPv4Trie()::get, getIPv6Trie()::get);
	}
	public V put(IPAddress addr, V value) {
		return DualIPv4v6Tries.addressValValBiFuncOp(addr, value, getIPv4Trie()::put, getIPv6Trie()::put);
	}
	public boolean putNew(IPAddress addr, V value) {
		return DualIPv4v6Tries.addressValBiFuncOp(addr, value, getIPv4Trie()::putNew, getIPv6Trie()::putNew);
	}
	public AssociativeTrieNode<? extends IPAddress, V> putNode(IPAddress addr, V value) {
		return DualIPv4v6Tries.addressValBiFuncOp(addr, value, getIPv4Trie()::putNode, getIPv6Trie()::putNode);
	}
	public AssociativeTrieNode<? extends IPAddress, V> putTrie(AssociativeTrieNode<? extends IPAddress, V> trie) {
		return DualIPv4v6Tries.unaryOp(trie, getIPv4Trie()::putTrie, getIPv6Trie()::putTrie);
	}
	public AssociativeTrieNode<? extends IPAddress, V> remap(IPAddress addr, Function<? super V, ? extends V> remapper) {
		return addressFuncOp(addr, remapper, getIPv4Trie()::remap, getIPv6Trie()::remap);
	}
	public AssociativeTrieNode<? extends IPAddress, V> remapIfAbsent(IPAddress addr, Supplier<? extends V> remapper, boolean insertNull) {
		return addressFuncBoolOp(addr, remapper, insertNull, getIPv4Trie()::remapIfAbsent, getIPv6Trie()::remapIfAbsent);
	}
	static <T, V, F> T addressFuncOp(
			IPAddress addr, 
			F remapper, 
			BiFunction<IPv4Address, F, T> ipv4Op, 
			BiFunction<IPv6Address, F, T> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4(), remapper);
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6(), remapper);
		} 
		return null;
	}
	static <T, V, F> T addressFuncBoolOp(
			IPAddress addr, 
			F remapper, 
			boolean insertNull,
			TriBoolFunction<IPv4Address, F, T> ipv4Op, 
			TriBoolFunction<IPv6Address, F, T> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4(), remapper, insertNull);
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6(), remapper, insertNull);
		} 
		return null;
	}
	@FunctionalInterface
	public interface TriBoolFunction<T, U, R> {
	    R apply(T t, U u, boolean b);
	}
}
package inet.ipaddr.format.util;
import java.io.Serializable;
import java.util.Comparator;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Spliterator;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import inet.ipaddr.Address;
import inet.ipaddr.IPAddress;
import inet.ipaddr.format.util.AddressTrie.TrieNode;
import inet.ipaddr.format.util.AddressTrieOps.AddressTrieAddOps;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker;
import inet.ipaddr.format.util.BinaryTreeNode.ChangeTracker.Change;
import inet.ipaddr.ipv4.IPv4Address;
import inet.ipaddr.ipv6.IPv6Address;
public abstract class BaseDualIPv4v6Tries<T4 extends AddressTrie<IPv4Address>, T6 extends AddressTrie<IPv6Address>> implements Iterable<IPAddress>, Serializable, Cloneable {
	private static final long serialVersionUID = 1L;
	public abstract T4 getIPv4Trie();
	public abstract T6 getIPv6Trie();
	private ChangeTracker ipv4Tracker, ipv6Tracker;
	BaseDualIPv4v6Tries(AddressTrie<IPv4Address> ipv4Trie, AddressTrie<IPv6Address> ipv6Trie) {
		assignTrackers(ipv4Trie, ipv6Trie);
	}
	void assignTrackers(AddressTrie<IPv4Address> ipv4Trie, AddressTrie<IPv6Address> ipv6Trie) {
		this.ipv4Tracker = ipv4Trie.absoluteRoot().changeTracker;
		this.ipv6Tracker = ipv6Trie.absoluteRoot().changeTracker;
	}
	@SuppressWarnings("unchecked")
	@Override
	public BaseDualIPv4v6Tries<T4, T6> clone() {
		try {
			return (BaseDualIPv4v6Tries<T4, T6>) super.clone();
		} catch (CloneNotSupportedException e) {
			return null;
		}
	}
	@Override
	public boolean equals(Object other) {
		if(other instanceof BaseDualIPv4v6Tries) {
			BaseDualIPv4v6Tries<?, ?> o = (BaseDualIPv4v6Tries<?, ?>) other;
			return getIPv4Trie().equals(o.getIPv4Trie()) && getIPv6Trie().equals(o.getIPv6Trie());
		}
		return false;
	}
	@Override
	public String toString() {
		return AddressTrie.toString(true, getIPv4Trie(), getIPv6Trie());
	}
	static boolean addressPredicateOp(IPAddress addr, Predicate<IPv4Address> ipv4Op, Predicate<IPv6Address> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.test(addr.toIPv4());
		} else if(addr.isIPv6()) {
			return ipv6Op.test(addr.toIPv6());
		} 
		return false;
	}
	static <T> T addressFuncOp(IPAddress addr, Function<IPv4Address, T> ipv4Op, Function<IPv6Address, T> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4());
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6());
		} 
		return null;
	}
	static <V> V addressValValBiFuncOp(IPAddress addr, V value, BiFunction<IPv4Address, V, V> ipv4Op, BiFunction<IPv6Address, V, V> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4(), value);
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6(), value);
		} 
		return null;
	}
	static <V, R> R addressValBiFuncOp(IPAddress addr, V value, BiFunction<IPv4Address, V, R> ipv4Op, BiFunction<IPv6Address, V, R> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.apply(addr.toIPv4(), value);
		} else if(addr.isIPv6()) {
			return ipv6Op.apply(addr.toIPv6(), value);
		} 
		return null;
	}
	static <V> boolean addressValBiPredicateOp(IPAddress addr, V value, BiPredicate<IPv4Address, V> ipv4Op, BiPredicate<IPv6Address, V> ipv6Op) {
		if(addr.isIPv4()) {
			return ipv4Op.test(addr.toIPv4(), value);
		} else if(addr.isIPv6()) {
			return ipv6Op.test(addr.toIPv6(), value);
		} 
		return false;
	}
	@SuppressWarnings("unchecked")
	static <T extends TrieNode<? extends IPAddress>, 
		R extends TrieNode<? extends IPAddress>,
		R1 extends TrieNode<IPv4Address>, 
		R2 extends TrieNode<IPv6Address>> R unaryOp(T trie, UnaryOperator<R1> ipv4Op, UnaryOperator<R2> ipv6Op) {
		IPAddress addr = trie.getKey();
		if(addr.isIPv4()) {
			return (R) ipv4Op.apply((R1) trie);
		} else if(addr.isIPv6()) {
			return (R) ipv6Op.apply((R2) trie);
		} 
		return null;
	}
	public int size() {
		return getIPv4Trie().size() + getIPv6Trie().size();
	}
	public boolean isEmpty() {
		return getIPv4Trie().isEmpty() && getIPv6Trie().isEmpty();
	}
	public boolean add(IPAddress addr) {
		return addressPredicateOp(addr, getIPv4Trie()::add, getIPv6Trie()::add);
	}
	public boolean contains(IPAddress addr) {
		return addressPredicateOp(addr, getIPv4Trie()::contains, getIPv6Trie()::contains);
	}
	public boolean remove(IPAddress addr) {
		return addressPredicateOp(addr, getIPv4Trie()::remove, getIPv6Trie()::remove);
	}
	public boolean elementContains(IPAddress addr) {
		return addressPredicateOp(addr, getIPv4Trie()::elementContains, getIPv6Trie()::elementContains);
	}
	public TrieNode<? extends IPAddress> elementsContaining(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::elementsContaining, getIPv6Trie()::elementsContaining);
	}
	public TrieNode<? extends IPAddress> elementsContainedBy(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::elementsContainedBy, getIPv6Trie()::elementsContainedBy);
	}
	public TrieNode<? extends IPAddress> removeElementsContainedBy(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::removeElementsContainedBy, getIPv6Trie()::removeElementsContainedBy);
	}
	public TrieNode<? extends IPAddress> getAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::getAddedNode, getIPv6Trie()::getAddedNode);
	}
	public TrieNode<? extends IPAddress> longestPrefixMatchNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::longestPrefixMatchNode, getIPv6Trie()::longestPrefixMatchNode);
	}
	public IPAddress longestPrefixMatch(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::longestPrefixMatch, getIPv6Trie()::longestPrefixMatch);
	}
	public TrieNode<? extends IPAddress> addNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::addNode, getIPv6Trie()::addNode);
	}
	public TrieNode<? extends IPAddress> addTrie(TrieNode<? extends IPAddress> trie) {
		return unaryOp(trie, getIPv4Trie()::addTrie, getIPv6Trie()::addTrie);
	}
	public TrieNode<? extends IPAddress> floorAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::floorAddedNode, getIPv6Trie()::floorAddedNode);
	}
	public TrieNode<? extends IPAddress> lowerAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::lowerAddedNode, getIPv6Trie()::lowerAddedNode);
	}
	public TrieNode<? extends IPAddress> ceilingAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::ceilingAddedNode, getIPv6Trie()::ceilingAddedNode);
	}
	public TrieNode<? extends IPAddress> higherAddedNode(IPAddress addr) {
		return addressFuncOp(addr, getIPv4Trie()::higherAddedNode, getIPv6Trie()::higherAddedNode);
	}
	public IPAddress floor(IPAddress addr) {
		return AddressTrie.getNodeKey(floorAddedNode(addr));
	}
	public IPAddress lower(IPAddress addr) {
		return AddressTrie.getNodeKey(lowerAddedNode(addr));
	}
	public IPAddress ceiling(IPAddress addr) {
		return AddressTrie.getNodeKey(ceilingAddedNode(addr));
	}
	public IPAddress higher(IPAddress addr) {
		return AddressTrie.getNodeKey(higherAddedNode(addr));
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPAddress> iterator() {
		Iterator<? extends IPAddress> ipv4Iterator = getIPv4Trie().iterator(), ipv6Iterator = getIPv6Trie().iterator();
		return new DualIterator<IPAddress>((Iterator<IPAddress>) ipv4Iterator, (Iterator<IPAddress>) ipv6Iterator, true);
	}
	@SuppressWarnings("unchecked")
	public Iterator<IPAddress> descendingIterator() {
		Iterator<? extends IPAddress> ipv4Iterator = getIPv4Trie().descendingIterator(), ipv6Iterator = getIPv6Trie().descendingIterator();
		return new DualIterator<IPAddress>((Iterator<IPAddress>) ipv4Iterator, (Iterator<IPAddress>) ipv6Iterator, false);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPAddress> spliterator() {
		Spliterator<? extends IPAddress> ipv4Iterator = getIPv4Trie().spliterator(), ipv6Iterator = getIPv6Trie().spliterator();
		return new DualSpliterator<IPAddress>((Spliterator<IPAddress>) ipv4Iterator, (Spliterator<IPAddress>) ipv6Iterator);
	}
	@SuppressWarnings("unchecked")
	public Spliterator<IPAddress> descendingSpliterator() {
		Spliterator<? extends IPAddress> ipv4Iterator = getIPv4Trie().descendingSpliterator(), ipv6Iterator = getIPv6Trie().descendingSpliterator();
		return new DualSpliterator<IPAddress>((Spliterator<IPAddress>) ipv6Iterator, (Spliterator<IPAddress>) ipv4Iterator);
	}
	@SuppressWarnings("unchecked")
	<T extends TrieNode<? extends IPAddress>> Iterator<T> combineNodeIterators(
			boolean forward,
			Iterator<? extends T> ipv4It, 
			Iterator<? extends T> ipv6It) {
		Iterator<T> ipv4I = (Iterator<T>) ipv4It;
		Iterator<T> ipv6I = (Iterator<T>) ipv6It;
		return new DualIterator<T>(ipv4I, ipv6I, forward);
	}
	@SuppressWarnings("unchecked")
	<T extends TrieNode<? extends IPAddress>> Iterator<T> combineBlockSizeNodeIterators(
			boolean lowerSubNodeFirst,
			Iterator<? extends T> ipv4It, 
			Iterator<? extends T> ipv6It) {
		Iterator<T> ipv4I = (Iterator<T>) ipv4It;
		Iterator<T> ipv6I = (Iterator<T>) ipv6It;
		return new DualBlockSizeIterator<T>(lowerSubNodeFirst, ipv4I, ipv6I);
	}
	public abstract Iterator<? extends TrieNode<? extends IPAddress>> nodeIterator(boolean forward);
	public abstract Iterator<? extends TrieNode<? extends IPAddress>> containingFirstIterator(boolean forwardSubNodeOrder);
	public abstract Iterator<? extends TrieNode<? extends IPAddress>> containedFirstIterator(boolean forwardSubNodeOrder);
	public abstract Iterator<? extends TrieNode<? extends IPAddress>> blockSizeNodeIterator(boolean lowerSubNodeFirst);
	public abstract Spliterator<? extends TrieNode<? extends IPAddress>> nodeSpliterator(boolean forward);
	@SuppressWarnings("unchecked")
	<T extends TrieNode<? extends IPAddress>> Spliterator<T> combineNodeSpliterators(
			boolean forward,
			Spliterator<? extends T> ipv4It, 
			Spliterator<? extends T> ipv6It) {
		Spliterator<T> ipv4I = (Spliterator<T>) ipv4It;
		Spliterator<T> ipv6I = (Spliterator<T>) ipv6It;
		if(forward) {
			return new DualSpliterator<T>(ipv4I, ipv6I);
		} 
		return new DualSpliterator<T>(ipv6I, ipv4I);
	}
	static class BlockSizeComp<E extends Address> implements Comparator<E> {
		private final boolean reverseBlocksEqualSize;
		BlockSizeComp(boolean reverseBlocksEqualSize) {
			this.reverseBlocksEqualSize = reverseBlocksEqualSize;
		}
		@Override
		public int compare(E addr1, E addr2) {
			if(addr1 == addr2) {
				return 0;
			}
			if(addr1.isPrefixed()) {
				if(addr2.isPrefixed()) {
					int val = (addr2.getBitCount() - addr2.getPrefixLength())
							- (addr1.getBitCount() - addr1.getPrefixLength());
					if(val == 0) {
						int compVal = compareLowValues(addr1, addr2);
						return reverseBlocksEqualSize ? -compVal : compVal;
					}
					return val;
				}
				return -1;
			}
			if(addr2.isPrefixed()) {
				return 1;
			}
			int compVal = compareLowValues(addr1, addr2);
			return reverseBlocksEqualSize ? -compVal : compVal;
		}
	};
	static int compareLowValues(Address one, Address two) {
		return Address.ADDRESS_LOW_VALUE_COMPARATOR.compare(one, two);
	}
	static final Comparator<?> BLOCK_SIZE_COMP = new BlockSizeComp<>(false), REVERSE_BLOCK_SIZE_COMP = new BlockSizeComp<>(true);
	class BaseDualIterator {
		Change ipv4CurrentChange, ipv6CurrentChange;
		BaseDualIterator() {
			if(ipv4Tracker != null) {
				ipv4CurrentChange = ipv4Tracker.getCurrent();
			}
			if(ipv6Tracker != null) {
				ipv6CurrentChange = ipv6Tracker.getCurrent();
			}
		}
		void changedSince() {
			if(ipv4Tracker != null) {
				ipv4Tracker.changedSince(ipv4CurrentChange);
			}
			if(ipv6Tracker != null) {
				ipv6Tracker.changedSince(ipv6CurrentChange);
			}
		}
	}
	class DualBlockSizeIterator<T extends TrieNode<? extends IPAddress>> extends BaseDualIterator implements Iterator<T> {
		T ipv4Item, ipv6Item; 
		Iterator<T> ipv4Iterator, ipv6Iterator;
		T lastItem;
		Comparator<IPAddress> comp;
		@SuppressWarnings("unchecked")
		DualBlockSizeIterator(boolean lowerSubNodeFirst, Iterator<T> ipv4Iterator, Iterator<T> ipv6Iterator) {
			boolean reverseBlocksEqualSize = !lowerSubNodeFirst;
			comp = (Comparator<IPAddress>) (reverseBlocksEqualSize ? REVERSE_BLOCK_SIZE_COMP : BLOCK_SIZE_COMP);
			this.ipv4Iterator = ipv4Iterator;
			this.ipv6Iterator = ipv6Iterator;
		}
		@Override
		public boolean hasNext() {
			return ipv4Item != null || ipv6Item != null || ipv4Iterator.hasNext() || ipv6Iterator.hasNext();
		}
		@Override
		public T next() {
			if(hasNext()) {
				changedSince();
			} else {
				throw new NoSuchElementException();
			}
			if(ipv4Item == null && ipv4Iterator.hasNext()) {
				ipv4Item = ipv4Iterator.next();
			} 
			if(ipv6Item == null && ipv6Iterator.hasNext()) {
				ipv6Item = ipv6Iterator.next();
			}
			T result;
			if(ipv4Item == null) {
				result = lastItem = ipv6Item;
				ipv6Item = null;
			} else if(ipv6Item == null) {
				result = lastItem = ipv4Item;
				ipv4Item = null;
			} else {
				int cmp = comp.compare(ipv4Item.getKey(), ipv6Item.getKey());
				if(cmp < 0) {
					result = lastItem = ipv4Item;
					ipv4Item = null;
				} else {
					result = lastItem = ipv6Item;
					ipv6Item = null;
				}
			}
			return result;
		}
		@Override
		public void remove() {
			if(lastItem == null) {
				throw new IllegalStateException();
			}
			changedSince();
			if(lastItem.getKey().isIPv4()) {
				ipv4Iterator.remove();
				ipv4CurrentChange = ipv4Tracker.getCurrent();
			} else {
				ipv6Iterator.remove();
				ipv6CurrentChange = ipv6Tracker.getCurrent();
			}
			lastItem = null;
	    }
	}
	class DualIterator<T> extends BaseDualIterator implements Iterator<T> {
		private Iterator<T> current; 
		private Iterator<T> first, last;
		private boolean firstIsIPv4;
		DualIterator(Iterator<T> ipv4Iterator, Iterator<T> ipv6Iterator, boolean forward) {
			if(forward) {
				this.first = ipv4Iterator;
				this.last = ipv6Iterator;
			} else {
				this.first = ipv6Iterator;
				this.last = ipv4Iterator;
			}
			current = first;
			firstIsIPv4 = forward;
		}
		@Override
		public boolean hasNext() {
			if(current == last) {
				return last.hasNext();
			}
			return current.hasNext() || last.hasNext();
		}
		@Override
		public T next() {
			if(current != last && !first.hasNext()) {
				current = last;
			}
			if(current.hasNext()) {
				changedSince();
			}
			return current.next();
		}
		@Override
		public void remove() {
			changedSince();
			current.remove();
	        if(current == first ? firstIsIPv4 : !firstIsIPv4) {
	        	if(ipv4Tracker != null) {
    				ipv4CurrentChange = ipv4Tracker.getCurrent();
    			}
	        } else if(ipv6Tracker != null) {
    			ipv6CurrentChange = ipv6Tracker.getCurrent();
	        }
	    }
	}
	class DualSpliterator<T> extends BaseDualIterator implements Spliterator<T> {
		Spliterator<T> first, second, current;
		DualSpliterator(Spliterator<T> first, Spliterator<T> second) {
			this.first = first;
			this.second = second;
		}
		@Override
		public boolean tryAdvance(Consumer<? super T> action) {
			changedSince();
			if(current == null) {
				if(first.tryAdvance(action)) {
					return true;
				}
				return second.tryAdvance(action);
			}
			return current.tryAdvance(action);
		}
		@Override
		public Spliterator<T> trySplit() {
			changedSince();
			if(current == null) {
				current = second;
				return first;
			}
			return current.trySplit();
		}
		@Override
		public void forEachRemaining(Consumer<? super T> action) {
			changedSince();
			if(current == null) {
				current = second;
				first.forEachRemaining(action);
				second.forEachRemaining(action);
			} else {
				current.forEachRemaining(action);
			}
	    }
		@Override
		public long estimateSize() {
			if(current == null) {
				return first.estimateSize() + second.estimateSize();
			}
			return current.estimateSize();
		}
		@Override
		public int characteristics() {
			if(current == null) {
				return first.characteristics() & second.characteristics();
			}
			return current.characteristics();
		}
	}
}
package inet.ipaddr.ipv4;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.format.util.AssociativeAddedTree;
import inet.ipaddr.format.util.AssociativeAddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
public class IPv4AddressAssociativeTrie<V> extends AssociativeAddressTrie<IPv4Address, V> {
	private static final long serialVersionUID = 1L;
	private static final IPv4Address INIT_ROOT = IPv4AddressTrie.INIT_ROOT;
	public IPv4AddressAssociativeTrie() {
		super(new IPv4AssociativeTrieNode<V>());
	}
	protected IPv4AddressAssociativeTrie(AddressBounds<IPv4Address> bounds) {
		super(new IPv4AssociativeTrieNode<V>(), bounds);
	}
	protected IPv4AddressAssociativeTrie(IPv4AssociativeTrieNode<V> root, AddressBounds<IPv4Address> bounds) {
		super(root, bounds);
	}
	@Override
	public IPv4AssociativeTrieNode<V> getRoot() {
		return (IPv4AssociativeTrieNode<V>) super.getRoot();
	}
	@Override
	protected IPv4AssociativeTrieNode<V> absoluteRoot() {
		return (IPv4AssociativeTrieNode<V>) super.absoluteRoot();
	}
	@Override
	protected IPv4AddressAssociativeTrie<V> createNew(AddressBounds<IPv4Address> bounds) {
		return new IPv4AddressAssociativeTrie<V>(bounds);
	}
	@Override
	protected IPv4AddressAssociativeTrie<V> createSubTrie(AddressBounds<IPv4Address> bounds) {
		return new IPv4AddressAssociativeTrie<V>(absoluteRoot(), bounds);
	}
	public static class IPv4AssociativeTrieNode<V> extends AssociativeTrieNode<IPv4Address, V> {
		private static final long serialVersionUID = 1L;
		protected IPv4AssociativeTrieNode(IPv4Address addr) {
			super(addr);
		}
		public IPv4AssociativeTrieNode() { 
			super(INIT_ROOT);
		}
		@Override
		protected void replaceThisRoot(BinaryTreeNode<IPv4Address> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		@Override
		public IPv4AssociativeTrieNode<V> getUpperSubNode() {
			return (IPv4AssociativeTrieNode<V>) super.getUpperSubNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> getLowerSubNode() {
			return (IPv4AssociativeTrieNode<V>) super.getLowerSubNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> getParent() {
			return (IPv4AssociativeTrieNode<V>) super.getParent();
		}
		@Override
		protected IPv4AssociativeTrieNode<V> createNewImpl(IPv4Address addr) {
			return new IPv4AssociativeTrieNode<V>(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> removeElementsContainedBy(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> elementsContainedBy(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.elementsContainedBy(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> elementsContaining(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.elementsContaining(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> longestPrefixMatchNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> getAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.getAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> getNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> nodeIterator(boolean forward) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> allNodeIterator(boolean forward) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4AssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4AssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv4AssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
			return (Spliterator<IPv4AssociativeTrieNode<V>>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv4AssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
			return (Spliterator<IPv4AssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
		}
		@Override
		public IPv4AssociativeTrieNode<V> previousAddedNode() {
			return (IPv4AssociativeTrieNode<V>) super.previousAddedNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> nextAddedNode() {
			return (IPv4AssociativeTrieNode<V>) super.nextAddedNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> nextNode() {
			return (IPv4AssociativeTrieNode<V>) super.nextNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> previousNode() {
			return (IPv4AssociativeTrieNode<V>) super.previousNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> lowerAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.lowerAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> floorAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.floorAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> higherAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.higherAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> ceilingAddedNode(IPv4Address addr) {
			return (IPv4AssociativeTrieNode<V>) super.ceilingAddedNode(addr);
		}
		@Override
		public IPv4AssociativeTrieNode<V> firstNode() {
			return (IPv4AssociativeTrieNode<V>) super.firstNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> lastNode() {
			return (IPv4AssociativeTrieNode<V>) super.lastNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> firstAddedNode() {
			return (IPv4AssociativeTrieNode<V>) super.firstAddedNode();
		}
		@Override
		public IPv4AssociativeTrieNode<V> lastAddedNode() {
			return (IPv4AssociativeTrieNode<V>) super.lastAddedNode();
		}
		@Override
		protected IPv4AddressAssociativeTrie<V> createNewTree() {
			return new IPv4AddressAssociativeTrie<V>();
		}
		@Override
		public IPv4AddressAssociativeTrie<V> asNewTrie() {
			return (IPv4AddressAssociativeTrie<V>) super.asNewTrie();
		}
		@Override
		public IPv4AssociativeTrieNode<V> cloneTree() {
			return (IPv4AssociativeTrieNode<V>) super.cloneTree();
		}
		@Override
		public IPv4AssociativeTrieNode<V> clone() {
			return (IPv4AssociativeTrieNode<V>) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv4AddressAssociativeTrie.IPv4AssociativeTrieNode && super.equals(o);
		}
		@Override
		protected TrieKeyData getTrieKeyCache(IPv4Address addr) {
			return addr.getTrieKeyCache();
		}
	}
	@Override
	public IPv4AssociativeTrieNode<V> removeElementsContainedBy(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> elementsContainedBy(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.elementsContainedBy(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> elementsContaining(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.elementsContaining(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> longestPrefixMatchNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> getAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.getAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> getNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.getNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> addNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.addNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public IPv4AssociativeTrieNode<V> addTrie(TrieNode<IPv4Address> trie) {
		return (IPv4AssociativeTrieNode<V>) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> nodeIterator(boolean forward) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> allNodeIterator(boolean forward) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<IPv4AssociativeTrieNode<V>, IPv4Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4AssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4AssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv4AssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
		return (Spliterator<IPv4AssociativeTrieNode<V>>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv4AssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
		return (Spliterator<IPv4AssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
	}
	@Override
	public IPv4AssociativeTrieNode<V> lowerAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.lowerAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> floorAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.floorAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> higherAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.higherAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> ceilingAddedNode(IPv4Address addr) {
		return (IPv4AssociativeTrieNode<V>) super.ceilingAddedNode(addr);
	}
	@Override
	public IPv4AssociativeTrieNode<V> firstNode() {
		return (IPv4AssociativeTrieNode<V>) super.firstNode();
	}
	@Override
	public IPv4AssociativeTrieNode<V> lastNode() {
		return (IPv4AssociativeTrieNode<V>) super.lastNode();
	}
	@Override
	public IPv4AssociativeTrieNode<V> firstAddedNode() {
		return (IPv4AssociativeTrieNode<V>) super.firstAddedNode();
	}
	@Override
	public IPv4AssociativeTrieNode<V> lastAddedNode() {
		return (IPv4AssociativeTrieNode<V>) super.lastAddedNode();
	}
	@Override
	public IPv4AssociativeTrieNode<V> putNode(IPv4Address addr, V value) {
		return (IPv4AssociativeTrieNode<V>) super.putNode(addr, value);
	}
	@Override
	public IPv4AssociativeTrieNode<V> putTrie(AssociativeTrieNode<IPv4Address, V> trie) {
		return (IPv4AssociativeTrieNode<V>) super.putTrie(trie);
	}
	@Override
	public IPv4AssociativeTrieNode<V> remap(IPv4Address addr, Function<? super V, ? extends V> remapper) {
		return (IPv4AssociativeTrieNode<V>) super.remap(addr, remapper);
	}
	@Override
	public IPv4AssociativeTrieNode<V> remapIfAbsent(IPv4Address addr, Supplier<? extends V> remapper, boolean insertNull) {
		return (IPv4AssociativeTrieNode<V>) super.remapIfAbsent(addr, remapper, insertNull);
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof IPv4AddressAssociativeTrie && super.equals(o);
	}
	@Override
	public IPv4AddressAssociativeTrie<V> clone() {
		return (IPv4AddressAssociativeTrie<V>) super.clone();
	}
	@Override
	public AssociativeAddedTree<IPv4Address, V> constructAddedNodesTree() {
		IPv4AddressAssociativeTrie<SubNodesMappingAssociative<IPv4Address, V>> trie = new IPv4AddressAssociativeTrie<SubNodesMappingAssociative<IPv4Address, V>>();
		contructAssociativeAddedTree(trie);
		return new AssociativeAddedTree<IPv4Address, V>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		IPv4AddressAssociativeTrie<SubNodesMappingAssociative<IPv4Address, V>> trie = new IPv4AddressAssociativeTrie<SubNodesMappingAssociative<IPv4Address, V>>();
		contructAssociativeAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
package inet.ipaddr.mac;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Function;
import java.util.function.Supplier;
import inet.ipaddr.format.util.AssociativeAddedTree;
import inet.ipaddr.format.util.AssociativeAddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
public class MACAddressAssociativeTrie<V> extends AssociativeAddressTrie<MACAddress, V> {
	private static final long serialVersionUID = 1L;
	private static final MACAddress INIT_ROOT = MACAddressTrie.INIT_ROOT;
	private static final MACAddress INIT_ROOT_EXTENDED = MACAddressTrie.INIT_ROOT_EXTENDED;
	public MACAddressAssociativeTrie() {
		super(new MACAssociativeTrieNode<V>());
	}
	protected MACAddressAssociativeTrie(AddressBounds<MACAddress> bounds) {
		super(new MACAssociativeTrieNode<V>(), bounds);
	}
	protected MACAddressAssociativeTrie(MACAssociativeTrieNode<V> root, AddressBounds<MACAddress> bounds) {
		super(root, bounds);
	}
	@Override
	protected void adjustRoot(MACAddress addr) {
		if(isEmpty() && addr.getSegmentCount() == MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT) {
			absoluteRoot().setExtendedRootKey();
		}
	}
	@Override
	public MACAssociativeTrieNode<V> getRoot() {
		return (MACAssociativeTrieNode<V>) super.getRoot();
	}
	@Override
	protected MACAssociativeTrieNode<V> absoluteRoot() {
		return (MACAssociativeTrieNode<V>) super.absoluteRoot();
	}
	@Override
	protected MACAddressAssociativeTrie<V> createNew(AddressBounds<MACAddress> bounds) {
		return new MACAddressAssociativeTrie<V>(bounds);
	}
	@Override
	protected MACAddressAssociativeTrie<V> createSubTrie(AddressBounds<MACAddress> bounds) {
		return new MACAddressAssociativeTrie<V>(absoluteRoot(), bounds);
	}
	public static class MACAssociativeTrieNode<V> extends AssociativeTrieNode<MACAddress, V> {
		private static final long serialVersionUID = 1L;
		protected MACAssociativeTrieNode(MACAddress addr) {
			super(addr);
		}
		public MACAssociativeTrieNode() { 
			super(INIT_ROOT);
		}
		@Override
		protected void replaceThisRoot(BinaryTreeNode<MACAddress> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		void setExtendedRootKey() {
			setKey(INIT_ROOT_EXTENDED);
		}
		@Override
		public MACAssociativeTrieNode<V> getUpperSubNode() {
			return (MACAssociativeTrieNode<V>) super.getUpperSubNode();
		}
		@Override
		public MACAssociativeTrieNode<V> getLowerSubNode() {
			return (MACAssociativeTrieNode<V>) super.getLowerSubNode();
		}
		@Override
		public MACAssociativeTrieNode<V> getParent() {
			return (MACAssociativeTrieNode<V>) super.getParent();
		}
		@Override
		protected MACAssociativeTrieNode<V> createNewImpl(MACAddress addr) {
			return new MACAssociativeTrieNode<V>(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> removeElementsContainedBy(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> elementsContainedBy(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.elementsContainedBy(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> elementsContaining(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.elementsContaining(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> longestPrefixMatchNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> getAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.getAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> getNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> nodeIterator(boolean forward) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> allNodeIterator(boolean forward) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACAssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACAssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<MACAssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
			return (Spliterator<MACAssociativeTrieNode<V>>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<MACAssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
			return (Spliterator<MACAssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
		}
		@Override
		public MACAssociativeTrieNode<V> previousAddedNode() {
			return (MACAssociativeTrieNode<V>) super.previousAddedNode();
		}
		@Override
		public MACAssociativeTrieNode<V> nextAddedNode() {
			return (MACAssociativeTrieNode<V>) super.nextAddedNode();
		}
		@Override
		public MACAssociativeTrieNode<V> nextNode() {
			return (MACAssociativeTrieNode<V>) super.nextNode();
		}
		@Override
		public MACAssociativeTrieNode<V> previousNode() {
			return (MACAssociativeTrieNode<V>) super.previousNode();
		}
		@Override
		public MACAssociativeTrieNode<V> lowerAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.lowerAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> floorAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.floorAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> higherAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.higherAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> ceilingAddedNode(MACAddress addr) {
			return (MACAssociativeTrieNode<V>) super.ceilingAddedNode(addr);
		}
		@Override
		public MACAssociativeTrieNode<V> firstNode() {
			return (MACAssociativeTrieNode<V>) super.firstNode();
		}
		@Override
		public MACAssociativeTrieNode<V> lastNode() {
			return (MACAssociativeTrieNode<V>) super.lastNode();
		}
		@Override
		public MACAssociativeTrieNode<V> firstAddedNode() {
			return (MACAssociativeTrieNode<V>) super.firstAddedNode();
		}
		@Override
		public MACAssociativeTrieNode<V> lastAddedNode() {
			return (MACAssociativeTrieNode<V>) super.lastAddedNode();
		}
		@Override
		protected MACAddressAssociativeTrie<V> createNewTree() {
			return new MACAddressAssociativeTrie<V>();
		}
		@Override
		public MACAddressAssociativeTrie<V> asNewTrie() {
			return (MACAddressAssociativeTrie<V>) super.asNewTrie();
		}
		@Override
		public MACAssociativeTrieNode<V> cloneTree() {
			return (MACAssociativeTrieNode<V>) super.cloneTree();
		}
		@Override
		public MACAssociativeTrieNode<V> clone() {
			return (MACAssociativeTrieNode<V>) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof MACAddressAssociativeTrie.MACAssociativeTrieNode && super.equals(o);
		}
	}
	@Override
	public MACAssociativeTrieNode<V> removeElementsContainedBy(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.removeElementsContainedBy(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> elementsContainedBy(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.elementsContainedBy(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> elementsContaining(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.elementsContaining(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> longestPrefixMatchNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.longestPrefixMatchNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> getAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.getAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> getNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.getNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> addNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.addNode(addr);
	}
	@SuppressWarnings("unchecked")
	@Override
	public MACAssociativeTrieNode<V> addTrie(TrieNode<MACAddress> trie) {
		return (MACAssociativeTrieNode<V>) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> nodeIterator(boolean forward) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> allNodeIterator(boolean forward) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<MACAssociativeTrieNode<V>, MACAddress, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACAssociativeTrieNode<V>> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACAssociativeTrieNode<V>>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<MACAssociativeTrieNode<V>> nodeSpliterator(boolean forward) {
		return (Spliterator<MACAssociativeTrieNode<V>>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<MACAssociativeTrieNode<V>> allNodeSpliterator(boolean forward) {
		return (Spliterator<MACAssociativeTrieNode<V>>) super.allNodeSpliterator(forward);
	}
	@Override
	public MACAssociativeTrieNode<V> lowerAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.lowerAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> floorAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.floorAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> higherAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.higherAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> ceilingAddedNode(MACAddress addr) {
		return (MACAssociativeTrieNode<V>) super.ceilingAddedNode(addr);
	}
	@Override
	public MACAssociativeTrieNode<V> firstNode() {
		return (MACAssociativeTrieNode<V>) super.firstNode();
	}
	@Override
	public MACAssociativeTrieNode<V> lastNode() {
		return (MACAssociativeTrieNode<V>) super.lastNode();
	}
	@Override
	public MACAssociativeTrieNode<V> firstAddedNode() {
		return (MACAssociativeTrieNode<V>) super.firstAddedNode();
	}
	@Override
	public MACAssociativeTrieNode<V> lastAddedNode() {
		return (MACAssociativeTrieNode<V>) super.lastAddedNode();
	}
	@Override
	public MACAssociativeTrieNode<V> putNode(MACAddress addr, V value) {
		return (MACAssociativeTrieNode<V>) super.putNode(addr, value);
	}
	@Override
	public MACAssociativeTrieNode<V> putTrie(AssociativeTrieNode<MACAddress, V> trie) {
		return (MACAssociativeTrieNode<V>) super.putTrie(trie);
	}
	@Override
	public MACAssociativeTrieNode<V> remap(MACAddress addr, Function<? super V, ? extends V> remapper) {
		return (MACAssociativeTrieNode<V>) super.remap(addr, remapper);
	}
	@Override
	public MACAssociativeTrieNode<V> remapIfAbsent(MACAddress addr, Supplier<? extends V> remapper, boolean insertNull) {
		return (MACAssociativeTrieNode<V>) super.remapIfAbsent(addr, remapper, insertNull);
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof MACAddressAssociativeTrie && super.equals(o);
	}
	@Override
	public MACAddressAssociativeTrie<V> clone() {
		return (MACAddressAssociativeTrie<V>) super.clone();
	}
	@Override
	public AssociativeAddedTree<MACAddress, V> constructAddedNodesTree() {
		MACAddressAssociativeTrie<SubNodesMappingAssociative<MACAddress, V>> trie = new MACAddressAssociativeTrie<SubNodesMappingAssociative<MACAddress, V>>();
		contructAssociativeAddedTree(trie);
		return new AssociativeAddedTree<MACAddress, V>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		MACAddressAssociativeTrie<SubNodesMappingAssociative<MACAddress, V>> trie = new MACAddressAssociativeTrie<SubNodesMappingAssociative<MACAddress, V>>();
		contructAssociativeAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
package inet.ipaddr.mac;
import java.util.Iterator;
import java.util.Spliterator;
import inet.ipaddr.MACAddressString;
import inet.ipaddr.format.util.AddedTree;
import inet.ipaddr.format.util.AddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
public class MACAddressTrie extends AddressTrie<MACAddress> {
	private static final long serialVersionUID = 1L;
	static final MACAddress INIT_ROOT = new MACAddressString("*:*:*:*:*:*").getAddress();
	static final MACAddress INIT_ROOT_EXTENDED = new MACAddressString("*:*:*:*:*:*:*:*").getAddress();
	public MACAddressTrie() {
		super(new MACTrieNode());
	}
	protected MACAddressTrie(AddressBounds<MACAddress> bounds) {
		super(new MACTrieNode(), bounds);
	}
	protected MACAddressTrie(MACTrieNode root, AddressBounds<MACAddress> bounds) {
		super(root, bounds);
	}
	@Override
	protected void adjustRoot(MACAddress addr) {
		if(isEmpty() && addr.getSegmentCount() == MACAddress.EXTENDED_UNIQUE_IDENTIFIER_64_SEGMENT_COUNT) {
			absoluteRoot().setExtendedRootKey();
		}
	}
	@Override
	protected MACTrieNode absoluteRoot() {
		return (MACTrieNode) super.absoluteRoot();
	}
	@Override
	protected MACAddressTrie createNew(AddressBounds<MACAddress> bounds) {
		return new MACAddressTrie(bounds);
	}
	@Override
	protected MACAddressTrie createSubTrie(AddressBounds<MACAddress> bounds) {
		return new MACAddressTrie(absoluteRoot(), bounds);
	}
	@Override
	public MACTrieNode getRoot() {
		return (MACTrieNode) super.getRoot();
	}
	public static class MACTrieNode extends TrieNode<MACAddress> {
		private static final long serialVersionUID = 1L;
		protected MACTrieNode(MACAddress addr) {
			super(addr);
		}
		public MACTrieNode() { 
			super(INIT_ROOT);
		}
		@Override
		protected void replaceThisRoot(BinaryTreeNode<MACAddress> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		void setExtendedRootKey() {
			setKey(INIT_ROOT_EXTENDED);
		}
		@Override
		public MACTrieNode getUpperSubNode() {
			return (MACTrieNode) super.getUpperSubNode();
		}
		@Override
		public MACTrieNode getLowerSubNode() {
			return (MACTrieNode) super.getLowerSubNode();
		}
		@Override
		public MACTrieNode getParent() {
			return (MACTrieNode) super.getParent();
		}
		@Override
		protected MACTrieNode createNewImpl(MACAddress addr) {
			return new MACTrieNode(addr);
		}
		@Override
		public MACTrieNode removeElementsContainedBy(MACAddress addr) {
			return (MACTrieNode) super.removeElementsContainedBy(addr);
		}
		@Override
		public MACTrieNode elementsContainedBy(MACAddress addr) {
			return (MACTrieNode) super.elementsContainedBy(addr);
		}
		@Override
		public MACTrieNode elementsContaining(MACAddress addr) {
			return (MACTrieNode) super.elementsContaining(addr);
		}
		@Override
		public MACTrieNode longestPrefixMatchNode(MACAddress addr) {
			return (MACTrieNode) super.longestPrefixMatchNode(addr);
		}
		@Override
		public MACTrieNode getAddedNode(MACAddress addr) {
			return (MACTrieNode) super.getAddedNode(addr);
		}
		@Override
		public MACTrieNode getNode(MACAddress addr) {
			return (MACTrieNode) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> nodeIterator(boolean forward) {
			return (Iterator<MACTrieNode>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> allNodeIterator(boolean forward) {
			return (Iterator<MACTrieNode>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<MACTrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<MACTrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<MACTrieNode, MACAddress, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<MACTrieNode, MACAddress, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACTrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<MACTrieNode, MACAddress, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<MACTrieNode, MACAddress, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACTrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<MACTrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<MACTrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<MACTrieNode> nodeSpliterator(boolean forward) {
			return (Spliterator<MACTrieNode>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<MACTrieNode> allNodeSpliterator(boolean forward) {
			return (Spliterator<MACTrieNode>) super.allNodeSpliterator(forward);
		}
		@Override
		public MACTrieNode previousAddedNode() {
			return (MACTrieNode) super.previousAddedNode();
		}
		@Override
		public MACTrieNode nextAddedNode() {
			return (MACTrieNode) super.nextAddedNode();
		}
		@Override
		public MACTrieNode nextNode() {
			return (MACTrieNode) super.nextNode();
		}
		@Override
		public MACTrieNode previousNode() {
			return (MACTrieNode) super.previousNode();
		}
		@Override
		public MACTrieNode lowerAddedNode(MACAddress addr) {
			return (MACTrieNode) super.lowerAddedNode(addr);
		}
		@Override
		public MACTrieNode floorAddedNode(MACAddress addr) {
			return (MACTrieNode) super.floorAddedNode(addr);
		}
		@Override
		public MACTrieNode higherAddedNode(MACAddress addr) {
			return (MACTrieNode) super.higherAddedNode(addr);
		}
		@Override
		public MACTrieNode ceilingAddedNode(MACAddress addr) {
			return (MACTrieNode) super.ceilingAddedNode(addr);
		}
		@Override
		public MACTrieNode firstNode() {
			return (MACTrieNode) super.firstNode();
		}
		@Override
		public MACTrieNode lastNode() {
			return (MACTrieNode) super.lastNode();
		}
		@Override
		public MACTrieNode firstAddedNode() {
			return (MACTrieNode) super.firstAddedNode();
		}
		@Override
		public MACTrieNode lastAddedNode() {
			return (MACTrieNode) super.lastAddedNode();
		}
		@Override
		protected MACAddressTrie createNewTree() {
			return new MACAddressTrie();
		}
		@Override
		public MACAddressTrie asNewTrie() {
			return (MACAddressTrie) super.asNewTrie();
		}
		@Override
		public MACTrieNode cloneTree() {
			return (MACTrieNode) super.cloneTree();
		}
		@Override
		public MACTrieNode clone() {
			return (MACTrieNode) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof MACTrieNode && super.equals(o);
		}
	}
	@Override
	public MACTrieNode removeElementsContainedBy(MACAddress addr) {
		return (MACTrieNode) super.removeElementsContainedBy(addr);
	}
	@Override
	public MACTrieNode elementsContainedBy(MACAddress addr) {
		return (MACTrieNode) super.elementsContainedBy(addr);
	}
	@Override
	public MACTrieNode elementsContaining(MACAddress addr) {
		return (MACTrieNode) super.elementsContaining(addr);
	}
	@Override
	public MACTrieNode longestPrefixMatchNode(MACAddress addr) {
		return (MACTrieNode) super.longestPrefixMatchNode(addr);
	}
	@Override
	public MACTrieNode getAddedNode(MACAddress addr) {
		return (MACTrieNode) super.getAddedNode(addr);
	}
	@Override
	public MACTrieNode getNode(MACAddress addr) {
		return (MACTrieNode) super.getNode(addr);
	}
	@Override
	public MACTrieNode addNode(MACAddress addr) {
		return (MACTrieNode) super.addNode(addr);
	}
	@Override
	public MACTrieNode addTrie(TrieNode<MACAddress> trie) {
		return (MACTrieNode) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> nodeIterator(boolean forward) {
		return (Iterator<MACTrieNode>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> allNodeIterator(boolean forward) {
		return (Iterator<MACTrieNode>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<MACTrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<MACTrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<MACTrieNode, MACAddress, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<MACTrieNode, MACAddress, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACTrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<MACTrieNode, MACAddress, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<MACTrieNode, MACAddress, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACTrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<MACTrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<MACTrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<MACTrieNode> nodeSpliterator(boolean forward) {
		return (Spliterator<MACTrieNode>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<MACTrieNode> allNodeSpliterator(boolean forward) {
		return (Spliterator<MACTrieNode>) super.allNodeSpliterator(forward);
	}
	@Override
	public MACTrieNode lowerAddedNode(MACAddress addr) {
		return (MACTrieNode) super.lowerAddedNode(addr);
	}
	@Override
	public MACTrieNode floorAddedNode(MACAddress addr) {
		return (MACTrieNode) super.floorAddedNode(addr);
	}
	@Override
	public MACTrieNode higherAddedNode(MACAddress addr) {
		return (MACTrieNode) super.higherAddedNode(addr);
	}
	@Override
	public MACTrieNode ceilingAddedNode(MACAddress addr) {
		return (MACTrieNode) super.ceilingAddedNode(addr);
	}
	@Override
	public MACTrieNode firstNode() {
		return (MACTrieNode) super.firstNode();
	}
	@Override
	public MACTrieNode lastNode() {
		return (MACTrieNode) super.lastNode();
	}
	@Override
	public MACTrieNode firstAddedNode() {
		return (MACTrieNode) super.firstAddedNode();
	}
	@Override
	public MACTrieNode lastAddedNode() {
		return (MACTrieNode) super.lastAddedNode();
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof MACAddressTrie && super.equals(o);
	}
	@Override
	public MACAddressTrie clone() {
		return (MACAddressTrie) super.clone();
	}
	@Override
	public AddedTree<MACAddress> constructAddedNodesTree() {
		MACAddressAssociativeTrie<SubNodesMappingBasic<MACAddress>> trie = new MACAddressAssociativeTrie<SubNodesMappingBasic<MACAddress>>();
		contructAddedTree(trie);
		return new AddedTree<MACAddress>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		MACAddressAssociativeTrie<SubNodesMappingBasic<MACAddress>> trie = new MACAddressAssociativeTrie<SubNodesMappingBasic<MACAddress>>();
		contructAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}
package inet.ipaddr.ipv4;
import java.util.Iterator;
import java.util.Spliterator;
import inet.ipaddr.IPAddressString;
import inet.ipaddr.format.util.AddedTree;
import inet.ipaddr.format.util.AddressTrie;
import inet.ipaddr.format.util.BinaryTreeNode;
import inet.ipaddr.format.util.BinaryTreeNode.CachingIterator;
public class IPv4AddressTrie extends AddressTrie<IPv4Address> {
	private static final long serialVersionUID = 1L;
	static final IPv4Address INIT_ROOT = new IPAddressString("0.0.0.0/0").getAddress().toIPv4();
	public IPv4AddressTrie() {
		super(new IPv4TrieNode());
	}
	protected IPv4AddressTrie(AddressBounds<IPv4Address> bounds) {
		super(new IPv4TrieNode(), bounds);
	}
	protected IPv4AddressTrie(IPv4TrieNode root, AddressBounds<IPv4Address> bounds) {
		super(root, bounds);
	}
	@Override
	protected IPv4TrieNode absoluteRoot() {
		return (IPv4TrieNode) super.absoluteRoot();
	}
	@Override
	protected IPv4AddressTrie createNew(AddressBounds<IPv4Address> bounds) {
		return new IPv4AddressTrie(bounds);
	}
	@Override
	protected IPv4AddressTrie createSubTrie(AddressBounds<IPv4Address> bounds) {
		return new IPv4AddressTrie(absoluteRoot(), bounds);
	}
	@Override
	public IPv4TrieNode getRoot() {
		return (IPv4TrieNode) super.getRoot();
	}
	public static class IPv4TrieNode extends TrieNode<IPv4Address> {
		private static final long serialVersionUID = 1L;
		protected IPv4TrieNode(IPv4Address addr) {
			super(addr);
		}
		public IPv4TrieNode() {
			super(INIT_ROOT);
		} 
		@Override
		protected void replaceThisRoot(BinaryTreeNode<IPv4Address> replacement) {
			super.replaceThisRoot(replacement);
			if(!FREEZE_ROOT && replacement == null) {
				setKey(INIT_ROOT);
			}
		}
		@Override
		public IPv4TrieNode getUpperSubNode() {
			return (IPv4TrieNode) super.getUpperSubNode();
		}
		@Override
		public IPv4TrieNode getLowerSubNode() {
			return (IPv4TrieNode) super.getLowerSubNode();
		}
		@Override
		public IPv4TrieNode getParent() {
			return (IPv4TrieNode) super.getParent();
		}
		@Override
		protected IPv4TrieNode createNewImpl(IPv4Address addr) {
			return new IPv4TrieNode(addr);
		}
		@Override
		public IPv4TrieNode removeElementsContainedBy(IPv4Address addr) {
			return (IPv4TrieNode) super.removeElementsContainedBy(addr);
		}
		@Override
		public IPv4TrieNode elementsContainedBy(IPv4Address addr) {
			return (IPv4TrieNode) super.elementsContainedBy(addr);
		}
		@Override
		public IPv4TrieNode elementsContaining(IPv4Address addr) {
			return (IPv4TrieNode) super.elementsContaining(addr);
		}
		@Override
		public IPv4TrieNode longestPrefixMatchNode(IPv4Address addr) {
			return (IPv4TrieNode) super.longestPrefixMatchNode(addr);
		}
		@Override
		public IPv4TrieNode getAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.getAddedNode(addr);
		}
		@Override
		public IPv4TrieNode getNode(IPv4Address addr) {
			return (IPv4TrieNode) super.getNode(addr);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> nodeIterator(boolean forward) {
			return (Iterator<IPv4TrieNode>) super.nodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> allNodeIterator(boolean forward) {
			return (Iterator<IPv4TrieNode>) super.allNodeIterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv4TrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
			return (Iterator<IPv4TrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv4TrieNode, IPv4Address, C> blockSizeCachingAllNodeIterator() {
			return (CachingIterator<IPv4TrieNode, IPv4Address, C>) super.blockSizeCachingAllNodeIterator();
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4TrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public <C> CachingIterator<IPv4TrieNode, IPv4Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (CachingIterator<IPv4TrieNode, IPv4Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4TrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Iterator<IPv4TrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
			return (Iterator<IPv4TrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv4TrieNode> nodeSpliterator(boolean forward) {
			return (Spliterator<IPv4TrieNode>) super.nodeSpliterator(forward);
		}
		@SuppressWarnings("unchecked")
		@Override
		public Spliterator<IPv4TrieNode> allNodeSpliterator(boolean forward) {
			return (Spliterator<IPv4TrieNode>) super.allNodeSpliterator(forward);
		}
		@Override
		public IPv4TrieNode previousAddedNode() {
			return (IPv4TrieNode) super.previousAddedNode();
		}
		@Override
		public IPv4TrieNode nextAddedNode() {
			return (IPv4TrieNode) super.nextAddedNode();
		}
		@Override
		public IPv4TrieNode nextNode() {
			return (IPv4TrieNode) super.nextNode();
		}
		@Override
		public IPv4TrieNode previousNode() {
			return (IPv4TrieNode) super.previousNode();
		}
		@Override
		public IPv4TrieNode lowerAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.lowerAddedNode(addr);
		}
		@Override
		public IPv4TrieNode floorAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.floorAddedNode(addr);
		}
		@Override
		public IPv4TrieNode higherAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.higherAddedNode(addr);
		}
		@Override
		public IPv4TrieNode ceilingAddedNode(IPv4Address addr) {
			return (IPv4TrieNode) super.ceilingAddedNode(addr);
		}
		@Override
		public IPv4TrieNode firstNode() {
			return (IPv4TrieNode) super.firstNode();
		}
		@Override
		public IPv4TrieNode lastNode() {
			return (IPv4TrieNode) super.lastNode();
		}
		@Override
		protected IPv4AddressTrie createNewTree() {
			return new IPv4AddressTrie();
		}
		@Override
		public IPv4AddressTrie asNewTrie() {
			return (IPv4AddressTrie) super.asNewTrie();
		}
		@Override
		public IPv4TrieNode cloneTree() {
			return (IPv4TrieNode) super.cloneTree();
		}
		@Override
		public IPv4TrieNode clone() {
			return (IPv4TrieNode) super.clone();
		}
		@Override
		public boolean equals(Object o) {
			return o instanceof IPv4TrieNode && super.equals(o);
		}
		static class IPv4TrieKeyData extends TrieKeyData {
			int uint32Val, mask32Val, nextBitMask32Val;
			@Override
			public boolean is32Bits() {
				return true;
			}
			@Override
			public int getUint32Val() {
				return uint32Val;
			}
			@Override
			public int getMask32Val() {
				return mask32Val;
			}
			@Override
			public int getNextBitMask32Val() {
				return nextBitMask32Val;
			}
		}
		@Override
		protected TrieKeyData getTrieKeyCache(IPv4Address addr) {
			return addr.getTrieKeyCache();
		}
	}
	@Override
	public IPv4TrieNode removeElementsContainedBy(IPv4Address addr) {
		return (IPv4TrieNode) super.removeElementsContainedBy(addr);
	}
	@Override
	public IPv4TrieNode elementsContainedBy(IPv4Address addr) {
		return (IPv4TrieNode) super.elementsContainedBy(addr);
	}
	@Override
	public IPv4TrieNode elementsContaining(IPv4Address addr) {
		return (IPv4TrieNode) super.elementsContaining(addr);
	}
	@Override
	public IPv4TrieNode longestPrefixMatchNode(IPv4Address addr) {
		return (IPv4TrieNode) super.longestPrefixMatchNode(addr);
	}
	@Override
	public IPv4TrieNode getAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.getAddedNode(addr);
	}
	@Override
	public IPv4TrieNode getNode(IPv4Address addr) {
		return (IPv4TrieNode) super.getNode(addr);
	}
	@Override
	public IPv4TrieNode addNode(IPv4Address addr) {
		return (IPv4TrieNode) super.addNode(addr);
	}
	@Override
	public IPv4TrieNode addTrie(TrieNode<IPv4Address> trie) {
		return (IPv4TrieNode) super.addTrie(trie);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> nodeIterator(boolean forward) {
		return (Iterator<IPv4TrieNode>) super.nodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> allNodeIterator(boolean forward) {
		return (Iterator<IPv4TrieNode>) super.allNodeIterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> blockSizeNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv4TrieNode>) super.blockSizeNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> blockSizeAllNodeIterator(boolean lowerSubNodeFirst) {
		return (Iterator<IPv4TrieNode>) super.blockSizeAllNodeIterator(lowerSubNodeFirst);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv4TrieNode, IPv4Address, C> blockSizeCachingAllNodeIterator() {
		return (CachingIterator<IPv4TrieNode, IPv4Address, C>) super.blockSizeCachingAllNodeIterator();
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> containingFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4TrieNode>) super.containingFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public <C> CachingIterator<IPv4TrieNode, IPv4Address, C> containingFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (CachingIterator<IPv4TrieNode, IPv4Address, C>) super.containingFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> containedFirstIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4TrieNode>) super.containedFirstIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Iterator<IPv4TrieNode> containedFirstAllNodeIterator(boolean forwardSubNodeOrder) {
		return (Iterator<IPv4TrieNode>) super.containedFirstAllNodeIterator(forwardSubNodeOrder);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv4TrieNode> nodeSpliterator(boolean forward) {
		return (Spliterator<IPv4TrieNode>) super.nodeSpliterator(forward);
	}
	@SuppressWarnings("unchecked")
	@Override
	public Spliterator<IPv4TrieNode> allNodeSpliterator(boolean forward) {
		return (Spliterator<IPv4TrieNode>) super.allNodeSpliterator(forward);
	}
	@Override
	public IPv4TrieNode lowerAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.lowerAddedNode(addr);
	}
	@Override
	public IPv4TrieNode floorAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.floorAddedNode(addr);
	}
	@Override
	public IPv4TrieNode higherAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.higherAddedNode(addr);
	}
	@Override
	public IPv4TrieNode ceilingAddedNode(IPv4Address addr) {
		return (IPv4TrieNode) super.ceilingAddedNode(addr);
	}
	@Override
	public IPv4TrieNode firstNode() {
		return (IPv4TrieNode) super.firstNode();
	}
	@Override
	public IPv4TrieNode lastNode() {
		return (IPv4TrieNode) super.lastNode();
	}
	@Override
	public IPv4AddressTrie clone() {
		return (IPv4AddressTrie) super.clone();
	}
	@Override
	public boolean equals(Object o) {
		return o instanceof IPv4AddressTrie && super.equals(o);
	}
	@Override
	public AddedTree<IPv4Address> constructAddedNodesTree() {
		IPv4AddressAssociativeTrie<SubNodesMappingBasic<IPv4Address>> trie = new IPv4AddressAssociativeTrie<SubNodesMappingBasic<IPv4Address>>();
		contructAddedTree(trie);
		return new AddedTree<IPv4Address>(trie);
	}
	@Override
	public String toAddedNodesTreeString() {
		IPv4AddressAssociativeTrie<SubNodesMappingBasic<IPv4Address>> trie = new IPv4AddressAssociativeTrie<SubNodesMappingBasic<IPv4Address>>();
		contructAddedTree(trie);
		return toAddedNodesTreeString(trie);
	}
}