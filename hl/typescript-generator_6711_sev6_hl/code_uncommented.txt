package cz.habarta.typescript.generator.compiler;
import cz.habarta.typescript.generator.DateMapping;
import cz.habarta.typescript.generator.EnumMapping;
import cz.habarta.typescript.generator.Extension;
import cz.habarta.typescript.generator.IdentifierCasing;
import cz.habarta.typescript.generator.MapMapping;
import cz.habarta.typescript.generator.NullabilityDefinition;
import cz.habarta.typescript.generator.OptionalPropertiesDeclaration;
import cz.habarta.typescript.generator.RestNamespacing;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TsParameter;
import cz.habarta.typescript.generator.TsProperty;
import cz.habarta.typescript.generator.TsType;
import cz.habarta.typescript.generator.TypeProcessor;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.emitter.EmitterExtension;
import cz.habarta.typescript.generator.emitter.TsAccessibilityModifier;
import cz.habarta.typescript.generator.emitter.TsAliasModel;
import cz.habarta.typescript.generator.emitter.TsAssignmentExpression;
import cz.habarta.typescript.generator.emitter.TsBeanCategory;
import cz.habarta.typescript.generator.emitter.TsBeanModel;
import cz.habarta.typescript.generator.emitter.TsCallExpression;
import cz.habarta.typescript.generator.emitter.TsConstructorModel;
import cz.habarta.typescript.generator.emitter.TsEnumModel;
import cz.habarta.typescript.generator.emitter.TsExpression;
import cz.habarta.typescript.generator.emitter.TsExpressionStatement;
import cz.habarta.typescript.generator.emitter.TsHelper;
import cz.habarta.typescript.generator.emitter.TsIdentifierReference;
import cz.habarta.typescript.generator.emitter.TsMemberExpression;
import cz.habarta.typescript.generator.emitter.TsMethodModel;
import cz.habarta.typescript.generator.emitter.TsModel;
import cz.habarta.typescript.generator.emitter.TsModifierFlags;
import cz.habarta.typescript.generator.emitter.TsObjectLiteral;
import cz.habarta.typescript.generator.emitter.TsParameterModel;
import cz.habarta.typescript.generator.emitter.TsPropertyDefinition;
import cz.habarta.typescript.generator.emitter.TsPropertyModel;
import cz.habarta.typescript.generator.emitter.TsReturnStatement;
import cz.habarta.typescript.generator.emitter.TsStatement;
import cz.habarta.typescript.generator.emitter.TsStringLiteral;
import cz.habarta.typescript.generator.emitter.TsSuperExpression;
import cz.habarta.typescript.generator.emitter.TsTaggedTemplateLiteral;
import cz.habarta.typescript.generator.emitter.TsTemplateLiteral;
import cz.habarta.typescript.generator.emitter.TsThisExpression;
import cz.habarta.typescript.generator.parser.BeanModel;
import cz.habarta.typescript.generator.parser.EnumModel;
import cz.habarta.typescript.generator.parser.MethodModel;
import cz.habarta.typescript.generator.parser.MethodParameterModel;
import cz.habarta.typescript.generator.parser.Model;
import cz.habarta.typescript.generator.parser.PathTemplate;
import cz.habarta.typescript.generator.parser.PropertyAccess;
import cz.habarta.typescript.generator.parser.PropertyModel;
import cz.habarta.typescript.generator.parser.RestApplicationModel;
import cz.habarta.typescript.generator.parser.RestMethodModel;
import cz.habarta.typescript.generator.parser.RestQueryParam;
import cz.habarta.typescript.generator.type.JTypeWithNullability;
import cz.habarta.typescript.generator.util.GenericsResolver;
import cz.habarta.typescript.generator.util.Pair;
import cz.habarta.typescript.generator.util.Utils;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class ModelCompiler {
    private final Settings settings;
    private final TypeProcessor typeProcessor;
    public ModelCompiler(Settings settings, TypeProcessor typeProcessor) {
        this.settings = settings;
        this.typeProcessor = typeProcessor;
    }
    public enum TransformationPhase {
        BeforeTsModel,
        BeforeEnums,
        BeforeSymbolResolution,
        AfterDeclarationSorting,
    }
    public TsModel javaToTypeScript(Model model) {
        final SymbolTable symbolTable = new SymbolTable(settings);
        final List<Extension.TransformerDefinition> extensionTransformers = getExtensionTransformers();
        model = applyExtensionModelTransformers(symbolTable, model, extensionTransformers);
        TsModel tsModel = processModel(symbolTable, model);
        tsModel = addCustomTypeAliases(symbolTable, tsModel);
        tsModel = removeInheritedProperties(symbolTable, tsModel);
        tsModel = addImplementedProperties(symbolTable, tsModel);
        tsModel = sortPropertiesDeclarations(symbolTable, tsModel);
        if (settings.generateConstructors) {
            tsModel = addConstructors(symbolTable, tsModel);
        }
        if (settings.isGenerateRest()) {
            final Symbol responseSymbol = createRestResponseType(symbolTable, tsModel);
            final TsType optionsType = settings.restOptionsType != null
                    ? new TsType.VerbatimType(settings.restOptionsType)
                    : null;
            final TsType.GenericVariableType optionsGenericVariable = settings.restOptionsTypeIsGeneric
                    ? new TsType.GenericVariableType(settings.restOptionsType)
                    : null;
            final List<RestApplicationModel> restApplicationsWithInterface = model.getRestApplications().stream()
                    .filter(restApplication -> restApplication.getType().generateInterface.apply(settings))
                    .collect(Collectors.toList());
            final List<RestApplicationModel> restApplicationsWithClient = model.getRestApplications().stream()
                    .filter(restApplication -> restApplication.getType().generateClient.apply(settings))
                    .collect(Collectors.toList());
            if (!restApplicationsWithInterface.isEmpty()) {
                createRestInterfaces(tsModel, symbolTable, restApplicationsWithInterface, responseSymbol, optionsGenericVariable, optionsType);
            }
            if (!restApplicationsWithClient.isEmpty()) {
                createRestClients(tsModel, symbolTable, restApplicationsWithClient, responseSymbol, optionsGenericVariable, optionsType);
            }
        }
        tsModel = transformMaps(symbolTable, tsModel);
        tsModel = transformDates(symbolTable, tsModel);
        tsModel = applyExtensionTransformers(symbolTable, model, tsModel, TransformationPhase.BeforeEnums, extensionTransformers);
        tsModel = addEnumValuesToJavadoc(tsModel);
        if (settings.enumMemberCasing != null && settings.enumMemberCasing != IdentifierCasing.keepOriginal) {
            tsModel = transformEnumMembersCase(tsModel);
        }
        if (!settings.areDefaultStringEnumsOverriddenByExtension()) {
            if (settings.mapEnum == null || settings.mapEnum == EnumMapping.asUnion || settings.mapEnum == EnumMapping.asInlineUnion) {
                tsModel = transformEnumsToUnions(tsModel);
            }
            if (settings.mapEnum == EnumMapping.asInlineUnion) {
                tsModel = inlineEnums(tsModel, symbolTable);
            }
            if (settings.mapEnum == EnumMapping.asNumberBasedEnum) {
                tsModel = transformEnumsToNumberBasedEnum(tsModel);
            }
        }
        tsModel = transformNonStringEnumKeyMaps(symbolTable, tsModel);
        tsModel = createAndUseTaggedUnions(symbolTable, tsModel);
        tsModel = makeUndefinablePropertiesAndParametersOptional(symbolTable, tsModel);
        tsModel = transformNullableTypes(symbolTable, tsModel);
        tsModel = eliminateUndefinedFromOptionalPropertiesAndParameters(symbolTable, tsModel);
        tsModel = transformOptionalProperties(symbolTable, tsModel);
        tsModel = applyExtensionTransformers(symbolTable, model, tsModel, TransformationPhase.BeforeSymbolResolution, extensionTransformers);
        symbolTable.resolveSymbolNames();
        tsModel = sortTypeDeclarations(symbolTable, tsModel);
        tsModel = applyExtensionTransformers(symbolTable, model, tsModel, TransformationPhase.AfterDeclarationSorting, extensionTransformers);
        return tsModel;
    }
    private List<Extension.TransformerDefinition> getExtensionTransformers() {
        final List<Extension.TransformerDefinition> transformers = new ArrayList<>();
        for (EmitterExtension emitterExtension : settings.extensions) {
            if (emitterExtension instanceof Extension) {
                final Extension extension = (Extension) emitterExtension;
                transformers.addAll(extension.getTransformers());
            }
        }
        return transformers;
    }
    private static Model applyExtensionModelTransformers(SymbolTable symbolTable, Model model,
            List<Extension.TransformerDefinition> transformerDefinitions
    ) {
        for (Extension.TransformerDefinition definition : transformerDefinitions) {
            if (definition.phase == TransformationPhase.BeforeTsModel) {
                model = definition.transformer.transformModel(symbolTable, model);
            }
        }
        return model;
    }
    private static TsModel applyExtensionTransformers(SymbolTable symbolTable, Model model, TsModel tsModel,
            TransformationPhase phase, List<Extension.TransformerDefinition> transformerDefinitions
    ) {
        final TsModelTransformer.Context context = new TsModelTransformer.Context(symbolTable, model);
        for (Extension.TransformerDefinition definition : transformerDefinitions) {
            if (definition.phase == phase) {
                tsModel = definition.tsTransformer.transformModel(context, tsModel);
            }
        }
        return tsModel;
    }
    public TsType javaToTypeScript(Type type) {
        final BeanModel beanModel = new BeanModel(Object.class, Object.class, null, null, null, Collections.<Type>emptyList(),
                Collections.singletonList(new PropertyModel("property", type, false, null, null, null, null, null)), null);
        final Model model = new Model(Collections.singletonList(beanModel), Collections.<EnumModel>emptyList(), null);
        final TsModel tsModel = javaToTypeScript(model);
        return tsModel.getBeans().get(0).getProperties().get(0).getTsType();
    }
    private TsModel processModel(SymbolTable symbolTable, Model model) {
        final Map<Type, List<BeanModel>> children = createChildrenMap(model);
        final List<TsBeanModel> beans = new ArrayList<>();
        for (BeanModel bean : model.getBeans()) {
            beans.add(processBean(symbolTable, model, children, bean));
        }
        final List<TsEnumModel> enums = new ArrayList<>();
        final List<TsEnumModel> stringEnums = new ArrayList<>();
        for (EnumModel enumModel : model.getEnums()) {
            final TsEnumModel tsEnumModel = processEnum(symbolTable, enumModel);
            enums.add(tsEnumModel);
            if (tsEnumModel.getKind() == EnumKind.StringBased) {
                stringEnums.add(tsEnumModel);
            }
        }
        return new TsModel().withBeans(beans).withEnums(enums).withOriginalStringEnums(stringEnums);
    }
    private Map<Type, List<BeanModel>> createChildrenMap(Model model) {
        final Map<Type, List<BeanModel>> children = new LinkedHashMap<>();
        for (BeanModel bean : model.getBeans()) {
            for (Type ancestor : bean.getParentAndInterfaces()) {
                final Type processedAncestor = Utils.getRawClassOrNull(ancestor);
                if (!children.containsKey(processedAncestor)) {
                    children.put(processedAncestor, new ArrayList<>());
                }
                children.get(processedAncestor).add(bean);
            }
        }
        return children;
    }
    private <T> TsBeanModel processBean(SymbolTable symbolTable, Model model, Map<Type, List<BeanModel>> children, BeanModel bean) {
        final boolean isClass = mappedToClass(bean.getOrigin());
        final List<TsType> extendsList = new ArrayList<>();
        final List<TsType> implementsList = new ArrayList<>();
        final TsType parentTypeFromJava = typeFromJava(symbolTable, bean.getParent());
        final TsType parentType = parentTypeFromJava != null && !parentTypeFromJava.equals(TsType.Any)
                ? parentTypeFromJava
                : null;
        if (parentType != null) {
            final boolean isParentMappedToClass = mappedToClass(getOriginClass(symbolTable, parentType));
            if (isClass && !isParentMappedToClass) {
                implementsList.add(parentType);
            } else {
                extendsList.add(parentType);
            }
        }
        final List<TsType> interfaces = new ArrayList<>();
        for (Type aInterface : bean.getInterfaces()) {
            final TsType interfaceType = typeFromJava(symbolTable, aInterface);
            if (!interfaceType.equals(TsType.Any)) {
                interfaces.add(interfaceType);
            }
        }
        if (isClass) {
            implementsList.addAll(interfaces);
        } else {
            extendsList.addAll(interfaces);
        }
        final List<TsPropertyModel> properties = processProperties(symbolTable, model, bean);
        boolean isTaggedUnion = false;
        if (bean.getDiscriminantProperty() != null && bean.getProperty(bean.getDiscriminantProperty()) == null) {
            isTaggedUnion = true;
            boolean isDisciminantProperty = true;
            final List<BeanModel> selfAndDescendants = getSelfAndDescendants(bean, children);
            final List<TsType.StringLiteralType> literals = new ArrayList<>();
            for (BeanModel descendant : selfAndDescendants) {
                if (descendant.getDiscriminantProperty() == null || descendant.getProperty(bean.getDiscriminantProperty()) != null) {
                    isTaggedUnion = false;
                    isDisciminantProperty = false;
                }
                if (descendant.getDiscriminantLiteral() != null) {
                    literals.add(new TsType.StringLiteralType(descendant.getDiscriminantLiteral()));
                }
            }
            final List<BeanModel> descendants = selfAndDescendants.subList(1, selfAndDescendants.size());
            for (BeanModel descendant : descendants) {
                final List<String> mappedGenericVariables = GenericsResolver.mapGenericVariablesToBase(descendant.getOrigin(), bean.getOrigin());
                if (mappedGenericVariables.contains(null)) {
                    isTaggedUnion = false;
                }
            }
            final TsType discriminantType = isDisciminantProperty && !literals.isEmpty()
                    ? new TsType.UnionType(literals)
                    : TsType.String;
            final TsModifierFlags modifiers = TsModifierFlags.None.setReadonly(settings.declarePropertiesAsReadOnly);
            properties.add(0, new TsPropertyModel(bean.getDiscriminantProperty(), discriminantType, modifiers,  true, null));
        }
        final TsBeanModel tsBean = new TsBeanModel(
                bean.getOrigin(),
                TsBeanCategory.Data,
                isClass,
                symbolTable.getSymbol(bean.getOrigin()),
                getTypeParameters(bean.getOrigin()),
                parentType,
                extendsList,
                implementsList,
                properties,
                 null,
                 null,
                bean.getComments());
        return isTaggedUnion
                ? tsBean.withTaggedUnion(bean.getTaggedUnionClasses(), bean.getDiscriminantProperty(), bean.getDiscriminantLiteral())
                : tsBean;
    }
    private boolean mappedToClass(Class<?> cls) {
        return cls != null && !cls.isInterface() && settings.getMapClassesAsClassesFilter().test(cls.getName());
    }
    private static List<TsType.GenericVariableType> getTypeParameters(Class<?> cls) {
        final List<TsType.GenericVariableType> typeParameters = new ArrayList<>();
        for (TypeVariable<?> typeParameter : cls.getTypeParameters()) {
            typeParameters.add(new TsType.GenericVariableType(typeParameter.getName()));
        }
        return typeParameters;
    }
    private List<TsPropertyModel> processProperties(SymbolTable symbolTable, Model model, BeanModel bean) {
        return processProperties(symbolTable, model, bean, "", "");
    }
    private List<TsPropertyModel> processProperties(SymbolTable symbolTable, Model model, BeanModel bean, String prefix, String suffix) {
        final List<TsPropertyModel> properties = new ArrayList<>();
        for (PropertyModel property : bean.getProperties()) {
            boolean pulled = false;
            final PropertyModel.PullProperties pullProperties = property.getPullProperties();
            if (pullProperties != null) {
                final Type type = JTypeWithNullability.getPlainType(property.getType());
                if (type instanceof Class<?>) {
                    final BeanModel pullBean = model.getBean((Class<?>) type);
                    if (pullBean != null) {
                        properties.addAll(processProperties(symbolTable, model, pullBean, prefix + pullProperties.prefix, pullProperties.suffix + suffix));
                        pulled = true;
                    }
                }
            }
            if (!pulled) {
                properties.add(processProperty(symbolTable, bean, property, prefix, suffix));
            }
        }
        return properties;
    }
    private static List<BeanModel> getSelfAndDescendants(BeanModel bean, Map<Type, List<BeanModel>> children) {
        final List<BeanModel> descendants = new ArrayList<>();
        descendants.add(bean);
        final List<BeanModel> directDescendants = children.get(bean.getOrigin());
        if (directDescendants != null) {
            for (BeanModel descendant : directDescendants) {
                descendants.addAll(getSelfAndDescendants(descendant, children));
            }
        }
        return descendants;
    }
    private TsPropertyModel processProperty(SymbolTable symbolTable, BeanModel bean, PropertyModel property, String prefix, String suffix) {
        final TsType type = typeFromJava(symbolTable, property.getType(), property.getContext(), property.getName(), bean.getOrigin());
        final TsType tsType = property.isOptional() ? type.optional() : type;
        final TsModifierFlags modifiers = TsModifierFlags.None.setReadonly(settings.declarePropertiesAsReadOnly);
        final List<String> comments = settings.generateReadonlyAndWriteonlyJSDocTags
                ? Utils.concat(property.getComments(), getPropertyAccessComments(property.getAccess()))
                : property.getComments();
        return new TsPropertyModel(prefix + property.getName() + suffix, tsType, modifiers,  false, comments);
    }
    private static List<String> getPropertyAccessComments(PropertyAccess access) {
        final String accessTag =
                access == PropertyAccess.ReadOnly ? "@readonly" :
                access == PropertyAccess.WriteOnly ? "@writeonly" :
                null;
        return accessTag != null ? Collections.singletonList(accessTag) : null;
    }
    private TsEnumModel processEnum(SymbolTable symbolTable, EnumModel enumModel) {
        final Symbol beanIdentifier = symbolTable.getSymbol(enumModel.getOrigin());
        TsEnumModel tsEnumModel = TsEnumModel.fromEnumModel(beanIdentifier, enumModel, isEnumNonConst(enumModel));
        return tsEnumModel;
    }
    private boolean isEnumNonConst(EnumModel enumModel) {
        boolean isNonConst = settings.nonConstEnums;
        if (!isNonConst) {
            for (Class<? extends Annotation> nonConstAnnotation : settings.nonConstEnumAnnotations) {
                if (enumModel.getOrigin().isAnnotationPresent(nonConstAnnotation)) {
                    isNonConst = true;
                    break;
                }
            }
        }
        return isNonConst;
    }
    private TsType typeFromJava(SymbolTable symbolTable, Type javaType) {
        return typeFromJava(symbolTable, javaType, null, null);
    }
    private TsType typeFromJava(SymbolTable symbolTable, Type javaType, String usedInProperty, Class<?> usedInClass) {
        return typeFromJava(symbolTable, javaType, null, usedInProperty, usedInClass);
    }
    private TsType typeFromJava(SymbolTable symbolTable, Type javaType, Object typeContext, String usedInProperty, Class<?> usedInClass) {
        if (javaType == null) {
            return null;
        }
        final TypeProcessor.Context context = new TypeProcessor.Context(symbolTable, typeProcessor, typeContext);
        final TypeProcessor.Result result = context.processType(javaType);
        if (result != null) {
            return result.getTsType();
        } else {
            if (usedInClass != null && usedInProperty != null) {
                TypeScriptGenerator.getLogger().warning(String.format("Unsupported type '%s' used in '%s.%s'", javaType, usedInClass.getSimpleName(), usedInProperty));
            } else {
                TypeScriptGenerator.getLogger().warning(String.format("Unsupported type '%s'", javaType));
            }
            return TsType.Any;
        }
    }
    private TsModel addCustomTypeAliases(SymbolTable symbolTable, TsModel tsModel) {
        final List<TsAliasModel> aliases = new ArrayList<>(tsModel.getTypeAliases());
        for (Settings.CustomTypeAlias customTypeAlias : settings.getValidatedCustomTypeAliases()) {
            final Symbol name = symbolTable.getSyntheticSymbol(customTypeAlias.tsType.rawName);
            final List<TsType.GenericVariableType> typeParameters = customTypeAlias.tsType.typeParameters != null
                    ? customTypeAlias.tsType.typeParameters.stream()
                            .map(TsType.GenericVariableType::new)
                            .collect(Collectors.toList())
                    : null;
            final TsType definition = new TsType.VerbatimType(customTypeAlias.tsDefinition);
            aliases.add(new TsAliasModel(null, name, typeParameters, definition, null));
        }
        return tsModel.withTypeAliases(aliases);
    }
    private TsModel removeInheritedProperties(SymbolTable symbolTable, TsModel tsModel) {
        final List<TsBeanModel> beans = new ArrayList<>();
        for (TsBeanModel bean : tsModel.getBeans()) {
            final Map<String, TsType> inheritedPropertyTypes = getInheritedProperties(symbolTable, tsModel, bean.getAllParents());
            final List<TsPropertyModel> properties = new ArrayList<>();
            for (TsPropertyModel property : bean.getProperties()) {
                if (property.isOwnProperty() || !Objects.equals(property.getTsType(), inheritedPropertyTypes.get(property.getName()))) {
                    properties.add(property);
                }
            }
            beans.add(bean.withProperties(properties));
        }
        return tsModel.withBeans(beans);
    }
    private TsModel addImplementedProperties(SymbolTable symbolTable, TsModel tsModel) {
        final List<TsBeanModel> beans = new ArrayList<>();
        for (TsBeanModel bean : tsModel.getBeans()) {
            if (bean.isClass()) {
                final List<TsPropertyModel> resultProperties = new ArrayList<>(bean.getProperties());
                final Set<String> classPropertyNames = new LinkedHashSet<>();
                for (TsPropertyModel property : bean.getProperties()) {
                    classPropertyNames.add(property.getName());
                }
                classPropertyNames.addAll(getInheritedProperties(symbolTable, tsModel, bean.getExtendsList()).keySet());
                final List<TsPropertyModel> implementedProperties = getImplementedProperties(symbolTable, tsModel, bean.getImplementsList());
                Collections.reverse(implementedProperties);
                for (TsPropertyModel implementedProperty : implementedProperties) {
                    if (!classPropertyNames.contains(implementedProperty.getName())) {
                        resultProperties.add(0, implementedProperty);
                        classPropertyNames.add(implementedProperty.getName());
                    }
                }
                beans.add(bean.withProperties(resultProperties));
            } else {
                beans.add(bean);
            }
        }
        return tsModel.withBeans(beans);
    }
    private TsModel addConstructors(SymbolTable symbolTable, TsModel tsModel) {
        final List<TsBeanModel> beans = new ArrayList<>();
        for (TsBeanModel bean : tsModel.getBeans()) {
            final Symbol beanIdentifier = symbolTable.getSymbol(bean.getOrigin());
            final List<TsType.GenericVariableType> typeParameters = getTypeParameters(bean.getOrigin());
            final TsType.ReferenceType dataType = typeParameters.isEmpty()
                    ? new TsType.ReferenceType(beanIdentifier)
                    : new TsType.GenericReferenceType(beanIdentifier, typeParameters);
            final List<TsStatement> body = new ArrayList<>();
            if (bean.getParent() != null) {
                body.add(new TsExpressionStatement(
                        new TsCallExpression(
                                new TsSuperExpression(),
                                new TsIdentifierReference("data")
                        )
                ));
            }
            for (TsPropertyModel property : bean.getProperties()) {
                final Map<String, TsType> inheritedProperties = ModelCompiler.getInheritedProperties(symbolTable, tsModel, Utils.listFromNullable(bean.getParent()));
                if (!inheritedProperties.containsKey(property.getName())) {
                    body.add(new TsExpressionStatement(new TsAssignmentExpression(
                            new TsMemberExpression(new TsThisExpression(), property.name),
                            new TsMemberExpression(new TsIdentifierReference("data"), property.name)
                    )));
                }
            }
            if (bean.isClass()) {
                final TsConstructorModel constructor = new TsConstructorModel(
                        TsModifierFlags.None,
                        Arrays.asList(new TsParameterModel("data", dataType)),
                        body,
                         null
                );
                beans.add(bean.withConstructor(constructor));
            } else {
                beans.add(bean);
            }
        }
        return tsModel.withBeans(beans);
    }
    public static Map<String, TsType> getInheritedProperties(SymbolTable symbolTable, TsModel tsModel, List<TsType> parents) {
        final Map<String, TsType> properties = new LinkedHashMap<>();
        for (TsType parentType : parents) {
            final TsBeanModel parent = tsModel.getBean(getOriginClass(symbolTable, parentType));
            if (parent != null) {
                properties.putAll(getInheritedProperties(symbolTable, tsModel, parent.getAllParents()));
                for (TsPropertyModel property : parent.getProperties()) {
                    properties.put(property.getName(), property.getTsType());
                }
            }
        }
        return properties;
    }
    private static List<TsPropertyModel> getImplementedProperties(SymbolTable symbolTable, TsModel tsModel, List<TsType> interfaces) {
        final List<TsPropertyModel> properties = new ArrayList<>();
        for (TsType aInterface : interfaces) {
            final TsBeanModel bean = tsModel.getBean(getOriginClass(symbolTable, aInterface));
            if (bean != null) {
                properties.addAll(getImplementedProperties(symbolTable, tsModel, bean.getExtendsList()));
                properties.addAll(bean.getProperties());
            }
        }
        return properties;
    }
    private Symbol createRestResponseType(SymbolTable symbolTable, TsModel tsModel) {
        final Symbol responseSymbol = symbolTable.getSyntheticSymbol("RestResponse");
        final TsType.GenericVariableType varR = new TsType.GenericVariableType("R");
        final TsAliasModel responseTypeAlias;
        if (settings.restResponseType != null) {
            responseTypeAlias = new TsAliasModel(null, responseSymbol, Arrays.asList(varR), new TsType.VerbatimType(settings.restResponseType), null);
        } else {
            final TsType.GenericReferenceType responseTypeDefinition = new TsType.GenericReferenceType(symbolTable.getSyntheticSymbol("Promise"), varR);
            responseTypeAlias = new TsAliasModel(null, responseSymbol, Arrays.asList(varR), responseTypeDefinition, null);
        }
        tsModel.getTypeAliases().add(responseTypeAlias);
        return responseSymbol;
    }
    private void createRestInterfaces(TsModel tsModel, SymbolTable symbolTable, List<RestApplicationModel> restApplications,
            Symbol responseSymbol, TsType.GenericVariableType optionsGenericVariable, TsType optionsType) {
        final List<TsType.GenericVariableType> typeParameters = Utils.listFromNullable(optionsGenericVariable);
        final Map<Symbol, List<TsMethodModel>> groupedMethods = processRestMethods(tsModel, restApplications, symbolTable, null, responseSymbol, optionsType, false);
        for (Map.Entry<Symbol, List<TsMethodModel>> entry : groupedMethods.entrySet()) {
            final TsBeanModel interfaceModel = new TsBeanModel(null, TsBeanCategory.Service, false, entry.getKey(), typeParameters, null, null, null, null, null, entry.getValue(), null);
            tsModel.getBeans().add(interfaceModel);
        }
    }
    private void createRestClients(TsModel tsModel, SymbolTable symbolTable, List<RestApplicationModel> restApplications,
            Symbol responseSymbol, TsType.GenericVariableType optionsGenericVariable, TsType optionsType) {
        final Symbol httpClientSymbol = symbolTable.getSyntheticSymbol("HttpClient");
        final List<TsType.GenericVariableType> typeParameters = Utils.listFromNullable(optionsGenericVariable);
        final TsType.GenericVariableType returnGenericVariable = new TsType.GenericVariableType("R");
        tsModel.getBeans().add(new TsBeanModel(null, TsBeanCategory.ServicePrerequisite, false, httpClientSymbol, typeParameters, null, null, null, null, null, Arrays.asList(
                new TsMethodModel("request", TsModifierFlags.None, Arrays.asList(returnGenericVariable), Arrays.asList(
                        new TsParameterModel("requestConfig", new TsType.ObjectType(
                                new TsProperty("method", TsType.String),
                                new TsProperty("url", TsType.String),
                                new TsProperty("queryParams", new TsType.OptionalType(TsType.Any)),
                                new TsProperty("data", new TsType.OptionalType(TsType.Any)),
                                new TsProperty("copyFn", new TsType.OptionalType(new TsType.FunctionType(Arrays.asList(new TsParameter("data", returnGenericVariable)), returnGenericVariable))),
                                optionsType != null ? new TsProperty("options", new TsType.OptionalType(optionsType)) : null
                        ))
                ), new TsType.GenericReferenceType(responseSymbol, returnGenericVariable), null, null)
        ), null));
        final TsType.ReferenceType httpClientType = optionsGenericVariable != null
                ? new TsType.GenericReferenceType(httpClientSymbol, optionsGenericVariable)
                : new TsType.ReferenceType(httpClientSymbol);
        final TsConstructorModel constructor = new TsConstructorModel(
                TsModifierFlags.None,
                Arrays.asList(new TsParameterModel(TsAccessibilityModifier.Protected, "httpClient", httpClientType)),
                Collections.<TsStatement>emptyList(),
                null
        );
        final boolean bothInterfacesAndClients = settings.generateJaxrsApplicationInterface || settings.generateSpringApplicationInterface;
        final String groupingSuffix = bothInterfacesAndClients ? null : "Client";
        final Map<Symbol, List<TsMethodModel>> groupedMethods = processRestMethods(tsModel, restApplications, symbolTable, groupingSuffix, responseSymbol, optionsType, true);
        for (Map.Entry<Symbol, List<TsMethodModel>> entry : groupedMethods.entrySet()) {
            final Symbol symbol = bothInterfacesAndClients ? symbolTable.addSuffixToSymbol(entry.getKey(), "Client") : entry.getKey();
            final TsType interfaceType = bothInterfacesAndClients ? new TsType.ReferenceType(entry.getKey()) : null;
            final TsBeanModel clientModel = new TsBeanModel(null, TsBeanCategory.Service, true, symbol, typeParameters, null, null,
                    Utils.listFromNullable(interfaceType), null, constructor, entry.getValue(), null);
            tsModel.getBeans().add(clientModel);
        }
        tsModel.getHelpers().add(TsHelper.loadFromResource("/helpers/uriEncoding.ts"));
    }
    private Map<Symbol, List<TsMethodModel>> processRestMethods(TsModel tsModel, List<RestApplicationModel> restApplications, SymbolTable symbolTable, String nameSuffix, Symbol responseSymbol, TsType optionsType, boolean implement) {
        final Map<Symbol, List<TsMethodModel>> result = new LinkedHashMap<>();
        final Map<Symbol, List<Pair<RestApplicationModel, RestMethodModel>>> groupedMethods = groupingByMethodContainer(restApplications, symbolTable, nameSuffix);
        for (Map.Entry<Symbol, List<Pair<RestApplicationModel, RestMethodModel>>> entry : groupedMethods.entrySet()) {
            result.put(entry.getKey(), processRestMethodGroup(tsModel, symbolTable, entry.getValue(), responseSymbol, optionsType, implement));
        }
        return result;
    }
    private List<TsMethodModel> processRestMethodGroup(TsModel tsModel, SymbolTable symbolTable, List<Pair<RestApplicationModel, RestMethodModel>> methods, Symbol responseSymbol, TsType optionsType, boolean implement) {
        final List<TsMethodModel> resultMethods = new ArrayList<>();
        final Map<String, Long> methodNamesCount = groupingByMethodName(methods);
        for (Pair<RestApplicationModel, RestMethodModel> pair : methods) {
            final RestApplicationModel restApplication = pair.getValue1();
            final RestMethodModel method = pair.getValue2();
            final boolean createLongName = methodNamesCount.get(method.getName()) > 1;
            resultMethods.add(processRestMethod(tsModel, symbolTable, restApplication.getApplicationPath(), responseSymbol, method, createLongName, optionsType, implement));
        }
        return resultMethods;
    }
    private Map<Symbol, List<Pair<RestApplicationModel, RestMethodModel>>> groupingByMethodContainer(List<RestApplicationModel> restApplications, SymbolTable symbolTable, String nameSuffix) {
        return restApplications.stream()
                .flatMap(restApplication -> restApplication.getMethods().stream().map(method -> Pair.of(restApplication, method)))
                .collect(Collectors.groupingBy(
                        pair -> getContainerSymbol(pair.getValue1(), symbolTable, nameSuffix, pair.getValue2()),
                        Utils.toSortedList(Comparator.comparing(pair -> pair.getValue2().getPath()))
                ));
    }
    private Symbol getContainerSymbol(RestApplicationModel restApplication, SymbolTable symbolTable, String nameSuffix, RestMethodModel method) {
        if (settings.restNamespacing == RestNamespacing.perResource) {
            return symbolTable.getSymbol(method.getRootResource(), nameSuffix);
        }
        if (settings.restNamespacing == RestNamespacing.byAnnotation) {
            final Annotation annotation = method.getRootResource().getAnnotation(settings.restNamespacingAnnotation);
            final String element = settings.restNamespacingAnnotationElement != null ? settings.restNamespacingAnnotationElement : "value";
            final String annotationValue = Utils.getAnnotationElementValue(annotation, element, String.class);
            if (annotationValue != null) {
                if (isValidIdentifierName(annotationValue)) {
                    return symbolTable.getSyntheticSymbol(annotationValue, nameSuffix);
                } else {
                    TypeScriptGenerator.getLogger().warning(String.format("Ignoring annotation value '%s' since it is not a valid identifier, '%s' will be in default namespace", annotationValue, method.getOriginClass().getName() + "." + method.getName()));
                }
            }
        }
        final String applicationName = getApplicationName(restApplication);
        return symbolTable.getSyntheticSymbol(applicationName, nameSuffix);
    }
    private static String getApplicationName(RestApplicationModel restApplication) {
        return restApplication.getApplicationName() != null ? restApplication.getApplicationName() : "RestApplication";
    }
    private static Map<String, Long> groupingByMethodName(List<Pair<RestApplicationModel, RestMethodModel>> methods) {
        return methods.stream()
                .map(pair -> pair.getValue2())
                .collect(Collectors.groupingBy(RestMethodModel::getName, Collectors.counting()));
    }
    private TsMethodModel processRestMethod(TsModel tsModel, SymbolTable symbolTable, String pathPrefix, Symbol responseSymbol, RestMethodModel method, boolean createLongName, TsType optionsType, boolean implement) {
        final String path = Utils.joinPath(pathPrefix, method.getPath());
        final PathTemplate pathTemplate = PathTemplate.parse(path);
        final List<String> comments = Utils.concat(method.getComments(), Arrays.asList(
            "HTTP " + method.getHttpMethod() + " /" + path,
            "Java method: " + method.getOriginClass().getName() + "." + method.getName()
        ));
        final List<TsParameterModel> parameters = new ArrayList<>();
        for (MethodParameterModel parameter : method.getPathParams()) {
            parameters.add(processParameter(symbolTable, method, parameter));
        }
        if (method.getEntityParam() != null) {
            parameters.add(processParameter(symbolTable, method, method.getEntityParam()));
        }
        final List<RestQueryParam> queryParams = method.getQueryParams();
        final TsParameterModel queryParameter;
        if (queryParams != null && !queryParams.isEmpty()) {
            final List<TsType> types = new ArrayList<>();
            if (queryParams.stream().anyMatch(param -> param instanceof RestQueryParam.Map)) {
                types.add(new TsType.IndexedArrayType(TsType.String, TsType.Any));
            } else {
                final List<TsProperty> currentSingles = new ArrayList<>();
                final Runnable flushSingles = () -> {
                    if (!currentSingles.isEmpty()) {
                        types.add(new TsType.ObjectType(currentSingles));
                        currentSingles.clear();
                    }
                };
                for (RestQueryParam restQueryParam : queryParams) {
                    if (restQueryParam instanceof RestQueryParam.Single) {
                        final MethodParameterModel queryParam = ((RestQueryParam.Single) restQueryParam).getQueryParam();
                        final TsType type = typeFromJava(symbolTable, queryParam.getType(), method.getName(), method.getOriginClass());
                        currentSingles.add(new TsProperty(queryParam.getName(), restQueryParam.required ? type : new TsType.OptionalType(type)));
                    }
                    if (restQueryParam instanceof RestQueryParam.Bean) {
                        final BeanModel queryBean = ((RestQueryParam.Bean) restQueryParam).getBean();
                        flushSingles.run();
                        final Symbol queryParamsSymbol = symbolTable.getSymbol(queryBean.getOrigin(), "QueryParams");
                        if (tsModel.getBean(queryParamsSymbol) == null) {
                            tsModel.getBeans().add(new TsBeanModel(
                                    queryBean.getOrigin(),
                                    TsBeanCategory.Data,
                                    false,
                                    queryParamsSymbol,
                                    null,
                                    null,
                                    null,
                                    null,
                                    processProperties(symbolTable, null, queryBean),
                                    null,
                                    null,
                                    null
                            ));
                        }
                        types.add(new TsType.ReferenceType(queryParamsSymbol));
                    }
                }
                flushSingles.run();
            }
            boolean allQueryParamsOptional = queryParams.stream().noneMatch(queryParam -> queryParam.required);
            TsType.IntersectionType queryParamType = new TsType.IntersectionType(types);
            queryParameter = new TsParameterModel("queryParams", allQueryParamsOptional ? new TsType.OptionalType(queryParamType) : queryParamType);
            parameters.add(queryParameter);
        } else {
            queryParameter = null;
        }
        if (optionsType != null) {
            final TsParameterModel optionsParameter = new TsParameterModel("options", new TsType.OptionalType(optionsType));
            parameters.add(optionsParameter);
        }
        final TsType returnType = typeFromJava(symbolTable, method.getReturnType(), method.getName(), method.getOriginClass());
        final TsType wrappedReturnType = new TsType.GenericReferenceType(responseSymbol, returnType);
        final String nameSuffix;
        if (createLongName) {
            nameSuffix = "$" + method.getHttpMethod() + "$" + pathTemplate.format("", "", false)
                    .replaceAll("/", "_")
                    .replaceAll("\\W", "");
        } else {
            nameSuffix = "";
        }
        final List<TsStatement> body;
        if (implement) {
            body = new ArrayList<>();
            body.add(new TsReturnStatement(
                    new TsCallExpression(
                            new TsMemberExpression(new TsMemberExpression(new TsThisExpression(), "httpClient"), "request"),
                            new TsObjectLiteral(
                                    new TsPropertyDefinition("method", new TsStringLiteral(method.getHttpMethod())),
                                    new TsPropertyDefinition("url", processPathTemplate(pathTemplate)),
                                    queryParameter != null ? new TsPropertyDefinition("queryParams", new TsIdentifierReference("queryParams")) : null,
                                    method.getEntityParam() != null ? new TsPropertyDefinition("data", new TsIdentifierReference(method.getEntityParam().getName())) : null,
                                    optionsType != null ? new TsPropertyDefinition("options", new TsIdentifierReference("options")) : null
                            )
                    )
            ));
        } else {
            body = null;
        }
        final TsMethodModel tsMethodModel = new TsMethodModel(method.getName() + nameSuffix, TsModifierFlags.None, null, parameters, wrappedReturnType, body, comments);
        return tsMethodModel;
    }
    private TsParameterModel processParameter(SymbolTable symbolTable, MethodModel method, MethodParameterModel parameter) {
        final String parameterName = parameter.getName();
        final TsType parameterType = typeFromJava(symbolTable, parameter.getType(), method.getName(), method.getOriginClass());
        return new TsParameterModel(parameterName, parameterType);
    }
    private static TsTemplateLiteral processPathTemplate(PathTemplate pathTemplate) {
        final List<TsExpression> spans = new ArrayList<>();
        for (PathTemplate.Part part : pathTemplate.getParts()) {
            if (part instanceof PathTemplate.Literal) {
                final PathTemplate.Literal literal = (PathTemplate.Literal) part;
                spans.add(new TsStringLiteral(literal.getLiteral()));
            }
            if (part instanceof PathTemplate.Parameter) {
                final PathTemplate.Parameter parameter = (PathTemplate.Parameter) part;
                spans.add(new TsIdentifierReference(parameter.getValidName()));
            }
        }
        return new TsTaggedTemplateLiteral(new TsIdentifierReference("uriEncoding"), spans);
    }
    private TsModel transformMaps(SymbolTable symbolTable, TsModel tsModel) {
        if (settings.mapMap != MapMapping.asRecord) {
            return tsModel;
        }
        final TsModel model = transformBeanPropertyTypes(tsModel, new TsType.Transformer() {
            @Override
            public TsType transform(TsType.Context context, TsType type) {
                if (type instanceof TsType.IndexedArrayType) {
                    final TsType.IndexedArrayType indexedArrayType = (TsType.IndexedArrayType) type;
                    return new TsType.GenericBasicType("Record", indexedArrayType.indexType, indexedArrayType.elementType);
                }
                return type;
            }
        });
        return model;
    }
    private TsModel transformDates(SymbolTable symbolTable, TsModel tsModel) {
        final TsAliasModel dateAsNumber = new TsAliasModel(null, symbolTable.getSyntheticSymbol("DateAsNumber"), null, TsType.Number, null);
        final TsAliasModel dateAsString = new TsAliasModel(null, symbolTable.getSyntheticSymbol("DateAsString"), null, TsType.String, null);
        final LinkedHashSet<TsAliasModel> typeAliases = new LinkedHashSet<>(tsModel.getTypeAliases());
        final TsModel model = transformBeanPropertyTypes(tsModel, new TsType.Transformer() {
            @Override
            public TsType transform(TsType.Context context, TsType type) {
                if (type == TsType.Date) {
                    if (settings.mapDate == DateMapping.asNumber) {
                        typeAliases.add(dateAsNumber);
                        return new TsType.ReferenceType(dateAsNumber.getName());
                    }
                    if (settings.mapDate == DateMapping.asString) {
                        typeAliases.add(dateAsString);
                        return new TsType.ReferenceType(dateAsString.getName());
                    }
                }
                return type;
            }
        });
        return model.withTypeAliases(new ArrayList<>(typeAliases));
    }
    static List<String> splitIdentifierIntoWords(String identifier) {
        final String pattern = String.join("|",
                "_",  
                "(?<=\\p{javaUpperCase})" + "(?=\\p{javaUpperCase}\\p{javaLowerCase})",  
                "(?<=[^_\\p{javaUpperCase}])" + "(?=\\p{javaUpperCase})",  
                "(?<=[\\p{javaUpperCase}\\p{javaLowerCase}])" + "(?=[^\\p{javaUpperCase}\\p{javaLowerCase}])",  
                "(?<=[^_\\p{javaUpperCase}\\p{javaLowerCase}])" + "(?=[\\p{javaUpperCase}\\p{javaLowerCase}])"  
        );
        return Arrays.asList(identifier.split(pattern));
    }
    private String convertIdentifierCasing(String identifier) {
        final List<String> words = splitIdentifierIntoWords(identifier);
        final String pascalCase = words.stream()
                .map(word -> word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase())
                .collect(Collectors.joining());
        if (settings.enumMemberCasing == IdentifierCasing.PascalCase) {
            return pascalCase;
        }
        if (settings.enumMemberCasing == IdentifierCasing.camelCase) {
            return pascalCase.substring(0, 1).toLowerCase() + pascalCase.substring(1);
        }
        return identifier;
    }
    private TsModel transformEnumMembersCase(TsModel tsModel) {
        final List<TsEnumModel> originalEnums = tsModel.getEnums();
        final LinkedHashSet<TsEnumModel> enums = new LinkedHashSet<>();
        for (TsEnumModel enumModel : originalEnums) {
            final List<EnumMemberModel> members = new ArrayList<>();
            for (EnumMemberModel member : enumModel.getMembers()) {
                members.add(member.withPropertyName(convertIdentifierCasing(member.getPropertyName())));
            }
            enums.add(enumModel.withMembers(members));
        }
        return tsModel.withRemovedEnums(originalEnums).withAddedEnums(new ArrayList<>(enums));
    }
    private TsModel transformEnumsToUnions(TsModel tsModel) {
        final List<TsEnumModel> stringEnums = tsModel.getEnums(EnumKind.StringBased);
        final LinkedHashSet<TsAliasModel> typeAliases = new LinkedHashSet<>(tsModel.getTypeAliases());
        for (TsEnumModel enumModel : stringEnums) {
            final List<TsType> values = new ArrayList<>();
            for (EnumMemberModel member : enumModel.getMembers()) {
                values.add(member.getEnumValue() instanceof Number
                        ? new TsType.NumberLiteralType((Number) member.getEnumValue())
                        : new TsType.StringLiteralType(String.valueOf(member.getEnumValue()))
                );
            }
            final TsType union = new TsType.UnionType(values);
            typeAliases.add(new TsAliasModel(enumModel.getOrigin(), enumModel.getName(), null, union, enumModel.getComments()));
        }
        return tsModel.withRemovedEnums(stringEnums).withTypeAliases(new ArrayList<>(typeAliases));
    }
    private TsModel inlineEnums(final TsModel tsModel, final SymbolTable symbolTable) {
        final Set<TsAliasModel> inlinedAliases = new LinkedHashSet<>();
        final TsModel newTsModel = transformBeanPropertyTypes(tsModel, new TsType.Transformer() {
            @Override
            public TsType transform(TsType.Context context, TsType tsType) {
                if (tsType instanceof TsType.EnumReferenceType) {
                    final TsAliasModel alias = tsModel.getTypeAlias(getOriginClass(symbolTable, tsType));
                    if (alias != null) {
                        inlinedAliases.add(alias);
                        return alias.getDefinition();
                    }
                }
                return tsType;
            }
        });
        return newTsModel.withRemovedTypeAliases(new ArrayList<>(inlinedAliases));
    }
    private TsModel transformEnumsToNumberBasedEnum(TsModel tsModel) {
        final List<TsEnumModel> stringEnums = tsModel.getEnums(EnumKind.StringBased);
        final LinkedHashSet<TsEnumModel> enums = new LinkedHashSet<>();
        for (TsEnumModel enumModel : stringEnums) {
            final List<EnumMemberModel> members = new ArrayList<>();
            for (EnumMemberModel member : enumModel.getMembers()) {
                members.add(new EnumMemberModel(member.getPropertyName(), (Number) null, member.getOriginalField(), member.getComments()));
            }
            enums.add(enumModel.withMembers(members));
        }
        return tsModel.withRemovedEnums(stringEnums).withAddedEnums(new ArrayList<>(enums));
    }
    private TsModel transformNonStringEnumKeyMaps(SymbolTable symbolTable, TsModel tsModel) {
        return transformBeanPropertyTypes(tsModel, new TsType.Transformer() {
            @Override
            public TsType transform(TsType.Context context, TsType tsType) {
                if (tsType instanceof TsType.MappedType) {
                    final TsType.MappedType mappedType = (TsType.MappedType) tsType;
                    if (mappedType.parameterType instanceof TsType.EnumReferenceType) {
                        final TsType.EnumReferenceType enumType = (TsType.EnumReferenceType) mappedType.parameterType;
                        final Class<?> enumClass = symbolTable.getSymbolClass(enumType.symbol);
                        final TsEnumModel enumModel = tsModel.getEnums().stream()
                                .filter(model -> Objects.equals(model.getOrigin(), enumClass))
                                .findFirst()
                                .orElse(null);
                        if (settings.mapEnum == EnumMapping.asNumberBasedEnum
                                || enumModel != null && enumModel.getKind() == EnumKind.NumberBased
                                || enumModel != null && enumModel.getMembers().stream().anyMatch(member -> !(member.getEnumValue() instanceof String))) {
                            return new TsType.IndexedArrayType(TsType.String, mappedType.type);
                        }
                    }
                }
                return tsType;
            }
        });
    }
    private static TsModel addEnumValuesToJavadoc(TsModel tsModel) {
        return tsModel.withEnums(tsModel.getEnums().stream()
                .map(enumModel -> addEnumValuesToJavadoc(enumModel))
                .collect(Collectors.toList())
        );
    }
    private static TsEnumModel addEnumValuesToJavadoc(TsEnumModel enumModel) {
        final boolean hasComments = enumModel.getComments() != null && !enumModel.getComments().isEmpty();
        final boolean hasMemberComments = enumModel.getMembers().stream()
                .anyMatch(enumMember -> enumMember.getComments() != null && !enumMember.getComments().isEmpty());
        if (hasComments || hasMemberComments) {
            return enumModel.withComments(Stream
                    .of(
                            Utils.listFromNullable(enumModel.getComments()).stream(),
                            (hasComments ? Stream.of("") : Stream.<String>empty()),
                            Stream.of("Values:"),
                            enumModel.getMembers().stream()
                                    .map(enumMember -> "- `" + enumMember.getEnumValue() + "`"
                                            + (enumMember.getComments() != null
                                            ? " - " + String.join(" ", enumMember.getComments())
                                            : ""))
                    )
                    .flatMap(s -> s)
                    .collect(Collectors.toList())
            );
        } else {
            return enumModel;
        }
    }
    private TsModel createAndUseTaggedUnions(final SymbolTable symbolTable, TsModel tsModel) {
        if (settings.disableTaggedUnions) {
            return tsModel;
        }
        final List<TsBeanModel> beans = new ArrayList<>();
        final LinkedHashSet<TsAliasModel> typeAliases = new LinkedHashSet<>(tsModel.getTypeAliases());
        for (TsBeanModel bean : tsModel.getBeans()) {
            if (!bean.getTaggedUnionClasses().isEmpty() && bean.getDiscriminantProperty() != null) {
                final Symbol unionName = symbolTable.getSymbol(bean.getOrigin(), "Union");
                final boolean isGeneric = !bean.getTypeParameters().isEmpty();
                final List<TsType> unionTypes = new ArrayList<>();
                for (Class<?> cls : bean.getTaggedUnionClasses()) {
                    final TsType type;
                    if (isGeneric && cls.getTypeParameters().length != 0) {
                        final List<String> mappedGenericVariables = GenericsResolver.mapGenericVariablesToBase(cls, bean.getOrigin());
                        type = new TsType.GenericReferenceType(
                                symbolTable.getSymbol(cls),
                                mappedGenericVariables.stream()
                                        .map(TsType.GenericVariableType::new)
                                        .collect(Collectors.toList()));
                    } else {
                        type = new TsType.ReferenceType(symbolTable.getSymbol(cls));
                    }
                    unionTypes.add(type);
                }
                final TsType.UnionType union = new TsType.UnionType(unionTypes);
                final TsAliasModel tsAliasModel = new TsAliasModel(bean.getOrigin(), unionName, bean.getTypeParameters(), union, null);
                beans.add(bean.withTaggedUnionAlias(tsAliasModel));
                typeAliases.add(tsAliasModel);
            } else {
                beans.add(bean);
            }
        }
        final TsModel modelWithTaggedUnions = tsModel.withBeans(beans).withTypeAliases(new ArrayList<>(typeAliases));
        final TsModel modelWithUsedTaggedUnions = transformBeanPropertyTypes(modelWithTaggedUnions, new TsType.Transformer() {
            @Override
            public TsType transform(TsType.Context context, TsType tsType) {
                final Class<?> cls = getOriginClass(symbolTable, tsType);
                if (cls != null) {
                    final Symbol unionSymbol = symbolTable.hasSymbol(cls, "Union");
                    if (unionSymbol != null) {
                        if (tsType instanceof TsType.GenericReferenceType) {
                            final TsType.GenericReferenceType genericReferenceType = (TsType.GenericReferenceType) tsType;
                            return new TsType.GenericReferenceType(unionSymbol, genericReferenceType.typeArguments);
                        } else {
                            return new TsType.ReferenceType(unionSymbol);
                        }
                    }
                }
                return tsType;
            }
        });
        return modelWithUsedTaggedUnions;
    }
    private TsModel makeUndefinablePropertiesAndParametersOptional(final SymbolTable symbolTable, TsModel tsModel) {
        final NullabilityDefinition nullabilityDefinition = settings.getNullabilityDefinition();
        if (!nullabilityDefinition.containsUndefined()) {
            return tsModel;
        }
        return tsModel.withBeans(tsModel.getBeans().stream()
                .map(bean -> {
                    bean = bean.withProperties(bean.getProperties().stream()
                            .map(property -> property.withTsType(makeNullableTypeOptional(property.getTsType())))
                            .collect(Collectors.toList())
                    );
                    bean = bean.withMethods(bean.getMethods().stream()
                            .map(method -> method.withParameters(method.getParameters().stream()
                                    .map(parameter -> parameter.withTsType(makeNullableTypeOptional(parameter.getTsType())))
                                    .collect(Collectors.toList())
                            ))
                            .collect(Collectors.toList())
                    );
                    return bean;
                })
                .collect(Collectors.toList())
        );
    }
    private static TsType makeNullableTypeOptional(TsType type) {
        return type instanceof TsType.NullableType
                ? new TsType.OptionalType(type)
                : type;
    }
    private TsModel transformNullableTypes(final SymbolTable symbolTable, TsModel tsModel) {
        final AtomicBoolean declareNullableType = new AtomicBoolean(false);
        final NullabilityDefinition nullabilityDefinition = settings.getNullabilityDefinition();
        TsModel transformedModel = transformBeanPropertyTypes(tsModel, new TsType.Transformer() {
            @Override
            public TsType transform(TsType.Context context, TsType tsType) {
                if (tsType instanceof TsType.NullableType) {
                    final TsType.NullableType nullableType = (TsType.NullableType) tsType;
                    if (nullabilityDefinition.isInline()) {
                        return new TsType.UnionType(nullableType.type).add(nullabilityDefinition.getTypes());
                    } else {
                        declareNullableType.set(true);
                    }
                }
                return tsType;
            }
        });
        if (declareNullableType.get()) {
            final TsType.GenericVariableType tVar = new TsType.GenericVariableType("T");
            transformedModel = transformedModel.withAddedTypeAliases(Arrays.asList(new TsAliasModel(
                     null,
                    symbolTable.getSyntheticSymbol(TsType.NullableType.AliasName),
                    Arrays.asList(tVar),
                    new TsType.UnionType(tVar).add(nullabilityDefinition.getTypes()),
                     null
            )));
        }
        return transformedModel;
    }
    private TsModel eliminateUndefinedFromOptionalPropertiesAndParameters(final SymbolTable symbolTable, TsModel tsModel) {
        return tsModel.withBeans(tsModel.getBeans().stream()
                .map(bean -> {
                    bean = bean.withProperties(bean.getProperties().stream()
                            .map(property -> property.withTsType(eliminateUndefinedFromOptionalType(property.getTsType())))
                            .collect(Collectors.toList())
                    );
                    bean = bean.withMethods(bean.getMethods().stream()
                            .map(method -> method.withParameters(method.getParameters().stream()
                                    .map(parameter -> parameter.withTsType(eliminateUndefinedFromOptionalType(parameter.getTsType())))
                                    .collect(Collectors.toList())
                            ))
                            .collect(Collectors.toList())
                    );
                    return bean;
                })
                .collect(Collectors.toList())
        );
    }
    private static TsType eliminateUndefinedFromOptionalType(TsType type) {
        if (type instanceof TsType.OptionalType) {
            final TsType.OptionalType optionalType = (TsType.OptionalType) type;
            if (optionalType.type instanceof TsType.UnionType) {
                final TsType.UnionType unionType = (TsType.UnionType) optionalType.type;
                if (unionType.types.contains(TsType.Undefined)) {
                    return new TsType.OptionalType(unionType.remove(Arrays.asList(TsType.Undefined)));
                }
            }
        }
        return type;
    }
    private TsModel transformOptionalProperties(final SymbolTable symbolTable, TsModel tsModel) {
        return tsModel.withBeans(tsModel.getBeans().stream()
                .map(bean -> {
                    if (bean.getCategory() != TsBeanCategory.Data) {
                        return bean;
                    }
                    return bean.withProperties(bean.getProperties().stream()
                            .map(property -> {
                                if (property.getTsType() instanceof TsType.OptionalType) {
                                    final TsType.OptionalType optionalType = (TsType.OptionalType) property.getTsType();
                                    if (settings.optionalPropertiesDeclaration == OptionalPropertiesDeclaration.nullableType) {
                                        return property.withTsType(
                                                TsType.UnionType.combine(Arrays.asList(optionalType.type, TsType.Null)));
                                    }
                                    if (settings.optionalPropertiesDeclaration == OptionalPropertiesDeclaration.questionMarkAndNullableType) {
                                        return property.withTsType(
                                                new TsType.OptionalType(
                                                        TsType.UnionType.combine(Arrays.asList(optionalType.type, TsType.Null))));
                                    }
                                    if (settings.optionalPropertiesDeclaration == OptionalPropertiesDeclaration.nullableAndUndefinableType) {
                                        return property.withTsType(
                                                TsType.UnionType.combine(Arrays.asList(optionalType.type, TsType.Null, TsType.Undefined)));
                                    }
                                    if (settings.optionalPropertiesDeclaration == OptionalPropertiesDeclaration.undefinableType) {
                                        return property.withTsType(
                                                TsType.UnionType.combine(Arrays.asList(optionalType.type, TsType.Undefined)));
                                    }
                                }
                                return property;
                            })
                            .collect(Collectors.toList())
                    );
                })
                .collect(Collectors.toList())
        );
    }
    private TsModel sortPropertiesDeclarations(SymbolTable symbolTable, TsModel tsModel) {
        if (settings.sortDeclarations) {
            for (TsBeanModel bean : tsModel.getBeans()) {
                Collections.sort(bean.getProperties());
            }
        }
        return tsModel;
    }
    private TsModel sortTypeDeclarations(SymbolTable symbolTable, TsModel tsModel) {
        final List<TsBeanModel> beans = tsModel.getBeans();
        final List<TsAliasModel> aliases = tsModel.getTypeAliases();
        final List<TsEnumModel> enums = tsModel.getEnums();
        if (settings.sortDeclarations || settings.sortTypeDeclarations) {
            Collections.sort(beans);
            Collections.sort(aliases);
            Collections.sort(enums);
        }
        final LinkedHashSet<TsBeanModel> orderedBeans = new LinkedHashSet<>();
        for (TsBeanModel bean : beans) {
            addOrderedClass(symbolTable, tsModel, bean, orderedBeans);
        }
        return tsModel
                    .withBeans(new ArrayList<>(orderedBeans))
                    .withTypeAliases(aliases)
                    .withEnums(enums);
    }
    private static void addOrderedClass(SymbolTable symbolTable, TsModel tsModel, TsBeanModel bean, LinkedHashSet<TsBeanModel> orderedBeans) {
        if (bean.isClass() && bean.getParent() != null) {
            final TsBeanModel parentBean = tsModel.getBean(getOriginClass(symbolTable, bean.getParent()));
            if (parentBean != null) {
                addOrderedClass(symbolTable, tsModel, parentBean, orderedBeans);
            }
        }
        orderedBeans.add(bean);
    }
    private static TsModel transformBeanPropertyTypes(TsModel tsModel, TsType.Transformer transformer) {
        final List<TsBeanModel> newBeans = new ArrayList<>();
        for (TsBeanModel bean : tsModel.getBeans()) {
            final TsType.Context context = new TsType.Context();
            final List<TsPropertyModel> newProperties = new ArrayList<>();
            for (TsPropertyModel property : bean.getProperties()) {
                final TsType newType = TsType.transformTsType(context, property.getTsType(), transformer);
                newProperties.add(property.withTsType(newType));
            }
            final List<TsMethodModel> newMethods = new ArrayList<>();
            for (TsMethodModel method : bean.getMethods()) {
                final List<TsParameterModel> newParameters = new ArrayList<>();
                for (TsParameterModel parameter : method.getParameters()) {
                    final TsType newParameterType = TsType.transformTsType(context, parameter.getTsType(), transformer);
                    newParameters.add(new TsParameterModel(parameter.getAccessibilityModifier(), parameter.getName(), newParameterType));
                }
                final TsType newReturnType = TsType.transformTsType(context, method.getReturnType(), transformer);
                newMethods.add(new TsMethodModel(method.getName(), method.getModifiers(), method.getTypeParameters(), newParameters, newReturnType, method.getBody(), method.getComments()));
            }
            final List<TsType> newImplements = new ArrayList<>();
            for (TsType type: bean.getImplementsList()) {
                if (type instanceof TsType.GenericBasicType || type instanceof TsType.GenericReferenceType) {
                    newImplements.add(TsType.transformTsType(context, type, transformer));
                } else {
                    newImplements.add(type);
                }
            }
            final List<TsType> newExtends = new ArrayList<>();
            for (TsType type: bean.getExtendsList()) {
                if (type instanceof TsType.GenericBasicType || type instanceof TsType.GenericReferenceType) {
                    newExtends.add(TsType.transformTsType(context, type, transformer));
                } else {
                    newExtends.add(type);
                }
            }
            newBeans.add(bean.withProperties(newProperties).withMethods(newMethods).withImplements(newImplements).withExtends(newExtends));
        }
        return tsModel.withBeans(newBeans);
    }
    private static Class<?> getOriginClass(SymbolTable symbolTable, TsType type) {
        if (type instanceof TsType.ReferenceType) {
            final TsType.ReferenceType referenceType = (TsType.ReferenceType) type;
            return symbolTable.getSymbolClass(referenceType.symbol);
        }
        return null;
    }
    public static String getValidIdentifierName(String name) {
        final String identifier = removeInvalidIdentifierCharacters(replaceDashPattern(name));
        final String prefix = SymbolTable.isReservedWord(identifier) ? "_" : "";
        return prefix + identifier;
    }
    private static String replaceDashPattern(String name) {
        final StringBuffer sb = new StringBuffer();
        final Matcher matcher = Pattern.compile("-[^-]").matcher(name);
        while (matcher.find()) {
            matcher.appendReplacement(sb, Matcher.quoteReplacement("" + Character.toUpperCase(matcher.group().charAt(1))));
        }
        matcher.appendTail(sb);
        return sb.toString();
    }
    private static String removeInvalidIdentifierCharacters(String name) {
        final StringBuilder sb = new StringBuilder();
        for (char c : name.toCharArray()) {
            if (sb.length() == 0 ? isValidIdentifierStart(c) : isValidIdentifierPart(c)) {
                sb.append(c);
            }
        }
        return sb.toString();
    }
    public static boolean isValidIdentifierName(String name) {
        if (name == null || name.isEmpty()) {
            return false;
        }
        for (int i = 0; i < name.length(); i++) {
            final char c = name.charAt(i);
            if (i == 0 ? !isValidIdentifierStart(c) : !isValidIdentifierPart(c)) {
                return false;
            }
        }
        return true;
    }
    private static boolean isValidIdentifierStart(char start) {
        return Character.isUnicodeIdentifierStart(start) || start == '$' || start == '_';
    }
    private static boolean isValidIdentifierPart(char c) {
        return Character.isUnicodeIdentifierPart(c) || c == '$' || c == '_' || c == '\u200C' || c == '\u200D';
    }
}
package cz.habarta.typescript.generator;
import cz.habarta.typescript.generator.compiler.ModelCompiler;
import cz.habarta.typescript.generator.emitter.Emitter;
import cz.habarta.typescript.generator.emitter.InfoJsonEmitter;
import cz.habarta.typescript.generator.emitter.NpmPackageJson;
import cz.habarta.typescript.generator.emitter.NpmPackageJsonEmitter;
import cz.habarta.typescript.generator.emitter.TsModel;
import cz.habarta.typescript.generator.parser.GsonParser;
import cz.habarta.typescript.generator.parser.Jackson2Parser;
import cz.habarta.typescript.generator.parser.JsonbParser;
import cz.habarta.typescript.generator.parser.Model;
import cz.habarta.typescript.generator.parser.ModelParser;
import cz.habarta.typescript.generator.parser.RestApplicationParser;
import cz.habarta.typescript.generator.util.Utils;
import java.io.File;
import java.io.InputStream;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Objects;
import java.util.Properties;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class TypeScriptGenerator {
    public static final String Version = getVersion();
    private static Logger logger = new Logger();
    private final Settings settings;
    private TypeProcessor commonTypeProcessor = null;
    private ModelParser modelParser = null;
    private ModelCompiler modelCompiler = null;
    private Emitter emitter = null;
    private InfoJsonEmitter infoJsonEmitter = null;
    private NpmPackageJsonEmitter npmPackageJsonEmitter = null;
    public static Logger getLogger() {
        return logger;
    }
    public static void setLogger(Logger logger) {
        TypeScriptGenerator.logger = logger;
    }
    public TypeScriptGenerator() {
        this (new Settings());
    }
    public TypeScriptGenerator(Settings settings) {
        this.settings = settings;
        settings.validate();
    }
    public static void printVersion() {
        TypeScriptGenerator.getLogger().info("Running TypeScriptGenerator version " + Version);
    }
    public String generateTypeScript(Input input) {
        final StringWriter stringWriter = new StringWriter();
        generateTypeScript(input, Output.to(stringWriter));
        return stringWriter.toString();
    }
    public void generateTypeScript(Input input, Output output) {
        final Model model = getModelParser().parseModel(input.getSourceTypes());
        final TsModel tsModel = getModelCompiler().javaToTypeScript(model);
        generateTypeScript(tsModel, output);
        generateInfoJson(tsModel, output);
        generateNpmPackageJson(output);
    }
    private void generateTypeScript(TsModel tsModel, Output output) {
        getEmitter().emit(tsModel, output.getWriter(), output.getName(), output.shouldCloseWriter());
    }
    private void generateInfoJson(TsModel tsModel, Output output) {
        if (settings.generateInfoJson) {
            if (output.getName() == null) {
                throw new RuntimeException("Generating info JSON can only be used when output is specified using file name");
            }
            final File outputFile = new File(output.getName());
            final Output out = Output.to(new File(outputFile.getParent(), "typescript-generator-info.json"));
            getInfoJsonEmitter().emit(tsModel, out.getWriter(), out.getName(), out.shouldCloseWriter());
        }
    }
    private void generateNpmPackageJson(Output output) {
        if (settings.generateNpmPackageJson) {
            if (output.getName() == null) {
                throw new RuntimeException("Generating NPM package.json can only be used when output is specified using file name");
            }
            final File outputFile = new File(output.getName());
            final Output npmOutput = Output.to(new File(outputFile.getParent(), "package.json"));
            final NpmPackageJson npmPackageJson = new NpmPackageJson();
            npmPackageJson.name = settings.npmName;
            npmPackageJson.version = settings.npmVersion;
            npmPackageJson.types = outputFile.getName();
            npmPackageJson.dependencies = new LinkedHashMap<>();
            npmPackageJson.devDependencies = new LinkedHashMap<>();
            npmPackageJson.peerDependencies = new LinkedHashMap<>();
            if (settings.moduleDependencies != null) {
                for (ModuleDependency dependency : settings.moduleDependencies) {
                    if (dependency.peerDependency) {
                        npmPackageJson.peerDependencies.put(dependency.npmPackageName, dependency.npmVersionRange);
                    } else {
                        npmPackageJson.dependencies.put(dependency.npmPackageName, dependency.npmVersionRange);
                    }
                }
            }
            if (settings.outputFileType == TypeScriptFileType.implementationFile) {
                npmPackageJson.types = Utils.replaceExtension(outputFile, ".d.ts").getName();
                npmPackageJson.main = Utils.replaceExtension(outputFile, ".js").getName();
                npmPackageJson.dependencies.putAll(settings.npmPackageDependencies);
                npmPackageJson.devDependencies.putAll(settings.npmDevDependencies);
                npmPackageJson.peerDependencies.putAll(settings.npmPeerDependencies);
                final String typescriptVersion = settings.npmTypescriptVersion != null ? settings.npmTypescriptVersion : settings.typescriptVersion;
                npmPackageJson.devDependencies.put("typescript", typescriptVersion);
                final String npmBuildScript = settings.npmBuildScript != null
                        ? settings.npmBuildScript
                        : "tsc --module umd --moduleResolution node --typeRoots --target es5 --lib es6 --declaration --sourceMap $outputFile";
                final String build = npmBuildScript.replaceAll(Pattern.quote("$outputFile"), outputFile.getName());
                npmPackageJson.scripts = Collections.singletonMap("build", build);
            }
            if (npmPackageJson.dependencies.isEmpty()) {
                npmPackageJson.dependencies = null;
            }
            if (npmPackageJson.devDependencies.isEmpty()) {
                npmPackageJson.devDependencies = null;
            }
            if (npmPackageJson.peerDependencies.isEmpty()) {
                npmPackageJson.peerDependencies = null;
            }
            getNpmPackageJsonEmitter().emit(npmPackageJson, npmOutput.getWriter(), npmOutput.getName(), npmOutput.shouldCloseWriter());
        }
    }
    public TypeProcessor getCommonTypeProcessor() {
        if (commonTypeProcessor == null) {
            final List<RestApplicationParser.Factory> restFactories = settings.getRestApplicationParserFactories();
            final ModelParser.Factory modelParserFactory = getModelParserFactory();
            final List<TypeProcessor> specificTypeProcessors = Stream
                    .concat(
                            restFactories.stream().map(factory -> factory.getSpecificTypeProcessor()),
                            Stream.of(modelParserFactory.getSpecificTypeProcessor())
                    )
                    .filter(Objects::nonNull)
                    .collect(Collectors.toList());
            commonTypeProcessor = createTypeProcessor(specificTypeProcessors);
        }
        return commonTypeProcessor;
    }
    private TypeProcessor createTypeProcessor(List<TypeProcessor> specificTypeProcessors) {
        final List<TypeProcessor> processors = new ArrayList<>();
        processors.add(new ExcludingTypeProcessor(settings.getExcludeFilter()));
        if (settings.customTypeProcessor != null) {
            processors.add(settings.customTypeProcessor);
        }
        processors.add(new CustomMappingTypeProcessor(settings.getValidatedCustomTypeMappings()));
        processors.addAll(specificTypeProcessors);
        processors.add(new DefaultTypeProcessor(settings.getLoadedDataLibraries()));
        final TypeProcessor typeProcessor = new TypeProcessor.Chain(processors);
        return typeProcessor;
    }
    public ModelParser getModelParser() {
        if (modelParser == null) {
            modelParser = createModelParser();
        }
        return modelParser;
    }
    private ModelParser createModelParser() {
        final List<RestApplicationParser.Factory> factories = settings.getRestApplicationParserFactories();
        final List<RestApplicationParser> restApplicationParsers = factories.stream()
                .map(factory -> factory.create(settings, getCommonTypeProcessor()))
                .collect(Collectors.toList());
        return getModelParserFactory().create(settings, getCommonTypeProcessor(), restApplicationParsers);
    }
    private ModelParser.Factory getModelParserFactory() {
        switch (settings.jsonLibrary) {
            case jackson2:
                return new Jackson2Parser.Jackson2ParserFactory();
            case jaxb:
                return new Jackson2Parser.JaxbParserFactory();
            case gson:
                return new GsonParser.Factory();
            case jsonb:
                return new JsonbParser.Factory();
            default:
                throw new RuntimeException();
        }
    }
    public ModelCompiler getModelCompiler() {
        if (modelCompiler == null) {
            modelCompiler = new ModelCompiler(settings, getCommonTypeProcessor());
        }
        return modelCompiler;
    }
    public Emitter getEmitter() {
        if (emitter == null) {
            emitter = new Emitter(settings);
        }
        return emitter;
    }
    public InfoJsonEmitter getInfoJsonEmitter() {
        if (infoJsonEmitter == null) {
            infoJsonEmitter = new InfoJsonEmitter();
        }
        return infoJsonEmitter;
    }
    public NpmPackageJsonEmitter getNpmPackageJsonEmitter() {
        if (npmPackageJsonEmitter == null) {
            npmPackageJsonEmitter = new NpmPackageJsonEmitter();
        }
        return npmPackageJsonEmitter;
    }
    private static String getVersion() {
        try {
            final InputStream inputStream = TypeScriptGenerator.class.getResourceAsStream(
                    "/META-INF/maven/cz.habarta.typescript-generator/typescript-generator-core/pom.properties");
            if (inputStream != null) {
                final Properties properties = new Properties();
                properties.load(inputStream);
                return (String) properties.get("version");
            }
            return null;
        } catch (Exception e) {
            return null;
        }
    }
}
package cz.habarta.typescript.generator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import cz.habarta.typescript.generator.compiler.ModelCompiler;
import cz.habarta.typescript.generator.compiler.SymbolTable.CustomTypeNamingFunction;
import cz.habarta.typescript.generator.emitter.EmitterExtension;
import cz.habarta.typescript.generator.emitter.EmitterExtensionFeatures;
import cz.habarta.typescript.generator.parser.JaxrsApplicationParser;
import cz.habarta.typescript.generator.parser.RestApplicationParser;
import cz.habarta.typescript.generator.parser.TypeParser;
import cz.habarta.typescript.generator.util.Pair;
import cz.habarta.typescript.generator.util.Utils;
import java.io.File;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.TypeVariable;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class Settings {
    public String newline = String.format("%n");
    public String quotes = "\"";
    public String indentString = "    ";
    public TypeScriptFileType outputFileType = TypeScriptFileType.declarationFile;
    public TypeScriptOutputKind outputKind = null;
    public String module = null;
    public String namespace = null;
    public boolean mapPackagesToNamespaces = false;
    public String umdNamespace = null;
    public List<ModuleDependency> moduleDependencies = new ArrayList<>();
    private LoadedModuleDependencies loadedModuleDependencies = null;
    public JsonLibrary jsonLibrary = null;
    public Jackson2ConfigurationResolved jackson2Configuration = null;
    public GsonConfiguration gsonConfiguration = null;
    public JsonbConfiguration jsonbConfiguration = null;
    public List<String> additionalDataLibraries = new ArrayList<>();
    private LoadedDataLibraries loadedDataLibrariesClasses = null;
    private Predicate<String> excludeFilter = null;
    public OptionalProperties optionalProperties; 
    public OptionalPropertiesDeclaration optionalPropertiesDeclaration; 
    public NullabilityDefinition nullabilityDefinition; 
    private TypeParser typeParser = null;
    public boolean declarePropertiesAsReadOnly = false;
    public String removeTypeNamePrefix = null;
    public String removeTypeNameSuffix = null;
    public String addTypeNamePrefix = null;
    public String addTypeNameSuffix = null;
    public Map<String, String> customTypeNaming = new LinkedHashMap<>();
    public String customTypeNamingFunction = null;
    public CustomTypeNamingFunction customTypeNamingFunctionImpl = null;
    public List<String> referencedFiles = new ArrayList<>();
    public List<String> importDeclarations = new ArrayList<>();
    public Map<String, String> customTypeMappings = new LinkedHashMap<>();
    private List<CustomTypeMapping> validatedCustomTypeMappings = null;
    public Map<String, String> customTypeAliases = new LinkedHashMap<>();
    private List<CustomTypeAlias> validatedCustomTypeAliases = null;
    public DateMapping mapDate; 
    public MapMapping mapMap; 
    public EnumMapping mapEnum; 
    public IdentifierCasing enumMemberCasing; 
    public boolean nonConstEnums = false;
    public List<Class<? extends Annotation>> nonConstEnumAnnotations = new ArrayList<>();
    public ClassMapping mapClasses; 
    public List<String> mapClassesAsClassesPatterns;
    private Predicate<String> mapClassesAsClassesFilter = null;
    public boolean generateConstructors = false;
    public List<Class<? extends Annotation>> disableTaggedUnionAnnotations = new ArrayList<>();
    public boolean disableTaggedUnions = false;
    public boolean generateReadonlyAndWriteonlyJSDocTags = false;
    public boolean ignoreSwaggerAnnotations = false;
    public boolean generateJaxrsApplicationInterface = false;
    public boolean generateJaxrsApplicationClient = false;
    public boolean generateSpringApplicationInterface = false;
    public boolean generateSpringApplicationClient = false;
    public boolean scanSpringApplication;
    public RestNamespacing restNamespacing;
    public Class<? extends Annotation> restNamespacingAnnotation = null;
    public String restNamespacingAnnotationElement;  
    public String restResponseType = null;
    public String restOptionsType = null;
    public boolean restOptionsTypeIsGeneric;
    private List<RestApplicationParser.Factory> restApplicationParserFactories;
    public TypeProcessor customTypeProcessor = null;
    public boolean sortDeclarations = false;
    public boolean sortTypeDeclarations = false;
    public boolean noFileComment = false;
    public boolean noTslintDisable = false;
    public boolean noEslintDisable = false;
    public boolean tsNoCheck = false;
    public List<File> javadocXmlFiles = null;
    public List<EmitterExtension> extensions = new ArrayList<>();
    public List<Class<? extends Annotation>> includePropertyAnnotations = new ArrayList<>();
    public List<Class<? extends Annotation>> excludePropertyAnnotations = new ArrayList<>();
    public List<Class<? extends Annotation>> optionalAnnotations = new ArrayList<>();
    public List<Class<? extends Annotation>> requiredAnnotations = new ArrayList<>();
    public List<Class<? extends Annotation>> nullableAnnotations = new ArrayList<>();
    public boolean primitivePropertiesRequired = false;
    public boolean generateInfoJson = false;
    public boolean generateNpmPackageJson = false;
    public String npmName = null;
    public String npmVersion = null;
    public Map<String, String> npmPackageDependencies = new LinkedHashMap<>();
    public Map<String, String> npmDevDependencies = new LinkedHashMap<>();
    public Map<String, String> npmPeerDependencies = new LinkedHashMap<>();
    public String typescriptVersion = "^2.4";
    public String npmTypescriptVersion = null;
    public String npmBuildScript = null;
    public boolean jackson2ModuleDiscovery = false;
    public List<Class<? extends Module>> jackson2Modules = new ArrayList<>();
    public ClassLoader classLoader = null;
    private boolean defaultStringEnumsOverriddenByExtension = false;
    public static class ConfiguredExtension {
        public String className;
        public Map<String, String> configuration;
    }
    public static class CustomTypeMapping {
        public final Class<?> rawClass;
        public final boolean matchSubclasses;
        public final GenericName javaType;
        public final GenericName tsType;
        public CustomTypeMapping(Class<?> rawClass, boolean matchSubclasses, GenericName javaType, GenericName tsType) {
            this.rawClass = rawClass;
            this.matchSubclasses = matchSubclasses;
            this.javaType = javaType;
            this.tsType = tsType;
        }
        @Override
        public String toString() {
            return Utils.objectToString(this);
        }
    }
    public static class CustomTypeAlias {
        public final GenericName tsType;
        public final String tsDefinition;
        public CustomTypeAlias(GenericName tsType, String tsDefinition) {
            this.tsType = tsType;
            this.tsDefinition = tsDefinition;
        }
    }
    public static class GenericName {
        public final String rawName;
        public final List<String> typeParameters;
        public GenericName(String rawName, List<String> typeParameters) {
            this.rawName = Objects.requireNonNull(rawName);
            this.typeParameters = typeParameters;
        }
        public int indexOfTypeParameter(String typeParameter) {
            return typeParameters != null ? typeParameters.indexOf(typeParameter) : -1;
        }
    }
    private static class TypeScriptGeneratorURLClassLoader extends URLClassLoader {
        private final String name;
        public TypeScriptGeneratorURLClassLoader(String name, URL[] urls, ClassLoader parent) {
            super(urls, parent);
            this.name = name;
        }
        @Override
        public String toString() {
            return "TsGenURLClassLoader{" + name + ", parent: " + getParent() + "}";
        }
    }
    public static URLClassLoader createClassLoader(String name, URL[] urls, ClassLoader parent) {
        return new TypeScriptGeneratorURLClassLoader(name, urls, parent);
    }
    public void setStringQuotes(StringQuotes quotes) {
        this.quotes = quotes == StringQuotes.singleQuotes ? "'" : "\"";
    }
    public void setIndentString(String indentString) {
        this.indentString = indentString != null ? indentString : "    ";
    }
    public void setJackson2Configuration(ClassLoader classLoader, Jackson2Configuration configuration) {
        if (configuration != null) {
            jackson2Configuration = Jackson2ConfigurationResolved.from(configuration, classLoader);
        }
    }
    public void loadCustomTypeProcessor(ClassLoader classLoader, String customTypeProcessor) {
        if (customTypeProcessor != null) {
            this.customTypeProcessor = loadInstance(classLoader, customTypeProcessor, TypeProcessor.class);
        }
    }
    public void loadExtensions(ClassLoader classLoader, List<String> extensions, List<Settings.ConfiguredExtension> extensionsWithConfiguration) {
        this.extensions = new ArrayList<>();
        this.extensions.addAll(loadInstances(classLoader, extensions, EmitterExtension.class));
        if (extensionsWithConfiguration != null) {
            for (ConfiguredExtension configuredExtension : extensionsWithConfiguration) {
                final EmitterExtension emitterExtension = loadInstance(classLoader, configuredExtension.className, EmitterExtension.class);
                if (emitterExtension instanceof Extension) {
                    final Extension extension = (Extension) emitterExtension;
                    extension.setConfiguration(Utils.mapFromNullable(configuredExtension.configuration));
                }
                this.extensions.add(emitterExtension);
            }
        }
    }
    public void loadNonConstEnumAnnotations(ClassLoader classLoader, List<String> stringAnnotations) {
        this.nonConstEnumAnnotations = loadClasses(classLoader, stringAnnotations, Annotation.class);
    }
    public void loadIncludePropertyAnnotations(ClassLoader classLoader, List<String> includePropertyAnnotations) {
        this.includePropertyAnnotations = loadClasses(classLoader, includePropertyAnnotations, Annotation.class);
    }
    public void loadExcludePropertyAnnotations(ClassLoader classLoader, List<String> excludePropertyAnnotations) {
        this.excludePropertyAnnotations = loadClasses(classLoader, excludePropertyAnnotations, Annotation.class);
    }
    public void loadOptionalAnnotations(ClassLoader classLoader, List<String> optionalAnnotations) {
        this.optionalAnnotations = loadClasses(classLoader, optionalAnnotations, Annotation.class);
    }
    public void loadRequiredAnnotations(ClassLoader classLoader, List<String> requiredAnnotations) {
        this.requiredAnnotations = loadClasses(classLoader, requiredAnnotations, Annotation.class);
    }
    public void loadNullableAnnotations(ClassLoader classLoader, List<String> nullableAnnotations) {
        this.nullableAnnotations = loadClasses(classLoader, nullableAnnotations, Annotation.class);
    }
    public void loadDisableTaggedUnionAnnotations(ClassLoader classLoader, List<String> disableTaggedUnionAnnotations) {
        this.disableTaggedUnionAnnotations = loadClasses(classLoader, disableTaggedUnionAnnotations, Annotation.class);
    }
    public void loadJackson2Modules(ClassLoader classLoader, List<String> jackson2Modules) {
        this.jackson2Modules = loadClasses(classLoader, jackson2Modules, Module.class);
    }
    public static Map<String, String> convertToMap(List<String> items, String itemName) {
        final Map<String, String> result = new LinkedHashMap<>();
        if (items != null) {
            for (String item : items) {
                final String[] values = item.split(":", 2);
                if (values.length < 2) {
                    throw new RuntimeException(String.format("Invalid '%s' format: %s", itemName, item));
                }
                result.put(values[0].trim(), values[1].trim());
            }
        }
        return result;
    }
    public void validate() {
        if (classLoader == null) {
            classLoader = Thread.currentThread().getContextClassLoader();
        }
        if (outputKind == null) {
            throw new RuntimeException("Required 'outputKind' parameter is not configured. " + seeLink());
        }
        if (outputKind == TypeScriptOutputKind.ambientModule && outputFileType == TypeScriptFileType.implementationFile) {
            throw new RuntimeException("Ambient modules are not supported in implementation files. " + seeLink());
        }
        if (outputKind == TypeScriptOutputKind.ambientModule && module == null) {
            throw new RuntimeException("'module' parameter must be specified for ambient module. " + seeLink());
        }
        if (outputKind != TypeScriptOutputKind.ambientModule && module != null) {
            throw new RuntimeException("'module' parameter is only applicable to ambient modules. " + seeLink());
        }
        if (outputKind != TypeScriptOutputKind.module && umdNamespace != null) {
            throw new RuntimeException("'umdNamespace' parameter is only applicable to modules. " + seeLink());
        }
        if (outputFileType == TypeScriptFileType.implementationFile && umdNamespace != null) {
            throw new RuntimeException("'umdNamespace' parameter is not applicable to implementation files. " + seeLink());
        }
        if (umdNamespace != null && !ModelCompiler.isValidIdentifierName(umdNamespace)) {
            throw new RuntimeException("Value of 'umdNamespace' parameter is not valid identifier: " + umdNamespace + ". " + seeLink());
        }
        if (jsonLibrary == null) {
            throw new RuntimeException("Required 'jsonLibrary' parameter is not configured.");
        }
        if (jackson2Configuration != null && jsonLibrary != JsonLibrary.jackson2) {
            throw new RuntimeException("'jackson2Configuration' parameter is only applicable to 'jackson2' library.");
        }
        if (!generateNpmPackageJson && (!npmPackageDependencies.isEmpty() || !npmDevDependencies.isEmpty() || !npmPeerDependencies.isEmpty())) {
            throw new RuntimeException("'npmDependencies', 'npmDevDependencies' and 'npmPeerDependencies' parameters are only applicable when generating NPM 'package.json'.");
        }
        getValidatedCustomTypeMappings();
        getValidatedCustomTypeAliases();
        for (EmitterExtension extension : extensions) {
            final String extensionName = extension.getClass().getSimpleName();
            final DeprecationText deprecation = extension.getClass().getAnnotation(DeprecationText.class);
            if (deprecation != null) {
                TypeScriptGenerator.getLogger().warning(String.format("Extension '%s' is deprecated: %s", extensionName, deprecation.value()));
            }
            final EmitterExtensionFeatures features = extension.getFeatures();
            if (features.generatesRuntimeCode && outputFileType != TypeScriptFileType.implementationFile) {
                throw new RuntimeException(String.format("Extension '%s' generates runtime code but 'outputFileType' parameter is not set to 'implementationFile'.", extensionName));
            }
            if (features.generatesModuleCode && outputKind != TypeScriptOutputKind.module) {
                throw new RuntimeException(String.format("Extension '%s' generates code as module but 'outputKind' parameter is not set to 'module'.", extensionName));
            }
            if (!features.worksWithPackagesMappedToNamespaces && mapPackagesToNamespaces) {
                throw new RuntimeException(String.format("Extension '%s' doesn't work with 'mapPackagesToNamespaces' parameter.", extensionName));
            }
            if (features.generatesJaxrsApplicationClient) {
                reportConfigurationChange(extensionName, "generateJaxrsApplicationClient", "true");
                generateJaxrsApplicationClient = true;
            }
            if (features.restResponseType != null) {
                reportConfigurationChange(extensionName, "restResponseType", features.restResponseType);
                restResponseType = features.restResponseType;
            }
            if (features.restOptionsType != null) {
                reportConfigurationChange(extensionName, "restOptionsType", features.restOptionsType);
                setRestOptionsType(features.restOptionsType);
            }
            if (features.npmPackageDependencies != null) {
                npmPackageDependencies.putAll(features.npmPackageDependencies);
            }
            if (features.npmDevDependencies != null) {
                npmDevDependencies.putAll(features.npmDevDependencies);
            }
            if (features.npmPeerDependencies != null) {
                npmPeerDependencies.putAll(features.npmPeerDependencies);
            }
            if (features.overridesStringEnums) {
                defaultStringEnumsOverriddenByExtension = true;
            }
        }
        if (enumMemberCasing != null && mapEnum != EnumMapping.asEnum && mapEnum != EnumMapping.asNumberBasedEnum) {
            throw new RuntimeException("'enumMemberCasing' parameter can only be used when 'mapEnum' parameter is set to 'asEnum' or 'asNumberBasedEnum'.");
        }
        if ((nonConstEnums || !nonConstEnumAnnotations.isEmpty()) && outputFileType != TypeScriptFileType.implementationFile) {
            throw new RuntimeException("Non-const enums can only be used in implementation files but 'outputFileType' parameter is not set to 'implementationFile'.");
        }
        if (mapClasses == ClassMapping.asClasses && outputFileType != TypeScriptFileType.implementationFile) {
            throw new RuntimeException("'mapClasses' parameter is set to 'asClasses' which generates runtime code but 'outputFileType' parameter is not set to 'implementationFile'.");
        }
        if (mapClassesAsClassesPatterns != null && mapClasses != ClassMapping.asClasses) {
            throw new RuntimeException("'mapClassesAsClassesPatterns' parameter can only be used when 'mapClasses' parameter is set to 'asClasses'.");
        }
        if (generateConstructors && mapClasses != ClassMapping.asClasses) {
            throw new RuntimeException("'generateConstructors' parameter can only be used when 'mapClasses' parameter is set to 'asClasses'.");
        }
        checkAnnotationsHaveRuntimeRetention(this.nonConstEnumAnnotations);
        checkAnnotationsHaveRuntimeRetention(this.disableTaggedUnionAnnotations);
        checkAnnotationHasRuntimeRetention(this.restNamespacingAnnotation);
        checkAnnotationsHaveRuntimeRetention(this.includePropertyAnnotations);
        checkAnnotationsHaveRuntimeRetention(this.excludePropertyAnnotations);
        checkAnnotationsHaveRuntimeRetention(this.optionalAnnotations);
        checkAnnotationsHaveRuntimeRetention(this.requiredAnnotations);
        checkAnnotationsHaveRuntimeRetention(this.nullableAnnotations);
        for (Class<? extends Annotation> annotation : optionalAnnotations) {
            final Target target = annotation.getAnnotation(Target.class);
            final List<ElementType> elementTypes = target != null ? Arrays.asList(target.value()) : Arrays.asList();
            if (elementTypes.contains(ElementType.TYPE_PARAMETER) || elementTypes.contains(ElementType.TYPE_USE)) {
                TypeScriptGenerator.getLogger().info(String.format(
                        "Suggestion: annotation '%s' supports 'TYPE_PARAMETER' or 'TYPE_USE' target. Consider using 'nullableAnnotations' parameter instead of 'optionalAnnotations'.",
                        annotation.getName()));
            }
        }
        if (!optionalAnnotations.isEmpty() && !requiredAnnotations.isEmpty()) {
            throw new RuntimeException("Only one of 'optionalAnnotations' and 'requiredAnnotations' can be used at the same time.");
        }
        if (primitivePropertiesRequired && requiredAnnotations.isEmpty()) {
            throw new RuntimeException("'primitivePropertiesRequired' parameter can only be used with 'requiredAnnotations' parameter.");
        }
        for (Class<? extends Annotation> annotation : nullableAnnotations) {
            final Target target = annotation.getAnnotation(Target.class);
            final List<ElementType> elementTypes = target != null ? Arrays.asList(target.value()) : Arrays.asList();
            if (!elementTypes.contains(ElementType.TYPE_PARAMETER) && !elementTypes.contains(ElementType.TYPE_USE)) {
                throw new RuntimeException(String.format(
                        "'%s' annotation cannot be used as nullable annotation because it doesn't have 'TYPE_PARAMETER' or 'TYPE_USE' target.",
                        annotation.getName()));
            }
        }
        if (generateJaxrsApplicationClient && outputFileType != TypeScriptFileType.implementationFile) {
            throw new RuntimeException("'generateJaxrsApplicationClient' can only be used when generating implementation file ('outputFileType' parameter is 'implementationFile').");
        }
        if (generateSpringApplicationClient && outputFileType != TypeScriptFileType.implementationFile) {
            throw new RuntimeException("'generateSpringApplicationClient' can only be used when generating implementation file ('outputFileType' parameter is 'implementationFile').");
        }
        if (restNamespacing != null && !isGenerateRest()) {
            throw new RuntimeException("'restNamespacing' parameter can only be used when generating REST client or interface.");
        }
        if (restNamespacingAnnotation != null && restNamespacing != RestNamespacing.byAnnotation) {
            throw new RuntimeException("'restNamespacingAnnotation' parameter can only be used when 'restNamespacing' parameter is set to 'byAnnotation'.");
        }
        if (restNamespacingAnnotation == null && restNamespacing == RestNamespacing.byAnnotation) {
            throw new RuntimeException("'restNamespacingAnnotation' must be specified when 'restNamespacing' parameter is set to 'byAnnotation'.");
        }
        if (restResponseType != null && !isGenerateRest()) {
            throw new RuntimeException("'restResponseType' parameter can only be used when generating REST client or interface.");
        }
        if (restOptionsType != null && !isGenerateRest()) {
            throw new RuntimeException("'restOptionsType' parameter can only be used when generating REST client or interface.");
        }
        if (generateInfoJson && (outputKind != TypeScriptOutputKind.module && outputKind != TypeScriptOutputKind.global)) {
            throw new RuntimeException("'generateInfoJson' can only be used when 'outputKind' parameter is 'module' or 'global'.");
        }
        if (generateNpmPackageJson && outputKind != TypeScriptOutputKind.module) {
            throw new RuntimeException("'generateNpmPackageJson' can only be used when generating proper module ('outputKind' parameter is 'module').");
        }
        if (generateNpmPackageJson) {
            if (npmName == null || npmVersion == null) {
                throw new RuntimeException("'npmName' and 'npmVersion' must be specified when generating NPM 'package.json'.");
            }
        }
        if (!generateNpmPackageJson) {
            if (npmName != null || npmVersion != null) {
                throw new RuntimeException("'npmName' and 'npmVersion' is only applicable when generating NPM 'package.json'.");
            }
            if (npmTypescriptVersion != null) {
                throw new RuntimeException("'npmTypescriptVersion' is only applicable when generating NPM 'package.json'.");
            }
            if (npmBuildScript != null) {
                throw new RuntimeException("'npmBuildScript' is only applicable when generating NPM 'package.json'.");
            }
        }
        if (npmTypescriptVersion != null && outputFileType != TypeScriptFileType.implementationFile) {
            throw new RuntimeException("'npmTypescriptVersion' can only be used when generating implementation file ('outputFileType' parameter is 'implementationFile').");
        }
        if (npmBuildScript != null && outputFileType != TypeScriptFileType.implementationFile) {
            throw new RuntimeException("'npmBuildScript' can only be used when generating implementation file ('outputFileType' parameter is 'implementationFile').");
        }
        getModuleDependencies();
        getLoadedDataLibraries();
    }
    public NullabilityDefinition getNullabilityDefinition() {
        return nullabilityDefinition != null ? nullabilityDefinition : NullabilityDefinition.nullInlineUnion;
    }
    public TypeParser getTypeParser() {
        if (typeParser == null) {
            typeParser = new TypeParser(nullableAnnotations);
        }
        return typeParser;
    }
    public List<CustomTypeMapping> getValidatedCustomTypeMappings() {
        if (validatedCustomTypeMappings == null) {
            validatedCustomTypeMappings = Utils.concat(
                    validateCustomTypeMappings(customTypeMappings, false),
                    getLoadedDataLibraries().typeMappings);
        }
        return validatedCustomTypeMappings;
    }
    private List<CustomTypeMapping> validateCustomTypeMappings(Map<String, String> customTypeMappings, boolean matchSubclasses) {
        final List<CustomTypeMapping> mappings = new ArrayList<>();
        for (Map.Entry<String, String> entry : customTypeMappings.entrySet()) {
            final String javaName = entry.getKey();
            final String tsName = entry.getValue();
            try {
                final GenericName genericJavaName = parseGenericName(javaName);
                final GenericName genericTsName = parseGenericName(tsName);
                validateTypeParameters(genericJavaName.typeParameters);
                validateTypeParameters(genericTsName.typeParameters);
                final Class<?> cls = loadClass(classLoader, genericJavaName.rawName, null);
                final int required = cls.getTypeParameters().length;
                final int specified = genericJavaName.typeParameters != null ? genericJavaName.typeParameters.size() : 0;
                if (specified != required) {
                    final String parameters = Stream.of(cls.getTypeParameters())
                            .map(TypeVariable::getName)
                            .collect(Collectors.joining(", "));
                    final String signature = cls.getName() + (parameters.isEmpty() ? "" : "<" + parameters + ">");
                    throw new RuntimeException(String.format(
                            "Wrong number of specified generic parameters, required: %s, found: %s. Correct format is: '%s'",
                            required, specified, signature));
                }
                mappings.add(new CustomTypeMapping(cls, matchSubclasses, genericJavaName, genericTsName));
            } catch (Exception e) {
                throw new RuntimeException(String.format("Failed to parse configured custom type mapping '%s:%s': %s", javaName, tsName, e.getMessage()), e);
            }
        }
        return mappings;
    }
    public List<CustomTypeAlias> getValidatedCustomTypeAliases() {
        if (validatedCustomTypeAliases == null) {
            validatedCustomTypeAliases = Utils.concat(
                    validateCustomTypeAliases(customTypeAliases),
                    getLoadedDataLibraries().typeAliases);
        }
        return validatedCustomTypeAliases;
    }
    public List<CustomTypeAlias> validateCustomTypeAliases(Map<String, String> customTypeAliases) {
        final List<CustomTypeAlias> aliases = new ArrayList<>();
        for (Map.Entry<String, String> entry : customTypeAliases.entrySet()) {
            final String tsName = entry.getKey();
            final String tsDefinition = entry.getValue();
            try {
                final GenericName genericTsName = parseGenericName(tsName);
                if (!ModelCompiler.isValidIdentifierName(genericTsName.rawName)) {
                    throw new RuntimeException(String.format("Invalid identifier: '%s'", genericTsName.rawName));
                }
                validateTypeParameters(genericTsName.typeParameters);
                aliases.add(new CustomTypeAlias(genericTsName, tsDefinition));
            } catch (Exception e) {
                throw new RuntimeException(String.format("Failed to parse configured custom type alias '%s:%s': %s", tsName, tsDefinition, e.getMessage()), e);
            }
        }
        return aliases;
    }
    private static GenericName parseGenericName(String name) {
        final Matcher matcher = Pattern.compile("([^<\\[]+)(<|\\[)([^>\\]]+)(>|\\])").matcher(name);
        final String rawName;
        final List<String> typeParameters;
        if (matcher.matches()) {  
            rawName = matcher.group(1);
            typeParameters = Stream.of(matcher.group(3).split(","))
                    .map(String::trim)
                    .collect(Collectors.toList());
        } else {
            rawName = name;
            typeParameters = null;
        }
        return new GenericName(rawName, typeParameters);
    }
    private static void validateTypeParameters(List<String> typeParameters) {
        if (typeParameters == null) {
            return;
        }
        for (String typeParameter : typeParameters) {
            if (!ModelCompiler.isValidIdentifierName(typeParameter)) {
                throw new RuntimeException(String.format("Invalid generic type parameter: '%s'", typeParameter));
            }
        }
    }
    private static void reportConfigurationChange(String extensionName, String parameterName, String parameterValue) {
        TypeScriptGenerator.getLogger().info(String.format("Configuration: '%s' extension set '%s' parameter to '%s'", extensionName, parameterName, parameterValue));
    }
    public String getExtension() {
        return outputFileType == TypeScriptFileType.implementationFile ? ".ts" : ".d.ts";
    }
    public void validateFileName(File outputFile) {
        if (outputFileType == TypeScriptFileType.declarationFile && !outputFile.getName().endsWith(".d.ts")) {
            throw new RuntimeException("Declaration file must have 'd.ts' extension: " + outputFile);
        }
        if (outputFileType == TypeScriptFileType.implementationFile && (!outputFile.getName().endsWith(".ts") || outputFile.getName().endsWith(".d.ts"))) {
            throw new RuntimeException("Implementation file must have 'ts' extension: " + outputFile);
        }
    }
    public String getDefaultNpmVersion() {
        return "1.0.0";
    }
    public LoadedModuleDependencies getModuleDependencies() {
        if (loadedModuleDependencies == null) {
            loadedModuleDependencies = new LoadedModuleDependencies(this, moduleDependencies);
        }
        return loadedModuleDependencies;
    }
    public LoadedDataLibraries getLoadedDataLibraries() {
        if (loadedDataLibrariesClasses == null) {
            loadedDataLibrariesClasses = loadDataLibrariesClasses();
        }
        return loadedDataLibrariesClasses;
    }
    private LoadedDataLibraries loadDataLibrariesClasses() {
        if (additionalDataLibraries == null) {
            return new LoadedDataLibraries();
        }
        final List<LoadedDataLibraries> loaded = new ArrayList<>();
        final ObjectMapper objectMapper = Utils.getObjectMapper();
        objectMapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
        for (String library : additionalDataLibraries) {
            final String resource = "datalibrary/" + library + ".json";
            TypeScriptGenerator.getLogger().verbose("Loading resource " + resource);
            final InputStream inputStream = classLoader.getResourceAsStream(resource);
            if (inputStream == null) {
                throw new RuntimeException("Resource not found: " + resource);
            }
            final DataLibraryJson dataLibrary = Utils.loadJson(objectMapper, inputStream, DataLibraryJson.class);
            final Map<String, String> typeMappings = Utils.listFromNullable(dataLibrary.classMappings).stream()
                    .filter(mapping -> mapping.customType != null)
                    .collect(Utils.toMap(
                            mapping -> mapping.className,
                            mapping -> mapping.customType
                    ));
            final Map<String, String> typeAliases = Utils.listFromNullable(dataLibrary.typeAliases).stream()
                    .collect(Utils.toMap(
                            alias -> alias.name,
                            alias -> alias.definition
                    ));
            loaded.add(new LoadedDataLibraries(
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.String),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.Number),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.Boolean),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.Date),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.Any),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.Void),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.List),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.Map),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.Optional),
                loadDataLibraryClasses(dataLibrary, DataLibraryJson.SemanticType.Wrapper),
                validateCustomTypeMappings(typeMappings, true),
                validateCustomTypeAliases(typeAliases)
            ));
        }
        return LoadedDataLibraries.join(loaded);
    }
    private List<Class<?>> loadDataLibraryClasses(DataLibraryJson dataLibrary, DataLibraryJson.SemanticType semanticType) {
        final List<String> classNames = dataLibrary.classMappings.stream()
                .filter(mapping -> mapping.semanticType == semanticType)
                .map(mapping -> mapping.className)
                .collect(Collectors.toList());
        return loadClasses(classLoader, classNames, null);
    }
    public Predicate<String> getExcludeFilter() {
        if (excludeFilter == null) {
            setExcludeFilter(null, null);
        }
        return excludeFilter;
    }
    public void setExcludeFilter(List<String> excludedClasses, List<String> excludedClassPatterns) {
        this.excludeFilter = createExcludeFilter(excludedClasses, excludedClassPatterns);
    }
    public static Predicate<String> createExcludeFilter(List<String> excludedClasses, List<String> excludedClassPatterns) {
        final Set<String> names = new LinkedHashSet<>(excludedClasses != null ? excludedClasses : Collections.<String>emptyList());
        names.add("java.lang.Record");
        final List<Pattern> patterns = Utils.globsToRegexps(excludedClassPatterns != null ? excludedClassPatterns : Collections.<String>emptyList());
        return new Predicate<String>() {
            @Override
            public boolean test(String className) {
                return names.contains(className) || Utils.classNameMatches(className, patterns);
            }
        };
    }
    public Predicate<String> getMapClassesAsClassesFilter() {
        if (mapClassesAsClassesFilter == null) {
            final List<Pattern> patterns = Utils.globsToRegexps(mapClassesAsClassesPatterns);
            mapClassesAsClassesFilter = new Predicate<String>() {
                @Override
                public boolean test(String className) {
                    return mapClasses == ClassMapping.asClasses &&
                            (patterns == null || Utils.classNameMatches(className, patterns));
                }
            };
        }
        return mapClassesAsClassesFilter;
    }
    public void setRestNamespacingAnnotation(ClassLoader classLoader, String restNamespacingAnnotation) {
        final Pair<Class<? extends Annotation>, String> pair = resolveRestNamespacingAnnotation(classLoader, restNamespacingAnnotation);
        if (pair != null) {
            this.restNamespacingAnnotation = pair.getValue1();
            this.restNamespacingAnnotationElement = pair.getValue2();
        }
    }
    private static Pair<Class<? extends Annotation>, String> resolveRestNamespacingAnnotation(ClassLoader classLoader, String restNamespacingAnnotation) {
        if (restNamespacingAnnotation == null) {
            return null;
        }
        final String[] split = restNamespacingAnnotation.split("#");
        final String className = split[0];
        final String elementName = split.length > 1 ? split[1] : "value";
        final Class<? extends Annotation> annotationClass = loadClass(classLoader, className, Annotation.class);
        return Pair.of(annotationClass, elementName);
    }
    public void setRestOptionsType(String restOptionsType) {
        if (restOptionsType != null) {
            if (restOptionsType.startsWith("<") && restOptionsType.endsWith(">")) {
                this.restOptionsType = restOptionsType.substring(1, restOptionsType.length() - 1);
                this.restOptionsTypeIsGeneric = true;
            } else {
                this.restOptionsType = restOptionsType;
                this.restOptionsTypeIsGeneric = false;
            }
        }
    }
    public List<RestApplicationParser.Factory> getRestApplicationParserFactories() {
        if (restApplicationParserFactories == null) {
            final List<RestApplicationParser.Factory> factories = new ArrayList<>();
            if (isGenerateJaxrs() || !isGenerateSpring()) {
                factories.add(new JaxrsApplicationParser.Factory());
            }
            if (isGenerateSpring()) {
                final String springClassName = "cz.habarta.typescript.generator.spring.SpringApplicationParser$Factory";
                final Class<?> springClass;
                try {
                    springClass = Class.forName(springClassName);
                } catch (ClassNotFoundException e) {
                    throw new RuntimeException("'generateStringApplicationInterface' or 'generateStringApplicationClient' parameter "
                            + "was specified but '" + springClassName + "' was not found. "
                            + "Please add 'cz.habarta.typescript-generator:typescript-generator-spring' artifact "
                            + "to typescript-generator plugin dependencies (not module dependencies).");
                }
                try {
                    final Object instance = springClass.getConstructor().newInstance();
                    factories.add((RestApplicationParser.Factory) instance);
                } catch (ReflectiveOperationException e) {
                    throw new RuntimeException(e);
                }
            }
            restApplicationParserFactories = factories;
        }
        return restApplicationParserFactories;
    }
    public boolean isGenerateJaxrs() {
        return generateJaxrsApplicationInterface || generateJaxrsApplicationClient;
    }
    public boolean isGenerateSpring() {
        return generateSpringApplicationInterface || generateSpringApplicationClient;
    }
    public boolean isGenerateRest() {
        return isGenerateJaxrs() || isGenerateSpring();
    }
    public boolean areDefaultStringEnumsOverriddenByExtension() {
        return defaultStringEnumsOverriddenByExtension;
    }
    private String seeLink() {
        return "For more information see 'http:
    }
    private static <T> List<Class<? extends T>> loadClasses(ClassLoader classLoader, List<String> classNames, Class<T> requiredClassType) {
        if (classNames == null) {
            return Collections.emptyList();
        }
        final List<Class<? extends T>> classes = new ArrayList<>();
        for (String className : classNames) {
            classes.add(loadClass(classLoader, className, requiredClassType));
        }
        return classes;
    }
    static <T> Class<? extends T> loadClass(ClassLoader classLoader, String className, Class<T> requiredClassType) {
        Objects.requireNonNull(classLoader, "classLoader");
        Objects.requireNonNull(className, "className");
        try {
            TypeScriptGenerator.getLogger().verbose("Loading class " + className);
            final Pair<String, Integer> pair = parseArrayClassDimensions(className);
            final int arrayDimensions = pair.getValue2();
            final Class<?> loadedClass;
            if (arrayDimensions > 0) {
                final String componentTypeName = pair.getValue1();
                final Class<?> componentType = loadPrimitiveOrRegularClass(classLoader, componentTypeName);
                loadedClass = Utils.getArrayClass(componentType, arrayDimensions);
            } else {
                loadedClass = loadPrimitiveOrRegularClass(classLoader, className);
            }
            if (requiredClassType != null && !requiredClassType.isAssignableFrom(loadedClass)) {
                throw new RuntimeException(String.format("Class '%s' is not assignable to '%s'.", loadedClass, requiredClassType));
            }
            @SuppressWarnings("unchecked") 
            final Class<? extends T> castedClass = (Class<? extends T>) loadedClass;
            return castedClass;
        } catch (ReflectiveOperationException e) {
            throw new RuntimeException(e);
        }
    }
    private static void checkAnnotationsHaveRuntimeRetention(List<Class<? extends Annotation>> annotationClasses) {
        annotationClasses.forEach(Settings::checkAnnotationHasRuntimeRetention);
    }
    private static void checkAnnotationHasRuntimeRetention(Class<? extends Annotation> annotationClass) {
        if (annotationClass == null) {
            return;
        }
        final Retention retention = annotationClass.getAnnotation(Retention.class);
        if (retention == null || retention.value() != RetentionPolicy.RUNTIME) {
            TypeScriptGenerator.getLogger().warning(String.format(
                "Annotation '%s' has no effect because it doesn't have 'RUNTIME' retention.",
                annotationClass.getName()));
        }
    }
    private static Pair<String, Integer> parseArrayClassDimensions(String className) {
        int dimensions = 0;
        while (className.endsWith("[]")) {
            dimensions++;
            className = className.substring(0, className.length() - 2);
        }
        return Pair.of(className, dimensions);
    }
    private static Class<?> loadPrimitiveOrRegularClass(ClassLoader classLoader, String className) throws ClassNotFoundException {
        final Class<?> primitiveType = Utils.getPrimitiveType(className);
        return primitiveType != null
                ? primitiveType
                : classLoader.loadClass(className);
    }
    private static <T> List<T> loadInstances(ClassLoader classLoader, List<String> classNames, Class<T> requiredType) {
        if (classNames == null) {
            return Collections.emptyList();
        }
        final List<T> instances = new ArrayList<>();
        for (String className : classNames) {
            instances.add(loadInstance(classLoader, className, requiredType));
        }
        return instances;
    }
    private static <T> T loadInstance(ClassLoader classLoader, String className, Class<T> requiredType) {
        try {
            TypeScriptGenerator.getLogger().verbose("Loading class " + className);
            return requiredType.cast(classLoader.loadClass(className).getConstructor().newInstance());
        } catch (ReflectiveOperationException e) {
            throw new RuntimeException(e);
        }
    }
    public static int parseModifiers(String modifiers, int allowedModifiers) {
        return Stream.of(modifiers.split("\\|"))
            .map(String::trim)
            .filter(s -> !s.isEmpty())
            .map(s -> {
                try {
                    return javax.lang.model.element.Modifier.valueOf(s.toUpperCase(Locale.US));
                } catch (IllegalArgumentException e) {
                    throw new RuntimeException("Invalid modifier: " + s);
                }
            })
            .mapToInt(modifier -> {
                final int mod = Settings.modifierToBitMask(modifier);
                if ((mod & allowedModifiers) == 0) {
                    throw new RuntimeException("Modifier not allowed: " + modifier);
                }
                return mod;
            })
            .reduce(0, (a, b) -> a | b);
    }
    private static int modifierToBitMask(javax.lang.model.element.Modifier modifier) {
        switch (modifier) {
            case PUBLIC: return java.lang.reflect.Modifier.PUBLIC;
            case PROTECTED: return java.lang.reflect.Modifier.PROTECTED;
            case PRIVATE: return java.lang.reflect.Modifier.PRIVATE;
            case ABSTRACT: return java.lang.reflect.Modifier.ABSTRACT;
            case STATIC: return java.lang.reflect.Modifier.STATIC;
            case FINAL: return java.lang.reflect.Modifier.FINAL;
            case TRANSIENT: return java.lang.reflect.Modifier.TRANSIENT;
            case VOLATILE: return java.lang.reflect.Modifier.VOLATILE;
            case SYNCHRONIZED: return java.lang.reflect.Modifier.SYNCHRONIZED;
            case NATIVE: return java.lang.reflect.Modifier.NATIVE;
            case STRICTFP: return java.lang.reflect.Modifier.STRICT;
            default: return 0;
        }
    }
}
package cz.habarta.typescript.generator.parser;
import cz.habarta.typescript.generator.ExcludingTypeProcessor;
import cz.habarta.typescript.generator.OptionalProperties;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TypeProcessor;
import cz.habarta.typescript.generator.type.JParameterizedType;
import cz.habarta.typescript.generator.util.Pair;
import cz.habarta.typescript.generator.util.PropertyMember;
import cz.habarta.typescript.generator.util.Utils;
import jakarta.json.JsonArray;
import jakarta.json.JsonNumber;
import jakarta.json.JsonObject;
import jakarta.json.JsonString;
import jakarta.json.JsonValue;
import jakarta.json.bind.annotation.JsonbCreator;
import jakarta.json.bind.annotation.JsonbProperty;
import jakarta.json.bind.annotation.JsonbTransient;
import jakarta.json.bind.annotation.JsonbVisibility;
import jakarta.json.bind.config.PropertyNamingStrategy;
import jakarta.json.bind.config.PropertyVisibilityStrategy;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Parameter;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Proxy;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class JsonbParser extends ModelParser {
    private final Class<? extends Annotation> johnzonAny;
    public static class Factory extends ModelParser.Factory {
        @Override
        public TypeProcessor getSpecificTypeProcessor() {
            return new ExcludingTypeProcessor(Collections.emptyList());
        }
        @Override
        public JsonbParser create(Settings settings, TypeProcessor commonTypeProcessor,
                                  List<RestApplicationParser> restApplicationParsers) {
            return new JsonbParser(settings, commonTypeProcessor, restApplicationParsers);
        }
    }
    public JsonbParser(Settings settings, TypeProcessor commonTypeProcessor) {
        this(settings, commonTypeProcessor, Collections.emptyList());
    }
    public JsonbParser(Settings settings, TypeProcessor commonTypeProcessor,
                       List<RestApplicationParser> restApplicationParsers) {
        super(settings, commonTypeProcessor, restApplicationParsers);
        johnzonAny = loadJohnzonAnyClass();
    }
    @SuppressWarnings("unchecked")
    private Class<? extends Annotation> loadJohnzonAnyClass() {
        try {
            return (Class<? extends Annotation>) settings.classLoader
                    .loadClass("org.apache.johnzon.mapper.JohnzonAny");
        } catch (ClassNotFoundException e) {
            return null;
        }
    }
    @Override
    protected DeclarationModel parseClass(final SourceType<Class<?>> sourceClass) {
        if (sourceClass.type.isEnum()) {
            return ModelParser.parseEnum(sourceClass);
        } else {
            return parseBean(sourceClass);
        }
    }
    private BeanModel parseBean(final SourceType<Class<?>> sourceClass) {
        final JsonbPropertyExtractor extractor = createExtractor();
        final  List<PropertyModel> properties = extractor.visit(sourceClass.type);
        final Type superclass = sourceClass.type.getGenericSuperclass() == Object.class ? null
                : sourceClass.type.getGenericSuperclass();
        if (superclass != null) {
            addBeanToQueue(new SourceType<>(superclass, sourceClass.type, "<superClass>"));
        }
        final List<Type> interfaces = Arrays.asList(sourceClass.type.getGenericInterfaces());
        for (Type aInterface : interfaces) {
            addBeanToQueue(new SourceType<>(aInterface, sourceClass.type, "<interface>"));
        }
        return new BeanModel(
                sourceClass.type, superclass, null, null, null,
                interfaces, properties, null);
    }
    private JsonbPropertyExtractor createExtractor() {
        return new JsonbPropertyExtractor(
                johnzonAny,
                new PropertyNamingStrategyFactory(Optional.ofNullable(settings.jsonbConfiguration).map(c -> c.namingStrategy).orElse("IDENTITY")).create(),
                new DefaultPropertyVisibilityStrategy(settings.classLoader),
                new FieldAndMethodAccessMode(johnzonAny));
    }
    private class JsonbPropertyExtractor {
        private final Class<? extends Annotation> johnzonAny;
        private final PropertyNamingStrategy naming;
        private final PropertyVisibilityStrategy visibility;
        private final BaseAccessMode delegate;
        private JsonbPropertyExtractor(
                final Class<? extends Annotation> johnzonAny,
                final PropertyNamingStrategy propertyNamingStrategy,
                final PropertyVisibilityStrategy visibilityStrategy,
                final BaseAccessMode delegate) {
            this.johnzonAny = johnzonAny;
            this.naming = propertyNamingStrategy;
            this.visibility = visibilityStrategy;
            this.delegate = delegate;
        }
        private List<PropertyModel> visit(final Class<?> clazz) {
            return Stream.of(clazz.getConstructors())
                    .filter(it -> getJsonbAnnotation(it, JsonbCreator.class) != null)
                    .findFirst()
                    .map(it -> new ArrayList<>(Stream.concat(visitConstructor(it), visitClass(clazz).stream())
                            .collect(Collectors.toMap(PropertyModel::getName, Function.identity(), (a, b) -> a)) 
                            .values()))
                    .orElseGet(() -> new ArrayList<>(visitClass(clazz)));
        }
        private Stream<PropertyModel> visitConstructor(final Constructor<?> constructor) {
            final List<Type> parameterTypes = settings.getTypeParser().getConstructorParameterTypes(constructor);
            final List<Pair<Parameter, Type>> parameters = Utils.zip(Arrays.asList(constructor.getParameters()), parameterTypes);
            return parameters.stream()
                    .map(it -> {
                        final Type type = it.getValue2();
                        final Parameter parameter = it.getValue1();
                        final Optional<JsonbProperty> property = Optional.ofNullable(
                                getJsonbAnnotation(parameter, JsonbProperty.class));
                        final PropertyMember propertyMember = new PropertyMember(
                                parameter, it.getValue2(), parameter.getAnnotatedType(), parameter::getAnnotation);
                        return JsonbParser.this.processTypeAndCreateProperty(
                                property
                                    .map(JsonbProperty::value)
                                    .filter(p -> !p.isEmpty())
                                    .orElseGet(parameter::getName),
                                type, null,
                                settings.optionalProperties != OptionalProperties.useLibraryDefinition ?
                                        isPropertyOptional(propertyMember) :
                                        (isOptional(type) || OptionalInt.class == type ||
                                        OptionalLong.class == type || OptionalDouble.class == type ||
                                        property.map(JsonbProperty::nillable).orElse(false)),
                                null, constructor.getDeclaringClass(), new ParameterMember(parameter),
                                null, null);
                    });
        }
        private List<PropertyModel> visitClass(final Class<?> clazz) {
            return delegate.find(clazz).entrySet().stream()
                    .filter(e -> !isTransient(e.getValue(), visibility))
                    .filter(e -> johnzonAny == null || e.getValue().getAnnotation(johnzonAny) == null)
                    .map(e -> {
                        final DecoratedType decoratedType = e.getValue();
                        final Member member = findMember(decoratedType);
                        final PropertyMember propertyMember = wrapMember(
                                settings.getTypeParser(), member,  null, decoratedType::getAnnotation, member.getName(), member.getDeclaringClass());
                        if (propertyMember == null) {
                            return null;
                        }
                        final JsonbProperty property = decoratedType.getAnnotation(JsonbProperty.class);
                        final String key = property == null || property.value().isEmpty() ? naming.translateName(e.getKey()) : property.value();
                        final Type type = Field.class.isInstance(member) ?
                                settings.getTypeParser().getFieldType(Field.class.cast(member)) :
                                settings.getTypeParser().getMethodReturnType(Method.class.cast(member));
                        return JsonbParser.this.processTypeAndCreateProperty(
                                key, replaceType(type),
                                null, settings.optionalProperties == OptionalProperties.useLibraryDefinition ||
                                        JsonbParser.this.isPropertyOptional(propertyMember),
                                null, clazz, member, null, null);
                    })
                    .filter(Objects::nonNull)
                    .sorted(Comparator.comparing(PropertyModel::getName))
                    .collect(Collectors.toList());
        }
        private Type replaceType(final Type type) {
            if (type == JsonValue.class || type == javax.json.JsonValue.class) {
                return Object.class;
            }
            if (type == JsonObject.class || type == javax.json.JsonObject.class) {
                return new JParameterizedType(Map.class, new Type[]{String.class, Object.class}, null);
            }
            if (type == JsonArray.class || type == javax.json.JsonArray.class) {
                return new JParameterizedType(List.class, new Type[]{Object.class}, null);
            }
            if (type == JsonString.class || type == javax.json.JsonString.class) {
                return String.class;
            }
            if (type == JsonNumber.class || type == javax.json.JsonNumber.class) {
                return Double.class;
            }
            return type;
        }
        private Member findMember(final DecoratedType value) {
            if (FieldAndMethodAccessMode.CompositeDecoratedType.class.isInstance(value)) { 
                final FieldAndMethodAccessMode.CompositeDecoratedType<?> decoratedType = FieldAndMethodAccessMode.CompositeDecoratedType.class.cast(value);
                final DecoratedType type1 = decoratedType.getType1();
                final DecoratedType type2 = decoratedType.getType2();
                if (FieldAccessMode.FieldDecoratedType.class.isInstance(type1)) {
                    return findMember(type1);
                }
                return findMember(type2);
            } else if (JsonbParser.FieldAccessMode.FieldDecoratedType.class.isInstance(value)){
                return JsonbParser.FieldAccessMode.FieldDecoratedType.class.cast(value).getField();
            } else if (MethodAccessMode.MethodDecoratedType.class.isInstance(value)){
                return MethodAccessMode.MethodDecoratedType.class.cast(value).getMethod();
            }
            throw new IllegalArgumentException("Unsupported reader: " + value);
        }
        private boolean isOptional(final Type type) {
            return ParameterizedType.class.isInstance(type) && Optional.class == ParameterizedType.class.cast(type).getRawType();
        }
        private boolean isTransient(final JsonbParser.DecoratedType dt, final PropertyVisibilityStrategy visibility) {
            if (!FieldAndMethodAccessMode.CompositeDecoratedType.class.isInstance(dt)) {
                return isTransient(dt) || shouldSkip(visibility, dt);
            }
            final FieldAndMethodAccessMode.CompositeDecoratedType<?> cdt = FieldAndMethodAccessMode.CompositeDecoratedType.class.cast(dt);
            return isTransient(cdt.getType1()) || isTransient(cdt.getType2()) ||
                    (shouldSkip(visibility, cdt.getType1()) && shouldSkip(visibility, cdt.getType2()));
        }
        private boolean shouldSkip(final PropertyVisibilityStrategy visibility, final JsonbParser.DecoratedType t) {
            return isNotVisible(visibility, t);
        }
        private boolean isTransient(final JsonbParser.DecoratedType t) {
            if (t.getAnnotation(JsonbTransient.class) != null) {
                return true;
            }
            if (JsonbParser.FieldAccessMode.FieldDecoratedType.class.isInstance(t)) {
                final Field field = JsonbParser.FieldAccessMode.FieldDecoratedType.class.cast(t).getField();
                return Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers());
            }
            return false;
        }
        private boolean isNotVisible(final PropertyVisibilityStrategy visibility, final JsonbParser.DecoratedType t) {
            return !(JsonbParser.FieldAccessMode.FieldDecoratedType.class.isInstance(t) ?
                    visibility.isVisible(JsonbParser.FieldAccessMode.FieldDecoratedType.class.cast(t).getField())
                    : (MethodAccessMode.MethodDecoratedType.class.isInstance(t) &&
                    visibility.isVisible(MethodAccessMode.MethodDecoratedType.class.cast(t).getMethod())));
        }
    }
    private interface DecoratedType {
        Type getType();
        <T extends Annotation> T getAnnotation(Class<T> clazz);
        <T extends Annotation> T getClassOrPackageAnnotation(Class<T> clazz);
    }
    private interface BaseAccessMode  {
        Map<String, JsonbParser.DecoratedType> find(Class<?> clazz);
    }
    private static class FieldAccessMode implements BaseAccessMode {
        private final Class<? extends Annotation> johnzonAny;
        public FieldAccessMode(final Class<? extends Annotation> johnzonAny) {
            this.johnzonAny = johnzonAny;
        }
        @Override
        public Map<String, JsonbParser.DecoratedType> find(final Class<?> clazz) {
            final Map<String, JsonbParser.DecoratedType> readers = new HashMap<>();
            for (final Map.Entry<String, Field> f : fields(clazz, true).entrySet()) {
                final String key = f.getKey();
                if (isIgnored(key) || (johnzonAny != null && Meta.getAnnotation(f.getValue(), johnzonAny) != null)) {
                    continue;
                }
                final Field field = f.getValue();
                readers.put(key, new FieldDecoratedType(field, field.getGenericType()));
            }
            return readers;
        }
        protected boolean isIgnored(final String key) {
            return key.contains("$");
        }
        protected Map<String, Field> fields(final Class<?> clazz, final boolean includeFinalFields) {
            final Map<String, Field> fields = new HashMap<>();
            Class<?> current = clazz;
            while (current != null && current != Object.class) {
                for (final Field f : current.getDeclaredFields()) {
                    final String name = f.getName();
                    final int modifiers = f.getModifiers();
                    if (fields.containsKey(name)
                            || Modifier.isStatic(modifiers)
                            || Modifier.isTransient(modifiers)
                            || (!includeFinalFields && Modifier.isFinal(modifiers))) {
                        continue;
                    }
                    fields.put(name, f);
                }
                current = current.getSuperclass();
            }
            return fields;
        }
        private static class FieldDecoratedType implements JsonbParser.DecoratedType {
            protected final Field field;
            protected final Type type;
            public FieldDecoratedType(final Field field, final Type type) {
                this.field = field;
                this.field.setAccessible(true);
                this.type = type;
            }
            @Override
            public <T extends Annotation> T getClassOrPackageAnnotation(final Class<T> clazz) {
                return Meta.getClassOrPackageAnnotation(field, clazz);
            }
            public Field getField() {
                return field;
            }
            @Override
            public Type getType() {
                return type;
            }
            @Override
            public <T extends Annotation> T getAnnotation(final Class<T> clazz) {
                return Meta.getAnnotation(field, clazz);
            }
            @Override
            public String toString() {
                return "FieldDecoratedType{" +
                        "field=" + field +
                        '}';
            }
        }
    }
    private static class MethodAccessMode implements BaseAccessMode {
        private final Class<? extends Annotation> johnzonAny;
        public MethodAccessMode(final Class<? extends Annotation> johnzonAny) {
            this.johnzonAny = johnzonAny;
        }
        @Override
        public Map<String, DecoratedType> find(final Class<?> clazz) {
            final Map<String, DecoratedType> readers = new HashMap<>();
            if (Records.isRecord(clazz)) {
                readers.putAll(Stream.of(clazz.getMethods())
                        .filter(it -> it.getDeclaringClass() != Object.class && it.getParameterCount() == 0)
                        .filter(it -> !"toString".equals(it.getName()) && !"hashCode".equals(it.getName()))
                        .filter(it -> !isIgnored(it.getName()) && johnzonAny != null && Meta.getAnnotation(it, johnzonAny) == null)
                        .collect(Collectors.toMap(Method::getName, it -> new MethodDecoratedType(it, it.getGenericReturnType()) {
                        })));
            } else {
                final PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(clazz);
                for (final PropertyDescriptor descriptor : propertyDescriptors) {
                    final Method readMethod = descriptor.getReadMethod();
                    final String name = descriptor.getName();
                    if (readMethod != null && readMethod.getDeclaringClass() != Object.class) {
                        if (isIgnored(name) || johnzonAny != null && Meta.getAnnotation(readMethod, johnzonAny) != null) {
                            continue;
                        }
                        readers.put(name, new MethodDecoratedType(readMethod, readMethod.getGenericReturnType()));
                    } else if (readMethod == null && descriptor.getWriteMethod() != null && 
                            (descriptor.getPropertyType() == Boolean.class || descriptor.getPropertyType() == boolean.class)) {
                        try {
                            final Method method = clazz.getMethod(
                                    "is" + Character.toUpperCase(name.charAt(0)) + (name.length() > 1 ? name.substring(1) : ""));
                            readers.put(name, new MethodDecoratedType(method, method.getGenericReturnType()));
                        } catch (final NoSuchMethodException e) {
                        }
                    }
                }
            }
            return readers;
        }
        protected boolean isIgnored(final String name) {
            return name.equals("metaClass") || name.contains("$");
        }
        private PropertyDescriptor[] getPropertyDescriptors(final Class<?> clazz) {
            final PropertyDescriptor[] propertyDescriptors;
            try {
                propertyDescriptors = Introspector.getBeanInfo(clazz).getPropertyDescriptors();
            } catch (final IntrospectionException e) {
                throw new IllegalStateException(e);
            }
            return propertyDescriptors;
        }
        public static class MethodDecoratedType implements DecoratedType {
            protected final Method method;
            protected final Type type;
            public MethodDecoratedType(final Method method, final Type type) {
                this.method = method;
                method.setAccessible(true);
                this.type = type;
            }
            @Override
            public <T extends Annotation> T getClassOrPackageAnnotation(final Class<T> clazz) {
                return Meta.getClassOrPackageAnnotation(method, clazz);
            }
            public Method getMethod() {
                return method;
            }
            @Override
            public Type getType() {
                return type;
            }
            @Override
            public <T extends Annotation> T getAnnotation(final Class<T> clazz) {
                return Meta.getAnnotation(method, clazz);
            }
            @Override
            public String toString() {
                return "MethodDecoratedType{" +
                        "method=" + method +
                        '}';
            }
        }
    }
    private static class FieldAndMethodAccessMode implements BaseAccessMode {
        private final FieldAccessMode fields;
        private final MethodAccessMode methods;
        private FieldAndMethodAccessMode(final Class<? extends Annotation> johnzonAny) {
            this.fields = new FieldAccessMode(johnzonAny);
            this.methods = new MethodAccessMode(johnzonAny);
        }
        @Override
        public Map<String, JsonbParser.DecoratedType> find(final Class<?> clazz) {
            final Map<String, JsonbParser.DecoratedType> methodReaders = this.methods.find(clazz);
            final boolean record = Records.isRecord(clazz);
            if (record) {
                return methodReaders;
            }
            final Map<String, JsonbParser.DecoratedType> fieldsReaders = this.fields.find(clazz);
            final Map<String, JsonbParser.DecoratedType> readers = new HashMap<>(fieldsReaders);
            for (final Map.Entry<String, JsonbParser.DecoratedType> entry : methodReaders.entrySet()) {
                final Method mr = MethodAccessMode.MethodDecoratedType.class.cast(entry.getValue()).getMethod();
                final String fieldName = record ?
                        mr.getName() :
                        Introspector.decapitalize(mr.getName().startsWith("is") ?
                                mr.getName().substring(2) : mr.getName().substring(3));
                final Field f = getField(fieldName, clazz);
                final JsonbParser.DecoratedType existing = readers.get(entry.getKey());
                if (existing == null) {
                    if (f != null) { 
                        readers.put(entry.getKey(), new CompositeDecoratedType<>(
                                entry.getValue(), new FieldAccessMode.FieldDecoratedType(f, f.getType())));
                    } else {
                        readers.put(entry.getKey(), entry.getValue());
                    }
                } else {
                    readers.put(entry.getKey(), new CompositeDecoratedType<>(entry.getValue(), existing));
                }
            }
            return readers;
        }
        private Field getField(final String fieldName, final Class<?> type) {
            Class<?> t = type;
            while (t != Object.class && t != null) {
                try {
                    return t.getDeclaredField(fieldName);
                } catch (final NoSuchFieldException e) {
                }
                t = t.getSuperclass();
            }
            return null;
        }
        public static class CompositeDecoratedType<T extends DecoratedType> implements DecoratedType {
            protected final T type1;
            protected final T type2;
            private CompositeDecoratedType(final T type1, final T type2) {
                this.type1 = type1;
                this.type2 = type2;
            }
            @Override
            public <A extends Annotation> A getClassOrPackageAnnotation(final Class<A> clazz) {
                final A found = type1.getClassOrPackageAnnotation(clazz);
                return found == null ? type2.getClassOrPackageAnnotation(clazz) : found;
            }
            @Override
            public <A extends Annotation> A getAnnotation(final Class<A> clazz) {
                final A found = type1.getAnnotation(clazz);
                return found == null ? type2.getAnnotation(clazz) : found;
            }
            @Override
            public Type getType() {
                return type1.getType();
            }
            public DecoratedType getType1() {
                return type1;
            }
            public DecoratedType getType2() {
                return type2;
            }
            @Override
            public String toString() {
                return "CompositeDecoratedType{" +
                        "type1=" + type1 +
                        ", type2=" + type2 +
                        '}';
            }
        }
    }
    private static class DefaultPropertyVisibilityStrategy implements PropertyVisibilityStrategy {
        private final ClassLoader classLoader;
        private final ConcurrentMap<Class<?>, PropertyVisibilityStrategy> strategies = new ConcurrentHashMap<>();
        public DefaultPropertyVisibilityStrategy(ClassLoader classLoader) {
            this.classLoader = classLoader;
        }
        @Override
        public boolean isVisible(final Field field) {
            if (getJsonbAnnotation(field, JsonbProperty.class) != null) {
                return true;
            }
            final PropertyVisibilityStrategy strategy = strategies.computeIfAbsent(
                    field.getDeclaringClass(), this::visibilityStrategy);
            return strategy == this ? Modifier.isPublic(field.getModifiers()) : strategy.isVisible(field);
        }
        @Override
        public boolean isVisible(final Method method) {
            final PropertyVisibilityStrategy strategy = strategies.computeIfAbsent(
                    method.getDeclaringClass(), this::visibilityStrategy);
            return strategy == this ? Modifier.isPublic(method.getModifiers()) : strategy.isVisible(method);
        }
        private PropertyVisibilityStrategy visibilityStrategy(final Class<?> type) {
            JsonbVisibility visibility = getJsonbAnnotation(type, JsonbVisibility.class);
            if (visibility != null) {
                return newVisibilityStrategy(visibility);
            }
            Package p = type.getPackage();
            while (p != null) {
                visibility = getJsonbAnnotation(p, JsonbVisibility.class);
                if (visibility != null) {
                    return newVisibilityStrategy(visibility);
                }
                final String name = p.getName();
                final int end = name.lastIndexOf('.');
                if (end < 0) {
                    break;
                }
                final String parentPack = name.substring(0, end);
                p = Package.getPackage(parentPack);
                if (p == null) {
                    try {
                        p = classLoader.loadClass(parentPack + ".package-info").getPackage();
                    } catch (final ClassNotFoundException e) {
                    }
                }
            }
            return this;
        }
        private PropertyVisibilityStrategy newVisibilityStrategy(JsonbVisibility visibility) {
            try {
                return Utils.asMigrationProxy(visibility.value().getConstructor().newInstance(), PropertyVisibilityStrategy.class);
            } catch (final ReflectiveOperationException e) {
                throw new IllegalArgumentException(e);
            }
        }
    }
    private static class PropertyNamingStrategyFactory {
        private final Object value;
        public PropertyNamingStrategyFactory(final Object value) {
            this.value = value;
        }
        public PropertyNamingStrategy create() {
            if (String.class.isInstance(value)) {
                final String val = value.toString();
                switch (val) {
                    case PropertyNamingStrategy.IDENTITY:
                        return propertyName -> propertyName;
                    case PropertyNamingStrategy.LOWER_CASE_WITH_DASHES:
                        return new ConfigurableNamingStrategy(Character::toLowerCase, '-');
                    case PropertyNamingStrategy.LOWER_CASE_WITH_UNDERSCORES:
                        return new ConfigurableNamingStrategy(Character::toLowerCase, '_');
                    case PropertyNamingStrategy.UPPER_CAMEL_CASE:
                        return camelCaseStrategy();
                    case PropertyNamingStrategy.UPPER_CAMEL_CASE_WITH_SPACES:
                        final PropertyNamingStrategy camelCase = camelCaseStrategy();
                        final PropertyNamingStrategy space = new ConfigurableNamingStrategy(Function.identity(), ' ');
                        return propertyName -> camelCase.translateName(space.translateName(propertyName));
                    case PropertyNamingStrategy.CASE_INSENSITIVE:
                        return propertyName -> propertyName;
                    default:
                        throw new IllegalArgumentException(val + " unknown as PropertyNamingStrategy");
                }
            }
            if (PropertyNamingStrategy.class.isInstance(value)) {
                return PropertyNamingStrategy.class.cast(value);
            }
            throw new IllegalArgumentException(value + " not supported as PropertyNamingStrategy");
        }
        private PropertyNamingStrategy camelCaseStrategy() {
            return propertyName -> Character.toUpperCase(propertyName.charAt(0)) + (propertyName.length() > 1 ? propertyName.substring(1) : "");
        }
        private static class ConfigurableNamingStrategy implements PropertyNamingStrategy {
            private final Function<Character, Character> converter;
            private final char separator;
            public ConfigurableNamingStrategy(final Function<Character, Character> wordConverter, final char sep) {
                this.converter = wordConverter;
                this.separator = sep;
            }
            @Override
            public String translateName(final String propertyName) {
                final StringBuilder global = new StringBuilder();
                final StringBuilder current = new StringBuilder();
                for (int i = 0; i < propertyName.length(); i++) {
                    final char c = propertyName.charAt(i);
                    if (Character.isUpperCase(c)) {
                        final char transformed = converter.apply(c);
                        if (current.length() > 0) {
                            global.append(current).append(separator);
                            current.setLength(0);
                        }
                        current.append(transformed);
                    } else {
                        current.append(c);
                    }
                }
                if (current.length() > 0) {
                    global.append(current);
                } else {
                    global.setLength(global.length() - 1); 
                }
                return global.toString();
            }
        }
    }
    private static class Records {
        private static final Method IS_RECORD;
        static {
            Method isRecord = null;
            try {
                isRecord = Class.class.getMethod("isRecord");
            } catch (final NoSuchMethodException e) {
            }
            IS_RECORD = isRecord;
        }
        private Records() {
        }
        public static boolean isRecord(final Class<?> clazz) {
            try {
                return IS_RECORD != null && Boolean.class.cast(IS_RECORD.invoke(clazz));
            } catch (final InvocationTargetException | IllegalAccessException e) {
                return false;
            }
        }
    }
    private static final class Meta {
        private Meta() {
        }
        private static <T extends Annotation> T getAnnotation(final AnnotatedElement holder, final Class<T> api) {
            return getDirectAnnotation(holder, api);
        }
        private static <T extends Annotation> T getClassOrPackageAnnotation(final Method holder, final Class<T> api) {
            return getIndirectAnnotation(api, holder::getDeclaringClass, () -> holder.getDeclaringClass().getPackage());
        }
        private static <T extends Annotation> T getClassOrPackageAnnotation(final Field holder, final Class<T> api) {
            return getIndirectAnnotation(api, holder::getDeclaringClass, () -> holder.getDeclaringClass().getPackage());
        }
        private static <T extends Annotation> T getDirectAnnotation(final AnnotatedElement holder, final Class<T> api) {
            final T annotation = getJsonbAnnotation(holder, api);
            if (annotation != null) {
                return annotation;
            }
            return findMeta(holder.getAnnotations(), api);
        }
        private static <T extends Annotation> T getIndirectAnnotation(final Class<T> api,
                                                                      final Supplier<Class<?>> ownerSupplier,
                                                                      final Supplier<Package> packageSupplier) {
            final T ownerAnnotation = getJsonbAnnotation(ownerSupplier.get(), api);
            if (ownerAnnotation != null) {
                return ownerAnnotation;
            }
            final Package pck = packageSupplier.get();
            if (pck != null) {
                return getJsonbAnnotation(pck, api);
            }
            return null;
        }
        public static <T extends Annotation> T findMeta(final Annotation[] annotations, final Class<T> api) {
            for (final Annotation a : annotations) {
                final Class<? extends Annotation> userType = a.annotationType();
                final T aa = getJsonbAnnotation(userType, api);
                if (aa != null) {
                    boolean overriden = false;
                    final Map<String, Method> mapping = new HashMap<String, Method>();
                    for (final Class<?> cm : Arrays.asList(api, userType)) {
                        for (final Method m : cm.getMethods()) {
                            overriden = mapping.put(m.getName(), m) != null || overriden;
                        }
                    }
                    if (!overriden) {
                        return aa;
                    }
                    return api.cast(newAnnotation(mapping, a, aa));
                }
            }
            return null;
        }
        @SuppressWarnings("unchecked")
        private static <T extends Annotation> T newAnnotation(final Map<String, Method> methodMapping, final Annotation user, final T johnzon) {
            return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), new Class<?>[]{johnzon.annotationType()},
                    (proxy, method, args) -> {
                        final Method m = methodMapping.get(method.getName());
                        try {
                            if (m.getDeclaringClass() == user.annotationType()) {
                                return m.invoke(user, args);
                            }
                            return m.invoke(johnzon, args);
                        } catch (final InvocationTargetException ite) {
                            throw ite.getTargetException();
                        }
                    });
        }
    }
    private static class ParameterMember implements Member, AnnotatedElement {
        private final Parameter parameter;
        public ParameterMember(final Parameter parameter) {
            this.parameter = parameter;
        }
        @Override
        public Class<?> getDeclaringClass() {
            return parameter.getDeclaringExecutable().getDeclaringClass();
        }
        @Override
        public String getName() {
            return parameter.getName();
        }
        @Override
        public int getModifiers() {
            return parameter.getModifiers();
        }
        @Override
        public boolean isSynthetic() {
            return parameter.isSynthetic();
        }
        @Override
        public <T extends Annotation> T getAnnotation(final Class<T> type) {
            return parameter.getAnnotation(type);
        }
        @Override
        public Annotation[] getAnnotations() {
            return parameter.getAnnotations();
        }
        @Override
        public Annotation[] getDeclaredAnnotations() {
            return parameter.getDeclaredAnnotations();
        }
    }
    static <A extends Annotation> A getJsonbAnnotation(AnnotatedElement annotatedElement, Class<A> jakartaAnnotationClass) {
        final Class<?> javaxAnnotationClass = javax(jakartaAnnotationClass);
        return Utils.getMigratedAnnotation(annotatedElement, jakartaAnnotationClass, javaxAnnotationClass);
    }
    private static <T> Class<T> javax(Class<T> jakartaClass) {
        @SuppressWarnings("unchecked")
        final Class<T> cls = (Class<T>) javaxClasses.get().get(jakartaClass);
        return cls;
    }
    private static final Supplier<Map<Class<?>, Class<?>>> javaxClasses = Utils.memoize(() -> {
        final Map<Class<?>, Class<?>> map = new LinkedHashMap<>();
        map.put(jakarta.json.bind.annotation.JsonbCreator.class, javax.json.bind.annotation.JsonbCreator.class);
        map.put(jakarta.json.bind.annotation.JsonbProperty.class, javax.json.bind.annotation.JsonbProperty.class);
        map.put(jakarta.json.bind.annotation.JsonbTransient.class, javax.json.bind.annotation.JsonbTransient.class);
        map.put(jakarta.json.bind.annotation.JsonbVisibility.class, javax.json.bind.annotation.JsonbVisibility.class);
        map.put(jakarta.json.bind.config.PropertyNamingStrategy.class, javax.json.bind.config.PropertyNamingStrategy.class);
        map.put(jakarta.json.bind.config.PropertyVisibilityStrategy.class, javax.json.bind.config.PropertyVisibilityStrategy.class);
        return map;
    });
}
package cz.habarta.typescript.generator;
import cz.habarta.typescript.generator.parser.SourceType;
import cz.habarta.typescript.generator.util.Utils;
import io.github.classgraph.ClassGraph;
import io.github.classgraph.ScanResult;
import java.lang.reflect.Type;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
public class Input {
    private final List<SourceType<Type>> sourceTypes;
    private Input(List<SourceType<Type>> sourceTypes) {
        this.sourceTypes = sourceTypes;
    }
    public List<SourceType<Type>> getSourceTypes() {
        return sourceTypes;
    }
    public static Input from(Type... types) {
        Objects.requireNonNull(types, "types");
        final List<SourceType<Type>> sourceTypes = new ArrayList<>();
        for (Type type : types) {
            sourceTypes.add(new SourceType<>(type));
        }
        return new Input(sourceTypes);
    }
    public static class Parameters {
        public List<String> classNames;
        public List<String> classNamePatterns;
        public List<String> classesWithAnnotations;
        public List<String> classesImplementingInterfaces;
        public List<String> classesExtendingClasses;
        public String jaxrsApplicationClassName;
        public boolean automaticJaxrsApplication;
        public Predicate<String> isClassNameExcluded;
        public URLClassLoader classLoader;
        public List<String> scanningAcceptedPackages;
        public boolean debug;
    }
    public static Input from(Parameters parameters) {
        final ClassLoader originalContextClassLoader = Thread.currentThread().getContextClassLoader();
        try {
            if (parameters.classLoader != null) {
                Thread.currentThread().setContextClassLoader(parameters.classLoader);
            }
            try (final ClasspathScanner classpathScanner = new ClasspathScanner(parameters.classLoader, parameters.scanningAcceptedPackages, parameters.debug)) {
                final List<SourceType<Type>> types = new ArrayList<>();
                if (parameters.classNames != null) {
                    types.addAll(fromClassNames(parameters.classNames));
                }
                if (parameters.classNamePatterns != null) {
                    types.addAll(fromClassNamePatterns(classpathScanner.getScanResult(), parameters.classNamePatterns));
                }
                if (parameters.classesImplementingInterfaces != null) {
                    final ScanResult scanResult = classpathScanner.getScanResult();
                    final List<SourceType<Type>> c = fromClassNames(parameters.classesImplementingInterfaces.stream()
                            .flatMap(interf -> scanResult.getClassesImplementing(interf).getNames().stream())
                            .distinct()
                            .collect(Collectors.toList())
                    );
                    types.addAll(c);
                }
                if (parameters.classesExtendingClasses != null) {
                    final ScanResult scanResult = classpathScanner.getScanResult();
                    final List<SourceType<Type>> c = fromClassNames(parameters.classesExtendingClasses.stream()
                            .flatMap(superclass -> scanResult.getSubclasses(superclass).getNames().stream())
                            .distinct()
                            .collect(Collectors.toList())
                    );
                    types.addAll(c);
                }
                if (parameters.classesWithAnnotations != null) {
                    final ScanResult scanResult = classpathScanner.getScanResult();
                    types.addAll(fromClassNames(parameters.classesWithAnnotations.stream()
                            .flatMap(annotation -> scanResult.getClassesWithAnnotation(annotation).getNames().stream())
                            .distinct()
                            .collect(Collectors.toList())
                    ));
                }
                if (parameters.jaxrsApplicationClassName != null) {
                    types.addAll(fromClassNames(Arrays.asList(parameters.jaxrsApplicationClassName)));
                }
                if (parameters.automaticJaxrsApplication) {
                    types.addAll(JaxrsApplicationScanner.scanAutomaticJaxrsApplication(classpathScanner.getScanResult(), parameters.isClassNameExcluded));
                }
                if (types.isEmpty()) {
                    final String errorMessage = "No input classes found.";
                    TypeScriptGenerator.getLogger().error(errorMessage);
                    throw new RuntimeException(errorMessage);
                }
                return new Input(types);
            }
        } finally {
            Thread.currentThread().setContextClassLoader(originalContextClassLoader);
        }
    }
    private static class ClasspathScanner implements AutoCloseable {
        private final URLClassLoader classLoader;
        private final List<String> acceptedPackages;
        private final boolean verbose;
        private ScanResult scanResult = null;
        public ClasspathScanner(URLClassLoader classLoader, List<String> acceptedPackages, boolean verbose) {
            this.classLoader = classLoader;
            this.acceptedPackages = acceptedPackages;
            this.verbose = verbose;
        }
        public ScanResult getScanResult() {
            if (scanResult == null) {
                TypeScriptGenerator.getLogger().info("Scanning classpath");
                final Date scanStart = new Date();
                ClassGraph classGraph = new ClassGraph()
                        .enableClassInfo()
                        .enableAnnotationInfo()
                        .ignoreClassVisibility();
                if (classLoader != null) {
                    classGraph = classGraph.overrideClasspath((Object[])classLoader.getURLs());
                }
                if (acceptedPackages != null && !acceptedPackages.isEmpty()) {
                    classGraph = classGraph.acceptPackages(acceptedPackages.toArray(new String[0]));
                }
                if (verbose) {
                    classGraph = classGraph.verbose();
                }
                final ScanResult result = classGraph.scan();
                final int count = result.getAllClasses().size();
                final Date scanEnd = new Date();
                final double timeInSeconds = (scanEnd.getTime() - scanStart.getTime()) / 1000.0;
                TypeScriptGenerator.getLogger().info(String.format("Scanning finished in %.2f seconds. Total number of classes: %d.", timeInSeconds, count));
                scanResult = result;
            }
            return scanResult;
        }
        @Override
        public void close() {
            if (scanResult != null) {
                scanResult.close();
            }
        }
    }
    private static List<SourceType<Type>> fromClassNamePatterns(ScanResult scanResult, List<String> classNamePatterns) {
        final List<String> allClassNames = new ArrayList<>();
        allClassNames.addAll(scanResult.getAllStandardClasses().getNames());
        allClassNames.addAll(scanResult.getAllInterfaces().getNames());
        Collections.sort(allClassNames);
        final List<String> classNames = filterClassNames(allClassNames, classNamePatterns);
        TypeScriptGenerator.getLogger().info(String.format("Found %d classes matching pattern.", classNames.size()));
        return fromClassNames(classNames);
    }
    private static List<SourceType<Type>> fromClassNames(List<String> classNames) {
        final List<SourceType<Type>> types = new ArrayList<>();
        for (Class<?> cls : loadClasses(classNames)) {
            if (!cls.isSynthetic() && !cls.isAnonymousClass()) {
                types.add(new SourceType<>(cls, null, null));
            }
        }
        return types;
    }
    static List<Class<?>> loadClasses(List<String> classNames) {
        final List<Class<?>> classes = new ArrayList<>();
        for (String className : classNames) {
            try {
                final Class<?> cls = Thread.currentThread().getContextClassLoader().loadClass(className);
                classes.add(cls);
            } catch (ReflectiveOperationException e) {
                final String errorMessage = String.format("Cannot load class '%s'", className);
                TypeScriptGenerator.getLogger().error(errorMessage);
                throw new RuntimeException(errorMessage, e);
            }
        }
        return classes;
    }
    static List<String> filterClassNames(List<String> classNames, List<String> globs) {
        final List<Pattern> regexps = Utils.globsToRegexps(globs);
        final List<String> result = new ArrayList<>();
        for (String className : classNames) {
            if (Utils.classNameMatches(className, regexps)) {
                result.add(className);
            }
        }
        return result;
    }
}
package cz.habarta.typescript.generator;
import cz.habarta.typescript.generator.compiler.Symbol;
import cz.habarta.typescript.generator.compiler.SymbolTable;
import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
public interface TypeProcessor {
    public Result processType(Type javaType, Context context);
    public default Result processTypeInTemporaryContext(Type type, Object typeContext, Settings settings) {
        return processType(type, new Context(new SymbolTable(settings), this, typeContext));
    }
    public default List<Class<?>> discoverClassesUsedInType(Type type, Object typeContext, Settings settings) {
        final TypeProcessor.Result result = processTypeInTemporaryContext(type, typeContext, settings);
        return result != null ? result.getDiscoveredClasses() : Collections.emptyList();
    }
    public default boolean isTypeExcluded(Type type, Object typeContext, Settings settings) {
        final TypeProcessor.Result result = processTypeInTemporaryContext(type, typeContext, settings);
        return result != null && result.tsType == TsType.Any;
    }
    public static class Context {
        private final SymbolTable symbolTable;
        private final TypeProcessor typeProcessor;
        private final Object typeContext;
        private final boolean insideCollection;
        public Context(SymbolTable symbolTable, TypeProcessor typeProcessor, Object typeContext) {
            this(symbolTable, typeProcessor, typeContext, false);
        }
        public Context(SymbolTable symbolTable, TypeProcessor typeProcessor, Object typeContext, boolean insideCollection) {
            this.symbolTable = Objects.requireNonNull(symbolTable, "symbolTable");
            this.typeProcessor = Objects.requireNonNull(typeProcessor, "typeProcessor");
            this.typeContext = typeContext;
            this.insideCollection = insideCollection;
        }
        public Symbol getSymbol(Class<?> cls) {
            return symbolTable.getSymbol(cls);
        }
        public Symbol getSymbolIfImported(Class<?> cls) {
            return symbolTable.getSymbolIfImported(cls);
        }
        public Result processType(Type javaType) {
            return typeProcessor.processType(javaType, this);
        }
        public Result processTypeInsideCollection(Type javaType) {
            return typeProcessor.processType(javaType, this.withInsideCollection());
        }
        public Object getTypeContext() {
            return typeContext;
        }
        public boolean isInsideCollection() {
            return insideCollection;
        }
        public Context withTypeContext(Object typeContext) {
            return new Context(symbolTable, typeProcessor, typeContext, insideCollection);
        }
        public Context withInsideCollection() {
            return new Context(symbolTable, typeProcessor, typeContext, true);
        }
    }
    public static class Result {
        private final TsType tsType;
        private final List<Class<?>> discoveredClasses;
        public Result(TsType tsType, List<Class<?>> discoveredClasses) {
            this.tsType = tsType;
            this.discoveredClasses = discoveredClasses;
        }
        public Result(TsType tsType, Class<?>... discoveredClasses) {
            this.tsType = tsType;
            this.discoveredClasses = Arrays.asList(discoveredClasses);
        }
        public TsType getTsType() {
            return tsType;
        }
        public List<Class<?>> getDiscoveredClasses() {
            return discoveredClasses;
        }
    }
    public static class Chain implements TypeProcessor {
        private final List<TypeProcessor> processors;
        public Chain(List<TypeProcessor> processors) {
            this.processors = processors;
        }
        public Chain(TypeProcessor... processors) {
            this.processors = Arrays.asList(processors);
        }
        @Override
        public Result processType(Type javaType, Context context) {
            for (TypeProcessor processor : processors) {
                final Result result = processor.processType(javaType, context);
                if (result != null) {
                    return result;
                }
            }
            return null;
        }
    }
}
package cz.habarta.typescript.generator.util;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import cz.habarta.typescript.generator.type.JGenericArrayType;
import cz.habarta.typescript.generator.type.JParameterizedType;
import cz.habarta.typescript.generator.type.JTypeWithNullability;
import cz.habarta.typescript.generator.type.JUnionType;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Proxy;
import java.lang.reflect.Type;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collector;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public final class Utils {
    private Utils() {
    }
    public static String joinPath(String part1, String part2) {
        final String path = Stream.of(part1, part2)
            .filter(part -> part != null && !part.isEmpty())  
            .reduce((a, b) -> trimRightSlash(a) + "/" + trimLeftSlash(b))  
            .orElse("");  
        return trimLeftSlash(path);  
    }
    private static String trimLeftSlash(String path) {
        return path.startsWith("/") ? path.substring(1) : path;
    }
    private static String trimRightSlash(String path) {
        return  path.endsWith("/") ? path.substring(0, path.length() - 1) : path;
    }
    public static Class<?> getRawClassOrNull(Type type) {
        final Pair<Class<?>, Optional<List<Type>>> rawClassAndTypeArguments = getRawClassAndTypeArguments(type);
        return rawClassAndTypeArguments != null ? rawClassAndTypeArguments.getValue1() : null;
    }
    public static Pair<Class<?>, Optional<List<Type>>> getRawClassAndTypeArguments(Type type) {
        if (type instanceof Class) {
            final Class<?> javaClass = (Class<?>) type;
            return javaClass.getTypeParameters().length != 0
                    ? Pair.of(javaClass, Optional.empty())  
                    : Pair.of(javaClass, Optional.of(Collections.emptyList()));  
        }
        if (type instanceof ParameterizedType) {
            final ParameterizedType parameterizedType = (ParameterizedType) type;
            if (parameterizedType.getRawType() instanceof Class) {
                final Class<?> javaClass = (Class<?>) parameterizedType.getRawType();
                return Pair.of(javaClass, Optional.of(Arrays.asList(parameterizedType.getActualTypeArguments())));
            }
        }
        return null;
    }
    public static Comparator<Method> methodComparator() {
        return (Method m1, Method m2) -> {
            final int nameDiff = m1.getName().compareToIgnoreCase(m2.getName());
            if (nameDiff != 0) {
                return nameDiff;
            }
            final int parameterTypesDiff = Arrays.asList(m1.getParameterTypes()).toString().compareTo(Arrays.asList(m2.getParameterTypes()).toString());
            if (parameterTypesDiff != 0) {
                return parameterTypesDiff;
            }
            return 0;
        };
    }
    public static List<Method> getAllMethods(Class<?> cls) {
        return getInheritanceChain(cls)
                .flatMap(c -> Stream.of(c.getDeclaredMethods()))
                .collect(Collectors.toList());
    }
    public static List<Field> getAllFields(Class<?> cls) {
        return getInheritanceChain(cls)
                .flatMap(c -> Stream.of(c.getDeclaredFields()))
                .collect(Collectors.toList());
    }
    public static Stream<Class<?>> getInheritanceChain(Class<?> cls) {
        return Stream.iterate(cls, c -> c != null, (Class<?> c) -> c.getSuperclass())
                .collect(toReversedCollection())
                .stream();
    }
    public static <T> Collector<T, ?, Collection<T>> toReversedCollection() {
        return Collector.<T, ArrayDeque<T>, Collection<T>>of(
                ArrayDeque::new,
                (deque, item) -> deque.addFirst(item),
                (deque1, deque2) -> { deque2.addAll(deque1); return deque2; },
                deque -> deque);
    }
    public static <T, K, U> Collector<T, ?, Map<K,U>> toMap(
            Function<? super T, ? extends K> keyMapper,
            Function<? super T, ? extends U> valueMapper
    ) {
        return Collectors.toMap(
                keyMapper,
                valueMapper,
                (a, b) -> {
                    throw new IllegalStateException("Duplicate key " + a);
                },
                LinkedHashMap::new
        );
    }
    public static boolean hasAnyAnnotation(
            Function<Class<? extends Annotation>, Annotation> getAnnotationFunction,
            List<Class<? extends Annotation>> annotations) {
        return annotations.stream()
                .map(getAnnotationFunction)
                .anyMatch(Objects::nonNull);
    }
    public static <T> T getAnnotationElementValue(AnnotatedElement annotatedElement, String annotationClassName, String annotationElementName, Class<T> annotationElementType) {
        final Annotation annotation = getAnnotation(annotatedElement, annotationClassName);
        return getAnnotationElementValue(annotation, annotationElementName, annotationElementType);
    }
    public static Annotation getAnnotation(AnnotatedElement annotatedElement, String annotationClassName) {
        if (annotatedElement != null) {
            for (Annotation annotation : annotatedElement.getAnnotations()) {
                if (annotation.annotationType().getName().equals(annotationClassName)) {
                    return annotation;
                }
            }
        }
        return null;
    }
    @SuppressWarnings("unchecked")
    public static <T> T getAnnotationElementValue(Annotation annotation, String annotationElementName, Class<T> annotationElementType) {
        try {
            if (annotation != null) {
                for (Method method : annotation.getClass().getMethods()) {
                    if (method.getName().equals(annotationElementName)) {
                        final Object value = method.invoke(annotation);
                        if (annotationElementType.isInstance(value)) {
                            return (T) value;
                        }
                    }
                }
            }
            return null;
        } catch (ReflectiveOperationException e) {
            throw new RuntimeException(e);
        }
    }
    public static List<Annotation> getRepeatableAnnotation(Annotation directAnnotation, Annotation containerAnnotation) {
        final List<Annotation> repeatableAnnotations = new ArrayList<>();
        if (directAnnotation != null) {
            repeatableAnnotations.add(directAnnotation);
        }
        if (containerAnnotation != null) {
            final Annotation[] annotations = Utils.getAnnotationElementValue(containerAnnotation, "value", Annotation[].class);
            Stream.of(annotations).forEach(repeatableAnnotations::add);
        }
        return repeatableAnnotations;
    }
    @SuppressWarnings("unchecked")
    public static <A extends Annotation> A getMigratedAnnotation(AnnotatedElement annotatedElement, Class<A> annotationClass, Class<?> fallbackAnnotationClass) {
        final A annotation = annotatedElement.getAnnotation(annotationClass);
        if (annotation != null) {
            return annotation;
        }
        if (fallbackAnnotationClass != null) {
            final Object fallbackAnnotation = annotatedElement.getAnnotation((Class<Annotation>)fallbackAnnotationClass);
            if (fallbackAnnotation != null) {
                return asMigrationProxy(fallbackAnnotation, annotationClass);
            }
        }
        return null;
    }
    @SuppressWarnings("unchecked")
    public static <T> T asMigrationProxy(Object object, Class<T> clazz) {
        return (T) Proxy.newProxyInstance(
                clazz.getClassLoader(),
                new Class<?>[]{clazz},
                (proxy, method, args) -> {
                    try {
                        final Method fallbackMethod = object.getClass().getMethod(method.getName(), method.getParameterTypes());
                        return fallbackMethod.invoke(object, args);
                    } catch (ReflectiveOperationException e) {
                        return null;
                    }
                }
        );
    }
    public static Type replaceRawClassInType(Type type, Class<?> newClass) {
        if (type instanceof ParameterizedType) {
            final ParameterizedType parameterizedType = (ParameterizedType) type;
            return createParameterizedType(newClass, parameterizedType.getActualTypeArguments());
        }
        return newClass;
    }
    public static ParameterizedType createParameterizedType(final Type rawType, final List<Type> actualTypeArguments) {
        return createParameterizedType(rawType, actualTypeArguments.toArray(new Type[0]));
    }
    public static ParameterizedType createParameterizedType(final Type rawType, final Type... actualTypeArguments) {
        return new JParameterizedType(rawType, actualTypeArguments, null);
    }
    public static Type transformContainedTypes(Type type, Function<Type, Type> transformer) {
        if (type instanceof ParameterizedType) {
            final ParameterizedType parameterizedType = (ParameterizedType) type;
            return new JParameterizedType(
                    parameterizedType.getRawType(),
                    transformTypes(parameterizedType.getActualTypeArguments(), transformer),
                    parameterizedType.getOwnerType()
            );
        }
        if (type instanceof GenericArrayType) {
            final GenericArrayType genericArrayType = (GenericArrayType) type;
            return new JGenericArrayType(
                    transformer.apply(genericArrayType.getGenericComponentType())
            );
        }
        if (type instanceof JUnionType) {
            final JUnionType unionType = (JUnionType) type;
            return new JUnionType(
                    transformTypes(unionType.getTypes(), transformer)
            );
        }
        if (type instanceof JTypeWithNullability) {
            final JTypeWithNullability typeWithNullability = (JTypeWithNullability) type;
            return new JTypeWithNullability(
                    transformer.apply(typeWithNullability.getType()),
                    typeWithNullability.isNullable()
            );
        }
        return type;
    }
    private static List<Type> transformTypes(List<Type> types, Function<Type, Type> transformer) {
        return types.stream()
                .map(transformer)
                .collect(Collectors.toList());
    }
    private static Type[] transformTypes(Type[] types, Function<Type, Type> transformer) {
        return Stream.of(types)
                .map(transformer)
                .toArray(Type[]::new);
    }
    public static boolean isPrimitiveType(Type type) {
        if (type instanceof Class<?>) {
            final Class<?> cls = (Class<?>) type;
            return cls.isPrimitive();
        }
        return false;
    }
    private static final Map<String, Class<?>> primitiveTypes = Stream
            .of(byte.class, short.class, int.class, long.class, float.class, double.class, boolean.class, char.class, void.class)
            .collect(Utils.toMap(cls -> cls.getName(), cls -> cls));
    public static Class<?> getPrimitiveType(String typeName) {
        return primitiveTypes.get(typeName);
    }
    public static Class<?> getArrayClass(Class<?> componentType, int dimensions) {
        return Array.newInstance(componentType, new int[dimensions]).getClass();
    }
    public static <T> List<T> concat(List<? extends T> list1, List<? extends T> list2) {
        if (list1 == null && list2 == null) {
            return null;
        }
        final List<T> result = new ArrayList<>();
        if (list1 != null) result.addAll(list1);
        if (list2 != null) result.addAll(list2);
        return result;
    }
    public static <T> List<T> listFromNullable(T item) {
        return item != null ? Arrays.asList(item) : Collections.<T>emptyList();
    }
    public static <T> List<T> listFromNullable(List<T> list) {
        return list != null ? list : Collections.<T>emptyList();
    }
    public static <K, V> Map<K, V> mapFromNullable(Map<K, V> map) {
        return map != null ? map : Collections.<K, V>emptyMap();
    }
    public static <T> List<T> removeNulls(List<T> list) {
        final ArrayList<T> result = new ArrayList<>(list);
        result.removeAll(Collections.singleton(null));
        return result;
    }
    public static <T> List<T> removeAll(List<T> list, List<T> toBeRemoved) {
        final ArrayList<T> result = new ArrayList<>(list);
        result.removeAll(toBeRemoved);
        return result;
    }
    public static <T> Collector<T, ?, List<T>> toSortedList(Comparator<? super T> comparator) {
        return Collectors.collectingAndThen(
                Collectors.toCollection(ArrayList::new),
                list -> {
                    list.sort(comparator);
                    return list;
                }
        );
    }
    public static <T1, T2> List<Pair<T1, T2>> zip(List<T1> list1, List<T2> list2) {
        final List<Pair<T1, T2>> result = new ArrayList<>();
        final int size = Math.min(list1.size(), list2.size());
        for (int i = 0; i < size; i++) {
            result.add(Pair.of(list1.get(i), list2.get(i)));
        }
        return result;
    }
    public static List<String> readLines(InputStream stream) {
        return splitMultiline(readString(stream), false);
    }
    public static String readString(InputStream stream) {
        try (Scanner scanner = new Scanner(stream, "UTF-8")) {
            scanner.useDelimiter("\\A");
            return scanner.hasNext() ? scanner.next() : "";
        }
    }
    public static String readString(InputStream stream, String lineEndings) {
        return normalizeLineEndings(readString(stream), lineEndings);
    }
    public static String normalizeLineEndings(String text, String lineEndings) {
        return text.replaceAll("\\r\\n|\\n|\\r", lineEndings);
    }
    public static List<String> splitMultiline(String text, boolean trimOneLeadingSpaceOnLines) {
        if (text == null) {
            return null;
        }
        final List<String> result = new ArrayList<>();
        final String[] lines = text.split("\\r\\n|\\n|\\r");
        for (String line : lines) {
            result.add(trimOneLeadingSpaceOnLines ? trimOneLeadingSpaceOnly(line) : line);
        }
        return result;
    }
    private static String trimOneLeadingSpaceOnly(String line) {
        if (line.startsWith(" ")) {
            return line.substring(1);
        }
        return line;
    }
    public static File replaceExtension(File file, String newExtension) {
        final String name = file.getName();
        final int dotIndex = name.lastIndexOf(".");
        final int index = dotIndex != -1 ? dotIndex : name.length();
        return new File(file.getParent(), name.substring(0, index) + newExtension);
    }
    public static boolean classNameMatches(String className, List<Pattern> regexps) {
        for (Pattern regexp : regexps) {
            if (regexp.matcher(className).matches()) {
                return true;
            }
        }
        return false;
    }
    public static List<Pattern> globsToRegexps(List<String> globs) {
        if (globs == null) {
            return null;
        }
        final List<Pattern> regexps = new ArrayList<>();
        for (String glob : globs) {
            regexps.add(globToRegexp(glob));
        }
        return regexps;
    }
    private static Pattern globToRegexp(String glob) {
        final Pattern globToRegexpPattern = Pattern.compile("(\\*\\*)|(\\*)");
        final Matcher matcher = globToRegexpPattern.matcher(glob);
        final StringBuffer sb = new StringBuffer();
        int lastEnd = 0;
        while (matcher.find()) {
            sb.append(Pattern.quote(glob.substring(lastEnd, matcher.start())));
            if (matcher.group(1) != null) {
                sb.append(Matcher.quoteReplacement(".*"));
            }
            if (matcher.group(2) != null) {
                sb.append(Matcher.quoteReplacement("[^.$]*"));
            }
            lastEnd = matcher.end();
        }
        sb.append(Pattern.quote(glob.substring(lastEnd, glob.length())));
        return Pattern.compile(sb.toString());
    }
    public static ObjectMapper getObjectMapper() {
        final ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
        objectMapper.setDefaultPrettyPrinter(new StandardJsonPrettyPrinter("  ", "\n"));
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        return objectMapper;
    }
    public static <T> T loadJson(ObjectMapper objectMapper, InputStream inputStream, Class<T> type) {
        try {
            return objectMapper.readValue(inputStream, type);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    public static String objectToString(Object object) {
        try {
            return new ObjectMapper().writeValueAsString(object);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }
    public static String exceptionToString(Throwable e) {
        final StringWriter writer = new StringWriter();
        e.printStackTrace(new PrintWriter(writer));
        return writer.toString();
    }
    public static <T> Supplier<T> memoize(Supplier<T> supplier) {
        final AtomicReference<T> value = new AtomicReference<>();
        return () -> value.updateAndGet(current -> current != null ? current : Objects.requireNonNull(supplier.get()));
    }
}
package cz.habarta.typescript.generator;
import cz.habarta.typescript.generator.parser.SourceType;
import cz.habarta.typescript.generator.util.Utils;
import io.github.classgraph.ScanResult;
import java.lang.reflect.Constructor;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
public class JaxrsApplicationScanner {
    public static List<SourceType<Type>> scanJaxrsApplication(Class<?> jaxrsApplicationClass, Predicate<String> isClassNameExcluded) {
        final ClassLoader originalContextClassLoader = Thread.currentThread().getContextClassLoader();
        try {
            Thread.currentThread().setContextClassLoader(jaxrsApplicationClass.getClassLoader());
            TypeScriptGenerator.getLogger().info("Scanning JAX-RS application: " + jaxrsApplicationClass.getName());
            final Constructor<?> constructor = jaxrsApplicationClass.getDeclaredConstructor();
            constructor.setAccessible(true);
            final Object instance = constructor.newInstance();
            final Set<Class<?>> applicationClasses;
            if (instance instanceof jakarta.ws.rs.core.Application) {
                applicationClasses = ((jakarta.ws.rs.core.Application) instance).getClasses();
            } else if (instance instanceof javax.ws.rs.core.Application) {
                applicationClasses = ((javax.ws.rs.core.Application) instance).getClasses();
            } else {
                applicationClasses = Collections.emptySet();
            }
            final List<Class<?>> resourceClasses = new ArrayList<>();
            for (Class<?> cls : applicationClasses) {
                if (cls.isAnnotationPresent(jakarta.ws.rs.Path.class) || cls.isAnnotationPresent(javax.ws.rs.Path.class)) {
                    resourceClasses.add(cls);
                }
            }
            return new JaxrsApplicationScanner().scanJaxrsApplication(jaxrsApplicationClass, resourceClasses, isClassNameExcluded);
        } catch (ReflectiveOperationException e) {
            throw reportError(e);
        } finally {
            Thread.currentThread().setContextClassLoader(originalContextClassLoader);
        }
    }
    public static List<SourceType<Type>> scanAutomaticJaxrsApplication(ScanResult scanResult, Predicate<String> isClassNameExcluded) {
        final List<String> namesOfResourceClasses = Utils.concat(
                scanResult.getClassesWithAnnotation(jakarta.ws.rs.Path.class.getName()).getNames(),
                scanResult.getClassesWithAnnotation(javax.ws.rs.Path.class.getName()).getNames()
        );
        final List<Class<?>> resourceClasses = Input.loadClasses(namesOfResourceClasses);
        TypeScriptGenerator.getLogger().info(String.format("Found %d root resources.", resourceClasses.size()));
        return new JaxrsApplicationScanner().scanJaxrsApplication(null, resourceClasses, isClassNameExcluded);
    }
    private static RuntimeException reportError(ReflectiveOperationException e) {
        final String url = "https:
        final String message = "Cannot load JAX-RS application. For more information see " + url + ".";
        TypeScriptGenerator.getLogger().error(message);
        return new RuntimeException(message, e);
    }
    List<SourceType<Type>> scanJaxrsApplication(Class<?> applicationClass, List<Class<?>> resourceClasses, Predicate<String> isClassNameExcluded) {
        Collections.sort(resourceClasses, (o1, o2) -> o1.getName().compareToIgnoreCase(o2.getName()));
        final List<SourceType<Type>> sourceTypes = new ArrayList<>();
        if (applicationClass != null) {
            sourceTypes.add(new SourceType<>(applicationClass));
        }
        for (Class<?> resourceClass : resourceClasses) {
            if (isClassNameExcluded == null || !isClassNameExcluded.test(resourceClass.getName())) {
                sourceTypes.add(new SourceType<>(resourceClass));
            }
        }
        return sourceTypes;
    }
}
package cz.habarta.typescript.generator;
import com.fasterxml.jackson.annotation.JsonInclude;
import cz.habarta.typescript.generator.util.Utils;
import java.io.File;
@JsonInclude(JsonInclude.Include.NON_DEFAULT) 
public class ModuleDependency {
    public boolean global;
    public String importFrom;
    public String importAs;
    public File infoJson;
    public String npmPackageName;
    public String npmVersionRange;
    public boolean peerDependency;
    public ModuleDependency() {
    }
    private ModuleDependency(boolean global, String importFrom, String importAs, File infoJson, String npmPackageName, String npmVersionRange, boolean peerDependency) {
        this.global = global;
        this.importFrom = importFrom;
        this.importAs = importAs;
        this.infoJson = infoJson;
        this.npmPackageName = npmPackageName;
        this.npmVersionRange = npmVersionRange;
        this.peerDependency = peerDependency;
    }
    public static ModuleDependency module(String importFrom, String importAs, File infoJson, String npmPackageName, String npmVersionRange) {
        return new ModuleDependency(false, importFrom, importAs, infoJson, npmPackageName, npmVersionRange, false);
    }
    public static ModuleDependency global(File infoJson) {
        return new ModuleDependency(true, null, null, infoJson, null, null, false);
    }
    @Override
    public String toString() {
        return Utils.objectToString(this);
    }
    public String toShortString() {
        return global ? "global" : "'" + importFrom + "'";
    }
}
package cz.habarta.typescript.generator.compiler;
import com.oracle.truffle.js.scriptengine.GraalJSScriptEngine;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.util.Pair;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Pattern;
import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptException;
import org.graalvm.polyglot.Context;
import org.graalvm.polyglot.Engine;
import org.graalvm.polyglot.HostAccess;
public class SymbolTable {
    private final Settings settings;
    private final LinkedHashMap<Pair<Class<?>, String>, Symbol> symbols = new LinkedHashMap<>();
    private final LinkedHashMap<String, Symbol> syntheticSymbols = new LinkedHashMap<>();
    private CustomTypeNamingFunction customTypeNamingFunction;
    public SymbolTable(Settings settings) {
        this.settings = settings;
    }
    public Symbol getSymbol(Class<?> cls) {
        return getSymbol(cls, null);
    }
    public Symbol getSymbol(Class<?> cls, String suffix) {
        final String suffixString = suffix != null ? suffix : "";
        final Pair<Class<?>, String> key = Pair.<Class<?>, String>of(cls, suffixString);
        if (!symbols.containsKey(key)) {
            symbols.put(key, new Symbol("$" + cls.getName().replace('.', '$') + suffixString + "$"));
        }
        return symbols.get(key);
    }
    public Symbol hasSymbol(Class<?> cls, String suffix) {
        return symbols.get(Pair.<Class<?>, String>of(cls, suffix));
    }
    public Class<?> getSymbolClass(Symbol symbol) {
        for (Map.Entry<Pair<Class<?>, String>, Symbol> entry : symbols.entrySet()) {
            if (entry.getValue() == symbol) {
                return entry.getKey().getValue1();
            }
        }
        return null;
    }
    public Symbol getSyntheticSymbol(String name) {
        if (!syntheticSymbols.containsKey(name)) {
            syntheticSymbols.put(name, new Symbol(name));
        }
        return syntheticSymbols.get(name);
    }
    public Symbol getSyntheticSymbol(String name, String suffix) {
        return getSyntheticSymbol(name + (suffix != null ? suffix : ""));
    }
    public Symbol addSuffixToSymbol(Symbol symbol, String suffix) {
        for (Map.Entry<Pair<Class<?>, String>, Symbol> entry : symbols.entrySet()) {
            if (entry.getValue() == symbol) {
                return getSymbol(entry.getKey().getValue1(), entry.getKey().getValue2() + suffix);
            }
        }
        return getSyntheticSymbol(symbol.getFullName() + suffix);
    }
    public void resolveSymbolNames() {
        final Map<String, List<Class<?>>> names = new LinkedHashMap<>();
        for (Map.Entry<Pair<Class<?>, String>, Symbol> entry : symbols.entrySet()) {
            final Class<?> cls = entry.getKey().getValue1();
            final String suffix = entry.getKey().getValue2();
            final Symbol symbol = entry.getValue();
            if (!symbol.isResolved()) {
                setSymbolQualifiedName(symbol, cls, suffix);
            }
            final String fullName = symbol.getFullName();
            if (!names.containsKey(fullName)) {
                names.put(fullName, new ArrayList<>());
            }
            names.get(fullName).add(cls);
        }
        reportConflicts(names);
    }
    private static void reportConflicts(Map<String, List<Class<?>>> names) {
        boolean conflict = false;
        for (Map.Entry<String, List<Class<?>>> entry : names.entrySet()) {
            final String name = entry.getKey();
            final List<Class<?>> classes = entry.getValue();
            if (classes.size() > 1) {
                TypeScriptGenerator.getLogger().warning(String.format("Multiple classes are mapped to '%s' name. Conflicting classes: %s", name, classes));
                conflict = true;
            }
        }
        if (conflict) {
            throw new NameConflictException("Multiple classes are mapped to the same name. You can use 'customTypeNaming' or 'customTypeNamingFunction' settings to resolve conflicts or exclude conflicting class if it was added accidentally.");
        }
    }
    private void setSymbolQualifiedName(Symbol symbol, Class<?> cls, String suffix) {
        final String module;
        final String namespacedName;
        final Pair<String, String> fullNameFromDependency = settings.getModuleDependencies().getFullName(cls);
        if (fullNameFromDependency != null) {
            module = fullNameFromDependency.getValue1();
            namespacedName = fullNameFromDependency.getValue2();
        } else {
            module = null;
            namespacedName = getMappedNamespacedName(cls);
        }
        final String suffixString = suffix != null ? suffix : "";
        symbol.setFullName(module, namespacedName + suffixString);
    }
    public String getMappedNamespacedName(Class<?> cls) {
        if (cls == null) {
            return null;
        }
        final String customName = settings.customTypeNaming.get(cls.getName());
        if (customName != null) {
            return customName;
        }
        if (settings.customTypeNamingFunctionImpl != null || settings.customTypeNamingFunction != null) {
            try {
                final CustomTypeNamingFunction function;
                if (settings.customTypeNamingFunctionImpl != null) {
                    function = settings.customTypeNamingFunctionImpl;
                } else {
                    function = getCustomTypeNamingFunction();
                }
                final Object getNameResult = function.getName(cls.getName(), cls.getSimpleName());
                if (getNameResult instanceof String) {
                    return (String) getNameResult;
                }
            } catch (ScriptException e) {
                throw new RuntimeException("Evaluating 'customTypeNamingFunction' failed.", e);
            }
        }
        String simpleName = cls.getSimpleName();
        if (settings.removeTypeNamePrefix != null && simpleName.startsWith(settings.removeTypeNamePrefix)) {
            simpleName = simpleName.substring(settings.removeTypeNamePrefix.length(), simpleName.length());
        }
        if (settings.removeTypeNameSuffix != null && simpleName.endsWith(settings.removeTypeNameSuffix)) {
            simpleName = simpleName.substring(0, simpleName.length() - settings.removeTypeNameSuffix.length());
        }
        if (settings.addTypeNamePrefix != null) {
            simpleName = settings.addTypeNamePrefix + simpleName;
        }
        if (settings.addTypeNameSuffix != null) {
            simpleName = simpleName + settings.addTypeNameSuffix;
        }
        if (settings.mapPackagesToNamespaces) {
            final String classNameDotted = cls.getName().replace('$', '.');
            final String[] parts = classNameDotted.split(Pattern.quote("."));
            final List<String> safeParts = new ArrayList<>();
            for (String part : Arrays.asList(parts).subList(0, parts.length - 1)) {
                safeParts.add(isReservedWord(part) ? "_" + part : part);
            }
            safeParts.add(simpleName);
            return String.join(".", safeParts);
        } else {
            return simpleName;
        }
    }
    private static final Set<String> Keywords = new LinkedHashSet<>(Arrays.asList(
        "break",             "case",              "catch",             "class",
        "const",             "continue",          "debugger",          "default",
        "delete",            "do",                "else",              "enum",
        "export",            "extends",           "false",             "finally",
        "for",               "function",          "if",                "import",
        "in",                "instanceof",        "new",               "null",
        "return",            "super",             "switch",            "this",
        "throw",             "true",              "try",               "typeof",
        "var",               "void",              "while",             "with",
        "implements",        "interface",         "let",               "package",
        "private",           "protected",         "public",            "static",
        "yield"
    ));
    public static boolean isReservedWord(String word) {
        return Keywords.contains(word);
    }
    private CustomTypeNamingFunction getCustomTypeNamingFunction() throws ScriptException {
        if (customTypeNamingFunction == null) {
            final ScriptEngine engine = GraalJSScriptEngine.create(
                    Engine.newBuilder().option("engine.WarnInterpreterOnly", "false").build(),
                    Context.newBuilder("js").allowHostAccess(HostAccess.ALL)
            );
            engine.eval("var getName = " + settings.customTypeNamingFunction);
            final Invocable invocable = (Invocable) engine;
            customTypeNamingFunction = invocable.getInterface(CustomTypeNamingFunction.class);
        }
        return customTypeNamingFunction;
    }
    public static interface CustomTypeNamingFunction {
        public Object getName(String className, String classSimpleName);
    }
    public Symbol getSymbolIfImported(Class<?> cls) {
        final Pair<String, String> fullNameFromDependency = settings.getModuleDependencies().getFullName(cls);
        if (fullNameFromDependency != null) {
            final Symbol symbol = new Symbol(null);
            symbol.setFullName(fullNameFromDependency.getValue1(), fullNameFromDependency.getValue2());
            return symbol;
        } else {
            return null;
        }
    }
    public static class NameConflictException extends RuntimeException {
        private static final long serialVersionUID = 1L;
        public NameConflictException() {
        }
        public NameConflictException(String message) {
            super(message);
        }
        public NameConflictException(String message, Throwable cause) {
            super(message, cause);
        }
        public NameConflictException(Throwable cause) {
            super(cause);
        }
    }
}
package cz.habarta.typescript.generator.parser;
import cz.habarta.typescript.generator.OptionalProperties;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TsType;
import cz.habarta.typescript.generator.TypeProcessor;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.compiler.EnumKind;
import cz.habarta.typescript.generator.compiler.EnumMemberModel;
import cz.habarta.typescript.generator.util.AnnotationGetter;
import cz.habarta.typescript.generator.util.GenericsResolver;
import cz.habarta.typescript.generator.util.PropertyMember;
import cz.habarta.typescript.generator.util.Utils;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public abstract class ModelParser {
    protected final Settings settings;
    private final Javadoc javadoc;
    private final DeprecationEnricher deprecationEnricher;
    private final Queue<SourceType<? extends Type>> typeQueue;
    private final TypeProcessor commonTypeProcessor;
    private final List<RestApplicationParser> restApplicationParsers;
    public static abstract class Factory {
        public TypeProcessor getSpecificTypeProcessor() {
            return null;
        }
        public abstract ModelParser create(Settings settings, TypeProcessor commonTypeProcessor, List<RestApplicationParser> restApplicationParsers);
    }
    public ModelParser(Settings settings, TypeProcessor commonTypeProcessor, List<RestApplicationParser> restApplicationParsers) {
        this.settings = settings;
        this.javadoc = new Javadoc(settings);
        this.deprecationEnricher = new DeprecationEnricher();
        this.typeQueue = new LinkedList<>();
        this.restApplicationParsers = restApplicationParsers;
        this.commonTypeProcessor = commonTypeProcessor;
    }
    public Model parseModel(Type type) {
        return parseModel(Arrays.asList(new SourceType<>(type)));
    }
    public Model parseModel(List<SourceType<Type>> types) {
        typeQueue.addAll(types);
        Model model = parseQueue();
        if (!settings.ignoreSwaggerAnnotations) {
            model = Swagger.enrichModel(model);
        }
        model = javadoc.enrichModel(model);
        model = deprecationEnricher.enrichModel(model);
        return model;
    }
    private Model parseQueue() {
        final Collection<Type> parsedTypes = new ArrayList<>();  
        final List<BeanModel> beans = new ArrayList<>();
        final List<EnumModel> enums = new ArrayList<>();
        SourceType<? extends Type> sourceType;
        while ((sourceType = typeQueue.poll()) != null) {
            if (parsedTypes.contains(sourceType.type)) {
                continue;
            }
            parsedTypes.add(sourceType.type);
            boolean parsedByRestApplicationParser = false;
            for (RestApplicationParser restApplicationParser : restApplicationParsers) {
                final JaxrsApplicationParser.Result jaxrsResult = restApplicationParser.tryParse(sourceType);
                if (jaxrsResult != null) {
                    typeQueue.addAll(jaxrsResult.discoveredTypes);
                    parsedByRestApplicationParser = true;
                }
            }
            if (parsedByRestApplicationParser) {
                continue;
            }
            final TypeProcessor.Result result = commonTypeProcessor.processTypeInTemporaryContext(sourceType.type, null, settings);
            if (result != null) {
                if (sourceType.type instanceof Class<?> && result.getTsType() instanceof TsType.ReferenceType) {
                    final Class<?> cls = (Class<?>) sourceType.type;
                    final TsType.ReferenceType referenceType = (TsType.ReferenceType) result.getTsType();
                    if (!referenceType.symbol.isResolved()) {
                        TypeScriptGenerator.getLogger().verbose("Parsing '" + cls.getName() + "'" +
                                (sourceType.usedInClass != null ? " used in '" + sourceType.usedInClass.getSimpleName() + "." + sourceType.usedInMember + "'" : ""));
                        final DeclarationModel model = parseClass(sourceType.asSourceClass());
                        if (model instanceof EnumModel) {
                            enums.add((EnumModel) model);
                        } else if (model instanceof BeanModel) {
                            beans.add((BeanModel) model);
                        } else {
                            throw new RuntimeException();
                        }
                    }
                }
                for (Class<?> cls : result.getDiscoveredClasses()) {
                    typeQueue.add(new SourceType<>(cls, sourceType.usedInClass, sourceType.usedInMember));
                }
            }
        }
        final List<RestApplicationModel> restModels = restApplicationParsers.stream()
                .map(RestApplicationParser::getModel)
                .collect(Collectors.toList());
        return new Model(beans, enums, restModels);
    }
    protected abstract DeclarationModel parseClass(SourceType<Class<?>> sourceClass);
    protected static PropertyMember wrapMember(TypeParser typeParser, Member propertyMember, Integer creatorIndex, AnnotationGetter annotationGetter,
            String propertyName, Class<?> sourceClass) {
        if (propertyMember instanceof Field) {
            final Field field = (Field) propertyMember;
            return new PropertyMember(field, typeParser.getFieldType(field), field.getAnnotatedType(), annotationGetter);
        }
        if (propertyMember instanceof Method) {
            final Method method = (Method) propertyMember;
            if (creatorIndex != null) {
                return new PropertyMember(method, typeParser.getMethodParameterTypes(method).get(creatorIndex), method.getAnnotatedParameterTypes()[creatorIndex], annotationGetter);
            } else {
                switch (method.getParameterCount()) {
                    case 0:
                        return new PropertyMember(method, typeParser.getMethodReturnType(method), method.getAnnotatedReturnType(), annotationGetter);
                    case 1:
                        return new PropertyMember(method, typeParser.getMethodParameterTypes(method).get(0), method.getAnnotatedParameterTypes()[0], annotationGetter);
                }
            }
        }
        if (propertyMember instanceof Constructor) {
            final Constructor<?> constructor = (Constructor<?>) propertyMember;
            if (creatorIndex != null) {
                return new PropertyMember(constructor, typeParser.getConstructorParameterTypes(constructor).get(creatorIndex), constructor.getAnnotatedParameterTypes()[creatorIndex], annotationGetter);
            }
        }
        TypeScriptGenerator.getLogger().verbose(String.format(
                "Unexpected member '%s' in property '%s' in class '%s'",
                propertyMember != null ? propertyMember.getClass().getName() : null,
                propertyName,
                sourceClass.getName()));
        return null;
    }
    protected boolean isAnnotatedPropertyIncluded(Function<Class<? extends Annotation>, Annotation> getAnnotationFunction, String propertyDescription) {
        boolean isIncluded = settings.includePropertyAnnotations.isEmpty()
                || Utils.hasAnyAnnotation(getAnnotationFunction, settings.includePropertyAnnotations);
        if (!isIncluded) {
            TypeScriptGenerator.getLogger().verbose("Skipping '" + propertyDescription + "' because it doesn't have any annotation from 'includePropertyAnnotations'");
            return false;
        }
        boolean isExcluded = Utils.hasAnyAnnotation(getAnnotationFunction, settings.excludePropertyAnnotations);
        if (isExcluded) {
            TypeScriptGenerator.getLogger().verbose("Skipping '" + propertyDescription + "' because it has some annotation from 'excludePropertyAnnotations'");
            return false;
        }
        return true;
    }
    protected boolean isPropertyOptional(PropertyMember propertyMember) {
        if (settings.optionalProperties == OptionalProperties.all) {
            return true;
        }
        if (settings.optionalProperties == null || settings.optionalProperties == OptionalProperties.useSpecifiedAnnotations) {
            if (!settings.optionalAnnotations.isEmpty()) {
                return Utils.hasAnyAnnotation(propertyMember::getAnnotation, settings.optionalAnnotations);
            }
            if (settings.primitivePropertiesRequired && Utils.isPrimitiveType(propertyMember.getType())) {
                return false;
            }
            if (!settings.requiredAnnotations.isEmpty()) {
                return !Utils.hasAnyAnnotation(propertyMember::getAnnotation, settings.requiredAnnotations);
            }
        }
        return false;
    }
    protected static DeclarationModel parseEnum(SourceType<Class<?>> sourceClass) {
        final List<EnumMemberModel> values = new ArrayList<>();
        if (sourceClass.type.isEnum()) {
            @SuppressWarnings("unchecked")
            final Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) sourceClass.type;
            final Map<String, Field> fields = Stream.of(enumClass.getDeclaredFields()).collect(Utils.toMap(field -> field.getName(), field -> field));
            for (Enum<?> enumConstant : enumClass.getEnumConstants()) {
                values.add(new EnumMemberModel(enumConstant.name(), enumConstant.name(), fields.get(enumConstant.name()), null));
            }
        }
        return new EnumModel(sourceClass.type, EnumKind.StringBased, values, null);
    }
    protected void addBeanToQueue(SourceType<? extends Type> sourceType) {
        typeQueue.add(sourceType);
    }
    protected PropertyModel processTypeAndCreateProperty(String name, Type type, Object typeContext, boolean optional, PropertyAccess access, Class<?> usedInClass, Member originalMember, PropertyModel.PullProperties pullProperties, List<String> comments) {
        final Type resolvedType = GenericsResolver.resolveType(usedInClass, type, originalMember.getDeclaringClass());
        final List<Class<?>> classes = commonTypeProcessor.discoverClassesUsedInType(resolvedType, typeContext, settings);
        for (Class<?> cls : classes) {
            typeQueue.add(new SourceType<>(cls, usedInClass, name));
        }
        return new PropertyModel(name, resolvedType, optional, access, originalMember, pullProperties, typeContext, comments);
    }
    public static boolean containsProperty(List<PropertyModel> properties, String propertyName) {
        for (PropertyModel property : properties) {
            if (property.getName().equals(propertyName)) {
                return true;
            }
        }
        return false;
    }
}
package cz.habarta.typescript.generator;
import cz.habarta.typescript.generator.util.GenericsResolver;
import cz.habarta.typescript.generator.util.Utils;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
public class CustomMappingTypeProcessor implements TypeProcessor {
    private final List<Settings.CustomTypeMapping> customMappings;
    public CustomMappingTypeProcessor(List<Settings.CustomTypeMapping> customMappings) {
        this.customMappings = customMappings;
    }
    @Override
    public Result processType(Type javaType, Context context) {
        final Class<?> rawClass = Utils.getRawClassOrNull(javaType);
        if (rawClass == null) {
            return null;
        }
        final Settings.CustomTypeMapping mapping = customMappings.stream()
                .filter(m -> m.matchSubclasses
                        ? m.rawClass.isAssignableFrom(rawClass)
                        : m.rawClass.equals(rawClass)
                )
                .findFirst()
                .orElse(null);
        if (mapping == null) {
            return null;
        }
        final List<Type> resolvedTypeParameters = GenericsResolver.resolveBaseGenericVariables(mapping.rawClass, javaType);
        final List<Class<?>> discoveredClasses = new ArrayList<>();
        final Function<Integer, TsType> processGenericParameter = index -> {
            final Type typeArgument = resolvedTypeParameters.get(index);
            final TypeProcessor.Result typeArgumentResult = context.processType(typeArgument);
            discoveredClasses.addAll(typeArgumentResult.getDiscoveredClasses());
            return typeArgumentResult.getTsType();
        };
        if (mapping.tsType.typeParameters != null) {
            final List<TsType> tsTypeArguments = new ArrayList<>();
            for (String typeParameter : mapping.tsType.typeParameters) {
                final TsType tsType;
                final int index = mapping.javaType.indexOfTypeParameter(typeParameter);
                if (index != -1) {
                    tsType = processGenericParameter.apply(index);
                } else {
                    tsType = new TsType.VerbatimType(typeParameter);
                }
                tsTypeArguments.add(tsType);
            }
            return new Result(new TsType.GenericBasicType(mapping.tsType.rawName, tsTypeArguments), discoveredClasses);
        } else {
            final int index = mapping.javaType.indexOfTypeParameter(mapping.tsType.rawName);
            if (index != -1) {
                final TsType tsType = processGenericParameter.apply(index);
                return new Result(tsType, discoveredClasses);
            } else {
                return new Result(new TsType.VerbatimType(mapping.tsType.rawName), discoveredClasses);
            }
        }
    }
}
package cz.habarta.typescript.generator;
import cz.habarta.typescript.generator.util.Utils;
import java.lang.reflect.Type;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
public class ExcludingTypeProcessor implements TypeProcessor {
    private final Predicate<String> excludeFilter;
    public ExcludingTypeProcessor(List<String> excludedTypes) {
        this(new Predicate<String>() {
            final Set<String> excludedTypesSet = excludedTypes != null ? new LinkedHashSet<>(excludedTypes) : Collections.emptySet();
            @Override
            public boolean test(String typeName) {
                return excludedTypesSet.contains(typeName);
            }
        });
    }
    public ExcludingTypeProcessor(Predicate<String> excludeFilter) {
        this.excludeFilter = excludeFilter;
    }
    @Override
    public Result processType(Type javaType, Context context) {
        final Class<?> rawClass = Utils.getRawClassOrNull(javaType);
        if (rawClass != null && excludeFilter.test(rawClass.getName())) {
            return new Result(TsType.Any);
        }
        return null;
    }
}
package cz.habarta.typescript.generator;
import cz.habarta.typescript.generator.compiler.Symbol;
import cz.habarta.typescript.generator.type.JTypeWithNullability;
import cz.habarta.typescript.generator.type.JUnionType;
import cz.habarta.typescript.generator.util.GenericsResolver;
import cz.habarta.typescript.generator.util.Utils;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.time.temporal.Temporal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.UUID;
import java.util.stream.Collectors;
public class DefaultTypeProcessor implements TypeProcessor {
    private final LoadedDataLibraries known;
    public DefaultTypeProcessor() {
        this(null);
    }
    public DefaultTypeProcessor(LoadedDataLibraries dataLibraries) {
        this.known = LoadedDataLibraries.join(getKnownClasses(), dataLibraries);
    }
    private static boolean isAssignableFrom(List<Class<?>> classes, Class<?> cls) {
        return assignableFrom(classes, cls).isPresent();
    }
    private static Optional<Class<?>> assignableFrom(List<Class<?>> classes, Class<?> cls) {
        return classes.stream().filter(c -> c.isAssignableFrom(cls)).findFirst();
    }
    @Override
    public Result processType(Type javaType, Context context) {
        if (Objects.equals(javaType, Object.class)) {
            return new Result(TsType.Any);
        }
        if (javaType instanceof Class) {
            final Class<?> javaClass = (Class<?>) javaType;
            if (isAssignableFrom(known.stringClasses, javaClass)) {
                return new Result(TsType.String);
            }
            if (isAssignableFrom(known.numberClasses, javaClass)) {
                return new Result(TsType.Number);
            }
            if (isAssignableFrom(known.booleanClasses, javaClass)) {
                return new Result(TsType.Boolean);
            }
            if (isAssignableFrom(known.dateClasses, javaClass)) {
                return new Result(TsType.Date);
            }
            if (isAssignableFrom(known.voidClasses, javaClass)) {
                return new Result(TsType.Void);
            }
        }
        if (javaType instanceof Class) {
            final Class<?> javaClass = (Class<?>) javaType;
            final Symbol importedSymbol = context.getSymbolIfImported(javaClass);
            if (importedSymbol != null) {
                return new Result(new TsType.ReferenceType(importedSymbol));
            }
        }
        if (javaType instanceof Class) {
            final Class<?> javaClass = (Class<?>) javaType;
            if (isAssignableFrom(known.anyClasses, javaClass)) {
                return new Result(TsType.Any);
            }
            if (javaClass.isArray()) {
                final Result result = context.processTypeInsideCollection(javaClass.getComponentType());
                return new Result(new TsType.BasicArrayType(result.getTsType()), result.getDiscoveredClasses());
            }
            if (javaClass.isEnum()) {
                return new Result(new TsType.EnumReferenceType(context.getSymbol(javaClass)), javaClass);
            }
            final Result knownGenericTypeResult = processKnownGenericType(javaClass, javaClass, context);
            if (knownGenericTypeResult != null) {
                return knownGenericTypeResult;
            }
            if (OptionalInt.class.isAssignableFrom(javaClass) ||
                    OptionalLong.class.isAssignableFrom(javaClass) ||
                    OptionalDouble.class.isAssignableFrom(javaClass)) {
                return new Result(TsType.Number.optional());
            }
            if (javaClass.getTypeParameters().length > 0) {
                final List<TsType> tsTypeArguments = new ArrayList<>();
                for (int i = 0; i < javaClass.getTypeParameters().length; i++) {
                    tsTypeArguments.add(TsType.Any);
                }
                return new Result(new TsType.GenericReferenceType(context.getSymbol(javaClass), tsTypeArguments));
            }
            return new Result(new TsType.ReferenceType(context.getSymbol(javaClass)), javaClass);
        }
        if (javaType instanceof ParameterizedType) {
            final ParameterizedType parameterizedType = (ParameterizedType) javaType;
            if (parameterizedType.getRawType() instanceof Class) {
                final Class<?> javaClass = (Class<?>) parameterizedType.getRawType();
                final Result knownGenericTypeResult = processKnownGenericType(javaType, javaClass, context);
                if (knownGenericTypeResult != null) {
                    return knownGenericTypeResult;
                }
                final List<Class<?>> discoveredClasses = new ArrayList<>();
                discoveredClasses.add(javaClass);
                final List<TsType> tsTypeArguments = new ArrayList<>();
                for (Type typeArgument : parameterizedType.getActualTypeArguments()) {
                    final TypeProcessor.Result typeArgumentResult = context.processType(typeArgument);
                    tsTypeArguments.add(typeArgumentResult.getTsType());
                    discoveredClasses.addAll(typeArgumentResult.getDiscoveredClasses());
                }
                return new Result(new TsType.GenericReferenceType(context.getSymbol(javaClass), tsTypeArguments), discoveredClasses);
            }
        }
        if (javaType instanceof GenericArrayType) {
            final GenericArrayType genericArrayType = (GenericArrayType) javaType;
            final Result result = context.processTypeInsideCollection(genericArrayType.getGenericComponentType());
            return new Result(new TsType.BasicArrayType(result.getTsType()), result.getDiscoveredClasses());
        }
        if (javaType instanceof TypeVariable) {
            final TypeVariable<?> typeVariable = (TypeVariable<?>) javaType;
            if (typeVariable.getGenericDeclaration() instanceof Method) {
                return context.processType(typeVariable.getBounds()[0]);
            }
            return new Result(new TsType.GenericVariableType(typeVariable.getName()));
        }
        if (javaType instanceof WildcardType) {
            final WildcardType wildcardType = (WildcardType) javaType;
            final Type[] upperBounds = wildcardType.getUpperBounds();
            return upperBounds.length > 0
                    ? context.processType(upperBounds[0])
                    : new Result(TsType.Any);
        }
        if (javaType instanceof JUnionType) {
            final JUnionType unionType = (JUnionType) javaType;
            final List<Result> results = unionType.getTypes().stream()
                    .map(type -> context.processType(type))
                    .collect(Collectors.toList());
            return new Result(
                    new TsType.UnionType(results.stream()
                            .map(result -> result.getTsType())
                            .collect(Collectors.toList())),
                    results.stream()
                            .flatMap(result -> result.getDiscoveredClasses().stream())
                            .collect(Collectors.toList())
            );
        }
        if (javaType instanceof JTypeWithNullability) {
            final JTypeWithNullability typeWithNullability = (JTypeWithNullability) javaType;
            final Result result = context.processType(typeWithNullability.getType());
            return new Result(
                    typeWithNullability.isNullable() ? new TsType.NullableType(result.getTsType()) : result.getTsType(),
                    result.getDiscoveredClasses()
            );
        }
        return null;
    }
    private Result processKnownGenericType(Type javaType, Class<?> rawClass, Context context) {
        final Optional<Class<?>> listBaseClass = assignableFrom(known.listClasses, rawClass);
        if (listBaseClass.isPresent()) {
            final List<Type> resolvedGenericVariables = GenericsResolver.resolveBaseGenericVariables(listBaseClass.get(), javaType);
            final Result result = context.processTypeInsideCollection(resolvedGenericVariables.get(0));
            return new Result(new TsType.BasicArrayType(result.getTsType()), result.getDiscoveredClasses());
        }
        final Optional<Class<?>> mapBaseClass = assignableFrom(known.mapClasses, rawClass);
        if (mapBaseClass.isPresent()) {
            final List<Type> resolvedGenericVariables = GenericsResolver.resolveBaseGenericVariables(mapBaseClass.get(), javaType);
            final Result keyResult = context.processType(resolvedGenericVariables.get(0));
            final Result valueResult = context.processTypeInsideCollection(resolvedGenericVariables.get(1));
            final TsType valueTsType = valueResult.getTsType();
            if (keyResult.getTsType() instanceof TsType.EnumReferenceType) {
                return new Result(
                        new TsType.MappedType(keyResult.getTsType(), TsType.MappedType.QuestionToken.Question, valueTsType),
                        Utils.concat(keyResult.getDiscoveredClasses(), valueResult.getDiscoveredClasses())
                );
            } else {
                return new Result(
                        new TsType.IndexedArrayType(TsType.String, valueTsType),
                        valueResult.getDiscoveredClasses()
                );
            }
        }
        final Optional<Class<?>> optionalBaseClass = assignableFrom(known.optionalClasses, rawClass);
        if (optionalBaseClass.isPresent()) {
            final List<Type> resolvedGenericVariables = GenericsResolver.resolveBaseGenericVariables(optionalBaseClass.get(), javaType);
            final Result result = context.processType(resolvedGenericVariables.get(0));
            return new Result(result.getTsType().optional(), result.getDiscoveredClasses());
        }
        final Optional<Class<?>> wrapperBaseClass = assignableFrom(known.wrapperClasses, rawClass);
        if (wrapperBaseClass.isPresent()) {
            final List<Type> resolvedGenericVariables = GenericsResolver.resolveBaseGenericVariables(wrapperBaseClass.get(), javaType);
            final Result result = context.processType(resolvedGenericVariables.get(0));
            return new Result(result.getTsType(), result.getDiscoveredClasses());
        }
        return null;
    }
    private static LoadedDataLibraries getKnownClasses() {
        return new LoadedDataLibraries(
            Arrays.asList(char.class, Character.class, String.class, UUID.class),
            Arrays.asList(byte.class, short.class, int.class, long.class, float.class, double.class, Number.class),
            Arrays.asList(boolean.class, Boolean.class),
            Arrays.asList(Date.class, Calendar.class, Temporal.class),
            Arrays.asList(),
            Arrays.asList(void.class, Void.class),
            Arrays.asList(Collection.class),
            Arrays.asList(Map.class),
            Arrays.asList(Optional.class),
            Arrays.asList(jakarta.xml.bind.JAXBElement.class, javax.xml.bind.JAXBElement.class),
            Arrays.asList(),
            Arrays.asList()
        );
    }
}
package cz.habarta.typescript.generator.parser;
import java.util.List;
import java.util.Objects;
public class Model {
    private final List<BeanModel> beans;
    private final List<EnumModel> enums;
    private final List<RestApplicationModel> restApplications;
    public Model(List<BeanModel> beans, List<EnumModel> enums, List<RestApplicationModel> restApplications) {
        this.beans = Objects.requireNonNull(beans);
        this.enums = Objects.requireNonNull(enums);
        this.restApplications = restApplications;
    }
    public List<BeanModel> getBeans() {
        return beans;
    }
    public BeanModel getBean(Class<?> beanClass) {
        for (BeanModel bean : beans) {
            if (bean.getOrigin().equals(beanClass)) {
                return bean;
            }
        }
        return null;
    }
    public List<EnumModel> getEnums() {
        return enums;
    }
    public List<RestApplicationModel> getRestApplications() {
        return restApplications;
    }
    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append("Model{");
        sb.append(String.format("%n"));
        for (BeanModel bean : beans) {
            sb.append("  ");
            sb.append(bean);
            sb.append(String.format("%n"));
        }
        for (EnumModel enumModel : enums) {
            sb.append("  ");
            sb.append(enumModel);
            sb.append(String.format("%n"));
        }
        sb.append('}');
        return sb.toString();
    }
}
package cz.habarta.typescript.generator.parser;
import com.google.gson.ExclusionStrategy;
import com.google.gson.FieldAttributes;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.annotations.SerializedName;
import cz.habarta.typescript.generator.ExcludingTypeProcessor;
import cz.habarta.typescript.generator.GsonConfiguration;
import cz.habarta.typescript.generator.OptionalProperties;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TypeProcessor;
import cz.habarta.typescript.generator.util.PropertyMember;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
public class GsonParser extends ModelParser {
    public static class Factory extends ModelParser.Factory {
        @Override
        public TypeProcessor getSpecificTypeProcessor() {
            return createSpecificTypeProcessor();
        }
        @Override
        public GsonParser create(Settings settings, TypeProcessor commonTypeProcessor,
                List<RestApplicationParser> restApplicationParsers) {
            return new GsonParser(settings, commonTypeProcessor, restApplicationParsers);
        }
    }
    private final Gson gson;
    public GsonParser(Settings settings, TypeProcessor commonTypeProcessor) {
        this(settings, commonTypeProcessor, Collections.emptyList());
    }
    public GsonParser(Settings settings, TypeProcessor commonTypeProcessor,
            List<RestApplicationParser> restApplicationParsers) {
        super(settings, commonTypeProcessor, restApplicationParsers);
        if (!settings.optionalAnnotations.isEmpty()) {
        }
        final GsonConfiguration config = settings.gsonConfiguration;
        int modifiers = config != null && config.excludeFieldsWithModifiers != null
            ? Settings.parseModifiers(config.excludeFieldsWithModifiers, Modifier.fieldModifiers())
            : Modifier.STATIC | Modifier.TRANSIENT;
        this.gson = new GsonBuilder()
            .excludeFieldsWithModifiers(modifiers)
            .setExclusionStrategies(new ExclusionStrategy() {
                @Override
                public boolean shouldSkipField(FieldAttributes fieldAttributes) {
                    return !isAnnotatedPropertyIncluded(fieldAttributes::getAnnotation, fieldAttributes.getDeclaringClass().getName() + "." + fieldAttributes.getName());
                }
                @Override
                public boolean shouldSkipClass(Class<?> aClass) {
                    return false;
                }
            })
            .create();
    }
    private static TypeProcessor createSpecificTypeProcessor() {
        return new ExcludingTypeProcessor(Arrays.asList());
    }
    @Override
    protected DeclarationModel parseClass(SourceType<Class<?>> sourceClass) {
        if (sourceClass.type.isEnum()) {
            return ModelParser.parseEnum(sourceClass);
        } else {
            return parseBean(sourceClass);
        }
    }
    private BeanModel parseBean(SourceType<Class<?>> sourceClass) {
        final List<PropertyModel> properties = new ArrayList<>();
        Class<?> cls = sourceClass.type;
        while (cls != null) {
            for (Field field : cls.getDeclaredFields()) {
                if (gson.excluder().excludeField(field, true)) {
                    continue;
                }
                String name = field.getName();
                SerializedName serializedName = field.getAnnotation(SerializedName.class);
                if (serializedName != null) {
                    name = serializedName.value();
                }
                final boolean optional = settings.optionalProperties == OptionalProperties.useLibraryDefinition
                        ? true
                        : isPropertyOptional(new PropertyMember(field, field.getGenericType(), field.getAnnotatedType(), null));
                properties.add(new PropertyModel(name, field.getGenericType(), optional, null, field, null, null, null));
                addBeanToQueue(new SourceType<>(field.getGenericType(), sourceClass.type, name));
            }
            cls = cls.getSuperclass();
        }
        final Type superclass = sourceClass.type.getGenericSuperclass() == Object.class ? null
                : sourceClass.type.getGenericSuperclass();
        if (superclass != null) {
            addBeanToQueue(new SourceType<>(superclass, sourceClass.type, "<superClass>"));
        }
        final List<Type> interfaces = Arrays.asList(sourceClass.type.getGenericInterfaces());
        for (Type aInterface : interfaces) {
            addBeanToQueue(new SourceType<>(aInterface, sourceClass.type, "<interface>"));
        }
        return new BeanModel(sourceClass.type, superclass, null, null, null, interfaces, properties, null);
    }
}
package cz.habarta.typescript.generator.emitter;
import com.fasterxml.jackson.databind.ObjectMapper;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.util.Utils;
import java.io.IOException;
import java.io.Writer;
public class NpmPackageJsonEmitter {
    private Writer writer;
    public void emit(NpmPackageJson npmPackageJson, Writer output, String outputName, boolean closeOutput) {
        this.writer = output;
        if (outputName != null) {
            TypeScriptGenerator.getLogger().info("Writing NPM package to: " + outputName);
        }
        emitPackageJson(npmPackageJson);
        if (closeOutput) {
            close();
        }
    }
    private void emitPackageJson(NpmPackageJson npmPackageJson) {
        try {
            final ObjectMapper objectMapper = Utils.getObjectMapper();
            objectMapper.writeValue(writer, npmPackageJson);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    private void close() {
        try {
            writer.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
package cz.habarta.typescript.generator.emitter;
import cz.habarta.typescript.generator.ModuleDependency;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TsParameter;
import cz.habarta.typescript.generator.TsType;
import cz.habarta.typescript.generator.TypeScriptFileType;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.TypeScriptOutputKind;
import cz.habarta.typescript.generator.compiler.EnumMemberModel;
import cz.habarta.typescript.generator.compiler.ModelCompiler;
import java.io.IOException;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
public class Emitter implements EmitterExtension.Writer {
    private final Settings settings;
    private Writer writer;
    private int indent;
    public Emitter(Settings settings) {
        this.settings = settings;
    }
    public void emit(TsModel model, Writer output, String outputName, boolean closeOutput) {
        this.writer = output;
        this.indent = 0;
        if (outputName != null) {
            TypeScriptGenerator.getLogger().info("Writing declarations to: " + outputName);
        }
        emitFileComment();
        emitReferences();
        emitImports();
        emitModule(model);
        emitUmdNamespace();
        if (closeOutput) {
            close();
        }
    }
    private void emitFileComment() {
        if (!settings.noTslintDisable) {
            writeIndentedLine("");
        }
        if (!settings.noEslintDisable) {
            writeIndentedLine("");
        }
        if (settings.tsNoCheck) {
            writeIndentedLine("
        }
        if (!settings.noFileComment) {
            final String timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
            writeIndentedLine("
        }
    }
    private void emitReferences() {
        if (settings.referencedFiles != null && !settings.referencedFiles.isEmpty()) {
            writeNewLine();
            for (String reference : settings.referencedFiles) {
                writeIndentedLine("
            }
        }
    }
    private void emitImports() {
        if (settings.moduleDependencies != null && !settings.moduleDependencies.isEmpty()) {
            writeNewLine();
            for (ModuleDependency dependency : settings.moduleDependencies) {
                if (!dependency.global) {
                    writeIndentedLine("import * as " + dependency.importAs + " from " + quote(dependency.importFrom, settings) + ";");
                }
            }
        }
        if (settings.importDeclarations != null && !settings.importDeclarations.isEmpty()) {
            writeNewLine();
            for (String importDeclaration : settings.importDeclarations) {
                writeIndentedLine(importDeclaration + ";");
            }
        }
    }
    private void emitModule(TsModel model) {
        if (settings.outputKind == TypeScriptOutputKind.ambientModule) {
            writeNewLine();
            writeIndentedLine("declare module " + quote(settings.module, settings) + " {");
            indent++;
            emitNamespace(model);
            indent--;
            writeNewLine();
            writeIndentedLine("}");
        } else {
            emitNamespace(model);
        }
    }
    private void emitNamespace(TsModel model) {
        if (settings.namespace != null) {
            writeNewLine();
            String prefix = "";
            if (settings.outputFileType == TypeScriptFileType.declarationFile && settings.outputKind == TypeScriptOutputKind.global) {
                prefix = "declare ";
            }
            if (settings.outputKind == TypeScriptOutputKind.module) {
                prefix = "export ";
            }
            writeIndentedLine(prefix +  "namespace " + settings.namespace + " {");
            indent++;
            final boolean exportElements = settings.outputFileType == TypeScriptFileType.implementationFile;
            emitElements(model, exportElements, false);
            indent--;
            writeNewLine();
            writeIndentedLine("}");
        } else {
            final boolean exportElements = settings.outputKind == TypeScriptOutputKind.module;
            final boolean declareElements = settings.outputFileType == TypeScriptFileType.declarationFile && settings.outputKind == TypeScriptOutputKind.global;
            emitElements(model, exportElements, declareElements);
        }
    }
    private void emitElements(TsModel model, boolean exportKeyword, boolean declareKeyword) {
        emitBeans(model, exportKeyword, declareKeyword);
        emitTypeAliases(model, exportKeyword, declareKeyword);
        emitLiteralEnums(model, exportKeyword, declareKeyword);
        emitHelpers(model);
        emitExtensions(model, exportKeyword);
    }
    private void emitBeans(TsModel model, boolean exportKeyword, boolean declareKeyword) {
        for (TsBeanModel bean : model.getBeans()) {
            emitFullyQualifiedDeclaration(bean, exportKeyword, declareKeyword);
        }
    }
    private void emitTypeAliases(TsModel model, boolean exportKeyword, boolean declareKeyword) {
        for (TsAliasModel alias : model.getTypeAliases()) {
            emitFullyQualifiedDeclaration(alias, exportKeyword, declareKeyword);
        }
    }
    private void emitLiteralEnums(TsModel model, boolean exportKeyword, boolean declareKeyword) {
        for (TsEnumModel enumModel : model.getEnums()) {
            emitFullyQualifiedDeclaration(enumModel, exportKeyword, declareKeyword);
        }
    }
    private void emitFullyQualifiedDeclaration(TsDeclarationModel declaration, boolean exportKeyword, boolean declareKeyword) {
        if (declaration.getName().getNamespace() != null) {
            writeNewLine();
            final String prefix = declareKeyword ? "declare " : "";
            writeIndentedLine(exportKeyword, prefix + "namespace " + declaration.getName().getNamespace() + " {");
            indent++;
            emitDeclaration(declaration, true, false);
            indent--;
            writeNewLine();
            writeIndentedLine("}");
        } else {
            emitDeclaration(declaration, exportKeyword, declareKeyword);
        }
    }
    private void emitDeclaration(TsDeclarationModel declaration, boolean exportKeyword, boolean declareKeyword) {
        if (declaration instanceof TsBeanModel) {
            emitBean((TsBeanModel) declaration, exportKeyword);
        } else if (declaration instanceof TsAliasModel) {
            emitTypeAlias((TsAliasModel) declaration, exportKeyword);
        } else if (declaration instanceof TsEnumModel) {
            emitLiteralEnum((TsEnumModel) declaration, exportKeyword, declareKeyword);
        } else {
            throw new RuntimeException("Unknown declaration type: " + declaration.getClass().getName());
        }
    }
    private void emitBean(TsBeanModel bean, boolean exportKeyword) {
        writeNewLine();
        emitComments(bean.getComments());
        emitDecorators(bean.getDecorators());
        final String declarationType = bean.isClass() ? "class" : "interface";
        final String typeParameters = bean.getTypeParameters().isEmpty() ? "" : "<" + formatList(settings, bean.getTypeParameters()) + ">";
        final List<TsType> extendsList = bean.getExtendsList();
        final List<TsType> implementsList = bean.getImplementsList();
        final String extendsClause = extendsList.isEmpty() ? "" : " extends " + formatList(settings, extendsList);
        final String implementsClause = implementsList.isEmpty() ? "" : " implements " + formatList(settings, implementsList);
        writeIndentedLine(exportKeyword, declarationType + " " + bean.getName().getSimpleName() + typeParameters + extendsClause + implementsClause + " {");
        indent++;
        for (TsPropertyModel property : bean.getProperties()) {
            emitProperty(property);
        }
        if (bean.getConstructor() != null) {
            emitCallable(bean.getConstructor());
        }
        for (TsMethodModel method : bean.getMethods()) {
            emitCallable(method);
        }
        indent--;
        writeIndentedLine("}");
    }
    private void emitProperty(TsPropertyModel property) {
        emitComments(property.getComments());
        emitDecorators(property.getDecorators());
        final TsType tsType = property.getTsType();
        final String staticString = property.modifiers.isStatic ? "static " : "";
        final String readonlyString = property.modifiers.isReadonly ? "readonly " : "";
        final String questionMark = tsType instanceof TsType.OptionalType ? "?" : "";
        final String defaultString = property.getDefaultValue() != null ? " = " + property.getDefaultValue().format(settings) : "";
        writeIndentedLine(staticString + readonlyString + quoteIfNeeded(property.getName(), settings) + questionMark + ": " + tsType.format(settings) + defaultString + ";");
    }
    private void emitDecorators(List<TsDecorator> decorators) {
        for (TsDecorator decorator : decorators) {
            writeIndentedLine(formatDecorator(settings, decorator));
        }
    }
    private static String formatDecoratorList(Settings settings, List<TsDecorator> decorators) {
        return decorators.stream()
                .map(decorator -> formatDecorator(settings, decorator))
                .collect(Collectors.joining(", "));
    }
    private static String formatDecorator(Settings settings, TsDecorator decorator) {
        final String at = decorator.getIdentifierReference().getIdentifier().startsWith("@") ? "" : "@";
        final String parameters = decorator.getArguments() != null
                ? ("(" + formatList(settings, decorator.getArguments()) + ")")
                : "";
        return at + decorator.getIdentifierReference().format(settings) + parameters;
    }
    public static String quoteIfNeeded(String name, Settings settings) {
        return ModelCompiler.isValidIdentifierName(name) ? name : quote(name, settings);
    }
    public static String quote(String value, Settings settings) {
        return settings.quotes + value + settings.quotes;
    }
    public static String formatList(Settings settings, List<? extends Emittable> list) {
        return formatList(settings, list, ", ");
    }
    public static String formatList(Settings settings, List<? extends Emittable> list, String delimiter) {
        return list.stream()
                .map(item -> item.format(settings))
                .collect(Collectors.joining(delimiter));
    }
    private void emitCallable(TsCallableModel method) {
        writeNewLine();
        emitComments(method.getComments());
        if (method instanceof TsMethodModel) {
            emitDecorators(((TsMethodModel) method).getDecorators());
        }
        final String staticString = method.getModifiers().isStatic ? "static " : "";
        final String typeParametersString = method.getTypeParameters().isEmpty() ? "" : "<" + formatList(settings, method.getTypeParameters()) + ">";
        final String parametersString = formatParameterModelList(settings, method.getParameters());
        final String type = method.getReturnType() != null ? ": " + method.getReturnType() : "";
        final String signature = staticString + method.getName() + typeParametersString + parametersString + type;
        if (method.getBody() != null) {
            writeIndentedLine(signature + " {");
            indent++;
            emitStatements(method.getBody());
            indent--;
            writeIndentedLine("}");
        } else {
            writeIndentedLine(signature + ";");
        }
    }
    public static String formatParameterModelList(Settings settings, List<TsParameterModel> parameters) {
        final List<String> params = new ArrayList<>();
        for (TsParameterModel parameter : parameters) {
            final List<TsDecorator> decorators = parameter.getDecorators();
            final String decoratorsString = decorators != null && !decorators.isEmpty() ? formatDecoratorList(settings, decorators) + " " : "";
            final TsAccessibilityModifier accessibilityModifier = parameter.getAccessibilityModifier();
            final String access = accessibilityModifier != null ? accessibilityModifier.format() + " " : "";
            params.add(decoratorsString + access + formatParameterNameAndType(parameter));
        }
        return joinParameters(params, true);
    }
    public static String formatParameterList(List<TsParameter> parameters) {
        final List<String> params = new ArrayList<>();
        for (TsParameter parameter : parameters) {
            params.add(formatParameterNameAndType(parameter));
        }
        final boolean parentheses = parameters.size() != 1 || parameters.get(0).tsType != null;
        return joinParameters(params, parentheses);
    }
    private static String formatParameterNameAndType(TsParameter parameter) {
        final String questionMark = (parameter.getTsType() instanceof TsType.OptionalType) ? "?" : "";
        final String type = parameter.getTsType() != null ? ": " + parameter.getTsType() : "";
        return parameter.getName() + questionMark + type;
    }
    private static String joinParameters(List<String> params, boolean parentheses) {
        return parentheses
                ? "(" + String.join(", ", params) + ")"
                : String.join(", ", params);
    }
    private void emitStatements(List<TsStatement> statements) {
        for (TsStatement statement : statements) {
            if (statement instanceof TsReturnStatement) {
                emitReturnStatement((TsReturnStatement) statement);
            } else if (statement instanceof TsIfStatement) {
                emitIfStatement((TsIfStatement) statement);
            } else if (statement instanceof TsExpressionStatement) {
                emitExpressionStatement((TsExpressionStatement) statement);
            } else if (statement instanceof TsVariableDeclarationStatement) {
                emitVariableDeclarationStatement((TsVariableDeclarationStatement) statement);
            } else if (statement instanceof TsSwitchStatement) {
                emitTsSwitchStatement((TsSwitchStatement) statement);
            }
        }
    }
    private void emitReturnStatement(TsReturnStatement returnStatement) {
        if (returnStatement.getExpression() != null) {
            writeIndentedLine("return " + returnStatement.getExpression().format(settings) + ";");
        } else {
            writeIndentedLine("return;");
        }
    }
    private void emitIfStatement(TsIfStatement ifStatement) {
        writeIndentedLine("if (" + ifStatement.getExpression().format(settings) + ") {");
        indent++;
        emitStatements(ifStatement.getThenStatements());
        indent--;
        if (ifStatement.getElseStatements() != null) {
            writeIndentedLine("} else {");
            indent++;
            emitStatements(ifStatement.getElseStatements());
            indent--;
        }
        writeIndentedLine("}");
    }
    private void emitExpressionStatement(TsExpressionStatement expressionStatement) {
        writeIndentedLine(expressionStatement.getExpression().format(settings) + ";");
    }
    private void emitVariableDeclarationStatement(TsVariableDeclarationStatement variableDeclarationStatement) {
        writeIndentedLine(
                (variableDeclarationStatement.isConst() ? "const " : "let ")
                + variableDeclarationStatement.getName()
                + (variableDeclarationStatement.getType() != null ? ": " + variableDeclarationStatement.getType().format(settings) : "")
                + (variableDeclarationStatement.getInitializer() != null ? " = " + variableDeclarationStatement.getInitializer().format(settings) : "")
                + ";"
        );
    }
    private void emitTsSwitchStatement(TsSwitchStatement switchStatement) {
        writeIndentedLine("switch (" + switchStatement.getExpression().format(settings) + ") {");
        indent++;
        for (TsSwitchCaseClause caseClause : switchStatement.getCaseClauses()) {
            writeIndentedLine("case " + caseClause.getExpression().format(settings) + ":");
            indent++;
            emitStatements(caseClause.getStatements());
            indent--;
        }
        if (switchStatement.getDefaultClause() != null) {
            writeIndentedLine("default:");
            indent++;
            emitStatements(switchStatement.getDefaultClause());
            indent--;
        }
        indent--;
        writeIndentedLine("}");
    }
    private void emitTypeAlias(TsAliasModel alias, boolean exportKeyword) {
        writeNewLine();
        emitComments(alias.getComments());
        final String genericParameters = alias.getTypeParameters().isEmpty()
                ? ""
                : "<" + formatList(settings, alias.getTypeParameters()) + ">";
        writeIndentedLine(exportKeyword, "type " + alias.getName().getSimpleName() + genericParameters + " = " + alias.getDefinition().format(settings) + ";");
    }
    private void emitLiteralEnum(TsEnumModel enumModel, boolean exportKeyword, boolean declareKeyword) {
        writeNewLine();
        emitComments(enumModel.getComments());
        final String declareText = declareKeyword ? "declare " : "";
        final String constText = enumModel.isNonConstEnum() ? "" : "const ";
        writeIndentedLine(exportKeyword, declareText + constText + "enum " + enumModel.getName().getSimpleName() + " {");
        indent++;
        for (EnumMemberModel member : enumModel.getMembers()) {
            emitComments(member.getComments());
            final Object value = member.getEnumValue();
            final String initializer = value != null
                    ? " = " + (value instanceof String ? quote((String) value, settings) : String.valueOf(value))
                    : "";
            writeIndentedLine(member.getPropertyName() + initializer + ",");
        }
        indent--;
        writeIndentedLine("}");
    }
    private void emitHelpers(TsModel model) {
        for (TsHelper helper : model.getHelpers()) {
            writeNewLine();
            writeTemplate(this, settings, helper.getLines(), null);
        }
    }
    private void emitExtensions(TsModel model, boolean exportKeyword) {
        for (EmitterExtension emitterExtension : settings.extensions) {
            final List<String> extensionLines = new ArrayList<>();
            final EmitterExtension.Writer extensionWriter = new EmitterExtension.Writer() {
                @Override
                public void writeIndentedLine(String line) {
                    extensionLines.add(line);
                }
            };
            emitterExtension.emitElements(extensionWriter, settings, exportKeyword, model);
            if (!extensionLines.isEmpty()) {
                writeNewLine();
                writeNewLine();
                writeIndentedLine(String.format("
                for (String line : extensionLines) {
                    this.writeIndentedLine(line);
                }
            }
        }
    }
    private void emitUmdNamespace() {
        if (settings.umdNamespace != null) {
            writeNewLine();
            writeIndentedLine("export as namespace " + settings.umdNamespace + ";");
        }
    }
    private void emitComments(List<String> comments) {
        if (comments != null) {
            writeIndentedLine("");
        }
    }
    public static void writeTemplate(EmitterExtension.Writer writer, Settings settings, List<String> template, Map<String, String> replacements) {
        for (String line : template) {
            if (replacements != null) {
                for (Map.Entry<String, String> entry : replacements.entrySet()) {
                    line = line.replace(entry.getKey(), entry.getValue());
                }
            }
            writer.writeIndentedLine(line
                    .replace("\t", settings.indentString)
                    .replace("\"", settings.quotes)
            );
        }
    }
    private void writeIndentedLine(boolean exportKeyword, String line) {
        writeIndentedLine((exportKeyword ? "export " : "") + line);
    }
    @Override
    public void writeIndentedLine(String line) {
        try {
            if (!line.isEmpty()) {
                for (int i = 0; i < indent; i++) {
                    writer.write(settings.indentString);
                }
            }
            writer.write(line);
            writeNewLine();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    private void writeNewLine() {
        try {
            writer.write(settings.newline);
            writer.flush();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    private void close() {
        try {
            writer.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
package cz.habarta.typescript.generator.emitter;
import com.fasterxml.jackson.databind.ObjectMapper;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.util.Utils;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.stream.Stream;
public class InfoJsonEmitter {
    private Writer writer;
    public void emit(TsModel tsModel, Writer output, String outputName, boolean closeOutput) {
        this.writer = output;
        if (outputName != null) {
            TypeScriptGenerator.getLogger().info("Writing module info to: " + outputName);
        }
        emitTypeMappingJson(tsModel);
        if (closeOutput) {
            close();
        }
    }
    private void emitTypeMappingJson(TsModel tsModel) {
        try {
            final ObjectMapper objectMapper = Utils.getObjectMapper();
            final InfoJson infoJson = getInfoJson(tsModel);
            objectMapper.writeValue(writer, infoJson);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    private InfoJson getInfoJson(TsModel tsModel) {
        final LinkedHashMap<String, InfoJson.ClassInfo> map = new LinkedHashMap<>();
        Stream
                .of(
                        tsModel.getBeans(),
                        tsModel.getEnums(),
                        tsModel.getTypeAliases()
                )
                .flatMap(s -> s.stream())
                .filter(declaration -> declaration.origin != null)
                .map(declaration -> {
                    final InfoJson.ClassInfo typeMapping = new InfoJson.ClassInfo();
                    typeMapping.javaClass = declaration.origin.getName();
                    typeMapping.typeName = declaration.name.getFullName();
                    return typeMapping;
                })
                .forEach(info -> {
                    map.remove(info.javaClass);
                    map.put(info.javaClass, info);
                });
        final InfoJson infoJson = new InfoJson();
        infoJson.classes = new ArrayList<>(map.values());
        return infoJson;
    }
    private void close() {
        try {
            writer.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
package cz.habarta.typescript.generator.emitter;
import cz.habarta.typescript.generator.compiler.EnumKind;
import cz.habarta.typescript.generator.compiler.Symbol;
import cz.habarta.typescript.generator.util.Utils;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
public class TsModel {
    private final List<TsBeanModel> beans;
    private final List<TsEnumModel> enums;
    private final List<TsEnumModel> originalStringEnums;
    private final List<TsAliasModel> typeAliases;
    private final List<TsHelper> helpers;
    public TsModel() {
        this (new ArrayList<TsBeanModel>(), new ArrayList<TsEnumModel>(), new ArrayList<TsEnumModel>(), new ArrayList<TsAliasModel>(), new ArrayList<TsHelper>());
    }
    public TsModel(List<TsBeanModel> beans, List<TsEnumModel> enums, List<TsEnumModel> originalStringEnums, List<TsAliasModel> typeAliases, List<TsHelper> helpers) {
        this.beans = Objects.requireNonNull(beans);
        this.enums = Objects.requireNonNull(enums);
        this.originalStringEnums = originalStringEnums;
        this.typeAliases = Objects.requireNonNull(typeAliases);
        this.helpers = helpers;
    }
    public List<TsBeanModel> getBeans() {
        return beans;
    }
    public TsBeanModel getBean(Class<?> origin) {
        if (origin != null) {
            for (TsBeanModel bean : beans) {
                if (Objects.equals(bean.getOrigin(), origin)) {
                    return bean;
                }
            }
        }
        return null;
    }
    public TsBeanModel getBean(Symbol name) {
        if (name != null) {
            for (TsBeanModel bean : beans) {
                if (Objects.equals(bean.getName(), name)) {
                    return bean;
                }
            }
        }
        return null;
    }
    public TsModel withBeans(List<TsBeanModel> beans) {
        return new TsModel(beans, enums, originalStringEnums, typeAliases, helpers);
    }
    public TsModel withoutBeans(List<TsBeanModel> beans) {
        return new TsModel(Utils.removeAll(this.beans, beans), enums, originalStringEnums, typeAliases, helpers);
    }
    public List<TsEnumModel> getEnums() {
        return enums;
    }
    public List<TsEnumModel> getEnums(EnumKind enumKind) {
        final List<TsEnumModel> result = new ArrayList<>();
        for (TsEnumModel enumModel : enums) {
            if (enumModel.getKind() == enumKind) {
                result.add(enumModel);
            }
        }
        return result;
    }
    public TsModel withEnums(List<TsEnumModel> enums) {
        return new TsModel(beans, enums, originalStringEnums, typeAliases, helpers);
    }
    public TsModel withAddedEnums(List<TsEnumModel> enums) {
        return new TsModel(beans, Utils.concat(this.enums, enums), originalStringEnums, typeAliases, helpers);
    }
    public TsModel withRemovedEnums(List<TsEnumModel> enums) {
        return new TsModel(beans, Utils.removeAll(this.enums, enums), originalStringEnums, typeAliases, helpers);
    }
    public List<TsEnumModel> getOriginalStringEnums() {
        return originalStringEnums;
    }
    public TsModel withOriginalStringEnums(List<TsEnumModel> originalStringEnums) {
        return new TsModel(beans, enums, originalStringEnums, typeAliases, helpers);
    }
    public List<TsAliasModel> getTypeAliases() {
        return typeAliases;
    }
    public TsAliasModel getTypeAlias(Class<?> origin) {
        if (origin != null) {
            for (TsAliasModel alias : typeAliases) {
                if (Objects.equals(alias.getOrigin(), origin)) {
                    return alias;
                }
            }
        }
        return null;
    }
    public TsModel withTypeAliases(List<TsAliasModel> typeAliases) {
        return new TsModel(beans, enums, originalStringEnums, typeAliases, helpers);
    }
    public TsModel withAddedTypeAliases(List<TsAliasModel> typeAliases) {
        return new TsModel(beans, enums, originalStringEnums, Utils.concat(this.typeAliases, typeAliases), helpers);
    }
    public TsModel withRemovedTypeAliases(List<TsAliasModel> typeAliases) {
        return new TsModel(beans, enums, originalStringEnums, Utils.removeAll(this.typeAliases, typeAliases), helpers);
    }
    public List<TsHelper> getHelpers() {
        return helpers;
    }
}
package cz.habarta.typescript.generator.parser;
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonClassDescription;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIdentityInfo;
import com.fasterxml.jackson.annotation.JsonIdentityReference;
import com.fasterxml.jackson.annotation.JsonPropertyDescription;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonUnwrapped;
import com.fasterxml.jackson.annotation.JsonView;
import com.fasterxml.jackson.annotation.ObjectIdGenerators;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.AnnotationIntrospector;
import com.fasterxml.jackson.databind.BeanDescription;
import com.fasterxml.jackson.databind.BeanProperty;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.Module;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationConfig;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.cfg.MutableConfigOverride;
import com.fasterxml.jackson.databind.deser.BeanDeserializer;
import com.fasterxml.jackson.databind.deser.BeanDeserializerFactory;
import com.fasterxml.jackson.databind.deser.CreatorProperty;
import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;
import com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap;
import com.fasterxml.jackson.databind.introspect.AnnotatedClass;
import com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair;
import com.fasterxml.jackson.databind.jsontype.NamedType;
import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;
import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;
import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
import com.fasterxml.jackson.databind.ser.BeanSerializer;
import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;
import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;
import com.fasterxml.jackson.databind.type.TypeFactory;
import com.fasterxml.jackson.module.jakarta.xmlbind.JakartaXmlBindAnnotationIntrospector;
import com.fasterxml.jackson.module.jaxb.JaxbAnnotationIntrospector;
import cz.habarta.typescript.generator.ExcludingTypeProcessor;
import cz.habarta.typescript.generator.Jackson2ConfigurationResolved;
import cz.habarta.typescript.generator.OptionalProperties;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TsType;
import cz.habarta.typescript.generator.TypeProcessor;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.compiler.EnumKind;
import cz.habarta.typescript.generator.compiler.EnumMemberModel;
import cz.habarta.typescript.generator.type.JUnionType;
import cz.habarta.typescript.generator.util.Pair;
import cz.habarta.typescript.generator.util.PropertyMember;
import cz.habarta.typescript.generator.util.Utils;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class Jackson2Parser extends ModelParser {
    public static class Jackson2ParserFactory extends ModelParser.Factory {
        private final boolean useJaxbAnnotations;
        public Jackson2ParserFactory() {
            this(false);
        }
        private Jackson2ParserFactory(boolean useJaxbAnnotations) {
            this.useJaxbAnnotations = useJaxbAnnotations;
        }
        @Override
        public TypeProcessor getSpecificTypeProcessor() {
            return createSpecificTypeProcessor();
        }
        @Override
        public Jackson2Parser create(Settings settings, TypeProcessor commonTypeProcessor, List<RestApplicationParser> restApplicationParsers) {
            return new Jackson2Parser(settings, commonTypeProcessor, restApplicationParsers, useJaxbAnnotations);
        }
    }
    public static class JaxbParserFactory extends Jackson2ParserFactory {
        public JaxbParserFactory() {
            super(true);
        }
    }
    private final ObjectMapper objectMapper = new ObjectMapper();
    public Jackson2Parser(Settings settings, TypeProcessor typeProcessor) {
        this(settings, typeProcessor, Collections.emptyList(), false);
    }
    public Jackson2Parser(Settings settings, TypeProcessor commonTypeProcessor, List<RestApplicationParser> restApplicationParsers, boolean useJaxbAnnotations) {
        super(settings, commonTypeProcessor, restApplicationParsers);
        if (settings.jackson2ModuleDiscovery) {
            objectMapper.registerModules(ObjectMapper.findModules(settings.classLoader));
        }
        for (Class<? extends Module> moduleClass : settings.jackson2Modules) {
            try {
                objectMapper.registerModule(moduleClass.getConstructor().newInstance());
            } catch (ReflectiveOperationException e) {
                throw new RuntimeException(String.format("Cannot instantiate Jackson2 module '%s'", moduleClass.getName()), e);
            }
        }
        if (useJaxbAnnotations) {
            final AnnotationIntrospector original = objectMapper.getSerializationConfig().getAnnotationIntrospector();
            final AnnotationIntrospector jakartaIntrospector = new JakartaXmlBindAnnotationIntrospector(objectMapper.getTypeFactory());
            final AnnotationIntrospector javaxIntrospector = new JaxbAnnotationIntrospector(objectMapper.getTypeFactory());
            final AnnotationIntrospectorPair jaxbPair = new AnnotationIntrospectorPair(jakartaIntrospector, javaxIntrospector);
            final AnnotationIntrospectorPair pair = new AnnotationIntrospectorPair(jaxbPair, original);
            objectMapper.setAnnotationIntrospector(pair);
        }
        final Jackson2ConfigurationResolved config = settings.jackson2Configuration;
        if (config != null) {
            setVisibility(PropertyAccessor.FIELD, config.fieldVisibility);
            setVisibility(PropertyAccessor.GETTER, config.getterVisibility);
            setVisibility(PropertyAccessor.IS_GETTER, config.isGetterVisibility);
            setVisibility(PropertyAccessor.SETTER, config.setterVisibility);
            setVisibility(PropertyAccessor.CREATOR, config.creatorVisibility);
            if (config.shapeConfigOverrides != null) {
                config.shapeConfigOverrides.entrySet()
                        .forEach(entry -> setShapeOverride(entry.getKey(), entry.getValue()));
            }
            if (config.enumsUsingToString) {
                objectMapper.enable(SerializationFeature.WRITE_ENUMS_USING_TO_STRING);
                objectMapper.enable(DeserializationFeature.READ_ENUMS_USING_TO_STRING);
            }
        }
    }
    private void setVisibility(PropertyAccessor accessor, JsonAutoDetect.Visibility visibility) {
        if (visibility != null) {
            objectMapper.setVisibility(accessor, visibility);
        }
    }
    private void setShapeOverride(Class<?> cls, JsonFormat.Shape shape) {
        final MutableConfigOverride configOverride = objectMapper.configOverride(cls);
        configOverride.setFormat(
                JsonFormat.Value.merge(
                        configOverride.getFormat(),
                        JsonFormat.Value.forShape(shape)));
    }
    private static TypeProcessor createSpecificTypeProcessor() {
        return new TypeProcessor.Chain(
                new ExcludingTypeProcessor(Arrays.asList(JsonNode.class.getName())),
                new TypeProcessor() {
                    @Override
                    public TypeProcessor.Result processType(Type javaType, TypeProcessor.Context context) {
                        if (context.getTypeContext() instanceof Jackson2TypeContext) {
                            final Jackson2TypeContext jackson2TypeContext = (Jackson2TypeContext) context.getTypeContext();
                            final Jackson2ConfigurationResolved config = jackson2TypeContext.parser.settings.jackson2Configuration;
                            final JsonSerialize jsonSerialize = jackson2TypeContext.beanProperty.getAnnotation(JsonSerialize.class);
                            if (jsonSerialize != null && config != null && config.serializerTypeMappings != null) {
                                @SuppressWarnings("unchecked")
                                final Class<? extends JsonSerializer<?>> using = (Class<? extends JsonSerializer<?>>)
                                    (context.isInsideCollection() ? jsonSerialize.contentUsing() : jsonSerialize.using());
                                final String mappedType = config.serializerTypeMappings.get(using);
                                if (mappedType != null) {
                                    return new TypeProcessor.Result(new TsType.VerbatimType(mappedType));
                                }
                            }
                            final JsonDeserialize jsonDeserialize = jackson2TypeContext.beanProperty.getAnnotation(JsonDeserialize.class);
                            if (jsonDeserialize != null && config != null && config.deserializerTypeMappings != null) {
                                @SuppressWarnings("unchecked")
                                final Class<? extends JsonDeserializer<?>> using = (Class<? extends JsonDeserializer<?>>)
                                    (context.isInsideCollection() ? jsonDeserialize.contentUsing() : jsonDeserialize.using());
                                final String mappedType = config.deserializerTypeMappings.get(using);
                                if (mappedType != null) {
                                    return new TypeProcessor.Result(new TsType.VerbatimType(mappedType));
                                }
                            }
                            if (!jackson2TypeContext.disableObjectIdentityFeature) {
                                final Type resultType = jackson2TypeContext.parser.processIdentity(javaType, jackson2TypeContext.beanProperty);
                                if (resultType != null) {
                                    return context.withTypeContext(null).processType(resultType);
                                }
                            }
                            final Class<?> rawClass = Utils.getRawClassOrNull(javaType);
                            if (rawClass != null && Map.Entry.class.isAssignableFrom(rawClass)) {
                                final ObjectMapper objectMapper = jackson2TypeContext.parser.objectMapper;
                                final SerializationConfig serializationConfig = objectMapper.getSerializationConfig();
                                final BeanDescription beanDescription = serializationConfig
                                        .introspect(TypeFactory.defaultInstance().constructType(rawClass));
                                final JsonFormat.Value formatOverride = serializationConfig.getDefaultPropertyFormat(Map.Entry.class);
                                final JsonFormat.Value formatFromAnnotation = beanDescription.findExpectedFormat(null);
                                final JsonFormat.Value format = JsonFormat.Value.merge(formatFromAnnotation, formatOverride);
                                if (format.getShape() != JsonFormat.Shape.OBJECT) {
                                    final Type mapType = Utils.replaceRawClassInType(javaType, Map.class);
                                    return context.processType(mapType);
                                }
                            }
                        }
                        return null;
                    }
                }
        );
    }
    private static class Jackson2TypeContext {
        public final Jackson2Parser parser;
        public final BeanProperty beanProperty;
        public final boolean disableObjectIdentityFeature;
        public Jackson2TypeContext(Jackson2Parser parser, BeanProperty beanProperty, boolean disableObjectIdentityFeature) {
            this.parser = parser;
            this.beanProperty = beanProperty;
            this.disableObjectIdentityFeature = disableObjectIdentityFeature;
        }
    }
    @Override
    protected DeclarationModel parseClass(SourceType<Class<?>> sourceClass) {
        final List<String> classComments = getComments(sourceClass.type.getAnnotation(JsonClassDescription.class));
        if (sourceClass.type.isEnum()) {
            return parseEnumOrObjectEnum(sourceClass, classComments);
        } else {
            return parseBean(sourceClass, classComments);
        }
    }
    private BeanModel parseBean(SourceType<Class<?>> sourceClass, List<String> classComments) {
        final List<PropertyModel> properties = new ArrayList<>();
        final Class<?> view = settings.jackson2Configuration != null ? settings.jackson2Configuration.view : null;
        final BeanHelpers beanHelpers = getBeanHelpers(sourceClass.type, view);
        if (beanHelpers != null) {
            for (final Pair<BeanProperty, PropertyAccess> pair : beanHelpers.getPropertiesAndAccess()) {
                final BeanProperty beanProperty = pair.getValue1();
                final PropertyAccess access = pair.getValue2();
                final Member member = beanProperty.getMember().getMember();
                final PropertyMember propertyMember = wrapMember(settings.getTypeParser(), member, getCreatorIndex(beanProperty), beanProperty::getAnnotation, beanProperty.getName(), sourceClass.type);
                if (propertyMember == null) {
                    continue;
                }
                Type propertyType = propertyMember.getType();
                final List<String> propertyComments = getComments(beanProperty.getAnnotation(JsonPropertyDescription.class));
                final Jackson2TypeContext jackson2TypeContext = new Jackson2TypeContext(
                        this,
                        beanProperty,
                        settings.jackson2Configuration != null && settings.jackson2Configuration.disableObjectIdentityFeature);
                if (!isAnnotatedPropertyIncluded(beanProperty::getAnnotation, sourceClass.type.getName() + "." + beanProperty.getName())) {
                    continue;
                }
                final boolean optional = settings.optionalProperties == OptionalProperties.useLibraryDefinition
                        ? !beanProperty.isRequired()
                        : isPropertyOptional(propertyMember);
                PropertyModel.PullProperties pullProperties = null;
                final JsonUnwrapped annotation = beanProperty.getAnnotation(JsonUnwrapped.class);
                if (annotation != null && annotation.enabled()) {
                    pullProperties = new PropertyModel.PullProperties(annotation.prefix(), annotation.suffix());
                }
                properties.add(processTypeAndCreateProperty(beanProperty.getName(), propertyType, jackson2TypeContext, optional, access, sourceClass.type, member, pullProperties, propertyComments));
            }
        }
        if (sourceClass.type.isEnum()) {
            return new BeanModel(sourceClass.type, null, null, null, null, null, properties, classComments);
        }
        final String discriminantProperty;
        final boolean syntheticDiscriminantProperty;
        final String discriminantLiteral;
        final Pair<Class<?>, JsonTypeInfo> classWithJsonTypeInfo = Pair.of(sourceClass.type, sourceClass.type.getAnnotation(JsonTypeInfo.class));
        final Pair<Class<?>, JsonTypeInfo> parentClassWithJsonTypeInfo;
        final boolean isTaggedUnionParent = isTaggedUnion(classWithJsonTypeInfo);
        if (isTaggedUnionParent) {
            final JsonTypeInfo jsonTypeInfo = classWithJsonTypeInfo.getValue2();
            discriminantProperty = getDiscriminantPropertyName(jsonTypeInfo);
            syntheticDiscriminantProperty = isDiscriminantPropertySynthetic(jsonTypeInfo);
            discriminantLiteral = isInterfaceOrAbstract(sourceClass.type) ? null : getTypeName(sourceClass.type);
        } else if (isTaggedUnion(parentClassWithJsonTypeInfo = getAnnotationRecursive(sourceClass.type, JsonTypeInfo.class))) {
            final JsonTypeInfo parentJsonTypeInfo = parentClassWithJsonTypeInfo.getValue2();
            discriminantProperty = getDiscriminantPropertyName(parentJsonTypeInfo);
            syntheticDiscriminantProperty = isDiscriminantPropertySynthetic(parentJsonTypeInfo);
            discriminantLiteral = getTypeName(sourceClass.type);
        } else {
            discriminantProperty = null;
            syntheticDiscriminantProperty = false;
            discriminantLiteral = null;
        }
        if (discriminantProperty != null) {
            final PropertyModel foundDiscriminantProperty = properties.stream()
                    .filter(property -> Objects.equals(property.getName(), discriminantProperty))
                    .findFirst()
                    .orElse(null);
            if (foundDiscriminantProperty != null) {
                if (syntheticDiscriminantProperty) {
                    TypeScriptGenerator.getLogger().warning(String.format(
                            "Class '%s' has duplicate property '%s'. "
                                    + "For more information see 'https:
                            sourceClass.type.getName(), discriminantProperty));
                } else {
                    properties.remove(foundDiscriminantProperty);
                }
            }
        }
        final List<Class<?>> taggedUnionClasses = getSubClassesFromAnnotation(sourceClass.type)
                .or(() -> isTaggedUnionParent ? getSubClassesFromResolver(sourceClass.type) : Optional.empty())
                .orElse(null);
        if (taggedUnionClasses != null) {
            taggedUnionClasses.forEach(subClass -> addBeanToQueue(new SourceType<>(subClass, sourceClass.type, "<subClass>")));
        }
        final Type superclass = sourceClass.type.getGenericSuperclass() == Object.class ? null : sourceClass.type.getGenericSuperclass();
        if (superclass != null) {
            addBeanToQueue(new SourceType<>(superclass, sourceClass.type, "<superClass>"));
        }
        final List<Type> interfaces = Arrays.asList(sourceClass.type.getGenericInterfaces());
        for (Type aInterface : interfaces) {
            addBeanToQueue(new SourceType<>(aInterface, sourceClass.type, "<interface>"));
        }
        return new BeanModel(sourceClass.type, superclass, taggedUnionClasses, discriminantProperty, discriminantLiteral, interfaces, properties, classComments);
    }
    private static Integer getCreatorIndex(BeanProperty beanProperty) {
        if (beanProperty instanceof CreatorProperty) {
            final CreatorProperty creatorProperty = (CreatorProperty) beanProperty;
            return creatorProperty.getCreatorIndex();
        } else {
            return null;
        }
    }
    private Type processIdentity(Type propertyType, BeanProperty beanProperty) {
        final Class<?> clsT = Utils.getRawClassOrNull(propertyType);
        final Class<?> clsW = beanProperty.getType().getRawClass();
        final Class<?> cls = clsT != null ? clsT : clsW;
        if (cls != null) {
            final JsonIdentityInfo identityInfoC = getAnnotationRecursive(cls, JsonIdentityInfo.class).getValue2();
            final JsonIdentityInfo identityInfoP = beanProperty.getAnnotation(JsonIdentityInfo.class);
            final JsonIdentityInfo identityInfo = identityInfoP != null ? identityInfoP : identityInfoC;
            if (identityInfo == null) {
                return null;
            }
            final JsonIdentityReference identityReferenceC = getAnnotationRecursive(cls, JsonIdentityReference.class).getValue2();
            final JsonIdentityReference identityReferenceP = beanProperty.getAnnotation(JsonIdentityReference.class);
            final JsonIdentityReference identityReference = identityReferenceP != null ? identityReferenceP : identityReferenceC;
            final boolean alwaysAsId = identityReference != null && identityReference.alwaysAsId();
            final Type idType;
            if (identityInfo.generator() == ObjectIdGenerators.None.class) {
                return null;
            } else if (identityInfo.generator() == ObjectIdGenerators.PropertyGenerator.class) {
                final BeanHelpers beanHelpers = getBeanHelpers(cls, null);
                if (beanHelpers == null) {
                    return null;
                }
                final List<BeanProperty> properties = beanHelpers.getProperties();
                final Optional<BeanProperty> idPropertyOptional = properties.stream()
                        .filter(p -> p.getName().equals(identityInfo.property()))
                        .findFirst();
                if (idPropertyOptional.isPresent()) {
                    final BeanProperty idProperty = idPropertyOptional.get();
                    final Member idMember = idProperty.getMember().getMember();
                    final PropertyMember idPropertyMember = wrapMember(settings.getTypeParser(), idMember, getCreatorIndex(idProperty), idProperty::getAnnotation, idProperty.getName(), cls);
                    idType = idPropertyMember != null ? idPropertyMember.getType() : Object.class;
                } else {
                    return null;
                }
            } else if (identityInfo.generator() == ObjectIdGenerators.IntSequenceGenerator.class) {
                idType = Integer.class;
            } else if (identityInfo.generator() == ObjectIdGenerators.UUIDGenerator.class) {
                idType = String.class;
            } else if (identityInfo.generator() == ObjectIdGenerators.StringIdGenerator.class) {
                idType = String.class;
            } else {
                idType = Object.class;
            }
            return alwaysAsId
                    ? idType
                    : new JUnionType(propertyType, idType);
        }
        return null;
    }
    private boolean isTaggedUnion(Pair<Class<?>, JsonTypeInfo> classWithJsonTypeInfo) {
        final Class<?> cls = classWithJsonTypeInfo.getValue1();
        final JsonTypeInfo jsonTypeInfo = classWithJsonTypeInfo.getValue2();
        if (cls == null || Utils.hasAnyAnnotation(cls::getAnnotation, settings.disableTaggedUnionAnnotations)) {
            return false;
        }
        return jsonTypeInfo != null &&
                (jsonTypeInfo.include() == JsonTypeInfo.As.PROPERTY || jsonTypeInfo.include() == JsonTypeInfo.As.EXISTING_PROPERTY) &&
                (jsonTypeInfo.use() == JsonTypeInfo.Id.NAME || jsonTypeInfo.use() == JsonTypeInfo.Id.CLASS);
    }
    private boolean isDiscriminantPropertySynthetic(JsonTypeInfo jsonTypeInfo) {
        return jsonTypeInfo.include() == JsonTypeInfo.As.PROPERTY;
    }
    private String getDiscriminantPropertyName(JsonTypeInfo jsonTypeInfo) {
        return jsonTypeInfo.property().isEmpty()
                ? jsonTypeInfo.use().getDefaultPropertyName()
                : jsonTypeInfo.property();
    }
    private String getTypeName(Class<?> cls) {
        try {
            final SerializationConfig config = objectMapper.getSerializationConfig();
            final JavaType javaType = config.constructType(cls);
            final TypeSerializer typeSerializer = objectMapper.getSerializerProviderInstance().findTypeSerializer(javaType);
            final TypeIdResolver typeIdResolver = typeSerializer.getTypeIdResolver();
            if (typeIdResolver.getMechanism() == JsonTypeInfo.Id.NAME) {
                final List<NamedType> subtypes = getSubtypesFromResolver(cls);
                final String typeName = subtypes.stream()
                        .filter(subtype -> Objects.equals(subtype.getType(), cls))
                        .filter(NamedType::hasName)
                        .map(NamedType::getName)
                        .findFirst()
                        .orElse(null);
                if (typeName == null) {
                    return isInterfaceOrAbstract(cls) ? null : typeIdResolver.idFromBaseType();
                } else {
                    return typeName;
                }
            } else {
                return typeIdResolver.idFromBaseType();
            }
        } catch (Exception e) {
            return null;
        }
    }
    private Optional<List<Class<?>>> getSubClassesFromAnnotation(Class<?> cls) {
        return Optional.ofNullable(cls.getAnnotation(JsonSubTypes.class))
                .map(jsonSubTypes -> Arrays.stream(jsonSubTypes.value())
                        .map(jsonSubType -> jsonSubType.value())
                        .collect(Collectors.toList()));
    }
    private Optional<List<Class<?>>> getSubClassesFromResolver(Class<?> cls) {
        final List<NamedType> subtypes = getSubtypesFromResolver(cls);
        final List<Class<?>> subClasses = subtypes.stream()
            .map(subtype -> subtype.getType())
            .filter(subClass -> !Objects.equals(subClass, cls))
            .collect(Collectors.toList());
        return subClasses.isEmpty() ? Optional.empty() : Optional.of(subClasses);
    }
    private List<NamedType> getSubtypesFromResolver(Class<?> cls) {
        final SerializationConfig config = objectMapper.getSerializationConfig();
        final SubtypeResolver subtypeResolver = config.getSubtypeResolver();
        final BeanDescription beanDescription = config.introspectClassAnnotations(cls);
        final AnnotatedClass annotatedClass = beanDescription.getClassInfo();
        final Collection<NamedType> deserializationSubtypes = subtypeResolver.collectAndResolveSubtypesByTypeId(config, annotatedClass);
        final Collection<NamedType> serializationSubtypes = subtypeResolver.collectAndResolveSubtypesByClass(config, annotatedClass);
        final LinkedHashSet<NamedType> subtypes = Stream
                .concat(deserializationSubtypes.stream(), serializationSubtypes.stream())
                .filter(namedType -> cls.isAssignableFrom(namedType.getType()))  
                .collect(Collectors.toCollection(LinkedHashSet::new));
        return new ArrayList<>(subtypes);
    }
    private boolean isInterfaceOrAbstract(Class<?> cls) {
        return cls.isInterface() || Modifier.isAbstract(cls.getModifiers());
    }
    private static <T extends Annotation> Pair<Class<?>, T> getAnnotationRecursive(Class<?> cls, Class<T> annotationClass) {
        return getAnnotationRecursive(cls, annotationClass, null);
    }
    private static <T extends Annotation> Pair<Class<?>, T> getAnnotationRecursive(Class<?> cls, Class<T> annotationClass, Predicate<T> annotationFilter) {
        if (cls == null) {
            return Pair.of(null, null);
        }
        final T annotation = cls.getAnnotation(annotationClass);
        if (annotation != null && (annotationFilter == null || annotationFilter.test(annotation))) {
            return Pair.of(cls, annotation);
        }
        for (Class<?> aInterface : cls.getInterfaces()) {
            final Pair<Class<?>, T> classWithAnnotation = getAnnotationRecursive(aInterface, annotationClass, annotationFilter);
            if (classWithAnnotation.getValue2() != null) {
                return classWithAnnotation;
            }
        }
        final Pair<Class<?>, T> classWithAnnotation = getAnnotationRecursive(cls.getSuperclass(), annotationClass, annotationFilter);
        if (classWithAnnotation.getValue2() != null) {
            return classWithAnnotation;
        }
        return Pair.of(null, null);
    }
    private BeanHelpers getBeanHelpers(Class<?> beanClass, Class<?> view) {
        if (beanClass == null) {
            return null;
        }
        if (beanClass == Enum.class) {
            return null;
        }
        final JavaType javaType = objectMapper.constructType(beanClass);
        final BeanSerializerHelper beanSerializerHelper = createBeanSerializerHelper(javaType);
        final BeanDeserializerHelper beanDeserializerHelper = createBeanDeserializerHelper(javaType);
        if (beanSerializerHelper != null || beanDeserializerHelper != null) {
            return new BeanHelpers(beanClass, view, beanSerializerHelper, beanDeserializerHelper);
        }
        return null;
    }
    private BeanSerializerHelper createBeanSerializerHelper(JavaType javaType) {
        try {
            final DefaultSerializerProvider.Impl serializerProvider = new DefaultSerializerProvider.Impl()
                    .createInstance(objectMapper.getSerializationConfig(), objectMapper.getSerializerFactory());
            final JsonSerializer<?> jsonSerializer = BeanSerializerFactory.instance.createSerializer(serializerProvider, javaType);
            if (jsonSerializer != null && jsonSerializer instanceof BeanSerializer) {
                return new BeanSerializerHelper((BeanSerializer) jsonSerializer);
            } else {
                return null;
            }
        } catch (Exception e) {
            return null;
        }
    }
    private BeanDeserializerHelper createBeanDeserializerHelper(JavaType javaType) {
        try {
            final DeserializationContext deserializationContext = new DefaultDeserializationContext.Impl(objectMapper.getDeserializationContext().getFactory())
                    .createInstance(objectMapper.getDeserializationConfig(), null, null);
            final BeanDescription beanDescription = deserializationContext.getConfig().introspect(javaType);
            final JsonDeserializer<?> jsonDeserializer = BeanDeserializerFactory.instance.createBeanDeserializer(deserializationContext, javaType, beanDescription);
            if (jsonDeserializer != null && jsonDeserializer instanceof BeanDeserializer) {
                return new BeanDeserializerHelper((BeanDeserializer) jsonDeserializer);
            } else {
                return null;
            }
        } catch (Exception e) {
            return null;
        }
    }
    protected List<BeanProperty> getBeanProperties(Class<?> beanClass) {
        return getBeanHelpers(beanClass, null).getProperties();
    }
    private static class BeanHelpers {
        public final Class<?> beanClass;
        public final Class<?> view;
        public final BeanSerializerHelper serializer;
        public final BeanDeserializerHelper deserializer;
        public BeanHelpers(Class<?> beanClass, Class<?> view, BeanSerializerHelper serializer, BeanDeserializerHelper deserializer) {
            this.beanClass = beanClass;
            this.view = view;
            this.serializer = serializer;
            this.deserializer = deserializer;
        }
        public List<BeanProperty> getProperties() {
            return getPropertiesAndAccess().stream()
                    .map(Pair::getValue1)
                    .collect(Collectors.toList());
        }
        public List<Pair<BeanProperty, PropertyAccess>> getPropertiesAndAccess() {
            return getPropertiesPairs().stream()
                    .map(pair -> pair.getValue1() != null
                            ? Pair.of(pair.getValue1(), pair.getValue2() != null ? PropertyAccess.ReadWrite : PropertyAccess.ReadOnly)
                            : Pair.of(pair.getValue2(), PropertyAccess.WriteOnly)
                    )
                    .collect(Collectors.toList());
        }
        private List<Pair<BeanProperty, BeanProperty>> getPropertiesPairs() {
            final List<BeanProperty> serializableProperties = getSerializableProperties();
            final List<BeanProperty> deserializableProperties = getDeserializableProperties();
            final List<Pair<BeanProperty, BeanProperty>> properties = Stream
                    .concat(
                            serializableProperties.stream()
                                    .filter(this::inView)
                                    .map(property -> Pair.of(property, getBeanProperty(deserializableProperties, property.getName()))),
                            deserializableProperties.stream()
                                    .filter(this::inView)
                                    .filter(property -> getBeanProperty(serializableProperties, property.getName()) == null)
                                    .map(property -> Pair.of((BeanProperty) null, property))
                    )
                    .collect(Collectors.toCollection(ArrayList::new));
            final Comparator<Pair<BeanProperty, BeanProperty>> bySerializationOrder = (pair1, pair2) ->
                    pair1.getValue1() != null && pair2.getValue1() != null
                            ? Integer.compare(
                                    serializableProperties.indexOf(pair1.getValue1()),
                                    serializableProperties.indexOf(pair2.getValue1()))
                            : 0;
            final Comparator<Pair<BeanProperty, BeanProperty>> byIndex = Comparator.comparing(
                    pair -> getIndex(pair),
                    Comparator.nullsLast(Comparator.naturalOrder()));
            final List<Field> fields = Utils.getAllFields(beanClass);
            final Comparator<Pair<BeanProperty, BeanProperty>> byFieldIndex = Comparator.comparing(
                    pair -> getFieldIndex(fields, pair),
                    Comparator.nullsLast(Comparator.naturalOrder()));
            properties.sort(bySerializationOrder
                    .thenComparing(byIndex)
                    .thenComparing(byFieldIndex));
            return properties;
        }
        private boolean inView(BeanProperty beanProperty) {
            if (view == null) {
                return true;
            }
            final JsonView annotation = beanProperty.getAnnotation(JsonView.class);
            if (annotation == null || annotation.value().length == 0) {
                return true;
            }
            return Stream.of(annotation.value())
                    .anyMatch(v -> v.isAssignableFrom(view));
        }
        private static BeanProperty getBeanProperty(List<BeanProperty> properties, String name) {
            return properties.stream()
                    .filter(dp -> Objects.equals(dp.getName(), name))
                    .findFirst()
                    .orElse(null);
        }
        private static Integer getIndex(Pair<BeanProperty, BeanProperty> pair) {
            final Integer index1 = getIndex(pair.getValue1());
            return index1 != null ? index1 : getIndex(pair.getValue2());
        }
        private static Integer getIndex(BeanProperty property) {
            if (property == null) {
                return null;
            }
            return property.getMetadata().getIndex();
        }
        private static Integer getFieldIndex(List<Field> fields, Pair<BeanProperty, BeanProperty> pair) {
            final Integer fieldIndex1 = getFieldIndex(fields, pair.getValue1());
            return fieldIndex1 != null ? fieldIndex1 : getFieldIndex(fields, pair.getValue2());
        }
        private static Integer getFieldIndex(List<Field> fields, BeanProperty property) {
            if (property == null) {
                return null;
            }
            final int index = fields.indexOf(property.getMember().getMember());
            return index != -1 ? index : null;
        }
        private List<BeanProperty> getSerializableProperties() {
            return serializer != null
                    ? Arrays.asList(serializer.getProps())
                    : Collections.emptyList();
        }
        private List<BeanProperty> getDeserializableProperties() {
            return deserializer != null
                    ? Arrays.asList(deserializer.getBeanProperties().getPropertiesInInsertionOrder())
                    : Collections.emptyList();
        }
    }
    private static class BeanSerializerHelper extends BeanSerializer {
        private static final long serialVersionUID = 1;
        public BeanSerializerHelper(BeanSerializer src) {
            super(src);
        }
        public BeanPropertyWriter[] getProps() {
            return _props;
        }
    }
    private static class BeanDeserializerHelper extends BeanDeserializer {
        private static final long serialVersionUID = 1;
        public BeanDeserializerHelper(BeanDeserializer src) {
            super(src);
        }
        public BeanPropertyMap getBeanProperties() {
            return _beanProperties;
        }
    }
    private DeclarationModel parseEnumOrObjectEnum(SourceType<Class<?>> sourceClass, List<String> classComments) {
        final JsonFormat jsonFormat = sourceClass.type.getAnnotation(JsonFormat.class);
        if (jsonFormat != null && jsonFormat.shape() == JsonFormat.Shape.OBJECT) {
            return parseBean(sourceClass, classComments);
        }
        final boolean isNumberBased = jsonFormat != null && (
                jsonFormat.shape() == JsonFormat.Shape.NUMBER ||
                jsonFormat.shape() == JsonFormat.Shape.NUMBER_FLOAT ||
                jsonFormat.shape() == JsonFormat.Shape.NUMBER_INT);
        final List<EnumMemberModel> enumMembers = new ArrayList<>();
        if (sourceClass.type.isEnum()) {
            @SuppressWarnings("unchecked")
            final Class<Enum<?>> enumClass = (Class<Enum<?>>) sourceClass.type;
            final List<Field> constants = Arrays.stream(enumClass.getEnumConstants()).map(e -> {
                try {
                    return enumClass.getDeclaredField(e.name());
                } catch (NoSuchFieldException noSuchFieldException) {
                    throw new RuntimeException(noSuchFieldException);
                }
            }).collect(Collectors.toList());
            for (Field constant : constants) {
                Object value;
                try {
                    constant.setAccessible(true);
                    final String enumJson = objectMapper.writeValueAsString(constant.get(null));
                    value = objectMapper.readValue(enumJson, new TypeReference<Object>(){});
                } catch (Throwable e) {
                    TypeScriptGenerator.getLogger().error(String.format("Cannot get enum value for constant '%s.%s'", enumClass.getName(), constant.getName()));
                    TypeScriptGenerator.getLogger().verbose(Utils.exceptionToString(e));
                    value = constant.getName();
                }
                final List<String> constantComments = getComments(constant.getAnnotation(JsonPropertyDescription.class));
                if (value instanceof String) {
                    enumMembers.add(new EnumMemberModel(constant.getName(), (String) value, constant, constantComments));
                } else if (value instanceof Number) {
                    enumMembers.add(new EnumMemberModel(constant.getName(), (Number) value, constant, constantComments));
                } else {
                    TypeScriptGenerator.getLogger().warning(String.format("'%s' enum as a @JsonValue that isn't a String or Number, ignoring", enumClass.getName()));
                }
            }
        }
        return new EnumModel(sourceClass.type, isNumberBased ? EnumKind.NumberBased : EnumKind.StringBased, enumMembers, classComments);
    }
    private static List<String> getComments(JsonClassDescription classDescriptionAnnotation) {
        final String propertyDescriptionValue = classDescriptionAnnotation != null ? classDescriptionAnnotation.value() : null;
        final List<String> classComments = Utils.splitMultiline(propertyDescriptionValue, false);
        return classComments;
    }
    private static List<String> getComments(JsonPropertyDescription propertyDescriptionAnnotation) {
        final String propertyDescriptionValue = propertyDescriptionAnnotation != null ? propertyDescriptionAnnotation.value() : null;
        final List<String> propertyComments = Utils.splitMultiline(propertyDescriptionValue, false);
        return propertyComments;
    }
}
package cz.habarta.typescript.generator.parser;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.compiler.EnumMemberModel;
import cz.habarta.typescript.generator.util.Utils;
import cz.habarta.typescript.generator.xmldoclet.Class;
import cz.habarta.typescript.generator.xmldoclet.Enum;
import cz.habarta.typescript.generator.xmldoclet.EnumConstant;
import cz.habarta.typescript.generator.xmldoclet.Field;
import cz.habarta.typescript.generator.xmldoclet.Interface;
import cz.habarta.typescript.generator.xmldoclet.Method;
import cz.habarta.typescript.generator.xmldoclet.Package;
import cz.habarta.typescript.generator.xmldoclet.Root;
import cz.habarta.typescript.generator.xmldoclet.TagInfo;
import jakarta.xml.bind.JAXB;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
public class Javadoc {
    private final String newline;
    private final List<Root> dRoots;
    public Javadoc(Settings settings) {
        Objects.requireNonNull(settings, "settings");
        this.newline = settings.newline;
        this.dRoots = loadJavadocXmlFiles(settings.javadocXmlFiles);
    }
    private static List<Root> loadJavadocXmlFiles(List<File> javadocXmlFiles) {
        final List<Root> dRoots = new ArrayList<>();
        if (javadocXmlFiles != null) {
            for (File file : javadocXmlFiles) {
                TypeScriptGenerator.getLogger().info("Loading Javadoc XML file: " + file);
                final Root dRoot = JAXB.unmarshal(file, Root.class);
                dRoots.add(dRoot);
            }
        }
        return dRoots;
    }
    public Model enrichModel(Model model) {
        final List<BeanModel> dBeans = new ArrayList<>();
        for (BeanModel bean : model.getBeans()) {
            final BeanModel dBean = enrichBean(bean);
            dBeans.add(dBean);
        }
        final List<EnumModel> dEnums = new ArrayList<>();
        for (EnumModel enumModel : model.getEnums()) {
            final EnumModel dEnumModel = enrichEnum(enumModel);
            dEnums.add(dEnumModel);
        }
        final List<RestApplicationModel> dRestApplications = new ArrayList<>();
        for (RestApplicationModel restApplication : model.getRestApplications()) {
            final RestApplicationModel dRestApplication = enrichRestApplication(restApplication);
            dRestApplications.add(dRestApplication);
        }
        return new Model(dBeans, dEnums, dRestApplications);
    }
    private BeanModel enrichBean(BeanModel bean) {
        if (bean.getOrigin().isInterface()) {
            final Interface dInterface = findJavadocInterface(bean.getOrigin(), dRoots);
            if (dInterface != null) {
                return enrichBean(bean, dInterface.getComment(), dInterface.getTag(), dInterface.getField(), dInterface.getMethod());
            }
        } else {
            final Class dClass = findJavadocClass(bean.getOrigin(), dRoots);
            if (dClass != null) {
                return enrichBean(bean, dClass.getComment(), dClass.getTag(), dClass.getField(), dClass.getMethod());
            }
        }
        return bean;
    }
    private BeanModel enrichBean(BeanModel bean, String beanComment, List<TagInfo> tags, List<Field> dFields, List<Method> dMethods) {
        final List<PropertyModel> enrichedProperties = new ArrayList<>();
        for (PropertyModel property : bean.getProperties()) {
            final PropertyModel enrichedProperty = enrichProperty(property, dFields, dMethods);
            enrichedProperties.add(enrichedProperty);
        }
        return bean
                .withProperties(enrichedProperties)
                .withComments(combineComments(getComments(beanComment, tags), bean.getComments()));
    }
    private PropertyModel enrichProperty(PropertyModel property, List<Field> dFields, List<Method> dMethods) {
        String propertyComment = null;
        List<TagInfo> tags = null;
        if (property.getOriginalMember() instanceof java.lang.reflect.Method) {
            final java.lang.reflect.Method method = (java.lang.reflect.Method) property.getOriginalMember();
            final Method dMethod = findJavadocMethod(method.getName(), dMethods);
            propertyComment = dMethod != null ? dMethod.getComment() : null;
            tags = dMethod != null ? dMethod.getTag() : null;
        } else if (property.getOriginalMember() instanceof java.lang.reflect.Field) {
            final java.lang.reflect.Field field = (java.lang.reflect.Field) property.getOriginalMember();
            final Field dField = findJavadocField(field.getName(), dFields);
            propertyComment = dField != null ? dField.getComment() : null;
            tags = dField != null ? dField.getTag() : null;
        } 
        if (propertyComment == null )  {
            final Field dField = findJavadocField(property.getName(), dFields);
            propertyComment = dField != null ? dField.getComment() : null;
            tags = dField != null ? dField.getTag() : null;
        }
        return property
                .withComments(combineComments(getComments(propertyComment, tags), property.getComments()));
    }
    private EnumModel enrichEnum(EnumModel enumModel) {
        final Enum dEnum = findJavadocEnum(enumModel.getOrigin(), dRoots);
        final List<EnumMemberModel> enrichedMembers = new ArrayList<>();
        for (EnumMemberModel member : enumModel.getMembers()) {
            final EnumMemberModel enrichedMember = enrichEnumMember(member, dEnum);
            enrichedMembers.add(enrichedMember);
        }
        final String enumComment = dEnum != null ? dEnum.getComment() : null;
        final List<TagInfo> tags = dEnum != null ? dEnum.getTag() : null;
        return enumModel
                .withMembers(enrichedMembers)
                .withComments(combineComments(getComments(enumComment, tags), enumModel.getComments()));
    }
    private EnumMemberModel enrichEnumMember(EnumMemberModel enumMember, Enum dEnum) {
        final EnumConstant dConstant = findJavadocEnumConstant(enumMember.getPropertyName(), dEnum);
        final List<TagInfo> tags = dConstant != null ? dConstant.getTag(): null;
        final String memberComment = dConstant != null ? dConstant.getComment() : null;
        return enumMember
                .withComments(combineComments(getComments(memberComment, tags), enumMember.getComments()));
    }
    private RestApplicationModel enrichRestApplication(RestApplicationModel restApplicationModel) {
        final List<RestMethodModel> enrichedRestMethods = new ArrayList<>();
        for (RestMethodModel restMethod : restApplicationModel.getMethods()) {
            final RestMethodModel enrichedRestMethod = enrichRestMethod(restMethod);
            enrichedRestMethods.add(enrichedRestMethod);
        }
        return restApplicationModel.withMethods(enrichedRestMethods);
    }
    private RestMethodModel enrichRestMethod(RestMethodModel method) {
        final Method dMethod = findJavadocMethod(method.getOriginClass(), method.getName(), dRoots);
        final String comment = dMethod != null ? dMethod.getComment() : null;
        final List<TagInfo> tags = dMethod != null ? dMethod.getTag() : null;
        return method
                .withComments(combineComments(getComments(comment, tags), method.getComments()));
    }
    private static Method findJavadocMethod(java.lang.Class<?> cls, String name, List<Root> dRoots) {
        final Class dClass = findJavadocClass(cls, dRoots);
        final Interface dInterface = findJavadocInterface(cls, dRoots);
        if (dClass != null) {
            return findJavadocMethod(name, dClass.getMethod());
        } else if (dInterface != null) {
            return findJavadocMethod(name, dInterface.getMethod());
        } else {
            return null;
        }
    }
    private static Class findJavadocClass(java.lang.Class<?> cls, List<Root> dRoots) {
        final String name = cls.getName().replace('$', '.');
        for (Root dRoot : dRoots) {
            for (Package dPackage : dRoot.getPackage()) {
                for (Class dClass : dPackage.getClazz()) {
                    if (dClass.getQualified().equals(name)) {
                        return dClass;
                    }
                }
            }
        }
        return null;
    }
    private static Interface findJavadocInterface(java.lang.Class<?> cls, List<Root> dRoots) {
        final String name = cls.getName().replace('$', '.');
        for (Root dRoot : dRoots) {
            for (Package dPackage : dRoot.getPackage()) {
                for (Interface dInterface : dPackage.getInterface()) {
                    if (dInterface.getQualified().equals(name)) {
                        return dInterface;
                    }
                }
            }
        }
        return null;
    }
    private static Field findJavadocField(String name, List<Field> dFields) {
        if (dFields != null) {
            for (Field dField : dFields) {
                if (dField.getName().equals(name)) {
                    return dField;
                }
            }
        }
        return null;
    }
    private static Method findJavadocMethod(String name, List<Method> dMethods) {
        if (dMethods != null) {
            for (Method dMethod : dMethods) {
                if (dMethod.getName().equals(name)) {
                    return dMethod;
                }
            }
        }
        return null;
    }
    private static Enum findJavadocEnum(java.lang.Class<?> cls, List<Root> dRoots) {
        final String name = cls.getName().replace('$', '.');
        for (Root dRoot : dRoots) {
            for (Package dPackage : dRoot.getPackage()) {
                for (Enum dEnum : dPackage.getEnum()) {
                    if (dEnum.getQualified().equals(name)) {
                        return dEnum;
                    }
                }
            }
        }
        return null;
    }
    private static EnumConstant findJavadocEnumConstant(String name, Enum dEnum) {
        if (dEnum != null) {
            for (EnumConstant dEnumConstant : dEnum.getConstant()) {
                if (dEnumConstant.getName().equals(name)) {
                    return dEnumConstant;
                }
            }
        }
        return null;
    }
    private List<String> getComments(String dComments, List<TagInfo> tags) {
        if (dComments == null && (tags == null || tags.isEmpty())) {
            return null;
        }
        final List<String> result = new ArrayList<>();
        if (dComments != null) {
            final String nn = newline + newline;
            final String replacedHtmlLines = dComments
                    .replaceAll("\\s*<br>\\s*", nn)
                    .replaceAll("\\s*<br/>\\s*", nn)
                    .replaceAll("\\s*<br />\\s*", nn)
                    .replaceAll("\\s*<p>\\s*", nn)
                    .replaceAll("\\s*</p>\\s*", nn);
            result.addAll(Utils.splitMultiline(replacedHtmlLines, true));
        }
        if (tags != null) {
            for (TagInfo tag : tags) {
                result.addAll(Utils.splitMultiline(tag.getName() + " " + tag.getText(), true));
            }
        }
        return result;
    }
    private static List<String> combineComments(List<String> firstComments, List<String> secondComments) {
        return Utils.concat(firstComments, secondComments);
    }
}
package cz.habarta.typescript.generator;
import com.fasterxml.jackson.databind.ObjectMapper;
import cz.habarta.typescript.generator.emitter.InfoJson;
import cz.habarta.typescript.generator.util.Pair;
import cz.habarta.typescript.generator.util.Utils;
import java.io.IOException;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
public class LoadedModuleDependencies {
    private final Map<String, Pair<ModuleDependency, String>> classMappings = new LinkedHashMap<>();
    public LoadedModuleDependencies(Settings settings, List<ModuleDependency> dependencies) {
        if (dependencies == null) {
            return;
        }
        final ObjectMapper objectMapper = Utils.getObjectMapper();
        final Map<String, ModuleDependency> importFromMap = new LinkedHashMap<>();
        final Map<String, ModuleDependency> importAsMap = new LinkedHashMap<>();
        final Map<String, ModuleDependency> globalTypeNames = new LinkedHashMap<>();
        for (ModuleDependency dependency : dependencies) {
            try {
                final Function<String, String> reportNullParameter = parameterName ->
                        String.format("Missing required configuration parameter '%s' in module dependency: %s", parameterName, dependency);
                if (dependency.global) {
                    if (dependency.importFrom != null) {
                        throw new RuntimeException(String.format(
                                "'importFrom' parameter is only applicable when 'global' is not set to 'true' (at module dependency %s).", dependency));
                    }
                    if (dependency.importAs != null) {
                        throw new RuntimeException(String.format(
                                "'importAs' parameter is only applicable when 'global' is not set to 'true' (at module dependency %s).", dependency));
                    }
                } else {
                    Objects.requireNonNull(dependency.importFrom, () -> reportNullParameter.apply("importFrom"));
                    Objects.requireNonNull(dependency.importAs, () -> reportNullParameter.apply("importAs"));
                }
                Objects.requireNonNull(dependency.infoJson, () -> reportNullParameter.apply("infoJson"));
                if (settings.generateNpmPackageJson) {
                    Objects.requireNonNull(dependency.npmPackageName, () -> reportNullParameter.apply("npmPackageName"));
                    Objects.requireNonNull(dependency.npmVersionRange, () -> reportNullParameter.apply("npmVersionRange"));
                } else {
                    if (dependency.npmPackageName != null) {
                        throw new RuntimeException(String.format(
                                "'npmPackageName' parameter is only applicable when 'generateNpmPackageJson' is set to 'true' (at module dependency %s).", dependency));
                    }
                    if (dependency.npmVersionRange != null) {
                        throw new RuntimeException(String.format(
                                "'npmVersionRange' parameter is only applicable when 'generateNpmPackageJson' is set to 'true' (at module dependency %s).", dependency));
                    }
                }
                TypeScriptGenerator.getLogger().info(String.format(
                        "Loading %s module info from: %s", dependency.toShortString(), dependency.infoJson));
                if (!dependency.global) {
                    final ModuleDependency importFromConflict = importFromMap.put(dependency.importFrom, dependency);
                    if (importFromConflict != null) {
                        throw new RuntimeException(String.format("Duplicate module '%s'", dependency.importFrom));
                    }
                    final ModuleDependency importAsConflict = importAsMap.put(dependency.importAs, dependency);
                    if (importAsConflict != null) {
                        throw new RuntimeException(String.format("Import identifier '%s' already used for module '%s'", dependency.importAs, importAsConflict.importFrom));
                    }
                }
                final InfoJson infoJson = objectMapper.readValue(dependency.infoJson, InfoJson.class);
                for (InfoJson.ClassInfo classInfo : infoJson.classes) {
                    final Pair<ModuleDependency, String> presentMapping = classMappings.get(classInfo.javaClass);
                    if (presentMapping != null) {
                        TypeScriptGenerator.getLogger().warning(String.format(
                                "Java class '%s' already present in '%s'", classInfo.javaClass, presentMapping.getValue1().infoJson));
                    } else {
                        classMappings.put(classInfo.javaClass, Pair.of(dependency, classInfo.typeName));
                    }
                    final ModuleDependency presentTypeName = globalTypeNames.get(classInfo.typeName);
                    if (presentTypeName != null) {
                        throw new RuntimeException(String.format(
                                "Duplicate TypeScript global name '%s', declared in '%s' and also '%s'", classInfo.typeName, presentTypeName.infoJson, dependency.infoJson));
                    } else {
                        globalTypeNames.put(classInfo.typeName, dependency);
                    }
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
    public Pair<String, String> getFullName(Class<?> cls) {
        final Pair<ModuleDependency, String> mapping = classMappings.get(cls.getName());
        if (mapping != null) {
            return Pair.of(mapping.getValue1().importAs, mapping.getValue2());
        }
        return null;
    }
}
package cz.habarta.typescript.generator.parser;
import cz.habarta.typescript.generator.JaxrsApplicationScanner;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TsType;
import cz.habarta.typescript.generator.TypeProcessor;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.type.JTypeWithNullability;
import cz.habarta.typescript.generator.util.GenericsResolver;
import cz.habarta.typescript.generator.util.Pair;
import cz.habarta.typescript.generator.util.Utils;
import jakarta.ws.rs.ApplicationPath;
import jakarta.ws.rs.BeanParam;
import jakarta.ws.rs.CookieParam;
import jakarta.ws.rs.FormParam;
import jakarta.ws.rs.HeaderParam;
import jakarta.ws.rs.HttpMethod;
import jakarta.ws.rs.MatrixParam;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.PathParam;
import jakarta.ws.rs.QueryParam;
import jakarta.ws.rs.container.Suspended;
import jakarta.ws.rs.core.Application;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.GenericEntity;
import jakarta.ws.rs.core.MultivaluedMap;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.StreamingOutput;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.annotation.Annotation;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.Stream;
public class JaxrsApplicationParser extends RestApplicationParser {
    public static class Factory extends RestApplicationParser.Factory {
        @Override
        public TypeProcessor getSpecificTypeProcessor() {
            return (javaType, context) -> {
                final Class<?> rawClass = Utils.getRawClassOrNull(javaType);
                if (rawClass != null) {
                    for (Map.Entry<Class<?>, TsType> entry : getStandardEntityClassesMapping().entrySet()) {
                        final Class<?> cls = entry.getKey();
                        final TsType type = entry.getValue();
                        if (cls.isAssignableFrom(rawClass)) {
                            return type != null ? new TypeProcessor.Result(type) : null;
                        }
                    }
                    if (getDefaultExcludedClassNames().contains(rawClass.getName())) {
                        return new TypeProcessor.Result(TsType.Any);
                    }
                }
                return null;
            };
        }
        @Override
        public JaxrsApplicationParser create(Settings settings, TypeProcessor commonTypeProcessor) {
            return new JaxrsApplicationParser(settings, commonTypeProcessor);
        }
    };
    public JaxrsApplicationParser(Settings settings, TypeProcessor commonTypeProcessor) {
        super(settings, commonTypeProcessor, new RestApplicationModel(RestApplicationType.Jaxrs));
    }
    @Override
    public Result tryParse(SourceType<?> sourceType) {
        if (!(sourceType.type instanceof Class<?>)) {
            return null;
        }
        final Class<?> cls = (Class<?>) sourceType.type;
        if (Application.class.isAssignableFrom(cls) || javax(Application.class).isAssignableFrom(cls)) {
            final ApplicationPath applicationPathAnnotation = getRsAnnotation(cls, ApplicationPath.class);
            if (applicationPathAnnotation != null) {
                model.setApplicationPath(applicationPathAnnotation.value());
            }
            model.setApplicationName(cls.getSimpleName());
            final List<SourceType<Type>> discoveredTypes = JaxrsApplicationScanner.scanJaxrsApplication(cls, isClassNameExcluded);
            return new Result(discoveredTypes);
        }
        final Path path = getRsAnnotation(cls, Path.class);
        if (path != null) {
            TypeScriptGenerator.getLogger().verbose("Parsing JAX-RS resource: " + cls.getName());
            final Result result = new Result();
            parseResource(result, new ResourceContext(cls, path.value()), cls);
            return result;
        }
        return null;
    }
    private void parseResource(Result result, ResourceContext context, Class<?> resourceClass) {
        final Map<String, Type> pathParamTypes = new LinkedHashMap<>();
        for (Field field : resourceClass.getDeclaredFields()) {
            final PathParam pathParamAnnotation = getRsAnnotation(field, PathParam.class);
            if (pathParamAnnotation != null) {
                pathParamTypes.put(pathParamAnnotation.value(), field.getType());
            }
        }
        final ResourceContext subContext = context.subPathParamTypes(pathParamTypes);
        final List<Method> methods = Arrays.asList(resourceClass.getMethods());
        Collections.sort(methods, Utils.methodComparator());
        for (Method method : methods) {
            parseResourceMethod(result, subContext, resourceClass, method);
        }
    }
    private void parseResourceMethod(Result result, ResourceContext context, Class<?> resourceClass, Method method) {
        final Path pathAnnotation = getRsAnnotation(method, Path.class);
        context = context.subPath(pathAnnotation != null ? pathAnnotation.value() : null);
        final Map<String, Type> pathParamTypes = new LinkedHashMap<>();
        for (Parameter parameter : method.getParameters()) {
            final PathParam pathParamAnnotation = getRsAnnotation(parameter, PathParam.class);
            if (pathParamAnnotation != null) {
                pathParamTypes.put(pathParamAnnotation.value(), parameter.getParameterizedType());
            }
        }
        context = context.subPathParamTypes(pathParamTypes);
        final HttpMethod httpMethod = getHttpMethod(method);
        if (httpMethod != null) {
            final SwaggerOperation swaggerOperation = settings.ignoreSwaggerAnnotations
                    ? new SwaggerOperation()
                    : Swagger.parseSwaggerAnnotations(method);
            if (swaggerOperation.possibleResponses != null) {
                for (SwaggerResponse response : swaggerOperation.possibleResponses) {
                    if (response.responseType != null) {
                        foundType(result, response.responseType, resourceClass, method.getName());
                    }
                }
            }
            if (swaggerOperation.hidden) {
                return;
            }
            final List<MethodParameterModel> pathParams = new ArrayList<>();
            final PathTemplate pathTemplate = PathTemplate.parse(context.path);
            for (PathTemplate.Part part : pathTemplate.getParts()) {
                if (part instanceof PathTemplate.Parameter) {
                    final PathTemplate.Parameter parameter = (PathTemplate.Parameter) part;
                    final Type type = context.pathParamTypes.get(parameter.getOriginalName());
                    final Type paramType = type != null ? type : String.class;
                    final Type resolvedParamType = GenericsResolver.resolveType(resourceClass, paramType, method.getDeclaringClass());
                    pathParams.add(new MethodParameterModel(parameter.getValidName(), resolvedParamType));
                    foundType(result, resolvedParamType, resourceClass, method.getName());
                }
            }
            final List<RestQueryParam> queryParams = new ArrayList<>();
            for (Parameter param : method.getParameters()) {
                final QueryParam queryParamAnnotation = getRsAnnotation(param, QueryParam.class);
                if (queryParamAnnotation != null) {
                    queryParams.add(new RestQueryParam.Single(new MethodParameterModel(queryParamAnnotation.value(), param.getParameterizedType()), false));
                    foundType(result, param.getParameterizedType(), resourceClass, method.getName());
                }
                final BeanParam beanParamAnnotation = getRsAnnotation(param, BeanParam.class);
                if (beanParamAnnotation != null) {
                    final Class<?> beanParamClass = param.getType();
                    final BeanModel paramBean = getQueryParameters(beanParamClass);
                    if (paramBean != null) {
                        queryParams.add(new RestQueryParam.Bean(paramBean));
                        for (PropertyModel property : paramBean.getProperties()) {
                            foundType(result, property.getType(), beanParamClass, property.getName());
                        }
                    }
                }
            }
            final List<Type> parameterTypes = settings.getTypeParser().getMethodParameterTypes(method);
            final List<Pair<Parameter, Type>> parameters = Utils.zip(Arrays.asList(method.getParameters()), parameterTypes);
            final MethodParameterModel entityParameter = getEntityParameter(resourceClass, method, parameters);
            if (entityParameter != null) {
                foundType(result, entityParameter.getType(), resourceClass, method.getName());
            }
            final Class<?> returnType = method.getReturnType();
            final Type parsedReturnType = settings.getTypeParser().getMethodReturnType(method);
            final Type plainReturnType = JTypeWithNullability.getPlainType(parsedReturnType);
            final Type modelReturnType;
            if (returnType == void.class) {
                if (hasAnyAnnotation(method.getParameters(), Arrays.asList(Suspended.class, javax(Suspended.class)))) {
                    if (swaggerOperation.responseType != null) {
                        modelReturnType = swaggerOperation.responseType;
                    } else {
                        modelReturnType = Object.class;
                    }
                } else {
                    modelReturnType = returnType;
                }
            } else if (returnType == Response.class || returnType == javax(Response.class)) {
                if (swaggerOperation.responseType != null) {
                    modelReturnType = swaggerOperation.responseType;
                } else {
                    modelReturnType = Object.class;
                }
            } else if (plainReturnType instanceof ParameterizedType && (returnType == GenericEntity.class || returnType == javax(GenericEntity.class))) {
                final ParameterizedType parameterizedReturnType = (ParameterizedType) plainReturnType;
                modelReturnType = parameterizedReturnType.getActualTypeArguments()[0];
            } else {
                modelReturnType = parsedReturnType;
            }
            final Type resolvedModelReturnType = GenericsResolver.resolveType(resourceClass, modelReturnType, method.getDeclaringClass());
            foundType(result, resolvedModelReturnType, resourceClass, method.getName());
            final List<String> comments = Swagger.getOperationComments(swaggerOperation);
            model.getMethods().add(new RestMethodModel(resourceClass, method.getName(), resolvedModelReturnType, method,
                    context.rootResource, httpMethod.value(), context.path, pathParams, queryParams, entityParameter, comments));
        }
        if (pathAnnotation != null && httpMethod == null) {
            parseResource(result, context, method.getReturnType());
        }
    }
    private static HttpMethod getHttpMethod(Method method) {
        for (Annotation annotation : method.getAnnotations()) {
            final HttpMethod httpMethodAnnotation = getRsAnnotation(annotation.annotationType(), HttpMethod.class);
            if (httpMethodAnnotation != null) {
                return httpMethodAnnotation;
            }
        }
        return null;
    }
    private static BeanModel getQueryParameters(Class<?> paramBean) {
        final List<PropertyModel> properties = new ArrayList<>();
        final List<Field> fields = Utils.getAllFields(paramBean);
        for (Field field : fields) {
            final QueryParam annotation = getRsAnnotation(field, QueryParam.class);
            if (annotation != null) {
                properties.add(new PropertyModel(annotation.value(), field.getGenericType(), true, null, field, null, null, null));
            }
        }
        try {
            final BeanInfo beanInfo = Introspector.getBeanInfo(paramBean);
            for (PropertyDescriptor propertyDescriptor : beanInfo.getPropertyDescriptors()) {
                final Method writeMethod = propertyDescriptor.getWriteMethod();
                if (writeMethod != null) {
                    final QueryParam annotation = getRsAnnotation(writeMethod, QueryParam.class);
                    if (annotation != null) {
                        properties.add(new PropertyModel(annotation.value(), propertyDescriptor.getPropertyType(), true, null, writeMethod, null, null, null));
                    }
                }
            }
        } catch (IntrospectionException e) {
            TypeScriptGenerator.getLogger().warning(String.format("Cannot introspect '%s' class: " + e.getMessage(), paramBean));
        }
        if (properties.isEmpty()) {
            return null;
        } else {
            return new BeanModel(paramBean, null, null, null, null, null, properties, null);
        }
    }
    private MethodParameterModel getEntityParameter(Class<?> resourceClass, Method method, List<Pair<Parameter, Type>> parameters) {
        for (Pair<Parameter, Type> pair : parameters) {
            if (!Utils.hasAnyAnnotation(annotationClass -> pair.getValue1().getAnnotation(annotationClass), Arrays.asList(
                    MatrixParam.class, javax(MatrixParam.class),
                    QueryParam.class, javax(QueryParam.class),
                    PathParam.class, javax(PathParam.class),
                    CookieParam.class, javax(CookieParam.class),
                    HeaderParam.class, javax(HeaderParam.class),
                    Suspended.class, javax(Suspended.class),
                    Context.class, javax(Context.class),
                    FormParam.class, javax(FormParam.class),
                    BeanParam.class, javax(BeanParam.class)
            ))) {
                final Type resolvedType = GenericsResolver.resolveType(resourceClass, pair.getValue2(), method.getDeclaringClass());
                return new MethodParameterModel(pair.getValue1().getName(), resolvedType);
            }
        }
        return null;
    }
    private static boolean hasAnyAnnotation(Parameter[] parameters, List<Class<? extends Annotation>> annotationClasses) {
        return Stream.of(parameters)
                .anyMatch(parameter -> Utils.hasAnyAnnotation(parameter::getAnnotation, annotationClasses));
    }
    private static Map<Class<?>, TsType> getStandardEntityClassesMapping() {
        if (standardEntityClassesMapping == null) {
            final Map<Class<?>, TsType> map = new LinkedHashMap<>();
            map.put(byte[].class, TsType.Any);
            map.put(java.lang.String.class, null);
            map.put(java.io.InputStream.class, TsType.Any);
            map.put(java.io.Reader.class, TsType.Any);
            map.put(java.io.File.class, TsType.Any);
            map.put(javax.activation.DataSource.class, TsType.Any);
            map.put(javax.xml.transform.Source.class, TsType.Any);
            map.put(jakarta.xml.bind.JAXBElement.class, null);
            map.put(javax.xml.bind.JAXBElement.class, null);
            map.put(MultivaluedMap.class, TsType.Any);
            map.put(javax(MultivaluedMap.class), TsType.Any);
            map.put(StreamingOutput.class, TsType.Any);
            map.put(javax(StreamingOutput.class), TsType.Any);
            map.put(java.lang.Boolean.class, null);
            map.put(java.lang.Character.class, null);
            map.put(java.lang.Number.class, null);
            map.put(long.class, null);
            map.put(int.class, null);
            map.put(short.class, null);
            map.put(byte.class, null);
            map.put(double.class, null);
            map.put(float.class, null);
            map.put(boolean.class, null);
            map.put(char.class, null);
            standardEntityClassesMapping = map;
        }
        return standardEntityClassesMapping;
    }
    private static Map<Class<?>, TsType> standardEntityClassesMapping;
    private static List<String> getDefaultExcludedClassNames() {
        return Arrays.asList(
                "org.glassfish.jersey.media.multipart.FormDataBodyPart"
        );
    }
    static <A extends Annotation> A getRsAnnotation(AnnotatedElement annotatedElement, Class<A> jakartaAnnotationClass) {
        final Class<?> javaxAnnotationClass = javax(jakartaAnnotationClass);
        return Utils.getMigratedAnnotation(annotatedElement, jakartaAnnotationClass, javaxAnnotationClass);
    }
    private static <T> Class<T> javax(Class<T> jakartaClass) {
        @SuppressWarnings("unchecked")
        final Class<T> cls = (Class<T>) javaxClasses.get().get(jakartaClass);
        if (cls == null) {
            throw new IllegalArgumentException(jakartaClass.getName());
        }
        return cls;
    }
    private static final Supplier<Map<Class<?>, Class<?>>> javaxClasses = Utils.memoize(() -> {
        final Map<Class<?>, Class<?>> map = new LinkedHashMap<>();
        map.put(jakarta.ws.rs.ApplicationPath.class, javax.ws.rs.ApplicationPath.class);
        map.put(jakarta.ws.rs.BeanParam.class, javax.ws.rs.BeanParam.class);
        map.put(jakarta.ws.rs.CookieParam.class, javax.ws.rs.CookieParam.class);
        map.put(jakarta.ws.rs.FormParam.class, javax.ws.rs.FormParam.class);
        map.put(jakarta.ws.rs.HeaderParam.class, javax.ws.rs.HeaderParam.class);
        map.put(jakarta.ws.rs.HttpMethod.class, javax.ws.rs.HttpMethod.class);
        map.put(jakarta.ws.rs.MatrixParam.class, javax.ws.rs.MatrixParam.class);
        map.put(jakarta.ws.rs.Path.class, javax.ws.rs.Path.class);
        map.put(jakarta.ws.rs.PathParam.class, javax.ws.rs.PathParam.class);
        map.put(jakarta.ws.rs.QueryParam.class, javax.ws.rs.QueryParam.class);
        map.put(jakarta.ws.rs.container.Suspended.class, javax.ws.rs.container.Suspended.class);
        map.put(jakarta.ws.rs.core.Application.class, javax.ws.rs.core.Application.class);
        map.put(jakarta.ws.rs.core.Context.class, javax.ws.rs.core.Context.class);
        map.put(jakarta.ws.rs.core.GenericEntity.class, javax.ws.rs.core.GenericEntity.class);
        map.put(jakarta.ws.rs.core.MultivaluedMap.class, javax.ws.rs.core.MultivaluedMap.class);
        map.put(jakarta.ws.rs.core.Response.class, javax.ws.rs.core.Response.class);
        map.put(jakarta.ws.rs.core.StreamingOutput.class, javax.ws.rs.core.StreamingOutput.class);
        return map;
    });
}
package cz.habarta.typescript.generator.maven;
import cz.habarta.typescript.generator.ClassMapping;
import cz.habarta.typescript.generator.DateMapping;
import cz.habarta.typescript.generator.EnumMapping;
import cz.habarta.typescript.generator.GsonConfiguration;
import cz.habarta.typescript.generator.IdentifierCasing;
import cz.habarta.typescript.generator.Input;
import cz.habarta.typescript.generator.Jackson2Configuration;
import cz.habarta.typescript.generator.JsonLibrary;
import cz.habarta.typescript.generator.JsonbConfiguration;
import cz.habarta.typescript.generator.Logger;
import cz.habarta.typescript.generator.MapMapping;
import cz.habarta.typescript.generator.ModuleDependency;
import cz.habarta.typescript.generator.NullabilityDefinition;
import cz.habarta.typescript.generator.OptionalProperties;
import cz.habarta.typescript.generator.OptionalPropertiesDeclaration;
import cz.habarta.typescript.generator.Output;
import cz.habarta.typescript.generator.RestNamespacing;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.StringQuotes;
import cz.habarta.typescript.generator.TypeScriptFileType;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.TypeScriptOutputKind;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.List;
import org.apache.maven.artifact.DependencyResolutionRequiredException;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.plugins.annotations.ResolutionScope;
import org.apache.maven.project.MavenProject;
@Mojo(name = "generate", defaultPhase = LifecyclePhase.PROCESS_CLASSES, requiresDependencyResolution = ResolutionScope.COMPILE, threadSafe = true)
public class GenerateMojo extends AbstractMojo {
    @Parameter
    private File outputFile;
    @Parameter
    private TypeScriptFileType outputFileType;
    @Parameter(required = true)
    public TypeScriptOutputKind outputKind;
    @Parameter
    private String module;
    @Parameter
    private String namespace;
    @Parameter
    private boolean mapPackagesToNamespaces;
    @Parameter
    private String umdNamespace;
    @Parameter
    private List<ModuleDependency> moduleDependencies;
    @Parameter
    private List<String> classes;
    @Parameter
    private List<String> classPatterns;
    @Parameter
    private List<String> classesWithAnnotations;
    @Parameter
    private List<String> classesImplementingInterfaces;
    @Parameter
    private List<String> classesExtendingClasses;
    @Parameter
    private String classesFromJaxrsApplication;
    @Parameter
    private boolean classesFromAutomaticJaxrsApplication;
    @Parameter
    private List<String> scanningAcceptedPackages;
    @Parameter
    private List<String> excludeClasses;
    @Parameter
    private List<String> excludeClassPatterns;
    @Parameter
    private List<String> includePropertyAnnotations;
    @Parameter
    private List<String> excludePropertyAnnotations;
    @Parameter(required = true)
    private JsonLibrary jsonLibrary;
    @Parameter
    private Jackson2Configuration jackson2Configuration;
    @Parameter
    private GsonConfiguration gsonConfiguration;
    @Parameter
    private JsonbConfiguration jsonbConfiguration;
    @Parameter
    private List<String> additionalDataLibraries;
    @Parameter
    private OptionalProperties optionalProperties;
    @Parameter
    private OptionalPropertiesDeclaration optionalPropertiesDeclaration;
    @Parameter
    private NullabilityDefinition nullabilityDefinition;
    @Parameter
    private boolean declarePropertiesAsReadOnly;
    @Parameter
    private String removeTypeNamePrefix;
    @Parameter
    private String removeTypeNameSuffix;
    @Parameter
    private String addTypeNamePrefix;
    @Parameter
    private String addTypeNameSuffix;
    @Parameter
    private List<String> customTypeNaming;
    @Parameter
    private String customTypeNamingFunction;
    @Parameter
    private List<String> referencedFiles;
    @Parameter
    private List<String> importDeclarations;
    @Parameter
    private List<String> customTypeMappings;
    @Parameter
    private List<String> customTypeAliases;
    @Parameter
    private DateMapping mapDate;
    @Parameter
    private MapMapping mapMap;
    @Parameter
    private EnumMapping mapEnum;
    @Parameter
    private IdentifierCasing enumMemberCasing;
    @Parameter
    private boolean nonConstEnums;
    @Parameter
    private List<String> nonConstEnumAnnotations;
    @Parameter
    private ClassMapping mapClasses;
    @Parameter
    private List<String> mapClassesAsClassesPatterns;
    @Parameter
    private boolean generateConstructors;
    @Parameter
    private List<String> disableTaggedUnionAnnotations;
    @Parameter
    private boolean disableTaggedUnions;
    @Parameter
    private boolean generateReadonlyAndWriteonlyJSDocTags;
    @Parameter
    private boolean ignoreSwaggerAnnotations;
    @Parameter
    private boolean generateJaxrsApplicationInterface;
    @Parameter
    private boolean generateJaxrsApplicationClient;
    @Parameter
    private boolean generateSpringApplicationInterface;
    @Parameter
    private boolean generateSpringApplicationClient;
    @Parameter
    private boolean scanSpringApplication;
    @Parameter
    private RestNamespacing restNamespacing;
    @Parameter
    private String restNamespacingAnnotation;
    @Parameter
    private String restResponseType;
    @Parameter
    private String restOptionsType;
    @Parameter
    private String customTypeProcessor;
    @Parameter
    private boolean sortDeclarations;
    @Parameter
    private boolean sortTypeDeclarations;
    @Parameter
    private boolean noFileComment;
    @Parameter
    private boolean noTslintDisable;
    @Parameter
    private boolean noEslintDisable;
    @Parameter
    private boolean tsNoCheck;
    @Parameter
    private List<File> javadocXmlFiles;
    @Parameter
    private List<String> extensions;
    @Parameter
    private List<Settings.ConfiguredExtension> extensionsWithConfiguration;
    @Parameter
    private List<String> optionalAnnotations;
    @Parameter
    private List<String> requiredAnnotations;
    @Parameter
    private List<String> nullableAnnotations;
    @Parameter
    private boolean primitivePropertiesRequired;
    @Parameter
    private boolean generateInfoJson;
    @Parameter
    private boolean generateNpmPackageJson;
    @Parameter
    private String npmName;
    @Parameter
    private String npmVersion;
    @Parameter
    private String npmTypescriptVersion;
    @Parameter
    private String npmBuildScript;
    @Parameter
    private List<String> npmDependencies;
    @Parameter
    private List<String> npmDevDependencies;
    @Parameter
    private List<String> npmPeerDependencies;
    @Parameter
    private StringQuotes stringQuotes;
    @Parameter
    private String indentString;
    @Parameter
    private boolean jackson2ModuleDiscovery;
    @Parameter
    private List<String> jackson2Modules;
    @Parameter
    private Logger.Level loggingLevel;
    @Parameter(property = "typescript.generator.skip")
    private boolean skip;
    @Parameter(defaultValue = "${project}", readonly = true, required = true)
    private MavenProject project;
    @Parameter(defaultValue = "${project.build.directory}", readonly = true, required = true)
    private String projectBuildDirectory;
    private Settings createSettings(URLClassLoader classLoader) {
        final Settings settings = new Settings();
        if (outputFileType != null) {
            settings.outputFileType = outputFileType;
        }
        settings.outputKind = outputKind;
        settings.module = module;
        settings.namespace = namespace;
        settings.mapPackagesToNamespaces = mapPackagesToNamespaces;
        settings.umdNamespace = umdNamespace;
        settings.moduleDependencies = moduleDependencies;
        settings.setExcludeFilter(excludeClasses, excludeClassPatterns);
        settings.jsonLibrary = jsonLibrary;
        settings.setJackson2Configuration(classLoader, jackson2Configuration);
        settings.gsonConfiguration = gsonConfiguration;
        settings.jsonbConfiguration = jsonbConfiguration;
        settings.additionalDataLibraries = additionalDataLibraries;
        settings.optionalProperties = optionalProperties;
        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;
        settings.nullabilityDefinition = nullabilityDefinition;
        settings.declarePropertiesAsReadOnly = declarePropertiesAsReadOnly;
        settings.removeTypeNamePrefix = removeTypeNamePrefix;
        settings.removeTypeNameSuffix = removeTypeNameSuffix;
        settings.addTypeNamePrefix = addTypeNamePrefix;
        settings.addTypeNameSuffix = addTypeNameSuffix;
        settings.customTypeNaming = Settings.convertToMap(customTypeNaming, "customTypeNaming");
        settings.customTypeNamingFunction = customTypeNamingFunction;
        settings.referencedFiles = referencedFiles;
        settings.importDeclarations = importDeclarations;
        settings.customTypeMappings = Settings.convertToMap(customTypeMappings, "customTypeMapping");
        settings.customTypeAliases = Settings.convertToMap(customTypeAliases, "customTypeAlias");
        settings.mapDate = mapDate;
        settings.mapMap = mapMap;
        settings.mapEnum = mapEnum;
        settings.enumMemberCasing = enumMemberCasing;
        settings.nonConstEnums = nonConstEnums;
        settings.loadNonConstEnumAnnotations(classLoader, nonConstEnumAnnotations);
        settings.mapClasses = mapClasses;
        settings.mapClassesAsClassesPatterns = mapClassesAsClassesPatterns;
        settings.generateConstructors = generateConstructors;
        settings.loadDisableTaggedUnionAnnotations(classLoader, disableTaggedUnionAnnotations);
        settings.disableTaggedUnions = disableTaggedUnions;
        settings.generateReadonlyAndWriteonlyJSDocTags = generateReadonlyAndWriteonlyJSDocTags;
        settings.ignoreSwaggerAnnotations = ignoreSwaggerAnnotations;
        settings.generateJaxrsApplicationInterface = generateJaxrsApplicationInterface;
        settings.generateJaxrsApplicationClient = generateJaxrsApplicationClient;
        settings.generateSpringApplicationInterface = generateSpringApplicationInterface;
        settings.generateSpringApplicationClient = generateSpringApplicationClient;
        settings.scanSpringApplication = scanSpringApplication;
        settings.restNamespacing = restNamespacing;
        settings.setRestNamespacingAnnotation(classLoader, restNamespacingAnnotation);
        settings.restResponseType = restResponseType;
        settings.setRestOptionsType(restOptionsType);
        settings.loadCustomTypeProcessor(classLoader, customTypeProcessor);
        settings.sortDeclarations = sortDeclarations;
        settings.sortTypeDeclarations = sortTypeDeclarations;
        settings.noFileComment = noFileComment;
        settings.noTslintDisable = noTslintDisable;
        settings.noEslintDisable = noEslintDisable;
        settings.tsNoCheck = tsNoCheck;
        settings.javadocXmlFiles = javadocXmlFiles;
        settings.loadExtensions(classLoader, extensions, extensionsWithConfiguration);
        settings.loadIncludePropertyAnnotations(classLoader, includePropertyAnnotations);
        settings.loadExcludePropertyAnnotations(classLoader, excludePropertyAnnotations);
        settings.loadOptionalAnnotations(classLoader, optionalAnnotations);
        settings.loadRequiredAnnotations(classLoader, requiredAnnotations);
        settings.loadNullableAnnotations(classLoader, nullableAnnotations);
        settings.primitivePropertiesRequired = primitivePropertiesRequired;
        settings.generateInfoJson = generateInfoJson;
        settings.generateNpmPackageJson = generateNpmPackageJson;
        settings.npmName = npmName == null && generateNpmPackageJson ? project.getArtifactId() : npmName;
        settings.npmVersion = npmVersion == null && generateNpmPackageJson ? settings.getDefaultNpmVersion() : npmVersion;
        settings.npmTypescriptVersion = npmTypescriptVersion;
        settings.npmBuildScript = npmBuildScript;
        settings.npmPackageDependencies = Settings.convertToMap(npmDependencies, "npmDependencies");
        settings.npmDevDependencies = Settings.convertToMap(npmDevDependencies, "npmDevDependencies");
        settings.npmPeerDependencies = Settings.convertToMap(npmPeerDependencies, "npmPeerDependencies");
        settings.setStringQuotes(stringQuotes);
        settings.setIndentString(indentString);
        settings.jackson2ModuleDiscovery = jackson2ModuleDiscovery;
        settings.loadJackson2Modules(classLoader, jackson2Modules);
        settings.classLoader = classLoader;
        return settings;
    }
    @Override
    public void execute() {
        TypeScriptGenerator.setLogger(new Logger(loggingLevel));
        TypeScriptGenerator.printVersion();
        if (skip) {
            TypeScriptGenerator.getLogger().info("Skipping plugin execution");
            return;
        }
        final List<URL> urls = new ArrayList<>();
        try {
            for (String element : project.getCompileClasspathElements()) {
                urls.add(new File(element).toURI().toURL());
            }
        } catch (DependencyResolutionRequiredException | IOException e) {
            throw new RuntimeException(e);
        }
        try (URLClassLoader classLoader = Settings.createClassLoader(project.getArtifactId(), urls.toArray(new URL[0]), Thread.currentThread().getContextClassLoader())) {
            final Settings settings = createSettings(classLoader);
            final Input.Parameters parameters = new Input.Parameters();
            parameters.classNames = classes;
            parameters.classNamePatterns = classPatterns;
            parameters.classesWithAnnotations = classesWithAnnotations;
            parameters.classesImplementingInterfaces = classesImplementingInterfaces;
            parameters.classesExtendingClasses = classesExtendingClasses;
            parameters.jaxrsApplicationClassName = classesFromJaxrsApplication;
            parameters.automaticJaxrsApplication = classesFromAutomaticJaxrsApplication;
            parameters.isClassNameExcluded = settings.getExcludeFilter();
            parameters.classLoader = classLoader;
            parameters.scanningAcceptedPackages = scanningAcceptedPackages;
            parameters.debug = loggingLevel == Logger.Level.Debug;
            final File output = outputFile != null
                    ? outputFile
                    : new File(new File(projectBuildDirectory, "typescript-generator"), project.getArtifactId() + settings.getExtension());
            settings.validateFileName(output);
            new TypeScriptGenerator(settings).generateTypeScript(Input.from(parameters), Output.to(output));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
package cz.habarta.typescript.generator.gradle;
import cz.habarta.typescript.generator.ClassMapping;
import cz.habarta.typescript.generator.DateMapping;
import cz.habarta.typescript.generator.EnumMapping;
import cz.habarta.typescript.generator.GsonConfiguration;
import cz.habarta.typescript.generator.IdentifierCasing;
import cz.habarta.typescript.generator.Input;
import cz.habarta.typescript.generator.Jackson2Configuration;
import cz.habarta.typescript.generator.JsonLibrary;
import cz.habarta.typescript.generator.JsonbConfiguration;
import cz.habarta.typescript.generator.Logger;
import cz.habarta.typescript.generator.MapMapping;
import cz.habarta.typescript.generator.ModuleDependency;
import cz.habarta.typescript.generator.NullabilityDefinition;
import cz.habarta.typescript.generator.OptionalProperties;
import cz.habarta.typescript.generator.OptionalPropertiesDeclaration;
import cz.habarta.typescript.generator.Output;
import cz.habarta.typescript.generator.RestNamespacing;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.StringQuotes;
import cz.habarta.typescript.generator.TypeScriptFileType;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.TypeScriptOutputKind;
import cz.habarta.typescript.generator.util.Utils;
import java.io.File;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import org.gradle.api.DefaultTask;
import org.gradle.api.Task;
import org.gradle.api.tasks.TaskAction;
public class GenerateTask extends DefaultTask {
    public String outputFile;
    public TypeScriptFileType outputFileType;
    public TypeScriptOutputKind outputKind;
    public String module;
    public String namespace;
    public boolean mapPackagesToNamespaces;
    public String umdNamespace;
    public List<ModuleDependency> moduleDependencies;
    public List<String> classes;
    public List<String> classPatterns;
    public List<String> classesWithAnnotations;
    public List<String> classesImplementingInterfaces;
    public List<String> classesExtendingClasses;
    public String classesFromJaxrsApplication;
    public boolean classesFromAutomaticJaxrsApplication;
    public List<String> scanningAcceptedPackages;
    public List<String> excludeClasses;
    public List<String> excludeClassPatterns;
    public List<String> includePropertyAnnotations;
    public List<String> excludePropertyAnnotations;
    public JsonLibrary jsonLibrary;
    public Jackson2Configuration jackson2Configuration;
    public GsonConfiguration gsonConfiguration;
    public JsonbConfiguration jsonbConfiguration;
    public List<String> additionalDataLibraries;
    public OptionalProperties optionalProperties;
    public OptionalPropertiesDeclaration optionalPropertiesDeclaration;
    public NullabilityDefinition nullabilityDefinition;
    public boolean declarePropertiesAsReadOnly;
    public String removeTypeNamePrefix;
    public String removeTypeNameSuffix;
    public String addTypeNamePrefix;
    public String addTypeNameSuffix;
    public List<String> customTypeNaming;
    public String customTypeNamingFunction;
    public List<String> referencedFiles;
    public List<String> importDeclarations;
    public List<String> customTypeMappings;
    public List<String> customTypeAliases;
    public DateMapping mapDate;
    public MapMapping mapMap;
    public EnumMapping mapEnum;
    public IdentifierCasing enumMemberCasing;
    public boolean nonConstEnums;
    public List<String> nonConstEnumAnnotations;
    public ClassMapping mapClasses;
    public List<String> mapClassesAsClassesPatterns;
    public boolean generateConstructors;
    public List<String> disableTaggedUnionAnnotations;
    public boolean disableTaggedUnions;
    public boolean generateReadonlyAndWriteonlyJSDocTags;
    public boolean ignoreSwaggerAnnotations;
    public boolean generateJaxrsApplicationInterface;
    public boolean generateJaxrsApplicationClient;
    public boolean generateSpringApplicationInterface;
    public boolean generateSpringApplicationClient;
    public boolean scanSpringApplication;
    public RestNamespacing restNamespacing;
    public String restNamespacingAnnotation;
    public String restResponseType;
    public String restOptionsType;
    public String customTypeProcessor;
    public boolean sortDeclarations;
    public boolean sortTypeDeclarations;
    public boolean noFileComment;
    public boolean noTslintDisable;
    public boolean noEslintDisable;
    public boolean tsNoCheck;
    public List<File> javadocXmlFiles;
    public List<String> extensionClasses;
    public List<String> extensions;
    public List<Settings.ConfiguredExtension> extensionsWithConfiguration;
    public List<String> optionalAnnotations;
    public List<String> requiredAnnotations;
    public List<String> nullableAnnotations;
    public boolean primitivePropertiesRequired;
    public boolean generateInfoJson;
    public boolean generateNpmPackageJson;
    public String npmName;
    public String npmVersion;
    public String npmTypescriptVersion;
    public String npmBuildScript;
    public List<String> npmDependencies;
    public List<String> npmDevDependencies;
    public List<String> npmPeerDependencies;
    public StringQuotes stringQuotes;
    public String indentString;
    public boolean jackson2ModuleDiscovery;
    public List<String> jackson2Modules;
    public Logger.Level loggingLevel;
    private Settings createSettings(URLClassLoader classLoader) {
        final Settings settings = new Settings();
        if (outputFileType != null) {
            settings.outputFileType = outputFileType;
        }
        settings.outputKind = outputKind;
        settings.module = module;
        settings.namespace = namespace;
        settings.mapPackagesToNamespaces = mapPackagesToNamespaces;
        settings.umdNamespace = umdNamespace;
        settings.moduleDependencies = moduleDependencies;
        settings.setExcludeFilter(excludeClasses, excludeClassPatterns);
        settings.jsonLibrary = jsonLibrary;
        settings.setJackson2Configuration(classLoader, jackson2Configuration);
        settings.gsonConfiguration = gsonConfiguration;
        settings.jsonbConfiguration = jsonbConfiguration;
        settings.additionalDataLibraries = additionalDataLibraries;
        settings.optionalProperties = optionalProperties;
        settings.optionalPropertiesDeclaration = optionalPropertiesDeclaration;
        settings.nullabilityDefinition = nullabilityDefinition;
        settings.declarePropertiesAsReadOnly = declarePropertiesAsReadOnly;
        settings.removeTypeNamePrefix = removeTypeNamePrefix;
        settings.removeTypeNameSuffix = removeTypeNameSuffix;
        settings.addTypeNamePrefix = addTypeNamePrefix;
        settings.addTypeNameSuffix = addTypeNameSuffix;
        settings.customTypeNaming = Settings.convertToMap(customTypeNaming, "customTypeNaming");
        settings.customTypeNamingFunction = customTypeNamingFunction;
        settings.referencedFiles = referencedFiles;
        settings.importDeclarations = importDeclarations;
        settings.customTypeMappings = Settings.convertToMap(customTypeMappings, "customTypeMapping");
        settings.customTypeAliases = Settings.convertToMap(customTypeAliases, "customTypeAlias");
        settings.mapDate = mapDate;
        settings.mapMap = mapMap;
        settings.mapEnum = mapEnum;
        settings.enumMemberCasing = enumMemberCasing;
        settings.nonConstEnums = nonConstEnums;
        settings.loadNonConstEnumAnnotations(classLoader, nonConstEnumAnnotations);
        settings.mapClasses = mapClasses;
        settings.mapClassesAsClassesPatterns = mapClassesAsClassesPatterns;
        settings.generateConstructors = generateConstructors;
        settings.loadDisableTaggedUnionAnnotations(classLoader, disableTaggedUnionAnnotations);
        settings.disableTaggedUnions = disableTaggedUnions;
        settings.generateReadonlyAndWriteonlyJSDocTags = generateReadonlyAndWriteonlyJSDocTags;
        settings.ignoreSwaggerAnnotations = ignoreSwaggerAnnotations;
        settings.generateJaxrsApplicationInterface = generateJaxrsApplicationInterface;
        settings.generateJaxrsApplicationClient = generateJaxrsApplicationClient;
        settings.generateSpringApplicationInterface = generateSpringApplicationInterface;
        settings.generateSpringApplicationClient = generateSpringApplicationClient;
        settings.scanSpringApplication = scanSpringApplication;
        settings.restNamespacing = restNamespacing;
        settings.setRestNamespacingAnnotation(classLoader, restNamespacingAnnotation);
        settings.restResponseType = restResponseType;
        settings.setRestOptionsType(restOptionsType);
        settings.loadCustomTypeProcessor(classLoader, customTypeProcessor);
        settings.sortDeclarations = sortDeclarations;
        settings.sortTypeDeclarations = sortTypeDeclarations;
        settings.noFileComment = noFileComment;
        settings.noTslintDisable = noTslintDisable;
        settings.noEslintDisable = noEslintDisable;
        settings.tsNoCheck = tsNoCheck;
        settings.javadocXmlFiles = javadocXmlFiles;
        settings.loadExtensions(classLoader, Utils.concat(extensionClasses, extensions), extensionsWithConfiguration);
        settings.loadIncludePropertyAnnotations(classLoader, includePropertyAnnotations);
        settings.loadExcludePropertyAnnotations(classLoader, excludePropertyAnnotations);
        settings.loadOptionalAnnotations(classLoader, optionalAnnotations);
        settings.loadRequiredAnnotations(classLoader, requiredAnnotations);
        settings.loadNullableAnnotations(classLoader, nullableAnnotations);
        settings.primitivePropertiesRequired = primitivePropertiesRequired;
        settings.generateInfoJson = generateInfoJson;
        settings.generateNpmPackageJson = generateNpmPackageJson;
        settings.npmName = npmName == null && generateNpmPackageJson ? getProject().getName() : npmName;
        settings.npmVersion = npmVersion == null && generateNpmPackageJson ? settings.getDefaultNpmVersion() : npmVersion;
        settings.npmTypescriptVersion = npmTypescriptVersion;
        settings.npmBuildScript = npmBuildScript;
        settings.npmPackageDependencies = Settings.convertToMap(npmDependencies, "npmDependencies");
        settings.npmDevDependencies = Settings.convertToMap(npmDevDependencies, "npmDevDependencies");
        settings.npmPeerDependencies = Settings.convertToMap(npmPeerDependencies, "npmPeerDependencies");
        settings.setStringQuotes(stringQuotes);
        settings.setIndentString(indentString);
        settings.jackson2ModuleDiscovery = jackson2ModuleDiscovery;
        settings.loadJackson2Modules(classLoader, jackson2Modules);
        settings.classLoader = classLoader;
        return settings;
    }
    @TaskAction
    public void generate() throws Exception {
        if (outputKind == null) {
            throw new RuntimeException("Please specify 'outputKind' property.");
        }
        if (jsonLibrary == null) {
            throw new RuntimeException("Please specify 'jsonLibrary' property.");
        }
        TypeScriptGenerator.setLogger(new Logger(loggingLevel));
        TypeScriptGenerator.printVersion();
        final Set<URL> urls = new LinkedHashSet<>();
        for (Task task : getProject().getTasks()) {
            if (task.getName().startsWith("compile") && !task.getName().startsWith("compileTest")) {
                for (File file : task.getOutputs().getFiles()) {
                    urls.add(file.toURI().toURL());
                }
            }
        }
        urls.addAll(getFilesFromConfiguration("compileClasspath"));
        try (URLClassLoader classLoader = Settings.createClassLoader(getProject().getName(), urls.toArray(new URL[0]), Thread.currentThread().getContextClassLoader())) {
            final Settings settings = createSettings(classLoader);
            final Input.Parameters parameters = new Input.Parameters();
            parameters.classNames = classes;
            parameters.classNamePatterns = classPatterns;
            parameters.classesWithAnnotations = classesWithAnnotations;
            parameters.classesImplementingInterfaces = classesImplementingInterfaces;
            parameters.classesExtendingClasses = classesExtendingClasses;
            parameters.jaxrsApplicationClassName = classesFromJaxrsApplication;
            parameters.automaticJaxrsApplication = classesFromAutomaticJaxrsApplication;
            parameters.isClassNameExcluded = settings.getExcludeFilter();
            parameters.classLoader = classLoader;
            parameters.scanningAcceptedPackages = scanningAcceptedPackages;
            parameters.debug = loggingLevel == Logger.Level.Debug;
            final File output = outputFile != null
                    ? getProject().file(outputFile)
                    : new File(new File(getProject().getBuildDir(), "typescript-generator"), getProject().getName() + settings.getExtension());
            settings.validateFileName(output);
            new TypeScriptGenerator(settings).generateTypeScript(Input.from(parameters), Output.to(output));
        }
    }
    private List<URL> getFilesFromConfiguration(String configuration) {
        try {
            final List<URL> urls = new ArrayList<>();
            for (File file : getProject().getConfigurations().getAt(configuration).getFiles()) {
                urls.add(file.toURI().toURL());
            }
            return urls;
        } catch (Exception e) {
            TypeScriptGenerator.getLogger().warning(String.format("Cannot get file names from configuration '%s': %s", configuration, e.getMessage()));
            return Collections.emptyList();
        }
    }
}
package cz.habarta.typescript.generator.ext;
import cz.habarta.typescript.generator.Extension;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.compiler.ModelCompiler;
import cz.habarta.typescript.generator.compiler.TsModelTransformer;
import cz.habarta.typescript.generator.emitter.EmitterExtensionFeatures;
import cz.habarta.typescript.generator.emitter.TsBeanModel;
import cz.habarta.typescript.generator.emitter.TsModel;
import cz.habarta.typescript.generator.emitter.TsNumberLiteral;
import cz.habarta.typescript.generator.emitter.TsPropertyModel;
import cz.habarta.typescript.generator.emitter.TsStringLiteral;
import cz.habarta.typescript.generator.parser.BeanModel;
import cz.habarta.typescript.generator.parser.PropertyModel;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Member;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
public class DefaultsFromInstanceExtension extends Extension {
    @Override
    public EmitterExtensionFeatures getFeatures() {
        final EmitterExtensionFeatures features = new EmitterExtensionFeatures();
        features.generatesRuntimeCode = true;
        features.worksWithPackagesMappedToNamespaces = true;
        return features;
    }
    @Override
    public List<TransformerDefinition> getTransformers() {
        return Arrays.asList(new TransformerDefinition(ModelCompiler.TransformationPhase.BeforeEnums, this::transformModel));
    }
    protected TsModel transformModel(TsModelTransformer.Context context, TsModel model) {
        final List<TsBeanModel> beans = model.getBeans().stream()
                .map(bean -> transformBean(context, bean))
                .collect(Collectors.toList());
        return model.withBeans(beans);
    }
    protected TsBeanModel transformBean(TsModelTransformer.Context context, TsBeanModel tsBean) {
        if (!tsBean.isClass()) {
            return tsBean;
        }
        final BeanModel bean = context.getBeanModelOrigin(tsBean);
        if (bean == null) {
            return tsBean;
        }
        final Class<?> originClass = bean.getOrigin();
        if (originClass == null) {
            return tsBean;
        }
        try {
            final Constructor<?> constructor = originClass.getConstructor();
            final Object instance = constructor.newInstance();
            final List<TsPropertyModel> properties = tsBean.getProperties().stream()
                    .map(tsProperty -> withDefaultValue(bean, instance, tsProperty))
                    .collect(Collectors.toList());
            return tsBean.withProperties(properties);
        } catch (Exception e) {
            TypeScriptGenerator.getLogger().verbose(String.format(
                    "Cannot create instance of class '%s' to get default values: %s",
                    originClass.getName(), e.getMessage()));
            return tsBean;
        }
    }
    protected TsPropertyModel withDefaultValue(BeanModel bean, Object instance, TsPropertyModel tsProperty) {
        final Object defaultValue = getDefaultValue(bean, instance, tsProperty.getName());
        if (defaultValue instanceof String) {
            return tsProperty.withDefaultValue(new TsStringLiteral((String) defaultValue));
        } else if (defaultValue instanceof Number) {
            return tsProperty.withDefaultValue(new TsNumberLiteral((Number) defaultValue));
        } else {
            return tsProperty;
        }
    }
    protected Object getDefaultValue(BeanModel bean, Object instance, String propertyName) {
        final PropertyModel property = bean.getProperty(propertyName);
        if (property == null) {
            return null;
        }
        final Member member = property.getOriginalMember();
        if (member == null) {
            return null;
        }
        try {
            if (member instanceof Field) {
                final Field field = (Field) member;
                field.setAccessible(true);
                final Object value = field.get(instance);
                return value;
            }
            if (member instanceof Method) {
                final Method method = (Method) member;
                method.setAccessible(true);
                final Object value = method.invoke(instance);
                return value;
            }
            return null;
        } catch (ReflectiveOperationException e) {
            TypeScriptGenerator.getLogger().verbose(String.format(
                    "Cannot get default value of property '%s' of class '%s': %s",
                    propertyName, bean.getOrigin().getName(), e.getMessage()));
            return null;
        }
    }
}
package cz.habarta.typescript.generator.spring;
import cz.habarta.typescript.generator.Settings;
import cz.habarta.typescript.generator.TsType;
import cz.habarta.typescript.generator.TypeProcessor;
import cz.habarta.typescript.generator.TypeScriptGenerator;
import cz.habarta.typescript.generator.parser.JaxrsApplicationParser;
import cz.habarta.typescript.generator.parser.MethodParameterModel;
import cz.habarta.typescript.generator.parser.PathTemplate;
import cz.habarta.typescript.generator.parser.RestApplicationModel;
import cz.habarta.typescript.generator.parser.RestApplicationParser;
import cz.habarta.typescript.generator.parser.RestApplicationType;
import cz.habarta.typescript.generator.parser.RestMethodModel;
import cz.habarta.typescript.generator.parser.RestQueryParam;
import cz.habarta.typescript.generator.parser.SourceType;
import cz.habarta.typescript.generator.parser.Swagger;
import cz.habarta.typescript.generator.parser.SwaggerOperation;
import cz.habarta.typescript.generator.parser.SwaggerResponse;
import cz.habarta.typescript.generator.type.JTypeWithNullability;
import cz.habarta.typescript.generator.util.GenericsResolver;
import cz.habarta.typescript.generator.util.Pair;
import cz.habarta.typescript.generator.util.Utils;
import static cz.habarta.typescript.generator.util.Utils.getInheritanceChain;
import java.beans.BeanInfo;
import java.beans.IntrospectionException;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.lang.reflect.Parameter;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.BridgeMethodResolver;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ValueConstants;
public class SpringApplicationParser extends RestApplicationParser {
    public static class Factory extends RestApplicationParser.Factory {
        @Override
        public TypeProcessor getSpecificTypeProcessor() {
            return (javaType, context) -> {
                final Class<?> rawClass = Utils.getRawClassOrNull(javaType);
                if (rawClass != null) {
                    for (Map.Entry<Class<?>, TsType> entry : getStandardEntityClassesMapping().entrySet()) {
                        final Class<?> cls = entry.getKey();
                        final TsType type = entry.getValue();
                        if (cls.isAssignableFrom(rawClass) && type != null) {
                            return new TypeProcessor.Result(type);
                        }
                    }
                    if (getDefaultExcludedClassNames().contains(rawClass.getName())) {
                        return new TypeProcessor.Result(TsType.Any);
                    }
                }
                return null;
            };
        }
        @Override
        public RestApplicationParser create(Settings settings, TypeProcessor commonTypeProcessor) {
            return new SpringApplicationParser(settings, commonTypeProcessor);
        }
    }
    public SpringApplicationParser(Settings settings, TypeProcessor commonTypeProcessor) {
        super(settings, commonTypeProcessor, new RestApplicationModel(RestApplicationType.Spring));
    }
    @Override
    public JaxrsApplicationParser.Result tryParse(SourceType<?> sourceType) {
        if (!(sourceType.type instanceof Class<?>)) {
            return null;
        }
        final Class<?> cls = (Class<?>) sourceType.type;
        final SpringBootApplication app = AnnotationUtils.findAnnotation(cls, SpringBootApplication.class);
        if (app != null) {
            if (settings.scanSpringApplication) {
                TypeScriptGenerator.getLogger().verbose("Scanning Spring application: " + cls.getName());
                final ClassLoader originalContextClassLoader = Thread.currentThread().getContextClassLoader();
                try {
                    Thread.currentThread().setContextClassLoader(settings.classLoader);
                    final SpringApplicationHelper springApplicationHelper = new SpringApplicationHelper(settings.classLoader, cls);
                    final List<Class<?>> restControllers = springApplicationHelper.findRestControllers();
                    return new JaxrsApplicationParser.Result(restControllers.stream()
                        .map(controller -> new SourceType<Type>(controller, cls, "<scanned>"))
                        .collect(Collectors.toList())
                    );
                } finally {
                    Thread.currentThread().setContextClassLoader(originalContextClassLoader);
                }
            } else {
                return null;
            }
        }
        final Component component = AnnotationUtils.findAnnotation(cls, Component.class);
        if (component != null) {
            TypeScriptGenerator.getLogger().verbose("Parsing Spring component: " + cls.getName());
            final JaxrsApplicationParser.Result result = new JaxrsApplicationParser.Result();
            final RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(cls, RequestMapping.class);
            final String path = requestMapping != null && requestMapping.path() != null && requestMapping.path().length != 0 ? requestMapping.path()[0] : null;
            final JaxrsApplicationParser.ResourceContext context = new JaxrsApplicationParser.ResourceContext(cls, path);
            parseController(result, context, cls);
            return result;
        }
        return null;
    }
    private class SpringApplicationHelper extends SpringApplication {
        private final ClassLoader classLoader;
        public SpringApplicationHelper(ClassLoader classLoader, Class<?>... primarySources) {
            super(primarySources);
            this.classLoader = classLoader;
        }
        public List<Class<?>> findRestControllers() {
            try (ConfigurableApplicationContext context = createApplicationContext()) {
                load(context, getAllSources().toArray());
                withSystemProperty("server.port", "0", () -> {
                    context.refresh();
                });
                final List<Class<?>> classes = Stream.of(context.getBeanDefinitionNames())
                    .map(beanName -> context.getBeanFactory().getBeanDefinition(beanName).getBeanClassName())
                    .filter(Objects::nonNull)
                    .filter(className -> isClassNameExcluded == null || !isClassNameExcluded.test(className))
                    .map(className -> {
                        try {
                            return classLoader.loadClass(className);
                        } catch (ClassNotFoundException e) {
                            throw new RuntimeException(e);
                        }
                    })
                    .filter(instance -> AnnotationUtils.findAnnotation(instance, Component.class) != null)
                    .collect(Collectors.toList());
                return classes;
            }
        }
    }
    private static void withSystemProperty(String name, String value, Runnable runnable) {
        final String original = System.getProperty(name);
        try {
            System.setProperty(name, value);
            runnable.run();
        } finally {
            if (original != null) {
                System.setProperty(name, original);
            } else {
                System.getProperties().remove(name);
            }
        }
    }
    private void parseController(JaxrsApplicationParser.Result result, JaxrsApplicationParser.ResourceContext context, Class<?> controllerClass) {
        final List<Method> methods = getAllRequestMethods(controllerClass);
        methods.sort(Utils.methodComparator());
        for (Method method : methods) {
            parseControllerMethod(result, context, controllerClass, method);
        }
    }
    private List<Method> getAllRequestMethods(Class<?> cls) {
        List<Method> currentlyResolvedMethods = new ArrayList<>();
        getInheritanceChain(cls)
            .forEach(clazz -> {
                for (Method method : clazz.getDeclaredMethods()) {
                    final RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);
                    if (requestMapping != null) {
                        addOrReplaceMethod(currentlyResolvedMethods, method);
                    }
                }
            });
        return currentlyResolvedMethods;
    }
    private void addOrReplaceMethod(List<Method> resolvedMethods, Method newMethod) {
        int methodIndex = getMethodIndex(resolvedMethods, newMethod);
        if (methodIndex == -1) {
            resolvedMethods.add(newMethod);
            return;
        }
        final Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(newMethod);
        int bridgedMethodIndex = getMethodIndex(resolvedMethods, bridgedMethod);
        if (bridgedMethodIndex == -1 || bridgedMethodIndex == methodIndex) {
            resolvedMethods.set(methodIndex, bridgedMethod);
        } else {
            resolvedMethods.set(bridgedMethodIndex, bridgedMethod);
            resolvedMethods.remove(methodIndex);
        }
    }
    private int getMethodIndex(List<Method> resolvedMethods, Method newMethod) {
        for (int i = 0; i < resolvedMethods.size(); i++) {
            Method currMethod = resolvedMethods.get(i);
            if (!currMethod.getName().equals(newMethod.getName())) continue;
            if (!Arrays.equals(currMethod.getParameterTypes(), newMethod.getParameterTypes())) continue;
            return i;
        }
        return -1;
    }
    private void parseControllerMethod(JaxrsApplicationParser.Result result, JaxrsApplicationParser.ResourceContext context, Class<?> controllerClass, Method method) {
        final RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);
        if (requestMapping != null) {
            final SwaggerOperation swaggerOperation = settings.ignoreSwaggerAnnotations
                    ? new SwaggerOperation()
                    : Swagger.parseSwaggerAnnotations(method);
            if (swaggerOperation.possibleResponses != null) {
                for (SwaggerResponse response : swaggerOperation.possibleResponses) {
                    if (response.responseType != null) {
                        foundType(result, response.responseType, controllerClass, method.getName());
                    }
                }
            }
            if (swaggerOperation.hidden) {
                return;
            }
            context = context.subPath(requestMapping.path().length == 0 ? "" : requestMapping.path()[0]);
            final Map<String, Type> pathParamTypes = new LinkedHashMap<>();
            for (Parameter parameter : method.getParameters()) {
                final PathVariable pathVariableAnnotation = AnnotationUtils.findAnnotation(parameter, PathVariable.class);
                if (pathVariableAnnotation != null) {
                    String pathVariableName = pathVariableAnnotation.value();
                    if (pathVariableName.isEmpty()) {
                        pathVariableName = parameter.getName();
                    }
                    pathParamTypes.put(pathVariableName, parameter.getParameterizedType());
                }
            }
            context = context.subPathParamTypes(pathParamTypes);
            final RequestMethod httpMethod = requestMapping.method().length == 0 ? RequestMethod.GET : requestMapping.method()[0];
            final PathTemplate pathTemplate = PathTemplate.parse(context.path);
            final Map<String, Type> contextPathParamTypes = context.pathParamTypes;
            final List<MethodParameterModel> pathParams = pathTemplate.getParts().stream()
                .filter(PathTemplate.Parameter.class::isInstance)
                .map(PathTemplate.Parameter.class::cast)
                .map(parameter -> {
                    final Type type = contextPathParamTypes.get(parameter.getOriginalName());
                    final Type paramType = type != null ? type : String.class;
                    foundType(result, paramType, controllerClass, method.getName());
                    return new MethodParameterModel(parameter.getValidName(), paramType);
                })
                .collect(Collectors.toList());
            final List<RestQueryParam> queryParams = new ArrayList<>();
            for (Parameter parameter : method.getParameters()) {
                if (parameter.getType() == Pageable.class) {
                    queryParams.add(new RestQueryParam.Single(new MethodParameterModel("page", Long.class), false));
                    queryParams.add(new RestQueryParam.Single(new MethodParameterModel("size", Long.class), false));
                    queryParams.add(new RestQueryParam.Single(new MethodParameterModel("sort", String.class), false));
                } else {
                    final RequestParam requestParamAnnotation = AnnotationUtils.findAnnotation(parameter, RequestParam.class);
                    if (requestParamAnnotation != null) {
                        if (parameter.getType() == MultiValueMap.class) {
                            queryParams.add(new RestQueryParam.Map(false));
                        } else {
                            final boolean isRequired = requestParamAnnotation.required() && requestParamAnnotation.defaultValue().equals(ValueConstants.DEFAULT_NONE);
                            queryParams.add(new RestQueryParam.Single(new MethodParameterModel(firstOf(
                                requestParamAnnotation.value(),
                                parameter.getName()
                            ), parameter.getParameterizedType()), isRequired));
                            foundType(result, parameter.getParameterizedType(), controllerClass, method.getName());
                        }
                    }
                    final ModelAttribute modelAttributeAnnotation = AnnotationUtils.findAnnotation(parameter, ModelAttribute.class);
                    if (modelAttributeAnnotation != null) {
                        try {
                            final BeanInfo beanInfo = Introspector.getBeanInfo(parameter.getType());
                            for (PropertyDescriptor propertyDescriptor : beanInfo.getPropertyDescriptors()) {
                                final Method writeMethod = propertyDescriptor.getWriteMethod();
                                if (writeMethod != null) {
                                    queryParams.add(new RestQueryParam.Single(new MethodParameterModel(
                                            propertyDescriptor.getName(),
                                            propertyDescriptor.getPropertyType()
                                    ), false));
                                    foundType(result, propertyDescriptor.getPropertyType(), controllerClass, method.getName());
                                }
                            }
                        } catch (IntrospectionException e) {
                            TypeScriptGenerator.getLogger().warning(String.format("Cannot introspect '%s' class: " + e.getMessage(), parameter.getAnnotatedType()));
                        }
                    }
                }
            }
            final MethodParameterModel entityParameter = getEntityParameter(controllerClass, method);
            if (entityParameter != null) {
                foundType(result, entityParameter.getType(), controllerClass, method.getName());
            }
            final Type modelReturnType = parseReturnType(controllerClass, method);
            foundType(result, modelReturnType, controllerClass, method.getName());
            model.getMethods().add(new RestMethodModel(controllerClass, method.getName(), modelReturnType, method,
                controllerClass, httpMethod.name(), context.path, pathParams, queryParams, entityParameter, null));
        }
    }
    private Type parseReturnType(Class<?> controllerClass, Method method) {
        final Class<?> returnType = method.getReturnType();
        final Type parsedReturnType = settings.getTypeParser().getMethodReturnType(method);
        final Type plainReturnType = JTypeWithNullability.getPlainType(parsedReturnType);
        final Type modelReturnType;
        if (returnType == void.class) {
            modelReturnType = returnType;
        } else if (plainReturnType instanceof ParameterizedType && returnType == ResponseEntity.class) {
            final ParameterizedType parameterizedReturnType = (ParameterizedType) plainReturnType;
            modelReturnType = parameterizedReturnType.getActualTypeArguments()[0];
        } else {
            modelReturnType = parsedReturnType;
        }
        return GenericsResolver.resolveType(controllerClass, modelReturnType, method.getDeclaringClass());
    }
    private MethodParameterModel getEntityParameter(Class<?> controller, Method method) {
        final List<Type> parameterTypes = settings.getTypeParser().getMethodParameterTypes(method);
        final List<Pair<Parameter, Type>> parameters = Utils.zip(Arrays.asList(method.getParameters()), parameterTypes);
        for (Pair<Parameter, Type> pair : parameters) {
            final RequestBody requestBodyAnnotation = AnnotationUtils.findAnnotation(pair.getValue1(), RequestBody.class);
            if (requestBodyAnnotation != null) {
                final Type resolvedType = GenericsResolver.resolveType(controller, pair.getValue2(), method.getDeclaringClass());
                return new MethodParameterModel(pair.getValue1().getName(), resolvedType);
            }
        }
        return null;
    }
    private static Map<Class<?>, TsType> getStandardEntityClassesMapping() {
        if (standardEntityClassesMapping == null) {
            final Map<Class<?>, TsType> map = new LinkedHashMap<>();
            standardEntityClassesMapping = map;
        }
        return standardEntityClassesMapping;
    }
    private static Map<Class<?>, TsType> standardEntityClassesMapping;
    private static List<String> getDefaultExcludedClassNames() {
        return Arrays.asList(
        );
    }
    private static String firstOf(String... values) {
        return Stream.of(values).filter(it -> it != null && !it.isEmpty()).findFirst().orElse("");
    }
}