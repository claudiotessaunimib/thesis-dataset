package com.github.theholywaffle.teamspeak3.api.reconnect;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2015 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.TS3Api;
import com.github.theholywaffle.teamspeak3.TS3Query;
public interface ConnectionHandler {
	void onConnect(TS3Api api);
	void onDisconnect(TS3Query ts3Query);
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2014 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.api.exception.TS3ConnectionFailedException;
import com.github.theholywaffle.teamspeak3.api.exception.TS3QueryShutDownException;
import com.github.theholywaffle.teamspeak3.api.reconnect.ConnectionHandler;
import com.github.theholywaffle.teamspeak3.api.reconnect.DisconnectingConnectionHandler;
import com.github.theholywaffle.teamspeak3.api.reconnect.ReconnectStrategy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
public class TS3Query {
	private static final Logger log = LoggerFactory.getLogger(TS3Query.class);
	/**
	 * Artificial delay between sending commands, measured in milliseconds.
	 * <p>
	 * If the query's hostname / IP has not been added to the server's {@code query_ip_whitelist.txt},
	 * you need to use {@link FloodRate#DEFAULT} to prevent the query from being flood-banned.
	 * </p><p>
	 * Calling {@link FloodRate#custom} allows you to use a custom command delay if neither
	 * {@link FloodRate#UNLIMITED} nor {@link FloodRate#DEFAULT} fit your needs.
	 * </p>
	 */
	public static class FloodRate {
		/**
		 * Default delay of 350 milliseconds between commands for queries that are not whitelisted.
		 */
		public static final FloodRate DEFAULT = new FloodRate(350);
		/**
		 * No delay between commands. If a query uses this without being whitelisted, it will likely be flood-banned.
		 */
		public static final FloodRate UNLIMITED = new FloodRate(0);
		/**
		 * Creates a FloodRate object that represents a custom command delay.
		 *
		 * @param milliseconds
		 * 		the delay between sending commands in milliseconds
		 *
		 * @return a new {@code FloodRate} object representing a custom delay
		 */
		public static FloodRate custom(int milliseconds) {
			if (milliseconds < 0) throw new IllegalArgumentException("Timeout must be positive");
			return new FloodRate(milliseconds);
		}
		private final int ms;
		private FloodRate(int ms) {
			this.ms = ms;
		}
		public int getMs() {
			return ms;
		}
	}
	/**
	 * The protocol used to communicate with the TeamSpeak3 server.
	 */
	public enum Protocol {
		RAW, SSH
	}
	private final ConnectionHandler connectionHandler;
	private final EventManager eventManager;
	private final ExecutorService userThreadPool;
	private final FileTransferHelper fileTransferHelper;
	private final CommandQueue globalQueue;
	private final TS3Config config;
	private final AtomicBoolean connected = new AtomicBoolean(false);
	private Connection connection;
	/**
	 * Creates a TS3Query that connects to a TS3 server at
	 * {@code localhost:10011} using default settings.
	 */
	public TS3Query() {
		this(new TS3Config());
	}
	/**
	 * Creates a customized TS3Query that connects to a server
	 * specified by {@code config}.
	 *
	 * @param config
	 * 		configuration for this TS3Query
	 */
	public TS3Query(TS3Config config) {
		this.config = config.freeze();
		this.eventManager = new EventManager(this);
		this.userThreadPool = Executors.newCachedThreadPool();
		this.fileTransferHelper = new FileTransferHelper(config.getHost());
		this.connectionHandler = config.getReconnectStrategy().create(config.getConnectionHandler());
		this.globalQueue = CommandQueue.newGlobalQueue(this, connectionHandler instanceof DisconnectingConnectionHandler);
	}
	// PUBLIC
	/**
	 * Tries to establish a connection to the TeamSpeak3 server.
	 *
	 * @throws IllegalStateException
	 * 		if this method was called from {@link ConnectionHandler#onConnect}
	 * @throws TS3ConnectionFailedException
	 * 		if the query can't connect to the server or the {@link ConnectionHandler} throws an exception
	 */
	public void connect() {
		if (Thread.holdsLock(this)) {
			// Check that connect is not called from onConnect
			throw new IllegalStateException("Cannot call connect from onConnect handler");
		}
		doConnect();
	}
	private synchronized void doConnect() {
		if (userThreadPool.isShutdown()) {
			throw new IllegalStateException("The query has already been shut down");
		}
		disconnect(); // If we're already connected
		try {
			CommandQueue queue = CommandQueue.newConnectQueue(this);
			Connection con = new Connection(this, config, queue);
			try {
				TS3Api api = queue.getApi();
				if (config.getProtocol() == Protocol.RAW && config.hasLoginCredentials()) {
					api.login(config.getUsername(), config.getPassword());
				}
				connectionHandler.onConnect(api);
			} catch (TS3QueryShutDownException e) {
				// Disconnected during onConnect, re-throw as a TS3ConnectionFailedException
				queue.failRemainingCommands();
				throw new TS3ConnectionFailedException(e);
			} catch (Exception e) {
				con.disconnect();
				queue.failRemainingCommands();
				throw new TS3ConnectionFailedException("ConnectionHandler threw exception in connect handler", e);
			}
			// Reject new commands and wait until the onConnect queue is empty
			queue.shutDown();
			connection = con;
			con.setCommandQueue(globalQueue);
			connected.set(true);
		} catch (TS3ConnectionFailedException conFailed) {
			// If this is the first connection attempt, we won't run the handleDisconnect method,
			// so we need to call shutDown from this method instead.
			if (connection == null) shutDown();
			throw conFailed;
		}
	}
	/**
	 * Disconnects the query and closes all open resources.
	 * <p>
	 * If the command queue still contains commands when this method is called,
	 * the query will first process these commands, causing this method to block.
	 * However, the query will reject any new commands as soon as this method is called.
	 * </p>
	 *
	 * @throws IllegalStateException
	 * 		if this method was called from {@link ConnectionHandler#onConnect}
	 */
	public void exit() {
		if (Thread.holdsLock(this)) {
			// Check that exit is not called from onConnect
			throw new IllegalStateException("Cannot call exit from onConnect handler");
		}
		try {
			globalQueue.quit();
		} finally {
			shutDown();
		}
	}
	private synchronized void shutDown() {
		if (userThreadPool.isShutdown()) return;
		disconnect();
		globalQueue.failRemainingCommands();
		userThreadPool.shutdown();
	}
	private synchronized void disconnect() {
		if (connection == null) return;
		connection.disconnect();
		connected.set(false);
	}
	/**
	 * Returns {@code true} if the query is likely connected,
	 * {@code false} if the query is disconnected or currently trying to reconnect.
	 * <p>
	 * Note that the only way to really determine whether the query is connected or not
	 * is to send a command and check whether it succeeds.
	 * Thus this method could return {@code true} almost a minute after the connection
	 * has been lost, when the last keep-alive command was sent.
	 * </p><p>
	 * Please do not use this method to write your own connection handler.
	 * Instead, use the built-in classes in the {@code api.reconnect} package.
	 * </p>
	 *
	 * @return whether the query is connected or not
	 *
	 * @see TS3Config#setReconnectStrategy(ReconnectStrategy)
	 * @see TS3Config#setConnectionHandler(ConnectionHandler)
	 */
	public boolean isConnected() {
		return connected.get();
	}
	/**
	 * Gets the API object that can be used to send commands to the TS3 server.
	 *
	 * @return a {@code TS3Api} object
	 */
	public TS3Api getApi() {
		return globalQueue.getApi();
	}
	/**
	 * Gets the asynchronous API object that can be used to send commands to the TS3 server
	 * in a non-blocking manner.
	 * <p>
	 * Please only use the asynchronous API if it is really necessary and if you understand
	 * the implications of having multiple threads interact with your program.
	 * </p>
	 *
	 * @return a {@code TS3ApiAsync} object
	 */
	public TS3ApiAsync getAsyncApi() {
		return globalQueue.getAsyncApi();
	}
	// INTERNAL
	void submitUserTask(final String name, final Runnable task) {
		userThreadPool.submit(() -> {
			try {
				task.run();
			} catch (Throwable throwable) {
				log.error(name + " threw an exception", throwable);
			}
		});
	}
	EventManager getEventManager() {
		return eventManager;
	}
	FileTransferHelper getFileTransferHelper() {
		return fileTransferHelper;
	}
	void fireDisconnect() {
		connected.set(false);
		submitUserTask("ConnectionHandler disconnect task", this::handleDisconnect);
	}
	private void handleDisconnect() {
		try {
			connectionHandler.onDisconnect(this);
		} finally {
			synchronized (this) {
				if (!connected.get()) {
					shutDown();
				}
			}
		}
	}
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2014 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.api.*;
import com.github.theholywaffle.teamspeak3.api.event.TS3EventType;
import com.github.theholywaffle.teamspeak3.api.event.TS3Listener;
import com.github.theholywaffle.teamspeak3.api.exception.TS3CommandFailedException;
import com.github.theholywaffle.teamspeak3.api.exception.TS3ConnectionFailedException;
import com.github.theholywaffle.teamspeak3.api.exception.TS3FileTransferFailedException;
import com.github.theholywaffle.teamspeak3.api.wrapper.*;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
/**
 * API to interact with the {@link TS3Query} synchronously.
 * <p>
 * This class is used to easily interact with a {@link TS3Query}. It constructs commands,
 * sends them to the TeamSpeak3 server, processes the response and returns the result.
 * </p><p>
 * All methods in this class are synchronous, so they will block until the response arrives.
 * Calls to this API will usually take about 50 milliseconds to complete (plus ping),
 * but delays can range up to 4 seconds.
 * If a command takes longer than 4 seconds to complete, a {@link TS3ConnectionFailedException}
 * will be thrown.
 * </p><p>
 * You won't be able to execute most commands while you're not logged in due to missing permissions.
 * Make sure to either pass your login credentials to the {@link TS3Config} object when
 * creating the {@code TS3Query} or to call {@link #login(String, String)} to log in.
 * </p><p>
 * After that, most commands also require you to select a {@linkplain VirtualServer virtual server}.
 * To do so, call either {@link #selectVirtualServerByPort(int)} or {@link #selectVirtualServerById(int)}.
 * </p><p>
 * Be aware that many methods in this class will return {@code null} or {@code -1} if a command fails.
 * </p>
 *
 * @see TS3ApiAsync The asynchronous version of the API
 */
public class TS3Api {
	private final TS3ApiAsync asyncApi;
	/**
	 * Creates a new synchronous API object for the given {@code TS3Query}.
	 * <p>
	 * <b>Usually, this constructor should not be called.</b> Use {@link TS3Query#getApi()} instead.
	 * </p>
	 *
	 * @param asyncApi
	 * 		the asynchronous version of the API this class routes its method calls through
	 */
	TS3Api(TS3ApiAsync asyncApi) {
		this.asyncApi = asyncApi;
	}
	/**
	 * Adds a new ban entry. At least one of the parameters {@code ip}, {@code name} or {@code uid} needs to be non-null.
	 * Returns the ID of the newly created ban entry.
	 *
	 * @param ip
	 * 		a RegEx pattern to match a client's IP against, can be {@code null}
	 * @param name
	 * 		a RegEx pattern to match a client's name against, can be {@code null}
	 * @param uid
	 * 		the unique identifier of a client, can be {@code null}
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 * @param reason
	 * 		the reason for the ban, can be {@code null}
	 *
	 * @return the ID of the newly created ban entry
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Pattern RegEx Pattern
	 * @see #addBan(String, String, String, String, long, String)
	 * @see Client#getId()
	 * @see Client#getUniqueIdentifier()
	 * @see ClientInfo#getIp()
	 */
	public int addBan(String ip, String name, String uid, long timeInSeconds, String reason) {
		return asyncApi.addBan(ip, name, uid, timeInSeconds, reason).getUninterruptibly();
	}
	/**
	 * Adds a new ban entry. At least one of the parameters {@code ip}, {@code name}, {@code uid}, or
	 * {@code myTSId} needs to be non-null. Returns the ID of the newly created ban entry.
	 * <p>
	 * Note that creating a ban entry for the {@code "empty"} "myTeamSpeak" ID will ban all clients who
	 * don't have a linked "myTeamSpeak" account.
	 * </p>
	 *
	 * @param ip
	 * 		a RegEx pattern to match a client's IP against, can be {@code null}
	 * @param name
	 * 		a RegEx pattern to match a client's name against, can be {@code null}
	 * @param uid
	 * 		the unique identifier of a client, can be {@code null}
	 * @param myTSId
	 * 		the "myTeamSpeak" ID of a client, the string {@code "empty"}, or {@code null}
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 * @param reason
	 * 		the reason for the ban, can be {@code null}
	 *
	 * @return the ID of the newly created ban entry
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Pattern RegEx Pattern
	 * @see Client#getId()
	 * @see Client#getUniqueIdentifier()
	 * @see ClientInfo#getIp()
	 */
	public int addBan(String ip, String name, String uid, String myTSId, long timeInSeconds, String reason) {
		return asyncApi.addBan(ip, name, uid, myTSId, timeInSeconds, reason).getUninterruptibly();
	}
	/**
	 * Adds a specified permission to a client in a specific channel.
	 *
	 * @param channelId
	 * 		the ID of the channel wherein the permission should be granted
	 * @param clientDBId
	 * 		the database ID of the client to add a permission to
	 * @param permName
	 * 		the name of the permission to grant
	 * @param permValue
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public void addChannelClientPermission(int channelId, int clientDBId, String permName, int permValue) {
		asyncApi.addChannelClientPermission(channelId, clientDBId, permName, permValue).getUninterruptibly();
	}
	/**
	 * Creates a new channel group for clients using a given name and returns its ID.
	 * <p>
	 * To create channel group templates or ones for server queries,
	 * use {@link #addChannelGroup(String, PermissionGroupDatabaseType)}.
	 * </p>
	 *
	 * @param name
	 * 		the name of the new channel group
	 *
	 * @return the ID of the newly created channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup
	 */
	public int addChannelGroup(String name) {
		return asyncApi.addChannelGroup(name).getUninterruptibly();
	}
	/**
	 * Creates a new channel group using a given name and returns its ID.
	 *
	 * @param name
	 * 		the name of the new channel group
	 * @param type
	 * 		the desired type of channel group
	 *
	 * @return the ID of the newly created channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup
	 */
	public int addChannelGroup(String name, PermissionGroupDatabaseType type) {
		return asyncApi.addChannelGroup(name, type).getUninterruptibly();
	}
	/**
	 * Adds a specified permission to a channel group.
	 *
	 * @param groupId
	 * 		the ID of the channel group to grant the permission
	 * @param permName
	 * 		the name of the permission to be granted
	 * @param permValue
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Permission
	 */
	public void addChannelGroupPermission(int groupId, String permName, int permValue) {
		asyncApi.addChannelGroupPermission(groupId, permName, permValue).getUninterruptibly();
	}
	/**
	 * Adds a specified permission to a channel.
	 *
	 * @param channelId
	 * 		the ID of the channel wherein the permission should be granted
	 * @param permName
	 * 		the name of the permission to grant
	 * @param permValue
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Permission
	 */
	public void addChannelPermission(int channelId, String permName, int permValue) {
		asyncApi.addChannelPermission(channelId, permName, permValue).getUninterruptibly();
	}
	/**
	 * Adds a specified permission to a channel.
	 *
	 * @deprecated
	 * This method is no longer preferred for adding permissions to a client.
	 * <p>
	 * Use {@link TS3Api#addClientPermission(int, IPermissionType, int, boolean)}
	 * or {@link TS3Api#addClientPermission(int, BPermissionType, boolean, boolean)} instead.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the client to grant the permission
	 * @param permName
	 * 		the name of the permission to grant
	 * @param value
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 * @param skipped
	 * 		if set to {@code true}, the permission will not be overridden by channel group permissions
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	@Deprecated
	public void addClientPermission(int clientDBId, String permName, int value, boolean skipped) {
		asyncApi.addClientPermission(clientDBId, permName, value, skipped).getUninterruptibly();
	}
	/**
	 * Adds a specified permission to a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client to grant the permission
	 * @param permName
	 * 		the enum of the permission to grant
	 * 		@see IPermissionType
	 * @param value
	 * 		the numeric value of the permission
	 * @param skipped
	 * 		if set to {@code true}, the permission will not be overridden by channel group permissions
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public void addClientPermission(int clientDBId, IPermissionType permName, int value, boolean skipped) {
		asyncApi.addClientPermission(clientDBId, permName, value, skipped).getUninterruptibly();
	}
	/**
	 * Adds a specified permission to a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client to grant the permission
	 * @param permName
	 * 		the enum of the permission to grant
	 * 		@see BPermissionType
	 * @param value
	 * 		the boolean value of the permission
	 * @param skipped
	 * 		if set to {@code true}, the permission will not be overridden by channel group permissions
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public void addClientPermission(int clientDBId, BPermissionType permName, boolean value, boolean skipped) {
		asyncApi.addClientPermission(clientDBId, permName, value, skipped).getUninterruptibly();
	}
	/**
	 * Adds a client to the specified server group.
	 * <p>
	 * Please note that a client cannot be added to default groups or template groups.
	 * </p>
	 *
	 * @param groupId
	 * 		the ID of the server group to add the client to
	 * @param clientDatabaseId
	 * 		the database ID of the client to add
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see Client#getDatabaseId()
	 */
	public void addClientToServerGroup(int groupId, int clientDatabaseId) {
		asyncApi.addClientToServerGroup(groupId, clientDatabaseId).getUninterruptibly();
	}
	/**
	 * Submits a complaint about the specified client.
	 * The length of the message is limited to 200 UTF-8 bytes and BB codes in it will be ignored.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param message
	 * 		the message of the complaint, may not contain BB codes
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Complaint#getMessage()
	 */
	public void addComplaint(int clientDBId, String message) {
		asyncApi.addComplaint(clientDBId, message).getUninterruptibly();
	}
	/**
	 * Adds a specified permission to all server groups of the type specified by {@code type} on all virtual servers.
	 *
	 * @param type
	 * 		the kind of server group this permission should be added to
	 * @param permName
	 * 		the name of the permission to be granted
	 * @param value
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 * @param negated
	 * 		if set to true, the lowest permission value will be selected instead of the highest
	 * @param skipped
	 * 		if set to true, this permission will not be overridden by client or channel group permissions
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroupType
	 * @see Permission
	 */
	public void addPermissionToAllServerGroups(ServerGroupType type, String permName, int value, boolean negated, boolean skipped) {
		asyncApi.addPermissionToAllServerGroups(type, permName, value, negated, skipped).getUninterruptibly();
	}
	/**
	 * Create a new privilege key that allows one client to join a server or channel group.
	 * <ul>
	 * <li>If {@code type} is set to {@linkplain PrivilegeKeyType#SERVER_GROUP SERVER_GROUP},
	 * {@code groupId} is used as a server group ID and {@code channelId} is ignored.</li>
	 * <li>If {@code type} is set to {@linkplain PrivilegeKeyType#CHANNEL_GROUP CHANNEL_GROUP},
	 * {@code groupId} is used as a channel group ID and {@code channelId} is used as the channel in which the group should be set.</li>
	 * </ul>
	 *
	 * @param type
	 * 		the type of token that should be created
	 * @param groupId
	 * 		the ID of the server or channel group
	 * @param channelId
	 * 		the ID of the channel, in case the token is channel group token
	 * @param description
	 * 		the description for the token, can be null
	 *
	 * @return the created token for a client to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see PrivilegeKeyType
	 * @see #addPrivilegeKeyServerGroup(int, String)
	 * @see #addPrivilegeKeyChannelGroup(int, int, String)
	 */
	public String addPrivilegeKey(PrivilegeKeyType type, int groupId, int channelId, String description) {
		return asyncApi.addPrivilegeKey(type, groupId, channelId, description).getUninterruptibly();
	}
	/**
	 * Creates a new privilege key for a channel group.
	 *
	 * @param channelGroupId
	 * 		the ID of the channel group
	 * @param channelId
	 * 		the ID of the channel in which the channel group should be set
	 * @param description
	 * 		the description for the token, can be null
	 *
	 * @return the created token for a client to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Channel#getId()
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #addPrivilegeKeyServerGroup(int, String)
	 */
	public String addPrivilegeKeyChannelGroup(int channelGroupId, int channelId, String description) {
		return asyncApi.addPrivilegeKeyChannelGroup(channelGroupId, channelId, description).getUninterruptibly();
	}
	/**
	 * Creates a new privilege key for a server group.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group
	 * @param description
	 * 		the description for the token, can be null
	 *
	 * @return the created token for a client to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #addPrivilegeKeyChannelGroup(int, int, String)
	 */
	public String addPrivilegeKeyServerGroup(int serverGroupId, String description) {
		return asyncApi.addPrivilegeKeyServerGroup(serverGroupId, description).getUninterruptibly();
	}
	/**
	 * Creates a new server group for clients using a given name and returns its ID.
	 * <p>
	 * To create server group templates or ones for server queries,
	 * use {@link #addServerGroup(String, PermissionGroupDatabaseType)}.
	 * </p>
	 *
	 * @param name
	 * 		the name of the new server group
	 *
	 * @return the ID of the newly created server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup
	 */
	public int addServerGroup(String name) {
		return asyncApi.addServerGroup(name).getUninterruptibly();
	}
	/**
	 * Creates a new server group using a given name and returns its ID.
	 *
	 * @param name
	 * 		the name of the new server group
	 * @param type
	 * 		the desired type of server group
	 *
	 * @return the ID of the newly created server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup
	 * @see PermissionGroupDatabaseType
	 */
	public int addServerGroup(String name, PermissionGroupDatabaseType type) {
		return asyncApi.addServerGroup(name, type).getUninterruptibly();
	}
	/**
	 * Adds a specified permission to a server group.
	 *
	 * @param groupId
	 * 		the ID of the channel group to which the permission should be added
	 * @param permName
	 * 		the name of the permission to add
	 * @param value
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 * @param negated
	 * 		if set to true, the lowest permission value will be selected instead of the highest
	 * @param skipped
	 * 		if set to true, this permission will not be overridden by client or channel group permissions
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see Permission
	 */
	public void addServerGroupPermission(int groupId, String permName, int value, boolean negated, boolean skipped) {
		asyncApi.addServerGroupPermission(groupId, permName, value, negated, skipped).getUninterruptibly();
	}
	/**
	 * Creates a server query login with name {@code loginName} for the client specified by {@code clientDBId}
	 * on the currently selected virtual server and returns the password of the created login.
	 * If the client already had a server query login, the existing login will be deleted and replaced.
	 * <p>
	 * Moreover, this method can be used to create new <i>global</i> server query logins that are not tied to any
	 * particular virtual server or client. To create such a server query login, make sure no virtual server is
	 * selected (e.g. use {@code selectVirtualServerById(0)}) and call this method with {@code clientDBId = 0}.
	 * </p>
	 *
	 * @param loginName
	 * 		the name of the server query login to add
	 * @param clientDBId
	 * 		the database ID of the client for which a server query login should be created
	 *
	 * @return an object containing the password of the new server query login
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #deleteServerQueryLogin(int)
	 * @see #getServerQueryLogins()
	 * @see #updateServerQueryLogin(String)
	 */
	public CreatedQueryLogin addServerQueryLogin(String loginName, int clientDBId) {
		return asyncApi.addServerQueryLogin(loginName, clientDBId).getUninterruptibly();
	}
	/**
	 * Adds one or more {@link TS3Listener}s to the event manager of the query.
	 * These listeners will be notified when the TS3 server fires an event.
	 * <p>
	 * Note that for the TS3 server to fire events, you must first also register
	 * the event types you want to listen to.
	 * </p>
	 *
	 * @param listeners
	 * 		one or more listeners to register
	 *
	 * @see #registerAllEvents()
	 * @see #registerEvent(TS3EventType, int)
	 * @see TS3Listener
	 * @see TS3EventType
	 */
	public void addTS3Listeners(TS3Listener... listeners) {
		asyncApi.addTS3Listeners(listeners);
	}
	/**
	 * Bans a client with a given client ID for a given time.
	 * <p>
	 * Please note that this will create up to three separate ban rules,
	 * one for the targeted client's IP address, one for their unique identifier,
	 * and potentially one more entry for their "myTeamSpeak" ID, if available.
	 * </p><p>
	 * <i>Exception:</i> If the banned client connects via a loopback address
	 * (i.e. {@code 127.0.0.1} or {@code localhost}), no IP ban is created.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 *
	 * @return an array containing the IDs of the created ban entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #addBan(String, String, String, long, String)
	 */
	public int[] banClient(int clientId, long timeInSeconds) {
		return asyncApi.banClient(clientId, timeInSeconds).getUninterruptibly();
	}
	/**
	 * Bans a client with a given client ID for a given time for the specified reason.
	 * <p>
	 * Please note that this will create up to three separate ban rules,
	 * one for the targeted client's IP address, one for their unique identifier,
	 * and potentially one more entry for their "myTeamSpeak" ID, if available.
	 * </p><p>
	 * <i>Exception:</i> If the banned client connects via a loopback address
	 * (i.e. {@code 127.0.0.1} or {@code localhost}), no IP ban is created.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 * @param reason
	 * 		the reason for the ban, can be null
	 *
	 * @return an array containing the IDs of the created ban entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #addBan(String, String, String, long, String)
	 */
	public int[] banClient(int clientId, long timeInSeconds, String reason) {
		return asyncApi.banClient(clientId, timeInSeconds, reason).getUninterruptibly();
	}
	/**
	 * Bans a client with a given client ID permanently for the specified reason.
	 * <p>
	 * Please note that this will create up to three separate ban rules,
	 * one for the targeted client's IP address, one for their unique identifier,
	 * and potentially one more entry for their "myTeamSpeak" ID, if available.
	 * </p><p>
	 * <i>Exception:</i> If the banned client connects via a loopback address
	 * (i.e. {@code 127.0.0.1} or {@code localhost}), no IP ban is created.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client
	 * @param reason
	 * 		the reason for the ban, can be null
	 *
	 * @return an array containing the IDs of the created ban entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #addBan(String, String, String, long, String)
	 */
	public int[] banClient(int clientId, String reason) {
		return asyncApi.banClient(clientId, reason).getUninterruptibly();
	}
	/**
	 * Bans multiple clients by their client ID for a given time for the specified reason.
	 * <p>
	 * Please note that this will create up to three separate ban rules for each client,
	 * one for the targeted client's IP address, one for their unique identifier,
	 * and potentially one more entry for their "myTeamSpeak" ID, if available.
	 * </p><p>
	 * <i>Exception:</i> If the banned client connects via a loopback address
	 * (i.e. {@code 127.0.0.1} or {@code localhost}), no IP ban is created.
	 * </p><p>
	 * <i>Exception:</i> If two or more clients are connecting from the
	 * same IP address, only one IP ban entry for that IP will be created.
	 * </p>
	 *
	 * @param clientIds
	 * 		the IDs of the clients to be banned
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 * @param reason
	 * 		the reason for the ban, can be null
	 * @param continueOnError
	 * 		if true, continue to the next client if banning one client fails, else do not create any bans on error
	 *
	 * @return an array containing the IDs of the created ban entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #addBan(String, String, String, long, String)
	 */
	public int[] banClients(int[] clientIds, long timeInSeconds, String reason, boolean continueOnError) {
		return asyncApi.banClients(clientIds, timeInSeconds, reason, continueOnError).getUninterruptibly();
	}
	/**
	 * Sends a text message to all clients on all virtual servers.
	 * These messages will appear to clients in the tab for server messages.
	 *
	 * @param message
	 * 		the message to be sent
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void broadcast(String message) {
		asyncApi.broadcast(message).getUninterruptibly();
	}
	/**
	 * Creates a copy of the channel group specified by {@code sourceGroupId},
	 * overwriting any other channel group specified by {@code targetGroupId}.
	 * <p>
	 * The parameter {@code type} can be used to create server query and template groups.
	 * </p>
	 *
	 * @param sourceGroupId
	 * 		the ID of the channel group to copy
	 * @param targetGroupId
	 * 		the ID of another channel group to overwrite
	 * @param type
	 * 		the desired type of channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 */
	public void copyChannelGroup(int sourceGroupId, int targetGroupId, PermissionGroupDatabaseType type) {
		asyncApi.copyChannelGroup(sourceGroupId, targetGroupId, type).getUninterruptibly();
	}
	/**
	 * Creates a copy of the channel group specified by {@code sourceGroupId} with a given name
	 * and returns the ID of the newly created channel group.
	 *
	 * @param sourceGroupId
	 * 		the ID of the channel group to copy
	 * @param targetName
	 * 		the name for the copy of the channel group
	 * @param type
	 * 		the desired type of channel group
	 *
	 * @return the ID of the newly created channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 */
	public int copyChannelGroup(int sourceGroupId, String targetName, PermissionGroupDatabaseType type) {
		return asyncApi.copyChannelGroup(sourceGroupId, targetName, type).getUninterruptibly();
	}
	/**
	 * Creates a copy of the server group specified by {@code sourceGroupId},
	 * overwriting another server group specified by {@code targetGroupId}.
	 * <p>
	 * The parameter {@code type} can be used to create server query and template groups.
	 * </p>
	 *
	 * @param sourceGroupId
	 * 		the ID of the server group to copy
	 * @param targetGroupId
	 * 		the ID of another server group to overwrite
	 * @param type
	 * 		the desired type of server group
	 *
	 * @return the ID of the newly created server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 */
	public int copyServerGroup(int sourceGroupId, int targetGroupId, PermissionGroupDatabaseType type) {
		return asyncApi.copyServerGroup(sourceGroupId, targetGroupId, type).getUninterruptibly();
	}
	/**
	 * Creates a copy of the server group specified by {@code sourceGroupId} with a given name
	 * and returns the ID of the newly created server group.
	 *
	 * @param sourceGroupId
	 * 		the ID of the server group to copy
	 * @param targetName
	 * 		the name for the copy of the server group
	 * @param type
	 * 		the desired type of server group
	 *
	 * @return the ID of the newly created server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 */
	public int copyServerGroup(int sourceGroupId, String targetName, PermissionGroupDatabaseType type) {
		return asyncApi.copyServerGroup(sourceGroupId, targetName, type).getUninterruptibly();
	}
	/**
	 * Creates a new channel with a given name using the given properties and returns its ID.
	 *
	 * @param name
	 * 		the name for the new channel
	 * @param options
	 * 		a map of options that should be set for the channel
	 *
	 * @return the ID of the newly created channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel
	 */
	public int createChannel(String name, Map<ChannelProperty, String> options) {
		return asyncApi.createChannel(name, options).getUninterruptibly();
	}
	/**
	 * Creates a new directory on the file repository in the specified channel.
	 *
	 * @param directoryPath
	 * 		the path to the directory that should be created
	 * @param channelId
	 * 		the ID of the channel the directory should be created in
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public void createFileDirectory(String directoryPath, int channelId) {
		asyncApi.createFileDirectory(directoryPath, channelId).getUninterruptibly();
	}
	/**
	 * Creates a new directory on the file repository in the specified channel.
	 *
	 * @param directoryPath
	 * 		the path to the directory that should be created
	 * @param channelId
	 * 		the ID of the channel the directory should be created in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public void createFileDirectory(String directoryPath, int channelId, String channelPassword) {
		asyncApi.createFileDirectory(directoryPath, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Creates a new virtual server with the given name and returns an object containing the ID of the newly
	 * created virtual server, the default server admin token and the virtual server's voice port. Usually,
	 * the virtual server is also automatically started. This can be turned off on the TS3 server, though.
	 * <p>
	 * If {@link VirtualServerProperty#VIRTUALSERVER_PORT} is not specified in the virtual server properties,
	 * the server will test for the first unused UDP port.
	 * </p><p>
	 * Please also note that creating virtual servers usually requires the server query admin account
	 * and that there is a limit to how many virtual servers can be created, which is dependent on your license.
	 * Unlicensed TS3 server instances are limited to 1 virtual server with up to 32 client slots.
	 * </p>
	 *
	 * @param name
	 * 		the name for the new virtual server
	 * @param options
	 * 		a map of options that should be set for the virtual server
	 *
	 * @return information about the newly created virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer
	 */
	public CreatedVirtualServer createServer(String name, Map<VirtualServerProperty, String> options) {
		return asyncApi.createServer(name, options).getUninterruptibly();
	}
	/**
	 * Creates a {@link Snapshot} of the selected virtual server containing all settings,
	 * groups and known client identities. The data from a server snapshot can be
	 * used to restore a virtual servers configuration.
	 *
	 * @return a snapshot of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #deployServerSnapshot(Snapshot)
	 */
	public Snapshot createServerSnapshot() {
		return asyncApi.createServerSnapshot().getUninterruptibly();
	}
	/**
	 * Deletes all active ban rules from the server. Use with caution.
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void deleteAllBans() {
		asyncApi.deleteAllBans().getUninterruptibly();
	}
	/**
	 * Deletes all complaints about the client with specified database ID from the server.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Complaint
	 */
	public void deleteAllComplaints(int clientDBId) {
		asyncApi.deleteAllComplaints(clientDBId).getUninterruptibly();
	}
	/**
	 * Deletes the ban rule with the specified ID from the server.
	 *
	 * @param banId
	 * 		the ID of the ban to delete
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Ban#getId()
	 */
	public void deleteBan(int banId) {
		asyncApi.deleteBan(banId).getUninterruptibly();
	}
	/**
	 * Deletes an existing channel specified by its ID, kicking all clients out of the channel.
	 *
	 * @param channelId
	 * 		the ID of the channel to delete
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #deleteChannel(int, boolean)
	 * @see #kickClientFromChannel(String, int...)
	 */
	public void deleteChannel(int channelId) {
		asyncApi.deleteChannel(channelId).getUninterruptibly();
	}
	/**
	 * Deletes an existing channel with a given ID.
	 * If {@code force} is true, the channel will be deleted even if there are clients within,
	 * else the command will fail in this situation.
	 *
	 * @param channelId
	 * 		the ID of the channel to delete
	 * @param force
	 * 		whether clients should be kicked out of the channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #kickClientFromChannel(String, int...)
	 */
	public void deleteChannel(int channelId, boolean force) {
		asyncApi.deleteChannel(channelId, force).getUninterruptibly();
	}
	/**
	 * Removes a specified permission from a client in a specific channel.
	 *
	 * @param channelId
	 * 		the ID of the channel wherein the permission should be removed
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 * @see Permission#getName()
	 */
	public void deleteChannelClientPermission(int channelId, int clientDBId, String permName) {
		asyncApi.deleteChannelClientPermission(channelId, clientDBId, permName).getUninterruptibly();
	}
	/**
	 * Removes the channel group with the given ID.
	 *
	 * @param groupId
	 * 		the ID of the channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 */
	public void deleteChannelGroup(int groupId) {
		asyncApi.deleteChannelGroup(groupId).getUninterruptibly();
	}
	/**
	 * Removes the channel group with the given ID.
	 * If {@code force} is true, the channel group will be deleted even if it still contains clients,
	 * else the command will fail in this situation.
	 *
	 * @param groupId
	 * 		the ID of the channel group
	 * @param force
	 * 		whether the channel group should be deleted even if it still contains clients
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 */
	public void deleteChannelGroup(int groupId, boolean force) {
		asyncApi.deleteChannelGroup(groupId, force).getUninterruptibly();
	}
	/**
	 * Removes a permission from the channel group with the given ID.
	 *
	 * @param groupId
	 * 		the ID of the channel group
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Permission#getName()
	 */
	public void deleteChannelGroupPermission(int groupId, String permName) {
		asyncApi.deleteChannelGroupPermission(groupId, permName).getUninterruptibly();
	}
	/**
	 * Removes a permission from the channel with the given ID.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Permission#getName()
	 */
	public void deleteChannelPermission(int channelId, String permName) {
		asyncApi.deleteChannelPermission(channelId, permName).getUninterruptibly();
	}
	/**
	 * Removes a permission from a client.
	 *
	 * @deprecated
	 * This method is no longer preferred for removing permissions from a client.
	 * <p>
	 * Use {@link TS3Api#deleteClientPermission(int, IPermissionType)}
	 * or {@link TS3Api#deleteClientPermission(int, BPermissionType)} instead.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission#getName()
	 */
	@Deprecated
	public void deleteClientPermission(int clientDBId, String permName) {
		asyncApi.deleteClientPermission(clientDBId, permName).getUninterruptibly();
	}
	/**
	 * Removes a permission from a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param permName
	 * 		the enum of the permission to revoke
	 * 		@see IPermissionType
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission#getName()
	 */
	public void deleteClientPermission(int clientDBId, IPermissionType permName) {
		asyncApi.deleteClientPermission(clientDBId, permName).getUninterruptibly();
	}
	/**
	 * Removes a permission from a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param permName
	 * 		the enum of the permission to revoke
	 * 		@see BPermissionType
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission#getName()
	 */
	public void deleteClientPermission(int clientDBId, BPermissionType permName) {
		asyncApi.deleteClientPermission(clientDBId, permName).getUninterruptibly();
	}
	/**
	 * Deletes the complaint about the client with database ID {@code targetClientDBId} submitted by
	 * the client with database ID {@code fromClientDBId} from the server.
	 *
	 * @param targetClientDBId
	 * 		the database ID of the client the complaint is about
	 * @param fromClientDBId
	 * 		the database ID of the client who added the complaint
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Complaint
	 * @see Client#getDatabaseId()
	 */
	public void deleteComplaint(int targetClientDBId, int fromClientDBId) {
		asyncApi.deleteComplaint(targetClientDBId, fromClientDBId).getUninterruptibly();
	}
	/**
	 * Removes the {@code key} custom client property from a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the target client
	 * @param key
	 * 		the key of the custom property to delete, cannot be {@code null}
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 */
	public void deleteCustomClientProperty(int clientDBId, String key) {
		asyncApi.deleteCustomClientProperty(clientDBId, key).getUninterruptibly();
	}
	/**
	 * Removes all stored database information about the specified client.
	 * Please note that this data is also automatically removed after a configured time (usually 90 days).
	 * <p>
	 * See {@link DatabaseClientInfo} for a list of stored information about a client.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #getDatabaseClientInfo(int)
	 * @see DatabaseClientInfo
	 */
	public void deleteDatabaseClientProperties(int clientDBId) {
		asyncApi.deleteDatabaseClientProperties(clientDBId).getUninterruptibly();
	}
	/**
	 * Deletes a file or directory from the file repository in the specified channel.
	 *
	 * @param filePath
	 * 		the path to the file or directory
	 * @param channelId
	 * 		the ID of the channel the file or directory resides in
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public void deleteFile(String filePath, int channelId) {
		asyncApi.deleteFile(filePath, channelId).getUninterruptibly();
	}
	/**
	 * Deletes a file or directory from the file repository in the specified channel.
	 *
	 * @param filePath
	 * 		the path to the file or directory
	 * @param channelId
	 * 		the ID of the channel the file or directory resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public void deleteFile(String filePath, int channelId, String channelPassword) {
		asyncApi.deleteFile(filePath, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Deletes multiple files or directories from the file repository in the specified channel.
	 *
	 * @param filePaths
	 * 		the paths to the files or directories
	 * @param channelId
	 * 		the ID of the channel the file or directory resides in
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public void deleteFiles(String[] filePaths, int channelId) {
		asyncApi.deleteFiles(filePaths, channelId).getUninterruptibly();
	}
	/**
	 * Deletes multiple files or directories from the file repository in the specified channel.
	 *
	 * @param filePaths
	 * 		the paths to the files or directories
	 * @param channelId
	 * 		the ID of the channel the file or directory resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public void deleteFiles(String[] filePaths, int channelId, String channelPassword) {
		asyncApi.deleteFiles(filePaths, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Deletes an icon from the icon directory in the file repository.
	 *
	 * @param iconId
	 * 		the ID of the icon to delete
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 */
	public void deleteIcon(long iconId) {
		asyncApi.deleteIcon(iconId).getUninterruptibly();
	}
	/**
	 * Deletes multiple icons from the icon directory in the file repository.
	 *
	 * @param iconIds
	 * 		the IDs of the icons to delete
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 */
	public void deleteIcons(long... iconIds) {
		asyncApi.deleteIcons(iconIds).getUninterruptibly();
	}
	/**
	 * Deletes the offline message with the specified ID.
	 *
	 * @param messageId
	 * 		the ID of the offline message to delete
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Message#getId()
	 */
	public void deleteOfflineMessage(int messageId) {
		asyncApi.deleteOfflineMessage(messageId).getUninterruptibly();
	}
	/**
	 * Removes a specified permission from all server groups of the type specified by {@code type} on all virtual servers.
	 *
	 * @param type
	 * 		the kind of server group this permission should be removed from
	 * @param permName
	 * 		the name of the permission to remove
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroupType
	 * @see Permission#getName()
	 */
	public void deletePermissionFromAllServerGroups(ServerGroupType type, String permName) {
		asyncApi.deletePermissionFromAllServerGroups(type, permName).getUninterruptibly();
	}
	/**
	 * Deletes the privilege key with the given token.
	 *
	 * @param token
	 * 		the token of the privilege key
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see PrivilegeKey
	 */
	public void deletePrivilegeKey(String token) {
		asyncApi.deletePrivilegeKey(token).getUninterruptibly();
	}
	/**
	 * Deletes the virtual server with the specified ID.
	 * <p>
	 * Only stopped virtual servers can be deleted.
	 * </p>
	 *
	 * @param serverId
	 * 		the ID of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getId()
	 * @see #stopServer(int)
	 */
	public void deleteServer(int serverId) {
		asyncApi.deleteServer(serverId).getUninterruptibly();
	}
	/**
	 * Deletes the server group with the specified ID, even if the server group still contains clients.
	 *
	 * @param groupId
	 * 		the ID of the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 */
	public void deleteServerGroup(int groupId) {
		asyncApi.deleteServerGroup(groupId).getUninterruptibly();
	}
	/**
	 * Deletes a server group with the specified ID.
	 * <p>
	 * If {@code force} is true, the server group will be deleted even if it contains clients,
	 * else the command will fail in this situation.
	 * </p>
	 *
	 * @param groupId
	 * 		the ID of the server group
	 * @param force
	 * 		whether the server group should be deleted if it still contains clients
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 */
	public void deleteServerGroup(int groupId, boolean force) {
		asyncApi.deleteServerGroup(groupId, force).getUninterruptibly();
	}
	/**
	 * Removes a permission from the server group with the given ID.
	 *
	 * @param groupId
	 * 		the ID of the server group
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see Permission#getName()
	 */
	public void deleteServerGroupPermission(int groupId, String permName) {
		asyncApi.deleteServerGroupPermission(groupId, permName).getUninterruptibly();
	}
	/**
	 * Deletes the server query login with the specified client database ID.
	 * <p>
	 * If you only know the name of the server query login, use {@link #getServerQueryLoginsByName(String)} first.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the client database ID of the server query login (usually the ID of the associated client)
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addServerQueryLogin(String, int)
	 * @see #getServerQueryLogins()
	 * @see #updateServerQueryLogin(String)
	 */
	public void deleteServerQueryLogin(int clientDBId) {
		asyncApi.deleteServerQueryLogin(clientDBId).getUninterruptibly();
	}
	/**
	 * Restores the selected virtual servers configuration using the data from a
	 * previously created server snapshot.
	 *
	 * @param snapshot
	 * 		the snapshot to restore
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #createServerSnapshot()
	 */
	public void deployServerSnapshot(Snapshot snapshot) {
		asyncApi.deployServerSnapshot(snapshot).getUninterruptibly();
	}
	/**
	 * Restores the configuration of the selected virtual server using the data from a
	 * previously created server snapshot.
	 *
	 * @param snapshot
	 * 		the snapshot to restore
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #createServerSnapshot()
	 */
	public void deployServerSnapshot(String snapshot) {
		asyncApi.deployServerSnapshot(snapshot).getUninterruptibly();
	}
	/**
	 * Downloads a file from the file repository at a given path and channel
	 * and writes the file's bytes to an open {@link OutputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code OutputStream} is
	 * open and to close the stream again once the download has finished.
	 * </p><p>
	 * Note that this method will not read the entire file to memory and can thus
	 * download arbitrarily sized files from the file repository.
	 * </p>
	 *
	 * @param dataOut
	 * 		a stream that the downloaded data should be written to
	 * @param filePath
	 * 		the path of the file on the file repository
	 * @param channelId
	 * 		the ID of the channel to download the file from
	 *
	 * @return how many bytes were downloaded
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #downloadFileDirect(String, int)
	 */
	public long downloadFile(OutputStream dataOut, String filePath, int channelId) {
		return asyncApi.downloadFile(dataOut, filePath, channelId).getUninterruptibly();
	}
	/**
	 * Downloads a file from the file repository at a given path and channel
	 * and writes the file's bytes to an open {@link OutputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code OutputStream} is
	 * open and to close the stream again once the download has finished.
	 * </p><p>
	 * Note that this method will not read the entire file to memory and can thus
	 * download arbitrarily sized files from the file repository.
	 * </p>
	 *
	 * @param dataOut
	 * 		a stream that the downloaded data should be written to
	 * @param filePath
	 * 		the path of the file on the file repository
	 * @param channelId
	 * 		the ID of the channel to download the file from
	 * @param channelPassword
	 * 		that channel's password
	 *
	 * @return how many bytes were downloaded
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #downloadFileDirect(String, int, String)
	 */
	public long downloadFile(OutputStream dataOut, String filePath, int channelId, String channelPassword) {
		return asyncApi.downloadFile(dataOut, filePath, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Downloads a file from the file repository at a given path and channel
	 * and returns the file's bytes as a byte array.
	 * <p>
	 * Note that this method <strong>will read the entire file to memory</strong>.
	 * That means that if a file is larger than 2<sup>31</sup>-1 bytes in size,
	 * the download will fail.
	 * </p>
	 *
	 * @param filePath
	 * 		the path of the file on the file repository
	 * @param channelId
	 * 		the ID of the channel to download the file from
	 *
	 * @return a byte array containing the file's data
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #downloadFile(OutputStream, String, int)
	 */
	public byte[] downloadFileDirect(String filePath, int channelId) {
		return asyncApi.downloadFileDirect(filePath, channelId).getUninterruptibly();
	}
	/**
	 * Downloads a file from the file repository at a given path and channel
	 * and returns the file's bytes as a byte array.
	 * <p>
	 * Note that this method <strong>will read the entire file to memory</strong>.
	 * That means that if a file is larger than 2<sup>31</sup>-1 bytes in size,
	 * the download will fail.
	 * </p>
	 *
	 * @param filePath
	 * 		the path of the file on the file repository
	 * @param channelId
	 * 		the ID of the channel to download the file from
	 * @param channelPassword
	 * 		that channel's password
	 *
	 * @return a byte array containing the file's data
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #downloadFile(OutputStream, String, int, String)
	 */
	public byte[] downloadFileDirect(String filePath, int channelId, String channelPassword) {
		return asyncApi.downloadFileDirect(filePath, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Downloads an icon from the icon directory in the file repository
	 * and writes the file's bytes to an open {@link OutputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code OutputStream} is
	 * open and to close the stream again once the download has finished.
	 * </p>
	 *
	 * @param dataOut
	 * 		a stream that the downloaded data should be written to
	 * @param iconId
	 * 		the ID of the icon that should be downloaded
	 *
	 * @return a byte array containing the icon file's data
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 * @see #downloadIconDirect(long)
	 * @see #uploadIcon(InputStream, long)
	 */
	public long downloadIcon(OutputStream dataOut, long iconId) {
		return asyncApi.downloadIcon(dataOut, iconId).getUninterruptibly();
	}
	/**
	 * Downloads an icon from the icon directory in the file repository
	 * and returns the file's bytes as a byte array.
	 * <p>
	 * Note that this method <strong>will read the entire file to memory</strong>.
	 * </p>
	 *
	 * @param iconId
	 * 		the ID of the icon that should be downloaded
	 *
	 * @return a byte array containing the icon file's data
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 * @see #downloadIcon(OutputStream, long)
	 * @see #uploadIconDirect(byte[])
	 */
	public byte[] downloadIconDirect(long iconId) {
		return asyncApi.downloadIconDirect(iconId).getUninterruptibly();
	}
	/**
	 * Changes a channel's configuration using the given properties.
	 *
	 * @param channelId
	 * 		the ID of the channel to edit
	 * @param options
	 * 		the map of properties to modify
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 */
	public void editChannel(int channelId, Map<ChannelProperty, String> options) {
		asyncApi.editChannel(channelId, options).getUninterruptibly();
	}
	/**
	 * Changes a single property of the given channel.
	 * <p>
	 * Note that one can set many properties at once with the overloaded method that
	 * takes a map of channel properties and strings.
	 * </p>
	 *
	 * @param channelId
	 * 		the ID of the channel to edit
	 * @param property
	 * 		the channel property to modify, make sure it is editable
	 * @param value
	 * 		the new value of the property
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #editChannel(int, Map)
	 */
	public void editChannel(int channelId, ChannelProperty property, String value) {
		asyncApi.editChannel(channelId, property, value).getUninterruptibly();
	}
	/**
	 * Changes a client's configuration using given properties.
	 * <p>
	 * Only {@link ClientProperty#CLIENT_DESCRIPTION} can be changed for other clients.
	 * To update the current client's properties, use {@link #updateClient(Map)}
	 * or {@link #updateClient(ClientProperty, String)}.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to edit
	 * @param options
	 * 		the map of properties to modify
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #updateClient(Map)
	 */
	public void editClient(int clientId, Map<ClientProperty, String> options) {
		asyncApi.editClient(clientId, options).getUninterruptibly();
	}
	/**
	 * Changes a single property of the given client.
	 * <p>
	 * Only {@link ClientProperty#CLIENT_DESCRIPTION} can be changed for other clients.
	 * To update the current client's properties, use {@link #updateClient(Map)}
	 * or {@link #updateClient(ClientProperty, String)}.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to edit
	 * @param property
	 * 		the client property to modify, make sure it is editable
	 * @param value
	 * 		the new value of the property
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #editClient(int, Map)
	 * @see #updateClient(Map)
	 */
	public void editClient(int clientId, ClientProperty property, String value) {
		asyncApi.editClient(clientId, property, value).getUninterruptibly();
	}
	/**
	 * Changes a client's database settings using given properties.
	 *
	 * @param clientDBId
	 * 		the database ID of the client to edit
	 * @param options
	 * 		the map of properties to modify
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see DatabaseClientInfo
	 * @see Client#getDatabaseId()
	 */
	public void editDatabaseClient(int clientDBId, Map<ClientProperty, String> options) {
		asyncApi.editDatabaseClient(clientDBId, options).getUninterruptibly();
	}
	/**
	 * Changes the server instance configuration using given properties.
	 * If the given property is not changeable, {@code IllegalArgumentException} will be thrown.
	 *
	 * @param property
	 * 		the property to edit, must be changeable
	 * @param value
	 * 		the new value for the edit
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code property} is not changeable
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerInstanceProperty#isChangeable()
	 */
	public void editInstance(ServerInstanceProperty property, String value) {
		asyncApi.editInstance(property, value).getUninterruptibly();
	}
	/**
	 * Changes the configuration of the selected virtual server using given properties.
	 *
	 * @param options
	 * 		the map of properties to edit
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServerProperty
	 */
	public void editServer(Map<VirtualServerProperty, String> options) {
		asyncApi.editServer(options).getUninterruptibly();
	}
	/**
	 * Gets a list of all bans on the selected virtual server.
	 *
	 * @return a list of all bans on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Ban
	 */
	public List<Ban> getBans() {
		return asyncApi.getBans().getUninterruptibly();
	}
	/**
	 * Gets a list of IP addresses used by the server instance.
	 *
	 * @return the list of bound IP addresses
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Binding
	 */
	public List<Binding> getBindings() {
		return asyncApi.getBindings().getUninterruptibly();
	}
	/**
	 * Finds and returns the channel matching the given name exactly.
	 *
	 * @param name
	 * 		the name of the channel
	 * @param ignoreCase
	 * 		whether the case of the name should be ignored
	 *
	 * @return the found channel or {@code null} if no channel was found
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel
	 * @see #getChannelsByName(String)
	 */
	public Channel getChannelByNameExact(String name, boolean ignoreCase) {
		return asyncApi.getChannelByNameExact(name, ignoreCase).getUninterruptibly();
	}
	/**
	 * Gets a list of channels whose names contain the given search string.
	 *
	 * @param name
	 * 		the name to search
	 *
	 * @return a list of all channels with names matching the search pattern
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Channel
	 * @see #getChannelByNameExact(String, boolean)
	 */
	public List<Channel> getChannelsByName(String name) {
		return asyncApi.getChannelsByName(name).getUninterruptibly();
	}
	/**
	 * Displays a list of permissions defined for a client in a specific channel.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return a list of permissions for the user in the specified channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public List<Permission> getChannelClientPermissions(int channelId, int clientDBId) {
		return asyncApi.getChannelClientPermissions(channelId, clientDBId).getUninterruptibly();
	}
	/**
	 * Gets all client / channel ID combinations currently assigned to channel groups.
	 * All three parameters are optional and can be turned off by setting it to {@code -1}.
	 *
	 * @param channelId
	 * 		restricts the search to the channel with a specified ID. Set to {@code -1} to ignore.
	 * @param clientDBId
	 * 		restricts the search to the client with a specified database ID. Set to {@code -1} to ignore.
	 * @param groupId
	 * 		restricts the search to the channel group with the specified ID. Set to {@code -1} to ignore.
	 *
	 * @return a list of combinations of channel ID, client database ID and channel group ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 * @see ChannelGroup#getId()
	 * @see ChannelGroupClient
	 */
	public List<ChannelGroupClient> getChannelGroupClients(int channelId, int clientDBId, int groupId) {
		return asyncApi.getChannelGroupClients(channelId, clientDBId, groupId).getUninterruptibly();
	}
	/**
	 * Gets all client / channel ID combinations currently assigned to the specified channel group.
	 *
	 * @param groupId
	 * 		the ID of the channel group whose client / channel assignments should be returned.
	 *
	 * @return a list of combinations of channel ID, client database ID and channel group ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see ChannelGroupClient
	 * @see #getChannelGroupClients(int, int, int)
	 */
	public List<ChannelGroupClient> getChannelGroupClientsByChannelGroupId(int groupId) {
		return asyncApi.getChannelGroupClientsByChannelGroupId(groupId).getUninterruptibly();
	}
	/**
	 * Gets all channel group assignments in the specified channel.
	 *
	 * @param channelId
	 * 		the ID of the channel whose channel group assignments should be returned.
	 *
	 * @return a list of combinations of channel ID, client database ID and channel group ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see ChannelGroupClient
	 * @see #getChannelGroupClients(int, int, int)
	 */
	public List<ChannelGroupClient> getChannelGroupClientsByChannelId(int channelId) {
		return asyncApi.getChannelGroupClientsByChannelId(channelId).getUninterruptibly();
	}
	/**
	 * Gets all channel group assignments for the specified client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client whose channel group
	 *
	 * @return a list of combinations of channel ID, client database ID and channel group ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see ChannelGroupClient
	 * @see #getChannelGroupClients(int, int, int)
	 */
	public List<ChannelGroupClient> getChannelGroupClientsByClientDBId(int clientDBId) {
		return asyncApi.getChannelGroupClientsByClientDBId(clientDBId).getUninterruptibly();
	}
	/**
	 * Gets a list of all permissions assigned to the specified channel group.
	 *
	 * @param groupId
	 * 		the ID of the channel group.
	 *
	 * @return a list of permissions assigned to the channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Permission
	 */
	public List<Permission> getChannelGroupPermissions(int groupId) {
		return asyncApi.getChannelGroupPermissions(groupId).getUninterruptibly();
	}
	/**
	 * Gets a list of all channel groups on the selected virtual server.
	 *
	 * @return a list of all channel groups on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup
	 */
	public List<ChannelGroup> getChannelGroups() {
		return asyncApi.getChannelGroups().getUninterruptibly();
	}
	/**
	 * Gets detailed configuration information about the channel specified channel.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 *
	 * @return information about the channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see ChannelInfo
	 */
	public ChannelInfo getChannelInfo(int channelId) {
		return asyncApi.getChannelInfo(channelId).getUninterruptibly();
	}
	/**
	 * Gets a list of all permissions assigned to the specified channel.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 *
	 * @return a list of all permissions assigned to the channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Permission
	 */
	public List<Permission> getChannelPermissions(int channelId) {
		return asyncApi.getChannelPermissions(channelId).getUninterruptibly();
	}
	/**
	 * Gets a list of all channels on the selected virtual server.
	 *
	 * @return a list of all channels on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel
	 */
	public List<Channel> getChannels() {
		return asyncApi.getChannels().getUninterruptibly();
	}
	/**
	 * Finds and returns the client whose nickname matches the given name exactly.
	 *
	 * @param name
	 * 		the name of the client
	 * @param ignoreCase
	 * 		whether the case of the name should be ignored
	 *
	 * @return the found client or {@code null} if no client was found
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client
	 * @see #getClientsByName(String)
	 */
	public Client getClientByNameExact(String name, boolean ignoreCase) {
		return asyncApi.getClientByNameExact(name, ignoreCase).getUninterruptibly();
	}
	/**
	 * Gets a list of clients whose nicknames contain the given search string.
	 *
	 * @param name
	 * 		the name to search
	 *
	 * @return a list of all clients with nicknames matching the search pattern
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Client
	 * @see #getClientByNameExact(String, boolean)
	 */
	public List<Client> getClientsByName(String name) {
		return asyncApi.getClientsByName(name).getUninterruptibly();
	}
	/**
	 * Gets information about the client with the specified unique identifier.
	 *
	 * @param clientUId
	 * 		the unique identifier of the client
	 *
	 * @return information about the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Client#getUniqueIdentifier()
	 * @see ClientInfo
	 */
	public ClientInfo getClientByUId(String clientUId) {
		return asyncApi.getClientByUId(clientUId).getUninterruptibly();
	}
	/**
	 * Gets information about the client with the specified client ID.
	 *
	 * @param clientId
	 * 		the client ID of the client
	 *
	 * @return information about the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see ClientInfo
	 */
	public ClientInfo getClientInfo(int clientId) {
		return asyncApi.getClientInfo(clientId).getUninterruptibly();
	}
	/**
	 * Gets a list of all permissions assigned to the specified client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return a list of all permissions assigned to the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public List<Permission> getClientPermissions(int clientDBId) {
		return asyncApi.getClientPermissions(clientDBId).getUninterruptibly();
	}
	/**
	 * Gets a list of all clients on the selected virtual server.
	 *
	 * @return a list of all clients on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client
	 */
	public List<Client> getClients() {
		return asyncApi.getClients().getUninterruptibly();
	}
	/**
	 * Gets a list of all complaints on the selected virtual server.
	 *
	 * @return a list of all complaints on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Complaint
	 * @see #getComplaints(int)
	 */
	public List<Complaint> getComplaints() {
		return asyncApi.getComplaints().getUninterruptibly();
	}
	/**
	 * Gets a list of all complaints about the specified client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return a list of all complaints about the specified client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Complaint
	 */
	public List<Complaint> getComplaints(int clientDBId) {
		return asyncApi.getComplaints(clientDBId).getUninterruptibly();
	}
	/**
	 * Gets detailed connection information about the selected virtual server.
	 *
	 * @return connection information about the selected virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ConnectionInfo
	 * @see #getServerInfo()
	 */
	public ConnectionInfo getConnectionInfo() {
		return asyncApi.getConnectionInfo().getUninterruptibly();
	}
	/**
	 * Gets a map of all custom client properties and their values
	 * assigned to the client with database ID {@code clientDBId}.
	 *
	 * @param clientDBId
	 * 		the database ID of the target client
	 *
	 * @return a map of the client's custom client property assignments
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #searchCustomClientProperty(String)
	 * @see #searchCustomClientProperty(String, String)
	 */
	public Map<String, String> getCustomClientProperties(int clientDBId) {
		return asyncApi.getCustomClientProperties(clientDBId).getUninterruptibly();
	}
	/**
	 * Gets all clients in the database whose last nickname matches the specified name <b>exactly</b>.
	 *
	 * @param name
	 * 		the nickname for the clients to match
	 *
	 * @return a list of all clients with a matching nickname
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1 + n,
	 * where n is the amount of database clients with a matching nickname
	 * @see Client#getNickname()
	 */
	public List<DatabaseClientInfo> getDatabaseClientsByName(String name) {
		return asyncApi.getDatabaseClientsByName(name).getUninterruptibly();
	}
	/**
	 * Gets information about the client with the specified unique identifier in the server database.
	 *
	 * @param clientUId
	 * 		the unique identifier of the client
	 *
	 * @return the database client or {@code null} if no client was found
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Client#getUniqueIdentifier()
	 * @see DatabaseClientInfo
	 */
	public DatabaseClientInfo getDatabaseClientByUId(String clientUId) {
		return asyncApi.getDatabaseClientByUId(clientUId).getUninterruptibly();
	}
	/**
	 * Gets information about the client with the specified database ID in the server database.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return the database client or {@code null} if no client was found
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see DatabaseClientInfo
	 */
	public DatabaseClientInfo getDatabaseClientInfo(int clientDBId) {
		return asyncApi.getDatabaseClientInfo(clientDBId).getUninterruptibly();
	}
	/**
	 * Gets information about all clients in the server database.
	 * <p>
	 * As this method uses internal commands which can only return 200 clients at once,
	 * this method can take quite some time to execute.
	 * </p><p>
	 * Also keep in mind that the client database can easily accumulate several thousand entries.
	 * </p>
	 *
	 * @return a {@link List} of all database clients
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1 + n,
	 * where n = Math.ceil([amount of database clients] / 200)
	 * @see DatabaseClient
	 */
	public List<DatabaseClient> getDatabaseClients() {
		return asyncApi.getDatabaseClients().getUninterruptibly();
	}
	/**
	 * Gets information about a set number of clients in the server database, starting at {@code offset}.
	 *
	 * @param offset
	 * 		the index of the first database client to be returned.
	 * 		Note that this is <b>not</b> a database ID, but an arbitrary, 0-based index.
	 * @param count
	 * 		the number of database clients that should be returned.
	 * 		Any integer greater than 200 might cause problems with the connection
	 *
	 * @return a {@link List} of database clients
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see DatabaseClient
	 */
	public List<DatabaseClient> getDatabaseClients(int offset, int count) {
		return asyncApi.getDatabaseClients(offset, count).getUninterruptibly();
	}
	/**
	 * Gets information about a file on the file repository in the specified channel.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePath
	 * 		the path to the file
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 *
	 * @return some information about the file
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public FileInfo getFileInfo(String filePath, int channelId) {
		return asyncApi.getFileInfo(filePath, channelId).getUninterruptibly();
	}
	/**
	 * Gets information about a file on the file repository in the specified channel.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePath
	 * 		the path to the file
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return some information about the file
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public FileInfo getFileInfo(String filePath, int channelId, String channelPassword) {
		return asyncApi.getFileInfo(filePath, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Gets information about multiple files on the file repository in the specified channel.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePaths
	 * 		the paths to the files
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 *
	 * @return some information about the file
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public List<FileInfo> getFileInfos(String[] filePaths, int channelId) {
		return asyncApi.getFileInfos(filePaths, channelId).getUninterruptibly();
	}
	/**
	 * Gets information about multiple files on the file repository in the specified channel.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePaths
	 * 		the paths to the files
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return some information about the file
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public List<FileInfo> getFileInfos(String[] filePaths, int channelId, String channelPassword) {
		return asyncApi.getFileInfos(filePaths, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Gets information about multiple files on the file repository in multiple channels.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePaths
	 * 		the paths to the files, may not be {@code null} and may not contain {@code null} elements
	 * @param channelIds
	 * 		the IDs of the channels the file resides in, may not be {@code null}
	 * @param channelPasswords
	 * 		the passwords of those channels, may be {@code null} and may contain {@code null} elements
	 *
	 * @return some information about the files
	 *
	 * @throws IllegalArgumentException
	 * 		if the dimensions of {@code filePaths}, {@code channelIds} and {@code channelPasswords} don't match
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public List<FileInfo> getFileInfos(String[] filePaths, int[] channelIds, String[] channelPasswords) {
		return asyncApi.getFileInfos(filePaths, channelIds, channelPasswords).getUninterruptibly();
	}
	/**
	 * Gets a list of files and directories in the specified parent directory and channel.
	 *
	 * @param directoryPath
	 * 		the path to the parent directory
	 * @param channelId
	 * 		the ID of the channel the directory resides in
	 *
	 * @return the files and directories in the parent directory
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public List<FileListEntry> getFileList(String directoryPath, int channelId) {
		return asyncApi.getFileList(directoryPath, channelId).getUninterruptibly();
	}
	/**
	 * Gets a list of files and directories in the specified parent directory and channel.
	 *
	 * @param directoryPath
	 * 		the path to the parent directory
	 * @param channelId
	 * 		the ID of the channel the directory resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return the files and directories in the parent directory
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public List<FileListEntry> getFileList(String directoryPath, int channelId, String channelPassword) {
		return asyncApi.getFileList(directoryPath, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Gets a list of active or recently active file transfers.
	 *
	 * @return a list of file transfers
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<FileTransfer> getFileTransfers() {
		return asyncApi.getFileTransfers().getUninterruptibly();
	}
	/**
	 * Displays detailed configuration information about the server instance including
	 * uptime, number of virtual servers online, traffic information, etc.
	 *
	 * @return information about the host
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public HostInfo getHostInfo() {
		return asyncApi.getHostInfo().getUninterruptibly();
	}
	/**
	 * Gets a list of all icon files on this virtual server.
	 *
	 * @return a list of all icons
	 */
	public List<IconFile> getIconList() {
		return asyncApi.getIconList().getUninterruptibly();
	}
	/**
	 * Displays the server instance configuration including database revision number,
	 * the file transfer port, default group IDs, etc.
	 *
	 * @return information about the TeamSpeak server instance.
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public InstanceInfo getInstanceInfo() {
		return asyncApi.getInstanceInfo().getUninterruptibly();
	}
	/**
	 * Fetches the specified amount of log entries from the server log.
	 *
	 * @param lines
	 * 		the amount of log entries to fetch, in the range between 1 and 100.
	 * 		Returns 100 entries if the argument is not in range
	 *
	 * @return a list of the latest log entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<String> getInstanceLogEntries(int lines) {
		return asyncApi.getInstanceLogEntries(lines).getUninterruptibly();
	}
	/**
	 * Fetches the last 100 log entries from the server log.
	 *
	 * @return a list of up to 100 log entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<String> getInstanceLogEntries() {
		return asyncApi.getInstanceLogEntries().getUninterruptibly();
	}
	/**
	 * Reads the message body of a message. This will not set the read flag, though.
	 *
	 * @param messageId
	 * 		the ID of the message to be read
	 *
	 * @return the body of the message with the specified ID or {@code null} if there was no message with that ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Message#getId()
	 * @see #setMessageRead(int)
	 */
	public String getOfflineMessage(int messageId) {
		return asyncApi.getOfflineMessage(messageId).getUninterruptibly();
	}
	/**
	 * Reads the message body of a message. This will not set the read flag, though.
	 *
	 * @param message
	 * 		the message to be read
	 *
	 * @return the body of the message with the specified ID or {@code null} if there was no message with that ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Message#getId()
	 * @see #setMessageRead(Message)
	 */
	public String getOfflineMessage(Message message) {
		return asyncApi.getOfflineMessage(message).getUninterruptibly();
	}
	/**
	 * Gets a list of all offline messages for the server query.
	 * The returned messages lack their message body, though.
	 * To read the actual message, use {@link #getOfflineMessage(int)} or {@link #getOfflineMessage(Message)}.
	 *
	 * @return a list of all offline messages this server query has received
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<Message> getOfflineMessages() {
		return asyncApi.getOfflineMessages().getUninterruptibly();
	}
	/**
	 * Displays detailed information about all assignments of the permission specified
	 * with {@code permName}. The output includes the type and the ID of the client,
	 * channel or group associated with the permission.
	 *
	 * @param permName
	 * 		the name of the permission
	 *
	 * @return a list of permission assignments
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #getPermissionOverview(int, int)
	 */
	public List<PermissionAssignment> getPermissionAssignments(String permName) {
		return asyncApi.getPermissionAssignments(permName).getUninterruptibly();
	}
	/**
	 * Gets the ID of the permission specified by {@code permName}.
	 * <p>
	 * Note that the use of numeric permission IDs is deprecated
	 * and that this API only uses the string variant of the IDs.
	 * </p>
	 *
	 * @param permName
	 * 		the name of the permission
	 *
	 * @return the numeric ID of the specified permission
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public int getPermissionIdByName(String permName) {
		return asyncApi.getPermissionIdByName(permName).getUninterruptibly();
	}
	/**
	 * Gets the IDs of the permissions specified by {@code permNames}.
	 * <p>
	 * Note that the use of numeric permission IDs is deprecated
	 * and that this API only uses the string variant of the IDs.
	 * </p>
	 *
	 * @param permNames
	 * 		the names of the permissions
	 *
	 * @return the numeric IDs of the specified permission
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code permNames} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public int[] getPermissionIdsByName(String... permNames) {
		return asyncApi.getPermissionIdsByName(permNames).getUninterruptibly();
	}
	/**
	 * Gets a list of all assigned permissions for a client in a specified channel.
	 * If you do not care about channel permissions, set {@code channelId} to {@code 0}.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 * @param clientDBId
	 * 		the database ID of the client to create the overview for
	 *
	 * @return a list of all permission assignments for the client in the specified channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 */
	public List<PermissionAssignment> getPermissionOverview(int channelId, int clientDBId) {
		return asyncApi.getPermissionOverview(channelId, clientDBId).getUninterruptibly();
	}
	/**
	 * Displays a list of all permissions, including ID, name and description.
	 *
	 * @return a list of all permissions
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<PermissionInfo> getPermissions() {
		return asyncApi.getPermissions().getUninterruptibly();
	}
	/**
	 * Displays the current value of the specified permission for this server query instance.
	 *
	 * @param permName
	 * 		the name of the permission
	 *
	 * @return the permission value, usually ranging from 0 to 100
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public int getPermissionValue(String permName) {
		return asyncApi.getPermissionValue(permName).getUninterruptibly();
	}
	/**
	 * Displays the current values of the specified permissions for this server query instance.
	 *
	 * @param permNames
	 * 		the names of the permissions
	 *
	 * @return the permission values, usually ranging from 0 to 100
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code permNames} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public int[] getPermissionValues(String... permNames) {
		return asyncApi.getPermissionValues(permNames).getUninterruptibly();
	}
	/**
	 * Gets a list of all available tokens to join channel or server groups,
	 * including their type and group IDs.
	 *
	 * @return a list of all generated, but still unclaimed privilege keys
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #usePrivilegeKey(String)
	 */
	public List<PrivilegeKey> getPrivilegeKeys() {
		return asyncApi.getPrivilegeKeys().getUninterruptibly();
	}
	/**
	 * Gets a list of all clients in the specified server group.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group for which the clients should be looked up
	 *
	 * @return a list of all clients in the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<ServerGroupClient> getServerGroupClients(int serverGroupId) {
		return asyncApi.getServerGroupClients(serverGroupId).getUninterruptibly();
	}
	/**
	 * Gets a list of all clients in the specified server group.
	 *
	 * @param serverGroup
	 * 		the server group for which the clients should be looked up
	 *
	 * @return a list of all clients in the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<ServerGroupClient> getServerGroupClients(ServerGroup serverGroup) {
		return asyncApi.getServerGroupClients(serverGroup).getUninterruptibly();
	}
	/**
	 * Gets a list of all permissions assigned to the specified server group.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group for which the permissions should be looked up
	 *
	 * @return a list of all permissions assigned to the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see #getServerGroupPermissions(ServerGroup)
	 */
	public List<Permission> getServerGroupPermissions(int serverGroupId) {
		return asyncApi.getServerGroupPermissions(serverGroupId).getUninterruptibly();
	}
	/**
	 * Gets a list of all permissions assigned to the specified server group.
	 *
	 * @param serverGroup
	 * 		the server group for which the permissions should be looked up
	 *
	 * @return a list of all permissions assigned to the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<Permission> getServerGroupPermissions(ServerGroup serverGroup) {
		return asyncApi.getServerGroupPermissions(serverGroup).getUninterruptibly();
	}
	/**
	 * Gets a list of all server groups on the virtual server.
	 * <p>
	 * Depending on your permissions, the output may also contain
	 * global server query groups and template groups.
	 * </p>
	 *
	 * @return a list of all server groups
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<ServerGroup> getServerGroups() {
		return asyncApi.getServerGroups().getUninterruptibly();
	}
	/**
	 * Gets a list of all server groups set for a client.
	 *
	 * @param clientDatabaseId
	 * 		the database ID of the client for which the server groups should be looked up
	 *
	 * @return a list of all server groups set for the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Client#getDatabaseId()
	 * @see #getServerGroupsByClient(Client)
	 */
	public List<ServerGroup> getServerGroupsByClientId(int clientDatabaseId) {
		return asyncApi.getServerGroupsByClientId(clientDatabaseId).getUninterruptibly();
	}
	/**
	 * Gets a list of all server groups set for a client.
	 *
	 * @param client
	 * 		the client for which the server groups should be looked up
	 *
	 * @return a list of all server group set for the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see #getServerGroupsByClientId(int)
	 */
	public List<ServerGroup> getServerGroupsByClient(Client client) {
		return asyncApi.getServerGroupsByClient(client).getUninterruptibly();
	}
	/**
	 * Gets the ID of a virtual server by its port.
	 *
	 * @param port
	 * 		the port of a virtual server
	 *
	 * @return the ID of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getPort()
	 * @see VirtualServer#getId()
	 */
	public int getServerIdByPort(int port) {
		return asyncApi.getServerIdByPort(port).getUninterruptibly();
	}
	/**
	 * Gets detailed information about the virtual server the server query is currently in.
	 *
	 * @return information about the current virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public VirtualServerInfo getServerInfo() {
		return asyncApi.getServerInfo().getUninterruptibly();
	}
	/**
	 * Gets a list of all server query logins (containing login name, virtual server ID, and client database ID).
	 * If a virtual server is selected, only the server query logins of the selected virtual server are returned.
	 *
	 * @return a list of {@code QueryLogin} objects describing existing server query logins
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addServerQueryLogin(String, int)
	 * @see #deleteServerQueryLogin(int)
	 * @see #getServerQueryLoginsByName(String)
	 * @see #updateServerQueryLogin(String)
	 */
	public List<QueryLogin> getServerQueryLogins() {
		return asyncApi.getServerQueryLogins().getUninterruptibly();
	}
	/**
	 * Gets a list of all server query logins (containing login name, virtual server ID, and client database ID)
	 * whose login name matches the specified SQL-like pattern.
	 * If a virtual server is selected, only the server query logins of the selected virtual server are returned.
	 *
	 * @param pattern
	 * 		the SQL-like pattern to match the server query login name against
	 *
	 * @return a list of {@code QueryLogin} objects describing existing server query logins
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addServerQueryLogin(String, int)
	 * @see #deleteServerQueryLogin(int)
	 * @see #getServerQueryLogins()
	 * @see #updateServerQueryLogin(String)
	 */
	public List<QueryLogin> getServerQueryLoginsByName(String pattern) {
		return asyncApi.getServerQueryLoginsByName(pattern).getUninterruptibly();
	}
	/**
	 * Gets the version, build number and platform of the TeamSpeak3 server.
	 *
	 * @return the version information of the server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public Version getVersion() {
		return asyncApi.getVersion().getUninterruptibly();
	}
	/**
	 * Gets a list of all virtual servers including their ID, status, number of clients online, etc.
	 *
	 * @return a list of all virtual servers
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<VirtualServer> getVirtualServers() {
		return asyncApi.getVirtualServers().getUninterruptibly();
	}
	/**
	 * Fetches the specified amount of log entries from the currently selected virtual server.
	 * If no virtual server is selected, the entries will be read from the server log instead.
	 *
	 * @param lines
	 * 		the amount of log entries to fetch, in the range between 1 and 100.
	 * 		Returns 100 entries if the argument is not in range
	 *
	 * @return a list of the latest log entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<String> getVirtualServerLogEntries(int lines) {
		return asyncApi.getVirtualServerLogEntries(lines).getUninterruptibly();
	}
	/**
	 * Fetches the last 100 log entries from the currently selected virtual server.
	 * If no virtual server is selected, the entries will be read from the server log instead.
	 *
	 * @return a list of up to 100 log entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public List<String> getVirtualServerLogEntries() {
		return asyncApi.getVirtualServerLogEntries().getUninterruptibly();
	}
	/**
	 * Checks whether the client with the specified client ID is online.
	 * <p>
	 * Please note that there is no guarantee that the client will still be
	 * online by the time the next command is executed.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client
	 *
	 * @return {@code true} if the client is online, {@code false} otherwise
	 *
	 * @querycommands 1
	 * @see #getClientInfo(int)
	 */
	public boolean isClientOnline(int clientId) {
		return asyncApi.isClientOnline(clientId).getUninterruptibly();
	}
	/**
	 * Checks whether the client with the specified unique identifier is online.
	 * <p>
	 * Please note that there is no guarantee that the client will still be
	 * online by the time the next command is executed.
	 * </p>
	 *
	 * @param clientUId
	 * 		the unique ID of the client
	 *
	 * @return {@code true} if the client is online, {@code false} otherwise
	 *
	 * @querycommands 1
	 * @see #getClientByUId(String)
	 */
	public boolean isClientOnline(String clientUId) {
		return asyncApi.isClientOnline(clientUId).getUninterruptibly();
	}
	/**
	 * Kicks one or more clients from their current channels.
	 * This will move the kicked clients into the default channel and
	 * won't do anything if the clients are already in the default channel.
	 *
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromChannel(Client...)
	 * @see #kickClientFromChannel(String, int...)
	 */
	public void kickClientFromChannel(int... clientIds) {
		asyncApi.kickClientFromChannel(clientIds).getUninterruptibly();
	}
	/**
	 * Kicks one or more clients from their current channels.
	 * This will move the kicked clients into the default channel and
	 * won't do anything if the clients are already in the default channel.
	 *
	 * @param clients
	 * 		the clients to kick
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromChannel(int...)
	 * @see #kickClientFromChannel(String, Client...)
	 */
	public void kickClientFromChannel(Client... clients) {
		asyncApi.kickClientFromChannel(clients).getUninterruptibly();
	}
	/**
	 * Kicks one or more clients from their current channels for the specified reason.
	 * This will move the kicked clients into the default channel and
	 * won't do anything if the clients are already in the default channel.
	 *
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #kickClientFromChannel(int...)
	 * @see #kickClientFromChannel(String, Client...)
	 */
	public void kickClientFromChannel(String message, int... clientIds) {
		asyncApi.kickClientFromChannel(message, clientIds).getUninterruptibly();
	}
	/**
	 * Kicks one or more clients from their current channels for the specified reason.
	 * This will move the kicked clients into the default channel and
	 * won't do anything if the clients are already in the default channel.
	 *
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clients
	 * 		the clients to kick
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromChannel(Client...)
	 * @see #kickClientFromChannel(String, int...)
	 */
	public void kickClientFromChannel(String message, Client... clients) {
		asyncApi.kickClientFromChannel(message, clients).getUninterruptibly();
	}
	/**
	 * Kicks one or more clients from the server.
	 *
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #kickClientFromServer(Client...)
	 * @see #kickClientFromServer(String, int...)
	 */
	public void kickClientFromServer(int... clientIds) {
		asyncApi.kickClientFromServer(clientIds).getUninterruptibly();
	}
	/**
	 * Kicks one or more clients from the server.
	 *
	 * @param clients
	 * 		the clients to kick
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromServer(int...)
	 * @see #kickClientFromServer(String, Client...)
	 */
	public void kickClientFromServer(Client... clients) {
		asyncApi.kickClientFromServer(clients).getUninterruptibly();
	}
	/**
	 * Kicks one or more clients from the server for the specified reason.
	 *
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #kickClientFromServer(int...)
	 * @see #kickClientFromServer(String, Client...)
	 */
	public void kickClientFromServer(String message, int... clientIds) {
		asyncApi.kickClientFromServer(message, clientIds).getUninterruptibly();
	}
	/**
	 * Kicks one or more clients from the server for the specified reason.
	 *
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clients
	 * 		the clients to kick
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromServer(Client...)
	 * @see #kickClientFromServer(String, int...)
	 */
	public void kickClientFromServer(String message, Client... clients) {
		asyncApi.kickClientFromServer(message, clients).getUninterruptibly();
	}
	/**
	 * Logs the server query in using the specified username and password.
	 * <p>
	 * Note that you can also set the login in the {@link TS3Config},
	 * so that you will be logged in right after the connection is established.
	 * </p>
	 *
	 * @param username
	 * 		the username of the server query
	 * @param password
	 * 		the password to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #logout()
	 */
	public void login(String username, String password) {
		asyncApi.login(username, password).getUninterruptibly();
	}
	/**
	 * Logs the server query out and deselects the current virtual server.
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #login(String, String)
	 */
	public void logout() {
		asyncApi.logout().getUninterruptibly();
	}
	/**
	 * Moves a channel to a new parent channel specified by its ID.
	 * To move a channel to root level, set {@code channelTargetId} to {@code 0}.
	 * <p>
	 * This will move the channel right below the specified parent channel, above all other child channels.
	 * This command will fail if the channel already has the specified target channel as the parent channel.
	 * </p>
	 *
	 * @param channelId
	 * 		the channel to move
	 * @param channelTargetId
	 * 		the new parent channel for the specified channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #moveChannel(int, int, int)
	 */
	public void moveChannel(int channelId, int channelTargetId) {
		asyncApi.moveChannel(channelId, channelTargetId).getUninterruptibly();
	}
	/**
	 * Moves a channel to a new parent channel specified by its ID.
	 * To move a channel to root level, set {@code channelTargetId} to {@code 0}.
	 * <p>
	 * The channel will be ordered below the channel with the ID specified by {@code order}.
	 * To move the channel right below the parent channel, set {@code order} to {@code 0}.
	 * </p><p>
	 * Note that you can't re-order a channel without also changing its parent channel with this method.
	 * Use {@link #editChannel(int, ChannelProperty, String)} to change {@link ChannelProperty#CHANNEL_ORDER} instead.
	 * </p>
	 *
	 * @param channelId
	 * 		the channel to move
	 * @param channelTargetId
	 * 		the new parent channel for the specified channel
	 * @param order
	 * 		the channel to sort the specified channel below
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #moveChannel(int, int)
	 */
	public void moveChannel(int channelId, int channelTargetId, int order) {
		asyncApi.moveChannel(channelId, channelTargetId, order).getUninterruptibly();
	}
	/**
	 * Moves a single client into a channel.
	 * <p>
	 * Consider using {@link #moveClients(int[], int)} to move multiple clients.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to move
	 * @param channelId
	 * 		the ID of the channel to move the client into
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see Channel#getId()
	 */
	public void moveClient(int clientId, int channelId) {
		asyncApi.moveClient(clientId, channelId).getUninterruptibly();
	}
	/**
	 * Moves multiple clients into a channel.
	 * Immediately returns {@code true} for an empty client ID array.
	 * <p>
	 * Use this method instead of {@link #moveClient(int, int)} for moving
	 * several clients as this will only send 1 command to the server and thus complete faster.
	 * </p>
	 *
	 * @param clientIds
	 * 		the IDs of the clients to move, cannot be {@code null}
	 * @param channelId
	 * 		the ID of the channel to move the clients into
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code clientIds} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see Channel#getId()
	 */
	public void moveClients(int[] clientIds, int channelId) {
		asyncApi.moveClients(clientIds, channelId).getUninterruptibly();
	}
	/**
	 * Moves a single client into a channel.
	 * <p>
	 * Consider using {@link #moveClients(Client[], ChannelBase)} to move multiple clients.
	 * </p>
	 *
	 * @param client
	 * 		the client to move, cannot be {@code null}
	 * @param channel
	 * 		the channel to move the client into, cannot be {@code null}
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code client} or {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void moveClient(Client client, ChannelBase channel) {
		asyncApi.moveClient(client, channel).getUninterruptibly();
	}
	/**
	 * Moves multiple clients into a channel.
	 * Immediately returns {@code true} for an empty client array.
	 * <p>
	 * Use this method instead of {@link #moveClient(Client, ChannelBase)} for moving
	 * several clients as this will only send 1 command to the server and thus complete faster.
	 * </p>
	 *
	 * @param clients
	 * 		the clients to move, cannot be {@code null}
	 * @param channel
	 * 		the channel to move the clients into, cannot be {@code null}
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code clients} or {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void moveClients(Client[] clients, ChannelBase channel) {
		asyncApi.moveClients(clients, channel).getUninterruptibly();
	}
	/**
	 * Moves a single client into a channel using the specified password.
	 * <p>
	 * Consider using {@link #moveClients(int[], int, String)} to move multiple clients.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to move
	 * @param channelId
	 * 		the ID of the channel to move the client into
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see Channel#getId()
	 */
	public void moveClient(int clientId, int channelId, String channelPassword) {
		asyncApi.moveClient(clientId, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Moves multiple clients into a channel using the specified password.
	 * Immediately returns {@code true} for an empty client ID array.
	 * <p>
	 * Use this method instead of {@link #moveClient(int, int, String)} for moving
	 * several clients as this will only send 1 command to the server and thus complete faster.
	 * </p>
	 *
	 * @param clientIds
	 * 		the IDs of the clients to move, cannot be {@code null}
	 * @param channelId
	 * 		the ID of the channel to move the clients into
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code clientIds} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see Channel#getId()
	 */
	public void moveClients(int[] clientIds, int channelId, String channelPassword) {
		asyncApi.moveClients(clientIds, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Moves a single client into a channel using the specified password.
	 * <p>
	 * Consider using {@link #moveClients(Client[], ChannelBase, String)} to move multiple clients.
	 * </p>
	 *
	 * @param client
	 * 		the client to move, cannot be {@code null}
	 * @param channel
	 * 		the channel to move the client into, cannot be {@code null}
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code client} or {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void moveClient(Client client, ChannelBase channel, String channelPassword) {
		asyncApi.moveClient(client, channel, channelPassword).getUninterruptibly();
	}
	/**
	 * Moves multiple clients into a channel using the specified password.
	 * Immediately returns {@code true} for an empty client array.
	 * <p>
	 * Use this method instead of {@link #moveClient(Client, ChannelBase, String)} for moving
	 * several clients as this will only send 1 command to the server and thus complete faster.
	 * </p>
	 *
	 * @param clients
	 * 		the clients to move, cannot be {@code null}
	 * @param channel
	 * 		the channel to move the clients into, cannot be {@code null}
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code clients} or {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void moveClients(Client[] clients, ChannelBase channel, String channelPassword) {
		asyncApi.moveClients(clients, channel, channelPassword).getUninterruptibly();
	}
	/**
	 * Moves and renames a file on the file repository within the same channel.
	 *
	 * @param oldPath
	 * 		the current path to the file
	 * @param newPath
	 * 		the desired new path
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #moveFile(String, String, int, int) moveFile to a different channel
	 */
	public void moveFile(String oldPath, String newPath, int channelId) {
		asyncApi.moveFile(oldPath, newPath, channelId).getUninterruptibly();
	}
	/**
	 * Renames a file on the file repository and moves it to a new path in a different channel.
	 *
	 * @param oldPath
	 * 		the current path to the file
	 * @param newPath
	 * 		the desired new path
	 * @param oldChannelId
	 * 		the ID of the channel the file currently resides in
	 * @param newChannelId
	 * 		the ID of the channel the file should be moved to
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #moveFile(String, String, int) moveFile within the same channel
	 */
	public void moveFile(String oldPath, String newPath, int oldChannelId, int newChannelId) {
		asyncApi.moveFile(oldPath, newPath, oldChannelId, newChannelId).getUninterruptibly();
	}
	/**
	 * Moves and renames a file on the file repository within the same channel.
	 *
	 * @param oldPath
	 * 		the current path to the file
	 * @param newPath
	 * 		the desired new path
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 * @param channelPassword
	 * 		the password of the channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #moveFile(String, String, int, String, int, String) moveFile to a different channel
	 */
	public void moveFile(String oldPath, String newPath, int channelId, String channelPassword) {
		asyncApi.moveFile(oldPath, newPath, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Renames a file on the file repository and moves it to a new path in a different channel.
	 *
	 * @param oldPath
	 * 		the current path to the file
	 * @param newPath
	 * 		the desired new path
	 * @param oldChannelId
	 * 		the ID of the channel the file currently resides in
	 * @param oldPassword
	 * 		the password of the current channel
	 * @param newChannelId
	 * 		the ID of the channel the file should be moved to
	 * @param newPassword
	 * 		the password of the new channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #moveFile(String, String, int, String) moveFile within the same channel
	 */
	public void moveFile(String oldPath, String newPath, int oldChannelId, String oldPassword, int newChannelId, String newPassword) {
		asyncApi.moveFile(oldPath, newPath, oldChannelId, oldPassword, newChannelId, newPassword).getUninterruptibly();
	}
	/**
	 * Moves the server query into a channel.
	 *
	 * @param channelId
	 * 		the ID of the channel to move the server query into
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 */
	public void moveQuery(int channelId) {
		asyncApi.moveQuery(channelId).getUninterruptibly();
	}
	/**
	 * Moves the server query into a channel.
	 *
	 * @param channel
	 * 		the channel to move the server query into, cannot be {@code null}
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void moveQuery(ChannelBase channel) {
		asyncApi.moveQuery(channel).getUninterruptibly();
	}
	/**
	 * Moves the server query into a channel using the specified password.
	 *
	 * @param channelId
	 * 		the ID of the channel to move the client into
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 */
	public void moveQuery(int channelId, String channelPassword) {
		asyncApi.moveQuery(channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Moves the server query into a channel using the specified password.
	 *
	 * @param channel
	 * 		the channel to move the client into, cannot be {@code null}
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void moveQuery(ChannelBase channel, String channelPassword) {
		asyncApi.moveQuery(channel, channelPassword).getUninterruptibly();
	}
	/**
	 * Pokes the client with the specified client ID.
	 * This opens up a small popup window for the client containing your message and plays a sound.
	 * The displayed message will be formatted like this: <br>
	 * {@code hh:mm:ss - "Your Nickname" poked you: <your message in green color>}
	 * <p>
	 * The displayed message length is limited to 100 UTF-8 bytes.
	 * If a client has already received a poke message, all subsequent pokes will simply add a line
	 * to the already opened popup window and will still play a sound.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to poke
	 * @param message
	 * 		the message to send, may contain BB codes
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 */
	public void pokeClient(int clientId, String message) {
		asyncApi.pokeClient(clientId, message).getUninterruptibly();
	}
	/**
	 * Terminates the connection with the TeamSpeak3 server.
	 * <p>
	 * This command should never be executed by a user of this API,
	 * as it leaves the query in an undefined state. To terminate
	 * a connection regularly, use {@link TS3Query#exit()}.
	 * </p>
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	void quit() {
		asyncApi.quit().getUninterruptibly();
	}
	/**
	 * Registers the server query to receive notifications about all server events.
	 * <p>
	 * This means that the following actions will trigger event notifications:
	 * </p>
	 * <ul>
	 * <li>A client joins the server or disconnects from it</li>
	 * <li>A client switches channels</li>
	 * <li>A client sends a server message</li>
	 * <li>A client sends a channel message <b>in the channel the query is in</b></li>
	 * <li>A client sends a private message to <b>the server query</b></li>
	 * <li>A client uses a privilege key</li>
	 * </ul>
	 * <p>
	 * The limitations to when the query receives notifications about chat events cannot be circumvented.
	 * </p>
	 * To be able to process these events in your application, register an event listener.
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 6
	 * @see #addTS3Listeners(TS3Listener...)
	 */
	public void registerAllEvents() {
		asyncApi.registerAllEvents().getUninterruptibly();
	}
	/**
	 * Registers the server query to receive notifications about a given event type.
	 * <p>
	 * If used with {@link TS3EventType#TEXT_CHANNEL}, this will listen to chat events in the current channel.
	 * If used with {@link TS3EventType#CHANNEL}, this will listen to <b>all</b> channel events.
	 * To specify a different channel for channel events, use {@link #registerEvent(TS3EventType, int)}.
	 * </p>
	 *
	 * @param eventType
	 * 		the event type to be notified about
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addTS3Listeners(TS3Listener...)
	 * @see #registerEvent(TS3EventType, int)
	 * @see #registerAllEvents()
	 */
	public void registerEvent(TS3EventType eventType) {
		asyncApi.registerEvent(eventType).getUninterruptibly();
	}
	/**
	 * Registers the server query to receive notifications about a given event type.
	 *
	 * @param eventType
	 * 		the event type to be notified about
	 * @param channelId
	 * 		the ID of the channel to listen to, will be ignored if set to {@code -1}.
	 * 		Can be set to {@code 0} for {@link TS3EventType#CHANNEL} to receive notifications about all channel switches.
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #addTS3Listeners(TS3Listener...)
	 * @see #registerAllEvents()
	 */
	public void registerEvent(TS3EventType eventType, int channelId) {
		asyncApi.registerEvent(eventType, channelId).getUninterruptibly();
	}
	/**
	 * Registers the server query to receive notifications about multiple given event types.
	 * <p>
	 * If used with {@link TS3EventType#TEXT_CHANNEL}, this will listen to chat events in the current channel.
	 * If used with {@link TS3EventType#CHANNEL}, this will listen to <b>all</b> channel events.
	 * To specify a different channel for channel events, use {@link #registerEvent(TS3EventType, int)}.
	 * </p>
	 *
	 * @param eventTypes
	 * 		the event types to be notified about
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands n, one command per TS3EventType
	 * @see #addTS3Listeners(TS3Listener...)
	 * @see #registerEvent(TS3EventType, int)
	 * @see #registerAllEvents()
	 */
	public void registerEvents(TS3EventType... eventTypes) {
		asyncApi.registerEvents(eventTypes).getUninterruptibly();
	}
	/**
	 * Removes the client specified by its database ID from the specified server group.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group
	 * @param clientDatabaseId
	 * 		the database ID of the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see Client#getDatabaseId()
	 * @see #removeClientFromServerGroup(ServerGroup, Client)
	 */
	public void removeClientFromServerGroup(int serverGroupId, int clientDatabaseId) {
		asyncApi.removeClientFromServerGroup(serverGroupId, clientDatabaseId).getUninterruptibly();
	}
	/**
	 * Removes the specified client from the specified server group.
	 *
	 * @param serverGroup
	 * 		the server group to remove the client from
	 * @param client
	 * 		the client to remove from the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #removeClientFromServerGroup(int, int)
	 */
	public void removeClientFromServerGroup(ServerGroup serverGroup, Client client) {
		asyncApi.removeClientFromServerGroup(serverGroup, client).getUninterruptibly();
	}
	/**
	 * Removes one or more {@link TS3Listener}s to the event manager of the query.
	 * <p>
	 * If a listener was not actually registered, it will be ignored and no exception will be thrown.
	 * </p>
	 *
	 * @param listeners
	 * 		one or more listeners to remove
	 *
	 * @see #addTS3Listeners(TS3Listener...)
	 * @see TS3Listener
	 * @see TS3EventType
	 */
	public void removeTS3Listeners(TS3Listener... listeners) {
		asyncApi.removeTS3Listeners(listeners);
	}
	/**
	 * Renames the channel group with the specified ID.
	 *
	 * @param channelGroupId
	 * 		the ID of the channel group to rename
	 * @param name
	 * 		the new name for the channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see #renameChannelGroup(ChannelGroup, String)
	 */
	public void renameChannelGroup(int channelGroupId, String name) {
		asyncApi.renameChannelGroup(channelGroupId, name).getUninterruptibly();
	}
	/**
	 * Renames the specified channel group.
	 *
	 * @param channelGroup
	 * 		the channel group to rename
	 * @param name
	 * 		the new name for the channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #renameChannelGroup(int, String)
	 */
	public void renameChannelGroup(ChannelGroup channelGroup, String name) {
		asyncApi.renameChannelGroup(channelGroup, name).getUninterruptibly();
	}
	/**
	 * Renames the server group with the specified ID.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group to rename
	 * @param name
	 * 		the new name for the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see #renameServerGroup(ServerGroup, String)
	 */
	public void renameServerGroup(int serverGroupId, String name) {
		asyncApi.renameServerGroup(serverGroupId, name).getUninterruptibly();
	}
	/**
	 * Renames the specified server group.
	 *
	 * @param serverGroup
	 * 		the server group to rename
	 * @param name
	 * 		the new name for the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #renameServerGroup(int, String)
	 */
	public void renameServerGroup(ServerGroup serverGroup, String name) {
		asyncApi.renameServerGroup(serverGroup, name).getUninterruptibly();
	}
	/**
	 * Resets all permissions and deletes all server / channel groups. Use carefully.
	 *
	 * @return a token for a new administrator account
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public String resetPermissions() {
		return asyncApi.resetPermissions().getUninterruptibly();
	}
	/**
	 * Finds all clients that have any value associated with the {@code key} custom client property,
	 * and returns the client's database ID and the key and value of the matching custom property.
	 *
	 * @param key
	 * 		the key to search for, cannot be {@code null}
	 *
	 * @return a list of client database IDs and their matching custom client properties
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #searchCustomClientProperty(String, String)
	 * @see #getCustomClientProperties(int)
	 */
	public List<CustomPropertyAssignment> searchCustomClientProperty(String key) {
		return asyncApi.searchCustomClientProperty(key).getUninterruptibly();
	}
	/**
	 * Finds all clients whose value associated with the {@code key} custom client property matches the
	 * SQL-like pattern {@code valuePattern}, and returns the client's database ID and the key and value
	 * of the matching custom property.
	 * <p>
	 * Patterns are case insensitive. They support the wildcard characters {@code %}, which matches any sequence of
	 * zero or more characters, and {@code _}, which matches exactly one arbitrary character.
	 * </p>
	 *
	 * @param key
	 * 		the key to search for, cannot be {@code null}
	 * @param valuePattern
	 * 		the pattern that values need to match to be included
	 *
	 * @return a list of client database IDs and their matching custom client properties
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #searchCustomClientProperty(String)
	 * @see #getCustomClientProperties(int)
	 */
	public List<CustomPropertyAssignment> searchCustomClientProperty(String key, String valuePattern) {
		return asyncApi.searchCustomClientProperty(key, valuePattern).getUninterruptibly();
	}
	/**
	 * Moves the server query into the virtual server with the specified ID.
	 *
	 * @param id
	 * 		the ID of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getId()
	 * @see #selectVirtualServerById(int, String)
	 * @see #selectVirtualServerByPort(int)
	 * @see #selectVirtualServer(VirtualServer)
	 */
	public void selectVirtualServerById(int id) {
		asyncApi.selectVirtualServerById(id).getUninterruptibly();
	}
	/**
	 * Moves the server query into the virtual server with the specified ID
	 * and sets the server query's nickname.
	 * <p>
	 * The nickname must be between 3 and 30 UTF-8 bytes long. BB codes will be ignored.
	 * </p>
	 *
	 * @param id
	 * 		the ID of the virtual server
	 * @param nickname
	 * 		the nickname, or {@code null} if the nickname should not be set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getId()
	 * @see #selectVirtualServerById(int)
	 * @see #selectVirtualServerByPort(int, String)
	 * @see #selectVirtualServer(VirtualServer, String)
	 */
	public void selectVirtualServerById(int id, String nickname) {
		asyncApi.selectVirtualServerById(id, nickname).getUninterruptibly();
	}
	/**
	 * Moves the server query into the virtual server with the specified voice port.
	 *
	 * @param port
	 * 		the voice port of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getPort()
	 * @see #selectVirtualServerById(int)
	 * @see #selectVirtualServerByPort(int, String)
	 * @see #selectVirtualServer(VirtualServer)
	 */
	public void selectVirtualServerByPort(int port) {
		asyncApi.selectVirtualServerByPort(port).getUninterruptibly();
	}
	/**
	 * Moves the server query into the virtual server with the specified voice port
	 * and sets the server query's nickname.
	 * <p>
	 * The nickname must be between 3 and 30 UTF-8 bytes long. BB codes will be ignored.
	 * </p>
	 *
	 * @param port
	 * 		the voice port of the virtual server
	 * @param nickname
	 * 		the nickname, or {@code null} if the nickname should not be set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getPort()
	 * @see #selectVirtualServerById(int, String)
	 * @see #selectVirtualServerByPort(int)
	 * @see #selectVirtualServer(VirtualServer, String)
	 */
	public void selectVirtualServerByPort(int port, String nickname) {
		asyncApi.selectVirtualServerByPort(port, nickname).getUninterruptibly();
	}
	/**
	 * Moves the server query into the specified virtual server.
	 *
	 * @param server
	 * 		the virtual server to move into
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #selectVirtualServerById(int)
	 * @see #selectVirtualServerByPort(int)
	 * @see #selectVirtualServer(VirtualServer, String)
	 */
	public void selectVirtualServer(VirtualServer server) {
		asyncApi.selectVirtualServer(server).getUninterruptibly();
	}
	/**
	 * Moves the server query into the specified virtual server
	 * and sets the server query's nickname.
	 * <p>
	 * The nickname must be between 3 and 30 UTF-8 bytes long. BB codes will be ignored.
	 * </p>
	 *
	 * @param server
	 * 		the virtual server to move into
	 * @param nickname
	 * 		the nickname, or {@code null} if the nickname should not be set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #selectVirtualServerById(int, String)
	 * @see #selectVirtualServerByPort(int, String)
	 * @see #selectVirtualServer(VirtualServer)
	 */
	public void selectVirtualServer(VirtualServer server, String nickname) {
		asyncApi.selectVirtualServer(server, nickname).getUninterruptibly();
	}
	/**
	 * Sends an offline message to the client with the given unique identifier.
	 * <p>
	 * The message subject's length is limited to 200 UTF-8 bytes and BB codes in it will be ignored.
	 * The message body's length is limited to 4096 UTF-8 bytes and accepts BB codes
	 * </p>
	 *
	 * @param clientUId
	 * 		the unique identifier of the client to send the message to
	 * @param subject
	 * 		the subject for the message, may not contain BB codes
	 * @param message
	 * 		the actual message body, may contain BB codes
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getUniqueIdentifier()
	 * @see Message
	 */
	public void sendOfflineMessage(String clientUId, String subject, String message) {
		asyncApi.sendOfflineMessage(clientUId, subject, message).getUninterruptibly();
	}
	/**
	 * Sends a text message either to the whole virtual server, a channel or specific client.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 * <p>
	 * To send a message to all virtual servers, use {@link #broadcast(String)}.
	 * To send an offline message, use {@link #sendOfflineMessage(String, String, String)}.
	 * </p>
	 *
	 * @param targetMode
	 * 		where the message should be sent to
	 * @param targetId
	 * 		the client ID of the recipient of this message. This value is ignored unless {@code targetMode} is {@code CLIENT}
	 * @param message
	 * 		the text message to send
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 */
	public void sendTextMessage(TextMessageTargetMode targetMode, int targetId, String message) {
		asyncApi.sendTextMessage(targetMode, targetId, message).getUninterruptibly();
	}
	/**
	 * Sends a text message to the channel with the specified ID.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 * <p>
	 * This will move the client into the channel with the specified channel ID,
	 * <b>but will not move it back to the original channel!</b>
	 * </p>
	 *
	 * @param channelId
	 * 		the ID of the channel to which the message should be sent to
	 * @param message
	 * 		the text message to send
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #sendChannelMessage(String)
	 * @see Channel#getId()
	 */
	public void sendChannelMessage(int channelId, String message) {
		asyncApi.sendChannelMessage(channelId, message).getUninterruptibly();
	}
	/**
	 * Sends a text message to the channel the server query is currently in.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 *
	 * @param message
	 * 		the text message to send
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void sendChannelMessage(String message) {
		asyncApi.sendChannelMessage(message).getUninterruptibly();
	}
	/**
	 * Sends a text message to the virtual server with the specified ID.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 * <p>
	 * This will move the client to the virtual server with the specified server ID,
	 * <b>but will not move it back to the original virtual server!</b>
	 * </p>
	 *
	 * @param serverId
	 * 		the ID of the virtual server to which the message should be sent to
	 * @param message
	 * 		the text message to send
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #sendServerMessage(String)
	 * @see VirtualServer#getId()
	 */
	public void sendServerMessage(int serverId, String message) {
		asyncApi.sendServerMessage(serverId, message).getUninterruptibly();
	}
	/**
	 * Sends a text message to the virtual server the server query is currently in.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 *
	 * @param message
	 * 		the text message to send
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void sendServerMessage(String message) {
		asyncApi.sendServerMessage(message).getUninterruptibly();
	}
	/**
	 * Sends a private message to the client with the specified client ID.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 *
	 * @param clientId
	 * 		the ID of the client to send the message to
	 * @param message
	 * 		the text message to send
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 */
	public void sendPrivateMessage(int clientId, String message) {
		asyncApi.sendPrivateMessage(clientId, message).getUninterruptibly();
	}
	/**
	 * Sets a channel group for a client in a specific channel.
	 *
	 * @param groupId
	 * 		the ID of the group the client should join
	 * @param channelId
	 * 		the ID of the channel where the channel group should be assigned
	 * @param clientDBId
	 * 		the database ID of the client for which the channel group should be set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 */
	public void setClientChannelGroup(int groupId, int channelId, int clientDBId) {
		asyncApi.setClientChannelGroup(groupId, channelId, clientDBId).getUninterruptibly();
	}
	/**
	 * Sets the value of the multiple custom client properties for a client.
	 * <p>
	 * If any key present in the map already has a value assigned for this client,
	 * the existing value will be overwritten.
	 * This method does not delete keys not present in the map.
	 * </p><p>
	 * If {@code properties} contains an entry with {@code null} as its key,
	 * that entry will be ignored and no exception will be thrown.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the target client
	 * @param properties
	 * 		the map of properties to set, cannot be {@code null}
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands properties.size()
	 * @see Client#getDatabaseId()
	 * @see #setCustomClientProperty(int, String, String)
	 * @see #deleteCustomClientProperty(int, String)
	 */
	public void setCustomClientProperties(int clientDBId, Map<String, String> properties) {
		asyncApi.setCustomClientProperties(clientDBId, properties).getUninterruptibly();
	}
	/**
	 * Sets the value of the {@code key} custom client property for a client.
	 * <p>
	 * If there is already an assignment of the {@code key} custom client property
	 * for this client, the existing value will be overwritten.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the target client
	 * @param key
	 * 		the key of the custom property to set, cannot be {@code null}
	 * @param value
	 * 		the (new) value of the custom property to set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #setCustomClientProperties(int, Map)
	 * @see #deleteCustomClientProperty(int, String)
	 */
	public void setCustomClientProperty(int clientDBId, String key, String value) {
		asyncApi.setCustomClientProperty(clientDBId, key, value).getUninterruptibly();
	}
	/**
	 * Sets the read flag to {@code true} for a given message. This will not delete the message.
	 *
	 * @param messageId
	 * 		the ID of the message for which the read flag should be set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #setMessageReadFlag(int, boolean)
	 */
	public void setMessageRead(int messageId) {
		asyncApi.setMessageRead(messageId).getUninterruptibly();
	}
	/**
	 * Sets the read flag to {@code true} for a given message. This will not delete the message.
	 *
	 * @param message
	 * 		the message for which the read flag should be set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #setMessageRead(int)
	 * @see #setMessageReadFlag(Message, boolean)
	 * @see #deleteOfflineMessage(int)
	 */
	public void setMessageRead(Message message) {
		asyncApi.setMessageRead(message).getUninterruptibly();
	}
	/**
	 * Sets the read flag for a given message. This will not delete the message.
	 *
	 * @param messageId
	 * 		the ID of the message for which the read flag should be set
	 * @param read
	 * 		the boolean value to which the read flag should be set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #setMessageRead(int)
	 * @see #setMessageReadFlag(Message, boolean)
	 * @see #deleteOfflineMessage(int)
	 */
	public void setMessageReadFlag(int messageId, boolean read) {
		asyncApi.setMessageReadFlag(messageId, read).getUninterruptibly();
	}
	/**
	 * Sets the read flag for a given message. This will not delete the message.
	 *
	 * @param message
	 * 		the message for which the read flag should be set
	 * @param read
	 * 		the boolean value to which the read flag should be set
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #setMessageRead(Message)
	 * @see #setMessageReadFlag(int, boolean)
	 * @see #deleteOfflineMessage(int)
	 */
	public void setMessageReadFlag(Message message, boolean read) {
		asyncApi.setMessageReadFlag(message, read).getUninterruptibly();
	}
	/**
	 * Sets the nickname of the server query client.
	 * <p>
	 * The nickname must be between 3 and 30 UTF-8 bytes long. BB codes will be ignored.
	 * </p>
	 *
	 * @param nickname
	 * 		the new nickname, may not be {@code null}
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #updateClient(Map)
	 */
	public void setNickname(String nickname) {
		asyncApi.setNickname(nickname).getUninterruptibly();
	}
	/**
	 * Starts the virtual server with the specified ID.
	 *
	 * @param serverId
	 * 		the ID of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void startServer(int serverId) {
		asyncApi.startServer(serverId).getUninterruptibly();
	}
	/**
	 * Starts the specified virtual server.
	 *
	 * @param virtualServer
	 * 		the virtual server to start
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void startServer(VirtualServer virtualServer) {
		asyncApi.startServer(virtualServer).getUninterruptibly();
	}
	/**
	 * Stops the virtual server with the specified ID.
	 *
	 * @param serverId
	 * 		the ID of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void stopServer(int serverId) {
		asyncApi.stopServer(serverId).getUninterruptibly();
	}
	/**
	 * Stops the virtual server with the specified ID.
	 *
	 * @param serverId
	 * 		the ID of the virtual server
	 * @param reason
	 * 		the reason message to display to clients when they are disconnected
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void stopServer(int serverId, String reason) {
		asyncApi.stopServer(serverId, reason).getUninterruptibly();
	}
	/**
	 * Stops the specified virtual server.
	 *
	 * @param virtualServer
	 * 		the virtual server to stop
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void stopServer(VirtualServer virtualServer) {
		asyncApi.stopServer(virtualServer).getUninterruptibly();
	}
	/**
	 * Stops the specified virtual server.
	 *
	 * @param virtualServer
	 * 		the virtual server to stop
	 * @param reason
	 * 		the reason message to display to clients when they are disconnected
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void stopServer(VirtualServer virtualServer, String reason) {
		asyncApi.stopServer(virtualServer, reason).getUninterruptibly();
	}
	/**
	 * Stops the entire TeamSpeak 3 Server instance by shutting down the process.
	 * <p>
	 * To have permission to use this command, you need to use the server query admin login.
	 * </p>
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void stopServerProcess() {
		asyncApi.stopServerProcess().getUninterruptibly();
	}
	/**
	 * Stops the entire TeamSpeak 3 Server instance by shutting down the process.
	 * <p>
	 * To have permission to use this command, you need to use the server query admin login.
	 * </p>
	 *
	 * @param reason
	 * 		the reason message to display to clients when they are disconnected
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void stopServerProcess(String reason) {
		asyncApi.stopServerProcess(reason).getUninterruptibly();
	}
	/**
	 * Unregisters the server query from receiving any event notifications.
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public void unregisterAllEvents() {
		asyncApi.unregisterAllEvents().getUninterruptibly();
	}
	/**
	 * Updates several client properties for this server query instance.
	 *
	 * @param options
	 * 		the map of properties to update
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #updateClient(ClientProperty, String)
	 * @see #editClient(int, Map)
	 */
	public void updateClient(Map<ClientProperty, String> options) {
		asyncApi.updateClient(options).getUninterruptibly();
	}
	/**
	 * Changes a single client property for this server query instance.
	 * <p>
	 * Note that one can set many properties at once with the overloaded method that
	 * takes a map of client properties and strings.
	 * </p>
	 *
	 * @param property
	 * 		the client property to modify, make sure it is editable
	 * @param value
	 * 		the new value of the property
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #updateClient(Map)
	 * @see #editClient(int, Map)
	 */
	public void updateClient(ClientProperty property, String value) {
		asyncApi.updateClient(property, value).getUninterruptibly();
	}
	/**
	 * Generates new login credentials for the currently connected server query instance, using the given name.
	 * <p>
	 * <b>This will remove the current login credentials!</b> You won't be logged out, but after disconnecting,
	 * the old credentials will no longer work. Make sure to not lock yourselves out!
	 * </p>
	 *
	 * @param loginName
	 * 		the name for the server query login
	 *
	 * @return the generated password for the server query login
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addServerQueryLogin(String, int)
	 * @see #deleteServerQueryLogin(int)
	 * @see #getServerQueryLogins()
	 */
	public String updateServerQueryLogin(String loginName) {
		return asyncApi.updateServerQueryLogin(loginName).getUninterruptibly();
	}
	/**
	 * Uploads a file to the file repository at a given path and channel
	 * by reading {@code dataLength} bytes from an open {@link InputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code InputStream} is
	 * open and that {@code dataLength} bytes can eventually be read from it. The user is
	 * also responsible for closing the stream once the upload has finished.
	 * </p><p>
	 * Note that this method will not read the entire file to memory and can thus
	 * upload arbitrarily sized files to the file repository.
	 * </p>
	 *
	 * @param dataIn
	 * 		a stream that contains the data that should be uploaded
	 * @param dataLength
	 * 		how many bytes should be read from the stream
	 * @param filePath
	 * 		the path the file should have after being uploaded
	 * @param overwrite
	 * 		if {@code false}, fails if there's already a file at {@code filePath}
	 * @param channelId
	 * 		the ID of the channel to upload the file to
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #uploadFileDirect(byte[], String, boolean, int, String)
	 */
	public void uploadFile(InputStream dataIn, long dataLength, String filePath, boolean overwrite, int channelId) {
		asyncApi.uploadFile(dataIn, dataLength, filePath, overwrite, channelId).getUninterruptibly();
	}
	/**
	 * Uploads a file to the file repository at a given path and channel
	 * by reading {@code dataLength} bytes from an open {@link InputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code InputStream} is
	 * open and that {@code dataLength} bytes can eventually be read from it. The user is
	 * also responsible for closing the stream once the upload has finished.
	 * </p><p>
	 * Note that this method will not read the entire file to memory and can thus
	 * upload arbitrarily sized files to the file repository.
	 * </p>
	 *
	 * @param dataIn
	 * 		a stream that contains the data that should be uploaded
	 * @param dataLength
	 * 		how many bytes should be read from the stream
	 * @param filePath
	 * 		the path the file should have after being uploaded
	 * @param overwrite
	 * 		if {@code false}, fails if there's already a file at {@code filePath}
	 * @param channelId
	 * 		the ID of the channel to upload the file to
	 * @param channelPassword
	 * 		that channel's password
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #uploadFileDirect(byte[], String, boolean, int, String)
	 */
	public void uploadFile(InputStream dataIn, long dataLength, String filePath, boolean overwrite, int channelId, String channelPassword) {
		asyncApi.uploadFile(dataIn, dataLength, filePath, overwrite, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Uploads a file that is already stored in memory to the file repository
	 * at a given path and channel.
	 *
	 * @param data
	 * 		the file's data as a byte array
	 * @param filePath
	 * 		the path the file should have after being uploaded
	 * @param overwrite
	 * 		if {@code false}, fails if there's already a file at {@code filePath}
	 * @param channelId
	 * 		the ID of the channel to upload the file to
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #uploadFile(InputStream, long, String, boolean, int)
	 */
	public void uploadFileDirect(byte[] data, String filePath, boolean overwrite, int channelId) {
		asyncApi.uploadFileDirect(data, filePath, overwrite, channelId).getUninterruptibly();
	}
	/**
	 * Uploads a file that is already stored in memory to the file repository
	 * at a given path and channel.
	 *
	 * @param data
	 * 		the file's data as a byte array
	 * @param filePath
	 * 		the path the file should have after being uploaded
	 * @param overwrite
	 * 		if {@code false}, fails if there's already a file at {@code filePath}
	 * @param channelId
	 * 		the ID of the channel to upload the file to
	 * @param channelPassword
	 * 		that channel's password
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #uploadFile(InputStream, long, String, boolean, int, String)
	 */
	public void uploadFileDirect(byte[] data, String filePath, boolean overwrite, int channelId, String channelPassword) {
		asyncApi.uploadFileDirect(data, filePath, overwrite, channelId, channelPassword).getUninterruptibly();
	}
	/**
	 * Uploads an icon to the icon directory in the file repository
	 * by reading {@code dataLength} bytes from an open {@link InputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code InputStream} is
	 * open and that {@code dataLength} bytes can eventually be read from it. The user is
	 * also responsible for closing the stream once the upload has finished.
	 * </p><p>
	 * Note that unlike the file upload methods, this <strong>will read the entire file to memory</strong>.
	 * This is because the CRC32 hash must be calculated before the icon can be uploaded.
	 * That means that all icon files must be less than 2<sup>31</sup>-1 bytes in size.
	 * </p>
	 * Uploads  that is already stored in memory to the icon directory
	 * in the file repository. If this icon has already been uploaded or
	 * if a hash collision occurs (CRC32), this command will fail.
	 *
	 * @param dataIn
	 * 		a stream that contains the data that should be uploaded
	 * @param dataLength
	 * 		how many bytes should be read from the stream
	 *
	 * @return the ID of the uploaded icon
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 * @see #uploadIconDirect(byte[])
	 * @see #downloadIcon(OutputStream, long)
	 */
	public long uploadIcon(InputStream dataIn, long dataLength) {
		return asyncApi.uploadIcon(dataIn, dataLength).getUninterruptibly();
	}
	/**
	 * Uploads an icon that is already stored in memory to the icon directory
	 * in the file repository. If this icon has already been uploaded or
	 * if a CRC32 hash collision occurs, this command will fail.
	 *
	 * @param data
	 * 		the icon's data as a byte array
	 *
	 * @return the ID of the uploaded icon
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 * @see #uploadIcon(InputStream, long)
	 * @see #downloadIconDirect(long)
	 */
	public long uploadIconDirect(byte[] data) {
		return asyncApi.uploadIconDirect(data).getUninterruptibly();
	}
	/**
	 * Uses an existing privilege key to join a server or channel group.
	 *
	 * @param token
	 * 		the privilege key to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see PrivilegeKey
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #usePrivilegeKey(PrivilegeKey)
	 */
	public void usePrivilegeKey(String token) {
		asyncApi.usePrivilegeKey(token).getUninterruptibly();
	}
	/**
	 * Uses an existing privilege key to join a server or channel group.
	 *
	 * @param privilegeKey
	 * 		the privilege key to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see PrivilegeKey
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #usePrivilegeKey(String)
	 */
	public void usePrivilegeKey(PrivilegeKey privilegeKey) {
		asyncApi.usePrivilegeKey(privilegeKey).getUninterruptibly();
	}
	/**
	 * Gets information about the current server query instance.
	 *
	 * @return information about the server query instance
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #getClientInfo(int)
	 */
	public ServerQueryInfo whoAmI() {
		return asyncApi.whoAmI().getUninterruptibly();
	}
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2014 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.api.*;
import com.github.theholywaffle.teamspeak3.api.event.TS3EventType;
import com.github.theholywaffle.teamspeak3.api.event.TS3Listener;
import com.github.theholywaffle.teamspeak3.api.exception.TS3CommandFailedException;
import com.github.theholywaffle.teamspeak3.api.exception.TS3Exception;
import com.github.theholywaffle.teamspeak3.api.exception.TS3FileTransferFailedException;
import com.github.theholywaffle.teamspeak3.api.wrapper.*;
import com.github.theholywaffle.teamspeak3.commands.*;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
/**
 * Asynchronous version of {@link TS3Api} to interact with the {@link TS3Query}.
 * <p>
 * This class is used to easily interact with a {@link TS3Query}. It constructs commands,
 * sends them to the TeamSpeak3 server, processes the response and returns the result.
 * </p><p>
 * All methods in this class are asynchronous (so they won't block) and
 * will return a {@link CommandFuture} of the corresponding return type in {@link TS3Api}.
 * If a command fails, no exception will be thrown directly. It will however be rethrown in
 * {@link CommandFuture#get()} and {@link CommandFuture#get(long, TimeUnit)}.
 * Usually, the thrown exception is a {@link TS3CommandFailedException}, which will get you
 * access to the {@link QueryError} from which more information about the error can be obtained.
 * </p><p>
 * Also note that while these methods are asynchronous, the commands will still be sent through a
 * synchronous command pipeline. That means if an asynchronous method is called immediately
 * followed by a synchronous method, the synchronous method will first have to wait until the
 * asynchronous method completed until it its command is sent.
 * </p><p>
 * You won't be able to execute most commands while you're not logged in due to missing permissions.
 * Make sure to either pass your login credentials to the {@link TS3Config} object when
 * creating the {@code TS3Query} or to call {@link #login(String, String)} to log in.
 * </p><p>
 * After that, most commands also require you to select a {@linkplain VirtualServer virtual server}.
 * To do so, call either {@link #selectVirtualServerByPort(int)} or {@link #selectVirtualServerById(int)}.
 * </p>
 *
 * @see TS3Api The synchronous version of the API
 */
public class TS3ApiAsync {
	/**
	 * The TS3 query that holds the event manager and the file transfer helper.
	 */
	private final TS3Query query;
	/**
	 * The queue that this TS3ApiAsync sends its commands to.
	 */
	private final CommandQueue commandQueue;
	/**
	 * Creates a new asynchronous API object for the given {@code TS3Query}.
	 * <p>
	 * <b>Usually, this constructor should not be called.</b> Use {@link TS3Query#getAsyncApi()} instead.
	 * </p>
	 *
	 * @param query
	 * 		the TS3Query to use
	 * @param commandQueue
	 * 		the queue to send commands to
	 */
	TS3ApiAsync(TS3Query query, CommandQueue commandQueue) {
		this.query = query;
		this.commandQueue = commandQueue;
	}
	/**
	 * Adds a new ban entry. At least one of the parameters {@code ip}, {@code name} or {@code uid} needs to be non-null.
	 * Returns the ID of the newly created ban entry.
	 *
	 * @param ip
	 * 		a RegEx pattern to match a client's IP against, can be {@code null}
	 * @param name
	 * 		a RegEx pattern to match a client's name against, can be {@code null}
	 * @param uid
	 * 		the unique identifier of a client, can be {@code null}
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 * @param reason
	 * 		the reason for the ban, can be {@code null}
	 *
	 * @return the ID of the newly created ban entry
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Pattern RegEx Pattern
	 * @see #addBan(String, String, String, String, long, String)
	 * @see Client#getId()
	 * @see Client#getUniqueIdentifier()
	 * @see ClientInfo#getIp()
	 */
	public CommandFuture<Integer> addBan(String ip, String name, String uid, long timeInSeconds, String reason) {
		return addBan(ip, name, uid, null, timeInSeconds, reason);
	}
	/**
	 * Adds a new ban entry. At least one of the parameters {@code ip}, {@code name}, {@code uid}, or
	 * {@code myTSId} needs to be non-null. Returns the ID of the newly created ban entry.
	 * <p>
	 * Note that creating a ban entry for the {@code "empty"} "myTeamSpeak" ID will ban all clients who
	 * don't have a linked "myTeamSpeak" account.
	 * </p>
	 *
	 * @param ip
	 * 		a RegEx pattern to match a client's IP against, can be {@code null}
	 * @param name
	 * 		a RegEx pattern to match a client's name against, can be {@code null}
	 * @param uid
	 * 		the unique identifier of a client, can be {@code null}
	 * @param myTSId
	 * 		the "myTeamSpeak" ID of a client, the string {@code "empty"}, or {@code null}
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 * @param reason
	 * 		the reason for the ban, can be {@code null}
	 *
	 * @return the ID of the newly created ban entry
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Pattern RegEx Pattern
	 * @see Client#getId()
	 * @see Client#getUniqueIdentifier()
	 * @see ClientInfo#getIp()
	 */
	public CommandFuture<Integer> addBan(String ip, String name, String uid, String myTSId, long timeInSeconds, String reason) {
		Command cmd = BanCommands.banAdd(ip, name, uid, myTSId, timeInSeconds, reason);
		return executeAndReturnIntProperty(cmd, "banid");
	}
	/**
	 * Adds a specified permission to a client in a specific channel.
	 *
	 * @param channelId
	 * 		the ID of the channel wherein the permission should be granted
	 * @param clientDBId
	 * 		the database ID of the client to add a permission to
	 * @param permName
	 * 		the name of the permission to grant
	 * @param permValue
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public CommandFuture<Void> addChannelClientPermission(int channelId, int clientDBId, String permName, int permValue) {
		Command cmd = PermissionCommands.channelClientAddPerm(channelId, clientDBId, permName, permValue);
		return executeAndReturnError(cmd);
	}
	/**
	 * Creates a new channel group for clients using a given name and returns its ID.
	 * <p>
	 * To create channel group templates or ones for server queries,
	 * use {@link #addChannelGroup(String, PermissionGroupDatabaseType)}.
	 * </p>
	 *
	 * @param name
	 * 		the name of the new channel group
	 *
	 * @return the ID of the newly created channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup
	 */
	public CommandFuture<Integer> addChannelGroup(String name) {
		return addChannelGroup(name, null);
	}
	/**
	 * Creates a new channel group using a given name and returns its ID.
	 *
	 * @param name
	 * 		the name of the new channel group
	 * @param type
	 * 		the desired type of channel group
	 *
	 * @return the ID of the newly created channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup
	 */
	public CommandFuture<Integer> addChannelGroup(String name, PermissionGroupDatabaseType type) {
		Command cmd = ChannelGroupCommands.channelGroupAdd(name, type);
		return executeAndReturnIntProperty(cmd, "cgid");
	}
	/**
	 * Adds a specified permission to a channel group.
	 *
	 * @param groupId
	 * 		the ID of the channel group to grant the permission
	 * @param permName
	 * 		the name of the permission to be granted
	 * @param permValue
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Permission
	 */
	public CommandFuture<Void> addChannelGroupPermission(int groupId, String permName, int permValue) {
		Command cmd = PermissionCommands.channelGroupAddPerm(groupId, permName, permValue);
		return executeAndReturnError(cmd);
	}
	/**
	 * Adds a specified permission to a channel.
	 *
	 * @param channelId
	 * 		the ID of the channel wherein the permission should be granted
	 * @param permName
	 * 		the name of the permission to grant
	 * @param permValue
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Permission
	 */
	public CommandFuture<Void> addChannelPermission(int channelId, String permName, int permValue) {
		Command cmd = PermissionCommands.channelAddPerm(channelId, permName, permValue);
		return executeAndReturnError(cmd);
	}
	/**
	 * Adds a specified permission to a channel.
	 *
	 * @deprecated
	 * This method is no longer preferred for adding permissions to a client.
	 * <p>
	 * Use {@link TS3ApiAsync#addClientPermission(int, IPermissionType, int, boolean)}
	 * or {@link TS3ApiAsync#addClientPermission(int, BPermissionType, boolean, boolean)} instead.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the client to grant the permission
	 * @param permName
	 * 		the name of the permission to grant
	 * @param value
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 * @param skipped
	 * 		if set to {@code true}, the permission will not be overridden by channel group permissions
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	@Deprecated
	public CommandFuture<Void> addClientPermission(int clientDBId, String permName, int value, boolean skipped) {
		Command cmd = PermissionCommands.clientAddPerm(clientDBId, permName, value, skipped);
		return executeAndReturnError(cmd);
	}
	/**
	 * Adds a specified permission to a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client to grant the permission
	 * @param permName
	 * 		the enum of the permission to grant
	 * 		@see IPermissionType
	 * @param value
	 * 		the numeric value of the permission
	 * @param skipped
	 * 		if set to {@code true}, the permission will not be overridden by channel group permissions
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public CommandFuture<Void> addClientPermission(int clientDBId, IPermissionType permName, int value, boolean skipped) {
		Command cmd = PermissionCommands.clientAddPerm(clientDBId, permName.getName(), value, skipped);
		return executeAndReturnError(cmd);
	}
	/**
	 * Adds a specified permission to a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client to grant the permission
	 * @param permName
	 * 		the enum of the permission to grant
	 * 		@see BPermissionType
	 * @param value
	 * 		the boolean value of the permission
	 * @param skipped
	 * 		if set to {@code true}, the permission will not be overridden by channel group permissions
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public CommandFuture<Void> addClientPermission(int clientDBId, BPermissionType permName, boolean value, boolean skipped) {
		Command cmd = PermissionCommands.clientAddPerm(clientDBId, permName.getName(), value, skipped);
		return executeAndReturnError(cmd);
	}
	/**
	 * Adds a client to the specified server group.
	 * <p>
	 * Please note that a client cannot be added to default groups or template groups.
	 * </p>
	 *
	 * @param groupId
	 * 		the ID of the server group to add the client to
	 * @param clientDatabaseId
	 * 		the database ID of the client to add
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see Client#getDatabaseId()
	 */
	public CommandFuture<Void> addClientToServerGroup(int groupId, int clientDatabaseId) {
		Command cmd = ServerGroupCommands.serverGroupAddClient(groupId, clientDatabaseId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Submits a complaint about the specified client.
	 * The length of the message is limited to 200 UTF-8 bytes and BB codes in it will be ignored.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param message
	 * 		the message of the complaint, may not contain BB codes
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Complaint#getMessage()
	 */
	public CommandFuture<Void> addComplaint(int clientDBId, String message) {
		Command cmd = ComplaintCommands.complainAdd(clientDBId, message);
		return executeAndReturnError(cmd);
	}
	/**
	 * Adds a specified permission to all server groups of the type specified by {@code type} on all virtual servers.
	 *
	 * @param type
	 * 		the kind of server group this permission should be added to
	 * @param permName
	 * 		the name of the permission to be granted
	 * @param value
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 * @param negated
	 * 		if set to true, the lowest permission value will be selected instead of the highest
	 * @param skipped
	 * 		if set to true, this permission will not be overridden by client or channel group permissions
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroupType
	 * @see Permission
	 */
	public CommandFuture<Void> addPermissionToAllServerGroups(ServerGroupType type, String permName, int value, boolean negated, boolean skipped) {
		Command cmd = PermissionCommands.serverGroupAutoAddPerm(type, permName, value, negated, skipped);
		return executeAndReturnError(cmd);
	}
	/**
	 * Create a new privilege key that allows one client to join a server or channel group.
	 * <ul>
	 * <li>If {@code type} is set to {@linkplain PrivilegeKeyType#SERVER_GROUP SERVER_GROUP},
	 * {@code groupId} is used as a server group ID and {@code channelId} is ignored.</li>
	 * <li>If {@code type} is set to {@linkplain PrivilegeKeyType#CHANNEL_GROUP CHANNEL_GROUP},
	 * {@code groupId} is used as a channel group ID and {@code channelId} is used as the channel in which the group should be set.</li>
	 * </ul>
	 *
	 * @param type
	 * 		the type of token that should be created
	 * @param groupId
	 * 		the ID of the server or channel group
	 * @param channelId
	 * 		the ID of the channel, in case the token is channel group token
	 * @param description
	 * 		the description for the token, can be null
	 *
	 * @return the created token for a client to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see PrivilegeKeyType
	 * @see #addPrivilegeKeyServerGroup(int, String)
	 * @see #addPrivilegeKeyChannelGroup(int, int, String)
	 */
	public CommandFuture<String> addPrivilegeKey(PrivilegeKeyType type, int groupId, int channelId, String description) {
		Command cmd = PrivilegeKeyCommands.privilegeKeyAdd(type, groupId, channelId, description);
		return executeAndReturnStringProperty(cmd, "token");
	}
	/**
	 * Creates a new privilege key for a channel group.
	 *
	 * @param channelGroupId
	 * 		the ID of the channel group
	 * @param channelId
	 * 		the ID of the channel in which the channel group should be set
	 * @param description
	 * 		the description for the token, can be null
	 *
	 * @return the created token for a client to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Channel#getId()
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #addPrivilegeKeyServerGroup(int, String)
	 */
	public CommandFuture<String> addPrivilegeKeyChannelGroup(int channelGroupId, int channelId, String description) {
		return addPrivilegeKey(PrivilegeKeyType.CHANNEL_GROUP, channelGroupId, channelId, description);
	}
	/**
	 * Creates a new privilege key for a server group.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group
	 * @param description
	 * 		the description for the token, can be null
	 *
	 * @return the created token for a client to use
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #addPrivilegeKeyChannelGroup(int, int, String)
	 */
	public CommandFuture<String> addPrivilegeKeyServerGroup(int serverGroupId, String description) {
		return addPrivilegeKey(PrivilegeKeyType.SERVER_GROUP, serverGroupId, 0, description);
	}
	/**
	 * Creates a new server group for clients using a given name and returns its ID.
	 * <p>
	 * To create server group templates or ones for server queries,
	 * use {@link #addServerGroup(String, PermissionGroupDatabaseType)}.
	 * </p>
	 *
	 * @param name
	 * 		the name of the new server group
	 *
	 * @return the ID of the newly created server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup
	 */
	public CommandFuture<Integer> addServerGroup(String name) {
		return addServerGroup(name, PermissionGroupDatabaseType.REGULAR);
	}
	/**
	 * Creates a new server group using a given name and returns its ID.
	 *
	 * @param name
	 * 		the name of the new server group
	 * @param type
	 * 		the desired type of server group
	 *
	 * @return the ID of the newly created server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup
	 * @see PermissionGroupDatabaseType
	 */
	public CommandFuture<Integer> addServerGroup(String name, PermissionGroupDatabaseType type) {
		Command cmd = ServerGroupCommands.serverGroupAdd(name, type);
		return executeAndReturnIntProperty(cmd, "sgid");
	}
	/**
	 * Adds a specified permission to a server group.
	 *
	 * @param groupId
	 * 		the ID of the channel group to which the permission should be added
	 * @param permName
	 * 		the name of the permission to add
	 * @param value
	 * 		the numeric value of the permission (or for boolean permissions: 1 = true, 0 = false)
	 * @param negated
	 * 		if set to true, the lowest permission value will be selected instead of the highest
	 * @param skipped
	 * 		if set to true, this permission will not be overridden by client or channel group permissions
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see Permission
	 */
	public CommandFuture<Void> addServerGroupPermission(int groupId, String permName, int value, boolean negated, boolean skipped) {
		Command cmd = PermissionCommands.serverGroupAddPerm(groupId, permName, value, negated, skipped);
		return executeAndReturnError(cmd);
	}
	/**
	 * Creates a server query login with name {@code loginName} for the client specified by {@code clientDBId}
	 * on the currently selected virtual server and returns the password of the created login.
	 * If the client already had a server query login, the existing login will be deleted and replaced.
	 * <p>
	 * Moreover, this method can be used to create new <i>global</i> server query logins that are not tied to any
	 * particular virtual server or client. To create such a server query login, make sure no virtual server is
	 * selected (e.g. use {@code selectVirtualServerById(0)}) and call this method with {@code clientDBId = 0}.
	 * </p>
	 *
	 * @param loginName
	 * 		the name of the server query login to add
	 * @param clientDBId
	 * 		the database ID of the client for which a server query login should be created
	 *
	 * @return an object containing the password of the new server query login
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #deleteServerQueryLogin(int)
	 * @see #getServerQueryLogins()
	 * @see #updateServerQueryLogin(String)
	 */
	public CommandFuture<CreatedQueryLogin> addServerQueryLogin(String loginName, int clientDBId) {
		Command cmd = QueryLoginCommands.queryLoginAdd(loginName, clientDBId);
		return executeAndTransformFirst(cmd, CreatedQueryLogin::new);
	}
	/**
	 * Adds one or more {@link TS3Listener}s to the event manager of the query.
	 * These listeners will be notified when the TS3 server fires an event.
	 * <p>
	 * Note that for the TS3 server to fire events, you must first also register
	 * the event types you want to listen to.
	 * </p>
	 *
	 * @param listeners
	 * 		one or more listeners to register
	 *
	 * @see #registerAllEvents()
	 * @see #registerEvent(TS3EventType, int)
	 * @see TS3Listener
	 * @see TS3EventType
	 */
	public void addTS3Listeners(TS3Listener... listeners) {
		query.getEventManager().addListeners(listeners);
	}
	/**
	 * Bans a client with a given client ID for a given time.
	 * <p>
	 * Please note that this will create up to three separate ban rules,
	 * one for the targeted client's IP address, one for their unique identifier,
	 * and potentially one more entry for their "myTeamSpeak" ID, if available.
	 * </p><p>
	 * <i>Exception:</i> If the banned client connects via a loopback address
	 * (i.e. {@code 127.0.0.1} or {@code localhost}), no IP ban is created.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 *
	 * @return an array containing the IDs of the created ban entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #addBan(String, String, String, long, String)
	 */
	public CommandFuture<int[]> banClient(int clientId, long timeInSeconds) {
		return banClient(clientId, timeInSeconds, null);
	}
	/**
	 * Bans a client with a given client ID for a given time for the specified reason.
	 * <p>
	 * Please note that this will create up to three separate ban rules,
	 * one for the targeted client's IP address, one for their unique identifier,
	 * and potentially one more entry for their "myTeamSpeak" ID, if available.
	 * </p><p>
	 * <i>Exception:</i> If the banned client connects via a loopback address
	 * (i.e. {@code 127.0.0.1} or {@code localhost}), no IP ban is created.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 * @param reason
	 * 		the reason for the ban, can be null
	 *
	 * @return an array containing the IDs of the created ban entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #addBan(String, String, String, long, String)
	 */
	public CommandFuture<int[]> banClient(int clientId, long timeInSeconds, String reason) {
		Command cmd = BanCommands.banClient(new int[] {clientId}, timeInSeconds, reason, false);
		return executeAndReturnIntArray(cmd, "banid");
	}
	/**
	 * Bans a client with a given client ID permanently for the specified reason.
	 * <p>
	 * Please note that this will create up to three separate ban rules,
	 * one for the targeted client's IP address, one for their unique identifier,
	 * and potentially one more entry for their "myTeamSpeak" ID, if available.
	 * </p><p>
	 * <i>Exception:</i> If the banned client connects via a loopback address
	 * (i.e. {@code 127.0.0.1} or {@code localhost}), no IP ban is created.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client
	 * @param reason
	 * 		the reason for the ban, can be null
	 *
	 * @return an array containing the IDs of the created ban entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #addBan(String, String, String, long, String)
	 */
	public CommandFuture<int[]> banClient(int clientId, String reason) {
		return banClient(clientId, 0, reason);
	}
	/**
	 * Bans multiple clients by their client ID for a given time for the specified reason.
	 * <p>
	 * Please note that this will create up to three separate ban rules for each client,
	 * one for the targeted client's IP address, one for their unique identifier,
	 * and potentially one more entry for their "myTeamSpeak" ID, if available.
	 * </p><p>
	 * <i>Exception:</i> If the banned client connects via a loopback address
	 * (i.e. {@code 127.0.0.1} or {@code localhost}), no IP ban is created.
	 * </p><p>
	 * <i>Exception:</i> If two or more clients are connecting from the
	 * same IP address, only one IP ban entry for that IP will be created.
	 * </p>
	 *
	 * @param clientIds
	 * 		the IDs of the clients to be banned
	 * @param timeInSeconds
	 * 		the duration of the ban in seconds. 0 equals a permanent ban
	 * @param reason
	 * 		the reason for the ban, can be null
	 * @param continueOnError
	 * 		if true, continue to the next client if banning one client fails, else do not create any bans on error
	 *
	 * @return an array containing the IDs of the created ban entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #addBan(String, String, String, long, String)
	 */
	public CommandFuture<int[]> banClients(int[] clientIds, long timeInSeconds, String reason, boolean continueOnError) {
		if (clientIds == null) throw new IllegalArgumentException("Client ID array was null");
		if (clientIds.length == 0) return CommandFuture.immediate(new int[0]); // Success
		Command cmd = BanCommands.banClient(clientIds, timeInSeconds, reason, continueOnError);
		return executeAndReturnIntArray(cmd, "banid");
	}
	/**
	 * Sends a text message to all clients on all virtual servers.
	 * These messages will appear to clients in the tab for server messages.
	 *
	 * @param message
	 * 		the message to be sent
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> broadcast(String message) {
		Command cmd = ServerCommands.gm(message);
		return executeAndReturnError(cmd);
	}
	/**
	 * Creates a copy of the channel group specified by {@code sourceGroupId},
	 * overwriting any other channel group specified by {@code targetGroupId}.
	 * <p>
	 * The parameter {@code type} can be used to create server query and template groups.
	 * </p>
	 *
	 * @param sourceGroupId
	 * 		the ID of the channel group to copy
	 * @param targetGroupId
	 * 		the ID of another channel group to overwrite
	 * @param type
	 * 		the desired type of channel group
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 */
	public CommandFuture<Void> copyChannelGroup(int sourceGroupId, int targetGroupId, PermissionGroupDatabaseType type) {
		if (targetGroupId <= 0) {
			throw new IllegalArgumentException("To create a new channel group, use the method with a String argument");
		}
		Command cmd = ChannelGroupCommands.channelGroupCopy(sourceGroupId, targetGroupId, type);
		return executeAndReturnError(cmd);
	}
	/**
	 * Creates a copy of the channel group specified by {@code sourceGroupId} with a given name
	 * and returns the ID of the newly created channel group.
	 *
	 * @param sourceGroupId
	 * 		the ID of the channel group to copy
	 * @param targetName
	 * 		the name for the copy of the channel group
	 * @param type
	 * 		the desired type of channel group
	 *
	 * @return the ID of the newly created channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 */
	public CommandFuture<Integer> copyChannelGroup(int sourceGroupId, String targetName, PermissionGroupDatabaseType type) {
		Command cmd = ChannelGroupCommands.channelGroupCopy(sourceGroupId, targetName, type);
		return executeAndReturnIntProperty(cmd, "cgid");
	}
	/**
	 * Creates a copy of the server group specified by {@code sourceGroupId},
	 * overwriting another server group specified by {@code targetGroupId}.
	 * <p>
	 * The parameter {@code type} can be used to create server query and template groups.
	 * </p>
	 *
	 * @param sourceGroupId
	 * 		the ID of the server group to copy
	 * @param targetGroupId
	 * 		the ID of another server group to overwrite
	 * @param type
	 * 		the desired type of server group
	 *
	 * @return the ID of the newly created server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 */
	public CommandFuture<Integer> copyServerGroup(int sourceGroupId, int targetGroupId, PermissionGroupDatabaseType type) {
		if (targetGroupId <= 0) {
			throw new IllegalArgumentException("To create a new server group, use the method with a String argument");
		}
		Command cmd = ServerGroupCommands.serverGroupCopy(sourceGroupId, targetGroupId, type);
		return executeAndReturnIntProperty(cmd, "sgid");
	}
	/**
	 * Creates a copy of the server group specified by {@code sourceGroupId} with a given name
	 * and returns the ID of the newly created server group.
	 *
	 * @param sourceGroupId
	 * 		the ID of the server group to copy
	 * @param targetName
	 * 		the name for the copy of the server group
	 * @param type
	 * 		the desired type of server group
	 *
	 * @return the ID of the newly created server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 */
	public CommandFuture<Integer> copyServerGroup(int sourceGroupId, String targetName, PermissionGroupDatabaseType type) {
		Command cmd = ServerGroupCommands.serverGroupCopy(sourceGroupId, targetName, type);
		return executeAndReturnIntProperty(cmd, "sgid");
	}
	/**
	 * Creates a new channel with a given name using the given properties and returns its ID.
	 *
	 * @param name
	 * 		the name for the new channel
	 * @param options
	 * 		a map of options that should be set for the channel
	 *
	 * @return the ID of the newly created channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel
	 */
	public CommandFuture<Integer> createChannel(String name, Map<ChannelProperty, String> options) {
		Command cmd = ChannelCommands.channelCreate(name, options);
		return executeAndReturnIntProperty(cmd, "cid");
	}
	/**
	 * Creates a new directory on the file repository in the specified channel.
	 *
	 * @param directoryPath
	 * 		the path to the directory that should be created
	 * @param channelId
	 * 		the ID of the channel the directory should be created in
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> createFileDirectory(String directoryPath, int channelId) {
		return createFileDirectory(directoryPath, channelId, null);
	}
	/**
	 * Creates a new directory on the file repository in the specified channel.
	 *
	 * @param directoryPath
	 * 		the path to the directory that should be created
	 * @param channelId
	 * 		the ID of the channel the directory should be created in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> createFileDirectory(String directoryPath, int channelId, String channelPassword) {
		Command cmd = FileCommands.ftCreateDir(directoryPath, channelId, channelPassword);
		return executeAndReturnError(cmd);
	}
	/**
	 * Creates a new virtual server with the given name and returns an object containing the ID of the newly
	 * created virtual server, the default server admin token and the virtual server's voice port. Usually,
	 * the virtual server is also automatically started. This can be turned off on the TS3 server, though.
	 * <p>
	 * If {@link VirtualServerProperty#VIRTUALSERVER_PORT} is not specified in the virtual server properties,
	 * the server will test for the first unused UDP port.
	 * </p><p>
	 * Please also note that creating virtual servers usually requires the server query admin account
	 * and that there is a limit to how many virtual servers can be created, which is dependent on your license.
	 * Unlicensed TS3 server instances are limited to 1 virtual server with up to 32 client slots.
	 * </p>
	 *
	 * @param name
	 * 		the name for the new virtual server
	 * @param options
	 * 		a map of options that should be set for the virtual server
	 *
	 * @return information about the newly created virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer
	 */
	public CommandFuture<CreatedVirtualServer> createServer(String name, Map<VirtualServerProperty, String> options) {
		Command cmd = VirtualServerCommands.serverCreate(name, options);
		return executeAndTransformFirst(cmd, CreatedVirtualServer::new);
	}
	/**
	 * Creates a {@link Snapshot} of the selected virtual server containing all settings,
	 * groups and known client identities. The data from a server snapshot can be
	 * used to restore a virtual servers configuration.
	 *
	 * @return a snapshot of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #deployServerSnapshot(Snapshot)
	 */
	public CommandFuture<Snapshot> createServerSnapshot() {
		Command cmd = VirtualServerCommands.serverSnapshotCreate();
		CommandFuture<Snapshot> future = cmd.getFuture()
				.map(result -> new Snapshot(result.getRawResponse()));
		commandQueue.enqueueCommand(cmd);
		return future;
	}
	/**
	 * Deletes all active ban rules from the server. Use with caution.
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> deleteAllBans() {
		Command cmd = BanCommands.banDelAll();
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes all complaints about the client with specified database ID from the server.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Complaint
	 */
	public CommandFuture<Void> deleteAllComplaints(int clientDBId) {
		Command cmd = ComplaintCommands.complainDelAll(clientDBId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes the ban rule with the specified ID from the server.
	 *
	 * @param banId
	 * 		the ID of the ban to delete
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Ban#getId()
	 */
	public CommandFuture<Void> deleteBan(int banId) {
		Command cmd = BanCommands.banDel(banId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes an existing channel specified by its ID, kicking all clients out of the channel.
	 *
	 * @param channelId
	 * 		the ID of the channel to delete
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #deleteChannel(int, boolean)
	 * @see #kickClientFromChannel(String, int...)
	 */
	public CommandFuture<Void> deleteChannel(int channelId) {
		return deleteChannel(channelId, true);
	}
	/**
	 * Deletes an existing channel with a given ID.
	 * If {@code force} is true, the channel will be deleted even if there are clients within,
	 * else the command will fail in this situation.
	 *
	 * @param channelId
	 * 		the ID of the channel to delete
	 * @param force
	 * 		whether clients should be kicked out of the channel
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #kickClientFromChannel(String, int...)
	 */
	public CommandFuture<Void> deleteChannel(int channelId, boolean force) {
		Command cmd = ChannelCommands.channelDelete(channelId, force);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes a specified permission from a client in a specific channel.
	 *
	 * @param channelId
	 * 		the ID of the channel wherein the permission should be removed
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 * @see Permission#getName()
	 */
	public CommandFuture<Void> deleteChannelClientPermission(int channelId, int clientDBId, String permName) {
		Command cmd = PermissionCommands.channelClientDelPerm(channelId, clientDBId, permName);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes the channel group with the given ID.
	 *
	 * @param groupId
	 * 		the ID of the channel group
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 */
	public CommandFuture<Void> deleteChannelGroup(int groupId) {
		return deleteChannelGroup(groupId, true);
	}
	/**
	 * Removes the channel group with the given ID.
	 * If {@code force} is true, the channel group will be deleted even if it still contains clients,
	 * else the command will fail in this situation.
	 *
	 * @param groupId
	 * 		the ID of the channel group
	 * @param force
	 * 		whether the channel group should be deleted even if it still contains clients
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 */
	public CommandFuture<Void> deleteChannelGroup(int groupId, boolean force) {
		Command cmd = ChannelGroupCommands.channelGroupDel(groupId, force);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes a permission from the channel group with the given ID.
	 *
	 * @param groupId
	 * 		the ID of the channel group
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Permission#getName()
	 */
	public CommandFuture<Void> deleteChannelGroupPermission(int groupId, String permName) {
		Command cmd = PermissionCommands.channelGroupDelPerm(groupId, permName);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes a permission from the channel with the given ID.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Permission#getName()
	 */
	public CommandFuture<Void> deleteChannelPermission(int channelId, String permName) {
		Command cmd = PermissionCommands.channelDelPerm(channelId, permName);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes a permission from a client.
	 *
	 * @deprecated
	 * This method is no longer preferred for removing permissions from a client.
	 * <p>
	 * Use {@link TS3ApiAsync#deleteClientPermission(int, IPermissionType)}
	 * or {@link TS3ApiAsync#deleteClientPermission(int, BPermissionType)} instead.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission#getName()
	 */
	@Deprecated
	public CommandFuture<Void> deleteClientPermission(int clientDBId, String permName) {
		Command cmd = PermissionCommands.clientDelPerm(clientDBId, permName);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes a permission from a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param permName
	 * 		the enum of the permission to revoke
	 * 		@see IPermissionType
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission#getName()
	 */
	public CommandFuture<Void> deleteClientPermission(int clientDBId, IPermissionType permName) {
		Command cmd = PermissionCommands.clientDelPerm(clientDBId, permName.getName());
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes a permission from a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 * @param permName
	 * 		the enum of the permission to revoke
	 * 		@see BPermissionType
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission#getName()
	 */
	public CommandFuture<Void> deleteClientPermission(int clientDBId, BPermissionType permName) {
		Command cmd = PermissionCommands.clientDelPerm(clientDBId, permName.getName());
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes the complaint about the client with database ID {@code targetClientDBId} submitted by
	 * the client with database ID {@code fromClientDBId} from the server.
	 *
	 * @param targetClientDBId
	 * 		the database ID of the client the complaint is about
	 * @param fromClientDBId
	 * 		the database ID of the client who added the complaint
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Complaint
	 * @see Client#getDatabaseId()
	 */
	public CommandFuture<Void> deleteComplaint(int targetClientDBId, int fromClientDBId) {
		Command cmd = ComplaintCommands.complainDel(targetClientDBId, fromClientDBId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes the {@code key} custom client property from a client.
	 *
	 * @param clientDBId
	 * 		the database ID of the target client
	 * @param key
	 * 		the key of the custom property to delete, cannot be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 */
	public CommandFuture<Void> deleteCustomClientProperty(int clientDBId, String key) {
		if (key == null) throw new IllegalArgumentException("Key cannot be null");
		Command cmd = CustomPropertyCommands.customDelete(clientDBId, key);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes all stored database information about the specified client.
	 * Please note that this data is also automatically removed after a configured time (usually 90 days).
	 * <p>
	 * See {@link DatabaseClientInfo} for a list of stored information about a client.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #getDatabaseClientInfo(int)
	 * @see DatabaseClientInfo
	 */
	public CommandFuture<Void> deleteDatabaseClientProperties(int clientDBId) {
		Command cmd = DatabaseClientCommands.clientDBDelete(clientDBId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes a file or directory from the file repository in the specified channel.
	 *
	 * @param filePath
	 * 		the path to the file or directory
	 * @param channelId
	 * 		the ID of the channel the file or directory resides in
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> deleteFile(String filePath, int channelId) {
		return deleteFile(filePath, channelId, null);
	}
	/**
	 * Deletes a file or directory from the file repository in the specified channel.
	 *
	 * @param filePath
	 * 		the path to the file or directory
	 * @param channelId
	 * 		the ID of the channel the file or directory resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> deleteFile(String filePath, int channelId, String channelPassword) {
		Command cmd = FileCommands.ftDeleteFile(channelId, channelPassword, filePath);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes multiple files or directories from the file repository in the specified channel.
	 *
	 * @param filePaths
	 * 		the paths to the files or directories
	 * @param channelId
	 * 		the ID of the channel the file or directory resides in
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> deleteFiles(String[] filePaths, int channelId) {
		return deleteFiles(filePaths, channelId, null);
	}
	/**
	 * Deletes multiple files or directories from the file repository in the specified channel.
	 *
	 * @param filePaths
	 * 		the paths to the files or directories
	 * @param channelId
	 * 		the ID of the channel the file or directory resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> deleteFiles(String[] filePaths, int channelId, String channelPassword) {
		Command cmd = FileCommands.ftDeleteFile(channelId, channelPassword, filePaths);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes an icon from the icon directory in the file repository.
	 *
	 * @param iconId
	 * 		the ID of the icon to delete
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 */
	public CommandFuture<Void> deleteIcon(long iconId) {
		String iconPath = "/icon_" + iconId;
		return deleteFile(iconPath, 0);
	}
	/**
	 * Deletes multiple icons from the icon directory in the file repository.
	 *
	 * @param iconIds
	 * 		the IDs of the icons to delete
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 */
	public CommandFuture<Void> deleteIcons(long... iconIds) {
		String[] iconPaths = new String[iconIds.length];
		for (int i = 0; i < iconIds.length; ++i) {
			iconPaths[i] = "/icon_" + iconIds[i];
		}
		return deleteFiles(iconPaths, 0);
	}
	/**
	 * Deletes the offline message with the specified ID.
	 *
	 * @param messageId
	 * 		the ID of the offline message to delete
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Message#getId()
	 */
	public CommandFuture<Void> deleteOfflineMessage(int messageId) {
		Command cmd = MessageCommands.messageDel(messageId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes a specified permission from all server groups of the type specified by {@code type} on all virtual servers.
	 *
	 * @param type
	 * 		the kind of server group this permission should be removed from
	 * @param permName
	 * 		the name of the permission to remove
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroupType
	 * @see Permission#getName()
	 */
	public CommandFuture<Void> deletePermissionFromAllServerGroups(ServerGroupType type, String permName) {
		Command cmd = PermissionCommands.serverGroupAutoDelPerm(type, permName);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes the privilege key with the given token.
	 *
	 * @param token
	 * 		the token of the privilege key
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see PrivilegeKey
	 */
	public CommandFuture<Void> deletePrivilegeKey(String token) {
		Command cmd = PrivilegeKeyCommands.privilegeKeyDelete(token);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes the virtual server with the specified ID.
	 * <p>
	 * Only stopped virtual servers can be deleted.
	 * </p>
	 *
	 * @param serverId
	 * 		the ID of the virtual server
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getId()
	 * @see #stopServer(int)
	 */
	public CommandFuture<Void> deleteServer(int serverId) {
		Command cmd = VirtualServerCommands.serverDelete(serverId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes the server group with the specified ID, even if the server group still contains clients.
	 *
	 * @param groupId
	 * 		the ID of the server group
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 */
	public CommandFuture<Void> deleteServerGroup(int groupId) {
		return deleteServerGroup(groupId, true);
	}
	/**
	 * Deletes a server group with the specified ID.
	 * <p>
	 * If {@code force} is true, the server group will be deleted even if it contains clients,
	 * else the command will fail in this situation.
	 * </p>
	 *
	 * @param groupId
	 * 		the ID of the server group
	 * @param force
	 * 		whether the server group should be deleted if it still contains clients
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 */
	public CommandFuture<Void> deleteServerGroup(int groupId, boolean force) {
		Command cmd = ServerGroupCommands.serverGroupDel(groupId, force);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes a permission from the server group with the given ID.
	 *
	 * @param groupId
	 * 		the ID of the server group
	 * @param permName
	 * 		the name of the permission to revoke
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see Permission#getName()
	 */
	public CommandFuture<Void> deleteServerGroupPermission(int groupId, String permName) {
		Command cmd = PermissionCommands.serverGroupDelPerm(groupId, permName);
		return executeAndReturnError(cmd);
	}
	/**
	 * Deletes the server query login with the specified client database ID.
	 * <p>
	 * If you only know the name of the server query login, use {@link #getServerQueryLoginsByName(String)} first.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the client database ID of the server query login (usually the ID of the associated client)
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addServerQueryLogin(String, int)
	 * @see #getServerQueryLogins()
	 * @see #updateServerQueryLogin(String)
	 */
	public CommandFuture<Void> deleteServerQueryLogin(int clientDBId) {
		Command cmd = QueryLoginCommands.queryLoginDel(clientDBId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Restores the selected virtual servers configuration using the data from a
	 * previously created server snapshot.
	 *
	 * @param snapshot
	 * 		the snapshot to restore
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #createServerSnapshot()
	 */
	public CommandFuture<Void> deployServerSnapshot(Snapshot snapshot) {
		return deployServerSnapshot(snapshot.get());
	}
	/**
	 * Restores the configuration of the selected virtual server using the data from a
	 * previously created server snapshot.
	 *
	 * @param snapshot
	 * 		the snapshot to restore
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #createServerSnapshot()
	 */
	public CommandFuture<Void> deployServerSnapshot(String snapshot) {
		Command cmd = VirtualServerCommands.serverSnapshotDeploy(snapshot);
		return executeAndReturnError(cmd);
	}
	/**
	 * Downloads a file from the file repository at a given path and channel
	 * and writes the file's bytes to an open {@link OutputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code OutputStream} is
	 * open and to close the stream again once the download has finished.
	 * </p><p>
	 * Note that this method will not read the entire file to memory and can thus
	 * download arbitrarily sized files from the file repository.
	 * </p>
	 *
	 * @param dataOut
	 * 		a stream that the downloaded data should be written to
	 * @param filePath
	 * 		the path of the file on the file repository
	 * @param channelId
	 * 		the ID of the channel to download the file from
	 *
	 * @return how many bytes were downloaded
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #downloadFileDirect(String, int)
	 */
	public CommandFuture<Long> downloadFile(OutputStream dataOut, String filePath, int channelId) {
		return downloadFile(dataOut, filePath, channelId, null);
	}
	/**
	 * Downloads a file from the file repository at a given path and channel
	 * and writes the file's bytes to an open {@link OutputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code OutputStream} is
	 * open and to close the stream again once the download has finished.
	 * </p><p>
	 * Note that this method will not read the entire file to memory and can thus
	 * download arbitrarily sized files from the file repository.
	 * </p>
	 *
	 * @param dataOut
	 * 		a stream that the downloaded data should be written to
	 * @param filePath
	 * 		the path of the file on the file repository
	 * @param channelId
	 * 		the ID of the channel to download the file from
	 * @param channelPassword
	 * 		that channel's password
	 *
	 * @return how many bytes were downloaded
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #downloadFileDirect(String, int, String)
	 */
	public CommandFuture<Long> downloadFile(OutputStream dataOut, String filePath, int channelId, String channelPassword) {
		FileTransferHelper helper = query.getFileTransferHelper();
		int transferId = helper.getClientTransferId();
		Command cmd = FileCommands.ftInitDownload(transferId, filePath, channelId, channelPassword);
		CommandFuture<Long> future = new CommandFuture<>();
		executeAndTransformFirst(cmd, FileTransferParameters::new).onSuccess(params -> {
			QueryError error = params.getQueryError();
			if (!error.isSuccessful()) {
				future.fail(new TS3CommandFailedException(error, cmd.getName()));
				return;
			}
			try {
				query.getFileTransferHelper().downloadFile(dataOut, params);
			} catch (IOException e) {
				future.fail(new TS3FileTransferFailedException("Download failed", e));
				return;
			}
			future.set(params.getFileSize());
		}).forwardFailure(future);
		return future;
	}
	/**
	 * Downloads a file from the file repository at a given path and channel
	 * and returns the file's bytes as a byte array.
	 * <p>
	 * Note that this method <strong>will read the entire file to memory</strong>.
	 * That means that if a file is larger than 2<sup>31</sup>-1 bytes in size,
	 * the download will fail.
	 * </p>
	 *
	 * @param filePath
	 * 		the path of the file on the file repository
	 * @param channelId
	 * 		the ID of the channel to download the file from
	 *
	 * @return a byte array containing the file's data
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #downloadFile(OutputStream, String, int)
	 */
	public CommandFuture<byte[]> downloadFileDirect(String filePath, int channelId) {
		return downloadFileDirect(filePath, channelId, null);
	}
	/**
	 * Downloads a file from the file repository at a given path and channel
	 * and returns the file's bytes as a byte array.
	 * <p>
	 * Note that this method <strong>will read the entire file to memory</strong>.
	 * That means that if a file is larger than 2<sup>31</sup>-1 bytes in size,
	 * the download will fail.
	 * </p>
	 *
	 * @param filePath
	 * 		the path of the file on the file repository
	 * @param channelId
	 * 		the ID of the channel to download the file from
	 * @param channelPassword
	 * 		that channel's password
	 *
	 * @return a byte array containing the file's data
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #downloadFile(OutputStream, String, int, String)
	 */
	public CommandFuture<byte[]> downloadFileDirect(String filePath, int channelId, String channelPassword) {
		FileTransferHelper helper = query.getFileTransferHelper();
		int transferId = helper.getClientTransferId();
		Command cmd = FileCommands.ftInitDownload(transferId, filePath, channelId, channelPassword);
		CommandFuture<byte[]> future = new CommandFuture<>();
		executeAndTransformFirst(cmd, FileTransferParameters::new).onSuccess(params -> {
			QueryError error = params.getQueryError();
			if (!error.isSuccessful()) {
				future.fail(new TS3CommandFailedException(error, cmd.getName()));
				return;
			}
			long fileSize = params.getFileSize();
			if (fileSize > Integer.MAX_VALUE) {
				future.fail(new TS3FileTransferFailedException("File too big for byte array"));
				return;
			}
			ByteArrayOutputStream dataOut = new ByteArrayOutputStream((int) fileSize);
			try {
				query.getFileTransferHelper().downloadFile(dataOut, params);
			} catch (IOException e) {
				future.fail(new TS3FileTransferFailedException("Download failed", e));
				return;
			}
			future.set(dataOut.toByteArray());
		}).forwardFailure(future);
		return future;
	}
	/**
	 * Downloads an icon from the icon directory in the file repository
	 * and writes the file's bytes to an open {@link OutputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code OutputStream} is
	 * open and to close the stream again once the download has finished.
	 * </p>
	 *
	 * @param dataOut
	 * 		a stream that the downloaded data should be written to
	 * @param iconId
	 * 		the ID of the icon that should be downloaded
	 *
	 * @return a byte array containing the icon file's data
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 * @see #downloadIconDirect(long)
	 * @see #uploadIcon(InputStream, long)
	 */
	public CommandFuture<Long> downloadIcon(OutputStream dataOut, long iconId) {
		String iconPath = "/icon_" + iconId;
		return downloadFile(dataOut, iconPath, 0);
	}
	/**
	 * Downloads an icon from the icon directory in the file repository
	 * and returns the file's bytes as a byte array.
	 * <p>
	 * Note that this method <strong>will read the entire file to memory</strong>.
	 * </p>
	 *
	 * @param iconId
	 * 		the ID of the icon that should be downloaded
	 *
	 * @return a byte array containing the icon file's data
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 * @see #downloadIcon(OutputStream, long)
	 * @see #uploadIconDirect(byte[])
	 */
	public CommandFuture<byte[]> downloadIconDirect(long iconId) {
		String iconPath = "/icon_" + iconId;
		return downloadFileDirect(iconPath, 0);
	}
	/**
	 * Changes a channel's configuration using the given properties.
	 *
	 * @param channelId
	 * 		the ID of the channel to edit
	 * @param options
	 * 		the map of properties to modify
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> editChannel(int channelId, Map<ChannelProperty, String> options) {
		Command cmd = ChannelCommands.channelEdit(channelId, options);
		return executeAndReturnError(cmd);
	}
	/**
	 * Changes a single property of the given channel.
	 * <p>
	 * Note that one can set many properties at once with the overloaded method that
	 * takes a map of channel properties and strings.
	 * </p>
	 *
	 * @param channelId
	 * 		the ID of the channel to edit
	 * @param property
	 * 		the channel property to modify, make sure it is editable
	 * @param value
	 * 		the new value of the property
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #editChannel(int, Map)
	 */
	public CommandFuture<Void> editChannel(int channelId, ChannelProperty property, String value) {
		return editChannel(channelId, Collections.singletonMap(property, value));
	}
	/**
	 * Changes a client's configuration using given properties.
	 * <p>
	 * Only {@link ClientProperty#CLIENT_DESCRIPTION} can be changed for other clients.
	 * To update the current client's properties, use {@link #updateClient(Map)}
	 * or {@link #updateClient(ClientProperty, String)}.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to edit
	 * @param options
	 * 		the map of properties to modify
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #updateClient(Map)
	 */
	public CommandFuture<Void> editClient(int clientId, Map<ClientProperty, String> options) {
		Command cmd = ClientCommands.clientEdit(clientId, options);
		return executeAndReturnError(cmd);
	}
	/**
	 * Changes a single property of the given client.
	 * <p>
	 * Only {@link ClientProperty#CLIENT_DESCRIPTION} can be changed for other clients.
	 * To update the current client's properties, use {@link #updateClient(Map)}
	 * or {@link #updateClient(ClientProperty, String)}.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to edit
	 * @param property
	 * 		the client property to modify, make sure it is editable
	 * @param value
	 * 		the new value of the property
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #editClient(int, Map)
	 * @see #updateClient(Map)
	 */
	public CommandFuture<Void> editClient(int clientId, ClientProperty property, String value) {
		return editClient(clientId, Collections.singletonMap(property, value));
	}
	/**
	 * Changes a client's database settings using given properties.
	 *
	 * @param clientDBId
	 * 		the database ID of the client to edit
	 * @param options
	 * 		the map of properties to modify
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see DatabaseClientInfo
	 * @see Client#getDatabaseId()
	 */
	public CommandFuture<Void> editDatabaseClient(int clientDBId, Map<ClientProperty, String> options) {
		Command cmd = DatabaseClientCommands.clientDBEdit(clientDBId, options);
		return executeAndReturnError(cmd);
	}
	/**
	 * Changes the server instance configuration using given properties.
	 * If the given property is not changeable, {@code IllegalArgumentException} will be thrown.
	 *
	 * @param property
	 * 		the property to edit, must be changeable
	 * @param value
	 * 		the new value for the edit
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code property} is not changeable
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerInstanceProperty#isChangeable()
	 */
	public CommandFuture<Void> editInstance(ServerInstanceProperty property, String value) {
		Command cmd = ServerCommands.instanceEdit(Collections.singletonMap(property, value));
		return executeAndReturnError(cmd);
	}
	/**
	 * Changes the configuration of the selected virtual server using given properties.
	 *
	 * @param options
	 * 		the map of properties to edit
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServerProperty
	 */
	public CommandFuture<Void> editServer(Map<VirtualServerProperty, String> options) {
		Command cmd = VirtualServerCommands.serverEdit(options);
		return executeAndReturnError(cmd);
	}
	/**
	 * Gets a list of all bans on the selected virtual server.
	 *
	 * @return a list of all bans on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Ban
	 */
	public CommandFuture<List<Ban>> getBans() {
		Command cmd = BanCommands.banList();
		return executeAndTransform(cmd, Ban::new);
	}
	/**
	 * Gets a list of IP addresses used by the server instance.
	 *
	 * @return the list of bound IP addresses
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Binding
	 */
	public CommandFuture<List<Binding>> getBindings() {
		Command cmd = ServerCommands.bindingList();
		return executeAndTransform(cmd, Binding::new);
	}
	/**
	 * Finds and returns the channel matching the given name exactly.
	 *
	 * @param name
	 * 		the name of the channel
	 * @param ignoreCase
	 * 		whether the case of the name should be ignored
	 *
	 * @return the found channel or {@code null} if no channel was found
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel
	 * @see #getChannelsByName(String)
	 */
	public CommandFuture<Channel> getChannelByNameExact(String name, boolean ignoreCase) {
		String caseName = ignoreCase ? name.toLowerCase(Locale.ROOT) : name;
		return getChannels().map(allChannels -> {
			for (Channel c : allChannels) {
				String channelName = ignoreCase ? c.getName().toLowerCase(Locale.ROOT) : c.getName();
				if (caseName.equals(channelName)) return c;
			}
			return null; // Not found
		});
	}
	/**
	 * Gets a list of channels whose names contain the given search string.
	 *
	 * @param name
	 * 		the name to search
	 *
	 * @return a list of all channels with names matching the search pattern
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Channel
	 * @see #getChannelByNameExact(String, boolean)
	 */
	public CommandFuture<List<Channel>> getChannelsByName(String name) {
		Command cmd = ChannelCommands.channelFind(name);
		CommandFuture<List<Channel>> future = new CommandFuture<>();
		CommandFuture<List<Integer>> channelIds = executeAndMap(cmd, response -> response.getInt("cid"));
		CommandFuture<List<Channel>> allChannels = getChannels();
		findByKey(channelIds, allChannels, Channel::getId)
				.forwardSuccess(future)
				.onFailure(transformError(future, 768, Collections.emptyList()));
		return future;
	}
	/**
	 * Displays a list of permissions defined for a client in a specific channel.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return a list of permissions for the user in the specified channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public CommandFuture<List<Permission>> getChannelClientPermissions(int channelId, int clientDBId) {
		Command cmd = PermissionCommands.channelClientPermList(channelId, clientDBId);
		return executeAndTransform(cmd, Permission::new);
	}
	/**
	 * Gets all client / channel ID combinations currently assigned to channel groups.
	 * All three parameters are optional and can be turned off by setting it to {@code -1}.
	 *
	 * @param channelId
	 * 		restricts the search to the channel with a specified ID. Set to {@code -1} to ignore.
	 * @param clientDBId
	 * 		restricts the search to the client with a specified database ID. Set to {@code -1} to ignore.
	 * @param groupId
	 * 		restricts the search to the channel group with the specified ID. Set to {@code -1} to ignore.
	 *
	 * @return a list of combinations of channel ID, client database ID and channel group ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 * @see ChannelGroup#getId()
	 * @see ChannelGroupClient
	 */
	public CommandFuture<List<ChannelGroupClient>> getChannelGroupClients(int channelId, int clientDBId, int groupId) {
		Command cmd = ChannelGroupCommands.channelGroupClientList(channelId, clientDBId, groupId);
		return executeAndTransform(cmd, ChannelGroupClient::new);
	}
	/**
	 * Gets all client / channel ID combinations currently assigned to the specified channel group.
	 *
	 * @param groupId
	 * 		the ID of the channel group whose client / channel assignments should be returned.
	 *
	 * @return a list of combinations of channel ID, client database ID and channel group ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see ChannelGroupClient
	 * @see #getChannelGroupClients(int, int, int)
	 */
	public CommandFuture<List<ChannelGroupClient>> getChannelGroupClientsByChannelGroupId(int groupId) {
		return getChannelGroupClients(-1, -1, groupId);
	}
	/**
	 * Gets all channel group assignments in the specified channel.
	 *
	 * @param channelId
	 * 		the ID of the channel whose channel group assignments should be returned.
	 *
	 * @return a list of combinations of channel ID, client database ID and channel group ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see ChannelGroupClient
	 * @see #getChannelGroupClients(int, int, int)
	 */
	public CommandFuture<List<ChannelGroupClient>> getChannelGroupClientsByChannelId(int channelId) {
		return getChannelGroupClients(channelId, -1, -1);
	}
	/**
	 * Gets all channel group assignments for the specified client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client whose channel group
	 *
	 * @return a list of combinations of channel ID, client database ID and channel group ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see ChannelGroupClient
	 * @see #getChannelGroupClients(int, int, int)
	 */
	public CommandFuture<List<ChannelGroupClient>> getChannelGroupClientsByClientDBId(int clientDBId) {
		return getChannelGroupClients(-1, clientDBId, -1);
	}
	/**
	 * Gets a list of all permissions assigned to the specified channel group.
	 *
	 * @param groupId
	 * 		the ID of the channel group.
	 *
	 * @return a list of permissions assigned to the channel group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Permission
	 */
	public CommandFuture<List<Permission>> getChannelGroupPermissions(int groupId) {
		Command cmd = PermissionCommands.channelGroupPermList(groupId);
		return executeAndTransform(cmd, Permission::new);
	}
	/**
	 * Gets a list of all channel groups on the selected virtual server.
	 *
	 * @return a list of all channel groups on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup
	 */
	public CommandFuture<List<ChannelGroup>> getChannelGroups() {
		Command cmd = ChannelGroupCommands.channelGroupList();
		return executeAndTransform(cmd, ChannelGroup::new);
	}
	/**
	 * Gets detailed configuration information about the channel specified channel.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 *
	 * @return information about the channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see ChannelInfo
	 */
	public CommandFuture<ChannelInfo> getChannelInfo(int channelId) {
		Command cmd = ChannelCommands.channelInfo(channelId);
		return executeAndTransformFirst(cmd, map -> new ChannelInfo(channelId, map));
	}
	/**
	 * Gets a list of all permissions assigned to the specified channel.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 *
	 * @return a list of all permissions assigned to the channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Permission
	 */
	public CommandFuture<List<Permission>> getChannelPermissions(int channelId) {
		Command cmd = PermissionCommands.channelPermList(channelId);
		return executeAndTransform(cmd, Permission::new);
	}
	/**
	 * Gets a list of all channels on the selected virtual server.
	 *
	 * @return a list of all channels on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel
	 */
	public CommandFuture<List<Channel>> getChannels() {
		Command cmd = ChannelCommands.channelList();
		return executeAndTransform(cmd, Channel::new);
	}
	/**
	 * Finds and returns the client whose nickname matches the given name exactly.
	 *
	 * @param name
	 * 		the name of the client
	 * @param ignoreCase
	 * 		whether the case of the name should be ignored
	 *
	 * @return the found client or {@code null} if no client was found
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client
	 * @see #getClientsByName(String)
	 */
	public CommandFuture<Client> getClientByNameExact(String name, boolean ignoreCase) {
		String caseName = ignoreCase ? name.toLowerCase(Locale.ROOT) : name;
		return getClients().map(allClients -> {
			for (Client c : allClients) {
				String clientName = ignoreCase ? c.getNickname().toLowerCase(Locale.ROOT) : c.getNickname();
				if (caseName.equals(clientName)) return c;
			}
			return null; // Not found
		});
	}
	/**
	 * Gets a list of clients whose nicknames contain the given search string.
	 *
	 * @param name
	 * 		the name to search
	 *
	 * @return a list of all clients with nicknames matching the search pattern
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Client
	 * @see #getClientByNameExact(String, boolean)
	 */
	public CommandFuture<List<Client>> getClientsByName(String name) {
		Command cmd = ClientCommands.clientFind(name);
		CommandFuture<List<Client>> future = new CommandFuture<>();
		CommandFuture<List<Integer>> clientIds = executeAndMap(cmd, response -> response.getInt("clid"));
		CommandFuture<List<Client>> allClients = getClients();
		findByKey(clientIds, allClients, Client::getId)
				.forwardSuccess(future)
				.onFailure(transformError(future, 512, Collections.emptyList()));
		return future;
	}
	/**
	 * Gets information about the client with the specified unique identifier.
	 *
	 * @param clientUId
	 * 		the unique identifier of the client
	 *
	 * @return information about the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Client#getUniqueIdentifier()
	 * @see ClientInfo
	 */
	public CommandFuture<ClientInfo> getClientByUId(String clientUId) {
		Command cmd = ClientCommands.clientGetIds(clientUId);
		return executeAndReturnIntProperty(cmd, "clid")
				.then(this::getClientInfo);
	}
	/**
	 * Gets information about the client with the specified client ID.
	 *
	 * @param clientId
	 * 		the client ID of the client
	 *
	 * @return information about the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see ClientInfo
	 */
	public CommandFuture<ClientInfo> getClientInfo(int clientId) {
		Command cmd = ClientCommands.clientInfo(clientId);
		return executeAndTransformFirst(cmd, map -> new ClientInfo(clientId, map));
	}
	/**
	 * Gets a list of all permissions assigned to the specified client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return a list of all permissions assigned to the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Permission
	 */
	public CommandFuture<List<Permission>> getClientPermissions(int clientDBId) {
		Command cmd = PermissionCommands.clientPermList(clientDBId);
		return executeAndTransform(cmd, Permission::new);
	}
	/**
	 * Gets a list of all clients on the selected virtual server.
	 *
	 * @return a list of all clients on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client
	 */
	public CommandFuture<List<Client>> getClients() {
		Command cmd = ClientCommands.clientList();
		return executeAndTransform(cmd, Client::new);
	}
	/**
	 * Gets a list of all complaints on the selected virtual server.
	 *
	 * @return a list of all complaints on the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Complaint
	 * @see #getComplaints(int)
	 */
	public CommandFuture<List<Complaint>> getComplaints() {
		return getComplaints(-1);
	}
	/**
	 * Gets a list of all complaints about the specified client.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return a list of all complaints about the specified client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see Complaint
	 */
	public CommandFuture<List<Complaint>> getComplaints(int clientDBId) {
		Command cmd = ComplaintCommands.complainList(clientDBId);
		return executeAndTransform(cmd, Complaint::new);
	}
	/**
	 * Gets detailed connection information about the selected virtual server.
	 *
	 * @return connection information about the selected virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ConnectionInfo
	 * @see #getServerInfo()
	 */
	public CommandFuture<ConnectionInfo> getConnectionInfo() {
		Command cmd = VirtualServerCommands.serverRequestConnectionInfo();
		return executeAndTransformFirst(cmd, ConnectionInfo::new);
	}
	/**
	 * Gets a map of all custom client properties and their values
	 * assigned to the client with database ID {@code clientDBId}.
	 *
	 * @param clientDBId
	 * 		the database ID of the target client
	 *
	 * @return a map of the client's custom client property assignments
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #searchCustomClientProperty(String)
	 * @see #searchCustomClientProperty(String, String)
	 */
	public CommandFuture<Map<String, String>> getCustomClientProperties(int clientDBId) {
		Command cmd = CustomPropertyCommands.customInfo(clientDBId);
		CommandFuture<Map<String, String>> future = cmd.getFuture()
				.map(result -> {
					List<Wrapper> response = result.getResponses();
					Map<String, String> properties = new HashMap<>(response.size());
					for (Wrapper wrapper : response) {
						properties.put(wrapper.get("ident"), wrapper.get("value"));
					}
					return properties;
				});
		commandQueue.enqueueCommand(cmd);
		return future;
	}
	/**
	 * Gets all clients in the database whose last nickname matches the specified name <b>exactly</b>.
	 *
	 * @param name
	 * 		the nickname for the clients to match
	 *
	 * @return a list of all clients with a matching nickname
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1 + n,
	 * where n is the amount of database clients with a matching nickname
	 * @see Client#getNickname()
	 */
	public CommandFuture<List<DatabaseClientInfo>> getDatabaseClientsByName(String name) {
		Command cmd = DatabaseClientCommands.clientDBFind(name, false);
		return executeAndMap(cmd, response -> response.getInt("cldbid"))
				.then(dbClientIds -> {
					Collection<CommandFuture<DatabaseClientInfo>> infoFutures = new ArrayList<>(dbClientIds.size());
					for (int dbClientId : dbClientIds) {
						infoFutures.add(getDatabaseClientInfo(dbClientId));
					}
					return CommandFuture.ofAll(infoFutures);
				});
	}
	/**
	 * Gets information about the client with the specified unique identifier in the server database.
	 *
	 * @param clientUId
	 * 		the unique identifier of the client
	 *
	 * @return the database client or {@code null} if no client was found
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Client#getUniqueIdentifier()
	 * @see DatabaseClientInfo
	 */
	public CommandFuture<DatabaseClientInfo> getDatabaseClientByUId(String clientUId) {
		Command cmd = DatabaseClientCommands.clientDBFind(clientUId, true);
		CommandFuture<DatabaseClientInfo> future = cmd.getFuture()
				.then(result -> {
					if (result.getResponses().isEmpty()) {
						return null;
					} else {
						int databaseId = result.getFirstResponse().getInt("cldbid");
						return getDatabaseClientInfo(databaseId);
					}
				});
		commandQueue.enqueueCommand(cmd);
		return future;
	}
	/**
	 * Gets information about the client with the specified database ID in the server database.
	 *
	 * @param clientDBId
	 * 		the database ID of the client
	 *
	 * @return the database client or {@code null} if no client was found
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see DatabaseClientInfo
	 */
	public CommandFuture<DatabaseClientInfo> getDatabaseClientInfo(int clientDBId) {
		Command cmd = DatabaseClientCommands.clientDBInfo(clientDBId);
		return executeAndTransformFirst(cmd, DatabaseClientInfo::new);
	}
	/**
	 * Gets information about all clients in the server database.
	 * <p>
	 * As this method uses internal commands which can only return 200 clients at once,
	 * this method can take quite some time to execute.
	 * </p><p>
	 * Also keep in mind that the client database can easily accumulate several thousand entries.
	 * </p>
	 *
	 * @return a {@link List} of all database clients
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1 + n,
	 * where n = Math.ceil([amount of database clients] / 200)
	 * @see DatabaseClient
	 */
	public CommandFuture<List<DatabaseClient>> getDatabaseClients() {
		Command cmd = DatabaseClientCommands.clientDBList(0, 1, true);
		return executeAndReturnIntProperty(cmd, "count")
				.then(count -> {
					Collection<CommandFuture<List<DatabaseClient>>> futures = new ArrayList<>((count + 199) / 200);
					for (int i = 0; i < count; i += 200) {
						futures.add(getDatabaseClients(i, 200));
					}
					return CommandFuture.ofAll(futures);
				}).map(listOfLists -> listOfLists.stream()
						.flatMap(List::stream)
						.collect(Collectors.toList()));
	}
	/**
	 * Gets information about a set number of clients in the server database, starting at {@code offset}.
	 *
	 * @param offset
	 * 		the index of the first database client to be returned.
	 * 		Note that this is <b>not</b> a database ID, but an arbitrary, 0-based index.
	 * @param count
	 * 		the number of database clients that should be returned.
	 * 		Any integer greater than 200 might cause problems with the connection
	 *
	 * @return a {@link List} of database clients
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see DatabaseClient
	 */
	public CommandFuture<List<DatabaseClient>> getDatabaseClients(int offset, int count) {
		Command cmd = DatabaseClientCommands.clientDBList(offset, count, false);
		return executeAndTransform(cmd, DatabaseClient::new);
	}
	/**
	 * Gets information about a file on the file repository in the specified channel.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePath
	 * 		the path to the file
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 *
	 * @return some information about the file
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<FileInfo> getFileInfo(String filePath, int channelId) {
		return getFileInfo(filePath, channelId, null);
	}
	/**
	 * Gets information about a file on the file repository in the specified channel.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePath
	 * 		the path to the file
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return some information about the file
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<FileInfo> getFileInfo(String filePath, int channelId, String channelPassword) {
		Command cmd = FileCommands.ftGetFileInfo(channelId, channelPassword, filePath);
		return executeAndTransformFirst(cmd, FileInfo::new);
	}
	/**
	 * Gets information about multiple files on the file repository in the specified channel.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePaths
	 * 		the paths to the files
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 *
	 * @return some information about the file
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<List<FileInfo>> getFileInfos(String[] filePaths, int channelId) {
		return getFileInfos(filePaths, channelId, null);
	}
	/**
	 * Gets information about multiple files on the file repository in the specified channel.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePaths
	 * 		the paths to the files
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return some information about the file
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<List<FileInfo>> getFileInfos(String[] filePaths, int channelId, String channelPassword) {
		Command cmd = FileCommands.ftGetFileInfo(channelId, channelPassword, filePaths);
		return executeAndTransform(cmd, FileInfo::new);
	}
	/**
	 * Gets information about multiple files on the file repository in multiple channels.
	 * <p>
	 * Note that this method does not work on directories and the information returned by this
	 * method is identical to the one returned by {@link #getFileList(String, int, String)}
	 * </p>
	 *
	 * @param filePaths
	 * 		the paths to the files, may not be {@code null} and may not contain {@code null} elements
	 * @param channelIds
	 * 		the IDs of the channels the file resides in, may not be {@code null}
	 * @param channelPasswords
	 * 		the passwords of those channels, may be {@code null} and may contain {@code null} elements
	 *
	 * @return some information about the files
	 *
	 * @throws IllegalArgumentException
	 * 		if the dimensions of {@code filePaths}, {@code channelIds} and {@code channelPasswords} don't match
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<List<FileInfo>> getFileInfos(String[] filePaths, int[] channelIds, String[] channelPasswords) {
		Command cmd = FileCommands.ftGetFileInfo(channelIds, channelPasswords, filePaths);
		return executeAndTransform(cmd, FileInfo::new);
	}
	/**
	 * Gets a list of files and directories in the specified parent directory and channel.
	 *
	 * @param directoryPath
	 * 		the path to the parent directory
	 * @param channelId
	 * 		the ID of the channel the directory resides in
	 *
	 * @return the files and directories in the parent directory
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<List<FileListEntry>> getFileList(String directoryPath, int channelId) {
		return getFileList(directoryPath, channelId, null);
	}
	/**
	 * Gets a list of files and directories in the specified parent directory and channel.
	 *
	 * @param directoryPath
	 * 		the path to the parent directory
	 * @param channelId
	 * 		the ID of the channel the directory resides in
	 * @param channelPassword
	 * 		the password of that channel
	 *
	 * @return the files and directories in the parent directory
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 */
	public CommandFuture<List<FileListEntry>> getFileList(String directoryPath, int channelId, String channelPassword) {
		Command cmd = FileCommands.ftGetFileList(directoryPath, channelId, channelPassword);
		return executeAndTransform(cmd, FileListEntry::new);
	}
	/**
	 * Gets a list of active or recently active file transfers.
	 *
	 * @return a list of file transfers
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<FileTransfer>> getFileTransfers() {
		Command cmd = FileCommands.ftList();
		return executeAndTransform(cmd, FileTransfer::new);
	}
	/**
	 * Displays detailed configuration information about the server instance including
	 * uptime, number of virtual servers online, traffic information, etc.
	 *
	 * @return information about the host
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<HostInfo> getHostInfo() {
		Command cmd = ServerCommands.hostInfo();
		return executeAndTransformFirst(cmd, HostInfo::new);
	}
	/**
	 * Gets a list of all icon files on this virtual server.
	 *
	 * @return a list of all icons
	 */
	public CommandFuture<List<IconFile>> getIconList() {
		return getFileList("/icons/", 0)
				.map(result -> {
					List<IconFile> icons = new ArrayList<>(result.size());
					for (FileListEntry file : result) {
						if (file.isDirectory() || file.isStillUploading()) continue;
						icons.add(new IconFile(file.getMap()));
					}
					return icons;
				});
	}
	/**
	 * Displays the server instance configuration including database revision number,
	 * the file transfer port, default group IDs, etc.
	 *
	 * @return information about the TeamSpeak server instance.
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<InstanceInfo> getInstanceInfo() {
		Command cmd = ServerCommands.instanceInfo();
		return executeAndTransformFirst(cmd, InstanceInfo::new);
	}
	/**
	 * Fetches the specified amount of log entries from the server log.
	 *
	 * @param lines
	 * 		the amount of log entries to fetch, in the range between 1 and 100.
	 * 		Returns 100 entries if the argument is not in range
	 *
	 * @return a list of the latest log entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<String>> getInstanceLogEntries(int lines) {
		Command cmd = ServerCommands.logView(lines, true);
		return executeAndMap(cmd, response -> response.get("l"));
	}
	/**
	 * Fetches the last 100 log entries from the server log.
	 *
	 * @return a list of up to 100 log entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<String>> getInstanceLogEntries() {
		return getInstanceLogEntries(100);
	}
	/**
	 * Reads the message body of a message. This will not set the read flag, though.
	 *
	 * @param messageId
	 * 		the ID of the message to be read
	 *
	 * @return the body of the message with the specified ID or {@code null} if there was no message with that ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Message#getId()
	 * @see #setMessageRead(int)
	 */
	public CommandFuture<String> getOfflineMessage(int messageId) {
		Command cmd = MessageCommands.messageGet(messageId);
		return executeAndReturnStringProperty(cmd, "message");
	}
	/**
	 * Reads the message body of a message. This will not set the read flag, though.
	 *
	 * @param message
	 * 		the message to be read
	 *
	 * @return the body of the message with the specified ID or {@code null} if there was no message with that ID
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Message#getId()
	 * @see #setMessageRead(Message)
	 */
	public CommandFuture<String> getOfflineMessage(Message message) {
		return getOfflineMessage(message.getId());
	}
	/**
	 * Gets a list of all offline messages for the server query.
	 * The returned messages lack their message body, though.
	 * To read the actual message, use {@link #getOfflineMessage(int)} or {@link #getOfflineMessage(Message)}.
	 *
	 * @return a list of all offline messages this server query has received
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<Message>> getOfflineMessages() {
		Command cmd = MessageCommands.messageList();
		return executeAndTransform(cmd, Message::new);
	}
	/**
	 * Displays detailed information about all assignments of the permission specified
	 * with {@code permName}. The output includes the type and the ID of the client,
	 * channel or group associated with the permission.
	 *
	 * @param permName
	 * 		the name of the permission
	 *
	 * @return a list of permission assignments
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #getPermissionOverview(int, int)
	 */
	public CommandFuture<List<PermissionAssignment>> getPermissionAssignments(String permName) {
		Command cmd = PermissionCommands.permFind(permName);
		CommandFuture<List<PermissionAssignment>> future = new CommandFuture<>();
		executeAndTransform(cmd, PermissionAssignment::new)
				.forwardSuccess(future)
				.onFailure(transformError(future, 2562, Collections.emptyList()));
		return future;
	}
	/**
	 * Gets the ID of the permission specified by {@code permName}.
	 * <p>
	 * Note that the use of numeric permission IDs is deprecated
	 * and that this API only uses the string variant of the IDs.
	 * </p>
	 *
	 * @param permName
	 * 		the name of the permission
	 *
	 * @return the numeric ID of the specified permission
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Integer> getPermissionIdByName(String permName) {
		Command cmd = PermissionCommands.permIdGetByName(permName);
		return executeAndReturnIntProperty(cmd, "permid");
	}
	/**
	 * Gets the IDs of the permissions specified by {@code permNames}.
	 * <p>
	 * Note that the use of numeric permission IDs is deprecated
	 * and that this API only uses the string variant of the IDs.
	 * </p>
	 *
	 * @param permNames
	 * 		the names of the permissions
	 *
	 * @return the numeric IDs of the specified permission
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code permNames} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<int[]> getPermissionIdsByName(String... permNames) {
		Command cmd = PermissionCommands.permIdGetByName(permNames);
		return executeAndReturnIntArray(cmd, "permid");
	}
	/**
	 * Gets a list of all assigned permissions for a client in a specified channel.
	 * If you do not care about channel permissions, set {@code channelId} to {@code 0}.
	 *
	 * @param channelId
	 * 		the ID of the channel
	 * @param clientDBId
	 * 		the database ID of the client to create the overview for
	 *
	 * @return a list of all permission assignments for the client in the specified channel
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 */
	public CommandFuture<List<PermissionAssignment>> getPermissionOverview(int channelId, int clientDBId) {
		Command cmd = PermissionCommands.permOverview(channelId, clientDBId);
		return executeAndTransform(cmd, PermissionAssignment::new);
	}
	/**
	 * Displays a list of all permissions, including ID, name and description.
	 *
	 * @return a list of all permissions
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<PermissionInfo>> getPermissions() {
		Command cmd = PermissionCommands.permissionList();
		return executeAndTransform(cmd, PermissionInfo::new);
	}
	/**
	 * Displays the current value of the specified permission for this server query instance.
	 *
	 * @param permName
	 * 		the name of the permission
	 *
	 * @return the permission value, usually ranging from 0 to 100
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Integer> getPermissionValue(String permName) {
		Command cmd = PermissionCommands.permGet(permName);
		return executeAndReturnIntProperty(cmd, "permvalue");
	}
	/**
	 * Displays the current values of the specified permissions for this server query instance.
	 *
	 * @param permNames
	 * 		the names of the permissions
	 *
	 * @return the permission values, usually ranging from 0 to 100
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code permNames} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<int[]> getPermissionValues(String... permNames) {
		Command cmd = PermissionCommands.permGet(permNames);
		return executeAndReturnIntArray(cmd, "permvalue");
	}
	/**
	 * Gets a list of all available tokens to join channel or server groups,
	 * including their type and group IDs.
	 *
	 * @return a list of all generated, but still unclaimed privilege keys
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #usePrivilegeKey(String)
	 */
	public CommandFuture<List<PrivilegeKey>> getPrivilegeKeys() {
		Command cmd = PrivilegeKeyCommands.privilegeKeyList();
		return executeAndTransform(cmd, PrivilegeKey::new);
	}
	/**
	 * Gets a list of all clients in the specified server group.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group for which the clients should be looked up
	 *
	 * @return a list of all clients in the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<ServerGroupClient>> getServerGroupClients(int serverGroupId) {
		Command cmd = ServerGroupCommands.serverGroupClientList(serverGroupId);
		return executeAndTransform(cmd, ServerGroupClient::new);
	}
	/**
	 * Gets a list of all clients in the specified server group.
	 *
	 * @param serverGroup
	 * 		the server group for which the clients should be looked up
	 *
	 * @return a list of all clients in the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<ServerGroupClient>> getServerGroupClients(ServerGroup serverGroup) {
		return getServerGroupClients(serverGroup.getId());
	}
	/**
	 * Gets a list of all permissions assigned to the specified server group.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group for which the permissions should be looked up
	 *
	 * @return a list of all permissions assigned to the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see #getServerGroupPermissions(ServerGroup)
	 */
	public CommandFuture<List<Permission>> getServerGroupPermissions(int serverGroupId) {
		Command cmd = PermissionCommands.serverGroupPermList(serverGroupId);
		return executeAndTransform(cmd, Permission::new);
	}
	/**
	 * Gets a list of all permissions assigned to the specified server group.
	 *
	 * @param serverGroup
	 * 		the server group for which the permissions should be looked up
	 *
	 * @return a list of all permissions assigned to the server group
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<Permission>> getServerGroupPermissions(ServerGroup serverGroup) {
		return getServerGroupPermissions(serverGroup.getId());
	}
	/**
	 * Gets a list of all server groups on the virtual server.
	 * <p>
	 * Depending on your permissions, the output may also contain
	 * global server query groups and template groups.
	 * </p>
	 *
	 * @return a list of all server groups
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<ServerGroup>> getServerGroups() {
		Command cmd = ServerGroupCommands.serverGroupList();
		return executeAndTransform(cmd, ServerGroup::new);
	}
	/**
	 * Gets a list of all server groups set for a client.
	 *
	 * @param clientDatabaseId
	 * 		the database ID of the client for which the server groups should be looked up
	 *
	 * @return a list of all server groups set for the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see Client#getDatabaseId()
	 * @see #getServerGroupsByClient(Client)
	 */
	public CommandFuture<List<ServerGroup>> getServerGroupsByClientId(int clientDatabaseId) {
		Command cmd = ServerGroupCommands.serverGroupsByClientId(clientDatabaseId);
		CommandFuture<List<Integer>> serverGroupIds = executeAndMap(cmd, response -> response.getInt("sgid"));
		CommandFuture<List<ServerGroup>> allServerGroups = getServerGroups();
		return findByKey(serverGroupIds, allServerGroups, ServerGroup::getId);
	}
	/**
	 * Gets a list of all server groups set for a client.
	 *
	 * @param client
	 * 		the client for which the server groups should be looked up
	 *
	 * @return a list of all server group set for the client
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 2
	 * @see #getServerGroupsByClientId(int)
	 */
	public CommandFuture<List<ServerGroup>> getServerGroupsByClient(Client client) {
		return getServerGroupsByClientId(client.getDatabaseId());
	}
	/**
	 * Gets the ID of a virtual server by its port.
	 *
	 * @param port
	 * 		the port of a virtual server
	 *
	 * @return the ID of the virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getPort()
	 * @see VirtualServer#getId()
	 */
	public CommandFuture<Integer> getServerIdByPort(int port) {
		Command cmd = VirtualServerCommands.serverIdGetByPort(port);
		return executeAndReturnIntProperty(cmd, "server_id");
	}
	/**
	 * Gets detailed information about the virtual server the server query is currently in.
	 *
	 * @return information about the current virtual server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<VirtualServerInfo> getServerInfo() {
		Command cmd = VirtualServerCommands.serverInfo();
		return executeAndTransformFirst(cmd, VirtualServerInfo::new);
	}
	/**
	 * Gets a list of all server query logins (containing login name, virtual server ID, and client database ID).
	 * If a virtual server is selected, only the server query logins of the selected virtual server are returned.
	 *
	 * @return a list of {@code QueryLogin} objects describing existing server query logins
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addServerQueryLogin(String, int)
	 * @see #deleteServerQueryLogin(int)
	 * @see #getServerQueryLoginsByName(String)
	 * @see #updateServerQueryLogin(String)
	 */
	public CommandFuture<List<QueryLogin>> getServerQueryLogins() {
		return getServerQueryLoginsByName(null);
	}
	/**
	 * Gets a list of all server query logins (containing login name, virtual server ID, and client database ID)
	 * whose login name matches the specified SQL-like pattern.
	 * If a virtual server is selected, only the server query logins of the selected virtual server are returned.
	 *
	 * @param pattern
	 * 		the SQL-like pattern to match the server query login name against
	 *
	 * @return a list of {@code QueryLogin} objects describing existing server query logins
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addServerQueryLogin(String, int)
	 * @see #deleteServerQueryLogin(int)
	 * @see #getServerQueryLogins()
	 * @see #updateServerQueryLogin(String)
	 */
	public CommandFuture<List<QueryLogin>> getServerQueryLoginsByName(String pattern) {
		Command cmd = QueryLoginCommands.queryLoginList(pattern);
		return executeAndTransform(cmd, QueryLogin::new);
	}
	/**
	 * Gets the version, build number and platform of the TeamSpeak3 server.
	 *
	 * @return the version information of the server
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Version> getVersion() {
		Command cmd = ServerCommands.version();
		return executeAndTransformFirst(cmd, Version::new);
	}
	/**
	 * Gets a list of all virtual servers including their ID, status, number of clients online, etc.
	 *
	 * @return a list of all virtual servers
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<VirtualServer>> getVirtualServers() {
		Command cmd = VirtualServerCommands.serverList();
		return executeAndTransform(cmd, VirtualServer::new);
	}
	/**
	 * Fetches the specified amount of log entries from the currently selected virtual server.
	 * If no virtual server is selected, the entries will be read from the server log instead.
	 *
	 * @param lines
	 * 		the amount of log entries to fetch, in the range between 1 and 100.
	 * 		Returns 100 entries if the argument is not in range
	 *
	 * @return a list of the latest log entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<String>> getVirtualServerLogEntries(int lines) {
		Command cmd = ServerCommands.logView(lines, false);
		return executeAndMap(cmd, response -> response.get("l"));
	}
	/**
	 * Fetches the last 100 log entries from the currently selected virtual server.
	 * If no virtual server is selected, the entries will be read from the server log instead.
	 *
	 * @return a list of up to 100 log entries
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<List<String>> getVirtualServerLogEntries() {
		return getVirtualServerLogEntries(100);
	}
	/**
	 * Checks whether the client with the specified client ID is online.
	 * <p>
	 * Please note that there is no guarantee that the client will still be
	 * online by the time the next command is executed.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client
	 *
	 * @return {@code true} if the client is online, {@code false} otherwise
	 *
	 * @querycommands 1
	 * @see #getClientInfo(int)
	 */
	public CommandFuture<Boolean> isClientOnline(int clientId) {
		Command cmd = ClientCommands.clientInfo(clientId);
		CommandFuture<Boolean> future = new CommandFuture<>();
		cmd.getFuture()
				.onSuccess(__ -> future.set(true))
				.onFailure(transformError(future, 512, false));
		commandQueue.enqueueCommand(cmd);
		return future;
	}
	/**
	 * Checks whether the client with the specified unique identifier is online.
	 * <p>
	 * Please note that there is no guarantee that the client will still be
	 * online by the time the next command is executed.
	 * </p>
	 *
	 * @param clientUId
	 * 		the unique ID of the client
	 *
	 * @return {@code true} if the client is online, {@code false} otherwise
	 *
	 * @querycommands 1
	 * @see #getClientByUId(String)
	 */
	public CommandFuture<Boolean> isClientOnline(String clientUId) {
		Command cmd = ClientCommands.clientGetIds(clientUId);
		CommandFuture<Boolean> future = cmd.getFuture()
				.map(result -> !result.getResponses().isEmpty());
		commandQueue.enqueueCommand(cmd);
		return future;
	}
	/**
	 * Kicks one or more clients from their current channels.
	 * This will move the kicked clients into the default channel and
	 * won't do anything if the clients are already in the default channel.
	 *
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromChannel(Client...)
	 * @see #kickClientFromChannel(String, int...)
	 */
	public CommandFuture<Void> kickClientFromChannel(int... clientIds) {
		return kickClients(ReasonIdentifier.REASON_KICK_CHANNEL, null, clientIds);
	}
	/**
	 * Kicks one or more clients from their current channels.
	 * This will move the kicked clients into the default channel and
	 * won't do anything if the clients are already in the default channel.
	 *
	 * @param clients
	 * 		the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromChannel(int...)
	 * @see #kickClientFromChannel(String, Client...)
	 */
	public CommandFuture<Void> kickClientFromChannel(Client... clients) {
		return kickClients(ReasonIdentifier.REASON_KICK_CHANNEL, null, clients);
	}
	/**
	 * Kicks one or more clients from their current channels for the specified reason.
	 * This will move the kicked clients into the default channel and
	 * won't do anything if the clients are already in the default channel.
	 *
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #kickClientFromChannel(int...)
	 * @see #kickClientFromChannel(String, Client...)
	 */
	public CommandFuture<Void> kickClientFromChannel(String message, int... clientIds) {
		return kickClients(ReasonIdentifier.REASON_KICK_CHANNEL, message, clientIds);
	}
	/**
	 * Kicks one or more clients from their current channels for the specified reason.
	 * This will move the kicked clients into the default channel and
	 * won't do anything if the clients are already in the default channel.
	 *
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clients
	 * 		the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromChannel(Client...)
	 * @see #kickClientFromChannel(String, int...)
	 */
	public CommandFuture<Void> kickClientFromChannel(String message, Client... clients) {
		return kickClients(ReasonIdentifier.REASON_KICK_CHANNEL, message, clients);
	}
	/**
	 * Kicks one or more clients from the server.
	 *
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #kickClientFromServer(Client...)
	 * @see #kickClientFromServer(String, int...)
	 */
	public CommandFuture<Void> kickClientFromServer(int... clientIds) {
		return kickClients(ReasonIdentifier.REASON_KICK_SERVER, null, clientIds);
	}
	/**
	 * Kicks one or more clients from the server.
	 *
	 * @param clients
	 * 		the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromServer(int...)
	 * @see #kickClientFromServer(String, Client...)
	 */
	public CommandFuture<Void> kickClientFromServer(Client... clients) {
		return kickClients(ReasonIdentifier.REASON_KICK_SERVER, null, clients);
	}
	/**
	 * Kicks one or more clients from the server for the specified reason.
	 *
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see #kickClientFromServer(int...)
	 * @see #kickClientFromServer(String, Client...)
	 */
	public CommandFuture<Void> kickClientFromServer(String message, int... clientIds) {
		return kickClients(ReasonIdentifier.REASON_KICK_SERVER, message, clientIds);
	}
	/**
	 * Kicks one or more clients from the server for the specified reason.
	 *
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clients
	 * 		the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #kickClientFromServer(Client...)
	 * @see #kickClientFromServer(String, int...)
	 */
	public CommandFuture<Void> kickClientFromServer(String message, Client... clients) {
		return kickClients(ReasonIdentifier.REASON_KICK_SERVER, message, clients);
	}
	/**
	 * Kicks a list of clients from either the channel or the server for a given reason.
	 *
	 * @param reason
	 * 		where to kick the clients from
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clients
	 * 		the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	private CommandFuture<Void> kickClients(ReasonIdentifier reason, String message, Client... clients) {
		int[] clientIds = new int[clients.length];
		for (int i = 0; i < clients.length; ++i) {
			clientIds[i] = clients[i].getId();
		}
		return kickClients(reason, message, clientIds);
	}
	/**
	 * Kicks a list of clients from either the channel or the server for a given reason.
	 *
	 * @param reason
	 * 		where to kick the clients from
	 * @param message
	 * 		the reason message to display to the clients
	 * @param clientIds
	 * 		the IDs of the clients to kick
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 */
	private CommandFuture<Void> kickClients(ReasonIdentifier reason, String message, int... clientIds) {
		Command cmd = ClientCommands.clientKick(reason, message, clientIds);
		return executeAndReturnError(cmd);
	}
	/**
	 * Logs the server query in using the specified username and password.
	 * <p>
	 * Note that you can also set the login in the {@link TS3Config},
	 * so that you will be logged in right after the connection is established.
	 * </p>
	 *
	 * @param username
	 * 		the username of the server query
	 * @param password
	 * 		the password to use
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #logout()
	 */
	public CommandFuture<Void> login(String username, String password) {
		Command cmd = QueryCommands.logIn(username, password);
		return executeAndReturnError(cmd);
	}
	/**
	 * Logs the server query out and deselects the current virtual server.
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #login(String, String)
	 */
	public CommandFuture<Void> logout() {
		Command cmd = QueryCommands.logOut();
		return executeAndReturnError(cmd);
	}
	/**
	 * Moves a channel to a new parent channel specified by its ID.
	 * To move a channel to root level, set {@code channelTargetId} to {@code 0}.
	 * <p>
	 * This will move the channel right below the specified parent channel, above all other child channels.
	 * This command will fail if the channel already has the specified target channel as the parent channel.
	 * </p>
	 *
	 * @param channelId
	 * 		the channel to move
	 * @param channelTargetId
	 * 		the new parent channel for the specified channel
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #moveChannel(int, int, int)
	 */
	public CommandFuture<Void> moveChannel(int channelId, int channelTargetId) {
		return moveChannel(channelId, channelTargetId, 0);
	}
	/**
	 * Moves a channel to a new parent channel specified by its ID.
	 * To move a channel to root level, set {@code channelTargetId} to {@code 0}.
	 * <p>
	 * The channel will be ordered below the channel with the ID specified by {@code order}.
	 * To move the channel right below the parent channel, set {@code order} to {@code 0}.
	 * </p><p>
	 * Note that you can't re-order a channel without also changing its parent channel with this method.
	 * Use {@link #editChannel(int, ChannelProperty, String)} to change {@link ChannelProperty#CHANNEL_ORDER} instead.
	 * </p>
	 *
	 * @param channelId
	 * 		the channel to move
	 * @param channelTargetId
	 * 		the new parent channel for the specified channel
	 * @param order
	 * 		the channel to sort the specified channel below
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #moveChannel(int, int)
	 */
	public CommandFuture<Void> moveChannel(int channelId, int channelTargetId, int order) {
		Command cmd = ChannelCommands.channelMove(channelId, channelTargetId, order);
		return executeAndReturnError(cmd);
	}
	/**
	 * Moves a single client into a channel.
	 * <p>
	 * Consider using {@link #moveClients(int[], int)} to move multiple clients.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to move
	 * @param channelId
	 * 		the ID of the channel to move the client into
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> moveClient(int clientId, int channelId) {
		return moveClient(clientId, channelId, null);
	}
	/**
	 * Moves multiple clients into a channel.
	 * Immediately returns {@code true} for an empty client ID array.
	 * <p>
	 * Use this method instead of {@link #moveClient(int, int)} for moving
	 * several clients as this will only send 1 command to the server and thus complete faster.
	 * </p>
	 *
	 * @param clientIds
	 * 		the IDs of the clients to move, cannot be {@code null}
	 * @param channelId
	 * 		the ID of the channel to move the clients into
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code clientIds} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> moveClients(int[] clientIds, int channelId) {
		return moveClients(clientIds, channelId, null);
	}
	/**
	 * Moves a single client into a channel.
	 * <p>
	 * Consider using {@link #moveClients(Client[], ChannelBase)} to move multiple clients.
	 * </p>
	 *
	 * @param client
	 * 		the client to move, cannot be {@code null}
	 * @param channel
	 * 		the channel to move the client into, cannot be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code client} or {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> moveClient(Client client, ChannelBase channel) {
		return moveClient(client, channel, null);
	}
	/**
	 * Moves multiple clients into a channel.
	 * Immediately returns {@code true} for an empty client array.
	 * <p>
	 * Use this method instead of {@link #moveClient(Client, ChannelBase)} for moving
	 * several clients as this will only send 1 command to the server and thus complete faster.
	 * </p>
	 *
	 * @param clients
	 * 		the clients to move, cannot be {@code null}
	 * @param channel
	 * 		the channel to move the clients into, cannot be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code clients} or {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> moveClients(Client[] clients, ChannelBase channel) {
		return moveClients(clients, channel, null);
	}
	/**
	 * Moves a single client into a channel using the specified password.
	 * <p>
	 * Consider using {@link #moveClients(int[], int, String)} to move multiple clients.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to move
	 * @param channelId
	 * 		the ID of the channel to move the client into
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> moveClient(int clientId, int channelId, String channelPassword) {
		Command cmd = ClientCommands.clientMove(clientId, channelId, channelPassword);
		return executeAndReturnError(cmd);
	}
	/**
	 * Moves multiple clients into a channel using the specified password.
	 * Immediately returns {@code true} for an empty client ID array.
	 * <p>
	 * Use this method instead of {@link #moveClient(int, int, String)} for moving
	 * several clients as this will only send 1 command to the server and thus complete faster.
	 * </p>
	 *
	 * @param clientIds
	 * 		the IDs of the clients to move, cannot be {@code null}
	 * @param channelId
	 * 		the ID of the channel to move the clients into
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code clientIds} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> moveClients(int[] clientIds, int channelId, String channelPassword) {
		if (clientIds == null) throw new IllegalArgumentException("Client ID array was null");
		if (clientIds.length == 0) return CommandFuture.immediate(null); // Success
		Command cmd = ClientCommands.clientMove(clientIds, channelId, channelPassword);
		return executeAndReturnError(cmd);
	}
	/**
	 * Moves a single client into a channel using the specified password.
	 * <p>
	 * Consider using {@link #moveClients(Client[], ChannelBase, String)} to move multiple clients.
	 * </p>
	 *
	 * @param client
	 * 		the client to move, cannot be {@code null}
	 * @param channel
	 * 		the channel to move the client into, cannot be {@code null}
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code client} or {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> moveClient(Client client, ChannelBase channel, String channelPassword) {
		if (client == null) throw new IllegalArgumentException("Client cannot be null");
		if (channel == null) throw new IllegalArgumentException("Channel cannot be null");
		return moveClient(client.getId(), channel.getId(), channelPassword);
	}
	/**
	 * Moves multiple clients into a channel using the specified password.
	 * Immediately returns {@code true} for an empty client array.
	 * <p>
	 * Use this method instead of {@link #moveClient(Client, ChannelBase, String)} for moving
	 * several clients as this will only send 1 command to the server and thus complete faster.
	 * </p>
	 *
	 * @param clients
	 * 		the clients to move, cannot be {@code null}
	 * @param channel
	 * 		the channel to move the clients into, cannot be {@code null}
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code clients} or {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> moveClients(Client[] clients, ChannelBase channel, String channelPassword) {
		if (clients == null) throw new IllegalArgumentException("Client array cannot be null");
		if (channel == null) throw new IllegalArgumentException("Channel cannot be null");
		int[] clientIds = new int[clients.length];
		for (int i = 0; i < clients.length; i++) {
			clientIds[i] = clients[i].getId();
		}
		return moveClients(clientIds, channel.getId(), channelPassword);
	}
	/**
	 * Moves and renames a file on the file repository within the same channel.
	 *
	 * @param oldPath
	 * 		the current path to the file
	 * @param newPath
	 * 		the desired new path
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #moveFile(String, String, int, int) moveFile to a different channel
	 */
	public CommandFuture<Void> moveFile(String oldPath, String newPath, int channelId) {
		return moveFile(oldPath, newPath, channelId, null);
	}
	/**
	 * Renames a file on the file repository and moves it to a new path in a different channel.
	 *
	 * @param oldPath
	 * 		the current path to the file
	 * @param newPath
	 * 		the desired new path
	 * @param oldChannelId
	 * 		the ID of the channel the file currently resides in
	 * @param newChannelId
	 * 		the ID of the channel the file should be moved to
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #moveFile(String, String, int) moveFile within the same channel
	 */
	public CommandFuture<Void> moveFile(String oldPath, String newPath, int oldChannelId, int newChannelId) {
		return moveFile(oldPath, newPath, oldChannelId, null, newChannelId, null);
	}
	/**
	 * Moves and renames a file on the file repository within the same channel.
	 *
	 * @param oldPath
	 * 		the current path to the file
	 * @param newPath
	 * 		the desired new path
	 * @param channelId
	 * 		the ID of the channel the file resides in
	 * @param channelPassword
	 * 		the password of the channel
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #moveFile(String, String, int, String, int, String) moveFile to a different channel
	 */
	public CommandFuture<Void> moveFile(String oldPath, String newPath, int channelId, String channelPassword) {
		Command cmd = FileCommands.ftRenameFile(oldPath, newPath, channelId, channelPassword);
		return executeAndReturnError(cmd);
	}
	/**
	 * Renames a file on the file repository and moves it to a new path in a different channel.
	 *
	 * @param oldPath
	 * 		the current path to the file
	 * @param newPath
	 * 		the desired new path
	 * @param oldChannelId
	 * 		the ID of the channel the file currently resides in
	 * @param oldPassword
	 * 		the password of the current channel
	 * @param newChannelId
	 * 		the ID of the channel the file should be moved to
	 * @param newPassword
	 * 		the password of the new channel
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #moveFile(String, String, int, String) moveFile within the same channel
	 */
	public CommandFuture<Void> moveFile(String oldPath, String newPath, int oldChannelId, String oldPassword, int newChannelId, String newPassword) {
		Command cmd = FileCommands.ftRenameFile(oldPath, newPath, oldChannelId, oldPassword, newChannelId, newPassword);
		return executeAndReturnError(cmd);
	}
	/**
	 * Moves the server query into a channel.
	 *
	 * @param channelId
	 * 		the ID of the channel to move the server query into
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> moveQuery(int channelId) {
		return moveClient(0, channelId, null);
	}
	/**
	 * Moves the server query into a channel.
	 *
	 * @param channel
	 * 		the channel to move the server query into, cannot be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> moveQuery(ChannelBase channel) {
		if (channel == null) throw new IllegalArgumentException("Channel cannot be null");
		return moveClient(0, channel.getId(), null);
	}
	/**
	 * Moves the server query into a channel using the specified password.
	 *
	 * @param channelId
	 * 		the ID of the channel to move the client into
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> moveQuery(int channelId, String channelPassword) {
		return moveClient(0, channelId, channelPassword);
	}
	/**
	 * Moves the server query into a channel using the specified password.
	 *
	 * @param channel
	 * 		the channel to move the client into, cannot be {@code null}
	 * @param channelPassword
	 * 		the password of the channel, can be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code channel} is {@code null}
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> moveQuery(ChannelBase channel, String channelPassword) {
		if (channel == null) throw new IllegalArgumentException("Channel cannot be null");
		return moveClient(0, channel.getId(), channelPassword);
	}
	/**
	 * Pokes the client with the specified client ID.
	 * This opens up a small popup window for the client containing your message and plays a sound.
	 * The displayed message will be formatted like this: <br>
	 * {@code hh:mm:ss - "Your Nickname" poked you: <your message in green color>}
	 * <p>
	 * The displayed message length is limited to 100 UTF-8 bytes.
	 * If a client has already received a poke message, all subsequent pokes will simply add a line
	 * to the already opened popup window and will still play a sound.
	 * </p>
	 *
	 * @param clientId
	 * 		the ID of the client to poke
	 * @param message
	 * 		the message to send, may contain BB codes
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 */
	public CommandFuture<Void> pokeClient(int clientId, String message) {
		Command cmd = ClientCommands.clientPoke(clientId, message);
		return executeAndReturnError(cmd);
	}
	/**
	 * Terminates the connection with the TeamSpeak3 server.
	 * <p>
	 * This command should never be executed by a user of this API,
	 * as it leaves the query in an undefined state. To terminate
	 * a connection regularly, use {@link TS3Query#exit()}.
	 * </p>
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	CommandFuture<Void> quit() {
		Command cmd = QueryCommands.quit();
		return executeAndReturnError(cmd);
	}
	/**
	 * Registers the server query to receive notifications about all server events.
	 * <p>
	 * This means that the following actions will trigger event notifications:
	 * </p>
	 * <ul>
	 * <li>A client joins the server or disconnects from it</li>
	 * <li>A client switches channels</li>
	 * <li>A client sends a server message</li>
	 * <li>A client sends a channel message <b>in the channel the query is in</b></li>
	 * <li>A client sends a private message to <b>the server query</b></li>
	 * <li>A client uses a privilege key</li>
	 * </ul>
	 * <p>
	 * The limitations to when the query receives notifications about chat events cannot be circumvented.
	 * </p>
	 * To be able to process these events in your application, register an event listener.
	 *
	 * @return whether all commands succeeded or not
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 6
	 * @see #addTS3Listeners(TS3Listener...)
	 */
	public CommandFuture<Void> registerAllEvents() {
		Collection<CommandFuture<Void>> eventFutures = Arrays.asList(
				registerEvent(TS3EventType.SERVER),
				registerEvent(TS3EventType.TEXT_SERVER),
				registerEvent(TS3EventType.CHANNEL, 0),
				registerEvent(TS3EventType.TEXT_CHANNEL, 0),
				registerEvent(TS3EventType.TEXT_PRIVATE),
				registerEvent(TS3EventType.PRIVILEGE_KEY_USED)
		);
		return CommandFuture.ofAll(eventFutures)
				.map(__ -> null); // Return success as Void, not List<Void>
	}
	/**
	 * Registers the server query to receive notifications about a given event type.
	 * <p>
	 * If used with {@link TS3EventType#TEXT_CHANNEL}, this will listen to chat events in the current channel.
	 * If used with {@link TS3EventType#CHANNEL}, this will listen to <b>all</b> channel events.
	 * To specify a different channel for channel events, use {@link #registerEvent(TS3EventType, int)}.
	 * </p>
	 *
	 * @param eventType
	 * 		the event type to be notified about
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addTS3Listeners(TS3Listener...)
	 * @see #registerEvent(TS3EventType, int)
	 * @see #registerAllEvents()
	 */
	public CommandFuture<Void> registerEvent(TS3EventType eventType) {
		if (eventType == TS3EventType.CHANNEL || eventType == TS3EventType.TEXT_CHANNEL) {
			return registerEvent(eventType, 0);
		} else {
			return registerEvent(eventType, -1);
		}
	}
	/**
	 * Registers the server query to receive notifications about a given event type.
	 *
	 * @param eventType
	 * 		the event type to be notified about
	 * @param channelId
	 * 		the ID of the channel to listen to, will be ignored if set to {@code -1}.
	 * 		Can be set to {@code 0} for {@link TS3EventType#CHANNEL} to receive notifications about all channel switches.
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Channel#getId()
	 * @see #addTS3Listeners(TS3Listener...)
	 * @see #registerAllEvents()
	 */
	public CommandFuture<Void> registerEvent(TS3EventType eventType, int channelId) {
		Command cmd = QueryCommands.serverNotifyRegister(eventType, channelId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Registers the server query to receive notifications about multiple given event types.
	 * <p>
	 * If used with {@link TS3EventType#TEXT_CHANNEL}, this will listen to chat events in the current channel.
	 * If used with {@link TS3EventType#CHANNEL}, this will listen to <b>all</b> channel events.
	 * To specify a different channel for channel events, use {@link #registerEvent(TS3EventType, int)}.
	 * </p>
	 *
	 * @param eventTypes
	 * 		the event types to be notified about
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands n, one command per TS3EventType
	 * @see #addTS3Listeners(TS3Listener...)
	 * @see #registerEvent(TS3EventType, int)
	 * @see #registerAllEvents()
	 */
	public CommandFuture<Void> registerEvents(TS3EventType... eventTypes) {
		if (eventTypes.length == 0) return CommandFuture.immediate(null); // Success
		Collection<CommandFuture<Void>> registerFutures = new ArrayList<>(eventTypes.length);
		for (TS3EventType type : eventTypes) {
			registerFutures.add(registerEvent(type));
		}
		return CommandFuture.ofAll(registerFutures)
				.map(__ -> null); // Return success as Void, not List<Void>
	}
	/**
	 * Removes the client specified by its database ID from the specified server group.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group
	 * @param clientDatabaseId
	 * 		the database ID of the client
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see Client#getDatabaseId()
	 * @see #removeClientFromServerGroup(ServerGroup, Client)
	 */
	public CommandFuture<Void> removeClientFromServerGroup(int serverGroupId, int clientDatabaseId) {
		Command cmd = ServerGroupCommands.serverGroupDelClient(serverGroupId, clientDatabaseId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Removes the specified client from the specified server group.
	 *
	 * @param serverGroup
	 * 		the server group to remove the client from
	 * @param client
	 * 		the client to remove from the server group
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #removeClientFromServerGroup(int, int)
	 */
	public CommandFuture<Void> removeClientFromServerGroup(ServerGroup serverGroup, Client client) {
		return removeClientFromServerGroup(serverGroup.getId(), client.getDatabaseId());
	}
	/**
	 * Removes one or more {@link TS3Listener}s to the event manager of the query.
	 * <p>
	 * If a listener was not actually registered, it will be ignored and no exception will be thrown.
	 * </p>
	 *
	 * @param listeners
	 * 		one or more listeners to remove
	 *
	 * @see #addTS3Listeners(TS3Listener...)
	 * @see TS3Listener
	 * @see TS3EventType
	 */
	public void removeTS3Listeners(TS3Listener... listeners) {
		query.getEventManager().removeListeners(listeners);
	}
	/**
	 * Renames the channel group with the specified ID.
	 *
	 * @param channelGroupId
	 * 		the ID of the channel group to rename
	 * @param name
	 * 		the new name for the channel group
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see #renameChannelGroup(ChannelGroup, String)
	 */
	public CommandFuture<Void> renameChannelGroup(int channelGroupId, String name) {
		Command cmd = ChannelGroupCommands.channelGroupRename(channelGroupId, name);
		return executeAndReturnError(cmd);
	}
	/**
	 * Renames the specified channel group.
	 *
	 * @param channelGroup
	 * 		the channel group to rename
	 * @param name
	 * 		the new name for the channel group
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #renameChannelGroup(int, String)
	 */
	public CommandFuture<Void> renameChannelGroup(ChannelGroup channelGroup, String name) {
		return renameChannelGroup(channelGroup.getId(), name);
	}
	/**
	 * Renames the server group with the specified ID.
	 *
	 * @param serverGroupId
	 * 		the ID of the server group to rename
	 * @param name
	 * 		the new name for the server group
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ServerGroup#getId()
	 * @see #renameServerGroup(ServerGroup, String)
	 */
	public CommandFuture<Void> renameServerGroup(int serverGroupId, String name) {
		Command cmd = ServerGroupCommands.serverGroupRename(serverGroupId, name);
		return executeAndReturnError(cmd);
	}
	/**
	 * Renames the specified server group.
	 *
	 * @param serverGroup
	 * 		the server group to rename
	 * @param name
	 * 		the new name for the server group
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #renameServerGroup(int, String)
	 */
	public CommandFuture<Void> renameServerGroup(ServerGroup serverGroup, String name) {
		return renameServerGroup(serverGroup.getId(), name);
	}
	/**
	 * Resets all permissions and deletes all server / channel groups. Use carefully.
	 *
	 * @return a token for a new administrator account
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<String> resetPermissions() {
		Command cmd = PermissionCommands.permReset();
		return executeAndReturnStringProperty(cmd, "token");
	}
	/**
	 * Finds all clients that have any value associated with the {@code key} custom client property,
	 * and returns the client's database ID and the key and value of the matching custom property.
	 *
	 * @param key
	 * 		the key to search for, cannot be {@code null}
	 *
	 * @return a list of client database IDs and their matching custom client properties
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #searchCustomClientProperty(String, String)
	 * @see #getCustomClientProperties(int)
	 */
	public CommandFuture<List<CustomPropertyAssignment>> searchCustomClientProperty(String key) {
		return searchCustomClientProperty(key, "%");
	}
	/**
	 * Finds all clients whose value associated with the {@code key} custom client property matches the
	 * SQL-like pattern {@code valuePattern}, and returns the client's database ID and the key and value
	 * of the matching custom property.
	 * <p>
	 * Patterns are case insensitive. They support the wildcard characters {@code %}, which matches any sequence of
	 * zero or more characters, and {@code _}, which matches exactly one arbitrary character.
	 * </p>
	 *
	 * @param key
	 * 		the key to search for, cannot be {@code null}
	 * @param valuePattern
	 * 		the pattern that values need to match to be included
	 *
	 * @return a list of client database IDs and their matching custom client properties
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #searchCustomClientProperty(String)
	 * @see #getCustomClientProperties(int)
	 */
	public CommandFuture<List<CustomPropertyAssignment>> searchCustomClientProperty(String key, String valuePattern) {
		if (key == null) throw new IllegalArgumentException("Key cannot be null");
		Command cmd = CustomPropertyCommands.customSearch(key, valuePattern);
		return executeAndTransform(cmd, CustomPropertyAssignment::new);
	}
	/**
	 * Moves the server query into the virtual server with the specified ID.
	 *
	 * @param id
	 * 		the ID of the virtual server
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getId()
	 * @see #selectVirtualServerById(int, String)
	 * @see #selectVirtualServerByPort(int)
	 * @see #selectVirtualServer(VirtualServer)
	 */
	public CommandFuture<Void> selectVirtualServerById(int id) {
		return selectVirtualServerById(id, null);
	}
	/**
	 * Moves the server query into the virtual server with the specified ID
	 * and sets the server query's nickname.
	 * <p>
	 * The nickname must be between 3 and 30 UTF-8 bytes long. BB codes will be ignored.
	 * </p>
	 *
	 * @param id
	 * 		the ID of the virtual server
	 * @param nickname
	 * 		the nickname, or {@code null} if the nickname should not be set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getId()
	 * @see #selectVirtualServerById(int)
	 * @see #selectVirtualServerByPort(int, String)
	 * @see #selectVirtualServer(VirtualServer, String)
	 */
	public CommandFuture<Void> selectVirtualServerById(int id, String nickname) {
		Command cmd = QueryCommands.useId(id, nickname);
		return executeAndReturnError(cmd);
	}
	/**
	 * Moves the server query into the virtual server with the specified voice port.
	 *
	 * @param port
	 * 		the voice port of the virtual server
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getPort()
	 * @see #selectVirtualServerById(int)
	 * @see #selectVirtualServerByPort(int, String)
	 * @see #selectVirtualServer(VirtualServer)
	 */
	public CommandFuture<Void> selectVirtualServerByPort(int port) {
		return selectVirtualServerByPort(port, null);
	}
	/**
	 * Moves the server query into the virtual server with the specified voice port
	 * and sets the server query's nickname.
	 * <p>
	 * The nickname must be between 3 and 30 UTF-8 bytes long. BB codes will be ignored.
	 * </p>
	 *
	 * @param port
	 * 		the voice port of the virtual server
	 * @param nickname
	 * 		the nickname, or {@code null} if the nickname should not be set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see VirtualServer#getPort()
	 * @see #selectVirtualServerById(int, String)
	 * @see #selectVirtualServerByPort(int)
	 * @see #selectVirtualServer(VirtualServer, String)
	 */
	public CommandFuture<Void> selectVirtualServerByPort(int port, String nickname) {
		Command cmd = QueryCommands.usePort(port, nickname);
		return executeAndReturnError(cmd);
	}
	/**
	 * Moves the server query into the specified virtual server.
	 *
	 * @param server
	 * 		the virtual server to move into
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #selectVirtualServerById(int)
	 * @see #selectVirtualServerByPort(int)
	 * @see #selectVirtualServer(VirtualServer, String)
	 */
	public CommandFuture<Void> selectVirtualServer(VirtualServer server) {
		return selectVirtualServerById(server.getId());
	}
	/**
	 * Moves the server query into the specified virtual server
	 * and sets the server query's nickname.
	 * <p>
	 * The nickname must be between 3 and 30 UTF-8 bytes long. BB codes will be ignored.
	 * </p>
	 *
	 * @param server
	 * 		the virtual server to move into
	 * @param nickname
	 * 		the nickname, or {@code null} if the nickname should not be set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #selectVirtualServerById(int, String)
	 * @see #selectVirtualServerByPort(int, String)
	 * @see #selectVirtualServer(VirtualServer)
	 */
	public CommandFuture<Void> selectVirtualServer(VirtualServer server, String nickname) {
		return selectVirtualServerById(server.getId(), nickname);
	}
	/**
	 * Sends an offline message to the client with the given unique identifier.
	 * <p>
	 * The message subject's length is limited to 200 UTF-8 bytes and BB codes in it will be ignored.
	 * The message body's length is limited to 4096 UTF-8 bytes and accepts BB codes
	 * </p>
	 *
	 * @param clientUId
	 * 		the unique identifier of the client to send the message to
	 * @param subject
	 * 		the subject for the message, may not contain BB codes
	 * @param message
	 * 		the actual message body, may contain BB codes
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getUniqueIdentifier()
	 * @see Message
	 */
	public CommandFuture<Void> sendOfflineMessage(String clientUId, String subject, String message) {
		Command cmd = MessageCommands.messageAdd(clientUId, subject, message);
		return executeAndReturnError(cmd);
	}
	/**
	 * Sends a text message either to the whole virtual server, a channel or specific client.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 * <p>
	 * To send a message to all virtual servers, use {@link #broadcast(String)}.
	 * To send an offline message, use {@link #sendOfflineMessage(String, String, String)}.
	 * </p>
	 *
	 * @param targetMode
	 * 		where the message should be sent to
	 * @param targetId
	 * 		the client ID of the recipient of this message. This value is ignored unless {@code targetMode} is {@code CLIENT}
	 * @param message
	 * 		the text message to send
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 */
	public CommandFuture<Void> sendTextMessage(TextMessageTargetMode targetMode, int targetId, String message) {
		Command cmd = ClientCommands.sendTextMessage(targetMode.getIndex(), targetId, message);
		return executeAndReturnError(cmd);
	}
	/**
	 * Sends a text message to the channel with the specified ID.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 * <p>
	 * This will move the client into the channel with the specified channel ID,
	 * <b>but will not move it back to the original channel!</b>
	 * </p>
	 *
	 * @param channelId
	 * 		the ID of the channel to which the message should be sent to
	 * @param message
	 * 		the text message to send
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #sendChannelMessage(String)
	 * @see Channel#getId()
	 */
	public CommandFuture<Void> sendChannelMessage(int channelId, String message) {
		return moveQuery(channelId)
				.then(__ -> sendTextMessage(TextMessageTargetMode.CHANNEL, 0, message));
	}
	/**
	 * Sends a text message to the channel the server query is currently in.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 *
	 * @param message
	 * 		the text message to send
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> sendChannelMessage(String message) {
		return sendTextMessage(TextMessageTargetMode.CHANNEL, 0, message);
	}
	/**
	 * Sends a text message to the virtual server with the specified ID.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 * <p>
	 * This will move the client to the virtual server with the specified server ID,
	 * <b>but will not move it back to the original virtual server!</b>
	 * </p>
	 *
	 * @param serverId
	 * 		the ID of the virtual server to which the message should be sent to
	 * @param message
	 * 		the text message to send
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #sendServerMessage(String)
	 * @see VirtualServer#getId()
	 */
	public CommandFuture<Void> sendServerMessage(int serverId, String message) {
		return selectVirtualServerById(serverId)
				.then(__ -> sendTextMessage(TextMessageTargetMode.SERVER, 0, message));
	}
	/**
	 * Sends a text message to the virtual server the server query is currently in.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 *
	 * @param message
	 * 		the text message to send
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> sendServerMessage(String message) {
		return sendTextMessage(TextMessageTargetMode.SERVER, 0, message);
	}
	/**
	 * Sends a private message to the client with the specified client ID.
	 * Your message may contain BB codes, but its length is limited to 1024 UTF-8 bytes.
	 *
	 * @param clientId
	 * 		the ID of the client to send the message to
	 * @param message
	 * 		the text message to send
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getId()
	 */
	public CommandFuture<Void> sendPrivateMessage(int clientId, String message) {
		return sendTextMessage(TextMessageTargetMode.CLIENT, clientId, message);
	}
	/**
	 * Sets a channel group for a client in a specific channel.
	 *
	 * @param groupId
	 * 		the ID of the group the client should join
	 * @param channelId
	 * 		the ID of the channel where the channel group should be assigned
	 * @param clientDBId
	 * 		the database ID of the client for which the channel group should be set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see ChannelGroup#getId()
	 * @see Channel#getId()
	 * @see Client#getDatabaseId()
	 */
	public CommandFuture<Void> setClientChannelGroup(int groupId, int channelId, int clientDBId) {
		Command cmd = ChannelGroupCommands.setClientChannelGroup(groupId, channelId, clientDBId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Sets the value of the multiple custom client properties for a client.
	 * <p>
	 * If any key present in the map already has a value assigned for this client,
	 * the existing value will be overwritten.
	 * This method does not delete keys not present in the map.
	 * </p><p>
	 * If {@code properties} contains an entry with {@code null} as its key,
	 * that entry will be ignored and no exception will be thrown.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the target client
	 * @param properties
	 * 		the map of properties to set, cannot be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands properties.size()
	 * @see Client#getDatabaseId()
	 * @see #setCustomClientProperty(int, String, String)
	 * @see #deleteCustomClientProperty(int, String)
	 */
	public CommandFuture<Void> setCustomClientProperties(int clientDBId, Map<String, String> properties) {
		Collection<CommandFuture<Void>> futures = new ArrayList<>(properties.size());
		for (Map.Entry<String, String> entry : properties.entrySet()) {
			String key = entry.getKey();
			String value = entry.getValue();
			if (key != null) {
				futures.add(setCustomClientProperty(clientDBId, key, value));
			}
		}
		return CommandFuture.ofAll(futures)
				.map(__ -> null); // Return success as Void, not List<Void>
	}
	/**
	 * Sets the value of the {@code key} custom client property for a client.
	 * <p>
	 * If there is already an assignment of the {@code key} custom client property
	 * for this client, the existing value will be overwritten.
	 * </p>
	 *
	 * @param clientDBId
	 * 		the database ID of the target client
	 * @param key
	 * 		the key of the custom property to set, cannot be {@code null}
	 * @param value
	 * 		the (new) value of the custom property to set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see Client#getDatabaseId()
	 * @see #setCustomClientProperties(int, Map)
	 * @see #deleteCustomClientProperty(int, String)
	 */
	public CommandFuture<Void> setCustomClientProperty(int clientDBId, String key, String value) {
		if (key == null) throw new IllegalArgumentException("Key cannot be null");
		Command cmd = CustomPropertyCommands.customSet(clientDBId, key, value);
		return executeAndReturnError(cmd);
	}
	/**
	 * Sets the read flag to {@code true} for a given message. This will not delete the message.
	 *
	 * @param messageId
	 * 		the ID of the message for which the read flag should be set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #setMessageReadFlag(int, boolean)
	 */
	public CommandFuture<Void> setMessageRead(int messageId) {
		return setMessageReadFlag(messageId, true);
	}
	/**
	 * Sets the read flag to {@code true} for a given message. This will not delete the message.
	 *
	 * @param message
	 * 		the message for which the read flag should be set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #setMessageRead(int)
	 * @see #setMessageReadFlag(Message, boolean)
	 * @see #deleteOfflineMessage(int)
	 */
	public CommandFuture<Void> setMessageRead(Message message) {
		return setMessageReadFlag(message.getId(), true);
	}
	/**
	 * Sets the read flag for a given message. This will not delete the message.
	 *
	 * @param messageId
	 * 		the ID of the message for which the read flag should be set
	 * @param read
	 * 		the boolean value to which the read flag should be set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #setMessageRead(int)
	 * @see #setMessageReadFlag(Message, boolean)
	 * @see #deleteOfflineMessage(int)
	 */
	public CommandFuture<Void> setMessageReadFlag(int messageId, boolean read) {
		Command cmd = MessageCommands.messageUpdateFlag(messageId, read);
		return executeAndReturnError(cmd);
	}
	/**
	 * Sets the read flag for a given message. This will not delete the message.
	 *
	 * @param message
	 * 		the message for which the read flag should be set
	 * @param read
	 * 		the boolean value to which the read flag should be set
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #setMessageRead(Message)
	 * @see #setMessageReadFlag(int, boolean)
	 * @see #deleteOfflineMessage(int)
	 */
	public CommandFuture<Void> setMessageReadFlag(Message message, boolean read) {
		return setMessageReadFlag(message.getId(), read);
	}
	/**
	 * Sets the nickname of the server query client.
	 * <p>
	 * The nickname must be between 3 and 30 UTF-8 bytes long. BB codes will be ignored.
	 * </p>
	 *
	 * @param nickname
	 * 		the new nickname, may not be {@code null}
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #updateClient(Map)
	 */
	public CommandFuture<Void> setNickname(String nickname) {
		Map<ClientProperty, String> options = Collections.singletonMap(ClientProperty.CLIENT_NICKNAME, nickname);
		return updateClient(options);
	}
	/**
	 * Starts the virtual server with the specified ID.
	 *
	 * @param serverId
	 * 		the ID of the virtual server
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> startServer(int serverId) {
		Command cmd = VirtualServerCommands.serverStart(serverId);
		return executeAndReturnError(cmd);
	}
	/**
	 * Starts the specified virtual server.
	 *
	 * @param virtualServer
	 * 		the virtual server to start
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> startServer(VirtualServer virtualServer) {
		return startServer(virtualServer.getId());
	}
	/**
	 * Stops the virtual server with the specified ID.
	 *
	 * @param serverId
	 * 		the ID of the virtual server
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> stopServer(int serverId) {
		return stopServer(serverId, null);
	}
	/**
	 * Stops the virtual server with the specified ID.
	 *
	 * @param serverId
	 * 		the ID of the virtual server
	 * @param reason
	 * 		the reason message to display to clients when they are disconnected
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> stopServer(int serverId, String reason) {
		Command cmd = VirtualServerCommands.serverStop(serverId, reason);
		return executeAndReturnError(cmd);
	}
	/**
	 * Stops the specified virtual server.
	 *
	 * @param virtualServer
	 * 		the virtual server to stop
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> stopServer(VirtualServer virtualServer) {
		return stopServer(virtualServer.getId(), null);
	}
	/**
	 * Stops the specified virtual server.
	 *
	 * @param virtualServer
	 * 		the virtual server to stop
	 * @param reason
	 * 		the reason message to display to clients when they are disconnected
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> stopServer(VirtualServer virtualServer, String reason) {
		return stopServer(virtualServer.getId(), reason);
	}
	/**
	 * Stops the entire TeamSpeak 3 Server instance by shutting down the process.
	 * <p>
	 * To have permission to use this command, you need to use the server query admin login.
	 * </p>
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> stopServerProcess() {
		return stopServerProcess(null);
	}
	/**
	 * Stops the entire TeamSpeak 3 Server instance by shutting down the process.
	 * <p>
	 * To have permission to use this command, you need to use the server query admin login.
	 * </p>
	 *
	 * @param reason
	 * 		the reason message to display to clients when they are disconnected
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> stopServerProcess(String reason) {
		Command cmd = ServerCommands.serverProcessStop(reason);
		return executeAndReturnError(cmd);
	}
	/**
	 * Unregisters the server query from receiving any event notifications.
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 */
	public CommandFuture<Void> unregisterAllEvents() {
		Command cmd = QueryCommands.serverNotifyUnregister();
		return executeAndReturnError(cmd);
	}
	/**
	 * Updates several client properties for this server query instance.
	 *
	 * @param options
	 * 		the map of properties to update
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #updateClient(ClientProperty, String)
	 * @see #editClient(int, Map)
	 */
	public CommandFuture<Void> updateClient(Map<ClientProperty, String> options) {
		Command cmd = ClientCommands.clientUpdate(options);
		return executeAndReturnError(cmd);
	}
	/**
	 * Changes a single client property for this server query instance.
	 * <p>
	 * Note that one can set many properties at once with the overloaded method that
	 * takes a map of client properties and strings.
	 * </p>
	 *
	 * @param property
	 * 		the client property to modify, make sure it is editable
	 * @param value
	 * 		the new value of the property
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #updateClient(Map)
	 * @see #editClient(int, Map)
	 */
	public CommandFuture<Void> updateClient(ClientProperty property, String value) {
		return updateClient(Collections.singletonMap(property, value));
	}
	/**
	 * Generates new login credentials for the currently connected server query instance, using the given name.
	 * <p>
	 * <b>This will remove the current login credentials!</b> You won't be logged out, but after disconnecting,
	 * the old credentials will no longer work. Make sure to not lock yourselves out!
	 * </p>
	 *
	 * @param loginName
	 * 		the name for the server query login
	 *
	 * @return the generated password for the server query login
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #addServerQueryLogin(String, int)
	 * @see #deleteServerQueryLogin(int)
	 * @see #getServerQueryLogins()
	 */
	public CommandFuture<String> updateServerQueryLogin(String loginName) {
		Command cmd = ClientCommands.clientSetServerQueryLogin(loginName);
		return executeAndReturnStringProperty(cmd, "client_login_password");
	}
	/**
	 * Uploads a file to the file repository at a given path and channel
	 * by reading {@code dataLength} bytes from an open {@link InputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code InputStream} is
	 * open and that {@code dataLength} bytes can eventually be read from it. The user is
	 * also responsible for closing the stream once the upload has finished.
	 * </p><p>
	 * Note that this method will not read the entire file to memory and can thus
	 * upload arbitrarily sized files to the file repository.
	 * </p>
	 *
	 * @param dataIn
	 * 		a stream that contains the data that should be uploaded
	 * @param dataLength
	 * 		how many bytes should be read from the stream
	 * @param filePath
	 * 		the path the file should have after being uploaded
	 * @param overwrite
	 * 		if {@code false}, fails if there's already a file at {@code filePath}
	 * @param channelId
	 * 		the ID of the channel to upload the file to
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #uploadFileDirect(byte[], String, boolean, int, String)
	 */
	public CommandFuture<Void> uploadFile(InputStream dataIn, long dataLength, String filePath, boolean overwrite, int channelId) {
		return uploadFile(dataIn, dataLength, filePath, overwrite, channelId, null);
	}
	/**
	 * Uploads a file to the file repository at a given path and channel
	 * by reading {@code dataLength} bytes from an open {@link InputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code InputStream} is
	 * open and that {@code dataLength} bytes can eventually be read from it. The user is
	 * also responsible for closing the stream once the upload has finished.
	 * </p><p>
	 * Note that this method will not read the entire file to memory and can thus
	 * upload arbitrarily sized files to the file repository.
	 * </p>
	 *
	 * @param dataIn
	 * 		a stream that contains the data that should be uploaded
	 * @param dataLength
	 * 		how many bytes should be read from the stream
	 * @param filePath
	 * 		the path the file should have after being uploaded
	 * @param overwrite
	 * 		if {@code false}, fails if there's already a file at {@code filePath}
	 * @param channelId
	 * 		the ID of the channel to upload the file to
	 * @param channelPassword
	 * 		that channel's password
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #uploadFileDirect(byte[], String, boolean, int, String)
	 */
	public CommandFuture<Void> uploadFile(InputStream dataIn, long dataLength, String filePath, boolean overwrite, int channelId, String channelPassword) {
		FileTransferHelper helper = query.getFileTransferHelper();
		int transferId = helper.getClientTransferId();
		Command cmd = FileCommands.ftInitUpload(transferId, filePath, channelId, channelPassword, dataLength, overwrite);
		CommandFuture<Void> future = new CommandFuture<>();
		executeAndTransformFirst(cmd, FileTransferParameters::new).onSuccess(params -> {
			QueryError error = params.getQueryError();
			if (!error.isSuccessful()) {
				future.fail(new TS3CommandFailedException(error, cmd.getName()));
				return;
			}
			try {
				query.getFileTransferHelper().uploadFile(dataIn, dataLength, params);
			} catch (IOException e) {
				future.fail(new TS3FileTransferFailedException("Upload failed", e));
				return;
			}
			future.set(null); // Mark as successful
		}).forwardFailure(future);
		return future;
	}
	/**
	 * Uploads a file that is already stored in memory to the file repository
	 * at a given path and channel.
	 *
	 * @param data
	 * 		the file's data as a byte array
	 * @param filePath
	 * 		the path the file should have after being uploaded
	 * @param overwrite
	 * 		if {@code false}, fails if there's already a file at {@code filePath}
	 * @param channelId
	 * 		the ID of the channel to upload the file to
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #uploadFile(InputStream, long, String, boolean, int)
	 */
	public CommandFuture<Void> uploadFileDirect(byte[] data, String filePath, boolean overwrite, int channelId) {
		return uploadFileDirect(data, filePath, overwrite, channelId, null);
	}
	/**
	 * Uploads a file that is already stored in memory to the file repository
	 * at a given path and channel.
	 *
	 * @param data
	 * 		the file's data as a byte array
	 * @param filePath
	 * 		the path the file should have after being uploaded
	 * @param overwrite
	 * 		if {@code false}, fails if there's already a file at {@code filePath}
	 * @param channelId
	 * 		the ID of the channel to upload the file to
	 * @param channelPassword
	 * 		that channel's password
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see FileInfo#getPath()
	 * @see Channel#getId()
	 * @see #uploadFile(InputStream, long, String, boolean, int, String)
	 */
	public CommandFuture<Void> uploadFileDirect(byte[] data, String filePath, boolean overwrite, int channelId, String channelPassword) {
		return uploadFile(new ByteArrayInputStream(data), data.length, filePath, overwrite, channelId, channelPassword);
	}
	/**
	 * Uploads an icon to the icon directory in the file repository
	 * by reading {@code dataLength} bytes from an open {@link InputStream}.
	 * <p>
	 * It is the user's responsibility to ensure that the given {@code InputStream} is
	 * open and that {@code dataLength} bytes can eventually be read from it. The user is
	 * also responsible for closing the stream once the upload has finished.
	 * </p><p>
	 * Note that unlike the file upload methods, this <strong>will read the entire file to memory</strong>.
	 * This is because the CRC32 hash must be calculated before the icon can be uploaded.
	 * That means that all icon files must be less than 2<sup>31</sup>-1 bytes in size.
	 * </p>
	 * Uploads  that is already stored in memory to the icon directory
	 * in the file repository. If this icon has already been uploaded or
	 * if a hash collision occurs (CRC32), this command will fail.
	 *
	 * @param dataIn
	 * 		a stream that contains the data that should be uploaded
	 * @param dataLength
	 * 		how many bytes should be read from the stream
	 *
	 * @return the ID of the uploaded icon
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 * @see #uploadIconDirect(byte[])
	 * @see #downloadIcon(OutputStream, long)
	 */
	public CommandFuture<Long> uploadIcon(InputStream dataIn, long dataLength) {
		byte[] data;
		try {
			data = FileTransferHelper.readFully(dataIn, dataLength);
		} catch (IOException e) {
			throw new TS3FileTransferFailedException("Reading stream failed", e);
		}
		return uploadIconDirect(data);
	}
	/**
	 * Uploads an icon that is already stored in memory to the icon directory
	 * in the file repository. If this icon has already been uploaded or
	 * if a CRC32 hash collision occurs, this command will fail.
	 *
	 * @param data
	 * 		the icon's data as a byte array
	 *
	 * @return the ID of the uploaded icon
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @throws TS3FileTransferFailedException
	 * 		if the file transfer fails for any reason
	 * @querycommands 1
	 * @see IconFile#getIconId()
	 * @see #uploadIcon(InputStream, long)
	 * @see #downloadIconDirect(long)
	 */
	public CommandFuture<Long> uploadIconDirect(byte[] data) {
		CommandFuture<Long> future = new CommandFuture<>();
		long iconId = FileTransferHelper.getIconId(data);
		String path = "/icon_" + iconId;
		uploadFileDirect(data, path, false, 0)
				.onSuccess(__ -> future.set(iconId))
				.onFailure(transformError(future, 2050, iconId));
		return future;
	}
	/**
	 * Uses an existing privilege key to join a server or channel group.
	 *
	 * @param token
	 * 		the privilege key to use
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see PrivilegeKey
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #usePrivilegeKey(PrivilegeKey)
	 */
	public CommandFuture<Void> usePrivilegeKey(String token) {
		Command cmd = PrivilegeKeyCommands.privilegeKeyUse(token);
		return executeAndReturnError(cmd);
	}
	/**
	 * Uses an existing privilege key to join a server or channel group.
	 *
	 * @param privilegeKey
	 * 		the privilege key to use
	 *
	 * @return a future to track the progress of this command
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see PrivilegeKey
	 * @see #addPrivilegeKey(PrivilegeKeyType, int, int, String)
	 * @see #usePrivilegeKey(String)
	 */
	public CommandFuture<Void> usePrivilegeKey(PrivilegeKey privilegeKey) {
		return usePrivilegeKey(privilegeKey.getToken());
	}
	/**
	 * Gets information about the current server query instance.
	 *
	 * @return information about the server query instance
	 *
	 * @throws TS3CommandFailedException
	 * 		if the execution of a command fails
	 * @querycommands 1
	 * @see #getClientInfo(int)
	 */
	public CommandFuture<ServerQueryInfo> whoAmI() {
		Command cmd = QueryCommands.whoAmI();
		return executeAndTransformFirst(cmd, ServerQueryInfo::new);
	}
	/**
	 * Checks whether a given {@link TS3Exception} is a {@link TS3CommandFailedException} with the
	 * specified error ID.
	 *
	 * @param exception
	 * 		the exception to check
	 * @param errorId
	 * 		the error ID to match
	 *
	 * @return whether {@code exception} is a {@code TS3CommandFailedException} with error ID {@code errorId}.
	 */
	private static boolean isQueryError(TS3Exception exception, int errorId) {
		if (exception instanceof TS3CommandFailedException) {
			TS3CommandFailedException cfe = (TS3CommandFailedException) exception;
			return (cfe.getError().getId() == errorId);
		} else {
			return false;
		}
	}
	/**
	 * Creates a {@code FailureListener} that checks whether the caught exception is
	 * a {@code TS3CommandFailedException} with error ID {@code errorId}.
	 * <p>
	 * If so, the listener makes {@code future} succeed by setting its result value to an empty
	 * list with element type {@code T}. Else, the caught exception is forwarded to {@code future}.
	 * </p>
	 *
	 * @param future
	 * 		the future to forward the result to
	 * @param errorId
	 * 		the error ID to catch
	 * @param replacement
	 * 		the value to
	 * @param <T>
	 * 		the type of {@code replacement} and element type of {@code future}
	 *
	 * @return a {@code FailureListener} with the described properties
	 */
	private static <T> CommandFuture.FailureListener transformError(CommandFuture<T> future, int errorId, T replacement) {
		return exception -> {
			if (isQueryError(exception, errorId)) {
				future.set(replacement);
			} else {
				future.fail(exception);
			}
		};
	}
	/**
	 * Executes a command and sets the returned future to true if the command succeeded.
	 *
	 * @param command
	 * 		the command to execute
	 *
	 * @return a future to track the progress of this command
	 */
	private CommandFuture<Void> executeAndReturnError(Command command) {
		CommandFuture<Void> future = command.getFuture()
				.map(__ -> null); // Mark as successful
		commandQueue.enqueueCommand(command);
		return future;
	}
	/**
	 * Executes a command, checking for failure and returning a single
	 * {@code String} property from the first response map.
	 *
	 * @param command
	 * 		the command to execute
	 * @param property
	 * 		the name of the property to return
	 *
	 * @return the value of the specified {@code String} property
	 */
	private CommandFuture<String> executeAndReturnStringProperty(Command command, String property) {
		CommandFuture<String> future = command.getFuture()
				.map(result -> result.getFirstResponse().get(property));
		commandQueue.enqueueCommand(command);
		return future;
	}
	/**
	 * Executes a command and returns a single {@code Integer} property from the first response map.
	 *
	 * @param command
	 * 		the command to execute
	 * @param property
	 * 		the name of the property to return
	 *
	 * @return the value of the specified {@code Integer} property
	 */
	private CommandFuture<Integer> executeAndReturnIntProperty(Command command, String property) {
		CommandFuture<Integer> future = command.getFuture()
				.map(result -> result.getFirstResponse().getInt(property));
		commandQueue.enqueueCommand(command);
		return future;
	}
	private CommandFuture<int[]> executeAndReturnIntArray(Command command, String property) {
		CommandFuture<int[]> future = command.getFuture()
				.map(result -> {
					List<Wrapper> responses = result.getResponses();
					int[] values = new int[responses.size()];
					int i = 0;
					for (Wrapper response : responses) {
						values[i++] = response.getInt(property);
					}
					return values;
				});
		commandQueue.enqueueCommand(command);
		return future;
	}
	/**
	 * Executes a command, checks for failure and transforms the first
	 * response map by invoking {@code fn}.
	 *
	 * @param command
	 * 		the command to execute
	 * @param fn
	 * 		the function that creates a new wrapper of type {@code T}
	 * @param <T>
	 * 		the wrapper class the map should be wrapped with
	 *
	 * @return a future of a {@code T} wrapper of the first response map
	 */
	private <T extends Wrapper> CommandFuture<T> executeAndTransformFirst(Command command, Function<Map<String, String>, T> fn) {
		return executeAndMapFirst(command, wrapper -> fn.apply(wrapper.getMap()));
	}
	/**
	 * Executes a command, checks for failure and maps the first
	 * response wrapper by using {@code fn}.
	 *
	 * @param command
	 * 		the command to execute
	 * @param fn
	 * 		a mapping function from {@code Wrapper} to {@code T}
	 * @param <T>
	 * 		the result type of the mapping function {@code fn}
	 *
	 * @return a future of a {@code T}
	 */
	private <T> CommandFuture<T> executeAndMapFirst(Command command, Function<Wrapper, T> fn) {
		CommandFuture<T> future = command.getFuture()
				.map(result -> fn.apply(result.getFirstResponse()));
		commandQueue.enqueueCommand(command);
		return future;
	}
	/**
	 * Executes a command, checks for failure and transforms all
	 * response maps to a wrapper by invoking {@code fn} on each map.
	 *
	 * @param command
	 * 		the command to execute
	 * @param fn
	 * 		the function that creates the new wrappers of type {@code T}
	 * @param <T>
	 * 		the wrapper class the maps should be wrapped with
	 *
	 * @return a future of a list of wrapped response maps
	 */
	private <T extends Wrapper> CommandFuture<List<T>> executeAndTransform(Command command, Function<Map<String, String>, T> fn) {
		return executeAndMap(command, wrapper -> fn.apply(wrapper.getMap()));
	}
	/**
	 * Executes a command, checks for failure and maps all response
	 * wrappers by using {@code fn}.
	 *
	 * @param command
	 * 		the command to execute
	 * @param fn
	 * 		a mapping function from {@code Wrapper} to {@code T}
	 * @param <T>
	 * 		the result type of the mapping function {@code fn}
	 *
	 * @return a future of a list of {@code T}
	 */
	private <T> CommandFuture<List<T>> executeAndMap(Command command, Function<Wrapper, T> fn) {
		CommandFuture<List<T>> future = command.getFuture()
				.map(result -> {
					List<Wrapper> response = result.getResponses();
					List<T> transformed = new ArrayList<>(response.size());
					for (Wrapper wrapper : response) {
						transformed.add(fn.apply(wrapper));
					}
					return transformed;
				});
		commandQueue.enqueueCommand(command);
		return future;
	}
	/**
	 * Computes a sub-list of the list of values produced by {@code valuesFuture} where
	 * each value matches a key in the list of keys produced by {@code keysFuture}.
	 * <p>
	 * The returned future succeeds if {@code keysFuture} and {@code valuesFuture} succeed and
	 * fails if {@code keysFuture} or {@code valuesFuture} fails.
	 * </p><p>
	 * {@code null} keys, {@code null} values, and keys without a matching value are ignored.
	 * If multiple values map to the same key, only the first value is used.
	 * </p><p>
	 * The order of values in the resulting list follows the order of matching keys,
	 * not the order of the original value list.
	 * </p>
	 *
	 * @param keysFuture
	 * 		the future producing a list of keys of type {@code K}
	 * @param valuesFuture
	 * 		the future producing a list of values of type {@code V}
	 * @param keyMapper
	 * 		a function extracting keys from the value type
	 * @param <K>
	 * 		the key type
	 * @param <V>
	 * 		the value type
	 *
	 * @return a future of a list of values of type {@code V}
	 */
	private static <K, V> CommandFuture<List<V>> findByKey(CommandFuture<List<K>> keysFuture, CommandFuture<List<V>> valuesFuture,
	                                                       Function<? super V, ? extends K> keyMapper) {
		CommandFuture<List<V>> future = new CommandFuture<>();
		keysFuture.onSuccess(keys ->
				valuesFuture.onSuccess(values -> {
					Map<K, V> valueMap = values.stream().collect(Collectors.toMap(keyMapper, Function.identity(), (l, r) -> l));
					List<V> foundValues = new ArrayList<>(keys.size());
					for (K key : keys) {
						if (key == null) continue;
						V value = valueMap.get(key);
						if (value == null) continue;
						foundValues.add(value);
					}
					future.set(foundValues);
				}).forwardFailure(future)
		).forwardFailure(future);
		return future;
	}
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2014 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.api.event.*;
import com.github.theholywaffle.teamspeak3.api.exception.TS3UnknownEventException;
import com.github.theholywaffle.teamspeak3.api.wrapper.Wrapper;
import com.github.theholywaffle.teamspeak3.commands.response.DefaultArrayResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Function;
class EventManager {
	private static final Logger log = LoggerFactory.getLogger(EventManager.class);
	private static final Map<String, Function<Wrapper, TS3Event>> eventByName = new HashMap<>(12);
	static {
		eventByName.put("notifytextmessage", TextMessageEvent::new);
		eventByName.put("notifycliententerview", ClientJoinEvent::new);
		eventByName.put("notifyclientleftview", ClientLeaveEvent::new);
		eventByName.put("notifyserveredited", ServerEditedEvent::new);
		eventByName.put("notifychanneledited", ChannelEditedEvent::new);
		eventByName.put("notifychanneldescriptionchanged", ChannelDescriptionEditedEvent::new);
		eventByName.put("notifyclientmoved", ClientMovedEvent::new);
		eventByName.put("notifychannelcreated", ChannelCreateEvent::new);
		eventByName.put("notifychanneldeleted", ChannelDeletedEvent::new);
		eventByName.put("notifychannelmoved", ChannelMovedEvent::new);
		eventByName.put("notifychannelpasswordchanged", ChannelPasswordChangedEvent::new);
		eventByName.put("notifytokenused", PrivilegeKeyUsedEvent::new);
	}
	// CopyOnWriteArrayList for thread safety
	private final Collection<ListenerTask> tasks = new CopyOnWriteArrayList<>();
	private final TS3Query ts3;
	EventManager(TS3Query query) {
		ts3 = query;
	}
	void addListeners(TS3Listener... listeners) {
		for (TS3Listener listener : listeners) {
			if (listener == null) throw new IllegalArgumentException("A listener was null");
			ListenerTask task = new ListenerTask(listener);
			tasks.add(task);
		}
	}
	void removeListeners(TS3Listener... listeners) {
		// Bad performance (O(n*m)), but this method is rarely if ever used
		List<TS3Listener> listenersToRemove = Arrays.asList(listeners);
		tasks.removeIf(listenerTask -> listenersToRemove.contains(listenerTask.listener));
	}
	void fireEvent(String notifyName, String notifyBody) {
		final DefaultArrayResponse response = DefaultArrayResponse.parse(notifyBody);
		for (Wrapper eventData : response.getResponses()) {
			TS3Event event = createEvent(notifyName, eventData);
			fireEvent(event);
		}
	}
	void fireEvent(TS3Event event) {
		if (event == null) throw new IllegalArgumentException("TS3Event was null");
		for (ListenerTask task : tasks) {
			task.enqueueEvent(event);
		}
	}
	private static TS3Event createEvent(String notifyName, Wrapper eventData) {
		Function<Wrapper, TS3Event> constructor = eventByName.get(notifyName);
		if (constructor == null) throw new TS3UnknownEventException(notifyName + " " + eventData);
		return constructor.apply(eventData);
	}
	/*
	 * Do not synchronize on instances of this class from outside the class itself!
	 */
	private class ListenerTask implements Runnable {
		private static final int START_QUEUE_SIZE = 16;
		private final TS3Listener listener;
		private final Queue<TS3Event> eventQueue;
		ListenerTask(TS3Listener ts3Listener) {
			listener = ts3Listener;
			eventQueue = new ArrayDeque<>(START_QUEUE_SIZE);
		}
		TS3Listener getListener() {
			return listener;
		}
		synchronized void enqueueEvent(TS3Event event) {
			if (eventQueue.isEmpty()) {
				// Add the event to the queue and start a task to process this event and any events
				// that might be enqueued before the last event is removed from the queue
				eventQueue.add(event);
				ts3.submitUserTask("Event listener task", this);
			} else {
				// Just add the event to the queue, the running task will pick it up
				eventQueue.add(event);
			}
		}
		@Override
		public void run() {
			TS3Event currentEvent;
			synchronized (this) {
				currentEvent = eventQueue.peek();
				if (currentEvent == null) throw new IllegalStateException("Task started without events");
			}
			do {
				try {
					currentEvent.fire(listener);
				} catch (Throwable throwable) {
					log.error("Event listener threw an exception", throwable);
				}
				synchronized (this) {
					eventQueue.remove();
					currentEvent = eventQueue.peek();
				}
			} while (currentEvent != null);
		}
	}
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2018 Bert De Geyter, Roger Baumgartner
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.api.exception.TS3QueryShutDownException;
import com.github.theholywaffle.teamspeak3.commands.Command;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class CommandQueue {
	private static final int INITIAL_QUEUE_SIZE = 16;
	private final Queue<Command> sendQueue;
	private final Queue<Command> receiveQueue;
	private final Lock queueLock;
	// Signalled when a command is added to sendQueue or removed from receiveQueue, or when rejectNew is set to true
	private final Condition canTransfer;
	// API objects that insert commands into this queue
	private final TS3Api api;
	private final TS3ApiAsync asyncApi;
	private final boolean unlimitedInFlightCommands;
	private final boolean isGlobal;
	private boolean rejectNew = false;
	private long firstEnqueueTimeAfterEmpty;
	static CommandQueue newGlobalQueue(TS3Query query, boolean unlimited) {
		return new CommandQueue(query, true, unlimited);
	}
	static CommandQueue newConnectQueue(TS3Query query) {
		return new CommandQueue(query, false, true);
	}
	private CommandQueue(TS3Query query, boolean global, boolean unlimited) {
		isGlobal = global;
		unlimitedInFlightCommands = unlimited;
		sendQueue = new ArrayDeque<>(INITIAL_QUEUE_SIZE);
		receiveQueue = new ArrayDeque<>(unlimited ? INITIAL_QUEUE_SIZE : 1);
		queueLock = new ReentrantLock();
		canTransfer = queueLock.newCondition();
		asyncApi = new TS3ApiAsync(query, this);
		api = new TS3Api(asyncApi);
	}
	TS3Api getApi() {
		return api;
	}
	TS3ApiAsync getAsyncApi() {
		return asyncApi;
	}
	boolean isGlobal() {
		return isGlobal;
	}
	void enqueueCommand(Command command) {
		queueLock.lock();
		try {
			if (rejectNew) {
				command.getFuture().fail(new TS3QueryShutDownException());
				return;
			}
			if (isEmpty()) {
				firstEnqueueTimeAfterEmpty = System.currentTimeMillis();
			}
			sendQueue.add(command);
			canTransfer.signalAll();
		} finally {
			queueLock.unlock();
		}
	}
	Command transferCommand() throws InterruptedException {
		queueLock.lockInterruptibly();
		try {
			while (sendQueue.isEmpty() || (!receiveQueue.isEmpty() && !unlimitedInFlightCommands)) {
				if (sendQueue.isEmpty() && rejectNew) return null;
				canTransfer.await();
			}
			Command command = sendQueue.remove();
			receiveQueue.add(command);
			return command;
		} finally {
			queueLock.unlock();
		}
	}
	Command peekReceiveQueue() {
		queueLock.lock();
		try {
			return receiveQueue.peek();
		} finally {
			queueLock.unlock();
		}
	}
	void removeFromReceiveQueue() {
		queueLock.lock();
		try {
			if (receiveQueue.isEmpty()) throw new IllegalStateException("Empty receive queue");
			receiveQueue.remove();
			canTransfer.signalAll();
		} finally {
			queueLock.unlock();
		}
	}
	void resetSentCommands() {
		queueLock.lock();
		try {
			Collection<Command> allCommands = getAllCommands();
			sendQueue.clear();
			receiveQueue.clear();
			sendQueue.addAll(allCommands);
			rejectNew = false;
			firstEnqueueTimeAfterEmpty = System.currentTimeMillis();
			canTransfer.signalAll();
		} finally {
			queueLock.unlock();
		}
	}
	boolean isEmpty() {
		queueLock.lock();
		try {
			return receiveQueue.isEmpty() && sendQueue.isEmpty();
		} finally {
			queueLock.unlock();
		}
	}
	long getBusyTime() {
		queueLock.lock();
		try {
			if (isEmpty()) {
				return 0L;
			} else {
				return System.currentTimeMillis() - firstEnqueueTimeAfterEmpty;
			}
		} finally {
			queueLock.unlock();
		}
	}
	void shutDown() {
		queueLock.lock();
		try {
			rejectNew = true;
			canTransfer.signalAll();
			while (!isEmpty()) {
				canTransfer.awaitUninterruptibly();
			}
		} finally {
			queueLock.unlock();
		}
	}
	void quit() {
		queueLock.lock();
		try {
			// Enqueue the last command - don't wait for a response, we'll wait in shutDown
			if (!rejectNew) asyncApi.quit();
			// And wait until all commands have been sent
			shutDown();
		} finally {
			queueLock.unlock();
		}
	}
	void failRemainingCommands() {
		queueLock.lock();
		try {
			rejectNew = true;
			canTransfer.signalAll();
			Collection<Command> allCommands = getAllCommands();
			for (Command command : allCommands) {
				command.getFuture().fail(new TS3QueryShutDownException());
			}
			sendQueue.clear();
			receiveQueue.clear();
		} finally {
			queueLock.unlock();
		}
	}
	// Only call this when holding queueLock
	private Collection<Command> getAllCommands() {
		Collection<Command> allCommands = new ArrayList<>(sendQueue.size() + receiveQueue.size());
		allCommands.addAll(sendQueue);
		allCommands.addAll(receiveQueue);
		return allCommands;
	}
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2018 Bert De Geyter, Roger Baumgartner
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.api.exception.TS3ConnectionFailedException;
import java.io.IOException;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
class Connection {
	private final TS3Query ts3Query;
	private final IOChannel ioChannel;
	private final StreamReader streamReader;
	private final StreamWriter streamWriter;
	private final KeepAlive keepAlive;
	private final AtomicReference<CommandQueue> commandQueue;
	private final AtomicLong lastCommandSent;
	private final long commandTimeout;
	Connection(TS3Query query, TS3Config config, CommandQueue initialQueue) {
		ts3Query = query;
		commandQueue = new AtomicReference<>(initialQueue);
		lastCommandSent = new AtomicLong(System.currentTimeMillis());
		commandTimeout = config.getCommandTimeout();
		try {
			if (config.getProtocol() == TS3Query.Protocol.SSH) {
				ioChannel = new SSHChannel(config);
			} else {
				ioChannel = new SocketChannel(config);
			}
			streamReader = new StreamReader(this, ioChannel.getInputStream(), query, config);
			streamWriter = new StreamWriter(this, ioChannel.getOutputStream(), config);
			keepAlive = new KeepAlive(this);
		} catch (IOException ioe) {
			closeSocket();
			throw new TS3ConnectionFailedException(ioe);
		}
		streamReader.start();
		streamWriter.start();
		keepAlive.start();
	}
	void internalDisconnect() {
		disconnect();
		CommandQueue queue = getCommandQueue();
		if (queue.isGlobal()) {
			ts3Query.fireDisconnect();
		} else {
			queue.failRemainingCommands();
		}
	}
	void disconnect() {
		keepAlive.interrupt();
		streamWriter.interrupt();
		streamReader.interrupt();
		boolean wasInterrupted = joinThread(keepAlive);
		wasInterrupted |= joinThread(streamWriter);
		wasInterrupted |= joinThread(streamReader);
		if (wasInterrupted) {
			// Restore the interrupt for the caller
			Thread.currentThread().interrupt();
		}
		closeSocket();
	}
	private static boolean joinThread(Thread thread) {
		if (thread == Thread.currentThread()) return false;
		try {
			thread.join();
			return false;
		} catch (InterruptedException e) {
			return true;
		}
	}
	private void closeSocket() {
		if (ioChannel == null) return;
		try {
			ioChannel.close();
		} catch (IOException ignored) {
		}
	}
	CommandQueue getCommandQueue() {
		return commandQueue.get();
	}
	void setCommandQueue(CommandQueue newQueue) {
		newQueue.resetSentCommands();
		CommandQueue oldQueue = commandQueue.getAndSet(newQueue);
		if (!oldQueue.isEmpty()) {
			// shutDown was not called on the old queue, but that's
			// a programming error that we can't recover from here
			throw new IllegalStateException("Old queue not empty");
		}
	}
	long getIdleTime() {
		return System.currentTimeMillis() - lastCommandSent.get();
	}
	void resetIdleTime() {
		lastCommandSent.set(System.currentTimeMillis());
	}
	boolean isTimedOut() {
		/*
		 * Rationale: The connection has only timed out if we haven't sent a command for some time
		 * and the command queue has had pending commands for at least that amount of time.
		 * CommandQueue#getBusyTime is reset when the command queue is switched, so even if a user
		 * blocks the onConnect handler for too long without sending a command, this won't return true
		 * when the queue is switched over in #setCommandTime.
		 */
		return getIdleTime() > commandTimeout && getCommandQueue().getBusyTime() > commandTimeout;
	}
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2014 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.TS3Query.FloodRate;
import com.github.theholywaffle.teamspeak3.TS3Query.Protocol;
import com.github.theholywaffle.teamspeak3.api.reconnect.ConnectionHandler;
import com.github.theholywaffle.teamspeak3.api.reconnect.ReconnectStrategy;
/**
 * Class used to configure the behavior of a {@link TS3Query}.
 */
public class TS3Config {
	private boolean frozen = false;
	private String host = null;
	private int queryPort = -1;
	private Protocol protocol = Protocol.RAW;
	private String username = null;
	private String password = null;
	private FloodRate floodRate = FloodRate.DEFAULT;
	private boolean enableCommunicationsLogging = false;
	private int commandTimeout = 4000;
	private ReconnectStrategy reconnectStrategy = ReconnectStrategy.disconnect();
	private ConnectionHandler connectionHandler = null;
	/**
	 * Sets the hostname or IP address of the TeamSpeak3 server to connect to.
	 * <p>
	 * Note that the query port <strong>is not</strong> part of the hostname -
	 * use {@link #setQueryPort(int)} for that purpose.
	 * </p><p>
	 * If the application is running on the same machine as the TS3 server, you can use
	 * {@code null} as the hostname. You can also use any other loopback address,
	 * such as {@code localhost} or {@code 127.0.0.1}.
	 * </p>
	 *
	 * @param host
	 * 		a valid hostname or IP address of a TeamSpeak3 server, or {@code null}
	 *
	 * @return this TS3Config object for chaining
	 */
	public TS3Config setHost(String host) {
		checkFrozen();
		this.host = host;
		return this;
	}
	String getHost() {
		return host;
	}
	/**
	 * Sets the query port to use when connecting to the TeamSpeak3 server.
	 * <p>
	 * Note that the query uses a different port to connect to a server than the regular
	 * TeamSpeak3 clients. Regular clients use "voice ports", the query uses the "query port".
	 * </p><p>
	 * If you don't set the query port by calling this method, the query will use the default
	 * query port:
	 * </p>
	 * <ul>
	 *     <li>{@code 10011} when connecting using {@link Protocol#RAW}</li>
	 *     <li>{@code 10022} when connecting using {@link Protocol#SSH}</li>
	 * </ul>
	 *
	 * @param queryPort
	 * 		the query port to use, must be between {@code 1} and {@code 65535}
	 *
	 * @return this TS3Config object for chaining
	 *
	 * @throws IllegalArgumentException
	 * 		if the port is out of range
	 */
	public TS3Config setQueryPort(int queryPort) {
		checkFrozen();
		if (queryPort <= 0 || queryPort > 65535) {
			throw new IllegalArgumentException("Port out of range: " + queryPort);
		}
		this.queryPort = queryPort;
		return this;
	}
	int getQueryPort() {
		if (queryPort > 0) {
			return queryPort;
		} else {
			// Query port not set by user, use default for chosen protocol
			return protocol == Protocol.SSH ? 10022 : 10011;
		}
	}
	/**
	 * Defines the protocol used to connect to the TeamSpeak3 server.
	 * By default, {@link Protocol#RAW} is used.
	 *
	 * @param protocol
	 * 		the connection protocol to use
	 *
	 * @return this TS3Config object for chaining
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code protocol} is {@code null}
	 * @see Protocol Protocol
	 */
	public TS3Config setProtocol(Protocol protocol) {
		checkFrozen();
		if (protocol == null) throw new IllegalArgumentException("protocol cannot be null!");
		this.protocol = protocol;
		return this;
	}
	Protocol getProtocol() {
		return protocol;
	}
	/**
	 * Authenticates the query with the TeamSpeak3 server using the given login credentials
	 * immediately after connecting.
	 * <p>
	 * Setting the login credentials is mandatory when using the {@link Protocol#SSH} protocol.
	 * </p><p>
	 * A server query login can be generated by heading over to the TeamSpeak3 Client, Tools,
	 * ServerQuery Login. Note that the server query will have the same permissions as the client who
	 * generated the credentials.
	 * </p>
	 *
	 * @param username
	 * 		the username used to authenticate the query
	 * @param password
	 * 		the password corresponding to {@code username}
	 *
	 * @return this TS3Config object for chaining
	 */
	public TS3Config setLoginCredentials(String username, String password) {
		checkFrozen();
		this.username = username;
		this.password = password;
		return this;
	}
	boolean hasLoginCredentials() {
		return username != null && password != null;
	}
	String getUsername() {
		return username;
	}
	String getPassword() {
		return password;
	}
	/**
	 * Sets the delay between sending commands.
	 * <p>
	 * If the query's hostname / IP has not been added to the server's {@code query_ip_whitelist.txt},
	 * you need to use {@link FloodRate#DEFAULT} to prevent the query from being flood-banned.
	 * </p><p>
	 * Calling {@link FloodRate#custom} allows you to use a custom command delay if neither
	 * {@link FloodRate#UNLIMITED} nor {@link FloodRate#DEFAULT} fit your needs.
	 * </p>
	 *
	 * @param rate
	 * 		a {@link FloodRate} object that defines the delay between commands
	 *
	 * @return this TS3Config object for chaining
	 *
	 * @throws IllegalArgumentException
	 * 		if {@code rate} is {@code null}
	 * @see FloodRate FloodRate
	 */
	public TS3Config setFloodRate(FloodRate rate) {
		checkFrozen();
		if (rate == null) throw new IllegalArgumentException("rate cannot be null!");
		this.floodRate = rate;
		return this;
	}
	FloodRate getFloodRate() {
		return floodRate;
	}
	/**
	 * Setting this value to {@code true} will log the communication between the
	 * query client and the TS3 server at the {@code DEBUG} level.
	 * <p>
	 * By default, this is turned off to prevent leaking IPs, tokens, passwords, etc.
	 * into the console and / or log files.
	 * </p>
	 *
	 * @param enable
	 * 		whether to log query commands
	 *
	 * @return this TS3Config object for chaining
	 */
	public TS3Config setEnableCommunicationsLogging(boolean enable) {
		checkFrozen();
		enableCommunicationsLogging = enable;
		return this;
	}
	boolean getEnableCommunicationsLogging() {
		return enableCommunicationsLogging;
	}
	/**
	 * Sets how long the query should wait for any response to a command before disconnecting.
	 * <p>
	 * If the query doesn't receive any data from the TeamSpeak server after
	 * having waited for at least {@code commandTimeout} milliseconds, the connection
	 * is considered to be interrupted, and the query will try to reconnect according to
	 * its {@linkplain TS3Config#setReconnectStrategy(ReconnectStrategy) reconnect strategy}.
	 * </p><p>
	 * By default, this timeout is 4000 milliseconds.
	 * </p>
	 *
	 * @param commandTimeout
	 * 		the minimum amount of time to wait for any response, in milliseconds
	 *
	 * @return this TS3Config object for chaining
	 *
	 * @throws IllegalArgumentException
	 * 		if the timeout value is less than or equal to {@code 0}
	 */
	public TS3Config setCommandTimeout(int commandTimeout) {
		checkFrozen();
		if (commandTimeout <= 0) {
			throw new IllegalArgumentException("Timeout value must be greater than 0");
		}
		this.commandTimeout = commandTimeout;
		return this;
	}
	int getCommandTimeout() {
		return commandTimeout;
	}
	/**
	 * Sets what strategy the query uses to reconnect after having been disconnected.
	 * <p>
	 * The different reconnect strategies let you control whether and after which delay the
	 * query will try to reconnect. By default, {@link ReconnectStrategy#disconnect()} is used,
	 * which doesn't try to reconnect and simply stops the query.
	 * </p><p>
	 * Note that when using a reconnect strategy, you probably also want to set the
	 * {@link ConnectionHandler} using {@link TS3Config#setConnectionHandler(ConnectionHandler)}.
	 *
	 * @param reconnectStrategy
	 * 		the reconnect strategy used when the query loses connection
	 *
	 * @return this TS3Config object for chaining
	 *
	 * @see ReconnectStrategy The reconnect strategies
	 * @see ConnectionHandler The connection handler
	 */
	public TS3Config setReconnectStrategy(ReconnectStrategy reconnectStrategy) {
		checkFrozen();
		if (reconnectStrategy == null) throw new IllegalArgumentException("reconnectStrategy cannot be null!");
		this.reconnectStrategy = reconnectStrategy;
		return this;
	}
	ReconnectStrategy getReconnectStrategy() {
		return reconnectStrategy;
	}
	/**
	 * Sets the {@link ConnectionHandler} that defines the query's behaviour
	 * when connecting or disconnecting.
	 * <p>
	 * The following sample code illustrates how a reconnect strategy and connection handler can be
	 * used to print a message to the console every time the query connects or disconnects:
	 * </p>
	 *
	 * <pre>
	 * config.setReconnectStrategy(ReconnectStrategy.exponentialBackoff());
	 * config.setConnectionHandler(new ConnectionHandler() {
	 * 	&#64;Override
	 * 	public void onConnect(TS3Api api) {
	 * 		System.out.println("Successfully connected!");
	 * 	}
	 *
	 * 	&#64;Override
	 * 	public void onDisconnect(TS3Query query) {
	 * 		System.out.println("The query was disconnected!");
	 * 	}
	 * });
	 * </pre>
	 *
	 * @param connectionHandler
	 * 		the {@link ConnectionHandler} object
	 *
	 * @return this TS3Config object for chaining
	 *
	 * @see TS3Config#setReconnectStrategy(ReconnectStrategy)
	 */
	public TS3Config setConnectionHandler(ConnectionHandler connectionHandler) {
		checkFrozen();
		this.connectionHandler = connectionHandler;
		return this;
	}
	ConnectionHandler getConnectionHandler() {
		return connectionHandler;
	}
	TS3Config freeze() {
		frozen = true;
		return this;
	}
	private void checkFrozen() {
		if (frozen) {
			throw new IllegalStateException("TS3Config cannot be modified after being used to create a TS3Query. " +
					"Please make any changes to TS3Config *before* calling TS3Query's constructor.");
		}
	}
}
package com.github.theholywaffle.teamspeak3.api.exception;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2018 Bert De Geyter, Roger Baumgartner
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
public class TS3QueryShutDownException extends TS3Exception {
	private static final long serialVersionUID = -6727279731231409306L;
	public TS3QueryShutDownException() {
		super("The query was shut down or disconnected.");
	}
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2018 Bert De Geyter, Roger Baumgartner
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.api.CommandFuture;
import com.github.theholywaffle.teamspeak3.api.exception.TS3CommandFailedException;
import com.github.theholywaffle.teamspeak3.api.wrapper.QueryError;
import com.github.theholywaffle.teamspeak3.commands.Command;
import com.github.theholywaffle.teamspeak3.commands.response.DefaultArrayResponse;
import com.github.theholywaffle.teamspeak3.commands.response.ResponseBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.SocketTimeoutException;
import java.nio.charset.StandardCharsets;
class StreamReader extends Thread {
	private static final Logger log = LoggerFactory.getLogger(StreamReader.class);
	private final TS3Query ts3;
	private final Connection con;
	private final BufferedReader in;
	private final boolean logComms;
	private CommandQueue commandQueue = null;
	private ResponseBuilder responseBuilder = null;
	private String lastEvent = "";
	StreamReader(Connection connection, InputStream inStream, TS3Query query, TS3Config config) throws IOException {
		super("[TeamSpeak-3-Java-API] StreamReader");
		ts3 = query;
		con = connection;
		in = new BufferedReader(new InputStreamReader(inStream, StandardCharsets.UTF_8));
		logComms = config.getEnableCommunicationsLogging();
		readWelcomeMessage();
	}
	private void readWelcomeMessage() throws IOException {
		for (int i = 0; i < 4 || in.ready(); ++i) {
			String welcomeMessage = in.readLine();
			if (logComms) log.debug("< {}", welcomeMessage);
		}
	}
	@Override
	public void run() {
		while (!isInterrupted()) {
			String line;
			try {
				// Will block until a full line of text could be read.
				line = in.readLine();
			} catch (SocketTimeoutException socketTimeout) {
				// Really disconnected or just no data transferred for <commandTimeout> milliseconds?
				if (con.isTimedOut()) {
					log.error("Connection timed out.", socketTimeout);
					break;
				} else {
					continue;
				}
			} catch (IOException io) {
				if (!isInterrupted()) {
					log.error("Connection error occurred.", io);
				}
				break;
			}
			if (line == null) {
				// End of stream: connection terminated by server
				log.error("Connection closed by the server.");
				break;
			} else if (line.isEmpty()) {
				continue; // The server is sending garbage
			}
			if (line.startsWith("notify")) {
				handleEvent(line);
			} else {
				con.resetIdleTime();
				handleCommandResponse(line);
			}
		}
		try {
			in.close();
		} catch (IOException ignored) {
			// Ignore
		}
		if (!isInterrupted()) {
			con.internalDisconnect();
		}
	}
	private void handleEvent(String event) {
		if (logComms) log.debug("[event] < {}", event);
		// Filter out duplicate events for join, quit and channel move events
		if (isDuplicate(event)) return;
		String arr[] = event.split(" ", 2);
		ts3.getEventManager().fireEvent(arr[0], arr[1]);
	}
	private void handleCommandResponse(String response) {
		if (responseBuilder == null) {
			commandQueue = con.getCommandQueue();
			Command command = commandQueue.peekReceiveQueue();
			if (command == null) {
				log.warn("[UNHANDLED] < {}", response);
				return;
			}
			responseBuilder = new ResponseBuilder(command);
		}
		if (logComms) log.debug("[{}] < {}", responseBuilder.getCommand().getName(), response);
		if (response.startsWith("error ")) {
			handleCommandError(responseBuilder, response);
			commandQueue.removeFromReceiveQueue();
			responseBuilder = null;
		} else {
			responseBuilder.appendResponse(response);
		}
	}
	private void handleCommandError(ResponseBuilder responseBuilder, String error) {
		Command command = responseBuilder.getCommand();
		if (command.getName().equals("quit")) {
			// Response to a quit command received, we're done
			interrupt();
		}
		QueryError queryError = DefaultArrayResponse.parseError(error);
		CommandFuture<DefaultArrayResponse> future = command.getFuture();
		if (queryError.isSuccessful()) {
			DefaultArrayResponse response = responseBuilder.buildResponse();
			ts3.submitUserTask("Future SuccessListener (" + command.getName() + ")",
					() -> future.set(response));
		} else {
			log.debug("TS3 command error: {}", queryError);
			ts3.submitUserTask("Future FailureListener (" + command.getName() + ")",
					() -> future.fail(new TS3CommandFailedException(queryError, command.getName())));
		}
	}
	private boolean isDuplicate(String eventMessage) {
		if (!(eventMessage.startsWith("notifyclientmoved")
				|| eventMessage.startsWith("notifycliententerview")
				|| eventMessage.startsWith("notifyclientleftview"))) {
			// Event that will never cause duplicates
			return false;
		}
		if (eventMessage.equals(lastEvent)) {
			// Duplicate event!
			lastEvent = ""; // Let's only ever filter one duplicate
			return true;
		}
		lastEvent = eventMessage;
		return false;
	}
}
package com.github.theholywaffle.teamspeak3;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2016 Bert De Geyter, Roger Baumgartner
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.api.wrapper.FileTransferParameters;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.zip.CRC32;
class FileTransferHelper {
	private static final Logger log = LoggerFactory.getLogger(FileTransferHelper.class);
	private static final int BUFFER_SIZE = 16_384; // 16 kB
	// Can only be in the range 0 - 65535
	private final AtomicInteger clientTransferId = new AtomicInteger(0);
	private final String defaultHost;
	FileTransferHelper(String host) {
		defaultHost = host;
	}
	// FILES
	void downloadFile(OutputStream dataOut, FileTransferParameters params) throws IOException {
		final String host = getHostFromResponse(params.getFileServerHost());
		final int port = params.getFileServerPort();
		final long dataLength = params.getFileSize();
		final int downloadId = params.getClientTransferId() + 1;
		log.info("[Download {}] Download started", downloadId);
		try (Socket socket = new Socket(host, port)) {
			socket.setReceiveBufferSize(BUFFER_SIZE);
			int actualSize = socket.getReceiveBufferSize();
			OutputStream out = socket.getOutputStream();
			out.write(params.getFileTransferKey().getBytes(StandardCharsets.UTF_8));
			out.flush();
			InputStream in = socket.getInputStream();
			byte[] buffer = new byte[actualSize];
			long total = 0;
			while (total < dataLength) {
				int read = in.read(buffer);
				if (read < 0) throw new IOException("Server response contained less data than specified");
				total += read;
				if (total > dataLength) throw new IOException("Server response contained more data than specified");
				dataOut.write(buffer, 0, read);
			}
			log.info("[Download {}] Download finished", downloadId);
		} catch (IOException e) {
			// Log and re-throw
			log.warn("[Download {}] Download failed: {}", downloadId, e.getMessage());
			throw e;
		}
	}
	void uploadFile(InputStream dataIn, long dataLength, FileTransferParameters params) throws IOException {
		final String host = getHostFromResponse(params.getFileServerHost());
		final int port = params.getFileServerPort();
		final int uploadId = params.getClientTransferId() + 1;
		log.info("[Upload {}] Upload started", uploadId);
		try (Socket socket = new Socket(host, port)) {
			socket.setSendBufferSize(BUFFER_SIZE);
			int actualSize = socket.getSendBufferSize();
			OutputStream out = socket.getOutputStream();
			out.write(params.getFileTransferKey().getBytes(StandardCharsets.UTF_8));
			out.flush();
			byte[] buffer = new byte[actualSize];
			long total = 0;
			while (total < dataLength) {
				int toRead = (int) Math.min(actualSize, dataLength - total);
				int read = dataIn.read(buffer, 0, toRead);
				if (read < 0) throw new IOException("User stream did not contain enough data");
				total += read;
				out.write(buffer, 0, read);
			}
			log.info("[Upload {}] Upload finished", uploadId);
		} catch (IOException e) {
			// Log and re-throw
			log.warn("[Upload {}] Upload failed: {}", uploadId, e.getMessage());
			throw e;
		}
	}
	// ICONS
	static long getIconId(byte[] data) {
		final CRC32 crc32 = new CRC32();
		crc32.update(data);
		return crc32.getValue();
	}
	// UTIL
	static byte[] readFully(InputStream dataIn, long dataLength) throws IOException {
		if (dataLength > Integer.MAX_VALUE - 64) throw new IOException("File too large");
		final int len = (int) dataLength;
		byte[] data = new byte[len];
		int total = 0;
		while (total < len) {
			int read = dataIn.read(data, total, len - total);
			if (read < 0) throw new IOException("User stream did not contain enough data");
			total += read;
		}
		return data;
	}
	int getClientTransferId() {
		return clientTransferId.getAndUpdate(id -> (id + 1) & 0xFFFF);
	}
	private String getHostFromResponse(String raw) {
		if (raw == null || raw.isEmpty()) return defaultHost;
		if (raw.startsWith("0.0.0.0")) return defaultHost;
		int firstComma = raw.indexOf(',');
		if (firstComma <= 0) return defaultHost;
		return raw.substring(0, firstComma);
	}
}
package com.github.theholywaffle.teamspeak3.api.exception;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2014 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
public class TS3ConnectionFailedException extends TS3Exception {
	private static final long serialVersionUID = 6849777544299282019L;
	public TS3ConnectionFailedException(String msg) {
		super(msg);
	}
	public TS3ConnectionFailedException(Throwable c) {
		super("Could not connect to the TeamSpeak3 server", c);
	}
	public TS3ConnectionFailedException(String msg, Throwable cause) {
		super(msg, cause);
	}
}
package com.github.theholywaffle.teamspeak3.api.reconnect;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2015 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.TS3Api;
import com.github.theholywaffle.teamspeak3.TS3Query;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class DisconnectingConnectionHandler implements ConnectionHandler {
	private static final Logger log = LoggerFactory.getLogger(DisconnectingConnectionHandler.class);
	private final ConnectionHandler userConnectionHandler;
	public DisconnectingConnectionHandler(ConnectionHandler userConnectionHandler) {
		this.userConnectionHandler = userConnectionHandler;
	}
	@Override
	public void onConnect(TS3Api api) {
		if (userConnectionHandler != null) {
			userConnectionHandler.onConnect(api);
		}
	}
	@Override
	public void onDisconnect(TS3Query ts3Query) {
		log.error("[Connection] Disconnected from TS3 server");
		if (userConnectionHandler != null) {
			userConnectionHandler.onDisconnect(ts3Query);
		}
	}
}
package com.github.theholywaffle.teamspeak3.api.reconnect;
/*
 * #%L
 * TeamSpeak 3 Java API
 * %%
 * Copyright (C) 2015 Bert De Geyter
 * %%
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * #L%
 */
import com.github.theholywaffle.teamspeak3.TS3Api;
import com.github.theholywaffle.teamspeak3.TS3Query;
import com.github.theholywaffle.teamspeak3.api.exception.TS3ConnectionFailedException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ReconnectingConnectionHandler implements ConnectionHandler {
	private static final Logger log = LoggerFactory.getLogger(ReconnectingConnectionHandler.class);
	private final ConnectionHandler userConnectionHandler;
	private final int startTimeout;
	private final int timeoutCap;
	private final int addend;
	private final double multiplier;
	public ReconnectingConnectionHandler(ConnectionHandler userConnectionHandler, int startTimeout,
	                                     int timeoutCap, int addend, double multiplier) {
		this.userConnectionHandler = userConnectionHandler;
		this.startTimeout = startTimeout;
		this.timeoutCap = timeoutCap;
		this.addend = addend;
		this.multiplier = multiplier;
	}
	@Override
	public void onConnect(TS3Api api) {
		if (userConnectionHandler != null) {
			userConnectionHandler.onConnect(api);
		}
	}
	@Override
	public void onDisconnect(TS3Query ts3Query) {
		// Announce disconnect and run user connection handler
		log.info("[Connection] Disconnected from TS3 server - reconnecting in {}ms", startTimeout);
		if (userConnectionHandler != null) {
			userConnectionHandler.onDisconnect(ts3Query);
		}
		int timeout = startTimeout;
		while (true) {
			try {
				Thread.sleep(timeout);
			} catch (InterruptedException e) {
				return;
			}
			timeout = (int) Math.ceil(timeout * multiplier) + addend;
			if (timeoutCap > 0) timeout = Math.min(timeout, timeoutCap);
			try {
				ts3Query.connect();
				return; // Successfully reconnected, return
			} catch (TS3ConnectionFailedException conFailed) {
				// Ignore exception, announce reconnect failure
				log.debug("[Connection] Failed to reconnect - waiting {}ms until next attempt", timeout);
			}
		}
	}
}