package com.github.unidbg.linux;
import com.github.unidbg.AbstractEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.LongJumpException;
import com.github.unidbg.StopEmulatorException;
import com.github.unidbg.Svc;
import com.github.unidbg.arm.ARM;
import com.github.unidbg.arm.ARMEmulator;
import com.github.unidbg.arm.ArmSvc;
import com.github.unidbg.arm.ThumbSvc;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BackendException;
import com.github.unidbg.arm.context.Arm32RegisterContext;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.file.FileIO;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.IOResolver;
import com.github.unidbg.file.linux.AndroidFileIO;
import com.github.unidbg.file.linux.IOConstants;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.file.ByteArrayFileIO;
import com.github.unidbg.linux.file.DriverFileIO;
import com.github.unidbg.linux.file.LocalAndroidUdpSocket;
import com.github.unidbg.linux.file.LocalSocketIO;
import com.github.unidbg.linux.file.NetLinkSocket;
import com.github.unidbg.linux.file.SocketIO;
import com.github.unidbg.linux.file.TcpSocket;
import com.github.unidbg.linux.file.UdpSocket;
import com.github.unidbg.linux.struct.Stat32;
import com.github.unidbg.linux.struct.SysInfo32;
import com.github.unidbg.linux.thread.KitKatThread;
import com.github.unidbg.linux.thread.MarshmallowThread;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.thread.PopContextException;
import com.github.unidbg.thread.Task;
import com.github.unidbg.thread.ThreadContextSwitchException;
import com.github.unidbg.unix.IO;
import com.github.unidbg.unix.UnixEmulator;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.ArmConst;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ARM32SyscallHandler extends AndroidSyscallHandler {
    private static final Logger log = LoggerFactory.getLogger(ARM32SyscallHandler.class);
    private final SvcMemory svcMemory;
    public ARM32SyscallHandler(SvcMemory svcMemory) {
        super();
        this.svcMemory = svcMemory;
    }
    @SuppressWarnings("unchecked")
    @Override
    public void hook(Backend backend, int intno, int swi, Object user) {
        Emulator<AndroidFileIO> emulator = (Emulator<AndroidFileIO>) user;
        UnidbgPointer pc = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_PC);
        final int bkpt;
        if (pc == null) {
            bkpt = swi;
        } else {
            if (ARM.isThumb(backend)) {
                bkpt = pc.getShort(0) & 0xff;
            } else {
                int instruction = pc.getInt(0);
                bkpt = (instruction & 0xf) | ((instruction >> 8) & 0xfff) << 4;
            }
        }
        if (intno == ARMEmulator.EXCP_BKPT) { 
            createBreaker(emulator).brk(pc, bkpt);
            return;
        }
        if (intno == ARMEmulator.EXCP_UDEF) {
            createBreaker(emulator).debug();
            return;
        }
        if (intno != ARMEmulator.EXCP_SWI) {
            throw new BackendException("intno=" + intno);
        }
        int NR = backend.reg_read(ArmConst.UC_ARM_REG_R7).intValue();
        String syscall = null;
        Throwable exception = null;
        try {
            if (swi == 0 && NR == 0 && (backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue()) == Svc.POST_CALLBACK_SYSCALL_NUMBER) { 
                int number = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
                Svc svc = svcMemory.getSvc(number);
                if (svc != null) {
                    svc.handlePostCallback(emulator);
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (swi == 0 && NR == 0 && (backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue()) == Svc.PRE_CALLBACK_SYSCALL_NUMBER) { 
                int number = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
                Svc svc = svcMemory.getSvc(number);
                if (svc != null) {
                    svc.handlePreCallback(emulator);
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (swi != 0) {
                if (swi == (ARM.isThumb(backend) ? ThumbSvc.SVC_MAX : ArmSvc.SVC_MAX)) {
                    throw new PopContextException();
                }
                if (swi == (ARM.isThumb(backend) ? ThumbSvc.SVC_MAX : ArmSvc.SVC_MAX) - 1) {
                    throw new ThreadContextSwitchException();
                }
                Svc svc = svcMemory.getSvc(swi);
                if (svc != null) {
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, (int) svc.handle(emulator));
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (log.isTraceEnabled()) {
                ARM.showThumbRegs(emulator);
            }
            if (handleSyscall(emulator, NR)) {
                return;
            }
            switch (NR) {
                case 1:
                    exit(emulator);
                    return;
                case 2:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fork(emulator));
                    return;
                case 3:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, read(emulator));
                    return;
                case 4:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, write(emulator));
                    return;
                case 5:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, open(emulator));
                    return;
                case 6:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, close(emulator));
                    return;
                case 10:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, unlink(emulator));
                    return;
                case 11:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, execve(emulator));
                    return;
                case 19:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, lseek(emulator));
                    return;
                case 26:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, ptrace(emulator));
                    return;
                case  20: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, emulator.getPid());
                    return;
                case 224: 
                    Task task = emulator.get(Task.TASK_KEY);
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, task == null ? 0 : task.getId());
                    return;
                case 33:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, access(emulator));
                    return;
                case 36: 
                    return;
                case 37:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, kill(emulator));
                    return;
                case 38:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, rename(emulator));
                    return;
                case 39:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mkdir(emulator));
                    return;
                case 41:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, dup(emulator));
                    return;
                case 42:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, pipe(emulator));
                    return;
                case 45:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, brk(emulator));
                    return;
                case 54:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, ioctl(emulator));
                    return;
                case 57:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setpgid(emulator));
                    return;
                case 60:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, umask(emulator));
                    return;
                case 63:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, dup2(backend, emulator));
                    return;
                case 64:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getppid(emulator));
                    return;
                case 67:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sigaction(emulator));
                    return;
                case 73:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, rt_sigpending(emulator));
                    return;
                case 78:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, gettimeofday(emulator));
                    return;
                case 85:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, readlink(emulator));
                    return;
                case 88:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, reboot(backend, emulator));
                    return;
                case 91:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, munmap(backend, emulator));
                    return;
                case 93:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, ftruncate(backend));
                    return;
                case 94:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fchmod(backend));
                    return;
                case 96:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getpriority(emulator));
                    return;
                case 97:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setpriority(emulator));
                    return;
                case 103:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, syslog(backend, emulator));
                    return;
                case 104:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setitimer(emulator));
                    return;
                case 116:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sysinfo(emulator));
                    return;
                case 118:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fsync(backend));
                    return;
                case 120:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, clone(emulator));
                    return;
                case 122:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, uname(emulator));
                    return;
                case 125:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mprotect(backend, emulator));
                    return;
                case 126:
                case 175:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sigprocmask(emulator));
                    return;
                case 132:
                    syscall = "getpgid";
                    break;
                case 136:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, personality(backend));
                    return;
                case 140:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, llseek(backend, emulator));
                    return;
                case 142:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, newselect(backend, emulator));
                    return;
                case 143:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, flock(backend));
                    return;
                case 146:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, writev(backend, emulator));
                    return;
                case 147:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getsid(emulator));
                    return;
                case 150:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mlock(emulator));
                    return;
                case 151:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, munlock(emulator));
                    return;
                case 155:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sched_getparam(emulator));
                    return;
                case 156:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sched_setscheduler(emulator));
                    return;
                case 157:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sched_getscheduler(emulator));
                    return;
                case 158:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sched_yield(emulator));
                    return;
                case 162:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, nanosleep(emulator));
                    return;
                case 163:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mremap(emulator));
                    return;
                case 168:
                case 336:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, poll(backend, emulator));
                    return;
                case 172:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, prctl(backend, emulator));
                    return;
                case 176:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, rt_sigpending(emulator));
                    return;
                case 177:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, rt_sigtimedwait(emulator));
                    return;
                case 178:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, rt_sigqueue(emulator));
                    return;
                case 180:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, pread64(emulator));
                    return;
                case 183:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getcwd(emulator));
                    return;
                case 186:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sigaltstack(emulator));
                    return;
                case 192:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mmap2(backend, emulator));
                    return;
                case 194:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, ftruncate(backend));
                    return;
                case 195:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, stat64(emulator));
                    return;
                case 196:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, lstat(emulator));
                    return;
                case 197:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fstat(backend, emulator));
                    return;
                case 199: 
                case 200: 
                case 201: 
                case 202: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, 0);
                    return;
                case 205:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getgroups(backend, emulator));
                    return;
                case 208:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setresuid32(backend));
                    return;
                case 210:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setresgid32(backend));
                    return;
                case 214:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setgid32(emulator));
                    return;
                case 217:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getdents64(emulator));
                    return;
                case 220:
                    syscall = "madvise";
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, 0);
                    return;
                case 221:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fcntl(backend, emulator));
                    return;
                case 230:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, lgetxattr(backend, emulator));
                    return;
                case 238:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, tkill(emulator));
                    return;
                case 240:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, futex(emulator));
                    return;
                case 241:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sched_setaffinity(emulator));
                    return;
                case 242:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sched_getaffinity(emulator));
                    return;
                case 248:
                    exit_group(emulator);
                    return;
                case 256:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, set_tid_address(emulator));
                    return;
                case 263:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, clock_gettime(backend, emulator));
                    return;
                case 266: {
                    RegisterContext context = emulator.getContext();
                    Pointer pathPointer = context.getPointerArg(0);
                    int size = context.getIntArg(1);
                    Pointer buf = context.getPointerArg(2).setSize(size);
                    String path = pathPointer.getString(0);
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, (int) statfs64(emulator, path, buf));
                    return;
                }
                case 268:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, tgkill(emulator));
                    return;
                case 269:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, utimes(emulator));
                    return;
                case 281:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, socket(backend, emulator));
                    return;
                case 282:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, bind(emulator));
                    return;
                case 283:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, connect(backend, emulator));
                    return;
                case 284:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, listen(emulator));
                    return;
                case 285:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, accept(emulator));
                    return;
                case 286:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getsockname(backend, emulator));
                    return;
                case 287:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getpeername(backend, emulator));
                    return;
                case 290:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sendto(backend, emulator));
                    return;
                case 292:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, recvfrom(emulator));
                    return;
                case 293:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, shutdown(backend, emulator));
                    return;
                case 294:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setsockopt(backend, emulator));
                    return;
                case 295:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getsockopt(backend, emulator));
                    return;
                case 322:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, openat(emulator));
                    return;
                case 323:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mkdirat(emulator));
                    return;
                case 327:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fstatat64(backend, emulator));
                    return;
                case 328:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, unlinkat(emulator));
                    return;
                case 332:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, readlinkat(emulator));
                    return;
                case 333:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fchmodat(emulator));
                    return;
                case 329:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, renameat(emulator));
                    return;
                case 334:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, faccessat(backend, emulator));
                    return;
                case 335:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, pselect6(emulator));
                    return;
                case 345:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getcpu(emulator));
                    return;
                case 348:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, utimensat(backend, emulator));
                    return;
                case 356:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, eventfd2(emulator));
                    return;
                case 352:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fallocate(emulator));
                    return;
                case 358:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, dup3(emulator));
                    return;
                case 359:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, pipe2(emulator));
                    return;
                case 366:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, accept4(emulator));
                    return;
                case 384:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getrandom(emulator));
                    return;
                case 0xf0002:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, cacheflush(backend, emulator));
                    return;
                case 0xf0005:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, set_tls(backend, emulator));
                    return;
            }
        } catch (StopEmulatorException e) {
            backend.emu_stop();
            return;
        } catch (LongJumpException e) {
            backend.emu_stop();
            throw e;
        } catch (Throwable e) {
            backend.emu_stop();
            exception = e;
        }
        if (exception == null && handleUnknownSyscall(emulator, NR)) {
            return;
        }
        log.warn("handleInterrupt intno={}, NR={}, svcNumber=0x{}, PC={}, LR={}, syscall={}", intno, NR, Integer.toHexString(swi), pc, emulator.getContext().getLRPointer(), syscall, exception);
        if (exception instanceof RuntimeException) {
            throw (RuntimeException) exception;
        }
    }
    private int getrandom(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer buf = context.getPointerArg(0);
        int bufSize = context.getIntArg(1);
        int flags = context.getIntArg(2);
        return getrandom(buf, bufSize, flags);
    }
    private int clone(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer child_stack = context.getPointerArg(1);
        if (child_stack == null &&
                context.getPointerArg(2) == null) {
            return fork(emulator); 
        }
        int fn = context.getR5Int();
        int arg = context.getR6Int();
        if (child_stack != null && child_stack.getInt(0) == fn && child_stack.getInt(4) == arg) {
            return bionic_clone(emulator);
        } else {
            return pthread_clone(emulator);
        }
    }
    private int tkill(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int tid = context.getIntArg(0);
        int sig = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("tkill tid={}, sig={}", tid, sig);
        }
        return 0;
    }
    private int setpgid(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        int pgid = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("setpgid pid={}, pgid={}", pid, pgid);
        }
        return 0;
    }
    private int getsid(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("getsid pid={}", pid);
        }
        return emulator.getPid();
    }
    private int readlinkat(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname = context.getPointerArg(1);
        Pointer buf = context.getPointerArg(2);
        int bufSize = context.getIntArg(3);
        String path = pathname.getString(0);
        if (dirfd != IO.AT_FDCWD) {
            throw new BackendException();
        }
        return readlink(emulator, path, buf, bufSize);
    }
    private int readlink(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        Pointer buf = context.getPointerArg(1);
        int bufSize = context.getIntArg(2);
        String path = pathname.getString(0);
        return readlink(emulator, path, buf, bufSize);
    }
    private int getppid(Emulator<?> emulator) {
        if (log.isDebugEnabled()) {
            log.debug("getppid");
        }
        return emulator.getPid();
    }
    private int getcpu(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer cpu = context.getR0Pointer();
        Pointer node = context.getR1Pointer();
        Pointer tcache = context.getR2Pointer();
        if (log.isDebugEnabled()) {
            log.debug("getcpu cpu={}, node={}, tcache={}", cpu, node, tcache);
        }
        if (cpu != null) {
            cpu.setInt(0, 0);
        }
        if (node != null) {
            node.setInt(0, 0);
        }
        return 0;
    }
    private int sysinfo(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer info = context.getR0Pointer();
        if (log.isDebugEnabled()) {
            log.debug("sysinfo info={}", info);
        }
        SysInfo32 sysInfo32 = new SysInfo32(info);
        sysInfo32.pack();
        return 0;
    }
    private int mremap(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        UnidbgPointer old_address = context.getR0Pointer();
        int old_size = context.getR1Int();
        int new_size = context.getR2Int();
        int flags = context.getR3Int();
        UnidbgPointer new_address = context.getR4Pointer();
        if (log.isDebugEnabled()) {
            log.debug("mremap old_address={}, old_size={}, new_size={}, flags={}, new_address={}", old_address, old_size, new_size, flags, new_address);
        }
        if (old_size == 0) {
            throw new BackendException("old_size is zero");
        }
        boolean fixed = (flags & MREMAP_FIXED) != 0;
        if ((flags & MREMAP_MAYMOVE) == 0) {
            throw new BackendException("flags=" + flags);
        }
        Memory memory = emulator.getMemory();
        byte[] data = old_address.getByteArray(0, old_size);
        int prot = memory.munmap(old_address.toUIntPeer(), old_size);
        final long address;
        if (fixed) {
            address = memory.mmap2(new_address.toUIntPeer(), new_size, prot, AndroidElfLoader.MAP_ANONYMOUS | AndroidElfLoader.MAP_FIXED, 0, 0);
        } else {
            address = memory.mmap2(0, new_size, prot, AndroidElfLoader.MAP_ANONYMOUS, 0, 0);
        }
        UnidbgPointer pointer = UnidbgPointer.pointer(emulator, address);
        assert pointer != null;
        pointer.write(0, data, 0, data.length);
        return (int) pointer.toUIntPeer();
    }
    protected int ptrace(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int request = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int pid = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        Pointer addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        Pointer data = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R3);
        log.info("ptrace request=0x{}, pid={}, addr={}, data={}", Integer.toHexString(request), pid, addr, data);
        return 0;
    }
    private int utimes(Emulator<?> emulator) {
        Pointer filename = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        Pointer times = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        if (log.isDebugEnabled()) {
            log.debug("utimes filename={}, times={}", filename.getString(0), times);
        }
        return 0;
    }
    private int utimensat(Backend backend, Emulator<?> emulator) {
        int dirfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer pathname = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        Pointer times = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        if (log.isDebugEnabled()) {
            log.debug("utimensat dirfd={}, pathname={}, times={}, flags={}", dirfd, pathname.getString(0), times, flags);
        }
        return 0;
    }
    private int fsync(Backend backend) {
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        if (log.isDebugEnabled()) {
            log.debug("fsync fd={}", fd);
        }
        return 0;
    }
    private int rename(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer oldpath = context.getR0Pointer();
        Pointer newpath = context.getR1Pointer();
        log.info("rename oldpath={}, newpath={}", oldpath.getString(0), newpath.getString(0));
        return 0;
    }
    private int unlink(Emulator<?> emulator) {
        Pointer pathname = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        String path = FilenameUtils.normalize(pathname.getString(0), true);
        log.info("unlink path={}", path);
        return 0;
    }
    private int pipe(Emulator<?> emulator) {
        Pointer pipefd = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        int readfd = pipefd.getInt(0);
        int writefd = pipefd.getInt(4);
        log.info("pipe readfd={}, writefd={}", readfd, writefd);
        emulator.getMemory().setErrno(UnixEmulator.EFAULT);
        return -1;
    }
    private int set_tls(Backend backend, Emulator<?> emulator) {
        UnidbgPointer tls = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        if (log.isDebugEnabled()) {
            log.debug("set_tls: {}", tls);
        }
        backend.reg_write(ArmConst.UC_ARM_REG_C13_C0_3, tls.peer);
        return 0;
    }
    private int cacheflush(Backend backend, Emulator<?> emulator) {
        Pointer begin = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        Pointer end = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int cache = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        if (log.isDebugEnabled()) {
            log.debug("cacheflush begin={}, end={}, cache={}", begin, end, cache);
        }
        return 0;
    }
    protected int fork(Emulator<?> emulator) {
        log.info("fork");
        Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
        if (log.isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        emulator.getMemory().setErrno(UnixEmulator.ENOSYS);
        return -1;
    }
    private static final int CLONE_VM = 0x00000100;
    private static final int CLONE_FS = 0x00000200;
    private static final int CLONE_FILES = 0x00000400;
    private static final int CLONE_SIGHAND = 0x00000800;
    private static final int CLONE_PTRACE = 0x00002000;
    private static final int CLONE_VFORK = 0x00004000;
    private static final int CLONE_PARENT = 0x00008000;
    private static final int CLONE_THREAD = 0x00010000;
    private static final int CLONE_NEWNS = 0x00020000;
    private static final int CLONE_SYSVSEM = 0x00040000;
    private static final int CLONE_SETTLS = 0x00080000;
    private static final int CLONE_PARENT_SETTID = 0x00100000;
    private static final int CLONE_CHILD_CLEARTID = 0x00200000;
    private static final int CLONE_DETACHED = 0x00400000;
    private static final int CLONE_UNTRACED = 0x00800000;
    private static final int CLONE_CHILD_SETTID = 0x01000000;
    private static final int CLONE_STOPPED = 0x02000000;
    private int pthread_clone(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int flags = context.getIntArg(0);
        UnidbgPointer child_stack = context.getPointerArg(1);
        List<String> list = new ArrayList<>();
        if ((flags & CLONE_VM) != 0) {
            list.add("CLONE_VM");
        }
        if ((flags & CLONE_FS) != 0) {
            list.add("CLONE_FS");
        }
        if ((flags & CLONE_FILES) != 0) {
            list.add("CLONE_FILES");
        }
        if ((flags & CLONE_SIGHAND) != 0) {
            list.add("CLONE_SIGHAND");
        }
        if ((flags & CLONE_PTRACE) != 0) {
            list.add("CLONE_PTRACE");
        }
        if ((flags & CLONE_VFORK) != 0) {
            list.add("CLONE_VFORK");
        }
        if ((flags & CLONE_PARENT) != 0) {
            list.add("CLONE_PARENT");
        }
        if ((flags & CLONE_THREAD) != 0) {
            list.add("CLONE_THREAD");
        }
        if ((flags & CLONE_NEWNS) != 0) {
            list.add("CLONE_NEWNS");
        }
        if ((flags & CLONE_SYSVSEM) != 0) {
            list.add("CLONE_SYSVSEM");
        }
        if ((flags & CLONE_SETTLS) != 0) {
            list.add("CLONE_SETTLS");
        }
        if ((flags & CLONE_PARENT_SETTID) != 0) {
            list.add("CLONE_PARENT_SETTID");
        }
        if ((flags & CLONE_CHILD_CLEARTID) != 0) {
            list.add("CLONE_CHILD_CLEARTID");
        }
        if ((flags & CLONE_DETACHED) != 0) {
            list.add("CLONE_DETACHED");
        }
        if ((flags & CLONE_UNTRACED) != 0) {
            list.add("CLONE_UNTRACED");
        }
        if ((flags & CLONE_CHILD_SETTID) != 0) {
            list.add("CLONE_CHILD_SETTID");
        }
        if ((flags & CLONE_STOPPED) != 0) {
            list.add("CLONE_STOPPED");
        }
        int threadId = incrementThreadId(emulator);
        UnidbgPointer fn = child_stack.getPointer(0);
        child_stack = child_stack.share(4, 0);
        UnidbgPointer arg = child_stack.getPointer(0);
        child_stack = child_stack.share(4, 0);
        if (threadDispatcherEnabled) {
            if (verbose) {
                System.out.printf("pthread_clone fn=%s%n", fn);
            }
            emulator.getThreadDispatcher().addThread(new KitKatThread(threadId, emulator.getReturnAddress(), child_stack, fn, arg));
            return threadId;
        }
        log.info("pthread_clone child_stack={}, thread_id={}, fn={}, arg={}, flags={}", child_stack, threadId, fn, arg, list);
        Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
        if (log.isDebugEnabled()) {
            emulator.attach().debug();
        }
        return threadId;
    }
    private int bionic_clone(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        int flags = context.getR0Int();
        Pointer child_stack = context.getR1Pointer();
        Pointer pid = context.getR2Pointer();
        Pointer tls = context.getR3Pointer();
        Pointer ctid = context.getR4Pointer();
        UnidbgPointer fn = context.getR5Pointer();
        UnidbgPointer arg = context.getR6Pointer();
        List<String> list = new ArrayList<>();
        if ((flags & CLONE_VM) != 0) {
            list.add("CLONE_VM");
        }
        if ((flags & CLONE_FS) != 0) {
            list.add("CLONE_FS");
        }
        if ((flags & CLONE_FILES) != 0) {
            list.add("CLONE_FILES");
        }
        if ((flags & CLONE_SIGHAND) != 0) {
            list.add("CLONE_SIGHAND");
        }
        if ((flags & CLONE_PTRACE) != 0) {
            list.add("CLONE_PTRACE");
        }
        if ((flags & CLONE_VFORK) != 0) {
            list.add("CLONE_VFORK");
        }
        if ((flags & CLONE_PARENT) != 0) {
            list.add("CLONE_PARENT");
        }
        if ((flags & CLONE_THREAD) != 0) {
            list.add("CLONE_THREAD");
        }
        if ((flags & CLONE_NEWNS) != 0) {
            list.add("CLONE_NEWNS");
        }
        if ((flags & CLONE_SYSVSEM) != 0) {
            list.add("CLONE_SYSVSEM");
        }
        if ((flags & CLONE_SETTLS) != 0) {
            list.add("CLONE_SETTLS");
        }
        if ((flags & CLONE_PARENT_SETTID) != 0) {
            list.add("CLONE_PARENT_SETTID");
        }
        if ((flags & CLONE_CHILD_CLEARTID) != 0) {
            list.add("CLONE_CHILD_CLEARTID");
        }
        if ((flags & CLONE_DETACHED) != 0) {
            list.add("CLONE_DETACHED");
        }
        if ((flags & CLONE_UNTRACED) != 0) {
            list.add("CLONE_UNTRACED");
        }
        if ((flags & CLONE_CHILD_SETTID) != 0) {
            list.add("CLONE_CHILD_SETTID");
        }
        if ((flags & CLONE_STOPPED) != 0) {
            list.add("CLONE_STOPPED");
        }
        int threadId = incrementThreadId(emulator);
        if (log.isDebugEnabled()) {
            log.debug("bionic_clone child_stack={}, thread_id={}, pid={}, tls={}, ctid={}, fn={}, arg={}, flags={}", child_stack, threadId, pid, tls, ctid, fn, arg, list);
        }
        if (threadDispatcherEnabled) {
            if (verbose) {
                System.out.printf("bionic_clone fn=%s, LR=%s%n", fn, context.getLRPointer());
            }
            emulator.getThreadDispatcher().addThread(new MarshmallowThread(emulator, fn, arg, ctid, threadId));
        }
        ctid.setInt(0, threadId);
        return threadId;
    }
    private int flock(Backend backend) {
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int operation = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (log.isDebugEnabled()) {
            log.debug("flock fd={}, operation={}", fd, operation);
        }
        return 0;
    }
    private int fchmod(Backend backend) {
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int mode = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (log.isDebugEnabled()) {
            log.debug("fchmod fd={}, mode={}", fd, mode);
        }
        return 0;
    }
    private int llseek(Backend backend, Emulator<?> emulator) {
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        long offset_high = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue() & 0xffffffffL;
        long offset_low = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue() & 0xffffffffL;
        long offset = (offset_high << 32) | offset_low;
        Pointer result = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R3);
        int whence = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
        if (log.isDebugEnabled()) {
            log.debug("llseek fd={}, offset_high={}, offset_low={}, result={}, whence={}", fd, offset_high, offset_low, result, whence);
        }
        FileIO io = fdMap.get(fd);
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        } else {
            return io.llseek(offset, result, whence);
        }
    }
    private int access(Emulator<AndroidFileIO> emulator) {
        Backend backend = emulator.getBackend();
        Pointer pathname = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        int mode = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (pathname == null) {
            emulator.getMemory().setErrno(UnixEmulator.EINVAL);
            return -1;
        }
        String path = pathname.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("access pathname={}, mode={}", path, mode);
        }
        int ret = faccessat(emulator, path);
        if (ret == -1) {
            log.info("access pathname={}, mode={}", path, mode);
        }
        return ret;
    }
    private int execve(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer filename = context.getPointerArg(0);
        Pointer argv = context.getPointerArg(1);
        Pointer envp = context.getPointerArg(2);
        assert filename != null;
        List<String> args = new ArrayList<>();
        Pointer pointer;
        while ((pointer = argv.getPointer(0)) != null) {
            args.add(pointer.getString(0));
            argv = argv.share(4);
        }
        List<String> env = new ArrayList<>();
        while ((pointer = envp.getPointer(0)) != null) {
            env.add(pointer.getString(0));
            envp = envp.share(4);
        }
        log.info("execve filename={}, args={}, env={}", filename.getString(0), args, env);
        Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
        if (log.isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        emulator.getMemory().setErrno(UnixEmulator.EACCES);
        return -1;
    }
    private long persona;
    private int personality(Backend backend) {
        long persona = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue() & 0xffffffffL;
        if (log.isDebugEnabled()) {
            log.debug("personality persona=0x{}", Long.toHexString(persona));
        }
        int old = (int) this.persona;
        if (persona != 0xffffffffL) {
            this.persona = persona;
        }
        return old;
    }
    private int shutdown(Backend backend, Emulator<?> emulator) {
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int how = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (log.isDebugEnabled()) {
            log.debug("shutdown sockfd={}, how={}", sockfd, how);
        }
        FileIO io = fdMap.get(sockfd);
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return io.shutdown(how);
    }
    private int dup(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int oldfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        FileIO io = fdMap.get(oldfd);
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (log.isDebugEnabled()) {
            log.debug("dup oldfd={}, io={}", oldfd, io);
        }
        AndroidFileIO _new = (AndroidFileIO) io.dup2();
        if (_new == null) {
            throw new UnsupportedOperationException();
        }
        int newfd = getMinFd();
        fdMap.put(newfd, _new);
        return newfd;
    }
    private int stat64(Emulator<AndroidFileIO> emulator) {
        Pointer pathname = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        Pointer statbuf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        String path = FilenameUtils.normalize(pathname.getString(0), true);
        if (log.isDebugEnabled()) {
            log.debug("stat64 pathname={}, statbuf={}", path, statbuf);
        }
        return stat64(emulator, path, statbuf);
    }
    private int lstat(Emulator<AndroidFileIO> emulator) {
        Pointer pathname = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        Pointer statbuf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        String path = FilenameUtils.normalize(pathname.getString(0), true);
        if (log.isDebugEnabled()) {
            log.debug("lstat pathname={}, statbuf={}", path, statbuf);
        }
        return stat64(emulator, path, statbuf);
    }
    protected int stat64(Emulator<AndroidFileIO> emulator, String pathname, Pointer statbuf) {
        FileResult<AndroidFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            return result.io.fstat(emulator, new Stat32(statbuf));
        }
        log.info("stat64 pathname={}, LR={}", pathname, emulator.getContext().getLRPointer());
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.ENOENT);
        return -1;
    }
    private int newselect(Backend backend, Emulator<?> emulator) {
        int nfds = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer readfds = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        Pointer writefds = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        Pointer exceptfds = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R3);
        Pointer timeout = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R4);
        int size = (nfds - 1) / 8 + 1;
        if (log.isDebugEnabled()) {
            log.debug("newselect nfds={}, readfds={}, writefds={}, exceptfds={}, timeout={}", nfds, readfds, writefds, exceptfds, timeout);
            if (readfds != null) {
                byte[] data = readfds.getByteArray(0, size);
                Inspector.inspect(data, "readfds");
            }
            if (writefds != null) {
                byte[] data = writefds.getByteArray(0, size);
                Inspector.inspect(data, "writefds");
            }
        }
        if (exceptfds != null) {
            emulator.getMemory().setErrno(UnixEmulator.ENOMEM);
            return -1;
        }
        if (writefds != null) {
            int count = select(nfds, writefds, readfds, false);
            if (count > 0) {
                return count;
            }
        }
        if (readfds != null) {
            int count = select(nfds, readfds, writefds, true);
            if (count == 0) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    throw new IllegalStateException(e);
                }
            }
            return count;
        }
        throw new AbstractMethodError("newselect nfds=" + nfds + ", readfds=null, writefds=" + writefds + ", exceptfds=null, timeout=" + timeout);
    }
    protected int pselect6(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        int nfds = context.getIntArg(0);
        Pointer readfds = context.getPointerArg(1);
        Pointer writefds = context.getPointerArg(2);
        Pointer exceptfds = context.getPointerArg(3);
        Pointer timeout = context.getR4Pointer();
        int size = (nfds - 1) / 8 + 1;
        if (log.isDebugEnabled()) {
            log.debug("pselect6 nfds={}, readfds={}, writefds={}, exceptfds={}, timeout={}, LR={}", nfds, readfds, writefds, exceptfds, timeout, context.getLRPointer());
            if (readfds != null) {
                byte[] data = readfds.getByteArray(0, size);
                Inspector.inspect(data, "readfds");
            }
            if (writefds != null) {
                byte[] data = writefds.getByteArray(0, size);
                Inspector.inspect(data, "writefds");
            }
        }
        if (exceptfds != null) {
            emulator.getMemory().setErrno(UnixEmulator.ENOMEM);
            return -1;
        }
        if (writefds != null) {
            int count = select(nfds, writefds, readfds, false);
            if (count > 0) {
                return count;
            }
        }
        if (readfds != null) {
            int count = select(nfds, readfds, writefds, true);
            if (count == 0) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    throw new IllegalStateException(e);
                }
            }
            return count;
        }
        throw new AbstractMethodError("pselect6 nfds=" + nfds + ", readfds=null, writefds=" + writefds + ", exceptfds=null, timeout=" + timeout + ", LR=" + context.getLRPointer());
    }
    private int getpeername(Backend backend, Emulator<?> emulator) {
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        Pointer addrlen = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        if (log.isDebugEnabled()) {
            log.debug("getpeername sockfd={}, addr={}, addrlen={}", sockfd, addr, addrlen);
        }
        FileIO io = fdMap.get(sockfd);
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return io.getpeername(addr, addrlen);
    }
    private static final short POLLIN = 0x0001;
    private static final short POLLOUT = 0x0004;
    private int poll(Backend backend, Emulator<?> emulator) {
        Pointer fds = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        int nfds = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int timeout = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int count = 0;
        for (int i = 0; i < nfds; i++) {
            Pointer pollfd = fds.share(i * 8L);
            int fd = pollfd.getInt(0);
            short events = pollfd.getShort(4); 
            if (log.isDebugEnabled()) {
                log.debug("poll fds={}, nfds={}, timeout={}, fd={}, events={}", fds, nfds, timeout, fd, events);
            }
            if (fd < 0) {
                pollfd.setShort(6, (short) 0);
            } else {
                short revents = 0;
                if ((events & POLLOUT) != 0) {
                    revents = POLLOUT;
                } else if ((events & POLLIN) != 0) {
                    revents = POLLIN;
                }
                pollfd.setShort(6, revents); 
                count++;
            }
        }
        return count;
    }
    private int mask = 0x12;
    private int umask(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int mask = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        if (log.isDebugEnabled()) {
            log.debug("umask mask=0x{}", Long.toHexString(mask));
        }
        int old = this.mask;
        this.mask = mask;
        return old;
    }
    private int setresuid32(Backend backend) {
        int ruid = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int euid = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int suid = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        if (log.isDebugEnabled()) {
            log.debug("setresuid32 ruid={}, euid={}, suid={}", ruid, euid, suid);
        }
        return 0;
    }
    private int setgid32(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int gid = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("setgid32 gid={}", gid);
        }
        return 0;
    }
    private int setresgid32(Backend backend) {
        int rgid = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int egid = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int sgid = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        if (log.isDebugEnabled()) {
            log.debug("setresgid32 rgid={}, egid={}, sgid={}", rgid, egid, sgid);
        }
        return 0;
    }
    private int mkdir(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        int mode = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("mkdir pathname={}, mode={}", pathname.getString(0), mode);
        }
        emulator.getMemory().setErrno(UnixEmulator.EACCES);
        return -1;
    }
    private int syslog(Backend backend, Emulator<?> emulator) {
        int type = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer bufp = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int len = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        if (log.isDebugEnabled()) {
            log.debug("syslog type={}, bufp={}, len={}", type, bufp, len);
        }
        throw new UnsupportedOperationException();
    }
    private int sigprocmask(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int how = context.getIntArg(0);
        Pointer set = context.getPointerArg(1);
        Pointer oldset = context.getPointerArg(2);
        return sigprocmask(emulator, how, set, oldset);
    }
    private int lgetxattr(Backend backend, Emulator<?> emulator) {
        Pointer path = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        Pointer name = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        Pointer value = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        int size = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        if (log.isDebugEnabled()) {
            log.debug("lgetxattr path={}, name={}, value={}, size={}", path.getString(0), name.getString(0), value, size);
        }
        throw new UnsupportedOperationException();
    }
    private int reboot(Backend backend, Emulator<?> emulator) {
        int magic = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int magic2 = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int cmd = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        Pointer arg = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R3);
        if (log.isDebugEnabled()) {
            log.debug("reboot magic={}, magic2={}, cmd={}, arg={}", magic, magic2, cmd, arg);
        }
        emulator.getMemory().setErrno(UnixEmulator.EPERM);
        return -1;
    }
    private int setitimer(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        int which = context.getR0Int();
        Pointer new_value = context.getR1Pointer();
        Pointer old_value = context.getR2Pointer();
        if (log.isDebugEnabled()) {
            log.debug("setitimer which={}, new_value={}, old_value={}", which, new_value, old_value);
        }
        return 0;
    }
    private int sigaction(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int signum = context.getIntArg(0);
        Pointer act = context.getPointerArg(1);
        Pointer oldact = context.getPointerArg(2);
        return sigaction(emulator, signum, act, oldact);
    }
    private int recvfrom(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int len = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        Pointer src_addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R4);
        Pointer addrlen = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R5);
        if (log.isDebugEnabled()) {
            log.debug("recvfrom sockfd={}, buf={}, flags={}, src_addr={}, addrlen={}", sockfd, buf, flags, src_addr, addrlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.recvfrom(backend, buf, len, flags, src_addr, addrlen);
    }
    private int sendto(Backend backend, Emulator<?> emulator) {
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int len = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        Pointer dest_addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R4);
        int addrlen = backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue();
        return sendto(emulator, sockfd, buf, len, flags, dest_addr, addrlen);
    }
    private int connect(Backend backend, Emulator<?> emulator) {
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int addrlen = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        return connect(emulator, sockfd, addr, addrlen);
    }
    private int accept(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer addr = context.getPointerArg(1);
        Pointer addrlen = context.getPointerArg(2);
        return accept(emulator, sockfd, addr, addrlen, 0);
    }
    private int accept4(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer addr = context.getPointerArg(1);
        Pointer addrlen = context.getPointerArg(2);
        int flags = context.getIntArg(3);
        return accept(emulator, sockfd, addr, addrlen, flags);
    }
    protected final int accept(Emulator<AndroidFileIO> emulator, int sockfd, Pointer addr, Pointer addrlen, int flags) {
        if (log.isDebugEnabled()) {
            log.debug("accept sockfd={}, addr={}, addrlen={}, flags={}", sockfd, addr, addrlen, flags);
        }
        AndroidFileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        AndroidFileIO newIO = file.accept(addr, addrlen);
        if (newIO == null) {
            return -1;
        } else {
            int fd = getMinFd();
            fdMap.put(fd, newIO);
            return fd;
        }
    }
    private int listen(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        int backlog = context.getIntArg(1);
        return listen(emulator, sockfd, backlog);
    }
    private int bind(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer addr = context.getPointerArg(1);
        int addrlen = context.getIntArg(2);
        return bind(emulator, sockfd, addr, addrlen);
    }
    private int getsockname(Backend backend, Emulator<?> emulator) {
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        Pointer addrlen = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        if (log.isDebugEnabled()) {
            log.debug("getsockname sockfd={}, addr={}, addrlen={}", sockfd, addr, addrlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.getsockname(addr, addrlen);
    }
    private int getsockopt(Backend backend, Emulator<?> emulator) {
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int level = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int optname = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        Pointer optval = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R3);
        Pointer optlen = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R4);
        if (log.isDebugEnabled()) {
            log.debug("getsockopt sockfd={}, level={}, optname={}, optval={}, optlen={}, from={}", sockfd, level, optname, optval, optlen, UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.getsockopt(level, optname, optval, optlen);
    }
    private int setsockopt(Backend backend, Emulator<?> emulator) {
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int level = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int optname = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        Pointer optval = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R3);
        int optlen = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
        if (log.isDebugEnabled()) {
            log.debug("setsockopt sockfd={}, level={}, optname={}, optval={}, optlen={}", sockfd, level, optname, optval, optlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.setsockopt(level, optname, optval, optlen);
    }
    private int sdk;
    @Override
    public void addIOResolver(IOResolver<AndroidFileIO> resolver) {
        super.addIOResolver(resolver);
        if (resolver instanceof AndroidResolver) {
            sdk = ((AndroidResolver) resolver).getSdk();
        }
    }
    protected AndroidFileIO createLocalSocketIO(Emulator<?> emulator, int sdk) {
        return new LocalSocketIO(emulator, sdk);
    }
    private int socket(Backend backend, Emulator<?> emulator) {
        int domain = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int type = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue() & 0x7ffff;
        int protocol = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        if (log.isDebugEnabled()) {
            log.debug("socket domain={}, type={}, protocol={}", domain, type, protocol);
        }
        if (protocol == SocketIO.IPPROTO_ICMP) {
            throw new UnsupportedOperationException();
        }
        int fd;
        switch (domain) {
            case SocketIO.AF_UNSPEC:
                throw new UnsupportedOperationException();
            case SocketIO.AF_LOCAL:
                switch (type) {
                    case SocketIO.SOCK_STREAM:
                        fd = getMinFd();
                        fdMap.put(fd, createLocalSocketIO(emulator, sdk));
                        return fd;
                    case SocketIO.SOCK_DGRAM:
                        fd = getMinFd();
                        fdMap.put(fd, new LocalAndroidUdpSocket(emulator));
                        return fd;
                    default:
                        emulator.getMemory().setErrno(UnixEmulator.EACCES);
                        return -1;
                }
            case SocketIO.AF_INET:
            case SocketIO.AF_INET6:
                switch (type) {
                    case SocketIO.SOCK_STREAM:
                        fd = getMinFd();
                        fdMap.put(fd, new TcpSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_DGRAM:
                        fd = getMinFd();
                        fdMap.put(fd, new UdpSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_RAW:
                        throw new UnsupportedOperationException();
                }
                break;
            case SocketIO.AF_NETLINK:
                switch (type) {
                    case SocketIO.SOCK_DGRAM:
                        fd = getMinFd();
                        fdMap.put(fd, new NetLinkSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_RAW:
                    default:
                        throw new UnsupportedOperationException();
                }
        }
        log.info("socket domain={}, type={}, protocol={}", domain, type, protocol);
        emulator.getMemory().setErrno(UnixEmulator.EAFNOSUPPORT);
        return -1;
    }
    private int getgroups(Backend backend, Emulator<?> emulator) {
        int size = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer list = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        if (log.isDebugEnabled()) {
            log.debug("getgroups size={}, list={}", size, list);
        }
        return 0;
    }
    protected int uname(Emulator<?> emulator) {
        Pointer buf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        if (log.isDebugEnabled()) {
            log.debug("uname buf={}", buf);
        }
        final int SYS_NMLN = 65;
        Pointer sysname = buf.share(0);
        sysname.setString(0, "Linux");
        Pointer nodename = sysname.share(SYS_NMLN);
        nodename.setString(0, "localhost");
        Pointer release = nodename.share(SYS_NMLN);
        release.setString(0, "1.0.0-unidbg");
        Pointer version = release.share(SYS_NMLN);
        version.setString(0, "#1 SMP PREEMPT Thu Apr 19 14:36:58 CST 2018");
        Pointer machine = version.share(SYS_NMLN);
        machine.setString(0, "armv7l");
        Pointer domainname = machine.share(SYS_NMLN);
        domainname.setString(0, "localdomain");
        return 0;
    }
    private void exit_group(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int status = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("exit with code: {}", status, new Exception("exit_group status=" + status));
        } else {
            System.out.println("exit with code: " + status);
        }
        if (LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        emulator.getBackend().emu_stop();
    }
    private int munmap(Backend backend, Emulator<?> emulator) {
        long timeInMillis = System.currentTimeMillis();
        long start = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue() & 0xffffffffL;
        int length = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (start % emulator.getPageAlign() != 0) {
            emulator.getMemory().setErrno(UnixEmulator.EINVAL);
            return -1;
        }
        emulator.getMemory().munmap(start, length);
        if (log.isDebugEnabled()) {
            log.debug("munmap start=0x{}, length={}, offset={}, from={}", Long.toHexString(start), length, System.currentTimeMillis() - timeInMillis, UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
        }
        return 0;
    }
    private static final int PR_GET_DUMPABLE = 3;
    private static final int PR_SET_DUMPABLE = 4;
    private static final int PR_SET_NAME = 15;
    private static final int PR_GET_NAME = 16;
    private static final int BIONIC_PR_SET_VMA = 0x53564d41;
    private static final int PR_SET_PTRACER = 0x59616d61;
    private int prctl(Backend backend, Emulator<?> emulator) {
        int option = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        long arg2 = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue() & 0xffffffffL;
        if (log.isDebugEnabled()) {
            log.debug("prctl option=0x{}, arg2=0x{}", Integer.toHexString(option), Long.toHexString(arg2));
        }
        switch (option) {
            case PR_GET_DUMPABLE:
            case PR_SET_DUMPABLE:
                return 0;
            case PR_SET_NAME: {
                Pointer threadName = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
                String name = threadName.getString(0);
                if (log.isDebugEnabled()) {
                    log.debug("prctl set thread name: {}", name);
                }
                return 0;
            }
            case PR_GET_NAME: {
                String name = java.lang.Thread.currentThread().getName();
                if (name.length() > 15) {
                    name = name.substring(0, 15);
                }
                if (log.isDebugEnabled()) {
                    log.debug("prctl get thread name: {}", name);
                }
                Pointer buffer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
                buffer.setString(0, name);
                return 0;
            }
            case BIONIC_PR_SET_VMA:
                Pointer addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
                int len = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
                Pointer pointer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R4);
                if (log.isDebugEnabled()) {
                    log.debug("prctl set vma addr={}, len={}, pointer={}, name={}", addr, len, pointer, pointer.getString(0));
                }
                return 0;
            case PR_SET_PTRACER:
                int pid = (int) arg2;
                if (log.isDebugEnabled()) {
                    log.debug("prctl set ptracer: {}", pid);
                }
                return 0;
        }
        throw new UnsupportedOperationException("option=" + option);
    }
    private static final int CLOCK_REALTIME = 0;
    private static final int CLOCK_MONOTONIC = 1;
    private static final int CLOCK_THREAD_CPUTIME_ID = 3;
    private static final int CLOCK_MONOTONIC_RAW = 4;
    private static final int CLOCK_MONOTONIC_COARSE = 6;
    private static final int CLOCK_BOOTTIME = 7;
    private final long nanoTime = System.nanoTime();
    protected int clock_gettime(Backend backend, Emulator<?> emulator) {
        int clk_id = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer tp = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        long offset = clk_id == CLOCK_REALTIME ? System.currentTimeMillis() * 1000000L : System.nanoTime() - nanoTime;
        long tv_sec = offset / 1000000000L;
        long tv_nsec = offset % 1000000000L;
        if (log.isDebugEnabled()) {
            log.debug("clock_gettime clk_id={}, tp={}, offset={}, tv_sec={}, tv_nsec={}", clk_id, tp, offset, tv_sec, tv_nsec);
        }
        switch (clk_id) {
            case CLOCK_REALTIME:
            case CLOCK_MONOTONIC:
            case CLOCK_MONOTONIC_RAW:
            case CLOCK_MONOTONIC_COARSE:
            case CLOCK_BOOTTIME:
                tp.setInt(0, (int) tv_sec);
                tp.setInt(4, (int) tv_nsec);
                return 0;
            case CLOCK_THREAD_CPUTIME_ID:
                tp.setInt(0, 0);
                tp.setInt(4, 1);
                return 0;
        }
        throw new UnsupportedOperationException("clk_id=" + clk_id);
    }
    private int fcntl(Backend backend, Emulator<?> emulator) {
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int cmd = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int arg = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        return fcntl(emulator, fd, cmd, arg);
    }
    private int writev(Backend backend, Emulator<?> emulator) {
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer iov = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int iovcnt = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        if (log.isDebugEnabled()) {
            for (int i = 0; i < iovcnt; i++) {
                Pointer iov_base = iov.getPointer(i * 8L);
                int iov_len = iov.getInt(i * 8L + 4);
                byte[] data = iov_base.getByteArray(0, iov_len);
                Inspector.inspect(data, "writev fd=" + fd + ", iov=" + iov + ", iov_base=" + iov_base);
            }
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int count = 0;
        for (int i = 0; i < iovcnt; i++) {
            Pointer iov_base = iov.getPointer(i * 8L);
            int iov_len = iov.getInt(i * 8L + 4);
            byte[] data = iov_base.getByteArray(0, iov_len);
            count += file.write(data);
        }
        return count;
    }
    private int brk(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        long address = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue() & 0xffffffffL;
        if (log.isDebugEnabled()) {
            log.debug("brk address=0x{}", Long.toHexString(address));
        }
        return emulator.getMemory().brk(address);
    }
    private int mprotect(Backend backend, Emulator<?> emulator) {
        long address = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue() & 0xffffffffL;
        int length = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int prot = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        long alignedAddress = address / ARMEmulator.PAGE_ALIGN * ARMEmulator.PAGE_ALIGN; 
        long offset = address - alignedAddress;
        long alignedLength = ARM.alignSize(length + offset, emulator.getPageAlign());
        if (log.isDebugEnabled()) {
            log.debug("mprotect address=0x{}, alignedAddress=0x{}, offset={}, length={}, alignedLength={}, prot=0x{}", Long.toHexString(address), Long.toHexString(alignedAddress), offset, length, alignedLength, Integer.toHexString(prot));
        }
        return emulator.getMemory().mprotect(alignedAddress, (int) alignedLength, prot);
    }
    private static final int MMAP2_SHIFT = 12;
    private int mmap2(Backend backend, Emulator<?> emulator) {
        long start = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue() & 0xffffffffL;
        int length = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int prot = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
        int offset = backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue() << MMAP2_SHIFT;
        boolean warning = length >= 0x10000000;
        if (log.isDebugEnabled() || warning) {
            String msg = "mmap2 start=0x" + Long.toHexString(start) + ", length=" + length + ", prot=0x" + Integer.toHexString(prot) + ", flags=0x" + Integer.toHexString(flags) + ", fd=" + fd + ", offset=" + offset + ", from=" + UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR);
            if (warning) {
                log.warn(msg);
                if (log.isDebugEnabled()) {
                    emulator.attach().debug();
                }
            } else {
                log.debug(msg);
            }
        }
        return (int) emulator.getMemory().mmap2(start, length, prot, flags, fd, offset);
    }
    private int gettimeofday(Emulator<?> emulator) {
        Pointer tv = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        Pointer tz = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        return gettimeofday(emulator, tv, tz);
    }
    private int faccessat(Backend backend, Emulator<AndroidFileIO> emulator) {
        int dirfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer pathname_p = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int oflags = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int mode = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        String pathname = pathname_p.getString(0);
        String msg = "faccessat dirfd=" + dirfd + ", pathname=" + pathname + ", oflags=0x" + Integer.toHexString(oflags) + ", mode=0x" + Integer.toHexString(mode);
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
        int ret = faccessat(emulator, pathname);
        if (ret == -1) {
            log.info(msg);
        }
        return ret;
    }
    private int faccessat(Emulator<AndroidFileIO> emulator, String pathname) {
        FileResult<?> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            return 0;
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.EACCES);
        return -1;
    }
    private int fstatat64(Backend backend, Emulator<AndroidFileIO> emulator) {
        int dirfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer pathname = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        Pointer statbuf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        String path = FilenameUtils.normalize(pathname.getString(0), true);
        if (log.isDebugEnabled()) {
            log.debug("fstatat64 dirfd={}, pathname={}, statbuf={}, flags={}", dirfd, path, statbuf, flags);
        }
        if (dirfd != IO.AT_FDCWD && !path.startsWith("/")) {
            throw new BackendException();
        }
        return stat64(emulator, path, statbuf);
    }
    private int openat(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname_p = context.getPointerArg(1);
        int oflags = context.getIntArg(2);
        int mode = context.getIntArg(3);
        String pathname = pathname_p.getString(0);
        log.debug("openat dirfd={}, pathname={}, oflags=0x{}, mode={}", dirfd, pathname, Integer.toHexString(oflags), Integer.toHexString(mode));
        pathname = FilenameUtils.normalize(pathname, true);
        if ("/data/misc/zoneinfo/current/tzdata".equals(pathname) || "/dev/pmsg0".equals(pathname)) {
            emulator.getMemory().setErrno(UnixEmulator.ENOENT);
            return -UnixEmulator.ENOENT;
        }
        if (pathname.startsWith("/")) {
            int fd = open(emulator, pathname, oflags);
            if (fd == -1) {
                log.info("openat dirfd={}, pathname={}, oflags=0x{}, mode={}", dirfd, pathname, Integer.toHexString(oflags), Integer.toHexString(mode));
                return -emulator.getMemory().getLastErrno();
            } else {
                return fd;
            }
        } else {
            if (dirfd != IO.AT_FDCWD) {
                throw new BackendException();
            }
            int fd = open(emulator, pathname, oflags);
            if (fd == -1) {
                log.info("openat AT_FDCWD dirfd={}, pathname={}, oflags=0x{}, mode={}", dirfd, pathname, Integer.toHexString(oflags), Integer.toHexString(mode));
                return -emulator.getMemory().getLastErrno();
            } else {
                return fd;
            }
        }
    }
    private int open(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname_p = context.getPointerArg(0);
        int oflags = context.getIntArg(1);
        int mode = context.getIntArg(2);
        String pathname = pathname_p.getString(0);
        String msg = "open pathname=" + pathname + ", oflags=0x" + Integer.toHexString(oflags) + ", mode=" + Integer.toHexString(mode) + ", from=" + UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR);
        if (log.isDebugEnabled()) {
            log.debug(msg);
        }
        int fd = open(emulator, pathname, oflags);
        if (fd == -1) {
            log.info(msg);
            return -emulator.getMemory().getLastErrno();
        } else {
            return fd;
        }
    }
    private int ftruncate(Backend backend) {
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int length = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (log.isDebugEnabled()) {
            log.debug("ftruncate fd={}, length={}", fd, length);
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            throw new UnsupportedOperationException();
        }
        return file.ftruncate(length);
    }
    private int lseek(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int offset = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int whence = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int pos = file.lseek(offset, whence);
        if (log.isDebugEnabled()) {
            log.debug("lseek fd={}, offset={}, whence={}, pos={}, from={}", fd, offset, whence, pos, UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
        }
        return pos;
    }
    private int close(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        if (log.isDebugEnabled()) {
            log.debug("close fd={}", fd);
        }
        return close(emulator, fd);
    }
    private int getdents64(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        UnidbgPointer dirp = context.getPointerArg(1);
        int size = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("getdents64 fd={}, dirp={}, size={}", fd, dirp, size);
        }
        AndroidFileIO io = fdMap.get(fd);
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        } else {
            dirp.setSize(size);
            return io.getdents64(dirp, size);
        }
    }
    private int fstat(Backend backend, Emulator<?> emulator) {
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer stat = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        return fstat(emulator, fd, stat);
    }
    protected int fstat(Emulator<?> emulator, int fd, Pointer stat) {
        AndroidFileIO file = fdMap.get(fd);
        if (file == null) {
            if (log.isDebugEnabled()) {
                log.debug("fstat fd={}, stat={}, errno=" + UnixEmulator.EBADF, fd, stat);
            }
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (log.isDebugEnabled()) {
            log.debug("fstat file={}, stat={}, from={}", file, stat, emulator.getContext().getLRPointer());
        }
        return file.fstat(emulator, new Stat32(stat));
    }
    private int ioctl(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        long request = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue() & 0xffffffffL;
        long argp = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue() & 0xffffffffL;
        if (log.isDebugEnabled()) {
            log.debug("ioctl fd={}, request=0x{}, argp=0x{}", fd, Long.toHexString(request), Long.toHexString(argp));
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int ret = file.ioctl(emulator, request, argp);
        if (ret == -1) {
            emulator.getMemory().setErrno(UnixEmulator.ENOTTY);
        }
        return ret;
    }
    private int write(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buffer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int count = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        return write(emulator, fd, buffer, count);
    }
    private int read(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buffer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int count = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        return read(emulator, fd, buffer, count);
    }
    private int pread64(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer buffer = context.getPointerArg(1);
        int count = context.getIntArg(2);
        long offset = context.getIntByReg(ArmConst.UC_ARM_REG_R4) | ((long) context.getIntByReg(ArmConst.UC_ARM_REG_R5) << 32L);
        return pread(emulator, fd, buffer, count, offset);
    }
    private int dup2(Backend backend, Emulator<?> emulator) {
        int oldfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int newfd = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (log.isDebugEnabled()) {
            log.debug("dup2 oldfd={}, newfd={}", oldfd, newfd);
        }
        FileIO old = fdMap.get(oldfd);
        if (old == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (oldfd == newfd) {
            return newfd;
        }
        AndroidFileIO _new = fdMap.remove(newfd);
        if (_new != null) {
            _new.close();
        }
        _new = (AndroidFileIO) old.dup2();
        fdMap.put(newfd, _new);
        return newfd;
    }
    private int dup3(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int oldfd = context.getIntArg(0);
        int newfd = context.getIntArg(1);
        int flags = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("dup3 oldfd={}, newfd={}, flags=0x{}", oldfd, newfd, Integer.toHexString(flags));
        }
        FileIO old = fdMap.get(oldfd);
        if (old == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (oldfd == newfd) {
            return newfd;
        }
        AndroidFileIO _new = fdMap.remove(newfd);
        if (_new != null) {
            _new.close();
        }
        _new = (AndroidFileIO) old.dup2();
        fdMap.put(newfd, _new);
        return newfd;
    }
    @Override
    protected AndroidFileIO createByteArrayFileIO(String pathname, int oflags, byte[] data) {
        return new ByteArrayFileIO(oflags, pathname, data);
    }
    @Override
    protected AndroidFileIO createDriverFileIO(Emulator<?> emulator, int oflags, String pathname) {
        return DriverFileIO.create(emulator, oflags, pathname);
    }
}
package com.github.unidbg.unix;
import com.github.unidbg.Emulator;
import com.github.unidbg.Family;
import com.github.unidbg.Module;
import com.github.unidbg.arm.backend.UnHook;
import com.github.unidbg.debugger.Breaker;
import com.github.unidbg.file.FileIO;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.IOResolver;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.memory.MemRegion;
import com.github.unidbg.spi.SyscallHandler;
import com.github.unidbg.thread.MainTask;
import com.github.unidbg.unix.struct.TimeVal32;
import com.github.unidbg.unix.struct.TimeVal64;
import com.github.unidbg.unix.struct.TimeZone;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.DataOutput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public abstract class UnixSyscallHandler<T extends NewFileIO> implements SyscallHandler<T> {
    private static final Logger log = LoggerFactory.getLogger(UnixSyscallHandler.class);
    private final List<IOResolver<T>> resolvers = new ArrayList<>(5);
    protected final Map<Integer, T> fdMap = new TreeMap<>();
    @Override
    public FileIO getFileIO(int fd) {
        return fdMap.get(fd);
    }
    @Override
    public void closeFileIO(int fd) {
        FileIO io = fdMap.remove(fd);
        if (io != null) {
            io.close();
        }
    }
    protected boolean verbose;
    @Override
    public void setVerbose(boolean verbose) {
        this.verbose = verbose;
    }
    private FileListener fileListener;
    public void setFileListener(FileListener fileListener) {
        this.fileListener = fileListener;
    }
    @Override
    public boolean isVerbose() {
        return verbose;
    }
    private Breaker breaker;
    @Override
    public void setBreaker(Breaker breaker) {
        this.breaker = breaker;
    }
    protected final Breaker createBreaker(Emulator<?> emulator) {
        return breaker != null ? breaker : emulator.attach();
    }
    protected int getMinFd() {
        int last_fd = -1;
        for (int fd : fdMap.keySet()) {
            if (last_fd + 1 == fd) {
                last_fd = fd;
            } else {
                break;
            }
        }
        return last_fd + 1;
    }
    @Override
    public int addFileIO(T io) {
        int fd = getMinFd();
        fdMap.put(fd, io);
        return fd;
    }
    @Override
    public void addIOResolver(IOResolver<T> resolver) {
        if (!resolvers.contains(resolver)) {
            resolvers.add(0, resolver);
        }
    }
    protected final FileResult<T> resolve(Emulator<T> emulator, String pathname, int oflags) {
        FileResult<T> failResult = null;
        for (IOResolver<T> resolver : resolvers) {
            FileResult<T> result = resolver.resolve(emulator, pathname, oflags);
            if (result != null && result.isSuccess()) {
                emulator.getMemory().setErrno(0);
                return result;
            } else if (result != null) {
                if (failResult == null || !failResult.isFallback()) {
                    failResult = result;
                }
            }
        }
        if (failResult != null && !failResult.isFallback()) {
            return failResult;
        }
        FileResult<T> result = emulator.getFileSystem().open(pathname, oflags);
        if (result != null && result.isSuccess()) {
            emulator.getMemory().setErrno(0);
            return result;
        } else if (failResult == null) {
            failResult = result;
        }
        Family family = emulator.getFamily();
        if (pathname.endsWith(family.getLibraryExtension())) {
            for (Module module : emulator.getMemory().getLoadedModules()) {
                for (MemRegion memRegion : module.getRegions()) {
                    if (pathname.equals(memRegion.getName())) {
                        try {
                            emulator.getMemory().setErrno(0);
                            return FileResult.success(createByteArrayFileIO(pathname, oflags, memRegion.readLibrary()));
                        } catch (IOException e) {
                            throw new IllegalStateException(e);
                        }
                    }
                }
            }
        }
        if (failResult != null && failResult.isFallback()) {
            return FileResult.success(failResult.io);
        }
        if (pathname.startsWith("/proc/" + emulator.getPid() + "/fd/") || pathname.startsWith("/proc/self/fd/")) {
            int fd = Integer.parseInt(pathname.substring(pathname.lastIndexOf("/") + 1));
            T file = fdMap.get(fd);
            if (file != null) {
                return FileResult.success(file);
            }
        }
        if (("/proc/" + emulator.getPid() + "/fd").equals(pathname) || "/proc/self/fd".equals(pathname)) {
            return createFdDir(oflags, pathname);
        }
        if (("/proc/" + emulator.getPid() + "/task/").equals(pathname) || "/proc/self/task/".equals(pathname)) {
            return createTaskDir(emulator, oflags, pathname);
        }
        return failResult;
    }
    protected FileResult<T> createTaskDir(Emulator<T> emulator, int oflags, String pathname) {
        throw new UnsupportedOperationException(pathname);
    }
    protected FileResult<T> createFdDir(int oflags, String pathname) {
        throw new UnsupportedOperationException(pathname);
    }
    protected abstract T createByteArrayFileIO(String pathname, int oflags, byte[] data);
    protected long currentTimeMillis() {
        return System.currentTimeMillis();
    }
    @SuppressWarnings("unused")
    protected int gettimeofday(Emulator<?> emulator, Pointer tv, Pointer tz) {
        if (log.isDebugEnabled()) {
            log.debug("gettimeofday tv={}, tz={}", tv, tz);
        }
        if (log.isDebugEnabled()) {
            byte[] before = tv.getByteArray(0, 8);
            Inspector.inspect(before, "gettimeofday tv=" + tv);
        }
        if (tz != null && log.isDebugEnabled()) {
            byte[] before = tz.getByteArray(0, 8);
            Inspector.inspect(before, "gettimeofday tz");
        }
        long currentTimeMillis = currentTimeMillis();
        long tv_sec = currentTimeMillis / 1000;
        long tv_usec = (currentTimeMillis % 1000) * 1000;
        TimeVal32 timeVal = new TimeVal32(tv);
        timeVal.tv_sec = (int) tv_sec;
        timeVal.tv_usec = (int) tv_usec;
        timeVal.pack();
        if (tz != null) {
            Calendar calendar = Calendar.getInstance();
            int tz_minuteswest = -(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 1000);
            TimeZone timeZone = new TimeZone(tz);
            timeZone.tz_minuteswest = tz_minuteswest;
            timeZone.tz_dsttime = 0;
            timeZone.pack();
        }
        if (log.isDebugEnabled()) {
            byte[] after = tv.getByteArray(0, 8);
            Inspector.inspect(after, "gettimeofday tv after tv_sec=" + tv_sec + ", tv_usec=" + tv_usec + ", tv=" + tv);
        }
        if (tz != null && log.isDebugEnabled()) {
            byte[] after = tz.getByteArray(0, 8);
            Inspector.inspect(after, "gettimeofday tz after");
        }
        return 0;
    }
    protected int gettimeofday64(Pointer tv, Pointer tz) {
        if (log.isDebugEnabled()) {
            log.debug("gettimeofday64 tv={}, tz={}", tv, tz);
        }
        if (log.isDebugEnabled()) {
            byte[] before = tv.getByteArray(0, 8);
            Inspector.inspect(before, "gettimeofday tv=" + tv);
        }
        if (tz != null && log.isDebugEnabled()) {
            byte[] before = tz.getByteArray(0, 8);
            Inspector.inspect(before, "gettimeofday tz");
        }
        long currentTimeMillis = currentTimeMillis();
        long tv_sec = currentTimeMillis / 1000;
        long tv_usec = (currentTimeMillis % 1000) * 1000;
        TimeVal64 timeVal = new TimeVal64(tv);
        timeVal.tv_sec = tv_sec;
        timeVal.tv_usec = tv_usec;
        timeVal.pack();
        if (tz != null) {
            Calendar calendar = Calendar.getInstance();
            int tz_minuteswest = -(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 1000);
            TimeZone timeZone = new TimeZone(tz);
            timeZone.tz_minuteswest = tz_minuteswest;
            timeZone.tz_dsttime = 0;
            timeZone.pack();
        }
        if (log.isDebugEnabled()) {
            byte[] after = tv.getByteArray(0, 8);
            Inspector.inspect(after, "gettimeofday tv after tv_sec=" + tv_sec + ", tv_usec=" + tv_usec + ", tv=" + tv);
        }
        if (tz != null && log.isDebugEnabled()) {
            byte[] after = tz.getByteArray(0, 8);
            Inspector.inspect(after, "gettimeofday tz after");
        }
        return 0;
    }
    protected int sigprocmask(Emulator<?> emulator, int how, Pointer set, Pointer oldset) {
        if (log.isDebugEnabled()) {
            log.debug("sigprocmask how={}, set={}, oldset={}", how, set, oldset);
        }
        emulator.getMemory().setErrno(UnixEmulator.EINVAL);
        return -1;
    }
    protected final int read(Emulator<?> emulator, int fd, Pointer buffer, int count) {
        if (log.isDebugEnabled()) {
            log.debug("read fd={}, buffer={}, count={}, from={}", fd, buffer, count, emulator.getContext().getLRPointer());
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int read = file.read(emulator.getBackend(), buffer, count);
        if (verbose && !file.isStdIO()) {
            System.out.printf("Read %d bytes from '%s'%n", read, file);
        }
        if (fileListener != null) {
            byte[] bytes;
            if (read <= 0) {
                bytes = new byte[0];
            } else {
                bytes = buffer.getByteArray(0, read);
            }
            fileListener.onRead(emulator, String.valueOf(file), bytes);
        }
        return read;
    }
    protected final int pread(Emulator<?> emulator, int fd, Pointer buffer, int count, long offset) {
        if (log.isDebugEnabled()) {
            log.debug("pread fd={}, buffer={}, count={}, offset={}, from={}", fd, buffer, count, offset, emulator.getContext().getLRPointer());
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int read = file.pread(emulator.getBackend(), buffer, count, offset);
        if (verbose) {
            System.out.printf("PRead %d bytes with offset %d from '%s'%n", read, offset, file);
        }
        return read;
    }
    protected final int close(Emulator<?> emulator, int fd) {
        FileIO file = fdMap.remove(fd);
        if (file != null) {
            file.close();
            if (verbose) {
                System.out.printf("File closed '%s' from %s%n", file, emulator.getContext().getLRPointer());
            }
            if (fileListener != null) {
                fileListener.onClose(emulator, file);
            }
            return 0;
        } else {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
    }
    @Override
    public final int open(Emulator<T> emulator, String pathname, int oflags) {
        int minFd = this.getMinFd();
        FileResult<T> resolveResult = resolve(emulator, pathname, oflags);
        if (resolveResult != null && resolveResult.isSuccess()) {
            emulator.getMemory().setErrno(0);
            this.fdMap.put(minFd, resolveResult.io);
            if (verbose) {
                System.out.printf("File opened '%s' with oflags=0x%x from %s%n", resolveResult.io, oflags, emulator.getContext().getLRPointer());
            }
            if (fileListener != null) {
                fileListener.onOpenSuccess(emulator, pathname, resolveResult.io);
            }
            return minFd;
        }
        T driverIO = createDriverFileIO(emulator, oflags, pathname);
        if (driverIO != null) {
            emulator.getMemory().setErrno(0);
            this.fdMap.put(minFd, driverIO);
            if (verbose) {
                System.out.printf("File opened '%s' with oflags=0x%x from %s%n", driverIO, oflags, emulator.getContext().getLRPointer());
            }
            if (fileListener != null) {
                fileListener.onOpenSuccess(emulator, pathname, driverIO);
            }
            return minFd;
        }
        FileResult<T> result = null;
        if (resolveResult != null) {
            result = resolveResult;
        }
        int errno = result != null ? result.errno : UnixEmulator.ENOENT;
        emulator.getMemory().setErrno(errno);
        if (verbose) {
            System.out.printf("File opened '%s' with oflags=0x%x errno is %d from %s%n", pathname, oflags, errno, emulator.getContext().getLRPointer());
        }
        return -1;
    }
    protected abstract T createDriverFileIO(Emulator<?> emulator, int oflags, String pathname);
    protected int fcntl(Emulator<?> emulator, int fd, int cmd, long arg) {
        if (log.isDebugEnabled()) {
            log.debug("fcntl fd={}, cmd={}, arg={}", fd, cmd, arg);
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.fcntl(emulator, cmd, arg);
    }
    private static final Pattern FD_PATTERN = Pattern.compile("/proc/self/fd/(\\d+)");
    protected int readlink(Emulator<?> emulator, String path, Pointer buf, int bufSize) {
        if (log.isDebugEnabled()) {
            log.debug("readlink path={}, buf={}, bufSize={}", path, buf, bufSize);
        }
        Matcher matcher = FD_PATTERN.matcher(path);
        if (matcher.find()) {
            int fd = Integer.parseInt(matcher.group(1));
            FileIO io = fdMap.get(fd);
            if (io != null) {
                path = io.getPath();
            }
        }
        buf.setString(0, path);
        return path.length() + 1;
    }
    private final Map<Integer, byte[]> sigMap = new HashMap<>();
    private static final int SIGHUP = 1;
    private static final int SIGINT = 2;
    private static final int SIGQUIT = 3;
    private static final int SIGILL = 4;
    private static final int SIGTRAP = 5; 
    private static final int SIGABRT = 6;
    protected static final int SIGBUS = 7; 
    private static final int SIGFPE = 8; 
    private static final int SIGUSR1 = 10;
    private static final int SIGSEGV = 11;
    private static final int SIGUSR2 = 12;
    private static final int SIGPIPE = 13;
    private static final int SIGALRM = 14;
    private static final int SIGTERM = 15;
    protected static final int SIGCHLD = 17;
    private static final int SIGCONT = 18;
    private static final int SIGTSTP = 20;
    private static final int SIGTTIN = 21;
    private static final int SIGTTOU = 22;
    private static final int SIGWINCH = 28;
    private static final int SIGSYS = 31; 
    private static final int SIGRTMIN = 32;
    protected int sigaction(Emulator<?> emulator, int signum, Pointer act, Pointer oldact) {
        final int ACT_SIZE = 16;
        return sigaction(emulator, signum, act, oldact, ACT_SIZE);
    }
    protected final int sigaction(Emulator<?> emulator, int signum, Pointer act, Pointer oldact, int sizeOfSigAction) {
        String prefix = "Unknown";
        if (signum > 32) {
            signum -= 32;
            prefix = "Real-time";
        }
        if (log.isDebugEnabled()) {
            log.debug("sigaction signum={}, act={}, oldact={}, prefix={}", signum, act, oldact, prefix);
        }
        if (oldact != null) {
            byte[] lastAct = sigMap.get(signum);
            byte[] data = lastAct == null ? new byte[sizeOfSigAction] : lastAct;
            oldact.write(0, data, 0, data.length);
        }
        switch (signum) {
            case SIGHUP:
            case SIGINT:
            case SIGQUIT:
            case SIGILL:
            case SIGTRAP:
            case SIGABRT:
            case SIGBUS:
            case SIGFPE:
            case SIGUSR1:
            case SIGSEGV:
            case SIGUSR2:
            case SIGPIPE:
            case SIGALRM:
            case SIGTERM:
            case SIGCHLD:
            case SIGCONT:
            case SIGTSTP:
            case SIGTTIN:
            case SIGTTOU:
            case SIGWINCH:
            case SIGSYS:
            case SIGRTMIN:
                if (act != null) {
                    sigMap.put(signum, act.getByteArray(0, sizeOfSigAction));
                }
                return 0;
        }
        createBreaker(emulator).debug();
        throw new UnsupportedOperationException("signum=" + signum);
    }
    protected final int bind(Emulator<?> emulator, int sockfd, Pointer addr, int addrlen) {
        if (log.isDebugEnabled()) {
            byte[] data = addr.getByteArray(0, addrlen);
            Inspector.inspect(data, "bind sockfd=" + sockfd + ", addr=" + addr + ", addrlen=" + addrlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.bind(addr, addrlen);
    }
    protected final int listen(Emulator<?> emulator, int sockfd, int backlog) {
        if (log.isDebugEnabled()) {
            log.debug("listen sockfd={}, backlog={}", sockfd, backlog);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.listen(backlog);
    }
    protected final int connect(Emulator<?> emulator, int sockfd, Pointer addr, int addrlen) {
        if (log.isDebugEnabled()) {
            byte[] data = addr.getByteArray(0, addrlen);
            Inspector.inspect(data, "connect sockfd=" + sockfd + ", addr=" + addr + ", addrlen=" + addrlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.connect(addr, addrlen);
    }
    protected final int sendto(Emulator<?> emulator, int sockfd, Pointer buf, int len, int flags, Pointer dest_addr, int addrlen) {
        byte[] data = buf.getByteArray(0, len);
        if (log.isDebugEnabled()) {
            Inspector.inspect(data, "sendto sockfd=" + sockfd + ", buf=" + buf + ", flags=" + flags + ", dest_addr=" + dest_addr + ", addrlen=" + addrlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.sendto(data, flags, dest_addr, addrlen);
    }
    protected final int write(Emulator<?> emulator, int fd, Pointer buffer, int count) {
        byte[] data = buffer.getByteArray(0, count);
        if (log.isDebugEnabled()) {
            Inspector.inspect(data, "write fd=" + fd + ", buffer=" + buffer + ", count=" + count);
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int write = file.write(data);
        if (verbose && !file.isStdIO()) {
            System.out.printf("Write %d bytes to '%s'%n", write, file);
        }
        if (fileListener != null) {
            byte[] bytes;
            if (write <= 0) {
                bytes = new byte[0];
            } else {
                bytes = Arrays.copyOf(data, write);
            }
            fileListener.onWrite(emulator, String.valueOf(file), bytes);
        }
        return write;
    }
    protected int getrandom(Pointer buf, int bufSize, int flags) {
        Random random = new Random();
        byte[] bytes = new byte[bufSize];
        random.nextBytes(bytes);
        buf.write(0, bytes, 0, bytes.length);
        if (log.isDebugEnabled()) {
            log.debug(Inspector.inspectString(bytes, "getrandom buf=" + buf + ", bufSize=" + bufSize + ", flags=0x" + Integer.toHexString(flags)));
        }
        return bufSize;
    }
    @SuppressWarnings("unused")
    protected boolean handleSyscall(Emulator<?> emulator, int NR) {
        return false;
    }
    protected boolean handleUnknownSyscall(Emulator<?> emulator, int NR) {
        return false;
    }
    @Override
    public void serialize(DataOutput out) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void onAttach(UnHook unHook) {
    }
    @Override
    public void detach() {
        throw new UnsupportedOperationException();
    }
    @Override
    public void destroy() {
        for (FileIO io : fdMap.values()) {
            io.close();
        }
    }
    protected boolean threadDispatcherEnabled;
    @Override
    public void setEnableThreadDispatcher(boolean threadDispatcherEnabled) {
        this.threadDispatcherEnabled = threadDispatcherEnabled;
    }
    @Override
    public MainTask createSignalHandlerTask(Emulator<?> emulator, int sig) {
        return null;
    }
}
package com.github.unidbg.ios;
import com.github.unidbg.AbstractEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.LongJumpException;
import com.github.unidbg.StopEmulatorException;
import com.github.unidbg.Svc;
import com.github.unidbg.arm.ARM;
import com.github.unidbg.arm.ARMEmulator;
import com.github.unidbg.arm.Arm64Svc;
import com.github.unidbg.arm.Cpsr;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BackendException;
import com.github.unidbg.arm.context.Arm64RegisterContext;
import com.github.unidbg.arm.context.EditableArm64RegisterContext;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.file.FileIO;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.ios.DarwinFileIO;
import com.github.unidbg.file.ios.IOConstants;
import com.github.unidbg.ios.file.ByteArrayFileIO;
import com.github.unidbg.ios.file.DriverFileIO;
import com.github.unidbg.ios.file.LocalDarwinUdpSocket;
import com.github.unidbg.ios.file.SocketIO;
import com.github.unidbg.ios.file.TcpSocket;
import com.github.unidbg.ios.file.UdpSocket;
import com.github.unidbg.ios.struct.attr.AttrList;
import com.github.unidbg.ios.struct.kernel.AslServerMessageRequest;
import com.github.unidbg.ios.struct.kernel.ClockGetTimeReply;
import com.github.unidbg.ios.struct.kernel.DyldCacheHeader;
import com.github.unidbg.ios.struct.kernel.HostGetClockServiceReply;
import com.github.unidbg.ios.struct.kernel.HostGetClockServiceRequest;
import com.github.unidbg.ios.struct.kernel.HostInfoReply;
import com.github.unidbg.ios.struct.kernel.HostInfoRequest;
import com.github.unidbg.ios.struct.kernel.IOServiceAddNotificationRequest;
import com.github.unidbg.ios.struct.kernel.IOServiceGetMatchingServiceRequest;
import com.github.unidbg.ios.struct.kernel.MachMsgHeader;
import com.github.unidbg.ios.struct.kernel.MachPortOptions;
import com.github.unidbg.ios.struct.kernel.MachPortReply;
import com.github.unidbg.ios.struct.kernel.MachPortSetAttributesReply;
import com.github.unidbg.ios.struct.kernel.MachPortSetAttributesRequest;
import com.github.unidbg.ios.struct.kernel.MachPortTypeReply;
import com.github.unidbg.ios.struct.kernel.MachPortTypeRequest;
import com.github.unidbg.ios.struct.kernel.MachPortsLookupReply64;
import com.github.unidbg.ios.struct.kernel.MachTimebaseInfo;
import com.github.unidbg.ios.struct.kernel.MachVmMapReply;
import com.github.unidbg.ios.struct.kernel.MachVmMapRequest;
import com.github.unidbg.ios.struct.kernel.MakeMemoryEntryReply;
import com.github.unidbg.ios.struct.kernel.MakeMemoryEntryRequest;
import com.github.unidbg.ios.struct.kernel.NotifyServerCancelReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerCancelRequest;
import com.github.unidbg.ios.struct.kernel.NotifyServerGetStateReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerGetStateRequest;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterCheck64Request;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterCheckReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterMachPort64Request;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterMachPortReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterPlain64Request;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterPlainReply;
import com.github.unidbg.ios.struct.kernel.ProcBsdShortInfo;
import com.github.unidbg.ios.struct.kernel.Pthread;
import com.github.unidbg.ios.struct.kernel.Pthread64;
import com.github.unidbg.ios.struct.kernel.PurgableControlReply;
import com.github.unidbg.ios.struct.kernel.PurgableControlRequest;
import com.github.unidbg.ios.struct.kernel.RLimit;
import com.github.unidbg.ios.struct.kernel.RUsage64;
import com.github.unidbg.ios.struct.kernel.SemaphoreCreateReply;
import com.github.unidbg.ios.struct.kernel.SemaphoreCreateRequest;
import com.github.unidbg.ios.struct.kernel.Stat64;
import com.github.unidbg.ios.struct.kernel.StatFS;
import com.github.unidbg.ios.struct.kernel.TaskBasicInfoReply64V2;
import com.github.unidbg.ios.struct.kernel.TaskDyldInfoReply;
import com.github.unidbg.ios.struct.kernel.TaskGetExceptionPortsReply;
import com.github.unidbg.ios.struct.kernel.TaskGetExceptionPortsRequest;
import com.github.unidbg.ios.struct.kernel.TaskGetSpecialPortReply;
import com.github.unidbg.ios.struct.kernel.TaskGetSpecialPortRequest;
import com.github.unidbg.ios.struct.kernel.TaskInfoRequest;
import com.github.unidbg.ios.struct.kernel.TaskSetExceptionPortsReply;
import com.github.unidbg.ios.struct.kernel.TaskSetExceptionPortsRequest;
import com.github.unidbg.ios.struct.kernel.TaskThreadsReply64;
import com.github.unidbg.ios.struct.kernel.TaskVmInfoReply64;
import com.github.unidbg.ios.struct.kernel.ThreadBasicInfoReply;
import com.github.unidbg.ios.struct.kernel.ThreadInfoRequest;
import com.github.unidbg.ios.struct.kernel.ThreadStateReply64;
import com.github.unidbg.ios.struct.kernel.ThreadStateRequest;
import com.github.unidbg.ios.struct.kernel.VmCopy64Request;
import com.github.unidbg.ios.struct.kernel.VmCopyReply;
import com.github.unidbg.ios.struct.kernel.VmReadOverwriteReply;
import com.github.unidbg.ios.struct.kernel.VmReadOverwriteRequest;
import com.github.unidbg.ios.struct.kernel.VmRegion64Reply;
import com.github.unidbg.ios.struct.kernel.VmRegion64Request;
import com.github.unidbg.ios.struct.kernel.VmRegionRecurse64Reply;
import com.github.unidbg.ios.struct.kernel.VmRegionRecurse64Request;
import com.github.unidbg.ios.struct.kernel.VmRemapReply;
import com.github.unidbg.ios.struct.kernel.VmRemapRequest;
import com.github.unidbg.ios.struct.sysctl.IfMsgHeader;
import com.github.unidbg.ios.struct.sysctl.KInfoProc64;
import com.github.unidbg.ios.struct.sysctl.SockAddrDL;
import com.github.unidbg.ios.struct.sysctl.TaskDyldInfo;
import com.github.unidbg.ios.struct.sysctl.TaskVmInfo64;
import com.github.unidbg.memory.MemoryMap;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.pointer.UnidbgStructure;
import com.github.unidbg.thread.PopContextException;
import com.github.unidbg.thread.RunnableTask;
import com.github.unidbg.thread.ThreadContextSwitchException;
import com.github.unidbg.unix.UnixEmulator;
import com.github.unidbg.unix.struct.TimeSpec;
import com.github.unidbg.unix.struct.TimeVal64;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.UnicornConst;
import java.net.SocketException;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import static com.github.unidbg.file.ios.DarwinFileIO.XATTR_CREATE;
import static com.github.unidbg.file.ios.DarwinFileIO.XATTR_REPLACE;
import static com.github.unidbg.ios.MachO.MAP_MY_FIXED;
import static com.github.unidbg.ios.file.SocketIO.AF_LINK;
import static com.github.unidbg.ios.file.SocketIO.AF_ROUTE;
public class ARM64SyscallHandler extends DarwinSyscallHandler {
    private static final Logger log = LoggerFactory.getLogger(ARM64SyscallHandler.class);
    private final SvcMemory svcMemory;
    protected ARM64SyscallHandler(SvcMemory svcMemory) {
        super();
        this.svcMemory = svcMemory;
    }
    @SuppressWarnings("unchecked")
    @Override
    public void hook(Backend backend, int intno, int swi, Object user) {
        Emulator<DarwinFileIO> emulator = (Emulator<DarwinFileIO>) user;
        UnidbgPointer pc = UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_PC);
        if (intno == ARMEmulator.EXCP_BKPT) { 
            createBreaker(emulator).brk(pc, pc == null ? swi : (pc.getInt(0) >> 5) & 0xffff);
            return;
        }
        if (intno == ARMEmulator.EXCP_UDEF) {
            createBreaker(emulator).debug();
            return;
        }
        if (intno != ARMEmulator.EXCP_SWI) {
            throw new BackendException("intno=" + intno);
        }
        int NR = backend.reg_read(Arm64Const.UC_ARM64_REG_X16).intValue();
        String syscall = null;
        Throwable exception = null;
        try {
            if (swi == 0 && NR == Svc.POST_CALLBACK_SYSCALL_NUMBER && backend.reg_read(Arm64Const.UC_ARM64_REG_X8).intValue() == 0) { 
                int number = backend.reg_read(Arm64Const.UC_ARM64_REG_X12).intValue();
                Svc svc = svcMemory.getSvc(number);
                if (svc != null) {
                    svc.handlePostCallback(emulator);
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (swi == 0 && NR == Svc.PRE_CALLBACK_SYSCALL_NUMBER && backend.reg_read(Arm64Const.UC_ARM64_REG_X8).intValue() == 0) { 
                int number = backend.reg_read(Arm64Const.UC_ARM64_REG_X12).intValue();
                Svc svc = svcMemory.getSvc(number);
                if (svc != null) {
                    svc.handlePreCallback(emulator);
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (swi != DARWIN_SWI_SYSCALL) {
                if (swi == Arm64Svc.SVC_MAX) {
                    throw new PopContextException();
                }
                if (swi == Arm64Svc.SVC_MAX - 1) {
                    throw new ThreadContextSwitchException();
                }
                Svc svc = svcMemory.getSvc(swi);
                if (svc != null) {
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, svc.handle(emulator));
                    return;
                }
                backend.emu_stop();
                throw new BackendException("svc number: " + swi + ", NR=" + NR + ", intno=" + intno);
            }
            if (log.isTraceEnabled()) {
                log.debug("handle syscall NR={}", NR);
                ARM.showRegs64(emulator, null);
            }
            Cpsr.getArm64(backend).setCarry(false);
            boolean isIndirect = NR == 0;
            if (isIndirect) {
                int indirectNR = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).intValue();
                if (!handleIndirect(emulator, indirectNR)) {
                    log.warn("handleInterrupt intno={}, indirectNR={}, svcNumber=0x{}, PC={}", intno, indirectNR, Integer.toHexString(swi), pc);
                    if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
                        createBreaker(emulator).debug();
                    }
                }
                return;
            }
            if (handleSyscall(emulator, NR)) {
                return;
            }
            switch (NR) {
                case -3:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mach_absolute_time());
                    return;
                case -10:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_vm_allocate_trap(emulator));
                    return;
                case -12:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_vm_deallocate_trap(emulator));
                    return;
                case -14:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_vm_protect_trap(emulator));
                    return;
                case -15:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_vm_map_trap(emulator));
                    return;
                case -16:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_port_allocate_trap(emulator));
                    return;
                case -18:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_port_deallocate_trap(emulator));
                    return;
                case -19:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_port_mod_refs_trap(emulator));
                    return;
                case -21:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_port_insert_right_trap(emulator));
                    return;
                case -22: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _mach_port_insert_member(emulator));
                    return;
                case -24:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_port_construct_trap(emulator));
                    return;
                case -26: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mach_reply_port());
                    return;
                case -27:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, thread_self_trap());
                    return;
                case -28: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, task_self_trap());
                    return;
                case -29:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, host_self_trap());
                    return;
                case -31:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mach_msg_trap(emulator));
                    return;
                case -33: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _os_semaphore_signal(emulator));
                    return;
                case -36: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _semaphore_wait_trap(emulator));
                    return;
                case -38: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, semaphore_timedwait_trap(emulator));
                    return;
                case -41: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _kernelrpc_mach_port_guard_trap(emulator));
                    return;
                case -47:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, kern_invalid());
                    return;
                case -59: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, swtch_pri(emulator));
                    return;
                case -61:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, thread_switch(emulator));
                    return;
                case -89:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _mach_timebase_info(emulator));
                    return;
                case -91: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _mk_timer_create());
                    return;
                case -93: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _mk_timer_arm(emulator));
                    return;
                case -94: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _mk_timer_cancel(emulator));
                    return;
                case 1:
                    exit(emulator);
                    return;
                case 2:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fork(emulator));
                    return;
                case 4:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, write(emulator, 0));
                    return;
                case 6:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, closeWithOffset(emulator, 0));
                    return;
                case 10:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, unlink(emulator));
                    return;
                case 15:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, chmod(emulator));
                    return;
                case 16:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, chown(emulator));
                    return;
                case 20:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getpid(emulator));
                    return;
                case 24: 
                case 25: 
                case 43: 
                case 47: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, 0);
                    return;
                case 33:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, access(emulator));
                    return;
                case 34:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, chflags(emulator));
                    return;
                case 35:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fchflags(emulator));
                    return;
                case 37:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, kill(emulator));
                    return;
                case 39:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getppid(emulator));
                    return;
                case 42:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, pipe(emulator));
                    return;
                case 46:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sigaction(emulator));
                    return;
                case 48:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sigprocmask(emulator));
                    return;
                case 52:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sigpending(emulator));
                    return;
                case 53:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sigaltstack(emulator));
                    return;
                case 54:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, ioctl(emulator));
                    return;
                case 58:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, readlink(emulator));
                    return;
                case 65:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, msync(emulator));
                    return;
                case 73:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, munmap(emulator));
                    return;
                case 74:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mprotect(emulator));
                    return;
                case 75:
                    syscall = "posix_madvise";
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, 0);
                    return;
                case 89:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getdtablesize());
                    return;
                case 90:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, dup2(emulator));
                    return;
                case 92:
                case 406: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fcntl(emulator));
                    return;
                case 93:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, newselect(emulator));
                    return;
                case 95:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fsync(emulator));
                    return;
                case 97:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, socket(emulator, 0));
                    return;
                case 98:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, connect(emulator, 0));
                    return;
                case 116:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, gettimeofday(emulator));
                    return;
                case 117:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getrusage(emulator));
                    return;
                case 121:
                case 412: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, writev(emulator));
                    return;
                case 123:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fchown(emulator));
                    return;
                case 124:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fchmod(emulator));
                    return;
                case 128:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, rename(emulator));
                    return;
                case 131:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, flock(emulator));
                    return;
                case 133:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sendto(emulator));
                    return;
                case 136:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mkdir(emulator));
                    return;
                case 137:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, rmdir(emulator));
                    return;
                case 138:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, utimes(emulator, 0));
                    return;
                case 139:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, futimes(emulator));
                    return;
                case 159:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, unmount(emulator));
                    return;
                case 169:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, csops(emulator));
                    return;
                case 194:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getrlimit(emulator));
                    return;
                case 195:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, setrlimit(emulator));
                    return;
                case 197:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mmap(emulator));
                    return;
                case 199:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, lseek(emulator));
                    return;
                case 201:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, ftruncate(emulator));
                    return;
                case 202:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sysctl(emulator, 0));
                    return;
                case 216:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, open_dprotected_np(emulator));
                    return;
                case 220:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getattrlist(emulator));
                    return;
                case 221:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, setattrlist(emulator));
                    return;
                case 234:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getxattr(emulator));
                    return;
                case 236:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, setxattr(emulator));
                    return;
                case 237:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fsetxattr(emulator));
                    return;
                case 238:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, removexattr(emulator));
                    return;
                case 240:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, listxattr(emulator));
                    return;
                case 241:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, flistxattr(emulator));
                    return;
                case 266:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, shm_open(emulator));
                    return;
                case 282:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, chmodx_np(emulator));
                    return;
                case 283:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fchmodx_np(emulator));
                    return;
                case 286:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, pthread_getugid_np(emulator));
                    return;
                case 294:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, shared_region_check_np(emulator));
                    return;
                case 301:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, psynch_mutexwait(emulator));
                    return;
                case 302:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, psynch_mutexdrop(emulator));
                    return;
                case 303:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, psynch_cvbroad(emulator));
                    return;
                case 305:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, psynch_cvwait(emulator));
                    return;
                case 307:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, psynch_rw_wrlock(emulator));
                    return;
                case 308:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, psynch_rw_unlock(emulator));
                    return;
                case 327:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, issetugid());
                    return;
                case 328:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, pthread_kill(emulator));
                    return;
                case 329:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, pthread_sigmask(emulator));
                    return;
                case 330:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sigwait(emulator));
                    return;
                case 331:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, disable_threadsignal(emulator));
                    return;
                case 334:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, semwait_signal(emulator));
                    return;
                case 336:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, proc_info(emulator, 0));
                    return;
                case 338:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, stat64(emulator, 0));
                    return;
                case 339:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fstat(emulator));
                    return;
                case 340:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, lstat(emulator, 0));
                    return;
                case 341:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, statx_np(emulator));
                    return;
                case 342:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, lstatx_np(emulator));
                    return;
                case 343:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fstatx_np(emulator));
                    return;
                case 344:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getdirentries64(emulator, 0));
                    return;
                case 345:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, statfs64(emulator));
                    return;
                case 346:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fstatfs64(emulator));
                    return;
                case 347:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getfsstat64(emulator, 0));
                    return;
                case 357:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getaudit_addr(emulator));
                    return;
                case 360:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, bsdthread_create(emulator));
                    return;
                case 361:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, bsdthread_terminate(emulator));
                    return;
                case 366:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, bsdthread_register(emulator));
                    return;
                case 367:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _workq_open(emulator));
                    return;
                case 368:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, _workq_kernreturn(emulator));
                    return;
                case 369:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, kevent64(emulator));
                    return;
                case 372:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, thread_selfid(emulator));
                    return;
                case 381:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sandbox_ms(emulator));
                    return;
                case 3:
                case 396:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, read_NOCANCEL(emulator, 0));
                    return;
                case 397:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, write_NOCANCEL(emulator));
                    return;
                case 5:
                case 398:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, open_NOCANCEL(emulator, 0));
                    return;
                case 399:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, close_NOCANCEL(emulator));
                    return;
                case 423:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, semwait_signal(emulator));
                    return;
                case 428:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, audit_session_self());
                    return;
                case 443:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, guarded_kqueue_np(emulator));
                    return;
                case 0x80000000:
                    NR = backend.reg_read(Arm64Const.UC_ARM64_REG_X3).intValue();
                    if(handleMachineDependentSyscall(emulator, NR)) {
                        return;
                    }
                default:
                    break;
            }
        } catch (StopEmulatorException e) {
            backend.emu_stop();
            return;
        } catch (LongJumpException e) {
            backend.emu_stop();
            throw e;
        } catch (Throwable e) {
            backend.emu_stop();
            exception = e;
        }
        log.warn("handleInterrupt intno={}, NR={}, svcNumber=0x{}, PC={}, syscall={}", intno, NR, Integer.toHexString(swi), pc, syscall, exception);
        if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        if (exception instanceof RuntimeException) {
            throw (RuntimeException) exception;
        }
    }
    private long newselect(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int nfds = context.getIntArg(0);
        Pointer readfds = context.getPointerArg(1);
        Pointer writefds = context.getPointerArg(2);
        Pointer exceptfds = context.getPointerArg(3);
        Pointer timeout = context.getPointerArg(4);
        int size = (nfds - 1) / 8 + 1;
        if (log.isDebugEnabled()) {
            log.debug("newselect nfds={}, readfds={}, writefds={}, exceptfds={}, timeout={}", nfds, readfds, writefds, exceptfds, timeout);
            if (readfds != null) {
                byte[] data = readfds.getByteArray(0, size);
                Inspector.inspect(data, "readfds");
            }
            if (writefds != null) {
                byte[] data = writefds.getByteArray(0, size);
                Inspector.inspect(data, "writefds");
            }
        }
        if (exceptfds != null) {
            emulator.getMemory().setErrno(UnixEmulator.ENOMEM);
            return -1;
        }
        if (writefds != null) {
            int count = select(nfds, writefds, readfds, false);
            if (count > 0) {
                return count;
            }
        }
        if (readfds != null) {
            int count = select(nfds, readfds, writefds, true);
            if (count == 0) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    throw new IllegalStateException(e);
                }
            }
            return count;
        }
        throw new AbstractMethodError("newselect nfds=" + nfds + ", readfds=null, writefds=" + writefds + ", exceptfds=null, timeout=" + timeout);
    }
    private long fstatx_np(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer sb = context.getPointerArg(1);
        Pointer fsacl = context.getPointerArg(2);
        Pointer fsacl_size = context.getPointerArg(3);
        DarwinFileIO io = fdMap.get(fd);
        if (io != null) {
            fsacl_size.setLong(0, 0);
            io.fstat(emulator, new Stat64(sb));
            log.debug("fstatx_np fd={}, sb={}, fsacl={}, fsacl_size={}, io={}", fd, sb, fsacl, fsacl_size, io);
            return 0;
        }
        int errno = UnixEmulator.ENOENT;
        if (verbose) {
            System.out.printf("File fstatx_np '%s' errno is %d from %s%n", fd, errno, emulator.getContext().getLRPointer());
        }
        Cpsr.getArm64(emulator.getBackend()).setCarry(true);
        return errno;
    }
    private long lstatx_np(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer obj = context.getPointerArg(0);
        Pointer sb = context.getPointerArg(1);
        Pointer fsacl = context.getPointerArg(2);
        Pointer fsacl_size = context.getPointerArg(3);
        String path = obj.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, path, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            fsacl_size.setLong(0, 0);
            result.io.fstat(emulator, new Stat64(sb));
            log.debug("lstatx_np path={}, sb={}, fsacl={}, fsacl_size={}, result={}", path, sb, fsacl, fsacl_size, result.io);
            return 0;
        }
        int errno = result != null ? result.errno : UnixEmulator.ENOENT;
        if (verbose) {
            System.out.printf("File lstatx_np '%s' errno is %d from %s%n", path, errno, emulator.getContext().getLRPointer());
        }
        Cpsr.getArm64(emulator.getBackend()).setCarry(true);
        return errno;
    }
    private long statx_np(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer obj = context.getPointerArg(0);
        Pointer sb = context.getPointerArg(1);
        Pointer fsacl = context.getPointerArg(2);
        Pointer fsacl_size = context.getPointerArg(3);
        String path = obj.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, path, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            fsacl_size.setLong(0, 0);
            result.io.fstat(emulator, new Stat64(sb));
            log.debug("statx_np path={}, sb={}, fsacl={}, fsacl_size={}, result={}", path, sb, fsacl, fsacl_size, result.io);
            return 0;
        }
        int errno = result != null ? result.errno : UnixEmulator.ENOENT;
        if (verbose) {
            System.out.printf("File statx '%s' errno is %d from %s%n", path, errno, emulator.getContext().getLRPointer());
        }
        Cpsr.getArm64(emulator.getBackend()).setCarry(true);
        return errno;
    }
    private long kern_invalid() {
        return 0x4; 
    }
    private long getrusage(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int who = context.getIntArg(0);
        Pointer r_usage = context.getPointerArg(1);
        RUsage64 usage64 = new RUsage64(r_usage);
        usage64.unpack();
        if (log.isDebugEnabled()) {
            log.debug("getrusage who={}, r_usage={}, usage64={}", who, r_usage, usage64);
        }
        usage64.fillDefault();
        usage64.pack();
        return 0;
    }
    private int unmount(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer target = context.getPointerArg(0);
        int flags = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("unmount target={}, flags=0x{}", target.getString(0), Integer.toHexString(flags));
        }
        return 0;
    }
    private UnidbgPointer shared_region;
    private int shared_region_check_np(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer start_address = context.getPointerArg(0);
        if (shared_region == null) {
            shared_region = emulator.getMemory().mmap(emulator.getPageAlign(), UnicornConst.UC_PROT_READ);
            DyldCacheHeader dyldCacheHeader = new DyldCacheHeader(shared_region);
            dyldCacheHeader.pack();
        }
        if (log.isDebugEnabled()) {
            log.debug("shared_region_check_np start_address={}, LR={}", start_address, context.getLRPointer());
        }
        start_address.setPointer(0, shared_region);
        return 0;
    }
    private int getdtablesize() {
        return 0x1000;
    }
    private static final int CS_OPS_STATUS = 0; 
    private static final int CS_GET_TASK_ALLOW = 0x00000004; 
    private static final int CS_INSTALLER = 0x00000008; 
    private static final int CS_HARD = 0x0000100; 
    private static final int CS_RESTRICT = 0x0000800; 
    private static final int CS_ENFORCEMENT = 0x0001000; 
    private static final int CS_REQUIRE_LV = 0x0002000; 
    private static final int CS_ENTITLEMENTS_VALIDATED = 0x0004000; 
    private static final int CS_DYLD_PLATFORM = 0x2000000; 
    private static final int CS_PLATFORM_BINARY = 0x4000000; 
    private static final int CS_DEBUGGED = 0x10000000; 
    private static final int CS_SIGNED = 0x20000000; 
    private static final int CS_OPS_CDHASH = 5; 
    private long csops(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        int op = context.getIntArg(1);
        Pointer addr = context.getPointerArg(2);
        int length = context.getIntArg(3);
        if (log.isDebugEnabled()) {
            log.debug("csops pid={}, op={}, addr={}, length={}", pid, op, addr, length);
        }
        if (op == CS_OPS_STATUS) {
            addr.setInt(0, CS_HARD | CS_RESTRICT | CS_ENFORCEMENT | CS_REQUIRE_LV | CS_ENTITLEMENTS_VALIDATED | CS_DYLD_PLATFORM | CS_PLATFORM_BINARY | CS_SIGNED);
            return 0;
        } else if (op == CS_OPS_CDHASH) {
            byte[] cdhash = new byte[length];
            for (int i = 0; i < length; i++) {
                cdhash[i] = (byte) (i + 0x10);
            }
            addr.write(0, cdhash, 0, length);
            return 0;
        } else {
            log.info("csops pid={}, op={}, addr={}, length={}", pid, op, addr, length);
            Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
            if (log.isDebugEnabled()) {
                emulator.attach().debug();
            }
            return -1;
        }
    }
    private long msync(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer addr = context.getPointerArg(0);
        int len = context.getIntArg(1);
        int flags = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("msync addr={}, len={}, flags=0x{}", addr, len, Integer.toHexString(flags));
        }
        return 0;
    }
    private long fchown(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int uid = context.getIntArg(1);
        int gid = context.getIntArg(2);
        DarwinFileIO io = fdMap.get(fd);
        if (io != null) {
            int ret = io.chown(uid, gid);
            if (ret == -1) {
                log.info("fchown fd={}, uid={}, gid={}", fd, uid, gid);
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("fchown fd={}, uid={}, gid={}", fd, uid, gid);
                }
            }
            return ret;
        } else {
            log.info("fchown fd={}, uid={}, gid={}", fd, uid, gid);
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    private long chown(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        int uid = context.getIntArg(1);
        int gid = context.getIntArg(2);
        String pathname = path.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.chown(uid, gid);
            if (ret == -1) {
                log.info("chown path={}, uid={}, gid={}", pathname, uid, gid);
            } else {
                log.debug("chown path={}, uid={}, gid={}", pathname, uid, gid);
            }
            return ret;
        } else {
            log.info("chown path={}, uid={}, gid={}, result={}", pathname, uid, gid, result);
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    private boolean handleMachineDependentSyscall(Emulator<?> emulator, int NR) {
        Backend backend = emulator.getBackend();
        switch (NR) {
            case 0:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sys_icache_invalidate(emulator));
                return true;
            case 1:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sys_dcache_flush(emulator));
                return true;
            case 2:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, pthread_set_self(emulator));
                return true;
        }
        return false;
    }
    private long sys_dcache_flush(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer address = context.getPointerArg(0);
        long size = context.getLongArg(1);
        if (log.isDebugEnabled()) {
            log.debug("sys_dcache_flush address={}, size={}", address, size);
        }
        return 0;
    }
    private long sys_icache_invalidate(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer address = context.getPointerArg(0);
        long size = context.getLongArg(1);
        if (log.isDebugEnabled()) {
            log.debug("sys_icache_invalidate address={}, size={}", address, size);
        }
        return 0;
    }
    private long _mach_port_insert_member(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int task = context.getIntArg(0);
        int name = context.getIntArg(1);
        int pset = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("_mach_port_insert_member task={}, name={}, pset={}", task, name, pset);
        }
        if (verbose) {
            System.out.printf("mach_port_insert_member %d with pset=0x%x from %s%n", name, pset, emulator.getContext().getLRPointer());
        }
        return 0;
    }
    private long _mk_timer_create() {
        if (log.isDebugEnabled()) {
            log.debug("_mk_timer_create");
        }
        return STATIC_PORT;
    }
    private long _mk_timer_arm(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int port = context.getIntArg(0);
        long time = context.getLongArg(1);
        if (log.isDebugEnabled()) {
            log.debug("_mk_timer_arm port={}, time={}", port, time);
        }
        return 0;
    }
    private long _mk_timer_cancel(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int name = context.getIntArg(0);
        Pointer result_time = context.getPointerArg(1);
        if (log.isDebugEnabled()) {
            log.debug("_mk_timer_cancel name={}, result_time={}", name, result_time);
        }
        return 0;
    }
    private long mkdir(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        int mode = context.getIntArg(1);
        String path = pathname.getString(0);
        if (emulator.getFileSystem().mkdir(path, mode)) {
            if (log.isDebugEnabled()) {
                log.debug("mkdir pathname={}, mode={}", path, mode);
            }
            return 0;
        } else {
            log.info("mkdir pathname={}, mode={}", path, mode);
            emulator.getMemory().setErrno(UnixEmulator.EACCES);
            return -1;
        }
    }
    private int rmdir(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        String pathname = path.getString(0);
        emulator.getFileSystem().rmdir(pathname);
        if (log.isDebugEnabled()) {
            log.debug("rmdir pathname={}", path);
        }
        return 0;
    }
    private long utimes(Emulator<?> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(offset);
        Pointer times = context.getPointerArg(offset + 1);
        String pathname = path.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("utimes pathname={}, times={}", pathname, times);
        }
        return 0;
    }
    private long futimes(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer times = context.getPointerArg(1);
        if (log.isDebugEnabled()) {
            log.debug("futimes fd={}, times={}", fd, times);
        }
        return 0;
    }
    protected boolean handleIndirect(Emulator<DarwinFileIO> emulator, int indirectNR) {
        Backend backend = emulator.getBackend();
        switch (indirectNR) {
            case 3:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, read_NOCANCEL(emulator, 1));
                return true;
            case 4:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, write(emulator, 1));
                return true;
            case 5:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, open_NOCANCEL(emulator, 1));
                return true;
            case 6:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, closeWithOffset(emulator, 1));
                return true;
            case 20:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getpid(emulator));
                return true;
            case 39:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getppid(emulator));
                return true;
            case 97:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, socket(emulator, 1));
                return true;
            case 98:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, connect(emulator, 1));
                return true;
            case 138:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, utimes(emulator, 1));
                return true;
            case 190:
            case 340:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, lstat(emulator, 1));
                return true;
            case 202:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sysctl(emulator, 1));
                return true;
            case 336:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, proc_info(emulator, 1));
                return true;
            case 338:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, stat64(emulator, 1));
                return true;
            case 344:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getdirentries64(emulator, 1));
                return true;
            case 347:
                backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getfsstat64(emulator, 1));
                return true;
        }
        return false;
    }
    private long _kernelrpc_mach_port_guard_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int task = context.getIntArg(0);
        int name = context.getIntArg(1);
        Pointer guard = context.getPointerArg(2);
        int strict = context.getIntArg(3);
        log.info("_kernelrpc_mach_port_guard_trap task={}, name={}, guard={}, strict={}", task, name, guard, strict);
        return 0;
    }
    private long semaphore_timedwait_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int port = context.getIntArg(0);
        log.info("semaphore_timedwait_trap port={}", port);
        Logger log = ARM64SyscallHandler.log;
        if (!log.isDebugEnabled()) {
            log = LoggerFactory.getLogger(AbstractEmulator.class);
        }
        if (log.isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        return 0;
    }
    private long _os_semaphore_signal(Emulator<?> emulator) {
        int semaphore = emulator.getContext().getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("_os_semaphore_signal semaphore={}", semaphore);
        }
        if (semaphore != 0) {
            semaphoreMap.put(semaphore, Boolean.TRUE);
        }
        Logger log = ARM64SyscallHandler.log;
        if (!log.isDebugEnabled()) {
            log = LoggerFactory.getLogger(AbstractEmulator.class);
        }
        if (log.isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        return 0;
    }
    private int _kernelrpc_mach_port_allocate_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int task = context.getIntArg(0);
        int right = context.getIntArg(1);
        Pointer name = context.getPointerArg(2);
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_allocate_trap task={}, right={}, name={}", task, right, name);
        }
        name.setInt(0, STATIC_PORT);
        if (verbose) {
            System.out.printf("mach_port_allocate %d with right=0x%x from %s%n", STATIC_PORT, right, emulator.getContext().getLRPointer());
        }
        return 0;
    }
    private int pthread_set_self(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer self = context.getPointerArg(0);
        Pthread pthread = new Pthread64(self.getPointer(0));
        pthread.unpack();
        UnidbgPointer tsd = pthread.getTSD();
        emulator.getBackend().reg_write(Arm64Const.UC_ARM64_REG_TPIDRRO_EL0, tsd.peer);
        MachOLoader loader = (MachOLoader) emulator.getMemory();
        loader.setErrnoPointer(pthread.getErrno());
        if (log.isDebugEnabled()) {
            String threadName = pthread.getName();
            log.debug("pthread_set_self={}, pthread={}, threadName={}, LR={}", self, pthread, threadName, emulator.getContext().getLRPointer());
        }
        return 0;
    }
    private int thread_switch(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int thread_name = context.getIntArg(0);
        int option = context.getIntArg(1);
        int option_time = context.getIntArg(2);
        log.info("thread_switch thread_name={}, option={}, option_time={}", thread_name, option, option_time);
        return 0;
    }
    private int _mach_timebase_info(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pointer = context.getPointerArg(0);
        MachTimebaseInfo info = new MachTimebaseInfo(pointer);
        info.denom = 1;
        info.numer = 1;
        info.pack();
        if (log.isDebugEnabled()) {
            log.debug("_mach_timebase_info info={}, LR={}", info, context.getLRPointer());
        }
        return 0;
    }
    private long psynch_rw_unlock(Emulator<?> emulator) {
        log.info("psynch_rw_unlock LR={}", emulator.getContext().getLRPointer());
        return 0;
    }
    private long psynch_rw_wrlock(Emulator<?> emulator) {
        log.info("psynch_rw_wrlock LR={}", emulator.getContext().getLRPointer());
        return 0;
    }
    private int psynch_mutexwait(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer mutex = context.getPointerArg(0);
        int mgen = context.getIntArg(1);
        int ugen = context.getIntArg(2);
        long tid = context.getLongArg(3);
        int flags = context.getIntArg(4);
        if (log.isDebugEnabled()) {
            log.debug("psynch_mutexwait mutex={}, mgen={}, ugen={}, tid={}, flags=0x{}, LR={}", mutex, mgen, ugen, tid, Integer.toHexString(flags), context.getLRPointer());
        }
        return 0;
    }
    private int psynch_mutexdrop(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer mutex = context.getPointerArg(0);
        int mgen = context.getIntArg(1);
        int ugen = context.getIntArg(2);
        long tid = context.getLongArg(3);
        int flags = context.getIntArg(4);
        if (log.isDebugEnabled()) {
            log.debug("psynch_mutexdrop mutex={}, mgen={}, ugen={}, tid={}, flags=0x{}, LR={}", mutex, mgen, ugen, tid, Integer.toHexString(flags), context.getLRPointer());
        }
        return 0;
    }
    private int psynch_cvwait(Emulator<?> emulator) {
        Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
        if (threadDispatcherEnabled) {
            if (log.isTraceEnabled()) {
                emulator.attach().debug();
            }
            throw new ThreadContextSwitchException();
        }
        log.info("psynch_cvwait LR=" + emulator.getContext().getLRPointer());
        if (log.isDebugEnabled()) {
            emulator.attach().debug();
        }
        emulator.getMemory().setErrno(UnixEmulator.EINTR);
        return -1;
    }
    private int shm_open(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pointer = context.getPointerArg(0);
        int oflags = context.getIntArg(1);
        int mode = context.getIntArg(2);
        String name = pointer.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("shm_open name={}, oflags=0x{}, mode={}", name, Integer.toHexString(oflags), Integer.toHexString(mode));
        }
        emulator.getMemory().setErrno(UnixEmulator.EACCES);
        return -1;
    }
    private int pthread_getugid_np(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer uid = context.getPointerArg(0);
        Pointer gid = context.getPointerArg(1);
        if (log.isDebugEnabled()) {
            log.debug("pthread_getugid_np uid={}, gid={}", uid, gid);
        }
        uid.setInt(0, 0);
        gid.setInt(0, 0);
        return 0;
    }
    private int closeWithOffset(Emulator<?> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(offset);
        if (log.isDebugEnabled()) {
            log.debug("close fd={}, LR={}", fd, context.getLRPointer());
        }
        return close(emulator, fd);
    }
    private int lseek(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        long offset = context.getLongArg(1);
        int whence = context.getIntArg(2);
        FileIO file = fdMap.get(fd);
        if (file == null) {
            if (log.isDebugEnabled()) {
                log.debug("lseek fd={}, offset={}, whence={}", fd, offset, whence);
            }
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int pos = file.lseek((int) offset, whence);
        if (log.isDebugEnabled()) {
            log.debug("lseek fd={}, offset={}, whence={}, pos={}", fd, offset, whence, pos);
        }
        return pos;
    }
    private long ftruncate(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int length = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("ftruncate fd={}, length={}, LR={}", fd, length, context.getLRPointer());
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            throw new UnsupportedOperationException("fd=" + fd + ", map=" + fdMap);
        }
        return file.ftruncate(length);
    }
    private int unlink(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        String path = FilenameUtils.normalize(pathname.getString(0), true);
        emulator.getFileSystem().unlink(path);
        return 0;
    }
    private int getdirentries64(Emulator<?> emulator, int index) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(index);
        UnidbgPointer buf = context.getPointerArg(index + 1);
        int bufSize = context.getIntArg(index + 2);
        Pointer basep = context.getPointerArg(index + 3);
        DarwinFileIO io = fdMap.get(fd);
        if (log.isDebugEnabled()) {
            log.debug("getdirentries64 fd={}, buf={}, bufSize={}, basep={}, io={}, LR={}", fd, buf, bufSize, basep, io, context.getLRPointer());
        }
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        } else {
            buf.setSize(bufSize);
            return io.getdirentries64(buf, bufSize);
        }
    }
    private long flock(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int operation = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("flock fd={}, operation={}", fd, operation);
        }
        return 0;
    }
    private int fstatfs64(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer buf = context.getPointerArg(1);
        if (log.isDebugEnabled()) {
            log.debug("fstatfs64 fd={}, buf={}, LR={}", fd, buf, context.getLRPointer());
        }
        DarwinFileIO io = fdMap.get(fd);
        if (io != null) {
            if (verbose) {
                System.out.printf("File fstatfs '%s' from %s%n", io, emulator.getContext().getLRPointer());
            }
            return io.fstatfs(new StatFS(buf));
        }
        emulator.getMemory().setErrno(UnixEmulator.EACCES);
        return -1;
    }
    private long fchflags(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int flags = context.getIntArg(1);
        DarwinFileIO io = fdMap.get(fd);
        if (io != null) {
            int ret = io.chflags(flags);
            if (ret == -1) {
                log.info("fchflags fd={}, flags=0x{}", io, Integer.toHexString(flags));
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("fchflags fd={}, flags=0x{}", io, Integer.toHexString(flags));
                }
            }
            return ret;
        } else {
            log.info("fchflags fd={}, flags=0x{}", io, Integer.toHexString(flags));
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    private long chflags(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        int flags = context.getIntArg(1);
        String pathname = path.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.chflags(flags);
            if (ret == -1) {
                log.info("chflags pathname={}, flags=0x{}", pathname, Integer.toHexString(flags));
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("chflags pathname={}, flags=0x{}", pathname, Integer.toHexString(flags));
                }
            }
            return ret;
        } else {
            log.info("chflags pathname={}, flags=0x{}", pathname, Integer.toHexString(flags));
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    private int getppid(Emulator<?> emulator) {
        if (log.isDebugEnabled()) {
            log.debug("getppid");
        }
        return emulator.getPid();
    }
    private long pipe(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pipefd = context.getPointerArg(0);
        if (log.isDebugEnabled()) {
            int readfd = pipefd.getInt(0);
            int writefd = pipefd.getInt(4);
            log.debug("pipe readfd={}, writefd={}", readfd, writefd);
        }
        emulator.getMemory().setErrno(UnixEmulator.EFAULT);
        return -1;
    }
    private int stat64(Emulator<DarwinFileIO> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(offset);
        Pointer statbuf = context.getPointerArg(offset + 1);
        String path = FilenameUtils.normalize(pathname.getString(0), true);
        if (log.isDebugEnabled()) {
            log.debug("stat64 pathname={}, statbuf={}", path, statbuf);
        }
        return stat64(emulator, path, statbuf);
    }
    protected int stat64(Emulator<DarwinFileIO> emulator, String pathname, Pointer statbuf) {
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            if (verbose) {
                System.out.printf("File stat '%s' from %s%n", pathname, emulator.getContext().getLRPointer());
            }
            return result.io.fstat(emulator, new Stat64(statbuf));
        }
        int errno = result != null ? result.errno : UnixEmulator.ENOENT;
        if (verbose) {
            System.out.printf("File stat '%s' errno is %d from %s%n", pathname, errno, emulator.getContext().getLRPointer());
        }
        Cpsr.getArm64(emulator.getBackend()).setCarry(true);
        return errno;
    }
    private int write_NOCANCEL(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer buffer = context.getPointerArg(1);
        int count = context.getIntArg(2);
        return write(emulator, fd, buffer, count);
    }
    private int lstat(Emulator<DarwinFileIO> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(offset);
        Pointer stat = context.getPointerArg(offset + 1);
        String pathStr = pathname.getString(0);
        String path = FilenameUtils.normalize(pathStr, true);
        int ret = stat64(emulator, path, stat);
        if (log.isDebugEnabled()) {
            log.debug("lstat path={}, pathStr={}, stat={}, ret={}, LR={}", path, pathStr, stat, ret, context.getLRPointer());
        }
        return ret;
    }
    private int fstat(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer stat = context.getPointerArg(1);
        return fstat(emulator, fd, stat);
    }
    protected int fstat(Emulator<DarwinFileIO> emulator, int fd, Pointer stat) {
        if (log.isDebugEnabled()) {
            log.debug("fstat fd={}, stat={}", fd, stat);
        }
        DarwinFileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (log.isDebugEnabled()) {
            log.debug("fstat file={}, stat={}", file, stat);
        }
        if (verbose) {
            System.out.printf("File fstat '%s' from %s%n", file, emulator.getContext().getLRPointer());
        }
        return file.fstat(emulator, new Stat64(stat));
    }
    private static final int RLIMIT_NOFILE = 8;        
    private static final int RLIMIT_POSIX_FLAG = 0x1000;    
    private long rlim_cur = 128;
    private long rlim_max = 256;
    private int getrlimit(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int resource = context.getIntArg(0);
        Pointer rlp = context.getPointerArg(1);
        boolean posix = (resource & RLIMIT_POSIX_FLAG) != 0;
        int type = resource & (RLIMIT_POSIX_FLAG - 1);
        String msg = "getrlimit resource=0x" + Integer.toHexString(resource) + ", rlp=" + rlp + ", posix=" + posix + ", type=" + type;
        if (type == RLIMIT_NOFILE) {
            RLimit rLimit = new RLimit(rlp);
            rLimit.rlim_cur = rlim_cur;
            rLimit.rlim_max = rlim_max;
            rLimit.pack();
            if (log.isDebugEnabled()) {
                msg += (", rLimit=" + rLimit);
                log.debug(msg);
            }
            return 0;
        } else {
            log.info(msg);
        }
        return 1;
    }
    private int setrlimit(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int resource = context.getIntArg(0);
        Pointer rlp = context.getPointerArg(1);
        boolean posix = (resource & RLIMIT_POSIX_FLAG) != 0;
        int type = resource & (RLIMIT_POSIX_FLAG - 1);
        String msg = "setrlimit resource=0x" + Integer.toHexString(resource) + ", rlp=" + rlp + ", posix=" + posix + ", type=" + type;
        if (type == RLIMIT_NOFILE) {
            RLimit rLimit = new RLimit(rlp);
            rLimit.unpack();
            rlim_cur = rLimit.rlim_cur;
            rlim_max = rLimit.rlim_max;
            if (log.isDebugEnabled()) {
                msg += (", rLimit=" + rLimit);
                log.debug(msg);
            }
            return 0;
        } else {
            log.info(msg);
        }
        return 1;
    }
    private long _kernelrpc_mach_port_mod_refs_trap(Emulator<?> emulator) {
        Arm64RegisterContext context = emulator.getContext();
        int task = context.getXInt(0);
        int name = context.getXInt(1);
        int right = context.getXInt(2);
        int delta = context.getXInt(3);
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_mod_refs_trap task={}, name={}, right={}, delta={}", task, name, right, delta);
        }
        if (verbose) {
            System.out.printf("mach_port_mod_refs %d with right=0x%x from %s%n", name, right, emulator.getContext().getLRPointer());
        }
        return 0;
    }
    private int _kernelrpc_mach_port_insert_right_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int task = context.getIntArg(0);
        int name = context.getIntArg(1);
        int poly = context.getIntArg(2);
        int polyPoly = context.getIntArg(3);
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_insert_right_trap task={}, name={}, poly={}, polyPoly={}", task, name, poly, polyPoly);
        }
        if (verbose) {
            System.out.printf("mach_port_insert_right %d with poly=0x%x from %s%n", name, poly, emulator.getContext().getLRPointer());
        }
        return 0;
    }
    private int _kernelrpc_mach_port_construct_trap(Emulator<?> emulator) {
        Arm64RegisterContext context = emulator.getContext();
        int task = context.getXInt(0);
        Pointer options = context.getXPointer(1);
        long ctx = context.getXInt(2);
        Pointer name = context.getXPointer(3);
        if (log.isDebugEnabled()) {
            MachPortOptions portOptions = new MachPortOptions(options);
            portOptions.unpack();
            log.debug("_kernelrpc_mach_port_construct_trap task={}, options={}, context=0x{}, name={}, portOptions={}", task, options, Long.toHexString(ctx), name, portOptions);
        }
        name.setInt(0, 0x88);
        if (verbose) {
            System.out.printf("mach_port_construct %d from %s%n", 0x88, emulator.getContext().getLRPointer());
        }
        return 0;
    }
    private long getaudit_addr(Emulator<?> emulator) {
        Arm64RegisterContext context = emulator.getContext();
        Pointer addr = context.getXPointer(0);
        int size = context.getXInt(1);
        if (log.isDebugEnabled()) {
            log.debug("getaudit_addr={}, size={}", addr, size);
        }
        return 0;
    }
    private static final int PROC_INFO_CALL_SETCONTROL = 0x5;
    private static final int PROC_SELFSET_THREADNAME = 2;
    private static final int PROC_INFO_CALL_PIDINFO = 0x2;
    private static final int PROC_PIDPATHINFO = 11;
    private static final int PROC_PIDT_SHORTBSDINFO = 13;
    private int proc_info(Emulator<?> emulator, int index) {
        RegisterContext context = emulator.getContext();
        int callNum = context.getIntArg(index);
        int pid = context.getIntArg(index + 1);
        int flavor = context.getIntArg(index + 2);
        long arg = context.getLongArg(index + 3);
        Pointer buffer = context.getPointerArg(index + 4);
        int bufferSize = context.getIntArg(index + 5);
        String executable = executableBundlePath;
        if (executable == null) {
            executable = emulator.getProcessName();
        }
        String msg = "proc_info callNum=" + callNum + ", pid=" + pid + ", flavor=" + flavor + ", arg=" + arg + ", buffer=" + buffer + ", bufferSize=" + bufferSize;
        if (PROC_INFO_CALL_SETCONTROL == callNum && PROC_SELFSET_THREADNAME == flavor) {
            String threadName = buffer.getString(0);
            if (log.isDebugEnabled()) {
                log.debug("{}, newName={}", msg, threadName);
            }
            return 0;
        } else if (PROC_INFO_CALL_PIDINFO == callNum && PROC_PIDT_SHORTBSDINFO == flavor) {
            ProcBsdShortInfo info = new ProcBsdShortInfo(buffer);
            info.unpack();
            String processName = emulator.getProcessName();
            if (processName == null) {
                processName = "unidbg";
            }
            info.pbsi_pid = pid;
            info.pbsi_status = ProcBsdShortInfo.SRUN;
            info.pbsi_comm = Arrays.copyOf(Arrays.copyOf(processName.getBytes(), DarwinSyscall.MAXCOMLEN-1), DarwinSyscall.MAXCOMLEN);
            info.pbsi_flags = 0x24090;
            info.pbsi_uid = 0;
            info.pbsi_ruid = 0;
            info.pbsi_svuid = 0;
            info.pbsi_gid = 0;
            info.pbsi_rgid = 0;
            info.pbsi_svgid = 0;
            info.pbsi_pgid = 0;
            info.pbsi_ppid = pid - 1;
            info.pack();
            if (log.isDebugEnabled()) {
                log.debug("{}, info={}", msg, info);
            }
            return info.size();
        } else if (PROC_INFO_CALL_PIDINFO == callNum && PROC_PIDPATHINFO == flavor && executable != null) {
            byte[] data = executable.getBytes(StandardCharsets.UTF_8);
            if (bufferSize < data.length + 1) {
                throw new UnsupportedOperationException();
            }
            buffer.write(0, Arrays.copyOf(data, data.length + 1), 0, data.length + 1);
            return 0;
        } else {
            log.info(msg);
            Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
            if (log.isDebugEnabled()) {
                emulator.attach().debug();
            }
            return -1;
        }
    }
    protected int semwait_signal(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int cond_sem = context.getIntArg(0);
        int mutex_sem = context.getIntArg(1);
        int timeout = context.getIntArg(2);
        int relative = context.getIntArg(3);
        long tv_sec = context.getLongArg(4);
        int tv_nsec = context.getIntArg(5);
        RunnableTask runningTask = emulator.getThreadDispatcher().getRunningTask();
        String msg = "semwait_signal cond_sem=" + cond_sem + ", mutex_sem=" + mutex_sem + ", timeout=" + timeout + ", relative=" + relative + ", tv_sec=" + tv_sec + ", tv_nsec=" + tv_nsec;
        if (threadDispatcherEnabled && runningTask != null) {
            if (log.isDebugEnabled()) {
                log.debug(msg);
            }
            return semwait_signal(emulator, runningTask, cond_sem, mutex_sem, timeout, relative, tv_sec, tv_nsec);
        }
        log.info(msg);
        try {
            Thread.sleep(tv_sec * 1000L + tv_nsec / 1000L, tv_nsec % 1000);
            emulator.getMemory().setErrno(ETIMEDOUT);
            return -1;
        } catch (InterruptedException e) {
            emulator.getMemory().setErrno(UnixEmulator.EINVAL);
            return -1;
        }
    }
    private int sandbox_ms(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer policyName = context.getPointerArg(0);
        int call = context.getIntArg(1);
        Pointer args = context.getPointerArg(2);
        if (log.isDebugEnabled()) {
            log.debug("sandbox_ms policyName={}, call={}, args={}", policyName.getString(0), call, args);
        }
        return 0;
    }
    private int issetugid() {
        log.debug("issetugid");
        return 0;
    }
    protected int statfs64(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathPointer = context.getPointerArg(0);
        Pointer buf = context.getPointerArg(1);
        String path = pathPointer.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, path, IOConstants.O_RDONLY);
        if (log.isDebugEnabled()) {
            log.debug("statfs64 pathPointer={}, buf={}, path={}", pathPointer, buf, path);
        }
        if (result != null && result.isSuccess()) {
            return result.io.fstatfs(new StatFS(buf));
        }
        log.info("statfs64 pathPointer={}, buf={}, path={}", pathPointer, buf, path);
        throw new BackendException("statfs64 path=" + path + ", buf=" + buf);
    }
    private long bsdthread_create(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        UnidbgPointer start_routine = context.getPointerArg(0);
        UnidbgPointer arg = context.getPointerArg(1);
        UnidbgPointer stack = context.getPointerArg(2);
        UnidbgPointer thread = context.getPointerArg(3);
        int flags = context.getIntArg(4);
        return bsdthread_create(emulator, start_routine, arg, stack, thread, flags);
    }
    private int bsdthread_register(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        UnidbgPointer thread_start = context.getPointerArg(0);
        UnidbgPointer start_wqthread = context.getPointerArg(1);
        int pthreadSize = context.getIntArg(2);
        UnidbgPointer data = context.getPointerArg(3);
        int dataSize = context.getIntArg(4);
        long offset = context.getLongArg(5);
        if (log.isDebugEnabled()) {
            log.debug("bsdthread_register thread_start={}, start_wqthread={}, pthreadSize={}, data={}, dataSize={}, offset=0x{}", thread_start, start_wqthread, pthreadSize, data, dataSize, Long.toHexString(offset));
        }
        return bsdthread_register(thread_start, pthreadSize);
    }
    private int readlink(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        Pointer buf = context.getPointerArg(1);
        int bufSize = context.getIntArg(2);
        String path = pathname.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("readlink path={}, buf={}, bufSize={}", path, buf, bufSize);
        }
        if ("/var/db/timezone/localtime".equals(path)) { 
            path = "/var/db/timezone/zoneinfo/Asia/Shanghai";
        }
        buf.setString(0, path);
        return path.length() + 1;
    }
    private int munmap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        long timeInMillis = System.currentTimeMillis();
        long start = context.getLongArg(0);
        int length = context.getIntArg(1);
        emulator.getMemory().munmap(start, length);
        if (log.isDebugEnabled()) {
            log.debug("munmap start=0x{}, length={}, offset={}", Long.toHexString(start), length, System.currentTimeMillis() - timeInMillis);
        }
        return 0;
    }
    private int sysctl(Emulator<?> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        Pointer name = context.getPointerArg(offset);
        int namelen = context.getIntArg(offset + 1);
        Pointer buffer = context.getPointerArg(offset + 2);
        Pointer bufferSize = context.getPointerArg(offset + 3);
        Pointer set0 = context.getPointerArg(offset + 4);
        int set1 = context.getIntArg(offset + 5);
        int top = name.getInt(0);
        switch (top) {
            case CTL_UNSPEC:
                int action = name.getInt(4);
                if (action == 3) {
                    byte[] bytes = set0.getByteArray(0, set1);
                    String sub = new String(bytes, StandardCharsets.UTF_8);
                    if (log.isDebugEnabled()) {
                        log.debug("sysctl CTL_UNSPEC action={}, namelen={}, buffer={}, bufferSize={}, sub={}, set1={}", action, namelen, buffer, bufferSize, sub, set1);
                    }
                    switch (sub) {
                        case "unidbg.debug":
                            return verbose || LoggerFactory.getLogger("com.github.unidbg.ios.debug").isDebugEnabled() ? 1 : 0;
                        case "kern.ostype":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_OSTYPE);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "kern.osrelease":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_OSRELEASE);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "kern.version":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_VERSION);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "kern.osversion":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_OSVERSION);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "kern.boottime":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_BOOTTIME);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.machine":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_MACHINE);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.model":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_MODEL);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.cputype":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_CPU_TYPE);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.cpusubtype":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_CPU_SUBTYPE);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.cpufamily":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_CPU_FAMILY);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.ncpu":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_NCPU);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.memsize":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_MEMSIZE);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.physicalcpu_max":
                        case "hw.logicalcpu_max":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_CPU_MAX);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "sysctl.proc_native":
                            return -1;
                    }
                    if (log.isDebugEnabled()) {
                        createBreaker(emulator).debug();
                    }
                    log.info("sysctl CTL_UNSPEC action={}, namelen={}, buffer={}, bufferSize={}, sub={}", action, namelen, buffer, bufferSize, sub);
                    return -1;
                }
                log.info("sysctl CTL_UNSPEC action={}, namelen={}, buffer={}, bufferSize={}, set0={}, set1={}", action, namelen, buffer, bufferSize, set0, set1);
                break;
            case CTL_KERN: {
                action = name.getInt(4);
                String msg = "sysctl CTL_KERN action=" + action + ", namelen=" + namelen + ", buffer=" + buffer + ", bufferSize=" + bufferSize + ", set0=" + set0 + ", set1=" + set1;
                switch (action) {
                    case KERN_USRSTACK32:
                    case KERN_PROCARGS2:
                        log.info(msg);
                        return 1;
                    case KERN_OSTYPE:
                        log.debug(msg);
                        String osType = getKernelOsType();
                        if (bufferSize != null) {
                            bufferSize.setLong(0, osType.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, osType);
                        }
                        return 0;
                    case KERN_OSRELEASE:
                        log.debug(msg);
                        String osRelease = getKernelOsRelease();
                        if (bufferSize != null) {
                            bufferSize.setLong(0, osRelease.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, osRelease);
                        }
                        return 0;
                    case KERN_VERSION:
                        log.debug(msg);
                        String version = getKernelVersion();
                        if (bufferSize != null) {
                            bufferSize.setLong(0, version.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, version);
                        }
                        return 0;
                    case KERN_ARGMAX:
                        bufferSize.setLong(0, 4);
                        buffer.setInt(0, 128);
                        return 0;
                    case KERN_PROC:
                        int subType = name.getInt(8);
                        if (subType == KERN_PROC_PID) {
                            if (bufferSize != null) {
                                bufferSize.setLong(0, UnidbgStructure.calculateSize(KInfoProc64.class));
                            }
                            KInfoProc64 kInfoProc = null;
                            if (buffer != null) {
                                kInfoProc = new KInfoProc64(buffer);
                                kInfoProc.unpack();
                                kInfoProc.kp_proc.p_flag = 0; 
                                kInfoProc.kp_eproc.e_ucred.cr_uid = 0;
                                kInfoProc.pack();
                            }
                            int pid = name.getInt(0xc);
                            log.debug("{}, subType={}, pid={}, kInfoProc={}", msg, subType, pid, kInfoProc);
                            return 0;
                        }
                        log.info("{}, subType={}", msg, subType);
                        break;
                    case KERN_OSVERSION:
                        log.debug(msg);
                        String osVersion = getBuildVersion();
                        if (bufferSize != null) {
                            bufferSize.setLong(0, osVersion.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, osVersion);
                        }
                        return 0;
                    case KERN_HOSTNAME:
                        log.debug(msg);
                        String hostName = getKernelHostName();
                        if (bufferSize != null) {
                            bufferSize.setLong(0, hostName.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, hostName);
                        }
                        return 0;
                    case KERN_USRSTACK64:
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 8);
                        }
                        if (buffer != null) {
                            buffer.setLong(0, emulator.getMemory().getStackBase());
                        }
                        return 0;
                    case KERN_BOOTTIME:
                        if (bufferSize != null) {
                            bufferSize.setLong(0, UnidbgStructure.calculateSize(TimeVal64.class));
                        }
                        if (buffer != null) {
                            fillKernelBootTime(buffer);
                        }
                        return 0;
                    case KERN_MAXFILESPERPROC:
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, 256);
                        }
                        return 0;
                    default:
                        log.info(msg);
                        if (log.isDebugEnabled()) {
                            createBreaker(emulator).debug();
                        }
                        break;
                }
                break;
            }
            case CTL_HW: {
                action = name.getInt(4);
                String msg = "sysctl CTL_HW action=" + action + ", namelen=" + namelen + ", buffer=" + buffer + ", bufferSize=" + bufferSize + ", set0=" + set0 + ", set1=" + set1;
                switch (action) {
                    case HW_MACHINE:
                        log.debug(msg);
                        String machine = getHwMachine();
                        if (bufferSize != null) {
                            bufferSize.setLong(0, machine.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, machine);
                        }
                        return 0;
                    case HW_MODEL:
                        log.debug(msg);
                        String model = "N53AP";
                        if (bufferSize != null) {
                            bufferSize.setLong(0, model.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, model);
                        }
                        return 0;
                    case HW_NCPU:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, getHwNcpu()); 
                        }
                        return 0;
                    case HW_PAGESIZE:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, emulator.getPageAlign());
                        }
                        return 0;
                    case HW_CPU_TYPE:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, CPU_TYPE_ARM);
                        }
                        return 0;
                    case HW_CPU_SUBTYPE:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, CPU_SUBTYPE_ARM_V7);
                        }
                        return 0;
                    case HW_CPU_FAMILY:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, 933271106);
                        }
                        return 0;
                    case HW_MEMSIZE:
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 8);
                        }
                        if (buffer != null) {
                            long memSize = 2L * 1024 * 1024 * 1024; 
                            buffer.setLong(0, memSize);
                        }
                        return 0;
                    case HW_CPU_FREQ:
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, 1800000000);
                        }
                        return 0;
                    case HW_CPU_MAX:
                    case HW_AVAILCPU:
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, getHwNcpu());
                        }
                        return 0;
                }
                log.info(msg);
                break;
            }
            case CTL_NET:
                action = name.getInt(4); 
                String msg = "sysctl CTL_NET action=" + action + ", namelen=" + namelen + ", buffer=" + buffer + ", bufferSize=" + bufferSize + ", set0=" + set0 + ", set1=" + set1;
                int family = name.getInt(0xc); 
                int rt = name.getInt(0x10);
                if(action == AF_ROUTE && rt == NET_RT_IFLIST) {
                    log.debug(msg);
                    try {
                        List<DarwinUtils.NetworkIF> networkIFList = DarwinUtils.getNetworkIFs(isVerbose());
                        int sizeOfSDL = UnidbgStructure.calculateSize(SockAddrDL.class);
                        int entrySize = UnidbgStructure.calculateSize(IfMsgHeader.class) + sizeOfSDL;
                        if (bufferSize != null) {
                            bufferSize.setLong(0, (long) entrySize * networkIFList.size());
                        }
                        if (buffer != null) {
                            Pointer pointer = buffer;
                            short index = 0;
                            for (DarwinUtils.NetworkIF networkIF : networkIFList) {
                                IfMsgHeader header = new IfMsgHeader(pointer);
                                SockAddrDL sockAddr = new SockAddrDL(pointer.share(header.size()));
                                header.ifm_msglen = (short) entrySize;
                                header.ifm_version = 5;
                                header.ifm_type = RTM_IFINFO;
                                header.ifm_addrs = 0x10;
                                header.ifm_index = ++index;
                                header.ifm_data.ifi_type = 6; 
                                header.pack();
                                byte[] networkInterfaceName = networkIF.networkInterface.getName().getBytes();
                                sockAddr.sdl_len = (byte) sizeOfSDL;
                                sockAddr.sdl_family = AF_LINK;
                                sockAddr.sdl_index = index;
                                sockAddr.sdl_type = 6; 
                                sockAddr.sdl_nlen = (byte) networkInterfaceName.length;
                                System.arraycopy(networkInterfaceName, 0, sockAddr.sdl_data, 0, networkInterfaceName.length);
                                byte[] macAddress = networkIF.networkInterface.getHardwareAddress();
                                sockAddr.sdl_alen = (byte) macAddress.length;
                                System.arraycopy(macAddress, 0, sockAddr.sdl_data, networkInterfaceName.length, macAddress.length);
                                sockAddr.pack();
                                pointer = pointer.share(entrySize);
                            }
                        }
                        return 0;
                    } catch (SocketException e) {
                        throw new IllegalStateException(e);
                    }
                }
                log.info("{}, family={}, rt={}", msg, family, rt);
                if (log.isDebugEnabled()) {
                    createBreaker(emulator).debug();
                }
            default:
                log.info("sysctl top={}, namelen={}, buffer={}, bufferSize={}, set0={}, set1={}", name.getInt(0), namelen, buffer, bufferSize, set0, set1);
                break;
        }
        return 1;
    }
    @Override
    protected void fillKernelBootTime(Pointer buffer) {
        long currentTimeMillis = bootTime;
        long tv_sec = currentTimeMillis / 1000;
        long tv_usec = (currentTimeMillis % 1000) * 1000 + (bootTime / 7 % 1000);
        TimeVal64 timeVal = new TimeVal64(buffer);
        timeVal.tv_sec = tv_sec;
        timeVal.tv_usec = tv_usec;
        timeVal.pack();
    }
    private long open_dprotected_np(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        int flags = context.getIntArg(1);
        int _class = context.getIntArg(2);
        int dpflags = context.getIntArg(3);
        int mode = context.getIntArg(4);
        String pathname = path.getString(0);
        int fd = open(emulator, pathname, flags);
        if (log.isDebugEnabled()) {
            log.debug("open_dprotected_np path={}, flags=0x{}, class={}, dpflags=0x{}, mode=0x{}", pathname, Integer.toHexString(flags), _class, Integer.toHexString(dpflags), Integer.toHexString(mode));
        }
        return fd;
    }
    private long getattrlist(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        Pointer attrListPointer = context.getPointerArg(1);
        UnidbgPointer attrBuf = context.getPointerArg(2);
        int attrBufSize = context.getIntArg(3);
        int options = context.getIntArg(4);
        String pathname = path.getString(0);
        AttrList attrList = new AttrList(attrListPointer);
        attrBuf.setSize(attrBufSize);
        String msg = "getattrlist path=" + pathname + ", attrList=" + attrList + ", attrBuf=" + attrBuf + ", attrBufSize=" + attrBufSize + ", options=0x" + Integer.toHexString(options);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.getattrlist(attrList, attrBuf, attrBufSize);
            if (ret != 0) {
                log.info("{}, ret={}", msg, ret);
                if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
                    createBreaker(emulator).debug();
                }
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("{}, ret={}", msg, ret);
                }
            }
            return ret;
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.EEXIST);
        return -1;
    }
    private long setattrlist(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        Pointer attrListPointer = context.getPointerArg(1);
        UnidbgPointer attrBuf = context.getPointerArg(2);
        int attrBufSize = context.getIntArg(3);
        int options = context.getIntArg(4);
        String pathname = path.getString(0);
        AttrList attrList = new AttrList(attrListPointer);
        attrBuf.setSize(attrBufSize);
        String msg = "setattrlist path=" + pathname + ", attrList=" + attrList + ", attrBuf=" + attrBuf + ", attrBufSize=" + attrBufSize + ", options=0x" + Integer.toHexString(options);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.setattrlist(attrList, attrBuf, attrBufSize);
            if (ret != 0) {
                log.info("{}, ret={}", msg, ret);
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("{}, ret={}, result={}", msg, ret, result);
                }
            }
            return ret;
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.EACCES);
        log.info(msg);
        return -1;
    }
    private long getxattr(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        Pointer name = context.getPointerArg(1);
        UnidbgPointer value = context.getPointerArg(2);
        int size = context.getIntArg(3);
        int position = context.getIntArg(4);
        int options = context.getIntArg(5);
        String pathname = path.getString(0);
        if (position != 0 || (options & XATTR_CREATE) != 0 || (options & XATTR_REPLACE) != 0) {
            log.info("getxattr path={}, name={}, value={}, size={}, position={}, options=0x{}", pathname, name.getString(0), value, size, position, Integer.toHexString(options));
            return -1;
        }
        if (value != null) {
            value.setSize(size);
        }
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.getxattr(emulator, name.getString(0), value, size);
            if (ret == -1) {
                log.info("getxattr path={}, name={}, value={}, size={}, position={}, options=0x{}", pathname, name.getString(0), value, size, position, Integer.toHexString(options));
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("getxattr path={}, name={}, value={}, size={}, position={}, options=0x{}", pathname, name.getString(0), value, size, position, Integer.toHexString(options));
                }
            }
            return ret;
        } else {
            log.info("getxattr path={}, name={}, value={}, size={}, position={}, options=0x{}", pathname, name.getString(0), value, size, position, Integer.toHexString(options));
            emulator.getMemory().setErrno(UnixEmulator.ENOENT);
            return -1;
        }
    }
    private long removexattr(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        Pointer name = context.getPointerArg(1);
        int options = context.getIntArg(2);
        String pathname = path.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.removexattr(name.getString(0));
            if (ret == -1) {
                log.info("removexattr path={}, name={}, options=0x{}", pathname, name.getString(0), Integer.toHexString(options));
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("removexattr path={}, name={}, options=0x{}", pathname, name.getString(0), Integer.toHexString(options));
                }
            }
            return ret;
        } else {
            log.info("removexattr path={}, name={}, options=0x{}, result={}", pathname, name.getString(0), Integer.toHexString(options), result);
            emulator.getMemory().setErrno(UnixEmulator.ENOENT);
            return -1;
        }
    }
    private long setxattr(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        Pointer name = context.getPointerArg(1);
        Pointer value = context.getPointerArg(2);
        int size = context.getIntArg(3);
        int position = context.getIntArg(4);
        int options = context.getIntArg(5);
        String pathname = path.getString(0);
        if (position != 0 || (options & XATTR_CREATE) != 0 || (options & XATTR_REPLACE) != 0) {
            log.info("setxattr path={}, name={}, value={}, size={}, position={}, options=0x{}", pathname, name.getString(0), value, size, position, Integer.toHexString(options));
            return -1;
        }
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.setxattr(name.getString(0), value.getByteArray(0, size));
            if (ret == -1) {
                log.info("setxattr path={}, name={}, value={}, size={}, position={}, options=0x{}", pathname, name.getString(0), value, size, position, Integer.toHexString(options));
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("setxattr path={}, name={}, value={}, size={}, position={}, options=0x{}", pathname, name.getString(0), value, size, position, Integer.toHexString(options));
                }
            }
            return ret;
        } else {
            log.info("setxattr path={}, name={}, value={}, size={}, position={}, options=0x{}", pathname, name.getString(0), value, size, position, Integer.toHexString(options));
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    private long fsetxattr(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer name = context.getPointerArg(1);
        Pointer value = context.getPointerArg(2);
        int size = context.getIntArg(3);
        int position = context.getIntArg(4);
        int options = context.getIntArg(5);
        DarwinFileIO io = fdMap.get(fd);
        if (position != 0 || (options & XATTR_CREATE) != 0 || (options & XATTR_REPLACE) != 0) {
            log.info("fsetxattr fd={}, name={}, value={}, size={}, position={}, options=0x{}", fd, name.getString(0), value, size, position, Integer.toHexString(options));
            return -1;
        }
        if (io != null) {
            int ret = io.setxattr(name.getString(0), value.getByteArray(0, size));
            if (ret == -1) {
                log.info("fsetxattr fd={}, name={}, value={}, size={}, position={}, options=0x{}", fd, name.getString(0), value, size, position, Integer.toHexString(options));
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("fsetxattr fd={}, name={}, value={}, size={}, position={}, options=0x{}", fd, name.getString(0), value, size, position, Integer.toHexString(options));
                }
            }
            return ret;
        }
        log.info("fsetxattr fd={}, name={}, value={}, size={}, position={}, options=0x{}", fd, name.getString(0), value, size, position, Integer.toHexString(options));
        return 0;
    }
    private int _kernelrpc_mach_vm_deallocate_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int target = context.getIntArg(0);
        long address = context.getLongArg(1);
        long size = context.getLongArg(2);
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_vm_deallocate_trap target={}, address=0x{}, size=0x{}", target, Long.toHexString(address), Long.toHexString(size));
        } else {
            Logger log = LoggerFactory.getLogger("com.github.unidbg.ios.malloc");
            if (log.isDebugEnabled()) {
                log.debug("_kernelrpc_mach_vm_deallocate_trap target=" + target + ", address=0x" + Long.toHexString(address) + ", size=0x" + Long.toHexString(size) + ", lr=" + context.getLRPointer());
            }
        }
        if (size > 0) {
            emulator.getMemory().munmap(address, (int) size);
        }
        return 0;
    }
    private int _kernelrpc_mach_vm_protect_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int target = context.getIntArg(0);
        long address = context.getLongArg(1);
        long size = context.getLongArg(2);
        int set_maximum = context.getIntArg(3);
        int new_protection = context.getIntArg(4);
        long alignedLength = ARM.alignSize(size, emulator.getPageAlign());
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_vm_protect_trap target={}, address=0x{}, size=0x{}, set_maximum={}, new_protection=0x{}", target, Long.toHexString(address), Long.toHexString(size), set_maximum, Integer.toHexString(new_protection));
        }
        if (address % emulator.getPageAlign() != 0) {
            throw new UnsupportedOperationException("address=0x" + Long.toHexString(address) + ", size=0x" + Long.toHexString(size));
        }
        return emulator.getMemory().mprotect(address, (int) alignedLength, new_protection);
    }
    private int _kernelrpc_mach_vm_map_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int target = context.getIntArg(0);
        Pointer address = context.getPointerArg(1);
        long size = context.getLongArg(2);
        long mask = context.getLongArg(3);
        int flags = context.getIntArg(4);
        int cur_protection = context.getIntArg(5);
        int tag = flags >> 24;
        boolean anywhere = (flags & MachO.VM_FLAGS_ANYWHERE) != 0;
        if (!anywhere) {
            throw new BackendException("_kernelrpc_mach_vm_map_trap fixed");
        }
        MachOLoader loader = (MachOLoader) emulator.getMemory();
        Pointer value = address.getPointer(0);
        UnidbgPointer pointer;
        if (mask != 0) {
            pointer = UnidbgPointer.pointer(emulator, loader.allocate(size, mask));
        } else {
            pointer = loader.mmap((int) size, cur_protection);
        }
        String msg = "_kernelrpc_mach_vm_map_trap target=" + target + ", address=" + address + ", value=" + value + ", size=0x" + Long.toHexString(size) + ", mask=0x" + Long.toHexString(mask) + ", flags=0x" + Long.toHexString(flags) + ", cur_protection=" + cur_protection + ", pointer=" + pointer + ", anywhere=true, tag=0x" + Integer.toHexString(tag);
        if (log.isDebugEnabled()) {
            log.debug(msg);
        } else {
            Logger log = LoggerFactory.getLogger("com.github.unidbg.ios.malloc");
            if (log.isDebugEnabled()) {
                log.debug(msg);
            }
        }
        address.setPointer(0, pointer);
        return 0;
    }
    private int _kernelrpc_mach_vm_allocate_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int target = context.getIntArg(0);
        Pointer address = context.getPointerArg(1);
        long size = context.getLongArg(2);
        int flags = context.getIntArg(3);
        int tag = flags >> 24;
        boolean anywhere = (flags & MachO.VM_FLAGS_ANYWHERE) != 0;
        if (!anywhere) {
            long start = address.getLong(0);
            long ret = emulator.getMemory().mmap2(start, (int) size, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE, MAP_MY_FIXED, -1, 0);
            if (ret == 0) {
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_vm_allocate_trap fixed, address={}, size={}, flags=0x{}", address.getPointer(0), size, Integer.toHexString(flags));
                }
                if (tag != MachO.VM_MEMORY_REALLOC) {
                    throw new IllegalStateException("_kernelrpc_mach_vm_allocate_trap fixed, address=" + address.getPointer(0) + ", size=" + size + ", flags=0x" + Integer.toHexString(flags) + ", tag=" + tag);
                }
                return -1;
            }
            Pointer pointer = address.getPointer(0);
            pointer.write(0, new byte[(int) size], 0, (int) size);
            if (log.isDebugEnabled()) {
                log.debug("_kernelrpc_mach_vm_allocate_trap fixed, address={}, size={}, flags=0x{}, anywhere=false", pointer, size, Integer.toHexString(flags));
            }
            return 0;
        }
        Pointer value = address.getPointer(0);
        UnidbgPointer pointer = emulator.getMemory().mmap((int) size, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE);
        pointer.write(0, new byte[(int) size], 0, (int) size);
        address.setPointer(0, pointer);
        String msg = "_kernelrpc_mach_vm_allocate_trap target=" + target + ", address=" + address + ", value=" + value + ", size=0x" + Long.toHexString(size) + ", flags=0x" + Integer.toHexString(flags) + ", pointer=" + pointer + ", anywhere=true, tag=0x" + Integer.toHexString(tag);
        if (log.isDebugEnabled()) {
            log.debug(msg);
        } else {
            Logger log = LoggerFactory.getLogger("com.github.unidbg.ios.malloc");
            if (log.isDebugEnabled()) {
                log.debug(msg);
            }
        }
        return 0;
    }
    private int _kernelrpc_mach_port_deallocate_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int task = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).intValue();
        int name = backend.reg_read(Arm64Const.UC_ARM64_REG_X1).intValue();
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_deallocate_trap task={}, name={}", task, name);
        }
        if (verbose) {
            System.out.printf("mach_port_deallocate %d from %s%n", name, emulator.getContext().getLRPointer());
        }
        return 0;
    }
    private int _workq_open(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        if (log.isDebugEnabled()) {
            log.debug("_workq_open LR={}", context.getLRPointer());
        }
        if (LoggerFactory.getLogger(AbstractEmulator.class).isTraceEnabled()) {
            createBreaker(emulator).debug();
        }
        return 0;
    }
    private int _workq_kernreturn(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int options = context.getIntArg(0);
        Pointer item = context.getPointerArg(1);
        int arg2 = context.getIntArg(2);
        int arg3 = context.getIntArg(3);
        if (log.isDebugEnabled()) {
            log.debug("_workq_kernreturn options=0x{}, item={}, arg2={}, arg3=0x{}, LR={}", Integer.toHexString(options), item, arg2, Integer.toHexString(arg3), context.getLRPointer());
        }
        if (LoggerFactory.getLogger(AbstractEmulator.class).isTraceEnabled()) {
            createBreaker(emulator).debug();
        }
        return 0;
    }
    private int mach_msg_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        RegisterContext context = emulator.getContext();
        UnidbgPointer msg = context.getPointerArg(0);
        int option = context.getIntArg(1);
        int send_size = context.getIntArg(2);
        int rcv_size = context.getIntArg(3);
        int rcv_name = context.getIntArg(4);
        int timeout = context.getIntArg(5);
        int notify = context.getIntArg(6);
        msg.setSize(Math.max(send_size, rcv_size));
        final MachMsgHeader header = new MachMsgHeader(msg);
        header.unpack();
        if (log.isDebugEnabled()) {
            log.debug("mach_msg_trap msg={}, option=0x{}, send_size={}, rcv_size={}, rcv_name={}, timeout={}, notify={}, LR={}, header={}", msg, Integer.toHexString(option), send_size, rcv_size, rcv_name, timeout, notify, context.getLRPointer(), header);
        }
        final UnidbgPointer request = (UnidbgPointer) msg.share(header.size());
        switch (header.msgh_id) {
            case 3409: 
            {
                TaskGetSpecialPortRequest args = new TaskGetSpecialPortRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("task_get_special_port request={}", args);
                }
                if (args.which == TASK_BOOTSTRAP_PORT) {
                    TaskGetSpecialPortReply reply = new TaskGetSpecialPortReply(request);
                    reply.unpack();
                    header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
                    header.msgh_size = header.size() + reply.size();
                    header.msgh_remote_port = header.msgh_local_port;
                    header.msgh_local_port = 0;
                    header.msgh_id += 100; 
                    header.pack();
                    reply.body.msgh_descriptor_count = 1;
                    reply.port.name = BOOTSTRAP_PORT; 
                    reply.port.pad1 = 0;
                    reply.port.pad2 = 0;
                    reply.port.disposition = 17; 
                    reply.port.type = MACH_MSG_PORT_DESCRIPTOR;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("task_get_special_port reply={}", reply);
                    }
                    if (verbose) {
                        System.out.printf("task_get_special_port %d from %s%n", BOOTSTRAP_PORT, emulator.getContext().getLRPointer());
                    }
                    return MACH_MSG_SUCCESS;
                }
            }
            case 200: 
            {
                HostInfoRequest args = new HostInfoRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("host_info args={}", args);
                }
                if (args.flavor == HOST_PRIORITY_INFO) {
                    HostInfoReply reply = new HostInfoReply(request);
                    reply.unpack();
                    header.msgh_bits &= 0xff;
                    header.msgh_size = header.size() + reply.size();
                    header.msgh_remote_port = header.msgh_local_port;
                    header.msgh_local_port = 0;
                    header.msgh_id += 100; 
                    header.pack();
                    reply.NDR = args.NDR;
                    reply.retCode = 0; 
                    reply.host_info_outCnt = 8;
                    reply.host_info_out.kernel_priority = 0;
                    reply.host_info_out.system_priority = 0;
                    reply.host_info_out.server_priority = 0;
                    reply.host_info_out.user_priority = 0;
                    reply.host_info_out.depress_priority = 0;
                    reply.host_info_out.idle_priority = 0;
                    reply.host_info_out.minimum_priority = 10;
                    reply.host_info_out.maximum_priority = -10;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("host_info reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
            }
            case 206: 
            {
                HostGetClockServiceRequest args = new HostGetClockServiceRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("host_get_clock_service args={}", args);
                }
                HostGetClockServiceReply reply = new HostGetClockServiceReply(request);
                reply.unpack();
                header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.clock_server.name = CLOCK_SERVER_PORT; 
                reply.clock_server.pad1 = 0;
                reply.clock_server.pad2 = 0;
                reply.clock_server.disposition = 17; 
                reply.clock_server.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("host_get_clock_service reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3418: 
            {
                SemaphoreCreateRequest args = new SemaphoreCreateRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("semaphore_create args={}", args);
                }
                SemaphoreCreateReply reply = new SemaphoreCreateReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.semaphore.name = ThreadLocalRandom.current().nextInt() & 0x7fffffff;
                reply.semaphore.pad1 = 0;
                reply.semaphore.pad2 = 0;
                reply.semaphore.disposition = 17; 
                reply.semaphore.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("semaphore_create reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 4807: 
            {
                VmCopy64Request args = new VmCopy64Request(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_copy args={}, lr={}", args, UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_LR));
                }
                byte[] data = backend.mem_read(args.source_address, args.size);
                emulator.getMemory().pointer(args.dest_address).write(data);
                VmCopyReply reply = new VmCopyReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 0;
                reply.NDR = args.NDR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_copy reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 4813: 
            {
                VmRemapRequest args = new VmRemapRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_vm_remap args={}, lr={}", args, UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_LR));
                }
                if ((args.anywhere != MachO.VM_FLAGS_OVERWRITE && args.anywhere != MachO.VM_FLAGS_FIXED) ||
                        args.mask != 0) {
                    throw new UnsupportedOperationException("_kernelrpc_mach_vm_remap anywhere=0x" + Integer.toHexString(args.anywhere) + ", mask=0x" + Long.toHexString(args.mask));
                }
                MachOLoader loader = (MachOLoader) emulator.getMemory();
                loader.remap(args);
                if (args.copy != 0) {
                    byte[] data = backend.mem_read(args.getSourceAddress(), args.size);
                    loader.pointer(args.target_address).write(data);
                }
                VmRemapReply reply = new VmRemapReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.retCode = 0;
                reply.target_address1 = (int) args.target_address;
                reply.target_address2 = (int) (args.target_address >> 32);
                reply.cur_protection = args.inheritance;
                reply.max_protection = args.inheritance;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_vm_remap reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 4815: 
            {
                VmRegionRecurse64Request args = new VmRegionRecurse64Request(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_region_recurse_64 args={}", args);
                }
                VmRegionRecurse64Reply reply = new VmRegionRecurse64Reply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                MemoryMap memoryMap = null;
                for (MemoryMap mm : emulator.getMemory().getMemoryMap()) {
                    if (args.getAddress() >= mm.base && args.getAddress() < mm.base + mm.size) {
                        memoryMap = mm;
                        break;
                    }
                }
                if (memoryMap == null) {
                    break;
                }
                reply.NDR = args.NDR;
                reply.retCode = 0; 
                reply.addressLow = (int) memoryMap.base;
                reply.addressHigh = (int) (memoryMap.base >> 32L);
                reply.sizeLow = (int) memoryMap.size;
                reply.sizeHigh = (int) (memoryMap.size >> 32L);
                reply.infoCnt = 7;
                reply.nestingDepth = args.nestingDepth;
                reply.info.protection = memoryMap.prot;
                reply.info.max_protection = memoryMap.prot;
                reply.info.inheritance = memoryMap.prot;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_region_recurse_64 reply={}, memoryMap={}", reply, memoryMap);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3413: { 
                TaskSetExceptionPortsRequest args = new TaskSetExceptionPortsRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("task_set_exception_ports args={}, lr={}", args, UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_LR));
                }
                TaskSetExceptionPortsReply reply = new TaskSetExceptionPortsReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.NDR = args.NDR;
                reply.retCode = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("task_set_exception_ports reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3414: 
            {
                TaskGetExceptionPortsRequest args = new TaskGetExceptionPortsRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("task_get_exception_ports args={}, lr={}", args, UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_LR));
                }
                TaskGetExceptionPortsReply reply = new TaskGetExceptionPortsReply(request);
                reply.unpack();
                header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                args.NDR.mig_vers = 0x20;
                reply.NDR = args.NDR;
                reply.retCode = 0;
                reply.header = new int[32];
                reply.reserved = new byte[0x100];
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("task_get_exception_ports reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3404: 
            {
                MachPortsLookupReply64 reply = new MachPortsLookupReply64(request);
                reply.unpack();
                header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
                header.msgh_size = 56;
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 1;
                reply.outPortLow = (int) request.toUIntPeer();
                reply.outPortHigh = (int) (request.peer >> 32L);
                reply.mask = 0x2110000;
                reply.cnt = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("mach_ports_lookup reply={}", reply);
                }
                if (verbose) {
                    System.out.printf("mach_ports_lookup from %s%n", emulator.getContext().getLRPointer());
                }
                return MACH_MSG_SUCCESS;
            }
            case 404: { 
                return vproc_mig_look_up2(request, header);
            }
            case 78945669: { 
                NotifyServerRegisterPlain64Request args = new NotifyServerRegisterPlain64Request(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    Pointer pointer = UnidbgPointer.pointer(emulator, args.nameLow | (long) args.nameHigh << 32L);
                    log.debug("notify_server_register_plain args={}, name={}", args, pointer == null ? null : new String(pointer.getByteArray(0, args.nameCnt), StandardCharsets.UTF_8));
                }
                NotifyServerRegisterPlainReply reply = new NotifyServerRegisterPlainReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.clientId = STATIC_PORT;
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_register_plain reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 78945681: { 
                NotifyServerGetStateRequest args = new NotifyServerGetStateRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_get_state args={}", args);
                }
                NotifyServerGetStateReply reply = new NotifyServerGetStateReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.version = 0;
                reply.pid = emulator.getPid();
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_get_state reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 78945679: { 
                NotifyServerCancelRequest args = new NotifyServerCancelRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_cancel args={}", args);
                }
                NotifyServerCancelReply reply = new NotifyServerCancelReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_cancel reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 78945670: { 
                NotifyServerRegisterCheck64Request args = new NotifyServerRegisterCheck64Request(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    Pointer pointer = UnidbgPointer.pointer(emulator, (args.nameLow & 0xffffffffL) | (long) args.nameHigh << 32L);
                    log.debug("notify_server_register_check args={}, name={}", args, pointer == null ? null : new String(pointer.getByteArray(0, args.namelen), StandardCharsets.UTF_8));
                }
                NotifyServerRegisterCheckReply reply = new NotifyServerRegisterCheckReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.shmsize = 0;
                reply.slot = 0;
                reply.clientId = STATIC_PORT;
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_register_check reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 118: { 
                AslServerMessageRequest args = new AslServerMessageRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("asl_server_message args={}", args);
                }
                return MACH_MSG_SUCCESS;
            }
            case 78945673: { 
                NotifyServerRegisterMachPort64Request args = new NotifyServerRegisterMachPort64Request(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    Pointer pointer = UnidbgPointer.pointer(emulator, args.nameLow | (long) args.nameHigh << 32L);
                    log.debug("notify_server_register_mach_port args={}, name={}", args, pointer == null ? null : new String(pointer.getByteArray(0, args.namelen), StandardCharsets.UTF_8));
                }
                NotifyServerRegisterMachPortReply reply = new NotifyServerRegisterMachPortReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.clientId = STATIC_PORT;
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_register_mach_port reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 205: { 
                MachPortReply reply = new MachPortReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.port.name = STATIC_PORT;
                reply.port.pad1 = 0;
                reply.port.pad2 = 0;
                reply.port.disposition = 17;
                reply.port.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("host_get_io_master reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 2873: { 
                IOServiceGetMatchingServiceRequest args = new IOServiceGetMatchingServiceRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("io_service_get_matching_service args={}, matching={}", args, args.getMatching());
                }
                MachPortReply reply = new MachPortReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.port.name = STATIC_PORT;
                reply.port.pad1 = 0;
                reply.port.pad2 = 0;
                reply.port.disposition = 17;
                reply.port.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("io_service_get_matching_service reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3218: { 
                MachPortSetAttributesRequest args = new MachPortSetAttributesRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_port_set_attributes args={}", args);
                }
                MachPortSetAttributesReply reply = new MachPortSetAttributesReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_port_set_attributes reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3201: { 
                MachPortTypeRequest args = new MachPortTypeRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_port_type args={}", args);
                }
                MachPortTypeReply reply = new MachPortTypeReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 0;
                reply.ptype = 0x70000;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_port_set_attributes reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 2868: { 
                IOServiceAddNotificationRequest args = new IOServiceAddNotificationRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("io_service_add_notification args={}, matching={}", args, args.getMatching());
                }
                MachPortReply reply = new MachPortReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.port.name = STATIC_PORT;
                reply.port.pad1 = 0;
                reply.port.pad2 = 0;
                reply.port.disposition = 17;
                reply.port.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("io_service_add_notification reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 4816: { 
                VmRegion64Request args = new VmRegion64Request(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_region_64 args={}", args);
                }
                if (args.flavor != VmRegion64Request.VM_REGION_BASIC_INFO_64) {
                    throw new UnsupportedOperationException("flavor=" + args.flavor);
                }
                VmRegion64Reply reply = new VmRegion64Reply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                MemoryMap memoryRegion = null;
                for (MemoryMap memoryMap : emulator.getMemory().getMemoryMap()) {
                    if (memoryMap.base >= args.address) {
                        memoryRegion = memoryMap;
                        break;
                    }
                }
                if (memoryRegion == null) {
                    header.setMsgBits(false);
                    header.msgh_size = 0x24;
                    header.pack();
                    reply.retCode1 = 1;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("vm_region_64 reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
                reply.NDR.mig_vers = 1;
                reply.NDR.int_rep = 0;
                reply.retCode2 = 0x110000;
                reply.outCnt = VmRegion64Request.VM_REGION_BASIC_INFO_COUNT_64;
                reply.address = memoryRegion.base;
                reply.size = memoryRegion.size;
                reply.info.protection = memoryRegion.prot;
                reply.info.max_protection = memoryRegion.prot;
                reply.info.inheritance = 0;
                reply.info.shared = false;
                reply.info.reserved = false;
                reply.info.offset = 0;
                reply.info.behavior = 0;
                reply.info.user_wired_count = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_region_64 reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3405: { 
                TaskInfoRequest args = new TaskInfoRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("task_info args={}", args);
                }
                if (args.flavor == TaskInfoRequest.TASK_DYLD_INFO) {
                    TaskDyldInfoReply reply = new TaskDyldInfoReply(request);
                    reply.unpack();
                    header.setMsgBits(false);
                    header.msgh_size = header.size() + reply.size();
                    header.msgh_remote_port = header.msgh_local_port;
                    header.msgh_local_port = 0;
                    header.msgh_id += 100; 
                    header.pack();
                    reply.retCode = 0;
                    reply.task_info_outCnt = UnidbgStructure.calculateSize(TaskDyldInfo.class) / 4;
                    reply.dyldInfo.allocateAllImage(emulator);
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("task_info TASK_DYLD_INFO reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
                if (args.flavor == TaskInfoRequest.TASK_VM_INFO) {
                    TaskVmInfoReply64 reply = new TaskVmInfoReply64(request);
                    reply.unpack();
                    header.setMsgBits(false);
                    header.msgh_size = header.size() + reply.size();
                    header.msgh_remote_port = header.msgh_local_port;
                    header.msgh_local_port = 0;
                    header.msgh_id += 100; 
                    header.pack();
                    reply.retCode = 0;
                    reply.task_info_outCnt = UnidbgStructure.calculateSize(TaskVmInfo64.class) / 4;
                    reply.vmInfo.virtual_size = 0x100000000L;
                    reply.vmInfo.region_count = emulator.getMemory().getMemoryMap().size();
                    reply.vmInfo.page_size = emulator.getPageAlign();
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("task_info TASK_VM_INFO reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
                if (args.flavor == TaskInfoRequest.TASK_BASIC_INFO_64_2) {
                    TaskBasicInfoReply64V2 reply = new TaskBasicInfoReply64V2(request);
                    reply.unpack();
                    header.setMsgBits(false);
                    header.msgh_size = header.size() + reply.size();
                    header.msgh_remote_port = header.msgh_local_port;
                    header.msgh_local_port = 0;
                    header.msgh_id += 100; 
                    header.pack();
                    reply.retCode = 0;
                    reply.task_info_outCnt = UnidbgStructure.calculateSize(TaskBasicInfoReply64V2.class) / 4;
                    reply.basicInfo.suspendCount = 0;
                    reply.basicInfo.virtualSize = 1024 * 1024 * 1024;
                    reply.basicInfo.residentSize = 100 * 1024 * 1024;
                    reply.basicInfo.userTime = 0;
                    reply.basicInfo.systemTime = 0;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("task_info TASK_BASIC_INFO_64_2 reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
                log.warn("task_info flavor={}", args.flavor);
                if (LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
                    createBreaker(emulator).debug();
                }
                return -1;
            }
            case 78: { 
                if (log.isDebugEnabled()) {
                    log.debug("_dispatch_send_wakeup_runloop_thread");
                }
                return MACH_MSG_SUCCESS;
            }
            case 3402: { 
                TaskThreadsReply64 reply = new TaskThreadsReply64(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.act_list = UnidbgPointer.nativeValue(request);
                reply.mask = 0x2110000;
                reply.act_listCnt = 0;
                reply.pack();
                log.debug("task_threads reply={}", reply);
                return MACH_MSG_SUCCESS;
            }
            case 1000: { 
                ClockGetTimeReply reply = new ClockGetTimeReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                long currentTimeMillis = System.currentTimeMillis();
                long nanoTime = System.nanoTime();
                long tv_sec = currentTimeMillis / 1000;
                long tv_usec = (currentTimeMillis % 1000) * 1000 + nanoTime % 1000;
                reply.retCode = 0;
                reply.tv_sec = (int) tv_sec;
                reply.tv_nsec = (int) tv_usec;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("clock_get_time reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 4808: 
            {
                VmReadOverwriteRequest args = new VmReadOverwriteRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_read_overwrite args={}, lr={}", args, UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_LR));
                }
                byte[] data = backend.mem_read(args.address, args.size);
                emulator.getMemory().pointer(args.data).write(data);
                VmReadOverwriteReply reply = new VmReadOverwriteReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 0;
                reply.NDR = args.NDR;
                reply.outSize = args.size;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_read_overwrite reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3603: { 
                ThreadStateRequest args = new ThreadStateRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_thread_get_state args={}", request);
                }
                ThreadStateReply64 reply = new ThreadStateReply64(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                if (args.flavor != ThreadStateRequest.ARM_THREAD_STATE64) {
                    reply.retCode = 4;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("_thread_get_state reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
                reply.retCode = 0;
                reply.outCnt = ThreadStateRequest.ARM_THREAD_STATE64_COUNT;
                for (int reg = Arm64Const.UC_ARM64_REG_X0; reg <= Arm64Const.UC_ARM64_REG_X28; reg++) {
                    reply.state.__x[reg - Arm64Const.UC_ARM64_REG_X0] = backend.reg_read(reg).longValue();
                }
                reply.state.__fp = backend.reg_read(Arm64Const.UC_ARM64_REG_FP).longValue();
                reply.state.__lr = backend.reg_read(Arm64Const.UC_ARM64_REG_LR).longValue();
                reply.state.__sp = backend.reg_read(Arm64Const.UC_ARM64_REG_SP).longValue();
                reply.state.__pc = backend.reg_read(Arm64Const.UC_ARM64_REG_PC).longValue();
                reply.state.__cpsr = backend.reg_read(Arm64Const.UC_ARM64_REG_NZCV).intValue();
                reply.state.__pad = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_thread_get_state reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3612: { 
                ThreadInfoRequest args = new ThreadInfoRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_thread_info args={}", args);
                }
                final int THREAD_BASIC_INFO = 3;
                if (args.flavor != THREAD_BASIC_INFO) {
                    throw new UnsupportedOperationException();
                }
                ThreadBasicInfoReply reply = new ThreadBasicInfoReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                final int THREAD_BASIC_INFO_COUNT = 10;
                final int POLICY_TIMESHARE = 1;
                final int TH_STATE_RUNNING = 1;
                reply.retCode = 0;
                reply.outCnt = THREAD_BASIC_INFO_COUNT;
                reply.info.user_time.tv_sec = 0;
                reply.info.user_time.tv_usec = 177546;
                reply.info.system_time.tv_sec = 0;
                reply.info.system_time.tv_usec = 0;
                reply.info.cpu_usage = 343;
                reply.info.policy = POLICY_TIMESHARE;
                reply.info.run_state = TH_STATE_RUNNING;
                reply.info.flags = 0;
                reply.info.suspend_count = 0;
                reply.info.sleep_time = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_thread_info reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 4811: { 
                MachVmMapRequest args = new MachVmMapRequest(request);
                args.unpack();
                log.debug("_kernelrpc_mach_vm_map args={}", args);
                MachVmMapReply reply = new MachVmMapReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.NDR = args.NDR;
                reply.retCode = 0;
                {
                    MachOLoader loader = (MachOLoader) emulator.getMemory();
                    UnidbgPointer pointer;
                    if (args.mask != 0) {
                        pointer = UnidbgPointer.pointer(emulator, loader.allocate(args.size, args.mask));
                    } else {
                        pointer = loader.mmap((int) args.size, args.cur_protection);
                    }
                    reply.address = UnidbgPointer.nativeValue(pointer);
                }
                reply.pack();
                log.debug("_kernelrpc_mach_vm_map reply={}, header={}", reply, header);
                return MACH_MSG_SUCCESS;
            }
            case 4817: { 
                MakeMemoryEntryRequest args = new MakeMemoryEntryRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("mach_make_memory_entry_64 args={}", args);
                }
                MakeMemoryEntryReply reply = new MakeMemoryEntryReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.status = 1;
                reply.object_handle = 0;
                reply.retCode = 0;
                reply.flags = 0x110000;
                reply.NDR = args.NDR;
                reply.outSize = args.size;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("mach_make_memory_entry_64 reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 4818: { 
                PurgableControlRequest args = new PurgableControlRequest(request);
                args.unpack();
                log.debug("vm_purgable_control args={}", args);
                PurgableControlReply reply = new PurgableControlReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                final int VM_PURGABLE_EMPTY = 2;
                reply.NDR = args.NDR;
                reply.retCode = 0;
                reply.state = VM_PURGABLE_EMPTY;
                reply.pack();
                log.debug("vm_purgable_control reply={}, header={}", reply, header);
                return MACH_MSG_SUCCESS;
            }
            case 216: 
                if (host_statistics(request, header)) {
                    return MACH_MSG_SUCCESS;
                }
            default:
                log.warn("mach_msg_trap header={}, size={}, lr={}", header, header.size(), UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_LR));
                if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
                    createBreaker(emulator).debug();
                }
                break;
        }
        return -1;
    }
    private static final int BOOTSTRAP_PORT = 11;
    private static final int CLOCK_SERVER_PORT = 13;
    private int task_self_trap() {
        log.debug("task_self_trap");
        return 1;
    }
    private int host_self_trap() {
        log.debug("host_self_trap");
        return 2;
    }
    private int thread_self_trap() {
        log.debug("thread_self_trap");
        return 3;
    }
    private int mach_reply_port() {
        log.debug("mach_reply_port");
        return 4;
    }
    private long audit_session_self() {
        log.debug("audit_session_self");
        return 5;
    }
    private int kevent64(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int kq = context.getIntArg(0);
        Pointer changelist = context.getPointerArg(1);
        int nchanges = context.getIntArg(2);
        Pointer eventlist = context.getPointerArg(3);
        int nevents = context.getIntArg(4);
        int flags = context.getIntArg(5);
        Pointer timeout = context.getPointerArg(6);
        return kevent64(emulator, kq, changelist, nchanges, eventlist, nevents, flags, TimeSpec.createTimeSpec(emulator, timeout));
    }
    private int sigprocmask(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int how = context.getIntArg(0);
        Pointer set = context.getPointerArg(1);
        Pointer oldset = context.getPointerArg(2);
        return sigprocmask(emulator, how, set, oldset);
    }
    private int sigaltstack(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer nstack = context.getPointerArg(0);
        Pointer ostack = context.getPointerArg(1);
        if (log.isDebugEnabled()) {
            log.debug("sigaltstack nstack={}, ostack={}", nstack, ostack);
        }
        return 0;
    }
    private long ioctl(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        long request = context.getLongArg(1);
        long argp = context.getLongArg(2);
        if (log.isDebugEnabled()) {
            log.debug("ioctl fd={}, request=0x{}, argp=0x{}", fd, Long.toHexString(request), Long.toHexString(argp));
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int ret = file.ioctl(emulator, request, argp);
        if (ret == -1) {
            emulator.getMemory().setErrno(UnixEmulator.ENOTTY);
        }
        return ret;
    }
    protected long gettimeofday(Emulator<?> emulator) {
        EditableArm64RegisterContext context = emulator.getContext();
        long currentTimeMillis = System.currentTimeMillis();
        long nanoTime = System.nanoTime();
        long tv_sec = currentTimeMillis / 1000;
        long tv_usec = (currentTimeMillis % 1000) * 1000 + nanoTime % 1000;
        context.setXLong(1, tv_usec);
        Pointer tv = context.getPointerArg(0);
        if (tv != null) {
            TimeVal64 timeVal = new TimeVal64(tv);
            timeVal.tv_sec = tv_sec;
            timeVal.tv_usec = tv_usec;
            timeVal.pack();
        }
        if (log.isDebugEnabled()) {
            log.debug("gettimeofday tv_sec={}, tv_usec={}", tv_sec, tv_usec);
        }
        return tv_sec;
    }
    private long writev(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer iov = context.getPointerArg(1);
        int iovcnt = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            for (int i = 0; i < iovcnt; i++) {
                Pointer iov_base = iov.getPointer(i * 16L);
                long iov_len = iov.getLong(i * 16L + 8);
                byte[] data = iov_base.getByteArray(0, (int) iov_len);
                Inspector.inspect(data, "writev fd=" + fd + ", iov=" + iov + ", iov_base=" + iov_base);
            }
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int count = 0;
        for (int i = 0; i < iovcnt; i++) {
            Pointer iov_base = iov.getPointer(i * 16L);
            long iov_len = iov.getLong(i * 16L + 8);
            byte[] data = iov_base.getByteArray(0, (int) iov_len);
            count += file.write(data);
        }
        return count;
    }
    private int rename(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer oldpath = context.getPointerArg(0);
        Pointer newpath = context.getPointerArg(1);
        String oldPath = oldpath.getString(0);
        String newPath = newpath.getString(0);
        int ret = emulator.getFileSystem().rename(oldPath, newPath);
        if (ret != 0) {
            log.info("rename oldPath={}, newPath={}", oldPath, newPath);
        } else {
            log.debug("rename oldPath={}, newPath={}", oldPath, newPath);
        }
        return 0;
    }
    private long mach_absolute_time() {
        long nanoTime = System.nanoTime();
        if (log.isDebugEnabled()) {
            log.debug("mach_absolute_time nanoTime={}", nanoTime);
        }
        return nanoTime;
    }
    private int close_NOCANCEL(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).intValue();
        if (log.isDebugEnabled()) {
            log.debug("close_NOCANCEL fd={}", fd);
        }
        return close(emulator, fd);
    }
    private int read_NOCANCEL(Emulator<?> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(offset);
        Pointer buffer = context.getPointerArg(offset + 1);
        int count = context.getIntArg(offset + 2);
        if (log.isDebugEnabled()) {
            log.debug("read_NOCANCEL fd={}, buffer={}, count={}, LR={}", fd, buffer, count, context.getLRPointer());
        }
        return read(emulator, fd, buffer, count);
    }
    private int getpid(Emulator<?> emulator) {
        int pid = emulator.getPid();
        log.debug("getpid pid={}", pid);
        return pid;
    }
    private int sendto(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer buf = context.getPointerArg(1);
        int len = context.getIntArg(2);
        int flags = context.getIntArg(3);
        Pointer dest_addr = context.getPointerArg(4);
        int addrlen = context.getIntArg(5);
        return sendto(emulator, sockfd, buf, len, flags, dest_addr, addrlen);
    }
    private int connect(Emulator<?> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(offset);
        Pointer addr = context.getPointerArg(offset + 1);
        int addrlen = context.getIntArg(offset + 2);
        return connect(emulator, sockfd, addr, addrlen);
    }
    private int sigaction(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int signum = context.getIntArg(0);
        Pointer act = context.getPointerArg(1);
        Pointer oldact = context.getPointerArg(2);
        return sigaction(emulator, signum, act, oldact);
    }
    private int dup2(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int oldfd = context.getIntArg(0);
        int newfd = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("dup2 oldfd={}, newfd={}", oldfd, newfd);
        }
        FileIO old = fdMap.get(oldfd);
        if (old == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (oldfd == newfd) {
            return newfd;
        }
        DarwinFileIO _new = fdMap.remove(newfd);
        if (_new != null) {
            _new.close();
        }
        _new = (DarwinFileIO) old.dup2();
        fdMap.put(newfd, _new);
        return newfd;
    }
    private int fcntl(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int cmd = context.getIntArg(1);
        long arg = context.getLongArg(2);
        return fcntl(emulator, fd, cmd, arg);
    }
    private int fsync(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("fsync fd={}", fd);
        }
        return 0;
    }
    private long mmap(Emulator<?> emulator) {
        Arm64RegisterContext context = emulator.getContext();
        UnidbgPointer addr = context.getXPointer(0);
        int length = context.getXInt(1);
        int prot = context.getXInt(2);
        int flags = context.getXInt(3);
        int fd = context.getXInt(4);
        long offset = context.getXLong(5);
        int tag = fd >>> 24;
        if (tag != 0) {
            fd = -1;
        }
        boolean warning = length >= 0x10000000;
        long base = emulator.getMemory().mmap2(addr == null ? 0 : addr.peer, length, prot, flags, fd, (int) offset);
        String msg = "mmap addr=" + addr + ", base=0x" + Long.toHexString(base) + ", length=" + length + ", prot=0x" + Integer.toHexString(prot) + ", flags=0x" + Integer.toHexString(flags) + ", fd=" + fd + ", offset=" + offset + ", tag=" + tag + ", LR=" + context.getLRPointer();
        if (log.isDebugEnabled() || warning) {
            if (warning) {
                log.warn(msg);
            } else {
                log.debug(msg);
            }
        } else if(LoggerFactory.getLogger("com.github.unidbg.ios.malloc").isDebugEnabled()) {
            log.debug(msg);
        }
        return base;
    }
    private int socket(Emulator<?> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        int domain = context.getIntArg(offset);
        int type = context.getIntArg(offset + 1) & 0x7ffff;
        int protocol = context.getIntArg(offset + 2);
        if (log.isDebugEnabled()) {
            log.debug("socket domain={}, type={}, protocol={}", domain, type, protocol);
        }
        if (protocol == SocketIO.IPPROTO_ICMP) {
            throw new UnsupportedOperationException();
        }
        int fd;
        switch (domain) {
            case SocketIO.AF_UNSPEC:
                throw new UnsupportedOperationException();
            case SocketIO.AF_LOCAL:
                if (type == SocketIO.SOCK_DGRAM) {
                    fd = getMinFd();
                    fdMap.put(fd, new LocalDarwinUdpSocket(emulator));
                    return fd;
                }
                emulator.getMemory().setErrno(UnixEmulator.EACCES);
                return -1;
            case SocketIO.AF_INET:
            case SocketIO.AF_INET6:
                switch (type) {
                    case SocketIO.SOCK_STREAM:
                        fd = getMinFd();
                        fdMap.put(fd, new TcpSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_DGRAM:
                        fd = getMinFd();
                        fdMap.put(fd, new UdpSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_RAW:
                        throw new UnsupportedOperationException();
                }
                break;
        }
        throw new UnsupportedOperationException("socket domain=" + domain + ", type=" + type + ", protocol=" + protocol);
    }
    private int write(Emulator<?> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(offset);
        Pointer buffer = context.getPointerArg(offset + 1);
        int count = context.getIntArg(offset + 2);
        byte[] data = buffer.getByteArray(0, count);
        if (log.isDebugEnabled()) {
            log.debug("write fd={}, buffer={}, count={}", fd, buffer, count);
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.write(data);
    }
    private int mprotect(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        long address = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).longValue();
        long length = backend.reg_read(Arm64Const.UC_ARM64_REG_X1).longValue();
        int prot = backend.reg_read(Arm64Const.UC_ARM64_REG_X2).intValue();
        long alignedAddress = address / ARMEmulator.PAGE_ALIGN * ARMEmulator.PAGE_ALIGN; 
        long offset = address - alignedAddress;
        long alignedLength = ARM.alignSize(length + offset, emulator.getPageAlign());
        if (log.isDebugEnabled()) {
            log.debug("mprotect address=0x{}, alignedAddress=0x{}, offset={}, length={}, alignedLength={}, prot=0x{}", Long.toHexString(address), Long.toHexString(alignedAddress), offset, length, alignedLength, Integer.toHexString(prot));
        }
        return emulator.getMemory().mprotect(alignedAddress, (int) alignedLength, prot);
    }
    @Override
    protected DarwinFileIO createByteArrayFileIO(String pathname, int oflags, byte[] data) {
        return new ByteArrayFileIO(oflags, pathname, data);
    }
    @Override
    protected DarwinFileIO createDriverFileIO(Emulator<?> emulator, int oflags, String pathname) {
        return DriverFileIO.create(emulator, oflags, pathname);
    }
}
package com.github.unidbg;
import com.alibaba.fastjson.util.IOUtils;
import com.github.unidbg.arm.ARMSvcMemory;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BackendFactory;
import com.github.unidbg.arm.backend.ReadHook;
import com.github.unidbg.arm.backend.WriteHook;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.DebugServer;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.debugger.DebuggerType;
import com.github.unidbg.debugger.gdb.GdbStub;
import com.github.unidbg.debugger.ida.AndroidServer;
import com.github.unidbg.file.FileSystem;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.listener.TraceCodeListener;
import com.github.unidbg.listener.TraceReadListener;
import com.github.unidbg.listener.TraceSystemMemoryWriteListener;
import com.github.unidbg.listener.TraceWriteListener;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.MemoryWriteListener;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.thread.MainTask;
import com.github.unidbg.thread.PopContextException;
import com.github.unidbg.thread.RunnableTask;
import com.github.unidbg.thread.ThreadContextSwitchException;
import com.github.unidbg.thread.ThreadDispatcher;
import com.github.unidbg.thread.UniThreadDispatcher;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.ArmConst;
import java.io.DataOutput;
import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.management.ManagementFactory;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Stack;
public abstract class AbstractEmulator<T extends NewFileIO> implements Emulator<T>, MemoryWriteListener {
    private static final Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
    public static final long DEFAULT_TIMEOUT = 0;
    protected final Backend backend;
    private final int pid;
    protected long timeout = DEFAULT_TIMEOUT;
    private final RegisterContext registerContext;
    private final FileSystem<T> fileSystem;
    protected final SvcMemory svcMemory;
    private final Family family;
    protected final DateFormat dateFormat = new SimpleDateFormat("[HH:mm:ss SSS]");
    public AbstractEmulator(boolean is64Bit, String processName, long svcBase, int svcSize, File rootDir, Family family, Collection<BackendFactory> backendFactories) {
        super();
        this.family = family;
        File targetDir = new File("target");
        if (!targetDir.exists()) {
            targetDir = FileUtils.getTempDirectory();
        }
        if (rootDir == null) {
            rootDir = new File(targetDir, FileSystem.DEFAULT_ROOT_FS);
        }
        if (rootDir.isFile()) {
            throw new IllegalArgumentException("rootDir must be directory: " + rootDir);
        }
        if (!rootDir.exists() && !rootDir.mkdirs()) {
            throw new IllegalStateException("mkdirs failed: " + rootDir);
        }
        this.fileSystem = createFileSystem(rootDir);
        this.backend = BackendFactory.createBackend(this, is64Bit, backendFactories);
        this.processName = processName == null ? "unidbg" : processName;
        this.registerContext = createRegisterContext(backend);
        String name = ManagementFactory.getRuntimeMXBean().getName();
        String pid = name.split("@")[0];
        this.pid = Integer.parseInt(pid) & 0x7fff;
        this.svcMemory = new ARMSvcMemory(svcBase, svcSize, this);
        this.threadDispatcher = createThreadDispatcher();
        this.backend.onInitialize();
    }
    protected ThreadDispatcher createThreadDispatcher() {
        return new UniThreadDispatcher(this);
    }
    @Override
    public final int getPageAlign() {
        int pageSize = backend.getPageSize();
        if (pageSize == 0) {
            pageSize = getPageAlignInternal();
        }
        return pageSize;
    }
    protected abstract int getPageAlignInternal();
    @Override
    public Family getFamily() {
        return family;
    }
    public final SvcMemory getSvcMemory() {
        return svcMemory;
    }
    @Override
    public final FileSystem<T> getFileSystem() {
        return fileSystem;
    }
    protected abstract FileSystem<T> createFileSystem(File rootDir);
    @Override
    public boolean is64Bit() {
        return getPointerSize() == 8;
    }
    @Override
    public boolean is32Bit() {
        return getPointerSize() == 4;
    }
    protected abstract RegisterContext createRegisterContext(Backend backend);
    @SuppressWarnings("unchecked")
    @Override
    public <V extends RegisterContext> V getContext() {
        return (V) registerContext;
    }
    protected  abstract Memory createMemory(UnixSyscallHandler<T> syscallHandler, String[] envs);
    protected abstract Dlfcn createDyld(SvcMemory svcMemory);
    protected abstract UnixSyscallHandler<T> createSyscallHandler(SvcMemory svcMemory);
    protected abstract byte[] assemble(Iterable<String> assembly);
    private Debugger debugger;
    @Override
    public Debugger attach() {
        return attach(DebuggerType.CONSOLE);
    }
    @Override
    public Debugger attach(DebuggerType type) {
        if (debugger != null) {
            return debugger;
        }
        switch (type) {
            case GDB_SERVER:
                debugger = new GdbStub(this);
                break;
            case ANDROID_SERVER_V7:
                debugger = new AndroidServer(this, DebugServer.IDA_PROTOCOL_VERSION_V7);
                break;
            case CONSOLE:
            default:
                debugger = createConsoleDebugger();
                break;
        }
        if (debugger == null) {
            throw new UnsupportedOperationException();
        }
        this.backend.debugger_add(debugger, 1, 0, this);
        this.timeout = 0;
        return debugger;
    }
    protected abstract Debugger createConsoleDebugger();
    @Override
    public int getPid() {
        return pid;
    }
    @Override
    public final TraceHook traceRead(long begin, long end) {
        return traceRead(begin, end, null);
    }
    @Override
    public TraceHook traceRead(long begin, long end, TraceReadListener listener) {
        TraceMemoryHook hook = new TraceMemoryHook(true);
        if (listener != null) {
            hook.traceReadListener = listener;
        }
        backend.hook_add_new((ReadHook) hook, begin, end, this);
        return hook;
    }
    @Override
    public final TraceHook traceWrite(long begin, long end) {
        return traceWrite(begin, end, null);
    }
    private long traceSystemMemoryWriteBegin;
    private long traceSystemMemoryWriteEnd;
    private boolean traceSystemMemoryWrite;
    private TraceSystemMemoryWriteListener traceSystemMemoryWriteListener;
    @Override
    public void setTraceSystemMemoryWrite(long begin, long end, TraceSystemMemoryWriteListener listener) {
        traceSystemMemoryWrite = true;
        traceSystemMemoryWriteBegin = begin;
        traceSystemMemoryWriteEnd = end;
        traceSystemMemoryWriteListener = listener;
    }
    @Override
    public void onSystemWrite(long addr, byte[] data) {
        if (!traceSystemMemoryWrite) {
            return;
        }
        long max = Math.max(addr, traceSystemMemoryWriteBegin);
        long min = Math.min(addr + data.length, traceSystemMemoryWriteEnd);
        if (max < min) {
            byte[] buf = new byte[(int) (min - max)];
            System.arraycopy(data, (int) (max - addr), buf, 0, buf.length);
            if (traceSystemMemoryWriteListener != null) {
                traceSystemMemoryWriteListener.onWrite(this, addr, buf);
            } else {
                StringWriter writer = new StringWriter();
                writer.write("### System Memory WRITE at 0x" + Long.toHexString(max) + "\n");
                new Exception().printStackTrace(new PrintWriter(writer));
                Inspector.inspect(buf, writer.toString());
            }
        }
    }
    @Override
    public TraceHook traceWrite(long begin, long end, TraceWriteListener listener) {
        TraceMemoryHook hook = new TraceMemoryHook(false);
        if (listener != null) {
            hook.traceWriteListener = listener;
        }
        backend.hook_add_new((WriteHook) hook, begin, end, this);
        return hook;
    }
    @Override
    public final TraceHook traceRead() {
        return traceRead(1, 0);
    }
    @Override
    public final TraceHook traceWrite() {
        return traceWrite(1, 0);
    }
    @Override
    public final TraceHook traceCode() {
        return traceCode(1, 0);
    }
    @Override
    public final TraceHook traceCode(long begin, long end) {
        return traceCode(begin, end, null);
    }
    @Override
    public TraceHook traceCode(long begin, long end, TraceCodeListener listener) {
        AssemblyCodeDumper hook = new AssemblyCodeDumper(this, begin, end, listener);
        backend.hook_add_new(hook, begin, end, this);
        return hook;
    }
    @Override
    public void setTimeout(long timeout) {
        this.timeout = timeout;
    }
    private boolean running;
    @Override
    public boolean isRunning() {
        return running;
    }
    private final ThreadDispatcher threadDispatcher;
    @Override
    public ThreadDispatcher getThreadDispatcher() {
        return threadDispatcher;
    }
    @Override
    public boolean emulateSignal(int sig) {
        MainTask main = getSyscallHandler().createSignalHandlerTask(this, sig);
        if (main == null) {
            return false;
        } else {
            Memory memory = getMemory();
            long spBackup = memory.getStackPoint();
            try {
                threadDispatcher.runMainForResult(main);
            } finally {
                memory.setStackPoint(spBackup);
            }
            return true;
        }
    }
    protected final Number runMainForResult(MainTask task) {
        Memory memory = getMemory();
        long spBackup = memory.getStackPoint();
        try {
            return getThreadDispatcher().runMainForResult(task);
        } finally {
            memory.setStackPoint(spBackup);
        }
    }
    public final Number emulate(long begin, long until) throws PopContextException {
        if (running) {
            backend.emu_stop();
            throw new IllegalStateException("running");
        }
        if (is32Bit()) {
            begin &= 0xffffffffL;
        }
        final Pointer pointer = UnidbgPointer.pointer(this, begin);
        long start = 0;
        Thread exitHook = null;
        try {
            if (log.isDebugEnabled()) {
                log.debug("emulate " + pointer + " started sp=" + getStackPointer());
            }
            start = System.currentTimeMillis();
            running = true;
            if (log.isDebugEnabled()) {
                exitHook = new Thread(() -> {
                    backend.emu_stop();
                    Debugger debugger = attach();
                    if (!debugger.isDebugging()) {
                        debugger.debug();
                    }
                });
                Runtime.getRuntime().addShutdownHook(exitHook);
            }
            backend.emu_start(begin, until, 0, 0);
            if (is64Bit()) {
                return backend.reg_read(Arm64Const.UC_ARM64_REG_X0);
            } else {
                Number r0 = backend.reg_read(ArmConst.UC_ARM_REG_R0);
                Number r1 = backend.reg_read(ArmConst.UC_ARM_REG_R1);
                return (r0.intValue() & 0xffffffffL) | ((r1.intValue() & 0xffffffffL) << 32);
            }
        } catch (ThreadContextSwitchException e) {
            e.syncReturnValue(this);
            if (log.isTraceEnabled()) {
                e.printStackTrace(System.out);
            }
            return null;
        } catch (PopContextException e) {
            throw e;
        } catch (RuntimeException e) {
            return handleEmuException(e, pointer, start);
        } finally {
            if (exitHook != null) {
                Runtime.getRuntime().removeShutdownHook(exitHook);
            }
            running = false;
            log.debug("emulate {} finished sp={}, offset={}ms", pointer, getStackPointer(), System.currentTimeMillis() - start);
        }
    }
    private int handleEmuException(RuntimeException e, Pointer pointer, long start) {
        boolean enterDebug = log.isDebugEnabled();
        if (enterDebug || !log.isWarnEnabled()) {
            e.printStackTrace(System.out);
            attach().debug();
        } else {
            String msg = e.getMessage();
            if (msg == null) {
                msg = e.getClass().getName();
            }
            RunnableTask runningTask = threadDispatcher.getRunningTask();
            log.warn("emulate {} exception sp={}, msg={}, offset={}ms{}", pointer, getStackPointer(), msg, System.currentTimeMillis() - start,
                    runningTask == null ? "" : (" @ " + runningTask));
        }
        return -1;
    }
    public abstract Pointer getStackPointer();
    private boolean closed;
    @Override
    public synchronized final void close() throws IOException {
        if (closed) {
            throw new IOException("Already closed.");
        }
        try {
            IOUtils.close(debugger);
            closeInternal();
            backend.destroy();
        } finally {
            closed = true;
        }
    }
    protected abstract void closeInternal();
    @Override
    public Backend getBackend() {
        return backend;
    }
    private final String processName;
    @Override
    public String getProcessName() {
        return processName == null ? "unidbg" : processName;
    }
    private final Map<String, Object> context = new HashMap<>();
    @Override
    public void set(String key, Object value) {
        context.put(key, value);
    }
    @SuppressWarnings("unchecked")
    @Override
    public <V> V get(String key) {
        return (V) context.get(key);
    }
    protected abstract boolean isPaddingArgument();
    protected void dumpClass(String className) {
        throw new UnsupportedOperationException("dumpClass className=" + className);
    }
    protected void searchClass(String keywords) {
        throw new UnsupportedOperationException("searchClass keywords=" + keywords);
    }
    protected void dumpGPBProtobufMsg(String className) {
        throw new UnsupportedOperationException("dumpGPBProtobufMsg className=" + className);
    }
    @Override
    public final void serialize(DataOutput out) throws IOException {
        out.writeUTF(getClass().getName());
        getMemory().serialize(out);
        getSvcMemory().serialize(out);
        getSyscallHandler().serialize(out);
        getDlfcn().serialize(out);
    }
    private static class Context {
        private final long ctx;
        private final int off;
        Context(long ctx, int off) {
            this.ctx = ctx;
            this.off = off;
        }
        void restoreAndFree(Backend backend) {
            backend.context_restore(ctx);
            backend.context_free(ctx);
        }
    }
    private final Stack<Context> contextStack = new Stack<>();
    @Override
    public void pushContext(int off) {
        long context = backend.context_alloc();
        backend.context_save(context);
        contextStack.push(new Context(context, off));
    }
    @Override
    public int popContext() {
        Context ctx = contextStack.pop();
        ctx.restoreAndFree(backend);
        return ctx.off;
    }
}
package com.github.unidbg.ios;
import com.github.unidbg.AbstractEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.LongJumpException;
import com.github.unidbg.StopEmulatorException;
import com.github.unidbg.Svc;
import com.github.unidbg.arm.ARM;
import com.github.unidbg.arm.ARMEmulator;
import com.github.unidbg.arm.ArmSvc;
import com.github.unidbg.arm.Cpsr;
import com.github.unidbg.arm.ThumbSvc;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BackendException;
import com.github.unidbg.arm.context.Arm32RegisterContext;
import com.github.unidbg.arm.context.EditableArm32RegisterContext;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.file.FileIO;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.ios.DarwinFileIO;
import com.github.unidbg.file.ios.IOConstants;
import com.github.unidbg.ios.file.ByteArrayFileIO;
import com.github.unidbg.ios.file.DriverFileIO;
import com.github.unidbg.ios.file.LocalDarwinUdpSocket;
import com.github.unidbg.ios.file.SocketIO;
import com.github.unidbg.ios.file.TcpSocket;
import com.github.unidbg.ios.file.UdpSocket;
import com.github.unidbg.ios.struct.attr.AttrList;
import com.github.unidbg.ios.struct.kernel.AslServerMessageRequest;
import com.github.unidbg.ios.struct.kernel.ClockGetTimeReply;
import com.github.unidbg.ios.struct.kernel.HostGetClockServiceReply;
import com.github.unidbg.ios.struct.kernel.HostGetClockServiceRequest;
import com.github.unidbg.ios.struct.kernel.HostInfoReply;
import com.github.unidbg.ios.struct.kernel.HostInfoRequest;
import com.github.unidbg.ios.struct.kernel.HostRequestNotificationReply;
import com.github.unidbg.ios.struct.kernel.HostRequestNotificationRequest;
import com.github.unidbg.ios.struct.kernel.IOServiceGetMatchingServiceRequest;
import com.github.unidbg.ios.struct.kernel.MachMsgHeader;
import com.github.unidbg.ios.struct.kernel.MachPortOptions;
import com.github.unidbg.ios.struct.kernel.MachPortReply;
import com.github.unidbg.ios.struct.kernel.MachPortSetAttributesReply;
import com.github.unidbg.ios.struct.kernel.MachPortSetAttributesRequest;
import com.github.unidbg.ios.struct.kernel.MachPortsLookupReply32;
import com.github.unidbg.ios.struct.kernel.MachTimebaseInfo;
import com.github.unidbg.ios.struct.kernel.NotifyServerCancelReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerCancelRequest;
import com.github.unidbg.ios.struct.kernel.NotifyServerGetStateReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerGetStateRequest;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterCheckReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterCheckRequest;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterMachPortReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterMachPortRequest;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterPlainReply;
import com.github.unidbg.ios.struct.kernel.NotifyServerRegisterPlainRequest;
import com.github.unidbg.ios.struct.kernel.ProcBsdShortInfo;
import com.github.unidbg.ios.struct.kernel.Pthread;
import com.github.unidbg.ios.struct.kernel.Pthread32;
import com.github.unidbg.ios.struct.kernel.RLimit;
import com.github.unidbg.ios.struct.kernel.SemaphoreCreateReply;
import com.github.unidbg.ios.struct.kernel.SemaphoreCreateRequest;
import com.github.unidbg.ios.struct.kernel.Stat;
import com.github.unidbg.ios.struct.kernel.StatFS;
import com.github.unidbg.ios.struct.kernel.TaskDyldInfoReply;
import com.github.unidbg.ios.struct.kernel.TaskGetExceptionPortsReply;
import com.github.unidbg.ios.struct.kernel.TaskGetExceptionPortsRequest;
import com.github.unidbg.ios.struct.kernel.TaskGetSpecialPortReply;
import com.github.unidbg.ios.struct.kernel.TaskGetSpecialPortRequest;
import com.github.unidbg.ios.struct.kernel.TaskInfoRequest;
import com.github.unidbg.ios.struct.kernel.TaskSetExceptionPortsReply;
import com.github.unidbg.ios.struct.kernel.TaskSetExceptionPortsRequest;
import com.github.unidbg.ios.struct.kernel.ThreadBasicInfoReply;
import com.github.unidbg.ios.struct.kernel.ThreadInfoRequest;
import com.github.unidbg.ios.struct.kernel.ThreadStateReply32;
import com.github.unidbg.ios.struct.kernel.ThreadStateRequest;
import com.github.unidbg.ios.struct.kernel.VmCopyReply;
import com.github.unidbg.ios.struct.kernel.VmCopyRequest;
import com.github.unidbg.ios.struct.kernel.VmRegionRecurse32Reply;
import com.github.unidbg.ios.struct.kernel.VmRegionRecurse32Request;
import com.github.unidbg.ios.struct.kernel.VmRegionReply;
import com.github.unidbg.ios.struct.kernel.VmRegionRequest;
import com.github.unidbg.ios.struct.kernel.VmRemapReply;
import com.github.unidbg.ios.struct.kernel.VmRemapRequest;
import com.github.unidbg.ios.struct.sysctl.IfMsgHeader;
import com.github.unidbg.ios.struct.sysctl.KInfoProc32;
import com.github.unidbg.ios.struct.sysctl.SockAddrDL;
import com.github.unidbg.ios.struct.sysctl.TaskDyldInfo;
import com.github.unidbg.memory.MemoryMap;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.pointer.UnidbgStructure;
import com.github.unidbg.thread.PopContextException;
import com.github.unidbg.thread.RunnableTask;
import com.github.unidbg.thread.Task;
import com.github.unidbg.thread.ThreadContextSwitchException;
import com.github.unidbg.unix.UnixEmulator;
import com.github.unidbg.unix.struct.TimeSpec;
import com.github.unidbg.unix.struct.TimeVal32;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.ArmConst;
import unicorn.UnicornConst;
import java.net.SocketException;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import static com.github.unidbg.ios.MachO.MAP_MY_FIXED;
import static com.github.unidbg.ios.file.SocketIO.AF_LINK;
import static com.github.unidbg.ios.file.SocketIO.AF_ROUTE;
public class ARM32SyscallHandler extends DarwinSyscallHandler {
    private static final Logger log = LoggerFactory.getLogger(ARM32SyscallHandler.class);
    private final SvcMemory svcMemory;
    protected ARM32SyscallHandler(SvcMemory svcMemory) {
        super();
        this.svcMemory = svcMemory;
    }
    @SuppressWarnings("unchecked")
    @Override
    public void hook(Backend backend, int intno, int swi, Object user) {
        Emulator<DarwinFileIO> emulator = (Emulator<DarwinFileIO>) user;
        UnidbgPointer pc = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_PC);
        final int bkpt;
        if (ARM.isThumb(backend)) {
            bkpt = pc.getShort(0) & 0xff;
        } else {
            int instruction = pc.getInt(0);
            bkpt = (instruction & 0xf) | ((instruction >> 8) & 0xfff) << 4;
        }
        if (intno == ARMEmulator.EXCP_BKPT) { 
            createBreaker(emulator).brk(pc, bkpt);
            return;
        }
        if (intno == ARMEmulator.EXCP_UDEF) {
            createBreaker(emulator).debug();
            return;
        }
        if (intno != ARMEmulator.EXCP_SWI) {
            throw new BackendException("intno=" + intno);
        }
        int NR = backend.reg_read(ArmConst.UC_ARM_REG_R12).intValue();
        String syscall = null;
        Throwable exception = null;
        try {
            if (swi == 0 && (backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue()) == Svc.POST_CALLBACK_SYSCALL_NUMBER && (backend.reg_read(ArmConst.UC_ARM_REG_R7).intValue()) == 0) { 
                int number = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
                Svc svc = svcMemory.getSvc(number);
                if (svc != null) {
                    svc.handlePostCallback(emulator);
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (swi == 0 && (backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue()) == Svc.PRE_CALLBACK_SYSCALL_NUMBER && (backend.reg_read(ArmConst.UC_ARM_REG_R7).intValue()) == 0) { 
                int number = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
                Svc svc = svcMemory.getSvc(number);
                if (svc != null) {
                    svc.handlePreCallback(emulator);
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (swi != DARWIN_SWI_SYSCALL) {
                if (swi == (ARM.isThumb(backend) ? ThumbSvc.SVC_MAX : ArmSvc.SVC_MAX)) {
                    throw new PopContextException();
                }
                if (swi == (ARM.isThumb(backend) ? ThumbSvc.SVC_MAX : ArmSvc.SVC_MAX) - 1) {
                    throw new ThreadContextSwitchException();
                }
                Svc svc = svcMemory.getSvc(swi);
                if (svc != null) {
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, (int) svc.handle(emulator));
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi + ", NR=" + NR);
            }
            if (log.isTraceEnabled()) {
                ARM.showThumbRegs(emulator);
            }
            Cpsr.getArm(backend).setCarry(false);
            if (handleSyscall(emulator, NR)) {
                return;
            }
            switch (NR) {
                case -3:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mach_absolute_time(emulator));
                    return;
                case -10:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_vm_allocate_trap(emulator));
                    return;
                case -12:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_vm_deallocate_trap(emulator));
                    return;
                case -15:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_vm_map_trap(emulator));
                    return;
                case -16:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_port_allocate_trap(emulator));
                    return;
                case -18:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_port_deallocate_trap(emulator));
                    return;
                case -19:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_port_mod_refs_trap(emulator));
                    return;
                case -20:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_port_move_member_trap(emulator));
                    return;
                case -21:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_port_insert_right_trap(emulator));
                    return;
                case -22: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _mach_port_insert_member(emulator));
                    return;
                case -24:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_port_construct_trap(emulator));
                    return;
                case -26: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mach_reply_port());
                    return;
                case -27:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, thread_self_trap());
                    return;
                case -28: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, task_self_trap());
                    return;
                case -29:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, host_self_trap());
                    return;
                case -31:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mach_msg_trap(emulator));
                    return;
                case -33: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _semaphore_signal_trap(emulator));
                    return;
                case -36: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _semaphore_wait_trap(emulator));
                    return;
                case -41: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _kernelrpc_mach_port_guard_trap(emulator));
                    return;
                case -59: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, swtch_pri(emulator));
                    return;
                case -61:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, thread_switch(emulator));
                    return;
                case -89:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _mach_timebase_info(emulator));
                    return;
                case -91: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _mk_timer_create());
                    return;
                case -93: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _mk_timer_arm(emulator));
                    return;
                case 1:
                    exit(emulator);
                    return;
                case 4:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, write(emulator));
                    return;
                case 6:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, close(emulator));
                    return;
                case 10:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, unlink(emulator));
                    return;
                case 15:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, chmod(emulator));
                    return;
                case 16:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, chown(emulator));
                    return;
                case 20:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getpid(emulator));
                    return;
                case 24: 
                case 25: 
                case 43: 
                case 47: 
                    if (log.isDebugEnabled()) {
                        log.debug("NR={}", NR);
                    }
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, 0);
                    return;
                case 33:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, access(emulator));
                    return;
                case 34:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, chflags(emulator));
                    return;
                case 37:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, kill(emulator));
                    return;
                case 39:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getppid(emulator));
                    return;
                case 46:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sigaction(emulator));
                    return;
                case 48:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sigprocmask(emulator));
                    return;
                case 52:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sigpending(emulator));
                    return;
                case 53:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sigaltstack(emulator));
                    return;
                case 54:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, ioctl(emulator));
                    return;
                case 58:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, readlink(emulator));
                    return;
                case 73:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, munmap(emulator));
                    return;
                case 74:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mprotect(emulator));
                    return;
                case 75:
                    syscall = "posix_madvise";
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, 0);
                    return;
                case 92:
                case 406: 
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fcntl(emulator));
                    return;
                case 95:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fsync(emulator));
                    return;
                case 97:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, socket(emulator));
                    return;
                case 98:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, connect(emulator));
                    return;
                case 116:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, gettimeofday(emulator));
                    return;
                case 121:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, writev(emulator));
                    return;
                case 128:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, rename(emulator));
                    return;
                case 133:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sendto(emulator));
                    return;
                case 136:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mkdir(emulator));
                    return;
                case 137:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, rmdir(emulator));
                    return;
                case 194:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getrlimit(emulator));
                    return;
                case 197:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, mmap(emulator));
                    return;
                case 199:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, lseek(emulator));
                    return;
                case 201:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, ftruncate(emulator));
                    return;
                case 202:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sysctl(emulator));
                    return;
                case 216:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, open_dprotected_np(emulator));
                    return;
                case 220:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getattrlist(emulator));
                    return;
                case 221:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setattrlist(emulator));
                    return;
                case 240:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, listxattr(emulator));
                    return;
                case 236:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, setxattr(emulator));
                    return;
                case 237:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fsetxattr(emulator));
                    return;
                case 286:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, pthread_getugid_np(emulator));
                    return;
                case 301:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, psynch_mutexwait(emulator));
                    return;
                case 302:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, psynch_mutexdrop(emulator));
                    return;
                case 303:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, psynch_cvbroad(emulator));
                    return;
                case 305:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, psynch_cvwait(emulator));
                    return;
                case 327:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, issetugid());
                    return;
                case 328:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, pthread_kill(emulator));
                    return;
                case 329:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, pthread_sigmask(emulator));
                    return;
                case 330:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sigwait(emulator));
                    return;
                case 331:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, disable_threadsignal(emulator));
                    return;
                case 334:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, semwait_signal(emulator));
                    return;
                case 336:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, proc_info(emulator));
                    return;
                case 338:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, stat64(emulator));
                    return;
                case 339:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fstat(emulator));
                    return;
                case 340:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, lstat(emulator));
                    return;
                case 344:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getdirentries64(emulator));
                    return;
                case 345:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, statfs64(emulator));
                    return;
                case 346:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, fstatfs64(emulator));
                    return;
                case 347:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getfsstat64(emulator, 0));
                    return;
                case 357:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, getaudit_addr(emulator));
                    return;
                case 360:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, bsdthread_create(emulator));
                    return;
                case 361:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, bsdthread_terminate(emulator));
                    return;
                case 362:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, kqueue());
                    return;
                case 366:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, bsdthread_register(emulator));
                    return;
                case 367:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _workq_open());
                    return;
                case 368:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, _workq_kernreturn());
                    return;
                case 369:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, kevent64(emulator));
                    return;
                case 372:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, thread_selfid(emulator));
                    backend.reg_write(ArmConst.UC_ARM_REG_R1, 0);
                    return;
                case 381:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, sandbox_ms(emulator));
                    return;
                case 3:
                case 396:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, read_NOCANCEL(emulator));
                    return;
                case 397:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, write_NOCANCEL(emulator));
                    return;
                case 5: 
                case 398:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, open_NOCANCEL(emulator, 0));
                    return;
                case 266:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, shm_open(emulator));
                    return;
                case 399:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, close_NOCANCEL(emulator));
                    return;
                case 423:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, semwait_signal(emulator));
                    return;
                case 428:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, audit_session_self());
                    return;
                case 443:
                    backend.reg_write(ArmConst.UC_ARM_REG_R0, guarded_kqueue_np(emulator));
                    return;
                case 0x80000000:
                    NR = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
                    if(handleMachineDependentSyscall(emulator, NR)) {
                        return;
                    }
                default:
                    break;
            }
        } catch (StopEmulatorException e) {
            backend.emu_stop();
            return;
        } catch (LongJumpException e) {
            backend.emu_stop();
            throw e;
        } catch (Throwable e) {
            backend.emu_stop();
            exception = e;
        }
        log.warn("handleInterrupt intno={}, NR={}, svcNumber=0x{}, PC={}, syscall={}", intno, NR, Integer.toHexString(swi), pc, syscall, exception);
        if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        if (exception instanceof RuntimeException) {
            throw (RuntimeException) exception;
        }
    }
    private int _kernelrpc_mach_port_move_member_trap(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int task = context.getIntArg(0);
        int member = context.getIntArg(1);
        int after = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_move_member_trap task={}, member={}, after={}", task, member, after);
        }
        return 0;
    }
    private int chflags(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        int flags = context.getIntArg(1);
        String pathname = path.getString(0);
        log.info("chflags paht={}, flags=0x{}", pathname, Integer.toHexString(flags));
        return -1;
    }
    private int open_dprotected_np(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        int flags = context.getIntArg(1);
        int _class = context.getIntArg(2);
        int dpflags = context.getIntArg(3);
        String pathname = path.getString(0);
        log.info("open_dprotected_np path={}, flags=0x{}, class={}, dpflags=0x{}", pathname, Integer.toHexString(flags), _class, Integer.toHexString(dpflags));
        return -1;
    }
    private int fsetxattr(Emulator<DarwinFileIO> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer name = context.getPointerArg(1);
        Pointer value = context.getPointerArg(2);
        int size = context.getIntArg(3);
        int position = context.getR4Int();
        int options = context.getR5Int();
        log.info("fsetxattr fd={}, name={}, value={}, size={}, position={}, options=0x{}", fd, name.getString(0), value, size, position, Integer.toHexString(options));
        return -1;
    }
    private int setxattr(Emulator<DarwinFileIO> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        Pointer name = context.getPointerArg(1);
        Pointer value = context.getPointerArg(2);
        int size = context.getIntArg(3);
        int position = context.getR4Int();
        int options = context.getR5Int();
        log.info("setxattr pat={}, name={}, value={}, size={}, position={}, options=0x{}", path.getString(0), name.getString(0), value, size, position, Integer.toHexString(options));
        return -1;
    }
    private int getattrlist(Emulator<DarwinFileIO> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        Pointer attrListPointer = context.getPointerArg(1);
        UnidbgPointer attrBuf = context.getPointerArg(2);
        int attrBufSize = context.getIntArg(3);
        int options = context.getR4Int();
        String pathname = path.getString(0);
        AttrList attrList = new AttrList(attrListPointer);
        attrBuf.setSize(attrBufSize);
        String msg = "getattrlist path=" + pathname + ", attrList=" + attrList + ", attrBuf=" + attrBuf + ", attrBufSize=" + attrBufSize + ", options=0x" + Integer.toHexString(options);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.getattrlist(attrList, attrBuf, attrBufSize);
            if (ret != 0) {
                log.info("{}, ret={}", msg, ret);
            } else {
                log.debug("{}", msg);
            }
            return ret;
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.EACCES);
        log.info(msg);
        return -1;
    }
    private int setattrlist(Emulator<DarwinFileIO> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        Pointer attrListPointer = context.getPointerArg(1);
        UnidbgPointer attrBuf = context.getPointerArg(2);
        int attrBufSize = context.getIntArg(3);
        int options = context.getR4Int();
        String pathname = path.getString(0);
        AttrList attrList = new AttrList(attrListPointer);
        attrBuf.setSize(attrBufSize);
        String msg = String.format("path=%s, attrList=%s, attrBuf=%s, attrBufSize=%d, options=0x%s", pathname, attrList, attrBuf, attrBufSize, Integer.toHexString(options));
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            int ret = result.io.setattrlist(attrList, attrBuf, attrBufSize);
            if (ret != 0) {
                log.info("{} {}, ret={}", "setattrlist", msg, ret);
            } else {
                log.debug("{}", msg);
            }
            return ret;
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.EACCES);
        log.info(msg);
        return -1;
    }
    private int fsync(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("fsync fd={}", fd);
        }
        return 0;
    }
    private int sigaltstack(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer nstack = context.getPointerArg(0);
        Pointer ostack = context.getPointerArg(1);
        log.info("sigaltstack nstack={}, ostack={}", nstack, ostack);
        return 0;
    }
    private int ioctl(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        long request = context.getLongArg(1);
        long argp = context.getLongArg(2);
        if (log.isDebugEnabled()) {
            log.debug("ioctl fd={}, request=0x{}, argp=0x{}", fd, Long.toHexString(request), Long.toHexString(argp));
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int ret = file.ioctl(emulator, request, argp);
        if (ret == -1) {
            emulator.getMemory().setErrno(UnixEmulator.ENOTTY);
        }
        return ret;
    }
    private boolean handleMachineDependentSyscall(Emulator<?> emulator, int NR) {
        Backend backend = emulator.getBackend();
        switch (NR) {
            case 0:
                backend.reg_write(ArmConst.UC_ARM_REG_R0, sys_icache_invalidate(emulator));
                return true;
            case 1:
                backend.reg_write(ArmConst.UC_ARM_REG_R0, sys_dcache_flush(emulator));
                return true;
            case 2:
                backend.reg_write(ArmConst.UC_ARM_REG_R0, pthread_set_self(emulator));
                return true;
        }
        return false;
    }
    private int pthread_set_self(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer self = context.getPointerArg(0);
        Pthread pthread = new Pthread32(self.getPointer(0));
        pthread.unpack();
        UnidbgPointer tsd = pthread.getTSD();
        emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_C13_C0_3, tsd.peer);
        Task task = emulator.get(Task.TASK_KEY);
        if (task != null && task.isMainThread()) {
            MachOLoader loader = (MachOLoader) emulator.getMemory();
            loader.setErrnoPointer(pthread.getErrno());
        }
        if (log.isDebugEnabled()) {
            String threadName = pthread.getName();
            log.debug("pthread_set_self={}, pthread={}, threadName={}, LR={}", self, pthread, threadName, emulator.getContext().getLRPointer());
        }
        return 0;
    }
    private int sys_dcache_flush(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer address = context.getPointerArg(0);
        long size = context.getLongArg(1);
        if (log.isDebugEnabled()) {
            log.debug("sys_dcache_flush address={}, size={}", address, size);
        }
        return 0;
    }
    private int sys_icache_invalidate(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer address = context.getPointerArg(0);
        long size = context.getLongArg(1);
        if (log.isDebugEnabled()) {
            log.debug("sys_icache_invalidate address={}, size={}", address, size);
        }
        return 0;
    }
    private int pthread_getugid_np(Emulator<?> emulator) {
        Pointer uid = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        Pointer gid = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        if (log.isDebugEnabled()) {
            log.debug("pthread_getugid_np uid={}, gid={}", uid, gid);
        }
        uid.setInt(0, 0);
        gid.setInt(0, 0);
        return 0;
    }
    private int _mach_timebase_info(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pointer = context.getPointerArg(0);
        MachTimebaseInfo info = new MachTimebaseInfo(pointer);
        info.denom = 1;
        info.numer = 1;
        info.pack();
        if (log.isDebugEnabled()) {
            log.debug("_mach_timebase_info info={}, LR={}", info, context.getLRPointer());
        }
        return 0;
    }
    private int _mk_timer_create() {
        if (log.isDebugEnabled()) {
            log.debug("_mk_timer_create");
        }
        return STATIC_PORT;
    }
    private int _mk_timer_arm(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int port = context.getIntArg(0);
        long time = context.getLongArg(1);
        if (log.isDebugEnabled()) {
            log.debug("_mk_timer_arm port={}, time={}", port, time);
        }
        return 0;
    }
    private int readlink(Emulator<?> emulator) {
        Backend emulatorBackend = emulator.getBackend();
        Pointer pathname = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        Pointer buf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int bufSize = emulatorBackend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        String path = pathname.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("readlink path={}, buf={}, bufSize={}", path, buf, bufSize);
        }
        if ("/var/db/timezone/localtime".equals(path)) { 
            path = "/var/db/timezone/zoneinfo/Asia/Shanghai";
        }
        buf.setString(0, path);
        return path.length() + 1;
    }
    private int psynch_mutexdrop(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer mutex = context.getPointerArg(0);
        int mgen = context.getIntArg(1);
        int ugen = context.getIntArg(2);
        long tid = context.getR3Int();
        int flags = context.getR5Int();
        if (log.isDebugEnabled()) {
            log.debug("psynch_mutexdrop mutex={}, mgen={}, ugen={}, tid={}, flags=0x{}, LR={}", mutex, mgen, ugen, tid, Integer.toHexString(flags), context.getLRPointer());
        }
        return 0;
    }
    private int psynch_mutexwait(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer mutex = context.getPointerArg(0);
        int mgen = context.getIntArg(1);
        int ugen = context.getIntArg(2);
        long tid = context.getR3Int();
        int flags = context.getR5Int();
        if (log.isDebugEnabled()) {
            log.debug("psynch_mutexwait mutex={}, mgen={}, ugen={}, tid={}, flags=0x{}, LR={}", mutex, mgen, ugen, tid, Integer.toHexString(flags), context.getLRPointer());
        }
        return 0;
    }
    private int bsdthread_create(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        UnidbgPointer start_routine = context.getPointerArg(0);
        UnidbgPointer arg = context.getPointerArg(1);
        UnidbgPointer stack = context.getPointerArg(2);
        UnidbgPointer thread = context.getPointerArg(3);
        int flags = context.getR4Int();
        return (int) bsdthread_create(emulator, start_routine, arg, stack, thread, flags);
    }
    private int _workq_open() {
        log.info("_workq_open");
        return 0;
    }
    private int _workq_kernreturn() {
        log.info("_workq_kernreturn");
        return 0;
    }
    private int kevent64(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        int kq = context.getR0Int();
        Pointer changelist = context.getR1Pointer();
        int nchanges = context.getR2Int();
        Pointer eventlist = context.getR3Pointer();
        int nevents = context.getR4Int();
        int flags = context.getR5Int();
        Pointer timeout = context.getR6Pointer();
        return kevent64(emulator, kq, changelist, nchanges, eventlist, nevents, flags, TimeSpec.createTimeSpec(emulator, timeout));
    }
    private int _kernelrpc_mach_port_allocate_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int task = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int right = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        Pointer name = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_allocate_trap task={}, right={}, name={}", task, right, name);
        }
        name.setInt(0, STATIC_PORT);
        return 0;
    }
    private int _kernelrpc_mach_port_insert_right_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int task = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int name = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int poly = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int polyPoly = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_insert_right_trap task={}, name={}, poly={}, polyPoly={}", task, name, poly, polyPoly);
        }
        return 0;
    }
    private int _mach_port_insert_member(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int task = context.getIntArg(0);
        int name = context.getIntArg(1);
        int pset = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("_mach_port_insert_member task={}, name={}, pset={}", task, name, pset);
        }
        return 0;
    }
    private int _semaphore_signal_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int port = context.getIntArg(0);
        log.info("_semaphore_signal_trap port={}", port);
        if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        return 0;
    }
    private long _kernelrpc_mach_port_guard_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int task = context.getIntArg(0);
        int name = context.getIntArg(1);
        Pointer guard = context.getPointerArg(2);
        int strict = context.getIntArg(3);
        log.info("_kernelrpc_mach_port_guard_trap task={}, name={}, guard={}, strict={}", task, name, guard, strict);
        return 0;
    }
    private int thread_switch(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int thread_name = context.getIntArg(0);
        int option = context.getIntArg(1);
        int option_time = context.getIntArg(2);
        log.info("thread_switch thread_name={}, option={}, option_time={}", thread_name, option, option_time);
        return 0;
    }
    private int psynch_cvwait(Emulator<?> emulator) {
        if (threadDispatcherEnabled) {
            throw new ThreadContextSwitchException();
        }
        log.info("psynch_cvwait LR={}", emulator.getContext().getLRPointer());
        emulator.attach().debug();
        emulator.getMemory().setErrno(UnixEmulator.EINTR);
        return -1;
    }
    private int close(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("close fd={}", fd);
        }
        return close(emulator, fd);
    }
    private int lseek(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int r1 = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        long r2 = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        long offset = r1 | (r2 << 32);
        int whence = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        FileIO file = fdMap.get(fd);
        if (file == null) {
            if (log.isDebugEnabled()) {
                log.debug("lseek fd={}, offset={}, whence={}", fd, offset, whence);
            }
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int pos = file.lseek((int) offset, whence);
        if (log.isDebugEnabled()) {
            log.debug("lseek fd={}, offset={}, whence={}, pos={}", fd, offset, whence, pos);
        }
        return pos;
    }
    private int ftruncate(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int length = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("ftruncate fd={}, length={}", fd, length);
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            throw new UnsupportedOperationException();
        }
        return file.ftruncate(length);
    }
    private int unlink(Emulator<?> emulator) {
        Pointer pathname = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        String path = FilenameUtils.normalize(pathname.getString(0), true);
        emulator.getFileSystem().unlink(path);
        return 0;
    }
    private int chown(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        int uid = context.getIntArg(1);
        int gid = context.getIntArg(2);
        String pathname = path.getString(0);
        log.info("chown path={}, uid={}, gid={}", pathname, uid, gid);
        return 0;
    }
    private int getdirentries64(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        UnidbgPointer buf = context.getPointerArg(1);
        int bufSize = context.getIntArg(2);
        Pointer basep = context.getPointerArg(3);
        if (log.isDebugEnabled()) {
            log.debug("getdirentries64 fd={}, buf={}, bufSize={}, basep={}, LR={}", fd, buf, bufSize, basep, context.getLRPointer());
        }
        DarwinFileIO io = fdMap.get(fd);
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        } else {
            buf.setSize(bufSize);
            return io.getdirentries64(buf, bufSize);
        }
    }
    protected int statfs64(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathPointer = context.getPointerArg(0);
        Pointer buf = context.getPointerArg(1);
        String path = pathPointer.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, path, IOConstants.O_RDONLY);
        if (log.isDebugEnabled()) {
            log.debug("statfs64 pathPointer={}, buf={}, path={}", pathPointer, buf, path);
        }
        if (result != null && result.isSuccess()) {
            return result.io.fstatfs(new StatFS(buf));
        }
        log.info("statfs64 pathPointer={}, buf={}, path={}", pathPointer, buf, path);
        throw new BackendException("statfs64 path=" + path + ", buf=" + buf);
    }
    private int fstatfs64(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        if (log.isDebugEnabled()) {
            log.debug("fstatfs64 fd={}, buf={}", fd, buf);
        }
        DarwinFileIO io = fdMap.get(fd);
        if (io != null) {
            return io.fstatfs(new StatFS(buf));
        }
        emulator.getMemory().setErrno(UnixEmulator.EACCES);
        return -1;
    }
    private int stat64(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        Pointer statbuf = context.getPointerArg(1);
        String path = pathname.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("stat64 pathname={}, statbuf={}, LR={}", path, statbuf, context.getLRPointer());
        }
        return stat64(emulator, FilenameUtils.normalize(path, true), statbuf);
    }
    protected int fstat(Emulator<DarwinFileIO> emulator, int fd, Pointer stat) {
        if (log.isDebugEnabled()) {
            log.debug("fstat fd={}, stat={}", fd, stat);
        }
        DarwinFileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (log.isDebugEnabled()) {
            log.debug("fstat file={}, stat={}", file, stat);
        }
        return file.fstat(emulator, new Stat(stat));
    }
    protected int stat64(Emulator<DarwinFileIO> emulator, String pathname, Pointer statbuf) {
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            return result.io.fstat(emulator, new Stat(statbuf));
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.ENOENT);
        return -1;
    }
    private int write_NOCANCEL(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buffer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int count = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        return write(emulator, fd, buffer, count);
    }
    private int fstat(Emulator<DarwinFileIO> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer stat = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        return fstat(emulator, fd, stat);
    }
    private int lstat(Emulator<DarwinFileIO> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer pathname = context.getR0Pointer();
        Pointer stat = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        String pathStr = pathname.getString(0);
        String path = FilenameUtils.normalize(pathStr, true);
        if (log.isDebugEnabled()) {
            log.debug("lstat path={}, pathStr={}, stat={}", path, pathStr, stat);
        }
        return stat64(emulator, path, stat);
    }
    private static final int RLIMIT_NOFILE = 8;		
    private static final int RLIMIT_POSIX_FLAG = 0x1000;	
    private int getrlimit(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int resource = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer rlp = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        boolean posix = (resource & RLIMIT_POSIX_FLAG) != 0;
        int type = resource & (RLIMIT_POSIX_FLAG - 1);
        String msg = "getrlimit resource=0x" + Integer.toHexString(resource) + ", rlp=" + rlp + ", posix=" + posix + ", type=" + type;
        if (type == RLIMIT_NOFILE) {
            if (log.isDebugEnabled()) {
                log.debug(msg);
            }
            RLimit rLimit = new RLimit(rlp);
            rLimit.rlim_cur = 128;
            rLimit.rlim_max = 256;
            rLimit.pack();
            return 0;
        } else {
            log.info(msg);
        }
        return 1;
    }
    private int _kernelrpc_mach_port_mod_refs_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int task = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int name = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int right = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int delta = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_mod_refs_trap task={}, name={}, right={}, delta={}", task, name, right, delta);
        }
        return 0;
    }
    private int _kernelrpc_mach_port_construct_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int task = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer options = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int r2 = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        long r3 = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        long context = r2 | (r3 << 32);
        Pointer name = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R4);
        if (log.isDebugEnabled()) {
            MachPortOptions portOptions = new MachPortOptions(options);
            portOptions.unpack();
            log.debug("_kernelrpc_mach_port_construct_trap task={}, options={}, context=0x{}, name={}, portOptions={}", task, options, Long.toHexString(context), name, portOptions);
        }
        name.setInt(0, 0x88);
        return 0;
    }
    private int getaudit_addr(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        Pointer addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        int size = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (log.isDebugEnabled()) {
            log.debug("getaudit_addr={}, size={}", addr, size);
        }
        return 0;
    }
    private int semwait_signal(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        int cond_sem = context.getR0Int();
        int mutex_sem = context.getR1Int();
        int timeout = context.getR2Int();
        int relative = context.getR3Int();
        long tv_sec = context.getR4Int() | (long) context.getR5Int() << 32;
        int tv_nsec = context.getR6Int();
        RunnableTask runningTask = emulator.getThreadDispatcher().getRunningTask();
        String msg = "semwait_signal cond_sem=" + cond_sem + ", mutex_sem=" + mutex_sem + ", timeout=" + timeout + ", relative=" + relative + ", tv_sec=" + tv_sec + ", tv_nsec=" + tv_nsec;
        if (threadDispatcherEnabled && runningTask != null) {
            if (log.isDebugEnabled()) {
                log.debug(msg);
            }
            return semwait_signal(emulator, runningTask, cond_sem, mutex_sem, timeout, relative, tv_sec, tv_nsec);
        }
        log.info(msg);
        try {
            Thread.sleep(tv_sec * 1000L + tv_nsec / 1000L, tv_nsec % 1000);
            emulator.getMemory().setErrno(ETIMEDOUT);
            return -1;
        } catch (InterruptedException e) {
            emulator.getMemory().setErrno(UnixEmulator.EINVAL);
            return -1;
        }
    }
    private static final int PROC_INFO_CALL_SETCONTROL = 0x5;
    private static final int PROC_SELFSET_THREADNAME = 2;
    private static final int PROC_INFO_CALL_PIDINFO = 0x2;
    private static final int PROC_PIDT_SHORTBSDINFO = 13;
    private int proc_info(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int callNum = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int pid = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int flavor = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int r3 = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        long r4 = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
        long arg = r3 | (r4 << 32);
        Pointer buffer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R5);
        int bufferSize = backend.reg_read(ArmConst.UC_ARM_REG_R6).intValue();
        String msg = "proc_info callNum=" + callNum + ", pid=" + pid + ", flavor=" + flavor + ", arg=" + arg + ", buffer=" + buffer + ", bufferSize=" + bufferSize;
        if (PROC_INFO_CALL_SETCONTROL == callNum && PROC_SELFSET_THREADNAME == flavor) {
            String threadName = buffer.getString(0);
            if (log.isDebugEnabled()) {
                log.debug("{}, threadName={}", msg, threadName);
            }
            return 0;
        } else if (PROC_INFO_CALL_PIDINFO == callNum && PROC_PIDT_SHORTBSDINFO == flavor) {
            ProcBsdShortInfo info = new ProcBsdShortInfo(buffer);
            info.unpack();
            String processName = emulator.getProcessName();
            if (processName == null) {
                processName = "unidbg";
            }
            info.pbsi_pid = pid;
            info.pbsi_status = ProcBsdShortInfo.SRUN;
            info.pbsi_comm = Arrays.copyOf(Arrays.copyOf(processName.getBytes(), DarwinSyscall.MAXCOMLEN-1), DarwinSyscall.MAXCOMLEN);
            info.pbsi_flags = 0x24090;
            info.pbsi_uid = 0;
            info.pbsi_ruid = 0;
            info.pbsi_svuid = 0;
            info.pbsi_gid = 0;
            info.pbsi_rgid = 0;
            info.pbsi_svgid = 0;
            info.pbsi_pgid = 0;
            info.pbsi_ppid = pid - 1;
            info.pack();
            if (log.isDebugEnabled()) {
                log.debug("{}, info={}", msg, info);
            }
            return info.size();
        } else {
            log.info(msg);
            return 1;
        }
    }
    private int sandbox_ms(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        Pointer policyName = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        int call = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        Pointer args = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        if (log.isDebugEnabled()) {
            log.debug("sandbox_ms policyName={}, call={}, args={}", policyName.getString(0), call, args);
        }
        return 0;
    }
    private int issetugid() {
        log.debug("issetugid");
        return 0;
    }
    private int bsdthread_register(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        UnidbgPointer thread_start = context.getR0Pointer();
        UnidbgPointer start_wqthread = context.getR1Pointer();
        int pthreadSize = context.getR2Int();
        UnidbgPointer data = context.getR3Pointer();
        int dataSize = context.getR4Int();
        int r5 = context.getR5Int();
        long r6 = context.getR6Int();
        long offset = r5 | (r6 << 32);
        if (log.isDebugEnabled()) {
            log.debug("bsdthread_register thread_start={}, start_wqthread={}, pthreadSize={}, data={}, dataSize={}, offset=0x{}", thread_start, start_wqthread, pthreadSize, data, dataSize, Long.toHexString(offset));
        }
        return bsdthread_register(thread_start, pthreadSize);
    }
    private int munmap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        long timeInMillis = System.currentTimeMillis();
        long start = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue() & 0xffffffffL;
        int length = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        emulator.getMemory().munmap(start, length);
        if (log.isDebugEnabled()) {
            log.debug("munmap start=0x{}, length={}, offset={}", Long.toHexString(start), length, System.currentTimeMillis() - timeInMillis);
        }
        return 0;
    }
    private int sysctl(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        Pointer name = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        int namelen = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        Pointer buffer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        Pointer bufferSize = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R3);
        Pointer set0 = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R4);
        int set1 = backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue();
        int top = name.getInt(0);
        switch (top) {
            case CTL_UNSPEC: {
                int action = name.getInt(4);
                if (action == 3) {
                    byte[] bytes = set0.getByteArray(0, set1);
                    String sub = new String(bytes, StandardCharsets.UTF_8);
                    if (log.isDebugEnabled()) {
                        log.debug("sysctl CTL_UNSPEC action={}, namelen={}, buffer={}, bufferSize={}, sub={}", action, namelen, buffer, bufferSize, sub);
                    }
                    switch (sub) {
                        case "unidbg.debug":
                            return LoggerFactory.getLogger("com.github.unidbg.ios.debug").isDebugEnabled() ? 1 : 0;
                        case "kern.ostype":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_OSTYPE);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "kern.osrelease":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_OSRELEASE);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "kern.version":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_VERSION);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "kern.osversion":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_OSVERSION);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "kern.boottime":
                            buffer.setInt(0, CTL_KERN);
                            buffer.setInt(4, KERN_BOOTTIME);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "hw.machine":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_MACHINE);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "hw.model":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_MODEL);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "hw.cputype":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_CPU_TYPE);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "hw.cpusubtype":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_CPU_SUBTYPE);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "hw.cpufamily":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_CPU_FAMILY);
                            bufferSize.setLong(0, 8);
                            return 0;
                        case "hw.ncpu":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_NCPU);
                            bufferSize.setInt(0, 8);
                            return 0;
                        case "hw.memsize":
                            buffer.setInt(0, CTL_HW);
                            buffer.setInt(4, HW_MEMSIZE);
                            bufferSize.setInt(0, 8);
                            return 0;
                    }
                    if (log.isDebugEnabled()) {
                        createBreaker(emulator).debug();
                    }
                    return -1;
                }
                log.info("sysctl CTL_UNSPEC action={}, namelen={}, buffer={}, bufferSize={}, set0={}, set1={}", action, namelen, buffer, bufferSize, set0, set1);
                break;
            }
            case CTL_KERN: {
                int action = name.getInt(4);
                String msg = "sysctl CTL_KERN action=" + action + ", namelen=" + namelen + ", buffer=" + buffer + ", bufferSize=" + bufferSize + ", set0=" + set0 + ", set1=" + set1;
                switch (action) {
                    case KERN_PROCARGS2:
                        log.info(msg);
                        return 1;
                    case KERN_OSTYPE:
                        log.debug(msg);
                        String osType = getKernelOsType();
                        if (bufferSize != null) {
                            bufferSize.setInt(0, osType.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, osType);
                        }
                        return 0;
                    case KERN_OSRELEASE:
                        log.debug(msg);
                        String osRelease = getKernelOsRelease();
                        if (bufferSize != null) {
                            bufferSize.setInt(0, osRelease.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, osRelease);
                        }
                        return 0;
                    case KERN_VERSION:
                        log.debug(msg);
                        String version = getKernelVersion();
                        if (bufferSize != null) {
                            bufferSize.setInt(0, version.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, version);
                        }
                        return 0;
                    case KERN_ARGMAX:
                        bufferSize.setInt(0, 4);
                        buffer.setInt(0, 128);
                        return 0;
                    case KERN_HOSTNAME:
                        log.debug(msg);
                        String host = getKernelHostName();
                        if (bufferSize != null) {
                            bufferSize.setInt(0, host.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, host);
                        }
                        return 0;
                    case KERN_PROC:
                        int subType = name.getInt(8);
                        if (subType == KERN_PROC_PID) {
                            int pid = name.getInt(0xc);
                            KInfoProc32 kInfoProc = new KInfoProc32(buffer);
                            kInfoProc.unpack();
                            kInfoProc.kp_proc.p_flag = 0; 
                            kInfoProc.kp_eproc.e_ucred.cr_uid = 0;
                            kInfoProc.pack();
                            if (log.isDebugEnabled()) {
                                log.debug("{}, subType={}, pid={}, kInfoProc={}", msg, subType, pid, kInfoProc);
                            }
                            return 0;
                        }
                        log.info("{}, subType={}", msg, subType);
                        break;
                    case KERN_OSVERSION:
                        log.debug(msg);
                        String osVersion = getBuildVersion();
                        if (bufferSize != null) {
                            bufferSize.setInt(0, osVersion.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, osVersion);
                        }
                        return 0;
                    case KERN_USRSTACK32:
                        if (bufferSize != null) {
                            bufferSize.setInt(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, (int) emulator.getMemory().getStackBase());
                        }
                        return 0;
                    case KERN_BOOTTIME:
                        if (bufferSize != null) {
                            bufferSize.setInt(0, UnidbgStructure.calculateSize(TimeVal32.class));
                        }
                        if (buffer != null) {
                            fillKernelBootTime(buffer);
                        }
                        return 0;
                    default:
                        log.info(msg);
                        break;
                }
                break;
            }
            case CTL_HW: {
                int action = name.getInt(4);
                String msg = "sysctl CTL_HW action=" + action + ", namelen=" + namelen + ", buffer=" + buffer + ", bufferSize=" + bufferSize + ", set0=" + set0 + ", set1=" + set1;
                switch (action) {
                    case HW_CPU_FREQ:
                        if (bufferSize != null) {
                            bufferSize.setLong(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, 1800000000);
                        }
                        return 0;
                    case HW_PAGESIZE:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setInt(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, emulator.getPageAlign());
                        }
                        return 0;
                    case HW_CPU_TYPE:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setInt(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, CPU_TYPE_ARM);
                        }
                        return 0;
                    case HW_CPU_SUBTYPE:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setInt(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, CPU_SUBTYPE_ARM_V7);
                        }
                        return 0;
                    case HW_CPU_FAMILY:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setInt(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, 933271106);
                        }
                        return 0;
                    case HW_MACHINE:
                        log.debug(msg);
                        String machine = getHwMachine();
                        if (bufferSize != null) {
                            bufferSize.setInt(0, machine.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, machine);
                        }
                        return 0;
                    case HW_MODEL:
                        log.debug(msg);
                        String model = "N53AP";
                        if (bufferSize != null) {
                            bufferSize.setInt(0, model.length() + 1);
                        }
                        if (buffer != null) {
                            buffer.setString(0, model);
                        }
                        return 0;
                    case HW_NCPU:
                        log.debug(msg);
                        if (bufferSize != null) {
                            bufferSize.setInt(0, 4);
                        }
                        if (buffer != null) {
                            buffer.setInt(0, getHwNcpu()); 
                        }
                        return 0;
                    case HW_MEMSIZE:
                        if (bufferSize != null) {
                            bufferSize.setInt(0, 8);
                        }
                        if (buffer != null) {
                            long memSize = 2L * 1024 * 1024 * 1024; 
                            buffer.setLong(0, memSize);
                        }
                        return 0;
                }
                log.info(msg);
                break;
            }
            case CTL_NET:
                int action = name.getInt(4); 
                String msg = "sysctl CTL_NET action=" + action + ", namelen=" + namelen + ", buffer=" + buffer + ", bufferSize=" + bufferSize + ", set0=" + set0 + ", set1=" + set1;
                int family = name.getInt(0xc); 
                int rt = name.getInt(0x10);
                if(action == AF_ROUTE && rt == NET_RT_IFLIST) {
                    try {
                        List<DarwinUtils.NetworkIF> networkIFList = DarwinUtils.getNetworkIFs(isVerbose());
                        int sizeOfSDL = UnidbgStructure.calculateSize(SockAddrDL.class);
                        int entrySize = UnidbgStructure.calculateSize(IfMsgHeader.class) + sizeOfSDL;
                        if (bufferSize != null) {
                            bufferSize.setInt(0, entrySize * networkIFList.size());
                        }
                        if (buffer != null) {
                            Pointer pointer = buffer;
                            short index = 0;
                            for (DarwinUtils.NetworkIF networkIF : networkIFList) {
                                IfMsgHeader header = new IfMsgHeader(pointer);
                                SockAddrDL sockAddr = new SockAddrDL(pointer.share(header.size()));
                                header.ifm_msglen = (short) entrySize;
                                header.ifm_version = 5;
                                header.ifm_type = RTM_IFINFO;
                                header.ifm_addrs = 0x10;
                                header.ifm_index = ++index;
                                header.ifm_data.ifi_type = 6; 
                                header.pack();
                                byte[] networkInterfaceName = networkIF.networkInterface.getName().getBytes();
                                sockAddr.sdl_len = (byte) sizeOfSDL;
                                sockAddr.sdl_family = AF_LINK;
                                sockAddr.sdl_index = index;
                                sockAddr.sdl_type = 6; 
                                sockAddr.sdl_nlen = (byte) networkInterfaceName.length;
                                System.arraycopy(networkInterfaceName, 0, sockAddr.sdl_data, 0, networkInterfaceName.length);
                                byte[] macAddress = networkIF.networkInterface.getHardwareAddress();
                                sockAddr.sdl_alen = (byte) macAddress.length;
                                System.arraycopy(macAddress, 0, sockAddr.sdl_data, networkInterfaceName.length, macAddress.length);
                                sockAddr.pack();
                                pointer = pointer.share(entrySize);
                            }
                        }
                        return 0;
                    } catch (SocketException e) {
                        throw new IllegalStateException(e);
                    }
                }
                log.info("{}, family={}, rt={}", msg, family, rt);
                if (log.isDebugEnabled()) {
                    createBreaker(emulator).debug();
                }
            default:
                log.info("sysctl top={}, namelen={}, buffer={}, bufferSize={}, set0={}, set1={}", name.getInt(0), namelen, buffer, bufferSize, set0, set1);
                break;
        }
        return -1;
    }
    private int _kernelrpc_mach_vm_deallocate_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int target = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        long r1 = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        long r2 = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        long address = r1 | (r2 << 32);
        long r3 = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        long r4 = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
        long size = r3 | (r4 << 32);
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_vm_deallocate_trap target={}, address=0x{}, size=0x{}", target, Long.toHexString(address), Long.toHexString(size));
        } else {
            Logger log = LoggerFactory.getLogger("com.github.unidbg.ios.malloc");
            if (log.isDebugEnabled()) {
                log.debug("_kernelrpc_mach_vm_deallocate_trap target=" + target + ", address=0x" + Long.toHexString(address) + ", size=0x" + Long.toHexString(size) + ", lr=" + UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
            }
        }
        if (size > 0) {
            emulator.getMemory().munmap(address, (int) size);
        }
        return 0;
    }
    @Override
    protected void fillKernelBootTime(Pointer buffer) {
        long currentTimeMillis = bootTime;
        long tv_sec = currentTimeMillis / 1000;
        long tv_usec = (currentTimeMillis % 1000) * 1000 + (bootTime / 7 % 1000);
        TimeVal32 timeVal = new TimeVal32(buffer);
        timeVal.tv_sec = (int) tv_sec;
        timeVal.tv_usec = (int) tv_usec;
        timeVal.pack();
    }
    private int _kernelrpc_mach_vm_map_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int target = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer address = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int r2 = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        long r3 = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        long size = (r3 << 32) | r2;
        int r4 = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
        long r5 = backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue();
        long mask = (r5 << 32) | r4;
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R6).intValue();
        int cur_protection = backend.reg_read(ArmConst.UC_ARM_REG_R8).intValue();
        int tag = flags >> 24;
        boolean anywhere = (flags & MachO.VM_FLAGS_ANYWHERE) != 0;
        if (!anywhere) {
            throw new BackendException("_kernelrpc_mach_vm_map_trap fixed");
        }
        Pointer value = address.getPointer(0);
        UnidbgPointer pointer;
        if (mask != 0) {
            MachOLoader loader = (MachOLoader) emulator.getMemory();
            pointer = UnidbgPointer.pointer(emulator, loader.allocate(size, mask));
        } else {
            pointer = emulator.getMemory().mmap((int) size, cur_protection);
        }
        String msg = "_kernelrpc_mach_vm_map_trap target=" + target + ", address=" + address + ", value=" + value + ", size=0x" + Long.toHexString(size) + ", mask=0x" + Long.toHexString(mask) + ", flags=0x" + Long.toHexString(flags) + ", cur_protection=" + cur_protection + ", pointer=" + pointer + ", anywhere=true, tag=0x" + Integer.toHexString(tag);
        if (log.isDebugEnabled()) {
            log.debug(msg);
        } else {
            Logger log = LoggerFactory.getLogger("com.github.unidbg.ios.malloc");
            if (log.isDebugEnabled()) {
                log.debug(msg);
            }
        }
        address.setPointer(0, pointer);
        return 0;
    }
    private int _kernelrpc_mach_vm_allocate_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int target = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer address = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        long r2 = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        long r3 = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        long size = r2 | (r3 << 32);
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
        int tag = flags >> 24;
        boolean anywhere = (flags & MachO.VM_FLAGS_ANYWHERE) != 0;
        if (!anywhere) {
            long start = address.getInt(0) & 0xffffffffL;
            long ret = emulator.getMemory().mmap2(start, (int) size, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE, MAP_MY_FIXED, -1, 0);
            if (ret == 0) {
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_vm_allocate_trap fixed, address={}, size={}, flags=0x{}", address.getPointer(0), size, Integer.toHexString(flags));
                }
                if (tag != MachO.VM_MEMORY_REALLOC) {
                    throw new IllegalStateException("_kernelrpc_mach_vm_allocate_trap fixed, address=" + address.getPointer(0) + ", size=" + size + ", flags=0x" + Integer.toHexString(flags) + ", tag=" + tag);
                }
                return -1;
            }
            Pointer pointer = address.getPointer(0);
            pointer.write(0, new byte[(int) size], 0, (int) size);
            if (log.isDebugEnabled()) {
                log.debug("_kernelrpc_mach_vm_allocate_trap fixed, address={}, size={}, flags=0x{}, ret={}", pointer, size, Integer.toHexString(flags), ret);
            }
            return 0;
        }
        Pointer value = address.getPointer(0);
        UnidbgPointer pointer = emulator.getMemory().mmap((int) size, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE);
        pointer.write(0, new byte[(int) size], 0, (int) size);
        address.setPointer(0, pointer);
        String str = "_kernelrpc_mach_vm_allocate_trap target=" + target + ", address=" + address + ", value=" + value + ", size=0x" + Long.toHexString(size) + ", flags=0x" + Integer.toHexString(flags) + ", pointer=" + pointer + ", anywhere=true, tag=0x" + Integer.toHexString(tag);
        if (log.isDebugEnabled()) {
            log.debug(str);
        } else {
            Logger log = LoggerFactory.getLogger("com.github.unidbg.ios.malloc");
            if (log.isDebugEnabled()) {
                log.debug(str);
            }
        }
        return 0;
    }
    private int _kernelrpc_mach_port_deallocate_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int task = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int name = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        if (log.isDebugEnabled()) {
            log.debug("_kernelrpc_mach_port_deallocate_trap task={}, name={}", task, name);
        }
        return 0;
    }
    private int mach_msg_trap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        Arm32RegisterContext context = emulator.getContext();
        UnidbgPointer msg = context.getR0Pointer();
        int option = context.getR1Int();
        int send_size = context.getR2Int();
        int rcv_size = context.getR3Int();
        int rcv_name = context.getR4Int();
        int timeout = context.getR5Int();
        int notify = context.getR6Int();
        msg.setSize(Math.max(send_size, rcv_size));
        final MachMsgHeader header = new MachMsgHeader(msg);
        header.unpack();
        if (log.isDebugEnabled()) {
            log.debug("mach_msg_trap msg={}, option=0x{}, send_size={}, rcv_size={}, rcv_name={}, timeout={}, notify={}, header={}", msg, Integer.toHexString(option), send_size, rcv_size, rcv_name, timeout, notify, header);
        }
        final Pointer request = msg.share(header.size());
        switch (header.msgh_id) {
            case 3409: 
            {
                TaskGetSpecialPortRequest args = new TaskGetSpecialPortRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("task_get_special_port request={}", args);
                }
                if (args.which == TASK_BOOTSTRAP_PORT) {
                    TaskGetSpecialPortReply reply = new TaskGetSpecialPortReply(request);
                    reply.unpack();
                    header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
                    header.msgh_size = header.size() + reply.size();
                    header.msgh_remote_port = header.msgh_local_port;
                    header.msgh_local_port = 0;
                    header.msgh_id += 100; 
                    header.pack();
                    reply.body.msgh_descriptor_count = 1;
                    reply.port.name = BOOTSTRAP_PORT; 
                    reply.port.pad1 = 0;
                    reply.port.pad2 = 0;
                    reply.port.disposition = 17; 
                    reply.port.type = MACH_MSG_PORT_DESCRIPTOR;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("task_get_special_port reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
            }
            case 200: 
            {
                HostInfoRequest args = new HostInfoRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("host_info args={}", args);
                }
                if (args.flavor == HOST_PRIORITY_INFO) {
                    HostInfoReply reply = new HostInfoReply(request);
                    reply.unpack();
                    header.msgh_bits &= 0xff;
                    header.msgh_size = header.size() + reply.size();
                    header.msgh_remote_port = header.msgh_local_port;
                    header.msgh_local_port = 0;
                    header.msgh_id += 100; 
                    header.pack();
                    reply.NDR = args.NDR;
                    reply.retCode = 0; 
                    reply.host_info_outCnt = 8;
                    reply.host_info_out.kernel_priority = 0;
                    reply.host_info_out.system_priority = 0;
                    reply.host_info_out.server_priority = 0;
                    reply.host_info_out.user_priority = 0;
                    reply.host_info_out.depress_priority = 0;
                    reply.host_info_out.idle_priority = 0;
                    reply.host_info_out.minimum_priority = 10;
                    reply.host_info_out.maximum_priority = -10;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("host_info reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
            }
            case 3603: { 
                ThreadStateRequest args = new ThreadStateRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_thread_get_state args={}", request);
                }
                ThreadStateReply32 reply = new ThreadStateReply32(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                if (args.flavor != ThreadStateRequest.ARM_THREAD_STATE) {
                    reply.retCode = 4;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("_thread_get_state reply={}, flavor={}", reply, args.flavor);
                    }
                    return MACH_MSG_SUCCESS;
                }
                reply.retCode = 0;
                reply.outCnt = ThreadStateRequest.ARM_THREAD_STATE_COUNT;
                for (int reg = ArmConst.UC_ARM_REG_R0; reg <= ArmConst.UC_ARM_REG_R12; reg++) {
                    reply.state.__r[reg - ArmConst.UC_ARM_REG_R0] = backend.reg_read(reg).intValue();
                }
                reply.state.__sp = backend.reg_read(ArmConst.UC_ARM_REG_SP).intValue();
                reply.state.__lr = backend.reg_read(ArmConst.UC_ARM_REG_LR).intValue();
                reply.state.__pc = backend.reg_read(ArmConst.UC_ARM_REG_PC).intValue();
                reply.state.__cpsr = backend.reg_read(ArmConst.UC_ARM_REG_CPSR).intValue();
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_thread_get_state reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3612: { 
                ThreadInfoRequest args = new ThreadInfoRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_thread_info args={}", args);
                }
                final int THREAD_BASIC_INFO = 3;
                if (args.flavor != THREAD_BASIC_INFO) {
                    throw new UnsupportedOperationException();
                }
                ThreadBasicInfoReply reply = new ThreadBasicInfoReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                final int THREAD_BASIC_INFO_COUNT = 10;
                final int POLICY_TIMESHARE = 1;
                final int TH_STATE_RUNNING = 1;
                reply.retCode = 0;
                reply.outCnt = THREAD_BASIC_INFO_COUNT;
                reply.info.user_time.tv_sec = 0;
                reply.info.user_time.tv_usec = 177546;
                reply.info.system_time.tv_sec = 0;
                reply.info.system_time.tv_usec = 0;
                reply.info.cpu_usage = 343;
                reply.info.policy = POLICY_TIMESHARE;
                reply.info.run_state = TH_STATE_RUNNING;
                reply.info.flags = 0;
                reply.info.suspend_count = 0;
                reply.info.sleep_time = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_thread_info reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 1000: { 
                ClockGetTimeReply reply = new ClockGetTimeReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                long currentTimeMillis = System.currentTimeMillis();
                long nanoTime = System.nanoTime();
                long tv_sec = currentTimeMillis / 1000;
                long tv_usec = (currentTimeMillis % 1000) * 1000 + nanoTime % 1000;
                reply.retCode = 0;
                reply.tv_sec = (int) tv_sec;
                reply.tv_nsec = (int) tv_usec;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("clock_get_time reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 206: 
            {
                HostGetClockServiceRequest args = new HostGetClockServiceRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("host_get_clock_service args={}", args);
                }
                HostGetClockServiceReply reply = new HostGetClockServiceReply(request);
                reply.unpack();
                header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.clock_server.name = CLOCK_SERVER_PORT; 
                reply.clock_server.pad1 = 0;
                reply.clock_server.pad2 = 0;
                reply.clock_server.disposition = 17; 
                reply.clock_server.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("host_get_clock_service reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3418: 
            {
                SemaphoreCreateRequest args = new SemaphoreCreateRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("semaphore_create args={}", args);
                }
                SemaphoreCreateReply reply = new SemaphoreCreateReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.semaphore.name = ThreadLocalRandom.current().nextInt() & 0x7fffffff;
                reply.semaphore.pad1 = 0;
                reply.semaphore.pad2 = 0;
                reply.semaphore.disposition = 17; 
                reply.semaphore.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("semaphore_create reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3822: 
            {
                VmRegionRecurse32Request args = new VmRegionRecurse32Request(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_region_recurse_64 args={}", args);
                }
                VmRegionRecurse32Reply reply = new VmRegionRecurse32Reply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                MemoryMap memoryMap = null;
                for (MemoryMap mm : emulator.getMemory().getMemoryMap()) {
                    if (args.getAddress() >= mm.base && args.getAddress() < mm.base + mm.size) {
                        memoryMap = mm;
                        break;
                    }
                }
                if (log.isDebugEnabled()) {
                    log.debug("vm_region_recurse_64 header={}, memoryMap={}", header, memoryMap);
                }
                if (memoryMap == null) {
                    log.warn("vm_region_recurse_64 failed address=0x{}, size=0x{}", args.address, Integer.toHexString(args.size()));
                    return -1;
                }
                reply.NDR = args.NDR;
                reply.retCode = 0; 
                reply.address = (int) memoryMap.base;
                reply.size = (int) memoryMap.size;
                reply.infoCnt = 7;
                reply.nestingDepth = 0;
                reply.info.protection = memoryMap.prot;
                reply.info.max_protection = memoryMap.prot;
                reply.info.inheritance = memoryMap.prot;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_region_recurse_64 reply={}, memoryMap={}", reply, memoryMap);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3413: { 
                TaskSetExceptionPortsRequest args = new TaskSetExceptionPortsRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("task_set_exception_ports args={}, lr={}", args, UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
                }
                TaskSetExceptionPortsReply reply = new TaskSetExceptionPortsReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.NDR = args.NDR;
                reply.retCode = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("task_set_exception_ports reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3414: 
            {
                TaskGetExceptionPortsRequest args = new TaskGetExceptionPortsRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("task_get_exception_ports args={}, lr={}", args, UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
                }
                TaskGetExceptionPortsReply reply = new TaskGetExceptionPortsReply(request);
                reply.unpack();
                header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                args.NDR.mig_vers = 0x20;
                reply.NDR = args.NDR;
                reply.retCode = 0;
                reply.header = new int[32];
                reply.reserved = new byte[0x100];
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("task_get_exception_ports reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3404: 
            {
                MachPortsLookupReply32 reply = new MachPortsLookupReply32(request);
                reply.unpack();
                header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
                header.msgh_size = 52;
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 1;
                reply.outPort = (int) UnidbgPointer.nativeValue(request);
                reply.ret = 0;
                reply.mask = 0x2110000;
                reply.cnt = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("mach_ports_lookup reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3808: 
            {
                VmCopyRequest args = new VmCopyRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_copy args={}, lr={}", args, UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
                }
                byte[] data = backend.mem_read(args.source_address, args.size);
                emulator.getMemory().pointer(args.dest_address).write(data);
                VmCopyReply reply = new VmCopyReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 0;
                reply.NDR = args.NDR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_copy reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 4813: 
            {
                VmRemapRequest args = new VmRemapRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_vm_remap args={}, lr={}", args, UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
                }
                if ((args.anywhere != MachO.VM_FLAGS_OVERWRITE && args.anywhere != MachO.VM_FLAGS_FIXED) ||
                        args.mask != 0) {
                    throw new UnsupportedOperationException("_kernelrpc_mach_vm_remap anywhere=0x" + Integer.toHexString(args.anywhere) + ", mask=0x" + Long.toHexString(args.mask));
                }
                MachOLoader loader = (MachOLoader) emulator.getMemory();
                loader.remap(args);
                if (args.copy != 0) {
                    byte[] data = backend.mem_read(args.getSourceAddress(), args.size);
                    loader.pointer(args.target_address).write(data);
                }
                VmRemapReply reply = new VmRemapReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.retCode = 0;
                reply.target_address1 = (int) args.target_address;
                reply.target_address2 = (int) (args.target_address >> 32);
                reply.cur_protection = args.inheritance;
                reply.max_protection = args.inheritance;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_vm_remap reply={}, header={}", reply, header);
                }
                return MACH_MSG_SUCCESS;
            }
            case 404: { 
                return vproc_mig_look_up2(request, header);
            }
            case 78945669: { 
                NotifyServerRegisterPlainRequest args = new NotifyServerRegisterPlainRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    Pointer pointer = UnidbgPointer.pointer(emulator, args.name);
                    log.debug("notify_server_register_plain args={}, name={}", args, pointer == null ? null : new String(pointer.getByteArray(0, args.nameCnt), StandardCharsets.UTF_8));
                }
                NotifyServerRegisterPlainReply reply = new NotifyServerRegisterPlainReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.clientId = STATIC_PORT;
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_register_plain reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 78945681: { 
                NotifyServerGetStateRequest args = new NotifyServerGetStateRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_get_state args={}", args);
                }
                NotifyServerGetStateReply reply = new NotifyServerGetStateReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.version = 0;
                reply.pid = emulator.getPid();
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_get_state reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 78945679: { 
                NotifyServerCancelRequest args = new NotifyServerCancelRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_cancel args={}", args);
                }
                NotifyServerCancelReply reply = new NotifyServerCancelReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_cancel reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 78945670: { 
                NotifyServerRegisterCheckRequest args = new NotifyServerRegisterCheckRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    Pointer pointer = UnidbgPointer.pointer(emulator, args.name & 0xffffffffL);
                    log.debug("notify_server_register_check args={}, name={}", args, pointer == null ? null : new String(pointer.getByteArray(0, args.namelen), StandardCharsets.UTF_8));
                }
                NotifyServerRegisterCheckReply reply = new NotifyServerRegisterCheckReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.shmsize = 0;
                reply.slot = 0;
                reply.clientId = STATIC_PORT;
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_register_check reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 118: { 
                AslServerMessageRequest args = new AslServerMessageRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("asl_server_message args={}", args);
                }
                return MACH_MSG_SUCCESS;
            }
            case 78945673: { 
                NotifyServerRegisterMachPortRequest args = new NotifyServerRegisterMachPortRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    Pointer pointer = UnidbgPointer.pointer(emulator, args.name);
                    log.debug("notify_server_register_mach_port args={}, name={}", args, pointer == null ? null : new String(pointer.getByteArray(0, args.namelen), StandardCharsets.UTF_8));
                }
                NotifyServerRegisterMachPortReply reply = new NotifyServerRegisterMachPortReply(request);
                reply.unpack();
                header.msgh_bits &= 0xff;
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.ret = 0;
                reply.code = 0;
                reply.clientId = STATIC_PORT;
                reply.status = NOTIFY_STATUS_OK;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("notify_server_register_mach_port reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 205: { 
                MachPortReply reply = new MachPortReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.port.name = STATIC_PORT;
                reply.port.pad1 = 0;
                reply.port.pad2 = 0;
                reply.port.disposition = 17;
                reply.port.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("host_get_io_master reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 2873: { 
                IOServiceGetMatchingServiceRequest args = new IOServiceGetMatchingServiceRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("io_service_get_matching_service args={}, matching={}", args, args.getMatching());
                }
                MachPortReply reply = new MachPortReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.body.msgh_descriptor_count = 1;
                reply.port.name = STATIC_PORT;
                reply.port.pad1 = 0;
                reply.port.pad2 = 0;
                reply.port.disposition = 17;
                reply.port.type = MACH_MSG_PORT_DESCRIPTOR;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("io_service_get_matching_service reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3218: { 
                MachPortSetAttributesRequest args = new MachPortSetAttributesRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_port_set_attributes args={}", args);
                }
                MachPortSetAttributesReply reply = new MachPortSetAttributesReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("_kernelrpc_mach_port_set_attributes reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3800: { 
                VmRegionRequest args = new VmRegionRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_region args={}", args);
                }
                if (args.flavor != VmRegionRequest.VM_REGION_BASIC_INFO) {
                    throw new UnsupportedOperationException("flavor=" + args.flavor);
                }
                VmRegionReply reply = new VmRegionReply(request);
                reply.unpack();
                header.setMsgBits(true);
                header.msgh_size = header.size() + reply.size() - 4;
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                MemoryMap memoryRegion = null;
                for (MemoryMap memoryMap : emulator.getMemory().getMemoryMap()) {
                    if (memoryMap.base >= args.address) {
                        memoryRegion = memoryMap;
                        break;
                    }
                }
                if (memoryRegion == null) {
                    header.setMsgBits(false);
                    header.msgh_size = 0x24;
                    header.pack();
                    reply.pad1 = 1;
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("vm_region reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
                reply.NDR.mig_vers = 1;
                reply.NDR.int_rep = 0;
                reply.retCode = 0x110000;
                reply.outCnt = VmRegionRequest.VM_REGION_BASIC_INFO_COUNT;
                reply.address = (int) memoryRegion.base;
                reply.size = (int) memoryRegion.size;
                reply.info.protection = memoryRegion.prot;
                reply.info.max_protection = memoryRegion.prot;
                reply.info.inheritance = 0;
                reply.info.shared = false;
                reply.info.reserved = false;
                reply.info.offset = 0;
                reply.info.behavior = 0;
                reply.info.user_wired_count = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("vm_region reply={}, memoryRegion={}", reply, memoryRegion);
                }
                return MACH_MSG_SUCCESS;
            }
            case 3405: { 
                TaskInfoRequest args = new TaskInfoRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("task_info args={}", args);
                }
                if (args.flavor == TaskInfoRequest.TASK_DYLD_INFO) {
                    TaskDyldInfoReply reply = new TaskDyldInfoReply(request);
                    reply.unpack();
                    header.setMsgBits(false);
                    header.msgh_size = header.size() + reply.size();
                    header.msgh_remote_port = header.msgh_local_port;
                    header.msgh_local_port = 0;
                    header.msgh_id += 100; 
                    header.pack();
                    reply.retCode = 0;
                    reply.task_info_outCnt = UnidbgStructure.calculateSize(TaskDyldInfo.class) / 4;
                    reply.dyldInfo.allocateAllImage(emulator);
                    reply.pack();
                    if (log.isDebugEnabled()) {
                        log.debug("task_info TASK_DYLD_INFO reply={}", reply);
                    }
                    return MACH_MSG_SUCCESS;
                }
                throw new UnsupportedOperationException("flavor=" + args.flavor);
            }
            case 217: 
                HostRequestNotificationRequest args = new HostRequestNotificationRequest(request);
                args.unpack();
                if (log.isDebugEnabled()) {
                    log.debug("host_request_notification args={}", args);
                }
                HostRequestNotificationReply reply = new HostRequestNotificationReply(request);
                reply.unpack();
                header.setMsgBits(false);
                header.msgh_size = header.size() + reply.size();
                header.msgh_remote_port = header.msgh_local_port;
                header.msgh_local_port = 0;
                header.msgh_id += 100; 
                header.pack();
                reply.retCode = 0;
                reply.pack();
                if (log.isDebugEnabled()) {
                    log.debug("host_request_notification reply={}", reply);
                }
                return MACH_MSG_SUCCESS;
            case 216: 
                if (host_statistics(request, header)) {
                    return MACH_MSG_SUCCESS;
                }
            default:
                log.warn("mach_msg_trap header={}, size={}, lr={}", header, header.size(), UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_LR));
                if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
                    createBreaker(emulator).debug();
                }
                break;
        }
        return -1;
    }
    private static final int BOOTSTRAP_PORT = 11;
    private static final int CLOCK_SERVER_PORT = 13;
    private int task_self_trap() {
        log.debug("task_self_trap");
        return 1;
    }
    private int host_self_trap() {
        log.debug("host_self_trap");
        return 2;
    }
    private int thread_self_trap() {
        log.debug("thread_self_trap");
        return 3;
    }
    private int mach_reply_port() {
        log.debug("mach_reply_port");
        return 4;
    }
    private int audit_session_self() {
        log.debug("audit_session_self");
        return 5;
    }
    private int sigprocmask(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int how = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer set = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        Pointer oldset = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R2);
        return sigprocmask(emulator, how, set, oldset);
    }
    protected int gettimeofday(Emulator<?> emulator) {
        EditableArm32RegisterContext context = emulator.getContext();
        long currentTimeMillis = System.currentTimeMillis();
        long tv_sec = currentTimeMillis / 1000;
        long tv_usec = (currentTimeMillis % 1000) * 1000;
        context.setR1((int) tv_usec);
        if (log.isDebugEnabled()) {
            log.debug("gettimeofday tv_sec={}, tv_usec={}", tv_sec, tv_usec);
        }
        return (int) tv_sec;
    }
    private int writev(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer iov = context.getPointerArg(1);
        int iovcnt = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            for (int i = 0; i < iovcnt; i++) {
                Pointer iov_base = iov.getPointer(i * 8L);
                int iov_len = iov.getInt(i * 8L + 4);
                byte[] data = iov_base.getByteArray(0, iov_len);
                Inspector.inspect(data, "writev fd=" + fd + ", iov=" + iov + ", iov_base=" + iov_base);
            }
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int count = 0;
        for (int i = 0; i < iovcnt; i++) {
            Pointer iov_base = iov.getPointer(i * 8L);
            int iov_len = iov.getInt(i * 8L + 4);
            byte[] data = iov_base.getByteArray(0, iov_len);
            count += file.write(data);
        }
        return count;
    }
    private int rename(Emulator<?> emulator) {
        Arm32RegisterContext context = emulator.getContext();
        Pointer oldpath = context.getR0Pointer();
        Pointer newpath = context.getR1Pointer();
        String oldPath = oldpath.getString(0);
        String newPath = newpath.getString(0);
        int ret = emulator.getFileSystem().rename(oldPath, newPath);
        if (ret != 0) {
            log.info("rename oldPath={}, newPath={}", oldPath, newPath);
        } else {
            log.debug("rename oldPath={}, newPath={}", oldPath, newPath);
        }
        return 0;
    }
    private int mach_absolute_time(Emulator<?> emulator) {
        long nanoTime = System.nanoTime();
        if (log.isDebugEnabled()) {
            log.debug("mach_absolute_time nanoTime={}", nanoTime);
        }
        emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, (int) (nanoTime >> 32));
        return (int) (nanoTime);
    }
    private int close_NOCANCEL(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        if (log.isDebugEnabled()) {
            log.debug("close_NOCANCEL fd={}", fd);
        }
        return close(emulator, fd);
    }
    private int read_NOCANCEL(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buffer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int count = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        if (log.isDebugEnabled()) {
            log.debug("read_NOCANCEL fd={}, buffer={}, count={}", fd, buffer, count);
        }
        return read(emulator, fd, buffer, count);
    }
    private int shm_open(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pointer = context.getPointerArg(0);
        int oflags = context.getIntArg(1);
        int mode = context.getIntArg(2);
        String name = pointer.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("shm_open name={}, oflags=0x{}, mode={}", name, Integer.toHexString(oflags), Integer.toHexString(mode));
        }
        emulator.getMemory().setErrno(UnixEmulator.EACCES);
        return -1;
    }
    private int getppid(Emulator<?> emulator) {
        if (log.isDebugEnabled()) {
            log.debug("getppid");
        }
        return emulator.getPid();
    }
    private int getpid(Emulator<?> emulator) {
        int pid = emulator.getPid();
        log.debug("getpid pid={}", pid);
        return pid;
    }
    private int mkdir(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        int mode = context.getIntArg(1);
        String path = pathname.getString(0);
        if (emulator.getFileSystem().mkdir(path, mode)) {
            if (log.isDebugEnabled()) {
                log.debug("mkdir pathname={}, mode={}", path, mode);
            }
            return 0;
        } else {
            log.info("mkdir pathname={}, mode={}", path, mode);
            emulator.getMemory().setErrno(UnixEmulator.EACCES);
            return -1;
        }
    }
    private int rmdir(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        String path = pathname.getString(0);
        emulator.getFileSystem().rmdir(path);
        if (log.isDebugEnabled()) {
            log.debug("rmdir pathname={}", path);
        }
        return 0;
    }
    private int sendto(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buf = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int len = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        Pointer dest_addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R4);
        int addrlen = backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue();
        return sendto(emulator, sockfd, buf, len, flags, dest_addr, addrlen);
    }
    private int connect(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int sockfd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int addrlen = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        return connect(emulator, sockfd, addr, addrlen);
    }
    private int sigaction(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int signum = context.getIntArg(0);
        Pointer act = context.getPointerArg(1);
        Pointer oldact = context.getPointerArg(2);
        return sigaction(emulator, signum, act, oldact);
    }
    private int fcntl(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int cmd = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int arg = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        return fcntl(emulator, fd, cmd, arg);
    }
    @Override
    protected int fcntl(Emulator<?> emulator, int fd, int cmd, long arg) {
        FileIO file = fdMap.get(fd);
        if (file != null && cmd == MachO.F_GETPATH) {
            Pointer pointer = UnidbgPointer.pointer(emulator, arg & 0xffffffffL);
            assert pointer != null;
            pointer.setString(0, file.getPath());
            return 0;
        }
        return super.fcntl(emulator, fd, cmd, arg);
    }
    private int mmap(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        UnidbgPointer addr = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0);
        int length = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int prot = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        int flags = backend.reg_read(ArmConst.UC_ARM_REG_R3).intValue();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R4).intValue();
        int r5 = backend.reg_read(ArmConst.UC_ARM_REG_R5).intValue();
        long r6 = backend.reg_read(ArmConst.UC_ARM_REG_R6).intValue();
        long offset = r5 | (r6 << 32);
        int tag = fd >>> 24;
        if (tag != 0) {
            fd = -1;
        }
        boolean warning = length >= 0x10000000;
        long base = emulator.getMemory().mmap2(addr == null ? 0 : addr.peer, length, prot, flags, fd, (int) offset);
        String msg = "mmap addr=" + addr + ", length=" + length + ", prot=0x" + Integer.toHexString(prot) + ", flags=0x" + Integer.toHexString(flags) + ", fd=" + fd + ", offset=" + offset + ", tag=" + tag;
        if (log.isDebugEnabled() || warning) {
            if (warning) {
                log.warn(msg);
            } else {
                log.debug(msg);
            }
        } else {
            Logger log = LoggerFactory.getLogger("com.github.unidbg.ios.malloc");
            if (log.isDebugEnabled()) {
                log.debug(msg + ", base=0x" + Long.toHexString(base));
            }
        }
        return (int) base;
    }
    private int socket(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int domain = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        int type = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue() & 0x7ffff;
        int protocol = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        if (log.isDebugEnabled()) {
            log.debug("socket domain={}, type={}, protocol={}", domain, type, protocol);
        }
        if (protocol == SocketIO.IPPROTO_ICMP) {
            throw new UnsupportedOperationException();
        }
        int fd;
        switch (domain) {
            case SocketIO.AF_UNSPEC:
                throw new UnsupportedOperationException();
            case SocketIO.AF_LOCAL:
                if (type == SocketIO.SOCK_DGRAM) {
                    fd = getMinFd();
                    fdMap.put(fd, new LocalDarwinUdpSocket(emulator));
                    return fd;
                }
                emulator.getMemory().setErrno(UnixEmulator.EACCES);
                return -1;
            case SocketIO.AF_INET:
            case SocketIO.AF_INET6:
                switch (type) {
                    case SocketIO.SOCK_STREAM:
                        fd = getMinFd();
                        fdMap.put(fd, new TcpSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_DGRAM:
                        fd = getMinFd();
                        fdMap.put(fd, new UdpSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_RAW:
                        throw new UnsupportedOperationException();
                }
                break;
        }
        throw new UnsupportedOperationException("socket domain=" + domain + ", type=" + type + ", protocol=" + protocol);
    }
    private int write(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        int fd = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue();
        Pointer buffer = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
        int count = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        byte[] data = buffer.getByteArray(0, count);
        if (log.isDebugEnabled()) {
            log.debug("write fd={}, buffer={}, count={}", fd, buffer, count);
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.write(data);
    }
    private int mprotect(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        long address = backend.reg_read(ArmConst.UC_ARM_REG_R0).intValue() & 0xffffffffL;
        long length = backend.reg_read(ArmConst.UC_ARM_REG_R1).intValue();
        int prot = backend.reg_read(ArmConst.UC_ARM_REG_R2).intValue();
        long alignedAddress = address / ARMEmulator.PAGE_ALIGN * ARMEmulator.PAGE_ALIGN; 
        long offset = address - alignedAddress;
        long alignedLength = ARM.alignSize(length + offset, emulator.getPageAlign());
        if (log.isDebugEnabled()) {
            log.debug("mprotect address=0x{}, alignedAddress=0x{}, offset={}, length={}, alignedLength={}, prot=0x{}", Long.toHexString(address), Long.toHexString(alignedAddress), offset, length, alignedLength, Integer.toHexString(prot));
        }
        return emulator.getMemory().mprotect(alignedAddress, (int) alignedLength, prot);
    }
    @Override
    protected DarwinFileIO createByteArrayFileIO(String pathname, int oflags, byte[] data) {
        return new ByteArrayFileIO(oflags, pathname, data);
    }
    @Override
    protected DarwinFileIO createDriverFileIO(Emulator<?> emulator, int oflags, String pathname) {
        return DriverFileIO.create(emulator, oflags, pathname);
    }
}
package com.github.unidbg;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.debugger.DebuggerType;
import com.github.unidbg.file.FileSystem;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.listener.TraceCodeListener;
import com.github.unidbg.listener.TraceReadListener;
import com.github.unidbg.listener.TraceSystemMemoryWriteListener;
import com.github.unidbg.listener.TraceWriteListener;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.serialize.Serializable;
import com.github.unidbg.spi.ArmDisassembler;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.spi.LibraryFile;
import com.github.unidbg.spi.SyscallHandler;
import com.github.unidbg.thread.ThreadDispatcher;
import com.github.unidbg.unwind.Unwinder;
import java.io.Closeable;
import java.io.File;
import java.net.URL;
public interface Emulator<T extends NewFileIO> extends Closeable, ArmDisassembler, Serializable {
    int getPointerSize();
    boolean is64Bit();
    boolean is32Bit();
    int getPageAlign();
    TraceHook traceRead();
    TraceHook traceRead(long begin, long end);
    TraceHook traceRead(long begin, long end, TraceReadListener listener);
    TraceHook traceWrite();
    TraceHook traceWrite(long begin, long end);
    TraceHook traceWrite(long begin, long end, TraceWriteListener listener);
    void setTraceSystemMemoryWrite(long begin, long end, TraceSystemMemoryWriteListener listener);
    TraceHook traceCode();
    TraceHook traceCode(long begin, long end);
    TraceHook traceCode(long begin, long end, TraceCodeListener listener);
    Number eFunc(long begin, Number... arguments);
    Number eEntry(long begin, long sp);
    boolean emulateSignal(int sig);
    boolean isRunning();
    void showRegs();
    void showRegs(int... regs);
    Module loadLibrary(File libraryFile);
    Module loadLibrary(File libraryFile, boolean forceCallInit);
    Memory getMemory();
    Backend getBackend();
    int getPid();
    String getProcessName();
    Debugger attach();
    Debugger attach(DebuggerType type);
    FileSystem<T> getFileSystem();
    SvcMemory getSvcMemory();
    SyscallHandler<T> getSyscallHandler();
    Family getFamily();
    LibraryFile createURLibraryFile(URL url, String libName);
    Dlfcn getDlfcn();
    void setTimeout(long timeout);
    <V extends RegisterContext> V getContext();
    Unwinder getUnwinder();
    void pushContext(int off);
    int popContext();
    ThreadDispatcher getThreadDispatcher();
    long getReturnAddress();
    void set(String key, Object value);
    <V> V get(String key);
}
package com.github.unidbg.file;
public class FileResult<T extends NewFileIO> {
    private static final int FALLBACK_ERRNO = -1;
    public static <T extends NewFileIO> FileResult<T> success(T io) {
        if (io == null) {
            throw new NullPointerException("io is null");
        }
        return new FileResult<>(io, 0);
    }
    public static <T extends NewFileIO> FileResult<T> failed(int errno) {
        if (errno == 0) {
            throw new IllegalArgumentException("errno=" + errno);
        }
        return new FileResult<>(null, errno);
    }
    public static <T extends NewFileIO> FileResult<T> fallback(T io) {
        if (io == null) {
            throw new NullPointerException("io is null");
        }
        return new FileResult<>(io, FALLBACK_ERRNO);
    }
    public final T io;
    public final int errno;
    public boolean isSuccess() {
        return io != null && errno == 0;
    }
    public boolean isFallback() {
        return io != null && errno == FALLBACK_ERRNO;
    }
    private FileResult(T io, int errno) {
        this.io = io;
        this.errno = errno;
    }
}
package com.github.unidbg.unix.struct;
import com.github.unidbg.pointer.UnidbgStructure;
import com.sun.jna.Pointer;
import java.util.Arrays;
import java.util.List;
public class TimeVal64 extends UnidbgStructure {
    public TimeVal64(Pointer p) {
        super(p);
    }
    public long tv_sec;
    public long tv_usec;
    @Override
    protected List<String> getFieldOrder() {
        return Arrays.asList("tv_sec", "tv_usec");
    }
}
package com.github.unidbg.debugger;
import com.github.unidbg.pointer.UnidbgPointer;
public interface Breaker {
    void debug();
    void brk(UnidbgPointer pc, int svcNumber);
}
package com.github.unidbg.thread;
import com.github.unidbg.AbstractEmulator;
public abstract class MainTask extends AbstractTask implements Task {
    protected final long until;
    protected MainTask(int pid, long until) {
        super(pid);
        this.until = until;
    }
    @Override
    public Number dispatch(AbstractEmulator<?> emulator) throws PopContextException {
        if (isContextSaved()) {
            return continueRun(emulator, until);
        }
        return run(emulator);
    }
    protected abstract Number run(AbstractEmulator<?> emulator);
    @Override
    public boolean isMainThread() {
        return true;
    }
    @Override
    public boolean isFinish() {
        return false;
    }
}
package com.github.unidbg.spi;
import com.github.unidbg.Emulator;
import com.github.unidbg.arm.backend.InterruptHook;
import com.github.unidbg.debugger.Breaker;
import com.github.unidbg.file.FileIO;
import com.github.unidbg.file.IOResolver;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.serialize.Serializable;
import com.github.unidbg.thread.MainTask;
import com.github.unidbg.unix.FileListener;
public interface SyscallHandler<T extends NewFileIO> extends InterruptHook, Serializable {
    int DARWIN_SWI_SYSCALL = 0x80;
    void addIOResolver(IOResolver<T> resolver);
    int open(Emulator<T> emulator, String pathname, int oflags);
    void setVerbose(boolean verbose);
    boolean isVerbose();
    void setFileListener(FileListener fileListener);
    void setBreaker(Breaker breaker);
    void setEnableThreadDispatcher(boolean threadDispatcherEnabled);
    MainTask createSignalHandlerTask(Emulator<?> emulator, int sig);
    FileIO getFileIO(int fd);
    void closeFileIO(int fd);
    int addFileIO(T io);
    void destroy();
}
package com.github.unidbg.unix.struct;
import com.github.unidbg.pointer.UnidbgStructure;
import com.sun.jna.Pointer;
import java.util.Arrays;
import java.util.List;
public class TimeVal32 extends UnidbgStructure {
    public TimeVal32(Pointer p) {
        super(p);
    }
    public int tv_sec;
    public int tv_usec;
    @Override
    protected List<String> getFieldOrder() {
        return Arrays.asList("tv_sec", "tv_usec");
    }
}
package com.github.unidbg.file;
public interface NewFileIO extends FileIO {
    boolean canRead();
}
package com.github.unidbg.ios;
import com.github.unidbg.Alignment;
import com.github.unidbg.Emulator;
import com.github.unidbg.LibraryResolver;
import com.github.unidbg.Module;
import com.github.unidbg.Svc;
import com.github.unidbg.Symbol;
import com.github.unidbg.Utils;
import com.github.unidbg.arm.ARM;
import com.github.unidbg.arm.Arm64Hook;
import com.github.unidbg.arm.Arm64Svc;
import com.github.unidbg.arm.ArmHook;
import com.github.unidbg.arm.ArmSvc;
import com.github.unidbg.arm.HookStatus;
import com.github.unidbg.arm.backend.BackendException;
import com.github.unidbg.arm.context.Arm32RegisterContext;
import com.github.unidbg.arm.context.Arm64RegisterContext;
import com.github.unidbg.file.FileIO;
import com.github.unidbg.file.IOResolver;
import com.github.unidbg.file.ios.DarwinFileIO;
import com.github.unidbg.file.ios.IOConstants;
import com.github.unidbg.hook.HookListener;
import com.github.unidbg.ios.patch.LibDyldPatcher;
import com.github.unidbg.ios.struct.kernel.Pthread;
import com.github.unidbg.ios.struct.kernel.Pthread32;
import com.github.unidbg.ios.struct.kernel.Pthread64;
import com.github.unidbg.ios.struct.kernel.VmRemapRequest;
import com.github.unidbg.ios.struct.sysctl.DyldImageInfo32;
import com.github.unidbg.ios.struct.sysctl.DyldImageInfo64;
import com.github.unidbg.memory.MemRegion;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.MemoryAllocBlock;
import com.github.unidbg.memory.MemoryBlock;
import com.github.unidbg.memory.MemoryBlockImpl;
import com.github.unidbg.memory.MemoryMap;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.pointer.UnidbgStructure;
import com.github.unidbg.spi.AbstractLoader;
import com.github.unidbg.spi.LibraryFile;
import com.github.unidbg.spi.Loader;
import com.github.unidbg.thread.Task;
import com.github.unidbg.unix.IO;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import io.kaitai.MachO;
import io.kaitai.struct.ByteBufferKaitaiStream;
import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.ArmConst;
import unicorn.Unicorn;
import unicorn.UnicornConst;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
public class MachOLoader extends AbstractLoader<DarwinFileIO> implements Memory, Loader, com.github.unidbg.ios.MachO {
    private static final Logger log = LoggerFactory.getLogger(MachOLoader.class);
    private boolean objcRuntime;
    MachOLoader(Emulator<DarwinFileIO> emulator, UnixSyscallHandler<DarwinFileIO> syscallHandler, String[] envs) {
        super(emulator, syscallHandler);
        stackSize = STACK_SIZE_OF_PAGE * emulator.getPageAlign();
        backend.mem_map(STACK_BASE - stackSize, stackSize, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE);
        setStackPoint(STACK_BASE);
        initializeTSD(envs);
    }
    @SuppressWarnings("unchecked")
    @Override
    public void setLibraryResolver(LibraryResolver libraryResolver) {
        if (libraryResolver instanceof IOResolver) {
            syscallHandler.addIOResolver((IOResolver<DarwinFileIO>) libraryResolver);
        }
        super.setLibraryResolver(libraryResolver);
        syscallHandler.open(emulator, IO.STDIN, IOConstants.O_RDONLY);
        syscallHandler.open(emulator, IO.STDOUT, IOConstants.O_WRONLY);
        syscallHandler.open(emulator, IO.STDERR, IOConstants.O_WRONLY);
    }
    @Override
    protected LibraryFile createLibraryFile(File file) {
        return new MachOLibraryFile(file);
    }
    public void setObjcRuntime(boolean objcRuntime) {
        this.objcRuntime = objcRuntime;
    }
    private UnidbgPointer vars;
    private Pointer errno;
    final void setErrnoPointer(Pointer errno) {
        this.errno = errno.getPointer(0);
        this.setErrno(0);
    }
    public static final long __TSD_THREAD_SELF = 0;
    public static final long __TSD_ERRNO = 1;
    public static final long __TSD_MIG_REPLY = 2;
    private void initializeTSD(String[] envs) {
        List<String> envList = new ArrayList<>();
        envList.add("MallocCorruptionAbort=0");
        for (String env : envs) {
            int index = env.indexOf('=');
            if (index != -1) {
                envList.add(env);
            }
        }
        final Pointer environ = allocateStack(emulator.getPointerSize() * (envList.size() + 1));
        assert environ != null;
        Pointer pointer = environ;
        for (String env : envList) {
            Pointer envPointer = writeStackString(env);
            pointer.setPointer(0, envPointer);
            pointer = pointer.share(emulator.getPointerSize());
        }
        pointer.setPointer(0, null);
        UnidbgPointer _NSGetEnviron = allocateStack(emulator.getPointerSize());
        _NSGetEnviron.setPointer(0, environ);
        final Pointer programName = writeStackString(emulator.getProcessName());
        Pointer _NSGetProgname = allocateStack(emulator.getPointerSize());
        _NSGetProgname.setPointer(0, programName);
        Pointer _NSGetArgc = allocateStack(emulator.getPointerSize());
        _NSGetArgc.setInt(0, 1);
        Pointer args = allocateStack(emulator.getPointerSize());
        args.setPointer(0, programName);
        Pointer _NSGetArgv = allocateStack(emulator.getPointerSize());
        _NSGetArgv.setPointer(0, args);
        vars = allocateStack(emulator.getPointerSize() * 5);
        vars.setPointer(0, null); 
        vars.setPointer(emulator.getPointerSize(), _NSGetArgc);
        vars.setPointer(2L * emulator.getPointerSize(), _NSGetArgv);
        vars.setPointer(3L * emulator.getPointerSize(), _NSGetEnviron);
        vars.setPointer(4L * emulator.getPointerSize(), _NSGetProgname);
        final Pointer thread = allocateStack(UnidbgStructure.calculateSize(emulator.is64Bit() ? Pthread64.class : Pthread32.class)); 
        Pthread pthread = Pthread.create(emulator, thread);
        final UnidbgPointer tsd = pthread.getTSD(); 
        assert tsd != null;
        tsd.setPointer(__TSD_THREAD_SELF, thread);
        tsd.setPointer(__TSD_ERRNO * emulator.getPointerSize(), errno);
        tsd.setPointer(__TSD_MIG_REPLY * emulator.getPointerSize(), null);
        if (emulator.is32Bit()) {
            backend.reg_write(ArmConst.UC_ARM_REG_C13_C0_3, tsd.peer);
        } else {
            backend.reg_write(Arm64Const.UC_ARM64_REG_TPIDRRO_EL0, tsd.peer);
        }
        long sp = getStackPoint();
        sp &= (~(emulator.is64Bit() ? 15 : 7));
        setStackPoint(sp);
        if (log.isDebugEnabled()) {
            log.debug("initializeTSD tsd={}, thread={}, environ={}, vars={}, sp=0x{}, errno={}", tsd, thread, environ, vars, Long.toHexString(getStackPoint()), errno);
        }
        addModuleListener(new LibDyldPatcher(_NSGetArgc, _NSGetArgv, _NSGetEnviron, _NSGetProgname));
    }
    public final void onExecutableLoaded(String executable) {
        if (callInitFunction) {
            for (MachOModule m : modules.values().toArray(new MachOModule[0])) {
                boolean needCallInit = m.symbolNotBound.isEmpty() || isPayloadModule(m) || m.getPath().equals(executable);
                if (needCallInit) {
                    m.doInitialization(emulator);
                }
            }
        }
    }
    @Override
    protected Module loadInternal(LibraryFile libraryFile, boolean forceCallInit) {
        try {
            return loadInternal(libraryFile, forceCallInit, true);
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }
    private MachOModule loadInternal(LibraryFile libraryFile, boolean forceCallInit, boolean checkBootstrap) throws IOException {
        MachOModule module = loadInternalPhase(libraryFile, true, checkBootstrap, Collections.emptyList());
        for (MachOModule export : modules.values().toArray(new MachOModule[0])) {
            for (NeedLibrary library : export.lazyLoadNeededList.toArray(new NeedLibrary[0])) {
                String neededLibrary = library.path;
                if (log.isDebugEnabled()) {
                    log.debug("{} need dependency {}", export.getPath(), neededLibrary);
                }
                MachOModule loaded = modules.get(FilenameUtils.getName(neededLibrary));
                if (loaded != null) {
                    if (library.upward) {
                        export.upwardLibraries.put(FilenameUtils.getBaseName(neededLibrary), loaded);
                    }
                    continue;
                }
                LibraryFile neededLibraryFile = resolveLibrary(libraryFile, neededLibrary, Collections.singletonList(FilenameUtils.getFullPath(libraryFile.getPath())));
                if (neededLibraryFile != null) {
                    MachOModule needed = loadInternalPhase(neededLibraryFile, true, false, Collections.emptySet());
                    needed.addReferenceCount();
                    if (library.upward) {
                        export.upwardLibraries.put(FilenameUtils.getBaseName(needed.name), needed);
                    }
                } else if (!library.weak) {
                    log.info("{} load NOT weak dependency {} failed", export.getPath(), neededLibrary);
                }
            }
            export.lazyLoadNeededList.clear();
        }
        for (MachOModule m : modules.values()) {
            processBind(m);
            m.callObjcNotifyMapped(_objcNotifyMapped);
        }
        notifySingle(Dyld.dyld_image_state_bound, module);
        notifySingle(Dyld.dyld_image_state_dependents_initialized, module);
        if (callInitFunction || forceCallInit) {
            MachOModule[] modules = this.modules.values().toArray(new MachOModule[0]);
            for (MachOModule m : modules) {
                if (isPayloadModule(m)) {
                    continue;
                }
                if (m.symbolNotBound.isEmpty() || forceCallInit) {
                    m.callObjcNotifyInit(_objcNotifyInit);
                    m.doInitialization(emulator);
                }
            }
        }
        for (MachOModule m : modules.values().toArray(new MachOModule[0])) {
            notifySingle(Dyld.dyld_image_state_initialized, m);
        }
        return module;
    }
    private com.github.unidbg.ios.Loader loader;
    public void setLoader(com.github.unidbg.ios.Loader loader) {
        this.loader = loader;
    }
    final boolean isPayloadModule(Module module) {
        return loader != null && loader.isPayloadModule(module.getPath());
    }
    private MachOModule loadInternalPhase(LibraryFile libraryFile, boolean loadNeeded, boolean checkBootstrap, Collection<String> parentRpath) {
        try {
            ByteBuffer buffer = libraryFile.mapBuffer();
            return loadInternalPhase(libraryFile, buffer, loadNeeded, checkBootstrap, parentRpath);
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }
    private MachOModule loadInternalPhase(LibraryFile libraryFile, ByteBuffer buffer,
                                          boolean loadNeeded, boolean checkBootstrap, Collection<String> parentRpath) throws IOException {
        MachO machO = new MachO(new ByteBufferKaitaiStream(buffer));
        MachO.MagicType magic = machO.magic();
        switch (magic) {
            case FAT_BE:
                Map<Long, MachO.FatArch> archMap = new HashMap<>();
                for (MachO.FatArch arch : machO.fatHeader().fatArchs()) {
                    if ((arch.cputype() == MachO.CpuType.ARM && emulator.is32Bit()) || (arch.cputype() == MachO.CpuType.ARM64 && emulator.is64Bit())) {
                        archMap.put(arch.cpusubtype(), arch);
                    }
                }
                MachO.FatArch arch = archMap.get(CPU_SUBTYPE_ARM_V7); 
                if (arch == null) {
                    Iterator<MachO.FatArch> iterator = archMap.values().iterator();
                    if (iterator.hasNext()) {
                        arch = iterator.next();
                    }
                }
                if (arch != null) {
                    buffer.limit((int) (arch.offset() + arch.size()));
                    buffer.position((int) arch.offset());
                    if (log.isDebugEnabled()) {
                        log.debug("loadFatArch={}, cpuSubType={}", arch.cputype(), arch.cpusubtype());
                    }
                    return loadInternalPhase(libraryFile, buffer.slice(), loadNeeded, checkBootstrap, parentRpath);
                }
                throw new IllegalArgumentException("find arch failed");
            case MACHO_LE_X86: 
                if (machO.header().cputype() != MachO.CpuType.ARM) {
                    throw new UnsupportedOperationException("cpuType=" + machO.header().cputype());
                }
                if (emulator.is64Bit()) {
                    throw new UnsupportedOperationException("NOT 64 bit executable: " + libraryFile.getName());
                }
                break;
            case MACHO_LE_X64:
                if (machO.header().cputype() != MachO.CpuType.ARM64) {
                    throw new UnsupportedOperationException("cpuType=" + machO.header().cputype());
                }
                if (emulator.is32Bit()) {
                    throw new UnsupportedOperationException("NOT 32 bit executable: " + libraryFile.getName());
                }
                break;
            default:
                throw new UnsupportedOperationException("magic=" + magic);
        }
        switch (machO.header().filetype()) {
            case DYLIB:
            case EXECUTE:
                break;
            default:
                throw new UnsupportedOperationException("fileType=" + machO.header().filetype());
        }
        final boolean isExecutable = machO.header().filetype() == MachO.FileType.EXECUTE;
        final boolean isPositionIndependent = (machO.header().flags() & MH_PIE) != 0;
        if (checkBootstrap && !isExecutable && executableModule == null) {
            URL url = getClass().getResource(objcRuntime ? "/ios/bootstrap_objc" : "/ios/bootstrap");
            String path = "unidbg_bootstrap";
            if (libraryFile instanceof DarwinLibraryFile) {
                path = ((DarwinLibraryFile) libraryFile).resolveBootstrapPath();
            }
            loadInternal(new URLibraryFile(url, path, null), false, false);
        }
        long start = System.currentTimeMillis();
        long size = 0;
        String dyId = libraryFile.getName();
        MachO.DyldInfoCommand dyldInfoCommand = null;
        MachO.LinkeditDataCommand chainedFixups = null;
        MachOModule subModule = null;
        boolean finalSegment = false;
        Set<String> rpathSet = new LinkedHashSet<>(2);
        byte[] uuid = null;
        String dylibPath = FilenameUtils.normalize(libraryFile.getPath(), true);
        for (MachO.LoadCommand command : machO.loadCommands()) {
            if (command == null) {
                throw new NullPointerException();
            }
            switch (command.type()) {
                case DYLD_INFO:
                case DYLD_INFO_ONLY:
                    if (dyldInfoCommand != null) {
                        throw new IllegalStateException("dyldInfoCommand=" + dyldInfoCommand);
                    }
                    dyldInfoCommand = (MachO.DyldInfoCommand) command.body();
                    break;
                case DYLD_CHAINED_FIXUPS:
                    if (chainedFixups != null) {
                        throw new IllegalStateException("chainedFixups=" + chainedFixups);
                    }
                    chainedFixups = (MachO.LinkeditDataCommand) command.body();
                    break;
                case SEGMENT: {
                    MachO.SegmentCommand segmentCommand = (MachO.SegmentCommand) command.body();
                    if ("__PAGEZERO".equals(segmentCommand.segname())) {
                        break;
                    }
                    if (segmentCommand.filesize() > segmentCommand.vmsize()) {
                        throw new IllegalStateException(String.format("malformed mach-o image: segment load command %s filesize is larger than vmsize", command.type()));
                    }
                    if (finalSegment) {
                        throw new IllegalStateException("finalSegment");
                    }
                    if (((segmentCommand.vmaddr() + segmentCommand.vmsize()) % emulator.getPageAlign()) != 0) {
                        finalSegment = true;
                    }
                    if (segmentCommand.vmaddr() % emulator.getPageAlign() != 0) {
                        throw new IllegalArgumentException("vmaddr not page aligned");
                    }
                    if (segmentCommand.vmsize() == 0) {
                        break;
                    }
                    if (segmentCommand.vmsize() < segmentCommand.filesize()) {
                        throw new IllegalStateException(String.format("malformed mach-o image: segment %s has vmsize < filesize", command.type()));
                    }
                    long vmsize = ARM.alignSize(segmentCommand.vmsize(), emulator.getPageAlign());
                    long high = segmentCommand.vmaddr() + vmsize;
                    if (size < high) {
                        size = high;
                    }
                    break;
                }
                case SEGMENT_64: {
                    MachO.SegmentCommand64 segmentCommand64 = (MachO.SegmentCommand64) command.body();
                    if ("__PAGEZERO".equals(segmentCommand64.segname())) {
                        break;
                    }
                    if (segmentCommand64.filesize() > segmentCommand64.vmsize()) {
                        throw new IllegalStateException(String.format("malformed mach-o image: segment load command %s filesize is larger than vmsize", command.type()));
                    }
                    if (finalSegment) {
                        throw new IllegalStateException("finalSegment");
                    }
                    if (((segmentCommand64.vmaddr() + segmentCommand64.vmsize()) % emulator.getPageAlign()) != 0) {
                        finalSegment = true;
                    }
                    if (segmentCommand64.vmaddr() % emulator.getPageAlign() != 0) {
                        throw new IllegalArgumentException("vmaddr not page aligned");
                    }
                    if (segmentCommand64.vmsize() == 0) {
                        break;
                    }
                    if (segmentCommand64.vmsize() < segmentCommand64.filesize()) {
                        throw new IllegalStateException(String.format("malformed mach-o image: segment %s has vmsize < filesize", command.type()));
                    }
                    long vmsize = ARM.alignSize(segmentCommand64.vmsize(), emulator.getPageAlign());
                    long high = segmentCommand64.vmaddr() + vmsize;
                    if (size < high) {
                        size = high;
                    }
                    break;
                }
                case ID_DYLIB:
                    MachO.DylibCommand dylibCommand = (MachO.DylibCommand) command.body();
                    String dylibName = dylibCommand.name();
                    if (loader != null && loader.isPayloadModule(dylibPath)) {
                        dylibPath = dylibPath.replace("@executable_path/", "");
                    } else if (dylibName.startsWith("/")) {
                        dylibPath = dylibName;
                    }
                    int index = dylibPath.indexOf('/'); 
                    if (index != -1) {
                        String first = dylibPath.substring(0, index);
                        String second = dylibPath.substring(index + 1);
                        if (first.equals(second)) {
                            dylibPath = "/System/Library/Frameworks/" + first + ".framework/" + first;
                        }
                    }
                    dyId = FilenameUtils.getName(dylibName);
                    break;
                case LOAD_DYLIB:
                case REEXPORT_DYLIB:
                case LOAD_UPWARD_DYLIB:
                case SYMTAB:
                case DYSYMTAB:
                    break;
                case ENCRYPTION_INFO:
                case ENCRYPTION_INFO_64:
                    MachO.EncryptionInfoCommand encryptionInfoCommand = (MachO.EncryptionInfoCommand) command.body();
                    if (encryptionInfoCommand.cryptid() != 0) {
                        throw new UnsupportedOperationException("Encrypted file: " + libraryFile.getName());
                    }
                    break;
                case UUID:
                    MachO.UuidCommand uuidCommand = (MachO.UuidCommand) command.body();
                    uuid = uuidCommand.uuid();
                    break;
                case FUNCTION_STARTS:
                case DATA_IN_CODE:
                case CODE_SIGNATURE:
                case SOURCE_VERSION:
                case SEGMENT_SPLIT_INFO:
                case DYLIB_CODE_SIGN_DRS:
                case SUB_FRAMEWORK:
                case VERSION_MIN_IPHONEOS:
                case LOAD_DYLINKER:
                case MAIN:
                case ROUTINES:
                case ROUTINES_64:
                case LOAD_WEAK_DYLIB:
                case BUILD_VERSION:
                case DYLD_EXPORTS_TRIE:
                    break;
                case SUB_CLIENT:
                    MachO.SubCommand subCommand = (MachO.SubCommand) command.body();
                    String name = subCommand.name().value();
                    MachOModule module = (MachOModule) findModule(name);
                    if (module == null) {
                        log.debug("Find sub client failed: {}", name);
                    } else {
                        subModule = module;
                    }
                    break;
                case RPATH:
                    MachO.RpathCommand rpathCommand = (MachO.RpathCommand) command.body();
                    String rpath = rpathCommand.path();
                    if (!rpath.contains("@loader_path/")) {
                        rpathSet.add(rpath);
                    }
                    break;
                default:
                    log.info("Not handle loadCommand={}, dylibPath={}", command.type(), dylibPath);
                    break;
            }
        }
        rpathSet.addAll(parentRpath);
        final long loadBase = isExecutable ? 0 : mmapBaseAddress;
        long machHeader = -1;
        if (isExecutable) {
            long end = loadBase + size;
            if (end >= mmapBaseAddress) {
                setMMapBaseAddress(end);
            }
        } else {
            setMMapBaseAddress(loadBase + size);
        }
        if (log.isDebugEnabled()) {
            log.debug(Inspector.inspectString(uuid, "start map dyid=" + dyId + ", base=0x" + Long.toHexString(loadBase) + ", size=0x" + Long.toHexString(size) + ", rpath=" + rpathSet + ", uuid=" + Utils.toUUID(uuid)));
        }
        final List<NeedLibrary> neededList = new ArrayList<>();
        final List<MemRegion> regions = new ArrayList<>(5);
        final List<MachO.DylibCommand> exportDylibs = new ArrayList<>();
        MachO.SymtabCommand symtabCommand = null;
        MachO.DysymtabCommand dysymtabCommand = null;
        MachO.EntryPointCommand entryPointCommand = null;
        List<String> ordinalList = new ArrayList<>();
        Section fEHFrameSection = null;
        Section fUnwindInfoSection = null;
        Map<String, MachO.SegmentCommand64.Section64> objcSections = new HashMap<>();
        List<Segment> segments = new ArrayList<>(10);
        for (MachO.LoadCommand command : machO.loadCommands()) {
            switch (command.type()) {
                case SEGMENT: {
                    MachO.SegmentCommand segmentCommand = (MachO.SegmentCommand) command.body();
                    long begin = loadBase + segmentCommand.vmaddr();
                    if ("__PAGEZERO".equals(segmentCommand.segname())) {
                        segments.add(new Segment(segmentCommand.vmaddr(), segmentCommand.vmsize(), segmentCommand.fileoff(), segmentCommand.filesize()));
                        regions.add(new MemRegion(begin, begin, begin + segmentCommand.vmsize(), 0, libraryFile, segmentCommand.vmaddr()));
                        break;
                    }
                    segments.add(new Segment(segmentCommand.vmaddr(), segmentCommand.vmsize(), segmentCommand.fileoff(), segmentCommand.filesize()));
                    boolean isTextSeg = "__TEXT".equals(segmentCommand.segname());
                    for (MachO.SegmentCommand.Section section : segmentCommand.sections()) {
                        String sectName = section.sectName();
                        checkSection(dyId, segmentCommand.segname(), sectName);
                    }
                    if (segmentCommand.vmsize() == 0) {
                        regions.add(new MemRegion(begin, begin, begin, 0, libraryFile, segmentCommand.vmaddr()));
                        break;
                    }
                    int prot = get_segment_protection(segmentCommand.initprot());
                    if (prot == UnicornConst.UC_PROT_NONE) {
                        prot = UnicornConst.UC_PROT_ALL;
                    }
                    if (machHeader == -1 && isTextSeg) {
                        machHeader = begin;
                    }
                    Alignment alignment = this.mem_map(begin, segmentCommand.vmsize(), prot, dyId, emulator.getPageAlign());
                    write_mem((int) segmentCommand.fileoff(), (int) segmentCommand.filesize(), begin, buffer);
                    regions.add(new MemRegion(begin, alignment.address, alignment.address + alignment.size, prot, libraryFile, segmentCommand.vmaddr()));
                    break;
                }
                case SEGMENT_64: {
                    MachO.SegmentCommand64 segmentCommand64 = (MachO.SegmentCommand64) command.body();
                    long begin = loadBase + segmentCommand64.vmaddr();
                    if ("__PAGEZERO".equals(segmentCommand64.segname())) {
                        segments.add(new Segment(segmentCommand64.vmaddr(), segmentCommand64.vmsize(), segmentCommand64.fileoff(), segmentCommand64.filesize()));
                        regions.add(new MemRegion(begin, begin, begin + segmentCommand64.vmsize(), 0, libraryFile, segmentCommand64.vmaddr()));
                        break;
                    }
                    segments.add(new Segment(segmentCommand64.vmaddr(), segmentCommand64.vmsize(), segmentCommand64.fileoff(), segmentCommand64.filesize()));
                    boolean isTextSeg = "__TEXT".equals(segmentCommand64.segname());
                    for (MachO.SegmentCommand64.Section64 section : segmentCommand64.sections()) {
                        String sectName = section.sectName();
                        if (isTextSeg && "__eh_frame".equals(sectName)) {
                            fEHFrameSection = new Section(section.addr(), section.size());
                            continue;
                        }
                        if (isTextSeg && "__unwind_info".equals(sectName)) {
                            fUnwindInfoSection = new Section(section.addr(), section.size());
                            continue;
                        }
                        if (sectName.startsWith("__objc_")) {
                            objcSections.put(sectName, section);
                            continue;
                        }
                        checkSection(dyId, segmentCommand64.segname(), sectName);
                    }
                    if (segmentCommand64.vmsize() == 0) {
                        regions.add(new MemRegion(begin, begin, begin, 0, libraryFile, segmentCommand64.vmaddr()));
                        break;
                    }
                    int prot = get_segment_protection(segmentCommand64.initprot());
                    if (prot == UnicornConst.UC_PROT_NONE) {
                        prot = UnicornConst.UC_PROT_ALL;
                    }
                    if (machHeader == -1 && isTextSeg) {
                        machHeader = begin;
                    }
                    Alignment alignment = this.mem_map(begin, segmentCommand64.vmsize(), prot, dyId, emulator.getPageAlign());
                    if (log.isDebugEnabled()) {
                        log.debug("mem_map address=0x{}, size=0x{}", Long.toHexString(alignment.address), Long.toHexString(alignment.size));
                    }
                    write_mem((int) segmentCommand64.fileoff(), (int) segmentCommand64.filesize(), begin, buffer);
                    regions.add(new MemRegion(begin, alignment.address, alignment.address + alignment.size, prot, libraryFile, segmentCommand64.vmaddr()));
                    break;
                }
                case LOAD_DYLIB: {
                    MachO.DylibCommand dylibCommand = (MachO.DylibCommand) command.body();
                    ordinalList.add(dylibCommand.name());
                    neededList.add(new NeedLibrary(dylibCommand.name(), false, false));
                    break;
                }
                case LOAD_WEAK_DYLIB: {
                    MachO.DylibCommand dylibCommand = (MachO.DylibCommand) command.body();
                    ordinalList.add(dylibCommand.name());
                    neededList.add(new NeedLibrary(dylibCommand.name(), true, true));
                    break;
                }
                case REEXPORT_DYLIB: {
                    MachO.DylibCommand dylibCommand = (MachO.DylibCommand) command.body();
                    ordinalList.add(dylibCommand.name());
                    exportDylibs.add((MachO.DylibCommand) command.body());
                    break;
                }
                case LAZY_LOAD_DYLIB: {
                    MachO.DylibCommand dylibCommand = (MachO.DylibCommand) command.body();
                    ordinalList.add(dylibCommand.name());
                    break;
                }
                case LOAD_UPWARD_DYLIB:
                    MachO.DylibCommand dylibCommand = (MachO.DylibCommand) command.body();
                    ordinalList.add(dylibCommand.name());
                    neededList.add(new NeedLibrary(dylibCommand.name(), true, false));
                    break;
                case SYMTAB:
                    symtabCommand = (MachO.SymtabCommand) command.body();
                    break;
                case DYSYMTAB:
                    dysymtabCommand = (MachO.DysymtabCommand) command.body();
                    break;
                case MAIN:
                    entryPointCommand = (MachO.EntryPointCommand) command.body();
                    break;
            }
        }
        Logger log = LoggerFactory.getLogger("com.github.unidbg.ios." + dyId);
        if (!log.isDebugEnabled()) {
            log = MachOLoader.log;
        }
        if (log.isDebugEnabled()) {
            log.debug("load dyId={}, base=0x{}, dyldInfoCommand={}, loadNeeded={}, regions={}, isPositionIndependent={}", dyId, Long.toHexString(loadBase), dyldInfoCommand, loadNeeded, regions, isPositionIndependent);
        }
        Map<String, Module> exportModules = new LinkedHashMap<>();
        if (rpathSet.isEmpty()) {
            rpathSet.add(FilenameUtils.getFullPath(dylibPath));
        }
        for (MachO.DylibCommand dylibCommand : exportDylibs) {
            String neededLibrary = dylibCommand.name();
            if (log.isDebugEnabled()) {
                log.debug("{} need export dependency {}", dyId, neededLibrary);
            }
            MachOModule loaded = modules.get(FilenameUtils.getName(neededLibrary));
            if (loaded != null) {
                loaded.addReferenceCount();
                exportModules.put(FilenameUtils.getBaseName(loaded.name), loaded);
                continue;
            }
            LibraryFile neededLibraryFile = resolveLibrary(libraryFile, neededLibrary, rpathSet);
            if (neededLibraryFile != null) {
                MachOModule needed = loadInternalPhase(neededLibraryFile, false, false, rpathSet);
                needed.addReferenceCount();
                exportModules.put(FilenameUtils.getBaseName(needed.name), needed);
            } else if(log.isDebugEnabled()) {
                log.debug("{} load export dependency {} failed", dyId, neededLibrary);
            }
        }
        Map<String, MachOModule> neededLibraries = new LinkedHashMap<>();
        Map<String, Module> upwardLibraries = new LinkedHashMap<>();
        final List<NeedLibrary> lazyLoadNeededList;
        if (loadNeeded) {
            lazyLoadNeededList = new ArrayList<>();
            for (NeedLibrary library : neededList) {
                String neededLibrary = library.path;
                if (log.isDebugEnabled()) {
                    log.debug("{} need dependency {}", dyId, neededLibrary);
                }
                MachOModule loaded = modules.get(FilenameUtils.getName(neededLibrary));
                if (loaded != null) {
                    loaded.addReferenceCount();
                    neededLibraries.put(FilenameUtils.getBaseName(loaded.name), loaded);
                    continue;
                }
                if (library.upward) {
                    lazyLoadNeededList.add(library);
                    continue;
                }
                LibraryFile neededLibraryFile = resolveLibrary(libraryFile, neededLibrary, rpathSet);
                if (neededLibraryFile != null) {
                    MachOModule needed = loadInternalPhase(neededLibraryFile, true, false, rpathSet);
                    needed.addReferenceCount();
                    neededLibraries.put(FilenameUtils.getBaseName(needed.name), needed);
                } else if(!library.weak) {
                    if ("/usr/lib/libnetwork.dylib".equals(neededLibrary)) {
                        continue;
                    }
                    log.info("Module \"{}\" load dependency {} failed: rpath={}", dyId, neededLibrary, rpathSet);
                }
            }
        } else {
            lazyLoadNeededList = neededList;
        }
        if (log.isDebugEnabled()) {
            log.debug("load dyId={}, base=0x{}, neededLibraries={}, upwardLibraries={}", dyId, Long.toHexString(loadBase), neededLibraries, upwardLibraries);
        }
        final long loadSize = size;
        MachOModule module = new MachOModule(machO, dyId, loadBase, loadSize, new HashMap<>(neededLibraries), regions,
                symtabCommand, dysymtabCommand, buffer, lazyLoadNeededList, upwardLibraries, exportModules, dylibPath, emulator,
                dyldInfoCommand, chainedFixups, null, null, vars, machHeader, isExecutable, this, hookListeners, ordinalList,
                fEHFrameSection, fUnwindInfoSection, objcSections, segments.toArray(new Segment[0]), libraryFile);
        if (isExecutable) {
            setExecuteModule(module);
        }
        for(MachOModule mm : modules.values()) {
            mm.onLoadNewModule(module);
        }
        modules.put(dyId, module);
        path_modules.put(dylibPath, module);
        if (subModule != null) {
            subModule.exportModules.put(FilenameUtils.getBaseName(module.name), module);
        }
        if (maxDylibName == null || dyId.length() > maxDylibName.length()) {
            maxDylibName = dyId;
        }
        if (loadSize > maxSizeOfDylib) {
            maxSizeOfDylib = loadSize;
        }
        for (MachOModule export : modules.values()) {
            for (Iterator<NeedLibrary> iterator = export.lazyLoadNeededList.iterator(); iterator.hasNext(); ) {
                NeedLibrary library = iterator.next();
                String neededLibrary = library.path;
                String name = FilenameUtils.getName(neededLibrary);
                MachOModule loaded = modules.get(name);
                if (loaded != null) {
                    if (library.upward) {
                        export.upwardLibraries.put(name, loaded);
                    } else {
                        export.neededLibraries().put(name, loaded);
                    }
                    iterator.remove();
                }
            }
        }
        processRebase(log, module);
        if ("libsystem_malloc.dylib".equals(dyId)) {
            malloc = module.findSymbolByName("_malloc", false);
            free = module.findSymbolByName("_free", false);
        } else if ("Foundation".equals(dyId)) {
            Symbol _NSSetLogCStringFunction = module.findSymbolByName("__NSSetLogCStringFunction", false);
            if (_NSSetLogCStringFunction == null) {
                throw new IllegalStateException("__NSSetLogCStringFunction is null");
            } else {
                Svc svc = emulator.is32Bit() ? new ArmHook() {
                    @Override
                    protected HookStatus hook(Emulator<?> emulator) {
                        Arm32RegisterContext context = emulator.getContext();
                        Pointer message = context.getR0Pointer();
                        int length = context.getR1Int();
                        boolean withSysLogBanner = context.getR2Int() != 0;
                        __NSSetLogCStringFunction(message, length, withSysLogBanner);
                        return HookStatus.LR(emulator, 0);
                    }
                } : new Arm64Hook() {
                    @Override
                    protected HookStatus hook(Emulator<?> emulator) {
                        Arm64RegisterContext context = emulator.getContext();
                        Pointer message = context.getXPointer(0);
                        int length = context.getXInt(1);
                        boolean withSysLogBanner = context.getXInt(2) != 0;
                        __NSSetLogCStringFunction(message, length, withSysLogBanner);
                        return HookStatus.LR(emulator, 0);
                    }
                };
                _NSSetLogCStringFunction.call(emulator, emulator.getSvcMemory().registerSvc(svc));
            }
        }
        if (entryPointCommand != null) {
            module.setEntryPoint(entryPointCommand.entryOff());
        }
        if (log.isDebugEnabled()) {
            log.debug("Load library {} offset={}ms", dyId, System.currentTimeMillis() - start);
        }
        notifyModuleLoaded(module);
        return module;
    }
    private static final String RPATH = "@rpath";
    private LibraryFile resolveLibrary(LibraryFile libraryFile, String neededLibrary, Collection<String> rpathSet) throws IOException {
        if (rpathSet.isEmpty() || !neededLibrary.contains(RPATH)) {
            LibraryFile neededLibraryFile = libraryFile.resolveLibrary(emulator, neededLibrary);
            if (libraryResolver != null && neededLibraryFile == null) {
                neededLibraryFile = libraryResolver.resolveLibrary(emulator, neededLibrary);
            }
            return neededLibraryFile;
        } else {
            List<String> rpathList = new ArrayList<>(rpathSet);
            Collections.reverse(rpathList);
            for (String rpath : rpathList) {
                String dylibName = neededLibrary.replace(RPATH, rpath);
                LibraryFile neededLibraryFile = libraryFile.resolveLibrary(emulator, dylibName);
                if (libraryResolver != null && neededLibraryFile == null) {
                    neededLibraryFile = libraryResolver.resolveLibrary(emulator, dylibName);
                }
                if (neededLibraryFile != null) {
                    return neededLibraryFile;
                }
            }
            return null;
        }
    }
    private void __NSSetLogCStringFunction(Pointer message, int length, boolean withSysLogBanner) {
        byte[] data = message.getByteArray(0, length);
        String str = new String(data, StandardCharsets.UTF_8);
        if (withSysLogBanner) {
            System.err.println("NSLog: " + str);
        } else {
            System.out.println("NSLog: " + str);
        }
    }
    private void checkSection(String dyId, String segName, String sectName) {
        if (log.isDebugEnabled()) {
            log.debug("checkSection name={}, dyId={}, segName={}", sectName, dyId, segName);
        }
    }
    private void processRebase(Logger log, MachOModule module) {
        MachO.DyldInfoCommand dyldInfoCommand = module.dyldInfoCommand;
        if (dyldInfoCommand == null) {
            MachO.LinkeditDataCommand chainedFixups = module.chainedFixups;
            if (chainedFixups == null) {
                return;
            }
            ByteBuffer buffer = module.buffer.duplicate();
            buffer.limit((int) (chainedFixups.dataOff() + chainedFixups.dataSize()));
            buffer.position((int) chainedFixups.dataOff()); 
            try (ByteBufferKaitaiStream io = new ByteBufferKaitaiStream(buffer.slice())) {
                fixupAllChainedFixups(io, module, chainedFixups);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            return;
        }
        if (dyldInfoCommand.rebaseSize() > 0) {
            ByteBuffer buffer = module.buffer.duplicate();
            buffer.limit((int) (dyldInfoCommand.rebaseOff() + dyldInfoCommand.rebaseSize()));
            buffer.position((int) dyldInfoCommand.rebaseOff());
            rebase(log, buffer.slice(), module);
        }
    }
    private void fixupAllChainedFixups(ByteBufferKaitaiStream io, MachOModule mm, MachO.LinkeditDataCommand chainedFixups) {
        long fixups_version = io.readU4le();
        long starts_offset = io.readU4le(); 
        long imports_offset = io.readU4le(); 
        long symbols_offset = io.readU4le(); 
        int imports_count = (int) io.readU4le(); 
        int imports_format = (int) io.readU4le(); 
        long symbols_format = io.readU4le(); 
        if (fixups_version != 0) {
            throw new IllegalStateException("chained fixups, unknown header version");
        }
        if (starts_offset >= io.size()) {
            throw new IllegalStateException("chained fixups, starts_offset exceeds LC_DYLD_CHAINED_FIXUPS size");
        }
        if (imports_offset >= io.size()) {
            throw new IllegalStateException("chained fixups, imports_offset exceeds LC_DYLD_CHAINED_FIXUPS size");
        }
        ByteBuffer buffer = mm.buffer.duplicate();
        buffer.limit((int) (chainedFixups.dataOff() + chainedFixups.dataSize()));
        buffer.position((int) (chainedFixups.dataOff() + symbols_offset)); 
        try (ByteBufferKaitaiStream symbolsPool = new ByteBufferKaitaiStream(buffer.slice())) {
            long formatEntrySize;
            List<FixupChains.BindTarget> bindTargets = new ArrayList<>(imports_count);
            switch (imports_format) {
                case FixupChains.DYLD_CHAINED_IMPORT:
                    formatEntrySize = 4;
                    io.seek(imports_offset);
                    for (int i = 0; i < imports_count; i++) {
                        long raw32 = io.readU4le();
                        int lib_ordinal = (int) (raw32 & 0xff);
                        raw32 >>>= 8;
                        boolean weak_import = (raw32 & 1) != 0;
                        int name_offset = (int) (raw32 >>> 1);
                        if (lib_ordinal > 0xf0) {
                            lib_ordinal = (byte) lib_ordinal;
                        }
                        bindTargets.add(new FixupChains.dyld_chained_import_addend64(lib_ordinal, weak_import, name_offset, 0L));
                    }
                    break;
                case FixupChains.DYLD_CHAINED_IMPORT_ADDEND: {
                    formatEntrySize = 8;
                    io.seek(imports_offset);
                    for (int i = 0; i < imports_count; i++) {
                        long raw32 = io.readU4le();
                        int lib_ordinal = (int) (raw32 & 0xff);
                        raw32 >>>= 8;
                        boolean weak_import = (raw32 & 1) != 0;
                        int name_offset = (int) (raw32 >>> 1);
                        long addend = io.readU4le();
                        if (lib_ordinal > 0xf0) {
                            lib_ordinal = (byte) lib_ordinal;
                        }
                        bindTargets.add(new FixupChains.dyld_chained_import_addend64(lib_ordinal, weak_import, name_offset, addend));
                    }
                    break;
                }
                case FixupChains.DYLD_CHAINED_IMPORT_ADDEND64:
                    formatEntrySize = 16;
                    io.seek(imports_offset);
                    for (int i = 0; i < imports_count; i++) {
                        long raw64 = io.readU8le();
                        int lib_ordinal = (int) (raw64 & 0xffff);
                        raw64 >>>= 16;
                        boolean weak_import = (raw64 & 1) != 0;
                        int name_offset = (int) (raw64 >>> 16);
                        long addend = io.readU8le();
                        if (lib_ordinal > 0xfff0) {
                            lib_ordinal = (short) lib_ordinal;
                        }
                        bindTargets.add(new FixupChains.dyld_chained_import_addend64(lib_ordinal, weak_import, name_offset, addend));
                    }
                    break;
                default:
                    throw new IllegalStateException("chained fixups, unknown imports_format");
            }
            if (FixupChains.greaterThanAddOrOverflow(imports_offset, (formatEntrySize * imports_count), symbols_offset)) {
                throw new IllegalStateException("chained fixups, imports array overlaps symbols");
            }
            if (symbols_format != 0) {
                throw new IllegalStateException("chained fixups, symbols_format unknown");
            }
            io.seek(starts_offset); 
            int seg_count = (int) io.readU4le();
            if (seg_count != mm.segments.length) {
                if (seg_count > mm.segments.length) {
                    throw new IllegalStateException("chained fixups, seg_count exceeds number of segments");
                }
                int numNoRelocSegments = 0;
                int numExtraSegments = mm.segments.length - seg_count;
                for (Segment segment : mm.segments) {
                    if (segment.vmSize == 0) {
                        ++numNoRelocSegments;
                    }
                }
                if (numNoRelocSegments != numExtraSegments) {
                    throw new IllegalStateException("chained fixups, seg_count does not match number of segments");
                }
            }
            long[] seg_info_offset = new long[seg_count];
            for (int i = 0; i < seg_count; i++) {
                seg_info_offset[i] = io.readU4le();
            }
            int pointer_format_for_all = -1;
            long maxValidPointerSeen = 0;
            for (int i = 0; i < seg_info_offset.length; i++) {
                long offset = seg_info_offset[i];
                if (offset == 0) {
                    continue;
                }
                io.seek(starts_offset + offset); 
                long size = io.readU4le(); 
                if (offset + size > imports_offset) { 
                    throw new IllegalStateException(String.format("chained fixups, dyld_chained_starts_in_segment for segment #%d overruns imports table", i));
                }
                int page_size = io.readU2le(); 
                if ((page_size != 0x1000) && (page_size != 0x4000)) {
                    throw new IllegalStateException(String.format("chained fixups, page_size not 4KB or 16KB in segment #%d", i));
                }
                int pointer_format = io.readU2le(); 
                if (pointer_format > 12) {
                    throw new IllegalStateException(String.format("chained fixups, unknown pointer_format in segment #%d", i));
                }
                if (pointer_format_for_all == -1) {
                    pointer_format_for_all = pointer_format;
                }
                if (pointer_format != pointer_format_for_all) {
                    throw new IllegalStateException(String.format("chained fixups, pointer_format not same for all segments %d and %d", pointer_format, pointer_format_for_all));
                }
                long segment_offset = io.readU8le(); 
                if (segment_offset != (mm.segments[i].vmAddr - mm.machHeader) && segment_offset != mm.segments[i].vmAddr) {
                    throw new IllegalStateException(String.format("chained fixups, segment_offset does not match vmaddr from LC_SEGMENT in segment #%d", i));
                }
                long max_valid_pointer = io.readU4le(); 
                if (max_valid_pointer != 0) {
                    if (maxValidPointerSeen == 0) {
                        maxValidPointerSeen = max_valid_pointer;
                    } else if (maxValidPointerSeen != max_valid_pointer) {
                        throw new IllegalStateException("chained fixups, different max_valid_pointer values seen in different segments");
                    }
                }
                int page_count = io.readU2le(); 
                if (page_count == 0) {
                    continue;
                }
                for (long pageIndex = 0; pageIndex < page_count; pageIndex++) {
                    int offsetInPage = io.readU2le(); 
                    if (offsetInPage == FixupChains.DYLD_CHAINED_PTR_START_NONE) {
                        continue;
                    }
                    if ((offsetInPage & FixupChains.DYLD_CHAINED_PTR_START_MULTI) != 0) {
                        throw new UnsupportedOperationException("DYLD_CHAINED_PTR_START_MULTI");
                    } else if (offsetInPage > page_size) {
                        throw new IllegalStateException(String.format("chained fixups, in segment #%d page_start[%d]=0x%04X exceeds page size", i, pageIndex, offsetInPage));
                    }
                    Pointer pageContentStart = UnidbgPointer.pointer(emulator, mm.machHeader + segment_offset + (pageIndex * page_size));
                    assert pageContentStart != null;
                    Pointer chain = pageContentStart.share(offsetInPage);
                    walkChain(mm, chain, pointer_format, bindTargets, symbolsPool);
                }
            }
            if (imports_count != 0) {
                int maxBindOrdinal = 0;
                switch (pointer_format_for_all) {
                    case FixupChains.DYLD_CHAINED_PTR_32:
                        maxBindOrdinal = 0x0fffff; 
                        break;
                    case FixupChains.DYLD_CHAINED_PTR_ARM64E:
                    case FixupChains.DYLD_CHAINED_PTR_ARM64E_USERLAND:
                    case FixupChains.DYLD_CHAINED_PTR_ARM64E_OFFSET:
                        maxBindOrdinal = 0x00ffff; 
                        break;
                    case FixupChains.DYLD_CHAINED_PTR_64:
                    case FixupChains.DYLD_CHAINED_PTR_64_OFFSET:
                    case FixupChains.DYLD_CHAINED_PTR_ARM64E_USERLAND24:
                        maxBindOrdinal = 0xFFFFFF; 
                        break;
                }
                if (imports_count >= maxBindOrdinal) {
                    throw new IllegalStateException(String.format("chained fixups, imports_count (%d) exceeds max of %d", imports_count, maxBindOrdinal));
                }
            }
            if (maxValidPointerSeen != 0) {
                Segment segment = mm.segments[mm.segments.length - 1];
                long lastSegmentLastVMAddr = segment.vmAddr + segment.vmSize;
                if (maxValidPointerSeen < lastSegmentLastVMAddr) {
                    throw new IllegalStateException("chained fixups, max_valid_pointer too small for image");
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    private void walkChain(MachOModule mm, Pointer chain, final int pointer_format, List<FixupChains.BindTarget> bindTargets, ByteBufferKaitaiStream symbolsPool) {
        Logger log = LoggerFactory.getLogger("com.github.unidbg.ios." + mm.name);
        boolean chainEnd = false;
        while (!chainEnd) {
            long raw64 = chain.getLong(0);
            log.trace("handleChain: {}, pointer_format={}, raw64=0x{}", chain, pointer_format, Long.toHexString(raw64));
            FixupChains.handleChain(emulator, mm, hookListeners, pointer_format, chain, raw64, bindTargets, symbolsPool);
            switch (pointer_format) {
                case FixupChains.DYLD_CHAINED_PTR_ARM64E: {
                    long dyld_chained_ptr_arm64e_rebase = chain.getLong(16);
                    int next = (int) ((dyld_chained_ptr_arm64e_rebase >> 51) & 0x7ff);
                    if (next == 0) {
                        chainEnd = true;
                    } else {
                        chain = chain.share(next * 8);
                    }
                    break;
                }
                case FixupChains.DYLD_CHAINED_PTR_64:
                case FixupChains.DYLD_CHAINED_PTR_64_OFFSET:
                    int next = (int) ((raw64 >> 51) & 0xfff);
                    if (next == 0) {
                        chainEnd = true;
                    } else {
                        chain = chain.share(next * 4);
                    }
                    break;
                default:
                    throw new UnsupportedOperationException("pointer_format=" + pointer_format);
            }
        }
    }
    private void rebase(Logger log, ByteBuffer buffer, MachOModule module) {
        final List<MemRegion> regions = module.getRegions();
        int type = 0;
        int segmentIndex;
        long address = module.base;
        long segmentEndAddress = module.base + module.size;
        int count;
        int skip;
        boolean done = false;
        while (!done && buffer.hasRemaining()) {
            int b = buffer.get() & 0xff;
            int immediate = b & REBASE_IMMEDIATE_MASK;
            int opcode = b & REBASE_OPCODE_MASK;
            switch (opcode) {
                case REBASE_OPCODE_DONE:
                    done = true;
                    break;
                case REBASE_OPCODE_SET_TYPE_IMM:
                    type = immediate;
                    break;
                case REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
                    segmentIndex = immediate;
                    if (segmentIndex >= regions.size()) {
                        throw new IllegalStateException(String.format("REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)", segmentIndex, regions.size() - 1));
                    }
                    MemRegion region = regions.get(segmentIndex);
                    address = region.begin + Utils.readULEB128(buffer).longValue();
                    segmentEndAddress = region.end;
                    break;
                case REBASE_OPCODE_ADD_ADDR_ULEB:
                    address += Utils.readULEB128(buffer).longValue();
                    break;
                case REBASE_OPCODE_ADD_ADDR_IMM_SCALED:
                    address += ((long) immediate * emulator.getPointerSize());
                    break;
                case REBASE_OPCODE_DO_REBASE_IMM_TIMES:
                    for (int i = 0; i < immediate; i++) {
                        if (address >= segmentEndAddress) {
                            throw new IllegalStateException();
                        }
                        rebaseAt(log, type, address, module);
                        address += emulator.getPointerSize();
                    }
                    break;
                case REBASE_OPCODE_DO_REBASE_ULEB_TIMES:
                    count = Utils.readULEB128(buffer).intValue();
                    for (int i = 0; i < count; i++) {
                        if (address >= segmentEndAddress) {
                            throw new IllegalStateException();
                        }
                        rebaseAt(log, type, address, module);
                        address += emulator.getPointerSize();
                    }
                    break;
                case REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:
                    if (address >= segmentEndAddress) {
                        throw new IllegalStateException();
                    }
                    rebaseAt(log, type, address, module);
                    address += (Utils.readULEB128(buffer).longValue() + emulator.getPointerSize());
                    break;
                case REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:
                    count = Utils.readULEB128(buffer).intValue();
                    skip = Utils.readULEB128(buffer).intValue();
                    for (int i = 0; i < count; i++) {
                        if (address >= segmentEndAddress) {
                            throw new IllegalStateException();
                        }
                        rebaseAt(log, type, address, module);
                        address += (skip + emulator.getPointerSize());
                    }
                    break;
                default:
                    throw new IllegalStateException("bad rebase opcode=0x" + Integer.toHexString(opcode));
            }
        }
    }
    private void rebaseAt(Logger log, int type, long address, Module module) {
        Pointer pointer = UnidbgPointer.pointer(emulator, address);
        if (pointer == null) {
            throw new IllegalStateException();
        }
        Pointer newPointer = pointer.getPointer(0);
        Pointer old = newPointer;
        if (newPointer == null) {
            newPointer = UnidbgPointer.pointer(emulator, module.base);
        } else {
            newPointer = newPointer.share(module.base);
        }
        if (log.isTraceEnabled()) {
            log.trace("rebaseAt type={}, address=0x{}, module={}, old={}, new={}", type, Long.toHexString(address - module.base), module.name, old, newPointer);
        }
        switch (type) {
            case REBASE_TYPE_POINTER:
            case REBASE_TYPE_TEXT_ABSOLUTE32:
                pointer.setPointer(0, newPointer);
                break;
            default:
                throw new IllegalStateException("bad rebase type " + type);
        }
    }
    private void bindLocalRelocations(MachOModule module) {
        MachO.DysymtabCommand dysymtabCommand = module.dysymtabCommand;
        if (dysymtabCommand.nLocRel() <= 0) {
            return;
        }
        ByteBuffer buffer = module.buffer;
        buffer.limit((int) (dysymtabCommand.locRelOff() + dysymtabCommand.nLocRel() * 8));
        buffer.position((int) dysymtabCommand.locRelOff());
        ByteBuffer slice = buffer.slice();
        slice.order(ByteOrder.LITTLE_ENDIAN);
        Logger log = LoggerFactory.getLogger("com.github.unidbg.ios." + module.name);
        for (int i = 0; i < dysymtabCommand.nLocRel(); i++) {
            Relocation relocation = Relocation.create(slice);
            if (relocation.pcRel || relocation.extern || relocation.scattered ||
                    relocation.length != (emulator.is64Bit() ? 3 : 2) ||
                    relocation.type != ARM_RELOC_VANILLA) {
                throw new IllegalStateException("Unexpected relocation found.");
            }
            buffer.limit(relocation.address + emulator.getPointerSize());
            buffer.position(relocation.address);
            long target = emulator.is64Bit() ? buffer.getLong() : buffer.getInt();
            Pointer pointer = UnidbgPointer.pointer(emulator, module.base + relocation.address);
            if (pointer == null) {
                throw new IllegalStateException();
            }
            pointer.setPointer(0, UnidbgPointer.pointer(emulator, module.base + target));
            if (log.isDebugEnabled()) {
                log.debug("bindLocalRelocations address=0x{}, symbolNum=0x{}, target=0x{}", Integer.toHexString(relocation.address), Integer.toHexString(relocation.symbolNum), Long.toHexString(target));
            }
        }
    }
    private void bindExternalRelocations(MachOModule module) {
        MachO.DysymtabCommand dysymtabCommand = module.dysymtabCommand;
        if (dysymtabCommand.nExtRel() <= 0) {
            return;
        }
        ByteBuffer buffer = module.buffer;
        buffer.limit((int) (dysymtabCommand.extRelOff() + dysymtabCommand.nExtRel() * 8));
        buffer.position((int) dysymtabCommand.extRelOff());
        ByteBuffer slice = buffer.slice();
        slice.order(ByteOrder.LITTLE_ENDIAN);
        Logger log = LoggerFactory.getLogger("com.github.unidbg.ios." + module.name);
        for (int i = 0; i < dysymtabCommand.nExtRel(); i++) {
            Relocation relocation = Relocation.create(slice);
            if (relocation.pcRel || !relocation.extern || relocation.scattered ||
                    relocation.length != (emulator.is64Bit() ? 3 : 2) ||
                    relocation.type != ARM_RELOC_VANILLA) {
                throw new IllegalStateException("Unexpected relocation found.");
            }
            MachOSymbol symbol = module.getSymbolByIndex(relocation.symbolNum);
            Pointer pointer = UnidbgPointer.pointer(emulator, module.base + relocation.address);
            if (pointer == null) {
                throw new IllegalStateException();
            }
            boolean isWeakRef = (symbol.nlist.desc() & N_WEAK_REF) != 0;
            long address = resolveSymbol(module, symbol);
            if (address == 0L) {
                if (isWeakRef) {
                    log.debug("bindExternalRelocations failed symbol={}, isWeakRef=true", symbol);
                    pointer.setPointer(0, null);
                } else {
                    log.warn("bindExternalRelocations failed symbol={}, isWeakRef=false", symbol);
                }
                module.addNotBoundSymbol(symbol.getName());
            } else {
                pointer.setPointer(0, UnidbgPointer.pointer(emulator, address));
                if (log.isDebugEnabled()) {
                    log.debug("bindExternalRelocations address=0x{}, symbolNum=0x{}, symbolName={}", Long.toHexString(relocation.address), Integer.toHexString(relocation.symbolNum), symbol.getName());
                }
            }
        }
    }
    private long resolveSymbol(MachOModule module, MachOSymbol symbol) {
        int libraryOrdinal = symbol.getLibraryOrdinal();
        Symbol replace = null;
        if (libraryOrdinal == BIND_SPECIAL_DYLIB_SELF) {
            replace = module.findSymbolByName(symbol.getName(), false);
        } else if (libraryOrdinal <= module.ordinalList.size()) {
            String path = module.ordinalList.get(libraryOrdinal - 1);
            MachOModule targetImage = this.modules.get(FilenameUtils.getName(path));
            if (targetImage != null) {
                replace = findSymbolInternal(targetImage, symbol.getName());
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("resolveSymbol libraryOrdinal={}, path={}", libraryOrdinal, path);
                }
            }
        } else {
            throw new IllegalStateException(String.format("bad mach-o binary, library ordinal (%d) too big (max %d) for symbol %s in %s", libraryOrdinal, module.ordinalList.size(), symbol.getName(), module.getPath()));
        }
        long address = replace == null ? 0L : replace.getAddress();
        for (HookListener listener : hookListeners) {
            long hook = listener.hook(emulator.getSvcMemory(), replace == null ? module.name : replace.getModuleName(), symbol.getName(), address);
            if (hook > 0) {
                address = hook;
                break;
            }
        }
        return address;
    }
    private Pointer dyldLazyBinder;
    private Pointer dyldFuncLookup;
    private void setupLazyPointerHandler(MachOModule module) {
        if (module.lazyPointerProcessed) {
            return;
        }
        module.lazyPointerProcessed = true;
        if (module.isVirtual()) { 
            return;
        }
        for (MachO.LoadCommand command : module.machO.loadCommands()) {
            switch (command.type()) {
                case SEGMENT:
                    MachO.SegmentCommand segmentCommand = (MachO.SegmentCommand) command.body();
                    if ("__DATA".equals(segmentCommand.segname())) {
                        for (MachO.SegmentCommand.Section section : segmentCommand.sections()) {
                            if ("__dyld".equals(section.sectName())) {
                                Pointer dd = UnidbgPointer.pointer(emulator, module.base + section.addr());
                                if (dyldLazyBinder == null) {
                                    dyldLazyBinder = emulator.getSvcMemory().registerSvc(new ArmSvc() {
                                        @Override
                                        public long handle(Emulator<?> emulator) {
                                            return ((Dyld) emulator.getDlfcn())._stub_binding_helper();
                                        }
                                    });
                                }
                                if (dyldFuncLookup == null) {
                                    dyldFuncLookup = emulator.getSvcMemory().registerSvc(new ArmSvc() {
                                        @Override
                                        public long handle(Emulator<?> emulator) {
                                            String name = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0).getString(0);
                                            Pointer address = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1);
                                            return ((Dyld) emulator.getDlfcn())._dyld_func_lookup(emulator, name, address);
                                        }
                                    });
                                }
                                if (dd != null) {
                                    dd.setPointer(0, dyldLazyBinder);
                                    dd.setPointer(emulator.getPointerSize(), dyldFuncLookup);
                                }
                            }
                        }
                    }
                    break;
                case SEGMENT_64:
                    MachO.SegmentCommand64 segmentCommand64 = (MachO.SegmentCommand64) command.body();
                    if ("__DATA".equals(segmentCommand64.segname())) {
                        for (MachO.SegmentCommand64.Section64 section : segmentCommand64.sections()) {
                            if ("__dyld".equals(section.sectName())) {
                                Pointer dd = UnidbgPointer.pointer(emulator, module.base + section.addr());
                                if (dyldLazyBinder == null) {
                                    dyldLazyBinder = emulator.getSvcMemory().registerSvc(new Arm64Svc() {
                                        @Override
                                        public long handle(Emulator<?> emulator) {
                                            return ((Dyld) emulator.getDlfcn())._stub_binding_helper();
                                        }
                                    });
                                }
                                if (dyldFuncLookup == null) {
                                    dyldFuncLookup = emulator.getSvcMemory().registerSvc(new Arm64Svc() {
                                        @Override
                                        public long handle(Emulator<?> emulator) {
                                            String name = UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_X0).getString(0);
                                            Pointer address = UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_X1);
                                            return ((Dyld) emulator.getDlfcn())._dyld_func_lookup(emulator, name, address);
                                        }
                                    });
                                }
                                if (dd != null) {
                                    dd.setPointer(0, dyldLazyBinder);
                                    dd.setPointer(emulator.getPointerSize(), dyldFuncLookup);
                                }
                            }
                        }
                    }
                    break;
            }
        }
    }
    private void bindIndirectSymbolPointers(MachOModule module) {
        if (module.indirectSymbolBound) {
            return;
        }
        module.indirectSymbolBound = true;
        if (module.chainedFixups != null) {
            return;
        }
        MachO.DysymtabCommand dysymtabCommand = module.dysymtabCommand;
        if (dysymtabCommand == null) { 
            return;
        }
        List<Long> indirectTable = dysymtabCommand.indirectSymbols();
        MachO.DyldInfoCommand dyldInfoCommand = module.dyldInfoCommand;
        if (dyldInfoCommand == null) {
            bindLocalRelocations(module);
            boolean allSymbolBound = true;
            for (MachO.LoadCommand command : module.machO.loadCommands()) {
                switch (command.type()) {
                    case SEGMENT: {
                        MachO.SegmentCommand segmentCommand = (MachO.SegmentCommand) command.body();
                        for (MachO.SegmentCommand.Section section : segmentCommand.sections()) {
                            allSymbolBound = processSection(module, indirectTable, allSymbolBound, section.flags(), section.size(), section.addr(), section.reserved1());
                        }
                        break;
                    }
                    case SEGMENT_64: {
                        MachO.SegmentCommand64 segmentCommand = (MachO.SegmentCommand64) command.body();
                        for (MachO.SegmentCommand64.Section64 section : segmentCommand.sections()) {
                            allSymbolBound = processSection(module, indirectTable, allSymbolBound, section.flags(), section.size(), section.addr(), section.reserved1());
                        }
                        break;
                    }
                }
            }
            bindExternalRelocations(module);
        } else {
            if (dyldInfoCommand.bindSize() > 0) {
                ByteBuffer buffer = module.buffer.duplicate();
                buffer.limit((int) (dyldInfoCommand.bindOff() + dyldInfoCommand.bindSize()));
                buffer.position((int) dyldInfoCommand.bindOff());
                Logger log = LoggerFactory.getLogger("com.github.unidbg.ios." + module.name);
                if (!log.isDebugEnabled()) {
                    log = MachOLoader.log;
                }
                eachBind(log, buffer.slice(), module);
            }
        }
    }
    private boolean processSection(MachOModule module, List<Long> indirectTable, boolean allSymbolBound, long flags, long size, long addr, long reserved1) {
        Logger log = LoggerFactory.getLogger("com.github.unidbg.ios." + module.name);
        if (!log.isDebugEnabled()) {
            log = MachOLoader.log;
        }
        long type = flags & SECTION_TYPE;
        long elementCount = size / emulator.getPointerSize();
        if (type != S_NON_LAZY_SYMBOL_POINTERS && type != S_LAZY_SYMBOL_POINTERS) {
            return allSymbolBound;
        }
        long ptrToBind = addr;
        int indirectTableOffset = (int) reserved1;
        for (int i = 0; i < elementCount; i++, ptrToBind += emulator.getPointerSize()) {
            long symbolIndex = indirectTable.get(indirectTableOffset + i);
            if (symbolIndex == INDIRECT_SYMBOL_ABS) {
                continue; 
            }
            if (symbolIndex == INDIRECT_SYMBOL_LOCAL) {
                UnidbgPointer pointer = UnidbgPointer.pointer(emulator, ptrToBind + module.base);
                if (pointer == null) {
                    throw new IllegalStateException("pointer is null");
                }
                Pointer newPointer = pointer.getPointer(0);
                if (newPointer == null) {
                    newPointer = UnidbgPointer.pointer(emulator, module.base);
                } else {
                    newPointer = newPointer.share(module.base);
                }
                if (log.isDebugEnabled()) {
                    log.debug("bindIndirectSymbolPointers pointer={}, newPointer={}", pointer, newPointer);
                }
                pointer.setPointer(0, newPointer);
                continue;
            }
            MachOSymbol symbol = module.getSymbolByIndex((int) symbolIndex);
            if (symbol == null) {
                log.warn("bindIndirectSymbolPointers symbol is null");
                allSymbolBound = false;
                continue;
            }
            boolean isWeakRef = (symbol.nlist.desc() & N_WEAK_REF) != 0;
            long address = resolveSymbol(module, symbol);
            UnidbgPointer pointer = UnidbgPointer.pointer(emulator, ptrToBind + module.base);
            if (pointer == null) {
                throw new IllegalStateException("pointer is null");
            }
            if (address == 0L) {
                if (log.isDebugEnabled()) {
                    log.debug("bindIndirectSymbolPointers symbol={}, isWeakRef={}", symbol, isWeakRef);
                }
                pointer.setPointer(0, null);
            } else {
                pointer.setPointer(0, UnidbgPointer.pointer(emulator, address));
                if (log.isDebugEnabled()) {
                    log.debug("bindIndirectSymbolPointers symbolIndex=0x{}, symbol={}, ptrToBind=0x{}", Long.toHexString(symbolIndex), symbol, Long.toHexString(ptrToBind));
                }
            }
        }
        return allSymbolBound;
    }
    private void eachBind(Logger log, ByteBuffer buffer, MachOModule module) {
        final List<MemRegion> regions = module.getRegions();
        int type = 0;
        int segmentIndex;
        long address = module.base;
        long segmentEndAddress = address + module.size;
        String symbolName = null;
        int symbolFlags = 0;
        int libraryOrdinal = 0;
        long addend = 0;
        int count;
        int skip;
        boolean done = false;
        while (!done && buffer.hasRemaining()) {
            int b = buffer.get() & 0xff;
            int immediate = b & BIND_IMMEDIATE_MASK;
            int opcode = b & BIND_OPCODE_MASK;
            switch (opcode) {
                case BIND_OPCODE_DONE:
                    done = true;
                    break;
                case BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:
                    libraryOrdinal = immediate;
                    break;
                case BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:
                    libraryOrdinal = Utils.readULEB128(buffer).intValue();
                    break;
                case BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:
                    if ( immediate == 0 )
                        libraryOrdinal = 0;
                    else {
                        libraryOrdinal = BIND_OPCODE_MASK | immediate;
                    }
                    break;
                case BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    while ((b = buffer.get()) != 0) {
                        baos.write(b);
                    }
                    symbolName = baos.toString();
                    symbolFlags = immediate;
                    break;
                case BIND_OPCODE_SET_TYPE_IMM:
                    type = immediate;
                    break;
                case BIND_OPCODE_SET_ADDEND_SLEB:
                    addend = Utils.readULEB128(buffer).longValue();
                    break;
                case BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:
                    segmentIndex = immediate;
                    if (segmentIndex >= regions.size()) {
                        throw new IllegalStateException(String.format("BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)", segmentIndex, regions.size() - 1));
                    }
                    MemRegion region = regions.get(segmentIndex);
                    address = region.begin + Utils.readULEB128(buffer).longValue();
                    segmentEndAddress = region.end;
                    break;
                case BIND_OPCODE_ADD_ADDR_ULEB:
                    address += Utils.readULEB128(buffer).longValue();
                    break;
                case BIND_OPCODE_DO_BIND:
                    if (address >= segmentEndAddress) {
                        throw new IllegalStateException();
                    }
                    doBindAt(log, libraryOrdinal, type, address, symbolName, symbolFlags, addend, module);
                    address += emulator.getPointerSize();
                    break;
                case BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:
                    if (address >= segmentEndAddress) {
                        throw new IllegalStateException();
                    }
                    doBindAt(log, libraryOrdinal, type, address, symbolName, symbolFlags, addend, module);
                    address += (Utils.readULEB128(buffer).longValue() + emulator.getPointerSize());
                    break;
                case BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:
                    if (address >= segmentEndAddress) {
                        throw new IllegalStateException();
                    }
                    doBindAt(log, libraryOrdinal, type, address, symbolName, symbolFlags, addend, module);
                    address += ((long) immediate *emulator.getPointerSize() + emulator.getPointerSize());
                    break;
                case BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:
                    count = Utils.readULEB128(buffer).intValue();
                    skip = Utils.readULEB128(buffer).intValue();
                    for (int i = 0; i < count; i++) {
                        if (address >= segmentEndAddress) {
                            throw new IllegalStateException();
                        }
                        doBindAt(log, libraryOrdinal, type, address, symbolName, symbolFlags, addend, module);
                        address += (skip + emulator.getPointerSize());
                    }
                    break;
                default:
                    throw new IllegalStateException(String.format("bad bind opcode 0x%s in bind info", Integer.toHexString(opcode)));
            }
        }
    }
    private void doBindAt(Logger log, int libraryOrdinal, int type, long address, String symbolName, int symbolFlags, long addend, MachOModule module) {
        Pointer pointer = UnidbgPointer.pointer(emulator, address);
        if (pointer == null) {
            throw new IllegalStateException();
        }
        MachOModule targetImage;
        if (libraryOrdinal == BIND_SPECIAL_DYLIB_MAIN_EXECUTABLE) {
            targetImage = executableModule;
        } else if (libraryOrdinal == BIND_SPECIAL_DYLIB_SELF) {
            targetImage = module;
        } else if (libraryOrdinal == BIND_SPECIAL_DYLIB_FLAT_LOOKUP) {
            for(MachOModule mm : modules.values().toArray(new MachOModule[0])) {
                if (doBindAt(type, pointer, addend, module, mm, symbolName, false)) {
                    return;
                }
            }
            module.addNotBoundSymbol(symbolName);
            return;
        } else if (libraryOrdinal <= 0) {
            throw new IllegalStateException(String.format("bad mach-o binary, unknown special library ordinal (%d) too big for symbol %s in %s: symbolFlags=0x%x", libraryOrdinal, symbolName, module.getPath(), symbolFlags));
        } else if (libraryOrdinal <= module.ordinalList.size()) {
            String path = module.ordinalList.get(libraryOrdinal - 1);
            targetImage = this.modules.get(FilenameUtils.getName(path));
            if (targetImage == null) { 
                if (log.isDebugEnabled()) {
                    log.debug("doBindAt LOAD_WEAK_DYLIB: {}", path);
                }
                module.addNotBoundSymbol(symbolName);
                return;
            }
        } else {
            throw new IllegalStateException(String.format("bad mach-o binary, library ordinal (%d) too big (max %d) for symbol %s in %s", libraryOrdinal, module.ordinalList.size(), symbolName, module.getPath()));
        }
        targetImage = fakeTargetImage(targetImage, symbolName);
        doBindAt(type, pointer, addend, module, targetImage, symbolName, true);
    }
    final MachOModule fakeTargetImage(MachOModule targetImage, String symbolName) {
        if ("___NSArray0__".equals(symbolName) ||
                "___NSDictionary0__".equals(symbolName) ||
                "_OBJC_CLASS_$_NSConstantIntegerNumber".equals(symbolName) ||
                "_NSProcessInfoPowerStateDidChangeNotification".equals(symbolName) ||
                "_NSExtensionHostDidEnterBackgroundNotification".equals(symbolName) ||
                "_NSExtensionHostDidBecomeActiveNotification".equals(symbolName)) {
            MachOModule fakeImage = this.modules.get("UIKit");
            if (fakeImage == null) {
                fakeImage = this.modules.get("AppKit");
            }
            if (fakeImage == null) {
                fakeImage = this.modules.get("IOKit");
            }
            if (fakeImage == null) {
                emulator.attach().debug();
                throw new IllegalStateException(String.format("targetImage=%s, symbolName=%s", targetImage, symbolName));
            } else {
                targetImage = fakeImage;
            }
        }
        return targetImage;
    }
    final Symbol findSymbolInternal(MachOModule targetImage, String symbolName) {
        if ("CoreFoundation".equals(targetImage.name)) {
            if ("___kCFBooleanFalse".equals(symbolName) ||
                    "___kCFBooleanTrue".equals(symbolName)) {
                Symbol symbol = targetImage.findSymbolByName(symbolName.substring(2), false);
                if (symbol == null) {
                    throw new IllegalStateException();
                }
                long address = symbol.getAddress();
                Pointer pointer = UnidbgPointer.pointer(emulator, address);
                assert pointer != null;
                long value = pointer.getLong(0);
                return new ExportSymbol(symbolName, value, targetImage, 0, com.github.unidbg.ios.MachO.EXPORT_SYMBOL_FLAGS_KIND_ABSOLUTE);
            }
        }
        Symbol symbol = targetImage.findSymbolByName(symbolName, false);
        if (symbol != null) {
            return symbol;
        }
        if ("CFNetwork".equals(targetImage.name)) {
            MachOModule foundation = modules.get("Foundation");
            if (foundation != null) {
                symbol = findSymbolInternal(foundation, symbolName);
                if (symbol != null) {
                    if (log.isDebugEnabled()) {
                        log.debug("Redirect symbol={}", symbol);
                    }
                }
            }
        }
        return symbol;
    }
    private boolean doBindAt(int type, Pointer pointer, long addend, MachOModule module, MachOModule targetImage, String symbolName, boolean updateNotBoundSymbol) {
        Symbol symbol = this.findSymbolInternal(targetImage, symbolName);
        if (symbol == null) {
            if (log.isDebugEnabled()) {
                log.info("doBindAt type={}, symbolName={}, targetImage={}", type, symbolName, targetImage);
            }
            long bindAt = 0;
            for (HookListener listener : hookListeners) {
                long hook = listener.hook(emulator.getSvcMemory(), module.name, symbolName, HookListener.EACH_BIND);
                if (hook > 0) {
                    bindAt = hook;
                    break;
                }
            }
            if (bindAt > 0) {
                Pointer newPointer = UnidbgPointer.pointer(emulator, bindAt);
                switch (type) {
                    case BIND_TYPE_POINTER:
                        pointer.setPointer(0, newPointer);
                        break;
                    case BIND_TYPE_TEXT_ABSOLUTE32:
                    case BIND_TYPE_TEXT_PCREL32:
                    default:
                        throw new IllegalStateException("bad bind type " + type);
                }
                return true;
            }
            if (updateNotBoundSymbol) {
                module.addNotBoundSymbol(symbolName);
            }
            return false;
        }
        long bindAt = symbol.getAddress() + addend;
        for (HookListener listener : hookListeners) {
            long hook = listener.hook(emulator.getSvcMemory(), symbol.getModuleName(), symbol.getName(), bindAt);
            if (hook > 0) {
                bindAt = hook;
                break;
            }
        }
        if (log.isTraceEnabled()) {
            log.trace("doBindAt 0x={}, type={}, symbolName={}, addend={}, lazy=" + false + ", symbol={}, pointer={}, bindAt=0x{}", Long.toHexString(symbol.getValue()), type, symbol.getModuleName(), addend, symbol, pointer, Long.toHexString(bindAt));
        }
        Pointer newPointer = UnidbgPointer.pointer(emulator, bindAt);
        switch (type) {
            case BIND_TYPE_POINTER:
                pointer.setPointer(0, newPointer);
                break;
            case BIND_TYPE_TEXT_ABSOLUTE32:
                pointer.setInt(0, (int) (symbol.getAddress() + addend));
                break;
            case BIND_TYPE_TEXT_PCREL32:
            default:
                throw new IllegalStateException("bad bind type " + type);
        }
        return true;
    }
    private String maxDylibName;
    private long maxSizeOfDylib;
    private void write_mem(int offset, int size, long begin, ByteBuffer buffer) {
        if (size > 0) {
            buffer.limit(offset + size);
            buffer.position(offset);
            byte[] data = new byte[size];
            buffer.get(data);
            pointer(begin).write(data);
        } else if(size < 0) {
            log.warn("write_mem offset={}, size={}, begin=0x{}", offset, offset, Long.toHexString(begin));
        }
    }
    final Map<String, MachOModule> modules = new LinkedHashMap<>();
    final Map<String, MachOModule> path_modules = new HashMap<>();
    private int get_segment_protection(MachO.VmProt vmProt) {
        int prot = Unicorn.UC_PROT_NONE;
        if (vmProt.read()) prot |= Unicorn.UC_PROT_READ;
        if (vmProt.write()) prot |= Unicorn.UC_PROT_WRITE;
        if (vmProt.execute()) prot |= Unicorn.UC_PROT_EXEC;
        return prot;
    }
    @Override
    public int brk(long address) {
        throw new UnsupportedOperationException();
    }
    private Symbol malloc, free;
    @Override
    public MemoryBlock malloc(int length, boolean runtime) {
        if (runtime) {
            return MemoryBlockImpl.alloc(this, length);
        } else {
            return MemoryAllocBlock.malloc(emulator, malloc, free, length);
        }
    }
    private int lastErrno;
    @Override
    public int getLastErrno() {
        return lastErrno;
    }
    @Override
    public void setErrno(int errno) {
        this.lastErrno = errno;
        Task task = emulator.get(Task.TASK_KEY);
        if (task != null && task.setErrno(emulator, errno)) {
            return;
        }
        if (this.errno != null) {
            this.errno.setInt(0, errno);
        }
    }
    @Override
    public Module dlopen(String path) {
        return dlopen(path, true);
    }
    private void processBind(MachOModule m) {
        bindIndirectSymbolPointers(m);
        setupLazyPointerHandler(m);
    }
    public boolean dlopen_preflight(String path) {
        MachOModule loaded = modules.get(FilenameUtils.getName(path));
        if (loaded != null) {
            return true;
        }
        LibraryFile libraryFile = libraryResolver == null ? null : libraryResolver.resolveLibrary(emulator, path);
        return libraryFile != null;
    }
    @Override
    public Module dlopen(String path, boolean callInit) {
        if ("/usr/lib/libSystem.dylib".equals(path)) {
            path = "/usr/lib/libSystem.B.dylib";
        }
        MachOModule loadedModule = modules.get(FilenameUtils.getName(path));
        if (loadedModule != null) {
            loadedModule.addReferenceCount();
            return loadedModule;
        }
        for (Module module : getLoadedModules()) {
            for (MemRegion memRegion : module.getRegions()) {
                if (path.equals(memRegion.getName())) {
                    module.addReferenceCount();
                    return module;
                }
            }
        }
        LibraryFile libraryFile = libraryResolver == null ? null : libraryResolver.resolveLibrary(emulator, path);
        if (libraryFile == null) {
            return null;
        }
        MachOModule module = loadInternalPhase(libraryFile, true, false, Collections.emptyList());
        for (MachOModule export : modules.values().toArray(new MachOModule[0])) {
            for (NeedLibrary library : export.lazyLoadNeededList.toArray(new NeedLibrary[0])) {
                String neededLibrary = library.path;
                if (log.isDebugEnabled()) {
                    log.debug("dlopen {} need dependency {}", export.getPath(), neededLibrary);
                }
                MachOModule loaded = modules.get(FilenameUtils.getName(neededLibrary));
                if (loaded != null) {
                    if (library.upward) {
                        export.upwardLibraries.put(FilenameUtils.getBaseName(neededLibrary), loaded);
                    }
                    continue;
                }
                try {
                    LibraryFile neededLibraryFile = resolveLibrary(libraryFile, neededLibrary, Collections.singletonList(FilenameUtils.getFullPath(libraryFile.getPath())));
                    if (neededLibraryFile != null) {
                        MachOModule needed = loadInternalPhase(neededLibraryFile, true, false, Collections.emptySet());
                        needed.addReferenceCount();
                        if (library.upward) {
                            export.upwardLibraries.put(FilenameUtils.getBaseName(needed.name), needed);
                        }
                    } else if (!library.weak) {
                        log.info("{} load dependency {} failed", export.getPath(), neededLibrary);
                    }
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            export.lazyLoadNeededList.clear();
        }
        for (MachOModule export : modules.values()) {
            if (!export.lazyLoadNeededList.isEmpty()) {
                log.info("dlopen {} resolve needed library failed: {}, neededList={}", path, export.name, export.lazyLoadNeededList);
            }
        }
        for (MachOModule m : modules.values()) {
            processBind(m);
        }
        if (!callInitFunction) { 
            for (MachOModule m : modules.values()) {
                m.initFunctionList.clear();
            }
        }
        if (callInit) {
            for (MachOModule m : modules.values()) {
                if (m.symbolNotBound.isEmpty()) {
                    m.doInitialization(emulator);
                }
            }
        }
        module.addReferenceCount();
        return module;
    }
    @Override
    public boolean dlclose(long handle) {
        throw new UnsupportedOperationException();
    }
    @Override
    public Symbol dlsym(long handle, String symbolName) {
        for (MachOModule module : modules.values()) {
            if (module.machHeader == handle) {
                return module.findSymbolByName(symbolName, false);
            }
            if (handle == Dyld.RTLD_NEXT) {
                Symbol symbol = module.findSymbolByName(symbolName, false);
                if (symbol != null) {
                    return symbol;
                }
            }
        }
        if (handle == Dyld.RTLD_DEFAULT) {
            for (Module module : modules.values()) {
                Symbol symbol = module.findSymbolByName(symbolName, false);
                if (symbol != null) {
                    return symbol;
                }
            }
        }
        log.info("dlsym failed: handle={}, symbolName={}", handle, symbolName);
        return null;
    }
    @Override
    public Collection<Module> getLoadedModules() {
        return new ArrayList<>(modules.values());
    }
    final List<Module> getLoadedModulesNoVirtual() {
        List<Module> list = new ArrayList<>(modules.size());
        for (MachOModule mm : modules.values()) {
            if (!mm.isVirtual()) {
                list.add(mm);
            }
        }
        return list;
    }
    @Override
    public String getMaxLengthLibraryName() {
        return maxDylibName;
    }
    @Override
    public long getMaxSizeOfLibrary() {
        return maxSizeOfDylib;
    }
    final List<UnidbgPointer> addImageCallbacks = new ArrayList<>();
    final List<UnidbgPointer> boundHandlers = new ArrayList<>();
    final List<UnidbgPointer> initializedHandlers = new ArrayList<>();
    UnidbgPointer _objcNotifyMapped;
    UnidbgPointer _objcNotifyInit;
    private UnidbgStructure createDyldImageInfo(MachOModule module) {
        if (emulator.is64Bit()) {
            int elementSize = UnidbgStructure.calculateSize(DyldImageInfo64.class);
            Pointer pointer = emulator.getSvcMemory().allocate(elementSize, "notifySingle");
            DyldImageInfo64 info = new DyldImageInfo64(pointer);
            info.imageFilePath = UnidbgPointer.nativeValue(module.createPathMemory(emulator.getSvcMemory()));
            info.imageLoadAddress = module.machHeader;
            info.imageFileModDate = 0;
            info.pack();
            return info;
        } else {
            int elementSize = UnidbgStructure.calculateSize(DyldImageInfo32.class);
            Pointer pointer = emulator.getSvcMemory().allocate(elementSize, "notifySingle");
            DyldImageInfo32 info = new DyldImageInfo32(pointer);
            info.imageFilePath = (int) (UnidbgPointer.nativeValue(module.createPathMemory(emulator.getSvcMemory())));
            info.imageLoadAddress = (int) module.machHeader;
            info.imageFileModDate = 0;
            info.pack();
            return info;
        }
    }
    private void notifySingle(int state, MachOModule module) {
        if (module.isVirtual()) { 
            return;
        }
        UnidbgStructure info = createDyldImageInfo(module);
        switch (state) {
            case Dyld.dyld_image_state_bound:
                long slide = module.slide;
                if (!module.executable) {
                    for (UnidbgPointer callback : addImageCallbacks) {
                        if (module.addImageCallSet.add(callback)) {
                            if (log.isDebugEnabled()) {
                                log.debug("notifySingle callback={}, module={}", callback, module.name);
                            }
                            Module.emulateFunction(emulator, callback.peer, UnidbgPointer.pointer(emulator, module.machHeader), UnidbgPointer.pointer(emulator, slide));
                        }
                    }
                }
                for (UnidbgPointer handler : boundHandlers) {
                    if (module.boundCallSet.add(handler)) {
                        if (log.isDebugEnabled()) {
                            log.debug("notifySingle state={}, handler={}, module={}", state, handler, module.name);
                        }
                        Module.emulateFunction(emulator, handler.peer, state, 1, info);
                    }
                }
                break;
            case Dyld.dyld_image_state_dependents_initialized:
                for (UnidbgPointer handler : initializedHandlers) {
                    if (module.dependentsInitializedCallSet.add(handler)) {
                        if (log.isDebugEnabled()) {
                            log.debug("dyld_image_state_dependents_initialized notifySingle state={}, handler={}, module={}", state, handler, module.name);
                        }
                        Module.emulateFunction(emulator, handler.peer, state, 1, info);
                    }
                }
                break;
            case Dyld.dyld_image_state_initialized:
                for (UnidbgPointer handler : boundHandlers) {
                    if (module.initializedCallSet.add(handler)) {
                        if (log.isDebugEnabled()) {
                            log.debug("dyld_image_state_initialized notifySingle state={}, handler={}, module={}", state, handler, module.name);
                        }
                        Module.emulateFunction(emulator, handler.peer, state, 1, info);
                    }
                }
                module.callObjcNotifyInit(_objcNotifyInit);
                break;
            default:
                throw new UnsupportedOperationException("state=" + state);
        }
    }
    private void setExecuteModule(MachOModule module) {
        if (executableModule == null) {
            executableModule = module;
            vars.setPointer(0, UnidbgPointer.pointer(emulator, module.machHeader)); 
        }
    }
    MachOModule executableModule;
    final long allocate(long size, long mask) {
        if (log.isDebugEnabled()) {
            log.debug("allocate size=0x{}, mask=0x{}", Long.toHexString(size), Long.toHexString(mask));
        }
        long address = allocateMapAddress(mask, size);
        int prot = UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE;
        backend.mem_map(address, size, prot);
        if (mMapListener != null) {
            mMapListener.onMap(address, size, prot);
        }
        if (memoryMap.put(address, new MemoryMap(address, size, prot)) != null) {
            log.warn("Replace memory map address=0x{}", Long.toHexString(address));
        }
        return address;
    }
    public Module getExecutableModule() {
        return executableModule;
    }
    final void remap(VmRemapRequest args) {
        MemoryMap memoryMap = null;
        for (MemoryMap map : emulator.getMemory().getMemoryMap()) {
            if (args.target_address >= map.base && args.target_address + args.size <= map.base + map.size) {
                memoryMap = map;
                break;
            }
        }
        if (memoryMap != null) {
            munmap(args.target_address, (int) args.size);
        }
        int prot = UnicornConst.UC_PROT_ALL;
        try {
            backend.mem_map(args.target_address, args.size, prot);
            if (mMapListener != null) {
                mMapListener.onMap(args.target_address, args.size, prot);
            }
        } catch (BackendException e) {
            throw new IllegalStateException("remap target_address=0x" + Long.toHexString(args.target_address) + ", size=" + args.size, e);
        }
        if (this.memoryMap.put(args.target_address, new MemoryMap(args.target_address, args.size, prot)) != null) {
            log.warn("remap replace exists memory map: start={}", Long.toHexString(args.target_address));
        }
    }
    @Override
    public long mmap2(long start, int length, int prot, int flags, int fd, int offset) {
        int aligned = (int) ARM.alignSize(length, emulator.getPageAlign());
        boolean isAnonymous = ((flags & com.github.unidbg.ios.MachO.MAP_ANONYMOUS) != 0) || (start == 0 && fd <= 0 && offset == 0);
        if ((flags & MAP_FIXED) != 0 && isAnonymous) {
            if (log.isDebugEnabled()) {
                log.debug("mmap2 MAP_FIXED start=0x{}, length={}, prot={}", Long.toHexString(start), length, prot);
            }
            MemoryMap mapped = null;
            for (MemoryMap map : memoryMap.values()) {
                if (start >= map.base && start + aligned <= map.base + map.size) {
                    mapped = map;
                }
            }
            if (mapped != null) {
                munmap(start, aligned);
                backend.mem_map(start, aligned, prot);
                if (mMapListener != null) {
                    mMapListener.onMap(start, aligned, prot);
                }
                if (memoryMap.put(start, new MemoryMap(start, aligned, prot)) != null) {
                    log.warn("mmap2 replace exists memory map: start={}", Long.toHexString(start));
                }
                return start;
            } else {
                throw new IllegalStateException("mmap2 MAP_FIXED not found mapped memory: start=0x" + Long.toHexString(start));
            }
        }
        if (isAnonymous) {
            long addr = allocateMapAddress(0, aligned);
            if (log.isDebugEnabled()) {
                log.debug("mmap2 addr=0x{}, mmapBaseAddress=0x{}, start={}, fd={}, offset={}, aligned={}", Long.toHexString(addr), Long.toHexString(mmapBaseAddress), start, fd, offset, aligned);
            }
            backend.mem_map(addr, aligned, prot);
            if (mMapListener != null) {
                mMapListener.onMap(addr, aligned, prot);
            }
            if (memoryMap.put(addr, new MemoryMap(addr, aligned, prot)) != null) {
                log.warn("mmap2 replace exists memory map: addr={}", Long.toHexString(addr));
            }
            return addr;
        }
        try {
            FileIO file;
            if (start == 0 && fd > 0 && (file = syscallHandler.getFileIO(fd)) != null) {
                long addr = allocateMapAddress(0, aligned);
                if (log.isDebugEnabled()) {
                    log.debug("mmap2 addr=0x{}, mmapBaseAddress=0x{}", Long.toHexString(addr), Long.toHexString(mmapBaseAddress));
                }
                long ret = file.mmap2(emulator, addr, aligned, prot, offset, length);
                if (mMapListener != null) {
                    mMapListener.onMap(addr, aligned, prot);
                }
                if (memoryMap.put(addr, new MemoryMap(addr, aligned, prot)) != null) {
                    log.warn("mmap2 replace exists memory map addr=0x{}", Long.toHexString(addr));
                }
                return ret;
            }
            if ((flags & MAP_FIXED) != 0) {
                if (log.isDebugEnabled()) {
                    log.debug("mmap2 MAP_FIXED start=0x{}, length={}, prot={}, fd={}, offset=0x{}", Long.toHexString(start), length, prot, fd, Long.toHexString(offset));
                }
                MemoryMap mapped = null;
                for (MemoryMap map : memoryMap.values()) {
                    if (start >= map.base && start + aligned <= map.base + map.size) {
                        mapped = map;
                    }
                }
                if (mapped != null) {
                    backend.mem_unmap(start, aligned);
                    if (mMapListener != null) {
                        mMapListener.onUnmap(start, aligned);
                    }
                } else {
                    log.warn("mmap2 MAP_FIXED not found mapped memory: start=0x{}", Long.toHexString(start));
                }
                FileIO io = syscallHandler.getFileIO(fd);
                if (io != null) {
                    long ret = io.mmap2(emulator, start, aligned, prot, offset, length);
                    if (mMapListener != null) {
                        mMapListener.onMap(start, aligned, prot);
                    }
                    return ret;
                }
            }
            if (flags == MAP_MY_FIXED) {
                if (log.isDebugEnabled()) {
                    log.debug("mmap2 NOT VM_FLAGS_ANYWHERE start=0x{}, length={}, prot={}, fd={}, offset=0x{}", Long.toHexString(start), length, prot, fd, Long.toHexString(offset));
                }
                MemoryMap mapped = null;
                for (MemoryMap map : memoryMap.values()) {
                    if (start >= map.base && start + aligned <= map.base + map.size) {
                        mapped = map;
                    }
                }
                if (mapped != null) {
                    if (log.isDebugEnabled()) {
                        log.debug("mmap2 NOT VM_FLAGS_ANYWHERE found mapped memory: start=0x{}", Long.toHexString(start));
                    }
                    return 0;
                }
                backend.mem_map(start, aligned, prot);
                if (mMapListener != null) {
                    mMapListener.onMap(start, aligned, prot);
                }
                if (memoryMap.put(start, new MemoryMap(start, aligned, prot)) != null) {
                    log.warn("mmap2 NOT VM_FLAGS_ANYWHERE exists memory map addr=0x{}", Long.toHexString(start));
                }
                if (start + aligned >= mmapBaseAddress) {
                    setMMapBaseAddress(start + aligned);
                }
                return start;
            }
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
        throw new AbstractMethodError("mmap2 start=0x" + Long.toHexString(start) + ", length=" + length + ", prot=0x" + Integer.toHexString(prot) + ", flags=0x" + Integer.toHexString(flags) + ", fd=" + fd + ", offset=" + offset);
    }
    @Override
    public Module loadVirtualModule(String name, Map<String, UnidbgPointer> symbols) {
        MachOModule module = MachOModule.createVirtualModule(name, symbols, emulator);
        modules.put(name, module);
        if (maxDylibName == null || name.length() > maxDylibName.length()) {
            maxDylibName = name;
        }
        return module;
    }
    @Override
    protected long getModuleBase(Module module) {
        return super.getModuleBase(module);
    }
}
package com.github.unidbg.ios;
import com.github.unidbg.AbstractEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.arm.Cpsr;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.ios.DarwinFileIO;
import com.github.unidbg.file.ios.IOConstants;
import com.github.unidbg.ios.kevent.KEvent;
import com.github.unidbg.ios.kevent.KEvent64;
import com.github.unidbg.ios.kevent.KEventWaiter;
import com.github.unidbg.ios.signal.SigAction;
import com.github.unidbg.ios.signal.SignalTask;
import com.github.unidbg.ios.struct.VMStatistics;
import com.github.unidbg.ios.struct.kernel.HostStatisticsReply;
import com.github.unidbg.ios.struct.kernel.HostStatisticsRequest;
import com.github.unidbg.ios.struct.kernel.MachMsgHeader;
import com.github.unidbg.ios.struct.kernel.Pthread;
import com.github.unidbg.ios.struct.kernel.StatFS;
import com.github.unidbg.ios.struct.kernel.VprocMigLookupData;
import com.github.unidbg.ios.struct.kernel.VprocMigLookupReply;
import com.github.unidbg.ios.struct.kernel.VprocMigLookupRequest;
import com.github.unidbg.ios.thread.BsdThread;
import com.github.unidbg.ios.thread.SemWaiter;
import com.github.unidbg.memory.MemoryBlock;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.pointer.UnidbgStructure;
import com.github.unidbg.signal.SigSet;
import com.github.unidbg.signal.SignalOps;
import com.github.unidbg.signal.UnixSigSet;
import com.github.unidbg.spi.SyscallHandler;
import com.github.unidbg.thread.RunnableTask;
import com.github.unidbg.thread.Task;
import com.github.unidbg.thread.ThreadContextSwitchException;
import com.github.unidbg.thread.ThreadDispatcher;
import com.github.unidbg.thread.ThreadTask;
import com.github.unidbg.unix.UnixEmulator;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.unix.struct.TimeSpec;
import com.sun.jna.Pointer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
public abstract class DarwinSyscallHandler extends UnixSyscallHandler<DarwinFileIO> implements SyscallHandler<DarwinFileIO>, DarwinSyscall  {
    private static final Logger log = LoggerFactory.getLogger(DarwinSyscallHandler.class);
    final long bootTime = System.currentTimeMillis();
    protected String getHwMachine() {
        return "iPhone6,2";
    }
    protected int getHwNcpu() {
        return 2;
    }
    protected abstract void fillKernelBootTime(Pointer buffer);
    protected final void exit(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int status = context.getIntArg(0);
        if (status != 0 || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            emulator.attach().debug();
        }
        System.exit(status);
    }
    protected int fork(Emulator<?> emulator) {
        log.info("fork");
        if (emulator.is64Bit()) {
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
        } else {
            Cpsr.getArm(emulator.getBackend()).setCarry(true);
        }
        return UnixEmulator.ENOSYS;
    }
    protected final int open_NOCANCEL(Emulator<DarwinFileIO> emulator, int offset) {
        RegisterContext context = emulator.getContext();
        Pointer pathname_p = context.getPointerArg(offset);
        int oflags = context.getIntArg(offset + 1);
        int mode = context.getIntArg(offset + 2);
        String pathname = pathname_p.getString(0);
        int fd = open(emulator, pathname, oflags);
        if (log.isDebugEnabled()) {
            log.debug("open_NOCANCEL pathname={}, oflags=0x{}, mode={}, fd={}, LR={}", pathname, Integer.toHexString(oflags), Integer.toHexString(mode), fd, context.getLRPointer());
        }
        if (fd == -1) {
            if (emulator.is64Bit()) {
                Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            } else {
                Cpsr.getArm(emulator.getBackend()).setCarry(true);
            }
            return emulator.getMemory().getLastErrno();
        } else {
            return fd;
        }
    }
    protected int getfsstat64(Emulator<DarwinFileIO> emulator, int off) {
        RegisterContext context = emulator.getContext();
        UnidbgPointer buf = context.getPointerArg(off);
        int bufSize = context.getIntArg(off + 1);
        int flags = context.getIntArg(off + 2);
        if (log.isDebugEnabled()) {
            log.debug("getfsstat64 buf={}, bufSize={}, flags=0x{}", buf, bufSize, Integer.toHexString(flags));
        }
        final int mountedFsSize = 2;
        if (buf == null) {
            return mountedFsSize;
        }
        buf.setSize(bufSize);
        Pointer pointer = buf;
        int statfs_size = UnidbgStructure.calculateSize(StatFS.class);
        if (bufSize >= statfs_size) {
            StatFS statFS = new StatFS(pointer);
            statFS.f_bsize = 0x1000;
            statFS.f_iosize = 0x100000;
            statFS.f_blocks = 507876;
            statFS.f_bfree = 76016;
            statFS.f_bavail = 70938;
            statFS.f_files = 507874;
            statFS.f_ffree = 70938;
            statFS.f_fsid = 0x1101000002L;
            statFS.f_owner = 0;
            statFS.f_type = 0x11;
            statFS.f_flags = 0x480d000;
            statFS.f_fssubtype = 0x3;
            statFS.setFsTypeName("hfs");
            statFS.setMntOnName("/");
            statFS.setMntFromName("/dev/disk0s1s1");
            statFS.pack();
            bufSize -= statfs_size;
            pointer = pointer.share(statfs_size);
        }
        if (bufSize >= statfs_size) {
            StatFS statFS = new StatFS(pointer);
            statFS.f_bsize = 0x1000;
            statFS.f_iosize = 0x100000;
            statFS.f_blocks = 3362844;
            statFS.f_bfree = 3000788;
            statFS.f_bavail = 3000788;
            statFS.f_files = 3362842;
            statFS.f_ffree = 3000788;
            statFS.f_fsid = 0x1101000003L;
            statFS.f_owner = 0;
            statFS.f_type = 0x11;
            statFS.f_flags = 0x14809080;
            statFS.f_fssubtype = 0x3;
            statFS.setFsTypeName("hfs");
            statFS.setMntOnName("/private/var");
            statFS.setMntFromName("/dev/disk0s1s2");
            statFS.pack();
        }
        if (verbose) {
            System.out.printf("getfsstat from %s%n", emulator.getContext().getLRPointer());
        }
        return mountedFsSize;
    }
    protected final int access(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer pathname = context.getPointerArg(0);
        int mode = context.getIntArg(1);
        String path = pathname.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("access pathname={}, mode={}", path, mode);
        }
        return faccessat(emulator, path, mode);
    }
    protected final int faccessat(Emulator<DarwinFileIO> emulator, String pathname, int mode) {
        FileResult<?> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            if (verbose) {
                System.out.printf("File access '%s' with mode=0x%x from %s%n", pathname, mode, emulator.getContext().getLRPointer());
            }
            return 0;
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.ENOENT);
        if (verbose) {
            System.out.printf("File access failed '%s' with mode=0x%x from %s%n", pathname, mode, emulator.getContext().getLRPointer());
        }
        return -1;
    }
    protected final int flistxattr(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        UnidbgPointer namebuf = context.getPointerArg(1);
        int size = context.getIntArg(2);
        int options = context.getIntArg(3);
        DarwinFileIO io = fdMap.get(fd);
        if (namebuf != null) {
            namebuf.setSize(size);
        }
        if (io != null) {
            int ret = io.listxattr(namebuf, size, options);
            if (ret == -1) {
                log.info("flistxattr fd={}, namebuf={}, size={}, options={}, LR={}", fd, namebuf, size, options, context.getLRPointer());
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("flistxattr fd={}, namebuf={}, size={}, options={}, LR={}", fd, namebuf, size, options, context.getLRPointer());
                }
            }
            return ret;
        } else {
            log.info("flistxattr fd={}, namebuf={}, size={}, options={}, LR={}", fd, namebuf, size, options, context.getLRPointer());
            emulator.getMemory().setErrno(UnixEmulator.ENOENT);
            return -1;
        }
    }
    protected final int listxattr(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        UnidbgPointer namebuf = context.getPointerArg(1);
        int size = context.getIntArg(2);
        int options = context.getIntArg(3);
        String pathname = path.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (namebuf != null) {
            namebuf.setSize(size);
        }
        if (result.isSuccess()) {
            int ret = result.io.listxattr(namebuf, size, options);
            if (ret == -1) {
                log.info("listxattr path={}, namebuf={}, size={}, options={}, LR={}", pathname, namebuf, size, options, context.getLRPointer());
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("listxattr path={}, namebuf={}, size={}, options={}, LR={}", pathname, namebuf, size, options, context.getLRPointer());
                }
            }
            return ret;
        } else {
            log.info("listxattr path={}, namebuf={}, size={}, options={}, LR={}", pathname, namebuf, size, options, context.getLRPointer());
            emulator.getMemory().setErrno(UnixEmulator.ENOENT);
            return -1;
        }
    }
    protected final int fchmodx_np(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int fsowner = context.getIntArg(1);
        int fsgrp = context.getIntArg(2);
        int fsmode = context.getIntArg(3);
        int fsacl = context.getIntArg(4);
        DarwinFileIO io = fdMap.get(fd);
        log.debug("fchmodx_np fd={}, fsowner={}, fsgrp={}, fsmode=0x{}, fsacl={}, io={}", fd, fsowner, fsgrp, Integer.toHexString(fsmode), fsacl, io);
        if (io != null) {
            int ret = io.chmod(fsmode);
            if (ret == -1) {
                log.info("fchmodx_np fd={}, fsmode=0x{}, io={}", fd, Integer.toHexString(fsmode), io);
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("fchmodx_np fd={}, fsmode=0x{}", fd, Integer.toHexString(fsmode));
                }
            }
            return ret;
        } else {
            log.info("fchmodx_np fd={}, fsmode=0x{}", fd, Integer.toHexString(fsmode));
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    protected final int chmodx_np(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        int fsowner = context.getIntArg(1);
        int fsgrp = context.getIntArg(2);
        int fsmode = context.getIntArg(3);
        int fsacl = context.getIntArg(4);
        String pathname = path.getString(0);
        log.debug("chmodx_np pathname={}, fsowner={}, fsgrp={}, fsmode=0x{}, fsacl={}", pathname, fsowner, fsgrp, Integer.toHexString(fsmode), fsacl);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result.isSuccess()) {
            int ret = result.io.chmod(fsmode);
            if (ret == -1) {
                log.info("chmodx_np path={}, fsmode=0x{}, io={}", pathname, Integer.toHexString(fsmode), result.io);
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("chmodx_np path={}, fsmode=0x{}", pathname, Integer.toHexString(fsmode));
                }
            }
            return ret;
        } else {
            log.info("chmodx_np path={}, fsmode=0x{}", pathname, Integer.toHexString(fsmode));
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    protected int fchmod(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int mode = context.getIntArg(1) & 0xffff;
        DarwinFileIO io = fdMap.get(fd);
        if (io != null) {
            int ret = io.chmod(mode);
            if (ret == -1) {
                log.info("fchmod fd={}, mode=0x{}, io={}", fd, Integer.toHexString(mode), io);
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("fchmod fd={}, mode=0x{}", fd, Integer.toHexString(mode));
                }
            }
            return ret;
        } else {
            log.info("fchmod fd={}, mode=0x{}", fd, Integer.toHexString(mode));
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    protected final int select(int nfds, Pointer checkfds, Pointer clearfds, boolean checkRead) {
        int count = 0;
        for (int i = 0; i < nfds; i++) {
            int mask = checkfds.getInt(i / 32);
            if (((mask >> i) & 1) == 1) {
                DarwinFileIO io = fdMap.get(i);
                if (!checkRead || io.canRead()) {
                    count++;
                } else {
                    mask &= ~(1 << i);
                    checkfds.setInt(i / 32, mask);
                }
            }
        }
        if (count > 0) {
            if (clearfds != null) {
                for (int i = 0; i < nfds; i++) {
                    clearfds.setInt(i / 32, 0);
                }
            }
        }
        return count;
    }
    protected final int chmod(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer path = context.getPointerArg(0);
        int mode = context.getIntArg(1) & 0xffff;
        String pathname = path.getString(0);
        FileResult<DarwinFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result.isSuccess()) {
            int ret = result.io.chmod(mode);
            if (ret == -1) {
                log.info("chmod path={}, mode=0x{}, io={}", pathname, Integer.toHexString(mode), result.io);
            } else {
                if (log.isDebugEnabled()) {
                    log.debug("chmod path={}, mode=0x{}", pathname, Integer.toHexString(mode));
                }
            }
            return ret;
        } else {
            log.info("chmod path={}, mode=0x{}", pathname, Integer.toHexString(mode));
            Cpsr.getArm64(emulator.getBackend()).setCarry(true);
            return UnixEmulator.ENOENT;
        }
    }
    protected final boolean host_statistics(Pointer request, MachMsgHeader header) {
        HostStatisticsRequest args = new HostStatisticsRequest(request);
        args.unpack();
        if (log.isDebugEnabled()) {
            log.debug("host_statistics args={}", args);
        }
        if (args.flavor == HostStatisticsRequest.HOST_VM_INFO) {
            int size = UnidbgStructure.calculateSize(VMStatistics.class);
            HostStatisticsReply reply = new HostStatisticsReply(request, size);
            reply.unpack();
            header.setMsgBits(false);
            header.msgh_size = header.size() + reply.size();
            header.msgh_remote_port = header.msgh_local_port;
            header.msgh_local_port = 0;
            header.msgh_id += 100; 
            header.pack();
            reply.writeVMStatistics();
            reply.retCode = 0;
            reply.host_info_outCnt = size / 4;
            reply.pack();
            if (log.isDebugEnabled()) {
                log.debug("host_statistics HOST_VM_INFO reply={}", reply);
            }
            return true;
        }
        return false;
    }
    final int vproc_mig_look_up2(Pointer request, MachMsgHeader header) {
        VprocMigLookupRequest args = new VprocMigLookupRequest(request);
        args.unpack();
        String serviceName = args.getServiceName();
        if (log.isDebugEnabled()) {
            log.debug("vproc_mig_look_up2 args={}, serviceName={}", args, serviceName);
        }
        if ("cy:com.saurik.substrated".equals(serviceName)) {
            return -1;
        }
        VprocMigLookupReply reply = new VprocMigLookupReply(request);
        reply.unpack();
        header.msgh_bits = (header.msgh_bits & 0xff) | MACH_MSGH_BITS_COMPLEX;
        header.msgh_size = header.size() + reply.size();
        header.msgh_remote_port = header.msgh_local_port;
        header.msgh_local_port = 0;
        header.msgh_id += 100; 
        header.pack();
        reply.body.msgh_descriptor_count = 1;
        reply.sp.name = STATIC_PORT;
        reply.sp.pad1 = 0;
        reply.sp.pad2 = 0;
        reply.sp.disposition = 17;
        reply.sp.type = MACH_MSG_PORT_DESCRIPTOR;
        reply.pack();
        VprocMigLookupData data = new VprocMigLookupData(request.share(reply.size()));
        data.size = 0x20;
        Arrays.fill(data.au_tok.val, 0);
        data.pack();
        if (log.isDebugEnabled()) {
            log.debug("vproc_mig_look_up2 reply={}, data={}", reply, data);
        }
        return MACH_MSG_SUCCESS;
    }
    protected String executableBundlePath;
    public void setExecutableBundlePath(String executableBundlePath) {
        this.executableBundlePath = executableBundlePath;
    }
    private int threadId;
    private int incrementThreadId(Emulator<?> emulator) {
        if (threadId == 0) {
            threadId = emulator.getPid();
        }
        return (++threadId) & 0xffff;
    }
    private int processSignal(ThreadDispatcher threadDispatcher, int sig, Task task, SigAction action) {
        if (action != null) {
            SignalOps signalOps = task.isMainThread() ? threadDispatcher : task;
            SigSet sigMaskSet = signalOps.getSigMaskSet();
            SigSet sigPendingSet = signalOps.getSigPendingSet();
            if (sigMaskSet == null || !sigMaskSet.containsSigNumber(sig)) {
                task.addSignalTask(new SignalTask(sig, action));
                throw new ThreadContextSwitchException().setReturnValue(0);
            } else if (sigPendingSet != null) {
                sigPendingSet.addSigNumber(sig);
            }
        }
        return 0;
    }
    protected int pthread_kill(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int threadPort = context.getIntArg(0);
        int sig = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("pthread_kill threadPort={}, sig={}", threadPort, sig);
        }
        if (sig > 0) {
            SigAction action = sigActionMap.get(sig);
            if (emulator.getThreadDispatcher().sendSignal(threadPort, sig, action == null ? null : new SignalTask(sig, action))) {
                throw new ThreadContextSwitchException().setReturnValue(0);
            }
        }
        return 0;
    }
    protected int _semaphore_wait_trap(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int port = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("_semaphore_wait_trap port={}, LR={}", port, context.getLRPointer());
        }
        if (log.isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        RunnableTask runningTask = emulator.getThreadDispatcher().getRunningTask();
        if (threadDispatcherEnabled && runningTask != null) {
            runningTask.setWaiter(emulator, new SemWaiter(port, semaphoreMap));
            throw new ThreadContextSwitchException().setReturnValue(0);
        }
        if (LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        return 0;
    }
    protected final Map<Integer, Boolean> semaphoreMap = new HashMap<>();
    protected int semwait_signal(Emulator<?> emulator, RunnableTask runningTask, int cond_sem, int mutex_sem, int timeout, int relative,
                                 long tv_sec, int tv_nsec) {
        if (timeout == 1 && relative == 1 && (tv_sec > 0 || tv_nsec > 0)) {
            if (threadDispatcherEnabled) {
                runningTask.setWaiter(emulator, new SemWaiter(cond_sem, semaphoreMap, tv_sec, tv_nsec));
                throw new ThreadContextSwitchException().setReturnValue(0);
            }
            try {
                Thread.sleep(tv_sec * 1000L + tv_nsec / 1000L, tv_nsec % 1000);
                emulator.getMemory().setErrno(ETIMEDOUT);
                return -1;
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
        }
        if (mutex_sem != 0 || timeout != 0 ||
                relative != 0 || tv_sec != 0 || tv_nsec != 0) {
            createBreaker(emulator).debug();
            throw new UnsupportedOperationException("semwait_signal cond_sem=" + cond_sem + ", mutex_sem=" + mutex_sem + ", timeout=" + timeout + ", relative=" + relative + ", tv_sec=" + tv_sec + ", tv_nsec=" + tv_nsec);
        }
        runningTask.setWaiter(emulator, new SemWaiter(cond_sem, semaphoreMap));
        throw new ThreadContextSwitchException().setReturnValue(0);
    }
    protected int disable_threadsignal(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int status = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("disable_threadsignal status={}", status);
        }
        Task task = emulator.get(Task.TASK_KEY);
        if (task == emulator.getThreadDispatcher().getRunningTask() &&
                !task.getSignalTaskList().isEmpty()) {
            throw new ThreadContextSwitchException().setReturnValue(0);
        }
        return 0;
    }
    protected int sigpending(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer set = context.getPointerArg(0);
        if (log.isDebugEnabled()) {
            log.debug("sigpending set={}", set);
        }
        Task task = emulator.get(Task.TASK_KEY);
        SignalOps signalOps = task.isMainThread() ? emulator.getThreadDispatcher() : task;
        SigSet sigSet = signalOps.getSigPendingSet();
        if (set != null && sigSet != null) {
            set.setInt(0, (int) sigSet.getMask());
        }
        return 0;
    }
    protected int sigwait(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer set = context.getPointerArg(0);
        Pointer sig = context.getPointerArg(1);
        int mask = set.getInt(0);
        Task task = emulator.get(Task.TASK_KEY);
        SigSet sigSet = new UnixSigSet(mask);
        SignalOps signalOps = task.isMainThread() ? emulator.getThreadDispatcher() : task;
        SigSet sigPendingSet = signalOps.getSigPendingSet();
        if (sigPendingSet != null) {
            for (Integer signum : sigSet) {
                if (sigPendingSet.containsSigNumber(signum)) {
                    sigPendingSet.removeSigNumber(signum);
                    sig.setInt(0, signum);
                    return 0;
                }
            }
        }
        if (!task.isMainThread()) {
            throw new ThreadContextSwitchException().setReturnValue(-1);
        }
        log.info("sigwait set={}, sig={}", set, sig);
        Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
        if (log.isDebugEnabled()) {
            emulator.attach().debug();
        }
        return 0;
    }
    protected int kill(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        int sig = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("kill pid={}, sig={}", pid, sig);
        }
        Task task = emulator.get(Task.TASK_KEY);
        if ((pid == 0 || pid == emulator.getPid()) && sig > 0 && task != null) {
            SigAction action = sigActionMap.get(sig);
            return processSignal(emulator.getThreadDispatcher(), sig, task, action);
        }
        throw new UnsupportedOperationException("kill pid=" + pid + ", sig=" + sig + ", LR=" + context.getLRPointer());
    }
    private final Map<Integer, SigAction> sigActionMap = new HashMap<>();
    @Override
    protected int sigaction(Emulator<?> emulator, int signum, Pointer act, Pointer oldact) {
        SigAction action = SigAction.create(emulator, act);
        SigAction oldAction = SigAction.create(emulator, oldact);
        if (log.isDebugEnabled()) {
            log.debug("sigaction signum={}, action={}, oldAction={}", signum, action, oldAction);
        }
        SigAction lastAction = sigActionMap.put(signum, action);
        if (oldAction != null) {
            if (lastAction == null) {
                oldact.write(0, new byte[oldAction.size()], 0, oldAction.size());
            } else {
                oldAction.setSaHandler(lastAction.getSaHandler());
                oldAction.sa_mask = lastAction.sa_mask;
                oldAction.sa_flags = lastAction.sa_flags;
                oldAction.pack();
            }
        }
        return 0;
    }
    protected int thread_selfid(Emulator<?> emulator) {
        Task task = emulator.get(Task.TASK_KEY);
        if (task != null) {
            if (task.isMainThread()) {
                return emulator.getPid();
            } else if (task instanceof ThreadTask) {
                ThreadTask thread = (ThreadTask) task;
                return thread.getId();
            }
        }
        log.debug("thread_selfid");
        return 1;
    }
    private static final int SIG_BLOCK = 1; 
    private static final int SIG_UNBLOCK = 2; 
    private static final int SIG_SETMASK = 3; 
    protected int pthread_sigmask(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int how = context.getIntArg(0);
        Pointer set = context.getPointerArg(1);
        Pointer oset = context.getPointerArg(2);
        if (log.isDebugEnabled()) {
            log.debug("pthread_sigmask how={}, set={}, oset={}", how, set, oset);
        }
        Task task = emulator.get(Task.TASK_KEY);
        SignalOps signalOps = task.isMainThread() ? emulator.getThreadDispatcher() : task;
        SigSet old = signalOps.getSigMaskSet();
        if (oset != null && old != null) {
            oset.setInt(0, (int) old.getMask());
        }
        if (set == null) {
            return 0;
        }
        int mask = set.getInt(0);
        switch (how) {
            case SIG_BLOCK:
                if (old == null) {
                    SigSet sigSet = new UnixSigSet(mask);
                    SigSet sigPendingSet = new UnixSigSet(0);
                    signalOps.setSigMaskSet(sigSet);
                    signalOps.setSigPendingSet(sigPendingSet);
                } else {
                    old.blockSigSet(mask);
                }
                return 0;
            case SIG_UNBLOCK:
                if (old != null) {
                    old.unblockSigSet(mask);
                }
                return 0;
            case SIG_SETMASK:
                SigSet sigSet = new UnixSigSet(mask);
                SigSet sigPendingSet = new UnixSigSet(0);
                signalOps.setSigMaskSet(sigSet);
                signalOps.setSigPendingSet(sigPendingSet);
                return 0;
            default:
                throw new IllegalStateException();
        }
    }
    protected int kqueue() {
        if (log.isDebugEnabled()) {
            log.debug("kqueue");
        }
        int fd = getMinFd();
        fdMap.put(fd, new KEvent(0));
        return fd;
    }
    protected int guarded_kqueue_np(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer guard = context.getPointerArg(0);
        int guardFlags = context.getIntArg(1);
        KEvent64 kev = new KEvent64(guard.getPointer(0));
        kev.unpack();
        if (log.isDebugEnabled()) {
            log.debug("guarded_kqueue_np kev={}, guardFlags=0x{}, LR={}", kev, Integer.toHexString(guardFlags), context.getLRPointer());
        }
        int fd = getMinFd();
        fdMap.put(fd, new KEvent(guardFlags));
        return fd;
    }
    protected int kevent64(Emulator<?> emulator, int kq, Pointer changelist, int nchanges, Pointer eventlist, int nevents, int flags, TimeSpec timeSpec) {
        RegisterContext context = emulator.getContext();
        if (log.isDebugEnabled()) {
            log.debug("kevent64 kq={}, changelist={}, nchanges={}, eventlist={}, nevents={}, flags=0x{}, timeSpec={}, LR={}", kq, changelist, nchanges, eventlist, nevents, Integer.toHexString(flags), timeSpec, context.getLRPointer());
        }
        if (timeSpec != null) {
            throw new UnsupportedOperationException();
        }
        KEvent event = (KEvent) fdMap.get(kq);
        event.processChangeList(changelist, nchanges);
        if (eventlist == null || nevents <= 0) {
            return 0;
        }
        RunnableTask runningTask = emulator.getThreadDispatcher().getRunningTask();
        if (runningTask != null) {
            runningTask.setWaiter(emulator, new KEventWaiter(event, eventlist, nevents));
            throw new ThreadContextSwitchException();
        }
        if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        return 0;
    }
    protected int psynch_cvbroad(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer ocond = context.getPointerArg(0);
        if (log.isDebugEnabled()) {
            log.debug("psynch_cvbroad ocond={}", ocond);
        }
        if (threadDispatcherEnabled) {
            throw new ThreadContextSwitchException().setReturnValue(0);
        }
        return 0;
    }
    private UnidbgPointer thread_start;
    private int pthreadSize;
    protected int bsdthread_register(UnidbgPointer thread_start, int pthreadSize) {
        this.thread_start = thread_start;
        this.pthreadSize = pthreadSize;
        return 0;
    }
    protected int bsdthread_terminate(Emulator<DarwinFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        final UnidbgPointer freeaddr = context.getPointerArg(0);
        final int freesize = context.getIntArg(1);
        int kport = context.getIntArg(2);
        int joinsem = context.getIntArg(3);
        if (log.isDebugEnabled()) {
            log.debug("bsdthread_terminate freeaddr={}, freesize={}, kport={}, joinsem={}", freeaddr, freesize, kport, joinsem);
        }
        if (joinsem != 0) {
            semaphoreMap.put(joinsem, Boolean.TRUE);
        }
        Task task = emulator.get(Task.TASK_KEY);
        if (task instanceof ThreadTask) {
            ThreadTask threadTask = (ThreadTask) task;
            threadTask.setExitStatus(0);
            emulator.getMemory().munmap(freeaddr.peer, freesize);
            throw new ThreadContextSwitchException().setReturnValue(0);
        }
        return 0;
    }
    protected long bsdthread_create(Emulator<?> emulator, UnidbgPointer start_routine, UnidbgPointer arg, UnidbgPointer stack, UnidbgPointer thread, int flags) {
        int threadId = incrementThreadId(emulator);
        if (thread == null) {
            if (thread_start == null || pthreadSize <= 0) {
                throw new IllegalStateException();
            }
            int stackSize = (int) stack.toUIntPeer();
            int pageSize = emulator.getPageAlign();
            MemoryBlock memoryBlock = emulator.getMemory().malloc(pageSize + stackSize + pthreadSize, true);
            thread = memoryBlock.getPointer().share(pageSize + stackSize, 0);
            Pthread pThread = Pthread.create(emulator, thread);
            pThread.setMachThreadSelf(threadId);
            pThread.pack();
            String msg = "bsdthread_create start_routine=" + start_routine + ", arg=" + arg + ", stack=" + stack + ", thread=" + thread + ", flags=0x" + Integer.toHexString(flags);
            if (threadDispatcherEnabled) {
                if (log.isDebugEnabled()) {
                    log.debug(msg);
                }
                if (verbose) {
                    System.out.printf("bsdthread_create start_routine=%s, stack=%s, thread=%s%n", start_routine, stack, thread);
                }
                if (log.isTraceEnabled()) {
                    createBreaker(emulator).debug();
                }
                emulator.getThreadDispatcher().addThread(new BsdThread(emulator, threadId, thread_start, thread, start_routine, arg, stackSize));
            } else {
                log.info(msg);
            }
            return thread.peer;
        } else {
            throw new UnsupportedOperationException();
        }
    }
    protected int swtch_pri(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int pri = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("swtch_pri pri={}, LR={}", pri, context.getLRPointer());
        }
        if (log.isDebugEnabled() || LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        return 0;
    }
    protected String getKernelOsType() {
        return "Darwin";
    }
    protected String getKernelOsRelease() {
        return "14.0.0";
    }
    protected String getKernelVersion() {
        return String.format("%s Kernel Version %s: Sun Mar 29 19:47:37 PDT 2015; root:xnu-2784.20.34~2/RELEASE_ARM64_S5L8960X", getKernelOsType(), getKernelOsRelease());
    }
    protected String getBuildVersion() {
        return "9A127";
    }
    protected String getKernelHostName() {
        return "unidbg.local";
    }
}
package com.github.unidbg.spi;
import com.github.unidbg.Alignment;
import com.github.unidbg.Emulator;
import com.github.unidbg.LibraryResolver;
import com.github.unidbg.Module;
import com.github.unidbg.ModuleListener;
import com.github.unidbg.arm.ARM;
import com.github.unidbg.arm.ARMEmulator;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.hook.HookListener;
import com.github.unidbg.memory.MMapListener;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.MemoryMap;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.thread.BaseTask;
import com.github.unidbg.unix.UnixEmulator;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.sun.jna.Pointer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.ArmConst;
import java.io.DataOutput;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
public abstract class AbstractLoader<T extends NewFileIO> implements Memory, Loader {
    private static final Logger log = LoggerFactory.getLogger(AbstractLoader.class);
    protected final Backend backend;
    protected final Emulator<T> emulator;
    protected final UnixSyscallHandler<T> syscallHandler;
    protected long sp;
    protected long mmapBaseAddress;
    protected final Map<Long, MemoryMap> memoryMap = new TreeMap<>();
    protected Boolean[] threadStackMap = new Boolean[Memory.MAX_THREADS];
    protected MMapListener mMapListener;
    @Override
    public int allocateThreadIndex(){
        for(int i = 0; i<threadStackMap.length ;  i++){
            if(threadStackMap[i]==null || !threadStackMap[i]){
                threadStackMap[i] = true;
                return i;
            }
        }
        throw new UnsupportedOperationException("Threads is too much, max is = " + threadStackMap.length);
    }
    @Override
    public void freeThreadIndex(int index){
        if(index>=0) {
            threadStackMap[index] = false;
        }
    }
    @Override
    public UnidbgPointer allocateThreadStack(int index){
        if(!threadStackMap[index]) {
            throw new UnsupportedOperationException("Your ThreadStackIndex doesn't exist, it must come from allocateThreadIndex(), index = " + index);
        }
        long threadStackBase = Memory.STACK_BASE - (long) Memory.STACK_SIZE_OF_MAIN_PAGE * emulator.getPageAlign();
        long address = threadStackBase - (long) BaseTask.THREAD_STACK_PAGE * index * emulator.getPageAlign();
        if (log.isDebugEnabled()) {
            log.debug("allocateThreadStackAddress=0x{}", Long.toHexString(address));
        }
        return UnidbgPointer.pointer(emulator, address);
    }
    @Override
    public void setMMapListener(MMapListener listener) {
        this.mMapListener = listener;
    }
    protected void setMMapBaseAddress(long address) {
        this.mmapBaseAddress = address;
        if (log.isDebugEnabled()) {
            log.debug("setMMapBaseAddress=0x{}", Long.toHexString(address));
        }
    }
    public AbstractLoader(Emulator<T> emulator, UnixSyscallHandler<T> syscallHandler) {
        this.backend = emulator.getBackend();
        this.emulator = emulator;
        this.syscallHandler = syscallHandler;
        setMMapBaseAddress(MMAP_BASE);
    }
    @Override
    public Collection<MemoryMap> getMemoryMap() {
        return memoryMap.values();
    }
    @Override
    public final UnidbgPointer mmap(int length, int prot) {
        int aligned = (int) ARM.alignSize(length, emulator.getPageAlign());
        long addr = mmap2(0, aligned, prot, 0, -1, 0);
        UnidbgPointer pointer = UnidbgPointer.pointer(emulator, addr);
        assert pointer != null;
        return pointer.setSize(aligned);
    }
    protected final long allocateMapAddress(long mask, long length) {
        Map.Entry<Long, MemoryMap> lastEntry = null;
        for (Map.Entry<Long, MemoryMap> entry : memoryMap.entrySet()) {
            if (lastEntry == null) {
                lastEntry = entry;
            } else {
                MemoryMap map = lastEntry.getValue();
                long mmapAddress = map.base + map.size;
                if (mmapAddress + length < entry.getKey() && (mmapAddress & mask) == 0) {
                    return mmapAddress;
                } else {
                    lastEntry = entry;
                }
            }
        }
        if (lastEntry != null) {
            MemoryMap map = lastEntry.getValue();
            long mmapAddress = map.base + map.size;
            if (mmapAddress < mmapBaseAddress) {
                log.debug("allocateMapAddress mmapBaseAddress=0x{}, mmapAddress=0x{}", Long.toHexString(mmapBaseAddress), Long.toHexString(mmapAddress));
                setMMapBaseAddress(mmapAddress);
            }
        }
        long addr = mmapBaseAddress;
        while ((addr & mask) != 0) {
            addr += emulator.getPageAlign();
        }
        setMMapBaseAddress(addr + length);
        return addr;
    }
    @Override
    public final int munmap(long start, int length) {
        int aligned = (int) ARM.alignSize(length, emulator.getPageAlign());
        backend.mem_unmap(start, aligned);
        if (mMapListener != null) {
            mMapListener.onUnmap(start, aligned);
        }
        MemoryMap removed = memoryMap.remove(start);
        if (removed == null) {
            MemoryMap segment = findMemoryMap(start, aligned);
            if (start + aligned < segment.base + segment.size) {
                long newSize = segment.base + segment.size - start - aligned;
                if (log.isDebugEnabled()) {
                    log.debug("munmap aligned=0x{}, start=0x{}, base=0x{}, newSize={}", Long.toHexString(aligned), Long.toHexString(start), Long.toHexString(start + aligned), newSize);
                }
                if (memoryMap.put(start + aligned, new MemoryMap(start + aligned, (int) newSize, segment.prot)) != null) {
                    log.warn("munmap replace exists memory map addr=0x{}", Long.toHexString(start + aligned));
                }
            }
            if (memoryMap.put(segment.base, new MemoryMap(segment.base, (int) (start - segment.base), segment.prot)) == null) {
                log.warn("munmap replace failed warning: addr=0x{}", Long.toHexString(segment.base));
            }
            if (log.isDebugEnabled()) {
                log.debug("munmap aligned=0x{}, start=0x{}, base=0x{}, size={}", Long.toHexString(aligned), Long.toHexString(start), Long.toHexString(segment.base), start - segment.base);
            }
            return segment.prot;
        }
        if(removed.size != aligned) {
            if (aligned >= removed.size) {
                if (log.isDebugEnabled()) {
                    log.debug("munmap removed=0x{}, aligned=0x{}, start=0x{}", Long.toHexString(removed.size), Long.toHexString(aligned), Long.toHexString(start));
                }
                long address = start + removed.size;
                long size = aligned - removed.size;
                while (size != 0) {
                    MemoryMap remove = memoryMap.remove(address);
                    if (removed.prot != remove.prot) {
                        throw new IllegalStateException();
                    }
                    address += remove.size;
                    size -= remove.size;
                }
                return removed.prot;
            }
            if (memoryMap.put(start + aligned, new MemoryMap(start + aligned, removed.size - aligned, removed.prot)) != null) {
                log.warn("munmap not aligned replace exists memory map addr=0x{}", Long.toHexString(start + aligned));
            }
            if (log.isDebugEnabled()) {
                log.debug("munmap removed=0x{}, aligned=0x{}, base=0x{}, size={}", Long.toHexString(removed.size), Long.toHexString(aligned), Long.toHexString(start + aligned), removed.size - aligned);
            }
            return removed.prot;
        }
        if (log.isDebugEnabled()) {
            log.debug("munmap aligned=0x{}, start=0x{}, base=0x{}, size={}", Long.toHexString(aligned), Long.toHexString(start), Long.toHexString(removed.base), removed.size);
        }
        if (memoryMap.isEmpty()) {
            setMMapBaseAddress(MMAP_BASE);
        }
        return removed.prot;
    }
    private MemoryMap findMemoryMap(long start, int aligned) {
        MemoryMap segment = null;
        for (Map.Entry<Long, MemoryMap> entry : memoryMap.entrySet()) {
            MemoryMap map = entry.getValue();
            if (start > entry.getKey() && start < map.base + map.size) {
                segment = entry.getValue();
                break;
            }
        }
        if (segment == null || segment.size < aligned) {
            throw new IllegalStateException("munmap aligned=0x" + Long.toHexString(aligned) + ", start=0x" + Long.toHexString(start));
        }
        return segment;
    }
    @Override
    public final int mprotect(long address, int length, int prot) {
        if (address % ARMEmulator.PAGE_ALIGN != 0) {
            setErrno(UnixEmulator.EINVAL);
            return -1;
        }
        if (mMapListener != null) {
            prot = mMapListener.onProtect(address, length, prot);
        }
        backend.mem_protect(address, length, prot);
        MemoryMap map = memoryMap.get(address);
        if (map != null && map.size == length) {
            map.prot = prot;
        }
        return 0;
    }
    @Override
    public final Module load(File elfFile) {
        return load(elfFile,false);
    }
    @Override
    public final Module load(LibraryFile libraryFile) {
        return load(libraryFile, false);
    }
    @Override
    public final Module load(File elfFile, boolean forceCallInit) {
        return loadInternal(createLibraryFile(elfFile), forceCallInit);
    }
    protected abstract LibraryFile createLibraryFile(File file);
    @Override
    public final Module load(LibraryFile libraryFile, boolean forceCallInit) {
        return loadInternal(libraryFile, forceCallInit);
    }
    protected abstract Module loadInternal(LibraryFile libraryFile, boolean forceCallInit);
    protected boolean callInitFunction = true;
    @Override
    public final void disableCallInitFunction() {
        this.callInitFunction = false;
    }
    @Override
    public void setCallInitFunction(boolean callInit) {
        this.callInitFunction = callInit;
    }
    protected final List<HookListener> hookListeners = new ArrayList<>();
    @Override
    public final void addHookListener(HookListener listener) {
        hookListeners.add(listener);
    }
    protected LibraryResolver libraryResolver;
    @Override
    public void setLibraryResolver(LibraryResolver libraryResolver) {
        libraryResolver.onSetToLoader(emulator);
        this.libraryResolver = libraryResolver;
    }
    @Override
    public final UnidbgPointer allocateStack(int size) {
        long newAddr = sp - size;
        long threadStackBase = Memory.STACK_BASE - (long) Memory.STACK_SIZE_OF_MAIN_PAGE * emulator.getPageAlign();
        if(newAddr <= threadStackBase){
            throw new IllegalStateException("Error! main thread stack point too large. sp=0x" + Long.toHexString(sp) + ", threadStackBase=0x" + Long.toHexString(threadStackBase));
        }
        setStackPoint(newAddr);
        UnidbgPointer pointer = UnidbgPointer.pointer(emulator, sp);
        assert pointer != null;
        return pointer.setSize(size);
    }
    @Override
    public final UnidbgPointer writeStackString(String str) {
        byte[] data = str.getBytes(StandardCharsets.UTF_8);
        return writeStackBytes(Arrays.copyOf(data, data.length + 1));
    }
    @Override
    public final UnidbgPointer writeStackBytes(byte[] data) {
        int size = ARM.alignSize(data.length);
        UnidbgPointer pointer = allocateStack(size);
        assert pointer != null;
        pointer.write(0, data, 0, data.length);
        return pointer;
    }
    @Override
    public final UnidbgPointer pointer(long address) {
        return UnidbgPointer.pointer(emulator, address);
    }
    private long stackBase;
    protected int stackSize;
    @Override
    public long getStackBase() {
        return stackBase;
    }
    @Override
    public int getStackSize() {
        return stackSize;
    }
    @Override
    public final void setStackPoint(long sp) {
        if (this.sp == 0) {
            this.stackBase = sp;
        }
        this.sp = sp;
        if (emulator.is32Bit()) {
            backend.reg_write(ArmConst.UC_ARM_REG_SP, sp);
        } else {
            backend.reg_write(Arm64Const.UC_ARM64_REG_SP, sp);
        }
    }
    @Override
    public long getStackPoint() {
        return sp;
    }
    protected final List<ModuleListener> moduleListeners = new ArrayList<>();
    @Override
    public final void addModuleListener(ModuleListener listener) {
        moduleListeners.add(listener);
    }
    protected final void notifyModuleLoaded(Module module) {
        for (ModuleListener listener : moduleListeners) {
            listener.onLoaded(emulator, module);
        }
    }
    protected final void dump(Pointer pointer, long size, File outFile) throws IOException {
        try (OutputStream outputStream = Files.newOutputStream(outFile.toPath())) {
            int dump = 0;
            while (dump < size) {
                long read = size - dump;
                if (read > ARMEmulator.PAGE_ALIGN) {
                    read = ARMEmulator.PAGE_ALIGN;
                }
                byte[] data = pointer.getByteArray(dump, (int) read);
                outputStream.write(data);
                dump += (int) read;
            }
        }
    }
    protected final Alignment mem_map(long address, long size, int prot, String libraryName, long align) {
        Alignment alignment = ARM.align(address, size, align);
        if (log.isDebugEnabled()) {
            log.debug("[{}]0x{} - 0x{}, size=0x{}, prot={}", libraryName, Long.toHexString(alignment.address), Long.toHexString(alignment.address + alignment.size), Long.toHexString(alignment.size), prot);
        }
        backend.mem_map(alignment.address, alignment.size, prot);
        if (mMapListener != null) {
            mMapListener.onMap(alignment.address, alignment.size, prot);
        }
        if (memoryMap.put(alignment.address, new MemoryMap(alignment.address, (int) alignment.size, prot)) != null) {
            log.warn("mem_map replace exists memory map address={}", Long.toHexString(alignment.address));
        }
        return alignment;
    }
    @Override
    public final Module findModuleByAddress(long address) {
        for (Module module : getLoadedModules()) {
            long base = getModuleBase(module);
            if (address >= base && address < base + module.size) {
                return module;
            }
        }
        return null;
    }
    protected long getModuleBase(Module module) {
        return module.base;
    }
    @Override
    public final Module findModule(String name) {
        for (Module module : getLoadedModules()) {
            if (module.name.equals(name)) {
                return module;
            }
        }
        return null;
    }
    @Override
    public Module loadVirtualModule(String name, Map<String, UnidbgPointer> symbols) {
        throw new UnsupportedOperationException();
    }
    @Override
    public void serialize(DataOutput out) throws IOException {
        out.writeLong(sp);
        out.writeLong(mmapBaseAddress);
        out.writeLong(stackBase);
        out.writeLong(stackSize);
        out.writeInt(memoryMap.size());
        for (Map.Entry<Long, MemoryMap> entry : memoryMap.entrySet()) {
            MemoryMap map = entry.getValue();
            out.writeLong(entry.getKey());
            map.serialize(out);
            UnidbgPointer pointer = UnidbgPointer.pointer(emulator, map.base);
            assert pointer != null;
            byte[] data = pointer.getByteArray(0, (int) map.size);
            out.write(data);
        }
    }
}
package com.github.unidbg.linux.android;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Family;
import com.github.unidbg.arm.AbstractARMEmulator;
import com.github.unidbg.arm.backend.BackendFactory;
import com.github.unidbg.file.FileSystem;
import com.github.unidbg.file.linux.AndroidFileIO;
import com.github.unidbg.file.linux.LinuxFileSystem;
import com.github.unidbg.linux.ARM32SyscallHandler;
import com.github.unidbg.linux.AndroidElfLoader;
import com.github.unidbg.linux.android.dvm.DalvikVM;
import com.github.unidbg.linux.android.dvm.VM;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.spi.LibraryFile;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.unwind.Unwinder;
import java.io.File;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Collection;
public class AndroidARMEmulator extends AbstractARMEmulator<AndroidFileIO> implements AndroidEmulator {
    protected AndroidARMEmulator(String processName, File rootDir, Collection<BackendFactory> backendFactories) {
        super(processName, rootDir, Family.Android32, backendFactories);
    }
    @Override
    protected FileSystem<AndroidFileIO> createFileSystem(File rootDir) {
        return new LinuxFileSystem(this, rootDir);
    }
    @Override
    protected Memory createMemory(UnixSyscallHandler<AndroidFileIO> syscallHandler, String[] envs) {
        return new AndroidElfLoader(this, syscallHandler);
    }
    @Override
    protected Dlfcn createDyld(SvcMemory svcMemory) {
        return new ArmLD(backend, svcMemory);
    }
    @Override
    protected UnixSyscallHandler<AndroidFileIO> createSyscallHandler(SvcMemory svcMemory) {
        return new ARM32SyscallHandler(svcMemory);
    }
    private VM createDalvikVMInternal(File apkFile) {
        return new DalvikVM(this, apkFile);
    }
    @Override
    protected final void setupTraps() {
        super.setupTraps();
        int __kuser_memory_barrier = 0xe12fff1e; 
        memory.pointer(0xffff0fa0L).setInt(0, __kuser_memory_barrier);
        ByteBuffer buffer = ByteBuffer.allocate(32);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        buffer.putInt(0xf57ff05f); 
        buffer.putInt(0xe1923f9f); 
        buffer.putInt(0xe0533000); 
        buffer.putInt(0x01823f91); 
        buffer.putInt(0x03330001); 
        buffer.putInt(0x0afffffa); 
        buffer.putInt(0xe2730000); 
        buffer.putInt(0xeaffffef); 
        byte[] __kuser_cmpxchg = buffer.array();
        memory.pointer(0xffff0fc0L).write(__kuser_cmpxchg);
    }
    @Override
    public LibraryFile createURLibraryFile(URL url, String libName) {
        return new URLibraryFile(url, libName, -1, false);
    }
    @Override
    protected boolean isPaddingArgument() {
        return true;
    }
    private VM vm;
    @Override
    public VM createDalvikVM() {
        return createDalvikVM((File) null);
    }
    @Override
    public final VM createDalvikVM(File apkFile) {
        if (vm != null) {
            throw new IllegalStateException("vm is already created");
        }
        vm = createDalvikVMInternal(apkFile);
        return vm;
    }
    @Override
    public VM createDalvikVM(Class<?> callingClass) {
        return createDalvikVM(new File(callingClass.getProtectionDomain().getCodeSource().getLocation().getPath()));
    }
    @Override
    public final VM getDalvikVM() {
        return vm;
    }
    @Override
    public Unwinder getUnwinder() {
        return new AndroidARMUnwinder(this);
    }
}
package com.github.unidbg.arm;
import capstone.api.Disassembler;
import capstone.api.DisassemblerFactory;
import capstone.api.Instruction;
import com.alibaba.fastjson.util.IOUtils;
import com.github.unidbg.AbstractEmulator;
import com.github.unidbg.Family;
import com.github.unidbg.Module;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BackendFactory;
import com.github.unidbg.arm.backend.EventMemHook;
import com.github.unidbg.arm.backend.UnHook;
import com.github.unidbg.arm.context.BackendArm32RegisterContext;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.spi.SyscallHandler;
import com.github.unidbg.thread.Entry;
import com.github.unidbg.thread.Function32;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.unwind.SimpleARMUnwinder;
import com.github.unidbg.unwind.Unwinder;
import com.sun.jna.Pointer;
import keystone.Keystone;
import keystone.KeystoneArchitecture;
import keystone.KeystoneEncoded;
import keystone.KeystoneMode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.ArmConst;
import unicorn.UnicornConst;
import java.io.File;
import java.io.PrintStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
public abstract class AbstractARMEmulator<T extends NewFileIO> extends AbstractEmulator<T> implements ARMEmulator<T> {
    private static final Logger log = LoggerFactory.getLogger(AbstractARMEmulator.class);
    private static final long LR = 0xffff0000L;
    protected final Memory memory;
    private final UnixSyscallHandler<T> syscallHandler;
    private final Dlfcn dlfcn;
    public AbstractARMEmulator(String processName, File rootDir, Family family, Collection<BackendFactory> backendFactories, String... envs) {
        super(false, processName, 0xfffe0000L, 0x10000, rootDir, family, backendFactories);
        backend.switchUserMode();
        backend.hook_add_new(new EventMemHook() {
            @Override
            public boolean hook(Backend backend, long address, int size, long value, Object user, UnmappedType unmappedType) {
                RegisterContext context = getContext();
                log.warn("{} memory failed: address=0x{}, size={}, value=0x{}, PC={}, LR={}", unmappedType, Long.toHexString(address), size, Long.toHexString(value), context.getPCPointer(), context.getLRPointer());
                if (LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
                    attach().debug();
                }
                return false;
            }
            @Override
            public void onAttach(UnHook unHook) {
            }
            @Override
            public void detach() {
                throw new UnsupportedOperationException();
            }
        }, UnicornConst.UC_HOOK_MEM_READ_UNMAPPED | UnicornConst.UC_HOOK_MEM_WRITE_UNMAPPED | UnicornConst.UC_HOOK_MEM_FETCH_UNMAPPED, null);
        this.syscallHandler = createSyscallHandler(svcMemory);
        backend.enableVFP();
        this.memory = createMemory(syscallHandler, envs);
        this.dlfcn = createDyld(svcMemory);
        this.memory.addHookListener(dlfcn);
        backend.hook_add_new(syscallHandler, this);
        setupTraps();
    }
    private Disassembler armDisassemblerCache, thumbDisassemblerCache;
    private final Map<Long, Instruction[]> disassembleCache = new HashMap<>();
    private synchronized Disassembler createThumbCapstone() {
        if (thumbDisassemblerCache == null) {
            this.thumbDisassemblerCache = DisassemblerFactory.createArmDisassembler(true);
            this.thumbDisassemblerCache.setDetail(true);
        }
        return thumbDisassemblerCache;
    }
    private synchronized Disassembler createArmCapstone() {
        if (armDisassemblerCache == null) {
            this.armDisassemblerCache = DisassemblerFactory.createArmDisassembler(false);
            this.armDisassemblerCache.setDetail(true);
        }
        return armDisassemblerCache;
    }
    @Override
    protected RegisterContext createRegisterContext(Backend backend) {
        return new BackendArm32RegisterContext(backend, this);
    }
    @Override
    public Dlfcn getDlfcn() {
        return dlfcn;
    }
    protected void setupTraps() {
        int size = 0x10000;
        backend.mem_map(LR, size, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_EXEC);
        int code = ArmSvc.assembleSvc(0);
        ByteBuffer buffer = ByteBuffer.allocate(size);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        for (int i = 0; i < size; i += 4) {
            buffer.putInt(code); 
        }
        memory.pointer(LR).write(buffer.array());
    }
    @Override
    protected final byte[] assemble(Iterable<String> assembly) {
        try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.Arm)) {
            KeystoneEncoded encoded = keystone.assemble(assembly);
            return encoded.getMachineCode();
        }
    }
    @Override
    protected Debugger createConsoleDebugger() {
        return new SimpleARMDebugger(this) {
            @Override
            protected void dumpClass(String className) {
                AbstractARMEmulator.this.dumpClass(className);
            }
            @Override
            protected void searchClass(String keywords) {
                AbstractARMEmulator.this.searchClass(keywords);
            }
        };
    }
    @Override
    protected void closeInternal() {
        syscallHandler.destroy();
        IOUtils.close(thumbDisassemblerCache);
        IOUtils.close(armDisassemblerCache);
        disassembleCache.clear();
    }
    @Override
    public Module loadLibrary(File libraryFile) {
        return memory.load(libraryFile);
    }
    @Override
    public Module loadLibrary(File libraryFile, boolean forceCallInit) {
        return memory.load(libraryFile, forceCallInit);
    }
    @Override
    public Memory getMemory() {
        return memory;
    }
    @Override
    public SyscallHandler<T> getSyscallHandler() {
        return syscallHandler;
    }
    @Override
    public final void showRegs() {
        this.showRegs((int[]) null);
    }
    @Override
    public final void showRegs(int... regs) {
        ARM.showRegs(this, regs);
    }
    @Override
    public Instruction[] printAssemble(PrintStream out, long address, int size, int maxLengthLibraryName, InstructionVisitor visitor) {
        Instruction[] insns = disassembleCache.get(address);
        byte[] currentCode = backend.mem_read(address, size);
        boolean needUpdateCache = false;
        if (insns != null) {
            byte[] cachedCode = new byte[size];
            int offset = 0;
            for (Instruction insn : insns) {
                byte[] insnBytes = insn.getBytes();
                System.arraycopy(insnBytes, 0, cachedCode, offset, insnBytes.length);
                offset += insnBytes.length;
            }
            if (!Arrays.equals(currentCode, cachedCode)) {
                needUpdateCache = true;
            }
        } else {
            needUpdateCache = true;
        }
        if (needUpdateCache) {
            insns = disassemble(address, size,  0);
            disassembleCache.put(address, insns);
        }
        printAssemble(out, insns, address, ARM.isThumb(backend), maxLengthLibraryName, visitor);
        return insns;
    }
    @Override
    public Instruction[] disassemble(long address, int size, long count) {
        boolean thumb = ARM.isThumb(backend);
        byte[] code = backend.mem_read(address, size);
        return thumb ? createThumbCapstone().disasm(code, address, count) : createArmCapstone().disasm(code, address, count);
    }
    @Override
    public Instruction[] disassemble(long address, byte[] code, boolean thumb, long count) {
        return thumb ? createThumbCapstone().disasm(code, address, count) : createArmCapstone().disasm(code, address, count);
    }
    private void printAssemble(PrintStream out, Instruction[] insns, long address, boolean thumb, int maxLengthLibraryName, InstructionVisitor visitor) {
        StringBuilder builder = new StringBuilder();
        for (Instruction ins : insns) {
            if(visitor != null) {
                visitor.visitLast(builder);
            }
            builder.append('\n');
            builder.append(dateFormat.format(new Date()));
            builder.append(ARM.assembleDetail(this, ins, address, thumb, maxLengthLibraryName));
            if (visitor != null) {
                visitor.visit(builder, ins);
            }
            address += ins.getSize();
        }
        out.print(builder);
    }
    @Override
    public Number eFunc(long begin, Number... arguments) {
        return runMainForResult(new Function32(getPid(), begin, LR, isPaddingArgument(), arguments));
    }
    @Override
    public Number eEntry(long begin, long sp) {
        return runMainForResult(new Entry(getPid(), begin, LR, sp));
    }
    @Override
    public int getPointerSize() {
        return 4;
    }
    @Override
    protected int getPageAlignInternal() {
        return PAGE_ALIGN;
    }
    @Override
    public Pointer getStackPointer() {
        return UnidbgPointer.register(this, ArmConst.UC_ARM_REG_SP);
    }
    @Override
    public Unwinder getUnwinder() {
        return new SimpleARMUnwinder(this);
    }
    @Override
    public long getReturnAddress() {
        return LR;
    }
}
package com.github.unidbg.file;
import com.github.unidbg.Emulator;
import com.github.unidbg.arm.backend.Backend;
import com.sun.jna.Pointer;
import java.io.IOException;
public interface FileIO {
    int SEEK_SET = 0;
    int SEEK_CUR = 1;
    int SEEK_END = 2;
    void close();
    int write(byte[] data);
    int read(Backend backend, Pointer buffer, int count);
    int pread(Backend backend, Pointer buffer, int count, long offset);
    int fcntl(Emulator<?> emulator, int cmd, long arg);
    int ioctl(Emulator<?> emulator, long request, long argp);
    FileIO dup2();
    int connect(Pointer addr, int addrlen);
    int bind(Pointer addr, int addrlen);
    int listen(int backlog);
    int setsockopt(int level, int optname, Pointer optval, int optlen);
    int sendto(byte[] data, int flags, Pointer dest_addr, int addrlen);
    int lseek(int offset, int whence);
    int ftruncate(int length);
    int getpeername(Pointer addr, Pointer addrlen);
    int shutdown(int how);
    int getsockopt(int level, int optname, Pointer optval, Pointer optlen);
    int getsockname(Pointer addr, Pointer addrlen);
    long mmap2(Emulator<?> emulator, long addr, int aligned, int prot, int offset, int length) throws IOException;
    int llseek(long offset, Pointer result, int whence);
    int recvfrom(Backend backend, Pointer buf, int len, int flags, Pointer src_addr, Pointer addrlen);
    String getPath();
    boolean isStdIO();
}
package com.github.unidbg.ios;
import com.github.unidbg.Family;
import com.github.unidbg.arm.AbstractARM64Emulator;
import com.github.unidbg.arm.backend.BackendException;
import com.github.unidbg.arm.backend.BackendFactory;
import com.github.unidbg.file.FileSystem;
import com.github.unidbg.file.ios.DarwinFileIO;
import com.github.unidbg.file.ios.DarwinFileSystem;
import com.github.unidbg.ios.classdump.ClassDumper;
import com.github.unidbg.ios.classdump.IClassDumper;
import com.github.unidbg.ios.gpb.GPBDescriptor;
import com.github.unidbg.ios.objc.ObjC;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.spi.LibraryFile;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.sun.jna.Pointer;
import unicorn.UnicornConst;
import java.io.File;
import java.net.URL;
import java.util.Collection;
public class DarwinARM64Emulator extends AbstractARM64Emulator<DarwinFileIO> {
    protected DarwinARM64Emulator(String processName, File rootDir, Collection<BackendFactory> backendFactories, String... envs) {
        super(processName, rootDir, Family.iOS, backendFactories, envs);
    }
    @Override
    protected FileSystem<DarwinFileIO> createFileSystem(File rootDir) {
        return new DarwinFileSystem(this, rootDir);
    }
    protected void setupTraps() {
        super.setupTraps();
        try {
            int size = 0x10000;
            backend.mem_map(MachO._KERNEL_BASE64, size, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_EXEC);
            long _COMM_PAGE_MEMORY_SIZE = (MachO._COMM_PAGE64_BASE_ADDRESS+0x038);	
            Pointer commPageMemorySize = UnidbgPointer.pointer(this, _COMM_PAGE_MEMORY_SIZE);
            if (commPageMemorySize != null) {
                commPageMemorySize.setLong(0, 0);
            }
            long _COMM_PAGE_NCPUS = (MachO._COMM_PAGE64_BASE_ADDRESS+0x022);	
            Pointer commPageNCpus = UnidbgPointer.pointer(this, _COMM_PAGE_NCPUS);
            if (commPageNCpus != null) {
                commPageNCpus.setByte(0, (byte) 1);
            }
            long _COMM_PAGE_ACTIVE_CPUS = (MachO._COMM_PAGE64_BASE_ADDRESS+0x034);	
            Pointer commPageActiveCpus = UnidbgPointer.pointer(this, _COMM_PAGE_ACTIVE_CPUS);
            if (commPageActiveCpus != null) {
                commPageActiveCpus.setByte(0, (byte) 1);
            }
            long _COMM_PAGE_PHYSICAL_CPUS = (MachO._COMM_PAGE64_BASE_ADDRESS+0x035);	
            Pointer commPagePhysicalCpus = UnidbgPointer.pointer(this, _COMM_PAGE_PHYSICAL_CPUS);
            if (commPagePhysicalCpus != null) {
                commPagePhysicalCpus.setByte(0, (byte) 1);
            }
            long _COMM_PAGE_LOGICAL_CPUS = (MachO._COMM_PAGE64_BASE_ADDRESS+0x036);	
            Pointer commPageLogicalCpus = UnidbgPointer.pointer(this, _COMM_PAGE_LOGICAL_CPUS);
            if (commPageLogicalCpus != null) {
                commPageLogicalCpus.setByte(0, (byte) 1);
            }
        } catch(BackendException ignored) { 
        }
    }
    @Override
    protected Memory createMemory(UnixSyscallHandler<DarwinFileIO> syscallHandler, String[] envs) {
        return new MachOLoader(this, syscallHandler, envs);
    }
    @Override
    protected Dlfcn createDyld(SvcMemory svcMemory) {
        return new Dyld64((MachOLoader) memory, svcMemory);
    }
    @Override
    protected UnixSyscallHandler<DarwinFileIO> createSyscallHandler(SvcMemory svcMemory) {
        return new ARM64SyscallHandler(svcMemory);
    }
    @Override
    public LibraryFile createURLibraryFile(URL url, String libName) {
        return new URLibraryFile(url, "/vendor/lib/" + libName, null);
    }
    @Override
    protected int getPageAlignInternal() {
        return 0x4000;
    }
    @Override
    protected boolean isPaddingArgument() {
        return false;
    }
    @Override
    protected void dumpClass(String className) {
        IClassDumper classDumper = ClassDumper.getInstance(this);
        String classData = classDumper.dumpClass(className);
        System.out.println("dumpClass\n" + classData);
    }
    @Override
    protected void searchClass(String keywords) {
        IClassDumper classDumper = ClassDumper.getInstance(this);
        classDumper.searchClass(keywords);
    }
    @Override
    protected void dumpGPBProtobufMsg(String className) {
        System.out.println(GPBDescriptor.toProtobufDef(this, ObjC.getInstance(this), className));
    }
}
package com.github.unidbg.arm;
import capstone.api.Disassembler;
import capstone.api.DisassemblerFactory;
import capstone.api.Instruction;
import com.alibaba.fastjson.util.IOUtils;
import com.github.unidbg.AbstractEmulator;
import com.github.unidbg.Family;
import com.github.unidbg.Module;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BackendFactory;
import com.github.unidbg.arm.backend.EventMemHook;
import com.github.unidbg.arm.backend.UnHook;
import com.github.unidbg.arm.context.BackendArm64RegisterContext;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.debugger.Debugger;
import com.github.unidbg.file.NewFileIO;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.spi.SyscallHandler;
import com.github.unidbg.thread.Entry;
import com.github.unidbg.thread.Function64;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.unwind.SimpleARM64Unwinder;
import com.github.unidbg.unwind.Unwinder;
import com.sun.jna.Pointer;
import keystone.Keystone;
import keystone.KeystoneArchitecture;
import keystone.KeystoneEncoded;
import keystone.KeystoneMode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.UnicornConst;
import java.io.File;
import java.io.PrintStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
public abstract class AbstractARM64Emulator<T extends NewFileIO> extends AbstractEmulator<T> implements ARMEmulator<T> {
    private static final Logger log = LoggerFactory.getLogger(AbstractARM64Emulator.class);
    protected final Memory memory;
    private final UnixSyscallHandler<T> syscallHandler;
    private static final long LR = 0x7ffff0000L;
    private final Dlfcn dlfcn;
    public AbstractARM64Emulator(String processName, File rootDir, Family family, Collection<BackendFactory> backendFactories, String... envs) {
        super(true, processName, 0xfffe0000L, 0x10000, rootDir, family, backendFactories);
        backend.switchUserMode();
        backend.hook_add_new(new EventMemHook() {
            @Override
            public boolean hook(Backend backend, long address, int size, long value, Object user, UnmappedType unmappedType) {
                log.warn("{} memory failed: address=0x{}, size={}, value=0x{}", unmappedType, Long.toHexString(address), size, Long.toHexString(value));
                if (LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
                    attach().debug();
                }
                return false;
            }
            @Override
            public void onAttach(UnHook unHook) {
            }
            @Override
            public void detach() {
                throw new UnsupportedOperationException();
            }
        }, UnicornConst.UC_HOOK_MEM_READ_UNMAPPED | UnicornConst.UC_HOOK_MEM_WRITE_UNMAPPED | UnicornConst.UC_HOOK_MEM_FETCH_UNMAPPED, null);
        this.syscallHandler = createSyscallHandler(svcMemory);
        backend.enableVFP();
        this.memory = createMemory(syscallHandler, envs);
        this.dlfcn = createDyld(svcMemory);
        this.memory.addHookListener(dlfcn);
        backend.hook_add_new(syscallHandler, this);
        setupTraps();
    }
    private Disassembler arm64DisassemblerCache;
    private final Map<Long, Instruction[]> disassembleCache = new HashMap<>();
    private synchronized Disassembler createArm64Disassembler() {
        if (arm64DisassemblerCache == null) {
            this.arm64DisassemblerCache = DisassemblerFactory.createArm64Disassembler();
            this.arm64DisassemblerCache.setDetail(true);
        }
        return arm64DisassemblerCache;
    }
    protected void setupTraps() {
        int size = getPageAlign();
        backend.mem_map(LR, size, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_EXEC);
        ByteBuffer buffer = ByteBuffer.allocate(size);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        int code = Arm64Svc.assembleSvc(0);
        for (int i = 0; i < size; i += 4) {
            buffer.putInt(code); 
        }
        memory.pointer(LR).write(buffer.array());
    }
    @Override
    protected RegisterContext createRegisterContext(Backend backend) {
        return new BackendArm64RegisterContext(backend, this);
    }
    @Override
    public Dlfcn getDlfcn() {
        return dlfcn;
    }
    @Override
    protected final byte[] assemble(Iterable<String> assembly) {
        try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian)) {
            KeystoneEncoded encoded = keystone.assemble(assembly);
            return encoded.getMachineCode();
        }
    }
    @Override
    protected Debugger createConsoleDebugger() {
        return new SimpleARM64Debugger(this) {
            @Override
            protected void dumpClass(String className) {
                AbstractARM64Emulator.this.dumpClass(className);
            }
            @Override
            protected void searchClass(String keywords) {
                AbstractARM64Emulator.this.searchClass(keywords);
            }
            @Override
            protected void dumpGPBProtobufMsg(String className) {
                AbstractARM64Emulator.this.dumpGPBProtobufMsg(className);
            }
        };
    }
    @Override
    protected void closeInternal() {
        syscallHandler.destroy();
        IOUtils.close(arm64DisassemblerCache);
        disassembleCache.clear();
    }
    @Override
    public Module loadLibrary(File libraryFile) {
        return memory.load(libraryFile);
    }
    @Override
    public Module loadLibrary(File libraryFile, boolean forceCallInit) {
        return memory.load(libraryFile, forceCallInit);
    }
    @Override
    public Memory getMemory() {
        return memory;
    }
    @Override
    public SyscallHandler<T> getSyscallHandler() {
        return syscallHandler;
    }
    @Override
    public final void showRegs() {
        this.showRegs((int[]) null);
    }
    @Override
    public final void showRegs(int... regs) {
        ARM.showRegs64(this, regs);
    }
    @Override
    public Instruction[] printAssemble(PrintStream out, long address, int size, int maxLengthLibraryName, InstructionVisitor visitor) {
        Instruction[] insns = disassembleCache.get(address);
        byte[] currentCode = backend.mem_read(address, size);
        boolean needUpdateCache = false;
        if (insns != null) {
            byte[] cachedCode = new byte[size];
            int offset = 0;
            for (Instruction insn : insns) {
                byte[] insnBytes = insn.getBytes();
                System.arraycopy(insnBytes, 0, cachedCode, offset, insnBytes.length);
                offset += insnBytes.length;
            }
            if (!Arrays.equals(currentCode, cachedCode)) {
                needUpdateCache = true;
            }
        } else {
            needUpdateCache = true;
        }
        if (needUpdateCache) {
            insns = disassemble(address, currentCode, false, 0);
            disassembleCache.put(address, insns);
        }
        printAssemble(out, insns, address, maxLengthLibraryName, visitor);
        return insns;
    }
    @Override
    public Instruction[] disassemble(long address, int size, long count) {
        byte[] code = backend.mem_read(address, size);
        return createArm64Disassembler().disasm(code, address, count);
    }
    @Override
    public Instruction[] disassemble(long address, byte[] code, boolean thumb, long count) {
        if (thumb) {
            throw new IllegalStateException();
        }
        return createArm64Disassembler().disasm(code, address, count);
    }
    private void printAssemble(PrintStream out, Instruction[] insns, long address, int maxLengthLibraryName, InstructionVisitor visitor) {
        StringBuilder builder = new StringBuilder();
        for (Instruction ins : insns) {
            if(visitor != null) {
                visitor.visitLast(builder);
            }
            builder.append('\n');
            builder.append(dateFormat.format(new Date()));
            builder.append(ARM.assembleDetail(this, ins, address, false, maxLengthLibraryName));
            if (visitor != null) {
                visitor.visit(builder, ins);
            }
            address += ins.getSize();
        }
        out.print(builder);
    }
    @Override
    public int getPointerSize() {
        return 8;
    }
    @Override
    protected int getPageAlignInternal() {
        return PAGE_ALIGN;
    }
    @Override
    public Number eFunc(long begin, Number... arguments) {
        return runMainForResult(new Function64(getPid(), begin, LR, isPaddingArgument(), arguments));
    }
    @Override
    public Number eEntry(long begin, long sp) {
        return runMainForResult(new Entry(getPid(), begin, LR, sp));
    }
    @Override
    public Pointer getStackPointer() {
        return UnidbgPointer.register(this, Arm64Const.UC_ARM64_REG_SP);
    }
    @Override
    public Unwinder getUnwinder() {
        return new SimpleARM64Unwinder(this);
    }
    @Override
    public long getReturnAddress() {
        return LR;
    }
}
package com.github.unidbg.file;
import com.github.unidbg.Emulator;
public interface IOResolver<T extends NewFileIO> {
    FileResult<T> resolve(Emulator<T> emulator, String pathname, int oflags);
}
package com.github.unidbg.linux;
import com.github.unidbg.Alignment;
import com.github.unidbg.Emulator;
import com.github.unidbg.LibraryResolver;
import com.github.unidbg.Module;
import com.github.unidbg.Symbol;
import com.github.unidbg.arm.ARM;
import com.github.unidbg.arm.ARMEmulator;
import com.github.unidbg.file.FileIO;
import com.github.unidbg.file.linux.AndroidFileIO;
import com.github.unidbg.file.linux.IOConstants;
import com.github.unidbg.hook.HookListener;
import com.github.unidbg.linux.android.ElfLibraryFile;
import com.github.unidbg.linux.thread.PThreadInternal;
import com.github.unidbg.memory.MemRegion;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.MemoryAllocBlock;
import com.github.unidbg.memory.MemoryBlock;
import com.github.unidbg.memory.MemoryBlockImpl;
import com.github.unidbg.memory.MemoryMap;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.AbstractLoader;
import com.github.unidbg.spi.InitFunction;
import com.github.unidbg.spi.LibraryFile;
import com.github.unidbg.spi.Loader;
import com.github.unidbg.thread.Task;
import com.github.unidbg.unix.IO;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.virtualmodule.VirtualSymbol;
import com.sun.jna.Pointer;
import net.fornwall.jelf.ArmExIdx;
import net.fornwall.jelf.ElfDynamicStructure;
import net.fornwall.jelf.ElfException;
import net.fornwall.jelf.ElfFile;
import net.fornwall.jelf.ElfRelocation;
import net.fornwall.jelf.ElfSection;
import net.fornwall.jelf.ElfSegment;
import net.fornwall.jelf.ElfSymbol;
import net.fornwall.jelf.GnuEhFrameHeader;
import net.fornwall.jelf.MemoizedObject;
import net.fornwall.jelf.PtLoadData;
import net.fornwall.jelf.SymbolLocator;
import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import unicorn.ArmConst;
import unicorn.Unicorn;
import unicorn.UnicornConst;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
public class AndroidElfLoader extends AbstractLoader<AndroidFileIO> implements Memory, Loader {
    private static final Logger log = LoggerFactory.getLogger(AndroidElfLoader.class);
    private Symbol malloc, free;
    public AndroidElfLoader(Emulator<AndroidFileIO> emulator, UnixSyscallHandler<AndroidFileIO> syscallHandler) {
        super(emulator, syscallHandler);
        stackSize = STACK_SIZE_OF_PAGE * emulator.getPageAlign();
        backend.mem_map(STACK_BASE - stackSize, stackSize, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE);
        setStackPoint(STACK_BASE);
        this.environ = initializeTLS(new String[] {
                "ANDROID_DATA=/data",
                "ANDROID_ROOT=/system",
                "PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin",
                "NO_ADDR_COMPAT_LAYOUT_FIXUP=1"
        });
        this.setErrno(0);
    }
    @Override
    public void setLibraryResolver(LibraryResolver libraryResolver) {
        super.setLibraryResolver(libraryResolver);
        syscallHandler.open(emulator, IO.STDIN, IOConstants.O_RDONLY);
        syscallHandler.open(emulator, IO.STDOUT, IOConstants.O_WRONLY);
        syscallHandler.open(emulator, IO.STDERR, IOConstants.O_WRONLY);
    }
    @Override
    protected LibraryFile createLibraryFile(File file) {
        return new ElfLibraryFile(file, emulator.is64Bit());
    }
    private UnidbgPointer initializeTLS(String[] envs) {
        final Pointer thread = allocateStack(0x400); 
        PThreadInternal pThread = PThreadInternal.create(emulator, thread);
        pThread.tid = emulator.getPid();
        pThread.pack();
        final Pointer __stack_chk_guard = allocateStack(emulator.getPointerSize());
        final Pointer programName = writeStackString(emulator.getProcessName());
        final Pointer programNamePointer = allocateStack(emulator.getPointerSize());
        assert programNamePointer != null;
        programNamePointer.setPointer(0, programName);
        final Pointer auxv = allocateStack(0x100);
        assert auxv != null;
        final int AT_RANDOM = 25; 
        auxv.setPointer(0, UnidbgPointer.pointer(emulator, AT_RANDOM));
        auxv.setPointer(emulator.getPointerSize(), __stack_chk_guard);
        final int AT_PAGESZ = 6;
        auxv.setPointer(emulator.getPointerSize() * 2L, UnidbgPointer.pointer(emulator, AT_PAGESZ));
        auxv.setPointer(emulator.getPointerSize() * 3L, UnidbgPointer.pointer(emulator, emulator.getPageAlign()));
        List<String> envList = new ArrayList<>();
        for (String env : envs) {
            int index = env.indexOf('=');
            if (index != -1) {
                envList.add(env);
            }
        }
        final Pointer environ = allocateStack(emulator.getPointerSize() * (envList.size() + 1));
        assert environ != null;
        Pointer pointer = environ;
        for (String env : envList) {
            Pointer envPointer = writeStackString(env);
            pointer.setPointer(0, envPointer);
            pointer = pointer.share(emulator.getPointerSize());
        }
        pointer.setPointer(0, null);
        final UnidbgPointer argv = allocateStack(0x100);
        assert argv != null;
        argv.setPointer(emulator.getPointerSize(), programNamePointer);
        argv.setPointer(2L * emulator.getPointerSize(), environ);
        argv.setPointer(3L * emulator.getPointerSize(), auxv);
        final UnidbgPointer tls = allocateStack(0x80 * 4); 
        assert tls != null;
        tls.setPointer(emulator.getPointerSize(), thread);
        this.errno = tls.share(emulator.getPointerSize() * 2L);
        tls.setPointer(emulator.getPointerSize() * 3L, argv);
        if (emulator.is32Bit()) {
            backend.reg_write(ArmConst.UC_ARM_REG_C13_C0_3, tls.peer);
        } else {
            backend.reg_write(Arm64Const.UC_ARM64_REG_TPIDR_EL0, tls.peer);
        }
        long sp = getStackPoint();
        sp &= (~(emulator.is64Bit() ? 15 : 7));
        setStackPoint(sp);
        if (log.isDebugEnabled()) {
            log.debug("initializeTLS tls={}, argv={}, auxv={}, thread={}, environ={}, sp=0x{}", tls, argv, auxv, thread, environ, Long.toHexString(getStackPoint()));
        }
        return argv.share(2L * emulator.getPointerSize(), 0);
    }
    private final Map<String, LinuxModule> modules = new LinkedHashMap<>();
    protected final LinuxModule loadInternal(LibraryFile libraryFile, boolean forceCallInit) {
        try {
            LinuxModule module = loadInternal(libraryFile);
            resolveSymbols(!forceCallInit);
            if (callInitFunction || forceCallInit) {
                for (LinuxModule m : modules.values().toArray(new LinuxModule[0])) {
                    boolean forceCall = (forceCallInit && m == module) || m.isForceCallInit();
                    if (callInitFunction) {
                        m.callInitFunction(emulator, forceCall);
                    } else if (forceCall) {
                        m.callInitFunction(emulator, true);
                    }
                    m.initFunctionList.clear();
                }
            }
            module.addReferenceCount();
            return module;
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }
    private void resolveSymbols(boolean showWarning) throws IOException {
        Collection<LinuxModule> linuxModules = modules.values();
        for (LinuxModule m : linuxModules) {
            for (Iterator<ModuleSymbol> iterator = m.getUnresolvedSymbol().iterator(); iterator.hasNext(); ) {
                ModuleSymbol moduleSymbol = iterator.next();
                ModuleSymbol resolved = moduleSymbol.resolve(new HashSet<>(linuxModules), true, hookListeners, emulator.getSvcMemory());
                if (resolved != null) {
                    log.debug("resolveSymbols[{}]{} symbol resolved to {}", moduleSymbol.soName, moduleSymbol.symbol.getName(), resolved.toSoName);
                    resolved.relocation(emulator, m);
                    iterator.remove();
                } else if(showWarning) {
                    log.info("[{}]symbol {} is missing relocationAddr={}, offset=0x{}", moduleSymbol.soName, moduleSymbol.symbol, moduleSymbol.relocationAddr, Long.toHexString(moduleSymbol.offset));
                }
            }
        }
    }
    @Override
    public Module dlopen(String filename, boolean calInit) {
        LinuxModule loaded = modules.get(FilenameUtils.getName(filename));
        if (loaded != null) {
            loaded.addReferenceCount();
            return loaded;
        }
        for (Module module : getLoadedModules()) {
            for (MemRegion memRegion : module.getRegions()) {
                if (filename.equals(memRegion.getName())) {
                    module.addReferenceCount();
                    return module;
                }
            }
        }
        LibraryFile file = libraryResolver == null ? null : libraryResolver.resolveLibrary(emulator, filename);
        if (file == null) {
            return null;
        }
        if (calInit) {
            return loadInternal(file, false);
        }
        try {
            LinuxModule module = loadInternal(file);
            resolveSymbols(false);
            if (!callInitFunction) { 
                for (LinuxModule m : modules.values()) {
                    m.initFunctionList.clear();
                }
            }
            module.addReferenceCount();
            return module;
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }
    @Override
    public Module dlopen(String filename) {
        return dlopen(filename, true);
    }
    private final UnidbgPointer environ;
    private static final int RTLD_DEFAULT = -1;
    @Override
    public Symbol dlsym(long handle, String symbolName) {
        if ("environ".equals(symbolName)) {
            return new VirtualSymbol(symbolName, null, environ.toUIntPeer());
        }
        Module sm = null;
        Symbol ret = null;
        for (LinuxModule module : modules.values()) {
            if (module.base == handle) { 
                Symbol symbol = module.findSymbolByName(symbolName, false);
                if (symbol != null) {
                    ret = symbol;
                    sm = module;
                    break;
                }
            }
        }
        if (ret == null && ((int) handle == RTLD_DEFAULT || handle == 0L)) {
            for (Module module : modules.values()) {
                Symbol symbol = module.findSymbolByName(symbolName, false);
                if (symbol != null) {
                    ret = symbol;
                    sm = module;
                    break;
                }
            }
        }
        for (HookListener listener : hookListeners) {
            long hook = listener.hook(emulator.getSvcMemory(), sm == null ? null : sm.name, symbolName, ret == null ? 0L : ret.getAddress());
            if (hook != 0) {
                return new VirtualSymbol(symbolName, null, hook);
            }
        }
        return ret;
    }
    @Override
    public boolean dlclose(long handle) {
        for (Iterator<Map.Entry<String, LinuxModule>> iterator = modules.entrySet().iterator(); iterator.hasNext(); ) {
            LinuxModule module = iterator.next().getValue();
            if (module.base == handle) {
                if (module.decrementReferenceCount() <= 0) {
                    module.unload(backend);
                    iterator.remove();
                }
                return true;
            }
        }
        return false;
    }
    private LinuxModule loadInternal(LibraryFile libraryFile) throws IOException {
        final ElfFile elfFile = ElfFile.fromBuffer(libraryFile.mapBuffer());
        if (emulator.is32Bit() && elfFile.objectSize != ElfFile.CLASS_32) {
            throw new ElfException("Must be 32-bit");
        }
        if (emulator.is64Bit() && elfFile.objectSize != ElfFile.CLASS_64) {
            throw new ElfException("Must be 64-bit");
        }
        if (elfFile.encoding != ElfFile.DATA_LSB) {
            throw new ElfException("Must be LSB");
        }
        if (emulator.is32Bit() && elfFile.arch != ElfFile.ARCH_ARM) {
            throw new ElfException("Must be ARM arch.");
        }
        if (emulator.is64Bit() && elfFile.arch != ElfFile.ARCH_AARCH64) {
            throw new ElfException("Must be ARM64 arch.");
        }
        long start = System.currentTimeMillis();
        long bound_high = 0;
        long align = 0;
        for (int i = 0; i < elfFile.num_ph; i++) {
            ElfSegment ph = elfFile.getProgramHeader(i);
            if (ph.type == ElfSegment.PT_LOAD && ph.mem_size > 0) {
                long high = ph.virtual_address + ph.mem_size;
                if (bound_high < high) {
                    bound_high = high;
                }
                if (ph.alignment > align) {
                    align = ph.alignment;
                }
            }
        }
        ElfDynamicStructure dynamicStructure = null;
        final long baseAlign = Math.max(emulator.getPageAlign(), align);
        final long load_base = ((mmapBaseAddress - 1) / baseAlign + 1) * baseAlign;
        long load_virtual_address = 0;
        long size = ARM.align(0, bound_high, baseAlign).size;
        setMMapBaseAddress(load_base + size);
        final List<MemRegion> regions = new ArrayList<>(5);
        MemoizedObject<ArmExIdx> armExIdx = null;
        MemoizedObject<GnuEhFrameHeader> ehFrameHeader = null;
        Alignment lastAlignment = null;
        for (int i = 0; i < elfFile.num_ph; i++) {
            ElfSegment ph = elfFile.getProgramHeader(i);
            switch (ph.type) {
                case ElfSegment.PT_LOAD:
                    int prot = get_segment_protection(ph.flags);
                    if (prot == UnicornConst.UC_PROT_NONE) {
                        prot = UnicornConst.UC_PROT_ALL;
                    }
                    final long begin = load_base + ph.virtual_address;
                    if (load_virtual_address == 0) {
                        load_virtual_address = begin;
                    }
                    Alignment check = ARM.align(begin, ph.mem_size, Math.max(emulator.getPageAlign(), ph.alignment));
                    final int regionSize = regions.size();
                    MemRegion last = regionSize == 0 ? null : regions.get(regionSize - 1);
                    MemRegion overall = null;
                    if (last != null && check.address >= last.begin && check.address < last.end) {
                        overall = last;
                    }
                    if (overall != null) {
                        long overallSize = overall.end - check.address;
                        int perms = overall.perms | prot;
                        if (mMapListener != null) {
                            perms = mMapListener.onProtect(check.address, overallSize, perms);
                        }
                        backend.mem_protect(check.address, overallSize, perms);
                        if (ph.mem_size > overallSize) {
                            Alignment alignment = this.mem_map(begin + overallSize, ph.mem_size - overallSize, prot, libraryFile.getName(), Math.max(emulator.getPageAlign(), ph.alignment));
                            regions.add(new MemRegion(begin, alignment.address, alignment.address + alignment.size, prot, libraryFile, ph.virtual_address));
                            if (lastAlignment != null && lastAlignment.begin + lastAlignment.dataSize > begin) {
                                throw new UnsupportedOperationException();
                            }
                            lastAlignment = alignment;
                            lastAlignment.begin = begin;
                        }
                    } else {
                        Alignment alignment = this.mem_map(begin, ph.mem_size, prot, libraryFile.getName(), Math.max(emulator.getPageAlign(), ph.alignment));
                        regions.add(new MemRegion(begin, alignment.address, alignment.address + alignment.size, prot, libraryFile, ph.virtual_address));
                        if (lastAlignment != null) {
                            long base = lastAlignment.address + lastAlignment.size;
                            long off = alignment.address - base;
                            if (off < 0) {
                                throw new IllegalStateException();
                            }
                            if (off > 0) {
                                backend.mem_map(base, off, UnicornConst.UC_PROT_NONE);
                                if (mMapListener != null) {
                                    mMapListener.onMap(base, off, UnicornConst.UC_PROT_NONE);
                                }
                                if (memoryMap.put(base, new MemoryMap(base, (int) off, UnicornConst.UC_PROT_NONE)) != null) {
                                    log.warn("mem_map replace exists memory map base={}", Long.toHexString(base));
                                }
                            }
                        }
                        lastAlignment = alignment;
                        lastAlignment.begin = begin;
                    }
                    PtLoadData loadData = ph.getPtLoadData();
                    loadData.writeTo(pointer(begin));
                    if (lastAlignment != null) {
                        lastAlignment.dataSize = loadData.getDataSize();
                    }
                    break;
                case ElfSegment.PT_DYNAMIC:
                    dynamicStructure = ph.getDynamicStructure();
                    break;
                case ElfSegment.PT_INTERP:
                    if (log.isDebugEnabled()) {
                        log.debug("[{}]interp={}", libraryFile.getName(), ph.getInterpreter());
                    }
                    break;
                case ElfSegment.PT_GNU_EH_FRAME:
                    ehFrameHeader = ph.getEhFrameHeader();
                    break;
                case ElfSegment.PT_ARM_EXIDX:
                    armExIdx = ph.getARMExIdxData();
                    break;
                default:
                    if (log.isDebugEnabled()) {
                        log.debug("[{}]segment type=0x{}, offset=0x{}", libraryFile.getName(), Integer.toHexString(ph.type), Long.toHexString(ph.offset));
                    }
                    break;
            }
        }
        if (dynamicStructure == null) {
            throw new IllegalStateException("dynamicStructure is empty.");
        }
        final String soName = dynamicStructure.getSOName(libraryFile.getName());
        Map<String, Module> neededLibraries = new HashMap<>();
        for (String neededLibrary : dynamicStructure.getNeededLibraries()) {
            if (log.isDebugEnabled()) {
                log.debug("{} need dependency {}", soName, neededLibrary);
            }
            LinuxModule loaded = modules.get(neededLibrary);
            if (loaded != null) {
                loaded.addReferenceCount();
                neededLibraries.put(FilenameUtils.getBaseName(loaded.name), loaded);
                continue;
            }
            LibraryFile neededLibraryFile = libraryFile.resolveLibrary(emulator, neededLibrary);
            if (libraryResolver != null && neededLibraryFile == null) {
                neededLibraryFile = libraryResolver.resolveLibrary(emulator, neededLibrary);
            }
            if (neededLibraryFile != null) {
                LinuxModule needed = loadInternal(neededLibraryFile);
                needed.addReferenceCount();
                neededLibraries.put(FilenameUtils.getBaseName(needed.name), needed);
            } else {
                log.info("{} load dependency {} failed", soName, neededLibrary);
            }
        }
        for (LinuxModule module : modules.values()) {
            for (Iterator<ModuleSymbol> iterator = module.getUnresolvedSymbol().iterator(); iterator.hasNext(); ) {
                ModuleSymbol moduleSymbol = iterator.next();
                ModuleSymbol resolved = moduleSymbol.resolve(module.getNeededLibraries(), false, hookListeners, emulator.getSvcMemory());
                if (resolved != null) {
                    if (log.isDebugEnabled()) {
                        log.debug("[{}]{} symbol resolved to {}", moduleSymbol.soName, moduleSymbol.symbol.getName(), resolved.toSoName);
                    }
                    resolved.relocation(emulator, module);
                    iterator.remove();
                }
            }
        }
        List<ModuleSymbol> list = new ArrayList<>();
        List<ModuleSymbol> resolvedSymbols = new ArrayList<>();
        for (MemoizedObject<ElfRelocation> object : dynamicStructure.getRelocations()) {
            ElfRelocation relocation = object.getValue();
            final int type = relocation.type();
            if (type == 0) {
                log.warn("Unhandled relocation type {}", type);
                continue;
            }
            ElfSymbol symbol = relocation.sym() == 0 ? null : relocation.symbol();
            long sym_value = symbol != null ? symbol.value : 0;
            Pointer relocationAddr = UnidbgPointer.pointer(emulator, load_base + relocation.offset());
            assert relocationAddr != null;
            Logger log = LoggerFactory.getLogger("com.github.unidbg.linux." + soName);
            if (log.isDebugEnabled()) {
                log.debug("symbol={}, type={}, relocationAddr={}, offset=0x{}, addend={}, sym={}, android={}", symbol, type, relocationAddr, Long.toHexString(relocation.offset()), relocation.addend(), relocation.sym(), relocation.isAndroid());
            }
            ModuleSymbol moduleSymbol;
            switch (type) {
                case ARMEmulator.R_ARM_ABS32: {
                    int offset = relocationAddr.getInt(0);
                    moduleSymbol = resolveSymbol(load_base, symbol, relocationAddr, soName, neededLibraries.values(), offset);
                    if (moduleSymbol == null) {
                        list.add(new ModuleSymbol(soName, load_base, symbol, relocationAddr, null, offset));
                    } else {
                        resolvedSymbols.add(moduleSymbol);
                    }
                    break;
                }
                case ARMEmulator.R_AARCH64_ABS64: {
                    long offset = relocationAddr.getLong(0) + relocation.addend();
                    moduleSymbol = resolveSymbol(load_base, symbol, relocationAddr, soName, neededLibraries.values(), offset);
                    if (moduleSymbol == null) {
                        list.add(new ModuleSymbol(soName, load_base, symbol, relocationAddr, null, offset));
                    } else {
                        resolvedSymbols.add(moduleSymbol);
                    }
                    break;
                }
                case ARMEmulator.R_ARM_RELATIVE: {
                    int offset = relocationAddr.getInt(0);
                    if (sym_value == 0) {
                        relocationAddr.setInt(0, (int) load_base + offset);
                    } else {
                        throw new IllegalStateException("sym_value=0x" + Long.toHexString(sym_value));
                    }
                    break;
                }
                case ARMEmulator.R_AARCH64_RELATIVE:
                    if (sym_value == 0) {
                        relocationAddr.setLong(0, load_base + relocation.addend());
                    } else {
                        throw new IllegalStateException("sym_value=0x" + Long.toHexString(sym_value));
                    }
                    break;
                case ARMEmulator.R_ARM_GLOB_DAT:
                case ARMEmulator.R_ARM_JUMP_SLOT:
                    moduleSymbol = resolveSymbol(load_base, symbol, relocationAddr, soName, neededLibraries.values(), 0);
                    if (moduleSymbol == null) {
                        list.add(new ModuleSymbol(soName, load_base, symbol, relocationAddr, null, 0));
                    } else {
                        resolvedSymbols.add(moduleSymbol);
                    }
                    break;
                case ARMEmulator.R_AARCH64_GLOB_DAT:
                case ARMEmulator.R_AARCH64_JUMP_SLOT:
                    moduleSymbol = resolveSymbol(load_base, symbol, relocationAddr, soName, neededLibraries.values(), relocation.addend());
                    if (moduleSymbol == null) {
                        list.add(new ModuleSymbol(soName, load_base, symbol, relocationAddr, null, relocation.addend()));
                    } else {
                        resolvedSymbols.add(moduleSymbol);
                    }
                    break;
                case ARMEmulator.R_ARM_COPY:
                    throw new IllegalStateException("R_ARM_COPY relocations are not supported");
                case ARMEmulator.R_AARCH64_COPY:
                    throw new IllegalStateException("R_AARCH64_COPY relocations are not supported");
                case ARMEmulator.R_AARCH64_ABS32:
                case ARMEmulator.R_AARCH64_ABS16:
                case ARMEmulator.R_AARCH64_PREL64:
                case ARMEmulator.R_AARCH64_PREL32:
                case ARMEmulator.R_AARCH64_PREL16:
                case ARMEmulator.R_AARCH64_IRELATIVE:
                case ARMEmulator.R_AARCH64_TLS_TPREL64:
                case ARMEmulator.R_AARCH64_TLS_DTPREL32:
                case ARMEmulator.R_ARM_IRELATIVE:
                case ARMEmulator.R_ARM_REL32:
                default:
                    log.warn("[" + soName + "]Unhandled relocation type " + type + ", symbol=" + symbol + ", relocationAddr=" + relocationAddr + ", offset=0x" + Long.toHexString(relocation.offset()) + ", addend=" + relocation.addend() + ", android=" + relocation.isAndroid());
                    break;
            }
        }
        List<InitFunction> initFunctionList = new ArrayList<>();
        int preInitArraySize = dynamicStructure.getPreInitArraySize();
        boolean executable = elfFile.file_type == ElfFile.FT_EXEC || preInitArraySize > 0;
        if (executable) {
            int count = preInitArraySize / emulator.getPointerSize();
            if (count > 0) {
                UnidbgPointer pointer = UnidbgPointer.pointer(emulator, load_base + dynamicStructure.getPreInitArrayOffset());
                if (pointer == null) {
                    throw new IllegalStateException("DT_PREINIT_ARRAY is null");
                }
                for (int i = 0; i < count; i++) {
                    UnidbgPointer ptr = pointer.share((long) i * emulator.getPointerSize(), 0);
                    initFunctionList.add(new AbsoluteInitFunction(load_base, soName, ptr));
                }
            }
        }
        if (elfFile.file_type == ElfFile.FT_DYN) { 
            int init = dynamicStructure.getInit();
            if (init != 0) {
                initFunctionList.add(new LinuxInitFunction(load_base, soName, init));
            }
            int initArraySize = dynamicStructure.getInitArraySize();
            int count = initArraySize / emulator.getPointerSize();
            if (count > 0) {
                UnidbgPointer pointer = UnidbgPointer.pointer(emulator, load_base + dynamicStructure.getInitArrayOffset());
                if (pointer == null) {
                    throw new IllegalStateException("DT_INIT_ARRAY is null");
                }
                for (int i = 0; i < count; i++) {
                    UnidbgPointer ptr = pointer.share((long) i * emulator.getPointerSize(), 0);
                    initFunctionList.add(new AbsoluteInitFunction(load_base, soName, ptr));
                }
            }
        }
        SymbolLocator dynsym = dynamicStructure.getSymbolStructure();
        if (dynsym == null) {
            throw new IllegalStateException("dynsym is null");
        }
        ElfSection symbolTableSection = null;
        try {
            symbolTableSection = elfFile.getSymbolTableSection();
        } catch(Throwable ignored) {}
        if (load_virtual_address == 0) {
            throw new IllegalStateException("load_virtual_address");
        }
        LinuxModule module = new LinuxModule(load_virtual_address, load_base, size, soName, dynsym, list, initFunctionList, neededLibraries, regions,
                armExIdx, ehFrameHeader, symbolTableSection, elfFile, dynamicStructure, libraryFile);
        for (ModuleSymbol symbol : resolvedSymbols) {
            symbol.relocation(emulator, module);
        }
        if (executable) {
            for (LinuxModule linuxModule : modules.values()) {
                for (Map.Entry<String, ModuleSymbol> entry : linuxModule.resolvedSymbols.entrySet()) {
                    ElfSymbol symbol = module.getELFSymbolByName(entry.getKey());
                    if (symbol != null && !symbol.isUndef()) {
                        entry.getValue().relocation(emulator, module, symbol);
                    }
                }
                linuxModule.resolvedSymbols.clear();
            }
        }
        if ("libc.so".equals(soName)) { 
            malloc = module.findSymbolByName("malloc", false);
            free = module.findSymbolByName("free", false);
        }
        modules.put(soName, module);
        if (maxSoName == null || soName.length() > maxSoName.length()) {
            maxSoName = soName;
        }
        if (bound_high > maxSizeOfSo) {
            maxSizeOfSo = bound_high;
        }
        module.setEntryPoint(elfFile.entry_point);
        log.debug("Load library {} offset={}ms, entry_point=0x{}", soName, System.currentTimeMillis() - start, Long.toHexString(elfFile.entry_point));
        notifyModuleLoaded(module);
        return module;
    }
    @Override
    public Module loadVirtualModule(String name, Map<String, UnidbgPointer> symbols) {
        LinuxModule module = LinuxModule.createVirtualModule(name, symbols, emulator);
        modules.put(name, module);
        if (maxSoName == null || name.length() > maxSoName.length()) {
            maxSoName = name;
        }
        return module;
    }
    private String maxSoName;
    private long maxSizeOfSo;
    private ModuleSymbol resolveSymbol(long load_base, ElfSymbol symbol, Pointer relocationAddr, String soName, Collection<Module> neededLibraries, long offset) throws IOException {
        if (symbol == null) {
            return new ModuleSymbol(soName, load_base, null, relocationAddr, soName, offset);
        }
        if (!symbol.isUndef()) {
            for (HookListener listener : hookListeners) {
                long hook = listener.hook(emulator.getSvcMemory(), soName, symbol.getName(), load_base + symbol.value + offset);
                if (hook > 0) {
                    return new ModuleSymbol(soName, ModuleSymbol.WEAK_BASE, symbol, relocationAddr, soName, hook);
                }
            }
            return new ModuleSymbol(soName, load_base, symbol, relocationAddr, soName, offset);
        }
        return new ModuleSymbol(soName, load_base, symbol, relocationAddr, null, offset).resolve(neededLibraries, false, hookListeners, emulator.getSvcMemory());
    }
    private int get_segment_protection(int flags) {
        int prot = Unicorn.UC_PROT_NONE;
        if ((flags & ElfSegment.PF_R) != 0) prot |= Unicorn.UC_PROT_READ;
        if ((flags & ElfSegment.PF_W) != 0) prot |= Unicorn.UC_PROT_WRITE;
        if ((flags & ElfSegment.PF_X) != 0) prot |= Unicorn.UC_PROT_EXEC;
        return prot;
    }
    @Override
    public MemoryBlock malloc(int length, boolean runtime) {
        if (runtime) {
            return MemoryBlockImpl.alloc(this, length);
        } else {
            return MemoryAllocBlock.malloc(emulator, malloc, free, length);
        }
    }
    private static final long HEAP_BASE = 0x8048000;
    private long brk;
    @Override
    public int brk(long address) {
        if (address == 0) {
            this.brk = HEAP_BASE;
            return (int) this.brk;
        }
        if (address % emulator.getPageAlign() != 0) {
            throw new UnsupportedOperationException();
        }
        if (address > brk) {
            backend.mem_map(brk, address - brk, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE);
            if (mMapListener != null) {
                mMapListener.onMap(brk, address - brk, UnicornConst.UC_PROT_READ | UnicornConst.UC_PROT_WRITE);
            }
            this.brk = address;
        } else if(address < brk) {
            backend.mem_unmap(address, brk - address);
            if (mMapListener != null) {
                mMapListener.onUnmap(address, brk - address);
            }
            this.brk = address;
        }
        return (int) this.brk;
    }
    private static final int MAP_FAILED = -1;
    public static final int MAP_FIXED = 0x10;
    public static final int MAP_ANONYMOUS = 0x20;
    @Override
    public long mmap2(long start, int length, int prot, int flags, int fd, int offset) {
        int aligned = (int) ARM.alignSize(length, emulator.getPageAlign());
        boolean isAnonymous = ((flags & MAP_ANONYMOUS) != 0) || (start == 0 && fd <= 0 && offset == 0);
        if ((flags & MAP_FIXED) != 0 && isAnonymous) {
            if (log.isDebugEnabled()) {
                log.debug("mmap2 MAP_FIXED start=0x{}, length={}, prot={}", Long.toHexString(start), length, prot);
            }
            munmap(start, length);
            backend.mem_map(start, aligned, prot);
            if (mMapListener != null) {
                mMapListener.onMap(start, aligned, prot);
            }
            if (memoryMap.put(start, new MemoryMap(start, aligned, prot)) != null) {
                log.warn("mmap2 replace exists memory map: start={}", Long.toHexString(start));
            }
            return start;
        }
        if (isAnonymous) {
            long addr = allocateMapAddress(0, aligned);
            if (log.isDebugEnabled()) {
                log.debug("mmap2 addr=0x{}, mmapBaseAddress=0x{}, start={}, fd={}, offset={}, aligned={}, LR={}", Long.toHexString(addr), Long.toHexString(mmapBaseAddress), start, fd, offset, aligned, emulator.getContext().getLRPointer());
            }
            backend.mem_map(addr, aligned, prot);
            if (mMapListener != null) {
                mMapListener.onMap(start, aligned, prot);
            }
            if (memoryMap.put(addr, new MemoryMap(addr, aligned, prot)) != null) {
                log.warn("memoryMap mmap2 replace exists memory map addr={}", Long.toHexString(addr));
            }
            return addr;
        }
        try {
            FileIO file;
            if (start == 0 && fd > 0 && (file = syscallHandler.getFileIO(fd)) != null) {
                long addr = allocateMapAddress(0, aligned);
                if (log.isDebugEnabled()) {
                    log.debug("mmap2 addr=0x{}, mmapBaseAddress=0x{}", Long.toHexString(addr), Long.toHexString(mmapBaseAddress));
                }
                long ret = file.mmap2(emulator, addr, aligned, prot, offset, length);
                if (mMapListener != null) {
                    mMapListener.onMap(addr, aligned, prot);
                }
                if (memoryMap.put(addr, new MemoryMap(addr, aligned, prot)) != null) {
                    log.warn("mmap2 replace exists memory map addr=0x{}", Long.toHexString(addr));
                }
                return ret;
            }
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
        try {
            FileIO file;
            if (fd > 0 && (file = syscallHandler.getFileIO(fd)) != null) {
                if ((start & (emulator.getPageAlign() - 1)) != 0) {
                    return MAP_FAILED;
                }
                long end = start + length;
                for (Map.Entry<Long, MemoryMap> entry : memoryMap.entrySet()) {
                    MemoryMap map = entry.getValue();
                    if (Math.max(start, entry.getKey()) <= Math.min(map.base + map.size, end)) {
                        return MAP_FAILED;
                    }
                }
                if (log.isDebugEnabled()) {
                    log.debug("mmap2 start=0x{}, mmapBaseAddress=0x{}, flags=0x{}, length=0x{}", Long.toHexString(start), Long.toHexString(mmapBaseAddress), Integer.toHexString(flags), Integer.toHexString(length));
                }
                long ret = file.mmap2(emulator, start, aligned, prot, offset, length);
                if (mMapListener != null) {
                    mMapListener.onMap(start, aligned, prot);
                }
                if (memoryMap.put(start, new MemoryMap(start, aligned, prot)) != null) {
                    log.warn("mmap2 replace exists memory map start=0x{}", Long.toHexString(start));
                }
                return ret;
            }
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
        emulator.attach().debug();
        throw new AbstractMethodError("mmap2 start=0x" + Long.toHexString(start) + ", length=" + length + ", prot=0x" + Integer.toHexString(prot) + ", flags=0x" + Integer.toHexString(flags) + ", fd=" + fd + ", offset=" + offset);
    }
    private Pointer errno;
    private int lastErrno;
    @Override
    public int getLastErrno() {
        return lastErrno;
    }
    @Override
    public void setErrno(int errno) {
        this.lastErrno = errno;
        Task task = emulator.get(Task.TASK_KEY);
        if (task != null && task.setErrno(emulator, errno)) {
            return;
        }
        this.errno.setInt(0, errno);
    }
    @Override
    public String getMaxLengthLibraryName() {
        return maxSoName;
    }
    @Override
    public long getMaxSizeOfLibrary() {
        return maxSizeOfSo;
    }
    @Override
    public Collection<Module> getLoadedModules() {
        return new ArrayList<>(modules.values());
    }
}
package com.github.unidbg;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.memory.MemRegion;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.InitFunctionListener;
import com.github.unidbg.spi.LibraryFile;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
public abstract class Module {
    public final String name;
    public final long base;
    public final long size;
    private final LibraryFile libraryFile;
    protected final Map<String, Module> neededLibraries;
    private final List<MemRegion> regions;
    public Module(String name, long base, long size, Map<String, Module> neededLibraries, List<MemRegion> regions, LibraryFile libraryFile) {
        this.name = name;
        this.base = base;
        this.size = size;
        this.neededLibraries = neededLibraries;
        this.regions = regions;
        this.libraryFile = libraryFile;
    }
    public long getFileSize() {
        return libraryFile == null ? 0 : libraryFile.getFileSize();
    }
    public long getBaseHeader() {
        return base;
    }
    public final List<MemRegion> getRegions() {
        return Collections.unmodifiableList(regions);
    }
    public abstract Number callFunction(Emulator<?> emulator, long offset, Object... args);
    public final Number callFunction(Emulator<?> emulator, String symbolName, Object... args) {
        Symbol symbol = findSymbolByName(symbolName, false);
        if (symbol == null) {
            throw new IllegalStateException("find symbol failed: " + symbolName);
        }
        if (symbol.isUndef()) {
            throw new IllegalStateException(symbolName + " is NOT defined");
        }
        return symbol.call(emulator, args);
    }
    public final Symbol findSymbolByName(String name) {
        return findSymbolByName(name, true);
    }
    public abstract Symbol findSymbolByName(String name, boolean withDependencies);
    public abstract Symbol findClosestSymbolByAddress(long address, boolean fast);
    protected final Symbol findDependencySymbolByName(String name) {
        for (Module module : neededLibraries.values()) {
            Symbol symbol = module.findSymbolByName(name, true);
            if (symbol != null) {
                return symbol;
            }
        }
        return null;
    }
    private int referenceCount;
    public void addReferenceCount() {
        referenceCount++;
    }
    public int decrementReferenceCount() {
        return --referenceCount;
    }
    private boolean forceCallInit;
    public boolean isForceCallInit() {
        return forceCallInit;
    }
    @SuppressWarnings("unused")
    public void setForceCallInit() {
        this.forceCallInit = true;
    }
    public final void unload(Backend backend) {
        for (MemRegion region : regions) {
            backend.mem_unmap(region.begin, region.end - region.begin);
        }
    }
    public Collection<Module> getNeededLibraries() {
        return neededLibraries.values();
    }
    public Module getDependencyModule(String name) {
        return neededLibraries.get(name);
    }
    protected long entryPoint;
    public void setEntryPoint(long entryPoint) {
        this.entryPoint = entryPoint;
    }
    public abstract int callEntry(Emulator<?> emulator, String... args);
    private UnidbgPointer pathPointer;
    public abstract String getPath();
    public abstract void registerSymbol(String symbolName, long address);
    public final UnidbgPointer createPathMemory(SvcMemory svcMemory) {
        if (this.pathPointer == null) {
            byte[] bytes = getPath().getBytes(StandardCharsets.UTF_8);
            byte[] path = Arrays.copyOf(bytes, bytes.length + 1);
            this.pathPointer = svcMemory.allocate(path.length, "Module.path: " + getPath());
            this.pathPointer.write(0, path, 0, path.length);
        }
        return this.pathPointer;
    }
    public static Number emulateFunction(Emulator<?> emulator, long address, Object... args) {
        List<Number> list = new ArrayList<>(args.length);
        for (Object arg : args) {
            if (arg instanceof String) {
                list.add(new StringNumber((String) arg));
            } else if(arg instanceof byte[]) {
                list.add(new ByteArrayNumber((byte[]) arg));
            } else if (arg instanceof PointerArg) {
                PointerArg pointerArg = (PointerArg) arg;
                list.add(new PointerNumber((UnidbgPointer) pointerArg.getPointer()));
            } else if (arg instanceof Number) {
                list.add((Number) arg);
            } else if(arg == null) {
                list.add(new PointerNumber(null)); 
            } else {
                throw new IllegalStateException("Unsupported arg: " + arg);
            }
        }
        return emulator.eFunc(address, list.toArray(new Number[0]));
    }
    public boolean isVirtual() {
        return false;
    }
    public abstract int virtualMemoryAddressToFileOffset(long offset);
    protected InitFunctionListener initFunctionListener;
    public void setInitFunctionListener(InitFunctionListener initFunctionListener) {
        this.initFunctionListener = initFunctionListener;
    }
}
package com.github.unidbg.memory;
import com.github.unidbg.Emulator;
import com.github.unidbg.spi.LibraryFile;
import java.io.IOException;
import java.nio.ByteBuffer;
public class MemRegion implements Comparable<MemRegion> {
    public final long virtualAddress;
    public final long begin;
    public final long end;
    public final int perms;
    private final LibraryFile libraryFile;
    public final long offset;
    public static MemRegion create(long begin, int size, int perms, final String name) {
        return new MemRegion(begin, begin, begin + size, perms, new LibraryFile() {
            @Override
            public String getName() {
                return name;
            }
            @Override
            public String getMapRegionName() {
                return name;
            }
            @Override
            public LibraryFile resolveLibrary(Emulator<?> emulator, String soName) {
                throw new UnsupportedOperationException();
            }
            @Override
            public ByteBuffer mapBuffer() {
                throw new UnsupportedOperationException();
            }
            @Override
            public String getPath() {
                return name;
            }
            @Override
            public long getFileSize() {
                throw new UnsupportedOperationException();
            }
        }, 0);
    }
    public MemRegion(long virtualAddress, long begin, long end, int perms, LibraryFile libraryFile, long offset) {
        this.virtualAddress = virtualAddress;
        this.begin = begin;
        this.end = end;
        this.perms = perms;
        this.libraryFile = libraryFile;
        this.offset = offset;
    }
    public String getName() {
        return libraryFile.getMapRegionName();
    }
    public byte[] readLibrary() throws IOException {
        ByteBuffer buffer = libraryFile.mapBuffer();
        byte[] data = new byte[buffer.remaining()];
        buffer.get(data);
        return data;
    }
    @Override
    public int compareTo(MemRegion o) {
        return Long.compare(begin, o.begin);
    }
}
package com.github.unidbg.ios;
import com.github.unidbg.Family;
import com.github.unidbg.arm.AbstractARMEmulator;
import com.github.unidbg.arm.backend.BackendFactory;
import com.github.unidbg.file.FileSystem;
import com.github.unidbg.file.ios.DarwinFileIO;
import com.github.unidbg.file.ios.DarwinFileSystem;
import com.github.unidbg.ios.classdump.ClassDumper;
import com.github.unidbg.ios.classdump.IClassDumper;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.spi.LibraryFile;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.sun.jna.Pointer;
import java.io.File;
import java.net.URL;
import java.util.Collection;
public class DarwinARMEmulator extends AbstractARMEmulator<DarwinFileIO> {
    protected DarwinARMEmulator(String processName, File rootDir, Collection<BackendFactory> backendFactories, String... envs) {
        super(processName, rootDir, Family.iOS, backendFactories, envs);
    }
    @Override
    protected FileSystem<DarwinFileIO> createFileSystem(File rootDir) {
        return new DarwinFileSystem(this, rootDir);
    }
    @Override
    protected void setupTraps() {
        super.setupTraps();
        long _COMM_PAGE_MEMORY_SIZE = (MachO._COMM_PAGE32_BASE_ADDRESS+0x038);	
        Pointer commPageMemorySize = UnidbgPointer.pointer(this, _COMM_PAGE_MEMORY_SIZE);
        if (commPageMemorySize != null) {
            commPageMemorySize.setLong(0, 0);
        }
        long _COMM_PAGE_NCPUS = (MachO._COMM_PAGE32_BASE_ADDRESS+0x022);	
        Pointer commPageNCpus = UnidbgPointer.pointer(this, _COMM_PAGE_NCPUS);
        if (commPageNCpus != null) {
            commPageNCpus.setByte(0, (byte) 1);
        }
        long _COMM_PAGE_ACTIVE_CPUS = (MachO._COMM_PAGE32_BASE_ADDRESS+0x034);	
        Pointer commPageActiveCpus = UnidbgPointer.pointer(this, _COMM_PAGE_ACTIVE_CPUS);
        if (commPageActiveCpus != null) {
            commPageActiveCpus.setByte(0, (byte) 1);
        }
        long _COMM_PAGE_PHYSICAL_CPUS = (MachO._COMM_PAGE32_BASE_ADDRESS+0x035);	
        Pointer commPagePhysicalCpus = UnidbgPointer.pointer(this, _COMM_PAGE_PHYSICAL_CPUS);
        if (commPagePhysicalCpus != null) {
            commPagePhysicalCpus.setByte(0, (byte) 1);
        }
        long _COMM_PAGE_LOGICAL_CPUS = (MachO._COMM_PAGE32_BASE_ADDRESS+0x036);	
        Pointer commPageLogicalCpus = UnidbgPointer.pointer(this, _COMM_PAGE_LOGICAL_CPUS);
        if (commPageLogicalCpus != null) {
            commPageLogicalCpus.setByte(0, (byte) 1);
        }
    }
    @Override
    protected Memory createMemory(UnixSyscallHandler<DarwinFileIO> syscallHandler, String[] envs) {
        return new MachOLoader(this, syscallHandler, envs);
    }
    @Override
    protected Dlfcn createDyld(SvcMemory svcMemory) {
        return new Dyld32((MachOLoader) memory, svcMemory);
    }
    @Override
    protected UnixSyscallHandler<DarwinFileIO> createSyscallHandler(SvcMemory svcMemory) {
        return new ARM32SyscallHandler(svcMemory);
    }
    @Override
    public LibraryFile createURLibraryFile(URL url, String libName) {
        return new URLibraryFile(url, "/vendor/lib/" + libName, null);
    }
    @Override
    protected boolean isPaddingArgument() {
        return false;
    }
    @Override
    protected void dumpClass(String className) {
        IClassDumper classDumper = ClassDumper.getInstance(this);
        String classData = classDumper.dumpClass(className);
        System.out.println("dumpClass\n" + classData);
    }
    @Override
    protected void searchClass(String keywords) {
        IClassDumper classDumper = ClassDumper.getInstance(this);
        classDumper.searchClass(keywords);
    }
}
package com.github.unidbg.linux;
import com.github.unidbg.AbstractEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.LongJumpException;
import com.github.unidbg.StopEmulatorException;
import com.github.unidbg.Svc;
import com.github.unidbg.arm.ARM;
import com.github.unidbg.arm.ARMEmulator;
import com.github.unidbg.arm.Arm64Svc;
import com.github.unidbg.arm.backend.Backend;
import com.github.unidbg.arm.backend.BackendException;
import com.github.unidbg.arm.context.Arm64RegisterContext;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.file.FileIO;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.IOResolver;
import com.github.unidbg.file.linux.AndroidFileIO;
import com.github.unidbg.file.linux.IOConstants;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.file.ByteArrayFileIO;
import com.github.unidbg.linux.file.DriverFileIO;
import com.github.unidbg.linux.file.LocalAndroidUdpSocket;
import com.github.unidbg.linux.file.LocalSocketIO;
import com.github.unidbg.linux.file.NetLinkSocket;
import com.github.unidbg.linux.file.PipedSocketIO;
import com.github.unidbg.linux.file.SocketIO;
import com.github.unidbg.linux.file.TcpSocket;
import com.github.unidbg.linux.file.UdpSocket;
import com.github.unidbg.linux.struct.RLimit64;
import com.github.unidbg.linux.struct.Stat64;
import com.github.unidbg.linux.thread.MarshmallowThread;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.thread.PopContextException;
import com.github.unidbg.thread.Task;
import com.github.unidbg.thread.ThreadContextSwitchException;
import com.github.unidbg.unix.IO;
import com.github.unidbg.unix.UnixEmulator;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import unicorn.Arm64Const;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
public class ARM64SyscallHandler extends AndroidSyscallHandler {
    private static final Logger log = LoggerFactory.getLogger(ARM64SyscallHandler.class);
    private final SvcMemory svcMemory;
    public ARM64SyscallHandler(SvcMemory svcMemory) {
        super();
        this.svcMemory = svcMemory;
    }
    @SuppressWarnings("unchecked")
    @Override
    public void hook(Backend backend, int intno, int swi, Object user) {
        Emulator<AndroidFileIO> emulator = (Emulator<AndroidFileIO>) user;
        UnidbgPointer pc = UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_PC);
        if (intno == ARMEmulator.EXCP_BKPT) { 
            createBreaker(emulator).brk(pc, pc == null ? swi : (pc.getInt(0) >> 5) & 0xffff);
            return;
        }
        if (intno == ARMEmulator.EXCP_UDEF) {
            createBreaker(emulator).debug();
            return;
        }
        if (intno != ARMEmulator.EXCP_SWI) {
            throw new BackendException("intno=" + intno);
        }
        int NR = backend.reg_read(Arm64Const.UC_ARM64_REG_X8).intValue();
        String syscall = null;
        Throwable exception = null;
        try {
            if (swi == 0 && NR == 0 && backend.reg_read(Arm64Const.UC_ARM64_REG_X16).intValue() == Svc.POST_CALLBACK_SYSCALL_NUMBER) { 
                int number = backend.reg_read(Arm64Const.UC_ARM64_REG_X12).intValue();
                Svc svc = svcMemory.getSvc(number);
                if (svc != null) {
                    svc.handlePostCallback(emulator);
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (swi == 0 && NR == 0 && backend.reg_read(Arm64Const.UC_ARM64_REG_X16).intValue() == Svc.PRE_CALLBACK_SYSCALL_NUMBER) { 
                int number = backend.reg_read(Arm64Const.UC_ARM64_REG_X12).intValue();
                Svc svc = svcMemory.getSvc(number);
                if (svc != null) {
                    svc.handlePreCallback(emulator);
                    return;
                }
                backend.emu_stop();
                throw new IllegalStateException("svc number: " + swi);
            }
            if (swi != 0) {
                if (swi == Arm64Svc.SVC_MAX) {
                    throw new PopContextException();
                }
                if (swi == Arm64Svc.SVC_MAX - 1) {
                    throw new ThreadContextSwitchException();
                }
                Svc svc = svcMemory.getSvc(swi);
                if (svc != null) {
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, svc.handle(emulator));
                    return;
                }
                backend.emu_stop();
                throw new BackendException("svc number: " + swi);
            }
            if (log.isTraceEnabled()) {
                ARM.showRegs64(emulator, null);
            }
            if (handleSyscall(emulator, NR)) {
                return;
            }
            switch (NR) {
                case 17:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getcwd(emulator));
                    return;
                case 19:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, eventfd2(emulator));
                    return;
                case 64:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, write(emulator));
                    return;
                case 221:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, execve(emulator));
                    return;
                case 62:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, lseek(emulator));
                    return;
                case 172: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, emulator.getPid());
                    return;
                case 178: 
                    Task task = emulator.get(Task.TASK_KEY);
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, task == null ? 0 : task.getId());
                    return;
                case 129:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, kill(emulator));
                    return;
                case 29:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, ioctl(emulator));
                    return;
                case 34:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mkdirat(emulator));
                    return;
                case 35:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, unlinkat(emulator));
                    return;
                case 38:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, renameat(emulator));
                    return;
                case 47:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fallocate(emulator));
                    return;
                case 53:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fchmodat(emulator));
                    return;
                case 54:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fchownat(emulator));
                    return;
                case 56:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, openat(emulator));
                    return;
                case 57:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, close(backend, emulator));
                    return;
                case 59:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, pipe2(emulator));
                    return;
                case 63:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, read(backend, emulator));
                    return;
                case 24:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, dup3(emulator));
                    return;
                case 43: {
                    RegisterContext context = emulator.getContext();
                    Pointer pathPointer = context.getPointerArg(0);
                    Pointer buf = context.getPointerArg(1);
                    String path = pathPointer.getString(0);
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, statfs64(emulator, path, buf));
                    return;
                }
                case 46: {
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, ftruncate(emulator));
                    return;
                }
                case 134:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sigaction(emulator));
                    return;
                case 72:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, pselect6(emulator));
                    return;
                case 78:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, readlinkat(emulator));
                    return;
                case 80:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fstat(backend, emulator));
                    return;
                case 83:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fdatasync(emulator));
                    return;
                case 96:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, set_tid_address(emulator));
                    return;
                case 98:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, futex(emulator));
                    return;
                case 220: {
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, clone(emulator));
                    return;
                }
                case 160:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, uname(emulator));
                    return;
                case 132:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sigaltstack(emulator));
                    return;
                case 135:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sigprocmask(emulator));
                    return;
                case 32:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, flock(emulator));
                    return;
                case 66:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, writev(emulator));
                    return;
                case 101:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, nanosleep(emulator));
                    return;
                case 119:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sched_setscheduler(emulator));
                    return;
                case 122:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sched_setaffinity(emulator));
                    return;
                case 123:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sched_getaffinity(emulator));
                    return;
                case 124:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sched_yield(emulator));
                    return;
                case 136:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, rt_sigpending(emulator));
                    return;
                case 137:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, rt_sigtimedwait(emulator));
                    return;
                case 138:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, rt_sigqueue(emulator));
                    return;
                case 140:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, setpriority(emulator));
                    return;
                case 167:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, prctl(emulator));
                    return;
                case 169:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, gettimeofday(emulator));
                    return;
                case 73:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, ppoll(emulator));
                    return;
                case 173:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getppid(emulator));
                    return;
                case 174: 
                case 175: 
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, 0);
                    return;
                case 200:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, bind(emulator));
                    return;
                case 201:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, listen(emulator));
                    return;
                case 214:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, brk(backend, emulator));
                    return;
                case 215:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, munmap(backend, emulator));
                    return;
                case 216:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mremap(emulator));
                    return;
                case 61:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getdents64(emulator));
                    return;
                case 233:
                    syscall = "madvise";
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, 0);
                    return;
                case 25:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fcntl(emulator));
                    return;
                case 222:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mmap(backend, emulator));
                    return;
                case 226:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mprotect(backend, emulator));
                    return;
                case 227:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, msync(emulator));
                    return;
                case 93:
                    exit(emulator);
                    return;
                case 94:
                    exit_group(emulator);
                    return;
                case 113:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, clock_gettime(emulator));
                    return;
                case 117:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, ptrace(emulator));
                    return;
                case 120:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sched_getscheduler(emulator));
                    return;
                case 121:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sched_getparam(emulator));
                    return;
                case 131:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, tgkill(emulator));
                    return;
                case 141:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getpriority(emulator));
                    return;
                case 163:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getrlimit64(emulator));
                    return;
                case 198:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, socket(emulator));
                    return;
                case 199:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, socketpair(emulator));
                    return;
                case 203:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, connect(emulator));
                    return;
                case 204:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getsockname(emulator));
                    return;
                case 242:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, accept4(emulator));
                    return;
                case 205:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getpeername(emulator));
                    return;
                case 206:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, sendto(emulator));
                    return;
                case 207:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, recvfrom(emulator));
                    return;
                case 208:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, setsockopt(emulator));
                    return;
                case 209:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, getsockopt(emulator));
                    return;
                case 228:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, mlock(emulator));
                    return;
                case 278:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, gerrandom(emulator));
                    return;
                case 79:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, fstatat64(emulator));
                    return;
                case 48:
                    backend.reg_write(Arm64Const.UC_ARM64_REG_X0, faccessat(emulator));
                    return;
            }
        } catch (StopEmulatorException e) {
            backend.emu_stop();
            return;
        } catch (LongJumpException e) {
            backend.emu_stop();
            throw e;
        } catch (Throwable e) {
            backend.emu_stop();
            exception = e;
        }
        if (exception == null && handleUnknownSyscall(emulator, NR)) {
            return;
        }
        log.warn("handleInterrupt intno={}, NR={}, svcNumber=0x{}, PC={}, LR={}, syscall={}", intno, NR, Integer.toHexString(swi), pc, UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_LR), syscall, exception);
        if (log.isDebugEnabled()) {
            emulator.attach().debug();
        }
        if (exception instanceof RuntimeException) {
            throw (RuntimeException) exception;
        }
    }
    private static final int RLIMIT_STACK = 3; 
    private long getrlimit64(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int resource = context.getIntArg(0);
        Pointer ptr = context.getPointerArg(1);
        if (resource == RLIMIT_STACK) {
            RLimit64 rlimit64 = new RLimit64(ptr);
            long size = (long) Memory.STACK_SIZE_OF_PAGE * emulator.getPageAlign();
            rlimit64.rlim_cur = size;
            rlimit64.rlim_max = size;
            rlimit64.pack();
            return 0;
        } else {
            throw new UnsupportedOperationException("getrlimit64 resource=" + resource + ", rlimit64=" + ptr);
        }
    }
    private long msync(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer addr = context.getPointerArg(0);
        int len = context.getIntArg(1);
        int flags = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("msync addr={}, len={}, flags=0x{}", addr, len, Integer.toHexString(flags));
        }
        return 0;
    }
    private long fdatasync(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("fdatasync fd={}", fd);
        }
        return 0;
    }
    private long gerrandom(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer buf = context.getPointerArg(0);
        int bufSize = context.getIntArg(1);
        int flags = context.getIntArg(2);
        return getrandom(buf, bufSize, flags);
    }
    private long clone(Emulator<?> emulator) {
        Arm64RegisterContext context = emulator.getContext();
        Pointer child_stack = context.getPointerArg(1);
        if (child_stack == null &&
                context.getPointerArg(2) == null) {
            return fork(emulator); 
        }
        long fn = context.getXLong(5);
        long arg = context.getXLong(6);
        if (child_stack != null && child_stack.getLong(0) == fn && child_stack.getLong(8) == arg) {
            return bionic_clone(emulator);
        } else {
            return pthread_clone(emulator);
        }
    }
    private int pthread_clone(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int flags = context.getIntArg(0);
        UnidbgPointer child_stack = context.getPointerArg(1);
        List<String> list = new ArrayList<>();
        if ((flags & CLONE_VM) != 0) {
            list.add("CLONE_VM");
        }
        if ((flags & CLONE_FS) != 0) {
            list.add("CLONE_FS");
        }
        if ((flags & CLONE_FILES) != 0) {
            list.add("CLONE_FILES");
        }
        if ((flags & CLONE_SIGHAND) != 0) {
            list.add("CLONE_SIGHAND");
        }
        if ((flags & CLONE_PTRACE) != 0) {
            list.add("CLONE_PTRACE");
        }
        if ((flags & CLONE_VFORK) != 0) {
            list.add("CLONE_VFORK");
        }
        if ((flags & CLONE_PARENT) != 0) {
            list.add("CLONE_PARENT");
        }
        if ((flags & CLONE_THREAD) != 0) {
            list.add("CLONE_THREAD");
        }
        if ((flags & CLONE_NEWNS) != 0) {
            list.add("CLONE_NEWNS");
        }
        if ((flags & CLONE_SYSVSEM) != 0) {
            list.add("CLONE_SYSVSEM");
        }
        if ((flags & CLONE_SETTLS) != 0) {
            list.add("CLONE_SETTLS");
        }
        if ((flags & CLONE_PARENT_SETTID) != 0) {
            list.add("CLONE_PARENT_SETTID");
        }
        if ((flags & CLONE_CHILD_CLEARTID) != 0) {
            list.add("CLONE_CHILD_CLEARTID");
        }
        if ((flags & CLONE_DETACHED) != 0) {
            list.add("CLONE_DETACHED");
        }
        if ((flags & CLONE_UNTRACED) != 0) {
            list.add("CLONE_UNTRACED");
        }
        if ((flags & CLONE_CHILD_SETTID) != 0) {
            list.add("CLONE_CHILD_SETTID");
        }
        if ((flags & CLONE_STOPPED) != 0) {
            list.add("CLONE_STOPPED");
        }
        int threadId = incrementThreadId(emulator);
        UnidbgPointer fn = child_stack.getPointer(0);
        child_stack = child_stack.share(8, 0);
        UnidbgPointer arg = child_stack.getPointer(0);
        child_stack = child_stack.share(8, 0);
        if (threadDispatcherEnabled) {
            throw new UnsupportedOperationException();
        }
        log.info("pthread_clone child_stack={}, thread_id={}, fn={}, arg={}, flags={}", child_stack, threadId, fn, arg, list);
        Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
        if (log.isDebugEnabled()) {
            emulator.attach().debug();
        }
        return threadId;
    }
    protected long fork(Emulator<?> emulator) {
        log.info("fork");
        emulator.getMemory().setErrno(UnixEmulator.ENOSYS);
        return -1;
    }
    private static final int CLONE_VM = 0x00000100;
    private static final int CLONE_FS = 0x00000200;
    private static final int CLONE_FILES = 0x00000400;
    private static final int CLONE_SIGHAND = 0x00000800;
    private static final int CLONE_PTRACE = 0x00002000;
    private static final int CLONE_VFORK = 0x00004000;
    private static final int CLONE_PARENT = 0x00008000;
    private static final int CLONE_THREAD = 0x00010000;
    private static final int CLONE_NEWNS = 0x00020000;
    private static final int CLONE_SYSVSEM = 0x00040000;
    private static final int CLONE_SETTLS = 0x00080000;
    private static final int CLONE_PARENT_SETTID = 0x00100000;
    private static final int CLONE_CHILD_CLEARTID = 0x00200000;
    private static final int CLONE_DETACHED = 0x00400000;
    private static final int CLONE_UNTRACED = 0x00800000;
    private static final int CLONE_CHILD_SETTID = 0x01000000;
    private static final int CLONE_STOPPED = 0x02000000;
    private int bionic_clone(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int flags = context.getIntArg(0);
        Pointer child_stack = context.getPointerArg(1);
        Pointer pid = context.getPointerArg(2);
        Pointer tls = context.getPointerArg(3);
        Pointer ctid = context.getPointerArg(4);
        UnidbgPointer fn = context.getPointerArg(5);
        UnidbgPointer arg = context.getPointerArg(6);
        List<String> list = new ArrayList<>();
        if ((flags & CLONE_VM) != 0) {
            list.add("CLONE_VM");
        }
        if ((flags & CLONE_FS) != 0) {
            list.add("CLONE_FS");
        }
        if ((flags & CLONE_FILES) != 0) {
            list.add("CLONE_FILES");
        }
        if ((flags & CLONE_SIGHAND) != 0) {
            list.add("CLONE_SIGHAND");
        }
        if ((flags & CLONE_PTRACE) != 0) {
            list.add("CLONE_PTRACE");
        }
        if ((flags & CLONE_VFORK) != 0) {
            list.add("CLONE_VFORK");
        }
        if ((flags & CLONE_PARENT) != 0) {
            list.add("CLONE_PARENT");
        }
        if ((flags & CLONE_THREAD) != 0) {
            list.add("CLONE_THREAD");
        }
        if ((flags & CLONE_NEWNS) != 0) {
            list.add("CLONE_NEWNS");
        }
        if ((flags & CLONE_SYSVSEM) != 0) {
            list.add("CLONE_SYSVSEM");
        }
        if ((flags & CLONE_SETTLS) != 0) {
            list.add("CLONE_SETTLS");
        }
        if ((flags & CLONE_PARENT_SETTID) != 0) {
            list.add("CLONE_PARENT_SETTID");
        }
        if ((flags & CLONE_CHILD_CLEARTID) != 0) {
            list.add("CLONE_CHILD_CLEARTID");
        }
        if ((flags & CLONE_DETACHED) != 0) {
            list.add("CLONE_DETACHED");
        }
        if ((flags & CLONE_UNTRACED) != 0) {
            list.add("CLONE_UNTRACED");
        }
        if ((flags & CLONE_CHILD_SETTID) != 0) {
            list.add("CLONE_CHILD_SETTID");
        }
        if ((flags & CLONE_STOPPED) != 0) {
            list.add("CLONE_STOPPED");
        }
        if (log.isDebugEnabled()) {
            log.debug("bionic_clone child_stack={}, pid={}, tls={}, ctid={}, fn={}, arg={}, flags={}", child_stack, pid, tls, ctid, fn, arg, list);
        }
        int threadId = incrementThreadId(emulator);
        if (threadDispatcherEnabled) {
            if (verbose) {
                System.out.printf("bionic_clone fn=%s, LR=%s%n", fn, context.getLRPointer());
            }
            emulator.getThreadDispatcher().addThread(new MarshmallowThread(emulator, fn, arg, ctid, threadId));
        }
        ctid.setInt(0, threadId);
        return threadId;
    }
    private int flock(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int operation = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("flock fd={}, operation={}", fd, operation);
        }
        return 0;
    }
    private int execve(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer filename = context.getPointerArg(0);
        Pointer argv = context.getPointerArg(1);
        Pointer envp = context.getPointerArg(2);
        assert filename != null;
        List<String> args = new ArrayList<>();
        Pointer pointer;
        while ((pointer = argv.getPointer(0)) != null) {
            args.add(pointer.getString(0));
            argv = argv.share(8);
        }
        List<String> env = new ArrayList<>();
        while ((pointer = envp.getPointer(0)) != null) {
            env.add(pointer.getString(0));
            envp = envp.share(8);
        }
        log.info("execve filename={}, args={}, env={}", filename.getString(0), args, env);
        emulator.getMemory().setErrno(UnixEmulator.EACCES);
        return -1;
    }
    private int bind(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer addr = context.getPointerArg(1);
        int addrlen = context.getIntArg(2);
        return bind(emulator, sockfd, addr, addrlen);
    }
    private int listen(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        int backlog = context.getIntArg(1);
        return listen(emulator, sockfd, backlog);
    }
    protected int stat64(Emulator<AndroidFileIO> emulator, String pathname, Pointer statbuf) {
        FileResult<AndroidFileIO> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            return result.io.fstat(emulator, new Stat64(statbuf));
        }
        if (verbose) {
            log.info("stat64 pathname={}", pathname);
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.ENOENT);
        return -1;
    }
    private int getpeername(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer addr = context.getPointerArg(1);
        Pointer addrlen = context.getPointerArg(2);
        if (log.isDebugEnabled()) {
            log.debug("getpeername sockfd={}, addr={}, addrlen={}", sockfd, addr, addrlen);
        }
        FileIO io = fdMap.get(sockfd);
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return io.getpeername(addr, addrlen);
    }
    private static final short POLLIN = 0x0001;
    private static final short POLLOUT = 0x0004;
    private int ppoll(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer fds = context.getPointerArg(0);
        int nfds = context.getIntArg(1);
        Pointer tmo_p = context.getPointerArg(2);
        Pointer sigmask = context.getPointerArg(3);
        int count = 0;
        for (int i = 0; i < nfds; i++) {
            Pointer pollfd = fds.share(i * 8L);
            int fd = pollfd.getInt(0);
            short events = pollfd.getShort(4); 
            if (log.isDebugEnabled()) {
                log.debug("ppoll fds={}, nfds={}, tmo_p={}, sigmask={}, fd={}, events={}", fds, nfds, tmo_p, sigmask, fd, events);
            }
            if (fd < 0) {
                pollfd.setShort(6, (short) 0);
            } else {
                short revents = 0;
                if ((events & POLLOUT) != 0) {
                    revents = POLLOUT;
                } else if ((events & POLLIN) != 0) {
                    revents = POLLIN;
                }
                pollfd.setShort(6, revents); 
                count++;
            }
        }
        return count;
    }
    private int sigprocmask(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int how = context.getIntArg(0);
        Pointer set = context.getPointerArg(1);
        Pointer oldset = context.getPointerArg(2);
        return sigprocmask(emulator, how, set, oldset);
    }
    private int ftruncate(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int length = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("ftruncate fd={}, length={}", fd, length);
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            throw new UnsupportedOperationException();
        }
        return file.ftruncate(length);
    }
    private int sigaction(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int signum = context.getIntArg(0);
        Pointer act = context.getPointerArg(1);
        Pointer oldact = context.getPointerArg(2);
        return sigaction(emulator, signum, act, oldact);
    }
    private int pselect6(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int nfds = context.getIntArg(0);
        Pointer readfds = context.getPointerArg(1);
        Pointer writefds = context.getPointerArg(2);
        Pointer exceptfds = context.getPointerArg(3);
        Pointer timeout = context.getPointerArg(4);
        int size = (nfds - 1) / 8 + 1;
        if (log.isDebugEnabled()) {
            log.debug("pselect6 nfds={}, readfds={}, writefds={}, exceptfds={}, timeout={}, LR={}", nfds, readfds, writefds, exceptfds, timeout, context.getLRPointer());
            if (readfds != null) {
                byte[] data = readfds.getByteArray(0, size);
                Inspector.inspect(data, "readfds");
            }
            if (writefds != null) {
                byte[] data = writefds.getByteArray(0, size);
                Inspector.inspect(data, "writefds");
            }
        }
        if (exceptfds != null) {
            emulator.getMemory().setErrno(UnixEmulator.ENOMEM);
            return -1;
        }
        if (writefds != null) {
            int count = select(nfds, writefds, readfds, false);
            if (count > 0) {
                return count;
            }
        }
        if (readfds != null) {
            int count = select(nfds, readfds, writefds, true);
            if (count == 0) {
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    throw new IllegalStateException(e);
                }
            }
            return count;
        }
        throw new AbstractMethodError("pselect6 nfds=" + nfds + ", readfds=null, writefds=" + writefds + ", exceptfds=null, timeout=" + timeout + ", LR=" + context.getLRPointer());
    }
    private int recvfrom(Emulator<?> emulator) {
        Backend backend = emulator.getBackend();
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer buf = context.getPointerArg(1);
        int len = context.getIntArg(2);
        int flags = context.getIntArg(3);
        Pointer src_addr = context.getPointerArg(4);
        Pointer addrlen = context.getPointerArg(5);
        log.debug("recvfrom sockfd={}, buf={}, len={}, flags={}, src_addr={}, addrlen={}", sockfd, buf, len, flags, src_addr, addrlen);
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.recvfrom(backend, buf, len, flags, src_addr, addrlen);
    }
    private int sendto(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer buf = context.getPointerArg(1);
        int len = context.getIntArg(2);
        int flags = context.getIntArg(3);
        Pointer dest_addr = context.getPointerArg(4);
        int addrlen = context.getIntArg(5);
        return sendto(emulator, sockfd, buf, len, flags, dest_addr, addrlen);
    }
    private int connect(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer addr = context.getPointerArg(1);
        int addrlen = context.getIntArg(2);
        return connect(emulator, sockfd, addr, addrlen);
    }
    private int getsockname(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer addr = context.getPointerArg(1);
        Pointer addrlen = context.getPointerArg(2);
        if (log.isDebugEnabled()) {
            log.debug("getsockname sockfd={}, addr={}, addrlen={}", sockfd, addr, addrlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.getsockname(addr, addrlen);
    }
    private int accept4(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        Pointer addr = context.getPointerArg(1);
        Pointer addrlen = context.getPointerArg(2);
        int flags = context.getIntArg(3);
        return accept(emulator, sockfd, addr, addrlen, flags);
    }
    protected final int accept(Emulator<AndroidFileIO> emulator, int sockfd, Pointer addr, Pointer addrlen, int flags) {
        if (log.isDebugEnabled()) {
            log.debug("accept sockfd={}, addr={}, addrlen={}, flags={}", sockfd, addr, addrlen, flags);
        }
        AndroidFileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        AndroidFileIO newIO = file.accept(addr, addrlen);
        if (newIO == null) {
            return -1;
        } else {
            int fd = getMinFd();
            fdMap.put(fd, newIO);
            return fd;
        }
    }
    private int getsockopt(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        int level = context.getIntArg(1);
        int optname = context.getIntArg(2);
        Pointer optval = context.getPointerArg(3);
        Pointer optlen = context.getPointerArg(4);
        if (log.isDebugEnabled()) {
            log.debug("getsockopt sockfd={}, level={}, optname={}, optval={}, optlen={}", sockfd, level, optname, optval, optlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.getsockopt(level, optname, optval, optlen);
    }
    private int setsockopt(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int sockfd = context.getIntArg(0);
        int level = context.getIntArg(1);
        int optname = context.getIntArg(2);
        Pointer optval = context.getPointerArg(3);
        int optlen = context.getIntArg(4);
        if (log.isDebugEnabled()) {
            log.debug("setsockopt sockfd={}, level={}, optname={}, optval={}, optlen={}", sockfd, level, optname, optval, optlen);
        }
        FileIO file = fdMap.get(sockfd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        return file.setsockopt(level, optname, optval, optlen);
    }
    private int sdk;
    @Override
    public void addIOResolver(IOResolver<AndroidFileIO> resolver) {
        super.addIOResolver(resolver);
        if (resolver instanceof AndroidResolver) {
            sdk = ((AndroidResolver) resolver).getSdk();
        }
    }
    protected AndroidFileIO createLocalSocketIO(Emulator<?> emulator, int sdk) {
        return new LocalSocketIO(emulator, sdk);
    }
    private long socketpair(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int domain = context.getIntArg(0);
        int type = context.getIntArg(1) & 0x7ffff;
        int protocol = context.getIntArg(2);
        Pointer sv = context.getPointerArg(3);
        log.debug("socketpair domain={}, type={}, protocol={}, sv={}", domain, type, protocol, sv);
        if (protocol != SocketIO.AF_UNSPEC) {
            throw new UnsupportedOperationException();
        }
        if (domain == SocketIO.AF_LOCAL) {
            switch (type) {
                case SocketIO.SOCK_STREAM:
                case SocketIO.SOCK_SEQPACKET: {
                    int fd0 = getMinFd();
                    PipedSocketIO one = new PipedSocketIO(emulator);
                    fdMap.put(fd0, one);
                    int fd1 = getMinFd();
                    PipedSocketIO two = new PipedSocketIO(emulator);
                    fdMap.put(fd1, two);
                    one.connectPeer(two);
                    sv.setInt(0, fd0);
                    sv.setInt(4, fd1);
                    return 0;
                }
                default:
                    break;
            }
        }
        throw new UnsupportedOperationException("domain=" + domain + ", type=" + type + ", LR=" + context.getLRPointer());
    }
    private int socket(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int domain = context.getIntArg(0);
        int type = context.getIntArg(1) & 0x7ffff;
        int protocol = context.getIntArg(2);
        log.debug("socket domain={}, type={}, protocol={}", domain, type, protocol);
        if (protocol == SocketIO.IPPROTO_ICMP) {
            throw new UnsupportedOperationException();
        }
        int fd;
        switch (domain) {
            case SocketIO.AF_UNSPEC:
                throw new UnsupportedOperationException();
            case SocketIO.AF_LOCAL:
                switch (type) {
                    case SocketIO.SOCK_STREAM:
                        fd = getMinFd();
                        fdMap.put(fd, createLocalSocketIO(emulator, sdk));
                        return fd;
                    case SocketIO.SOCK_DGRAM:
                        fd = getMinFd();
                        fdMap.put(fd, new LocalAndroidUdpSocket(emulator));
                        return fd;
                    default:
                        emulator.getMemory().setErrno(UnixEmulator.EACCES);
                        return -1;
                }
            case SocketIO.AF_INET:
            case SocketIO.AF_INET6:
                switch (type) {
                    case SocketIO.SOCK_STREAM:
                        fd = getMinFd();
                        fdMap.put(fd, new TcpSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_DGRAM:
                        fd = getMinFd();
                        fdMap.put(fd, new UdpSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_RAW:
                        throw new UnsupportedOperationException();
                }
                break;
            case SocketIO.AF_NETLINK:
                switch (type) {
                    case SocketIO.SOCK_DGRAM:
                        fd = getMinFd();
                        fdMap.put(fd, new NetLinkSocket(emulator));
                        return fd;
                    case SocketIO.SOCK_RAW:
                    default:
                        throw new UnsupportedOperationException();
                }
        }
        log.info("socket domain={}, type={}, protocol={}", domain, type, protocol);
        emulator.getMemory().setErrno(UnixEmulator.EAFNOSUPPORT);
        return -1;
    }
    protected int uname(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer buf = context.getPointerArg(0);
        if (log.isDebugEnabled()) {
            log.debug("uname buf={}", buf);
        }
        final int SYS_NMLN = 65;
        Pointer sysName = buf.share(0);
        sysName.setString(0, "Linux"); 
        Pointer nodeName = sysName.share(SYS_NMLN);
        nodeName.setString(0, "localhost"); 
        Pointer release = nodeName.share(SYS_NMLN);
        release.setString(0, "1.0.0-unidbg"); 
        Pointer version = release.share(SYS_NMLN);
        version.setString(0, "#1 SMP PREEMPT Thu Apr 19 14:36:58 CST 2018"); 
        Pointer machine = version.share(SYS_NMLN);
        machine.setString(0, "armv8l"); 
        Pointer domainName = machine.share(SYS_NMLN);
        domainName.setString(0, "localdomain"); 
        return 0;
    }
    private int getppid(Emulator<AndroidFileIO> emulator) {
        if (log.isDebugEnabled()) {
            log.debug("getppid");
        }
        return emulator.getPid();
    }
    private void exit_group(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int status = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("exit with code: {}", status, new Exception("exit_group status=" + status));
        } else {
            System.out.println("exit with code: " + status);
        }
        if (LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            createBreaker(emulator).debug();
        }
        emulator.getBackend().emu_stop();
    }
    private int munmap(Backend backend, Emulator<?> emulator) {
        long timeInMillis = System.currentTimeMillis();
        long start = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).longValue();
        int length = backend.reg_read(Arm64Const.UC_ARM64_REG_X1).intValue();
        emulator.getMemory().munmap(start, length);
        if (log.isDebugEnabled()) {
            log.debug("munmap start=0x{}, length={}, offset={}", Long.toHexString(start), length, System.currentTimeMillis() - timeInMillis);
        }
        return 0;
    }
    private long mremap(Emulator<?> emulator) {
        Arm64RegisterContext context = emulator.getContext();
        UnidbgPointer old_address = context.getXPointer(0);
        int old_size = context.getXInt(1);
        int new_size = context.getXInt(2);
        int flags = context.getXInt(3);
        UnidbgPointer new_address = context.getXPointer(4);
        if (log.isDebugEnabled()) {
            log.debug("mremap old_address={}, old_size={}, new_size={}, flags={}, new_address={}", old_address, old_size, new_size, flags, new_address);
        }
        if (old_size == 0) {
            throw new BackendException("old_size is zero");
        }
        boolean fixed = (flags & MREMAP_FIXED) != 0;
        if ((flags & MREMAP_MAYMOVE) == 0) {
            throw new BackendException("flags=" + flags);
        }
        Memory memory = emulator.getMemory();
        byte[] data = old_address.getByteArray(0, old_size);
        int prot = memory.munmap(old_address.toUIntPeer(), old_size);
        final long address;
        if (fixed) {
            address = memory.mmap2(new_address.toUIntPeer(), new_size, prot, AndroidElfLoader.MAP_ANONYMOUS | AndroidElfLoader.MAP_FIXED, 0, 0);
        } else {
            address = memory.mmap2(0, new_size, prot, AndroidElfLoader.MAP_ANONYMOUS, 0, 0);
        }
        UnidbgPointer pointer = UnidbgPointer.pointer(emulator, address);
        assert pointer != null;
        pointer.write(0, data, 0, data.length);
        return pointer.toUIntPeer();
    }
    private static final int PR_SET_NAME = 15;
    private static final int PR_SET_NO_NEW_PRIVS = 38;
    private static final int PR_SET_THP_DISABLE = 41;
    private static final int BIONIC_PR_SET_VMA = 0x53564d41;
    private static final int PR_SET_PTRACER = 0x59616d61;
    private int prctl(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int option = context.getIntArg(0);
        long arg2 = context.getLongArg(1);
        if (log.isDebugEnabled()) {
            log.debug("prctl option=0x{}, arg2=0x{}", Integer.toHexString(option), Long.toHexString(arg2));
        }
        switch (option) {
            case PR_SET_NAME:
                Pointer threadName = context.getPointerArg(1);
                if (log.isDebugEnabled()) {
                    log.debug("prctl set thread name: {}", threadName.getString(0));
                }
                return 0;
            case BIONIC_PR_SET_VMA:
                Pointer addr = context.getPointerArg(2);
                int len = context.getIntArg(3);
                Pointer pointer = context.getPointerArg(4);
                if (log.isDebugEnabled()) {
                    log.debug("prctl set vma addr={}, len={}, pointer={}, name={}", addr, len, pointer, pointer.getString(0));
                }
                return 0;
            case PR_SET_PTRACER:
                int pid = (int) arg2;
                if (log.isDebugEnabled()) {
                    log.debug("prctl set ptracer: {}", pid);
                }
                return 0;
            case PR_SET_NO_NEW_PRIVS:
            case PR_SET_THP_DISABLE:
                return 0;
        }
        throw new UnsupportedOperationException("option=" + option);
    }
    private static final int CLOCK_REALTIME = 0;
    private static final int CLOCK_MONOTONIC = 1;
    private static final int CLOCK_THREAD_CPUTIME_ID = 3;
    private static final int CLOCK_MONOTONIC_RAW = 4;
    private static final int CLOCK_MONOTONIC_COARSE = 6;
    private static final int CLOCK_BOOTTIME = 7;
    private final long nanoTime = System.nanoTime();
    protected int clock_gettime(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int clk_id = context.getIntArg(0) & 0x7;
        Pointer tp = context.getPointerArg(1);
        long offset = clk_id == CLOCK_REALTIME ? currentTimeMillis() * 1000000L : System.nanoTime() - nanoTime;
        long tv_sec = offset / 1000000000L;
        long tv_nsec = offset % 1000000000L;
        if (log.isDebugEnabled()) {
            log.debug("clock_gettime clk_id={}, tp={}, offset={}, tv_sec={}, tv_nsec={}", clk_id, tp, offset, tv_sec, tv_nsec);
        }
        switch (clk_id) {
            case CLOCK_REALTIME:
            case CLOCK_MONOTONIC:
            case CLOCK_THREAD_CPUTIME_ID:
            case CLOCK_MONOTONIC_RAW:
            case CLOCK_MONOTONIC_COARSE:
            case CLOCK_BOOTTIME:
                tp.setLong(0, tv_sec);
                tp.setLong(8, tv_nsec);
                return 0;
        }
        if (log.isDebugEnabled()) {
            emulator.attach().debug();
        }
        throw new UnsupportedOperationException("clk_id=" + clk_id);
    }
    protected long ptrace(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int request = context.getIntArg(0);
        int pid = context.getIntArg(1);
        Pointer addr = context.getPointerArg(2);
        Pointer data = context.getPointerArg(3);
        log.info("ptrace request=0x{}, pid={}, addr={}, data={}", Integer.toHexString(request), pid, addr, data);
        return 0;
    }
    private int fcntl(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int cmd = context.getIntArg(1);
        int arg = context.getIntArg(2);
        return fcntl(emulator, fd, cmd, arg);
    }
    private int writev(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer iov = context.getPointerArg(1);
        int iovcnt = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            for (int i = 0; i < iovcnt; i++) {
                Pointer iov_base = iov.getPointer(i * 16L);
                long iov_len = iov.getLong(i * 16L + 8);
                byte[] data = iov_base.getByteArray(0, (int) iov_len);
                Inspector.inspect(data, "writev fd=" + fd + ", iov=" + iov + ", iov_base=" + iov_base);
            }
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int count = 0;
        for (int i = 0; i < iovcnt; i++) {
            Pointer iov_base = iov.getPointer(i * 16L);
            long iov_len = iov.getLong(i * 16L + 8);
            byte[] data = iov_base.getByteArray(0, (int) iov_len);
            count += file.write(data);
        }
        return count;
    }
    private long brk(Backend backend, Emulator<?> emulator) {
        long address = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).longValue();
        if (log.isDebugEnabled()) {
            log.debug("brk address=0x{}", Long.toHexString(address));
        }
        return emulator.getMemory().brk(address);
    }
    private int mprotect(Backend backend, Emulator<?> emulator) {
        long address = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).longValue();
        int length = backend.reg_read(Arm64Const.UC_ARM64_REG_X1).intValue();
        int prot = backend.reg_read(Arm64Const.UC_ARM64_REG_X2).intValue();
        long pageAlign = emulator.getPageAlign();
        long alignedAddress = address / pageAlign * pageAlign;
        long offset = address - alignedAddress;
        long alignedLength = ARM.alignSize(length + offset, emulator.getPageAlign());
        if (log.isDebugEnabled()) {
            log.debug("mprotect address=0x{}, alignedAddress=0x{}, offset={}, length={}, alignedLength={}, prot=0x{}", Long.toHexString(address), Long.toHexString(alignedAddress), offset, length, alignedLength, Integer.toHexString(prot));
        }
        return emulator.getMemory().mprotect(alignedAddress, (int) alignedLength, prot);
    }
    private long mmap(Backend backend, Emulator<?> emulator) {
        long start = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).longValue();
        int length = backend.reg_read(Arm64Const.UC_ARM64_REG_X1).intValue();
        int prot = backend.reg_read(Arm64Const.UC_ARM64_REG_X2).intValue();
        int flags = backend.reg_read(Arm64Const.UC_ARM64_REG_X3).intValue();
        int fd = backend.reg_read(Arm64Const.UC_ARM64_REG_X4).intValue();
        int offset = backend.reg_read(Arm64Const.UC_ARM64_REG_X5).intValue();
        if (offset % emulator.getPageAlign() != 0) {
            throw new IllegalArgumentException("offset=0x" + Long.toHexString(offset));
        }
        boolean warning = length > 0x10000000;
        if (log.isDebugEnabled() || warning) {
            String msg = "mmap start=0x" + Long.toHexString(start) + ", length=" + length + ", prot=0x" + Integer.toHexString(prot) + ", flags=0x" + Integer.toHexString(flags) + ", fd=" + fd + ", offset=" + offset;
            if (warning) {
                log.warn(msg);
                if (log.isTraceEnabled()) {
                    emulator.attach().debug();
                }
            } else {
                log.debug(msg);
            }
        }
        return emulator.getMemory().mmap2(start, length, prot, flags, fd, offset);
    }
    private int gettimeofday(Emulator<?> emulator) {
        Pointer tv = UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_X0);
        Pointer tz = UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_X1);
        return gettimeofday64(tv, tz);
    }
    private int faccessat(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname_p = context.getPointerArg(1);
        int oflags = context.getIntArg(2);
        int mode = context.getIntArg(3);
        String pathname = pathname_p.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("faccessat dirfd={}, pathname={}, oflags=0x{}, mode=0x{}", dirfd, pathname, Integer.toHexString(oflags), Integer.toHexString(mode));
        }
        int ret = faccessat(emulator, pathname);
        if (ret == -1 && verbose) {
            log.info("faccessat failed dirfd={}, pathname={}, oflags=0x{}, mode=0x{}", dirfd, pathname, Integer.toHexString(oflags), Integer.toHexString(mode));
        }
        return ret;
    }
    private int faccessat(Emulator<AndroidFileIO> emulator, String pathname) {
        FileResult<?> result = resolve(emulator, pathname, IOConstants.O_RDONLY);
        if (result != null && result.isSuccess()) {
            return 0;
        }
        emulator.getMemory().setErrno(result != null ? result.errno : UnixEmulator.EACCES);
        return -1;
    }
    private int fstatat64(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname = context.getPointerArg(1);
        Pointer statbuf = context.getPointerArg(2);
        int flags = context.getIntArg(3);
        String path = FilenameUtils.normalize(pathname.getString(0), true);
        if (log.isDebugEnabled()) {
            log.debug("fstatat64 dirfd={}, pathname={}, statbuf={}, flags={}", dirfd, path, statbuf, flags);
        }
        if (dirfd == IO.AT_FDCWD && "".equals(path)) {
            return stat64(emulator, ".", statbuf);
        }
        if (path.startsWith("/")) {
            return stat64(emulator, path, statbuf);
        } else {
            if (dirfd != IO.AT_FDCWD) {
                throw new BackendException("dirfd=" + dirfd);
            }
            log.warn("fstatat64 dirfd={}, pathname={}, statbuf={}, flags={}", dirfd, path, statbuf, flags);
            if (log.isDebugEnabled()) {
                emulator.attach().debug();
            }
            emulator.getMemory().setErrno(UnixEmulator.EACCES);
            return -1;
        }
    }
    private int openat(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname_p = context.getPointerArg(1);
        int oflags = context.getIntArg(2);
        int mode = context.getIntArg(3);
        String pathname = pathname_p.getString(0);
        log.debug("openat dirfd={}, pathname={}, oflags=0x{}, mode={}", dirfd, pathname, Integer.toHexString(oflags), Integer.toHexString(mode));
        pathname = FilenameUtils.normalize(pathname, true);
        if ("/data/misc/zoneinfo/current/tzdata".equals(pathname) || "/dev/pmsg0".equals(pathname)) {
            emulator.getMemory().setErrno(UnixEmulator.ENOENT);
            return -UnixEmulator.ENOENT;
        }
        if (pathname.startsWith("/")) {
            int fd = open(emulator, pathname, oflags);
            if (fd == -1) {
                if (verbose) {
                    log.info("openat dirfd={}, pathname={}, oflags=0x{}, mode={}", dirfd, pathname, Integer.toHexString(oflags), Integer.toHexString(mode));
                }
                return -emulator.getMemory().getLastErrno();
            } else {
                return fd;
            }
        } else {
            if (dirfd != IO.AT_FDCWD) {
                throw new BackendException();
            }
            int fd = open(emulator, pathname, oflags);
            if (fd == -1) {
                if (log.isTraceEnabled()) {
                    emulator.attach().debug();
                }
                if (verbose) {
                    log.info("openat AT_FDCWD dirfd={}, pathname={}, oflags=0x{}, mode={}", dirfd, pathname, Integer.toHexString(oflags), Integer.toHexString(mode));
                }
                return -emulator.getMemory().getLastErrno();
            } else {
                return fd;
            }
        }
    }
    private int lseek(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int offset = context.getIntArg(1);
        int whence = context.getIntArg(2);
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int pos = file.lseek(offset, whence);
        if (log.isDebugEnabled()) {
            log.debug("lseek fd={}, offset={}, whence={}, pos={}", fd, offset, whence, pos);
        }
        return pos;
    }
    private int close(Backend backend, Emulator<?> emulator) {
        int fd = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).intValue();
        if (log.isDebugEnabled()) {
            log.debug("close fd={}", fd);
        }
        return close(emulator, fd);
    }
    private int getdents64(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        UnidbgPointer dirp = context.getPointerArg(1);
        int size = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("getdents64 fd={}, dirp={}, size={}", fd, dirp, size);
        }
        AndroidFileIO io = fdMap.get(fd);
        if (io == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        } else {
            dirp.setSize(size);
            return io.getdents64(dirp, size);
        }
    }
    private int readlinkat(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname = context.getPointerArg(1);
        Pointer buf = context.getPointerArg(2);
        int bufSize = context.getIntArg(3);
        String path = pathname.getString(0);
        if (dirfd != IO.AT_FDCWD) {
            throw new BackendException();
        }
        return readlink(emulator, path, buf, bufSize);
    }
    private int fstat(Backend backend, Emulator<?> emulator) {
        int fd = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).intValue();
        Pointer stat = UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_X1);
        return fstat(emulator, fd, stat);
    }
    protected int fstat(Emulator<?> emulator, int fd, Pointer stat) {
        AndroidFileIO file = fdMap.get(fd);
        if (file == null) {
            if (log.isDebugEnabled()) {
                log.debug("fstat fd={}, stat={}, errno=" + UnixEmulator.EBADF, fd, stat);
            }
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (log.isDebugEnabled()) {
            log.debug("fstat file={}, stat={}, from={}", file, stat, emulator.getContext().getLRPointer());
        }
        return file.fstat(emulator, new Stat64(stat));
    }
    private int ioctl(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        long request = context.getLongArg(1);
        long argp = context.getLongArg(2);
        if (log.isDebugEnabled()) {
            log.debug("ioctl fd={}, request=0x{}, argp=0x{}", fd, Long.toHexString(request), Long.toHexString(argp));
        }
        FileIO file = fdMap.get(fd);
        if (file == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        int ret = file.ioctl(emulator, request, argp);
        if (ret == -1) {
            emulator.getMemory().setErrno(UnixEmulator.ENOTTY);
        }
        return ret;
    }
    private int write(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        Pointer buffer = context.getPointerArg(1);
        int count = context.getIntArg(2);
        return write(emulator, fd, buffer, count);
    }
    private int read(Backend backend, Emulator<?> emulator) {
        int fd = backend.reg_read(Arm64Const.UC_ARM64_REG_X0).intValue();
        Pointer buffer = UnidbgPointer.register(emulator, Arm64Const.UC_ARM64_REG_X1);
        int count = backend.reg_read(Arm64Const.UC_ARM64_REG_X2).intValue();
        return read(emulator, fd, buffer, count);
    }
    private int dup3(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int oldfd = context.getIntArg(0);
        int newfd = context.getIntArg(1);
        int flags = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("dup3 oldfd={}, newfd={}, flags=0x{}", oldfd, newfd, Integer.toHexString(flags));
        }
        FileIO old = fdMap.get(oldfd);
        if (old == null) {
            emulator.getMemory().setErrno(UnixEmulator.EBADF);
            return -1;
        }
        if (oldfd == newfd) {
            return newfd;
        }
        AndroidFileIO _new = fdMap.remove(newfd);
        if (_new != null) {
            _new.close();
        }
        _new = (AndroidFileIO) old.dup2();
        fdMap.put(newfd, _new);
        return newfd;
    }
    @Override
    protected AndroidFileIO createByteArrayFileIO(String pathname, int oflags, byte[] data) {
        return new ByteArrayFileIO(oflags, pathname, data);
    }
    @Override
    protected AndroidFileIO createDriverFileIO(Emulator<?> emulator, int oflags, String pathname) {
        return DriverFileIO.create(emulator, oflags, pathname);
    }
}
package com.github.unidbg.linux;
import com.github.unidbg.AbstractEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.arm.backend.BackendException;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.file.FileResult;
import com.github.unidbg.file.linux.AndroidFileIO;
import com.github.unidbg.file.linux.IOConstants;
import com.github.unidbg.linux.file.DirectoryFileIO;
import com.github.unidbg.linux.file.EventFD;
import com.github.unidbg.linux.file.PipedReadFileIO;
import com.github.unidbg.linux.file.PipedWriteFileIO;
import com.github.unidbg.linux.signal.SigAction;
import com.github.unidbg.linux.signal.SignalFunction;
import com.github.unidbg.linux.signal.SignalTask;
import com.github.unidbg.linux.struct.StatFS;
import com.github.unidbg.linux.struct.StatFS32;
import com.github.unidbg.linux.struct.StatFS64;
import com.github.unidbg.linux.thread.FutexIndefinitelyWaiter;
import com.github.unidbg.linux.thread.FutexNanoSleepWaiter;
import com.github.unidbg.linux.thread.FutexWaiter;
import com.github.unidbg.linux.thread.MarshmallowThread;
import com.github.unidbg.linux.thread.NanoSleepWaiter;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.signal.SigSet;
import com.github.unidbg.signal.SignalOps;
import com.github.unidbg.signal.UnixSigSet;
import com.github.unidbg.spi.SyscallHandler;
import com.github.unidbg.thread.MainTask;
import com.github.unidbg.thread.RunnableTask;
import com.github.unidbg.thread.Task;
import com.github.unidbg.thread.ThreadContextSwitchException;
import com.github.unidbg.thread.ThreadDispatcher;
import com.github.unidbg.thread.ThreadTask;
import com.github.unidbg.thread.Waiter;
import com.github.unidbg.unix.IO;
import com.github.unidbg.unix.UnixEmulator;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.unix.struct.TimeSpec;
import com.github.unidbg.utils.Inspector;
import com.sun.jna.Pointer;
import net.dongliu.apk.parser.utils.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public abstract class AndroidSyscallHandler extends UnixSyscallHandler<AndroidFileIO> implements SyscallHandler<AndroidFileIO> {
    private static final Logger log = LoggerFactory.getLogger(AndroidSyscallHandler.class);
    static final int MREMAP_MAYMOVE = 1;
    static final int MREMAP_FIXED = 2;
    private byte[] sched_cpu_mask;
    final int mlock(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer addr = context.getPointerArg(0);
        int len = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("mlock addr={}, len={}", addr, len);
        }
        return 0;
    }
    final int munlock(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer addr = context.getPointerArg(0);
        int len = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("munlock addr={}, len={}", addr, len);
        }
        return 0;
    }
    final long sched_setaffinity(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        int cpusetsize = context.getIntArg(1);
        Pointer mask = context.getPointerArg(2);
        if (mask != null) {
            sched_cpu_mask = mask.getByteArray(0, cpusetsize);
        }
        if (log.isDebugEnabled()) {
            log.debug(Inspector.inspectString(sched_cpu_mask, "sched_setaffinity pid=" + pid + ", cpusetsize=" + cpusetsize + ", mask=" + mask));
        }
        return 0;
    }
    final long sched_getaffinity(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        int cpusetsize = context.getIntArg(1);
        Pointer mask = context.getPointerArg(2);
        int ret = 0;
        if (mask != null && sched_cpu_mask != null) {
            mask.write(0, sched_cpu_mask, 0, cpusetsize);
            ret = cpusetsize;
        }
        if (log.isDebugEnabled()) {
            log.debug(Inspector.inspectString(sched_cpu_mask, "sched_getaffinity pid=" + pid + ", cpusetsize=" + cpusetsize + ", mask=" + mask));
        }
        return ret;
    }
    private static final int EFD_SEMAPHORE = 1;
    private static final int EFD_NONBLOCK = IOConstants.O_NONBLOCK;
    private static final int EFD_CLOEXEC = IOConstants.O_CLOEXEC;
    final int eventfd2(Emulator<?> emulator) {
        RegisterContext ctx = emulator.getContext();
        int initval = ctx.getIntArg(0);
        int flags = ctx.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("eventfd2 initval={}, flags=0x{}", initval, Integer.toHexString(flags));
        }
        if ((flags & EFD_CLOEXEC) != 0) {
            throw new UnsupportedOperationException("eventfd2 flags=0x" + Integer.toHexString(flags));
        }
        boolean nonblock = (flags & EFD_NONBLOCK) != 0;
        boolean semaphore = (flags & EFD_SEMAPHORE) != 0;
        AndroidFileIO fileIO = new EventFD(initval, semaphore, nonblock);
        int minFd = this.getMinFd();
        this.fdMap.put(minFd, fileIO);
        if (verbose) {
            System.out.printf("eventfd(%d) with flags=0x%x fd=%d from %s%n", initval, flags, minFd, emulator.getContext().getLRPointer());
        }
        return minFd;
    }
    protected int sched_setscheduler(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        int policy = context.getIntArg(1);
        Pointer param = context.getPointerArg(2);
        if (log.isDebugEnabled()) {
            log.debug("sched_setscheduler pid={}, policy={}, param={}", pid, policy, param);
        }
        return 0;
    }
    protected int getcwd(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        UnidbgPointer buf = context.getPointerArg(0);
        int size = context.getIntArg(1);
        File workDir = emulator.getFileSystem().createWorkDir();
        String path = workDir.getPath();
        if (log.isDebugEnabled()) {
            log.debug("getcwd buf={}, size={}, path={}", buf, size, path);
        }
        buf.setString(0, ".");
        return (int) buf.peer;
    }
    private static final int SCHED_OTHER = 0;
    protected int sched_getscheduler(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        if (log.isDebugEnabled()) {
            log.debug("sched_getscheduler pid={}", pid);
        }
        return SCHED_OTHER;
    }
    protected int sched_getparam(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        Pointer param = context.getPointerArg(1);
        if (log.isDebugEnabled()) {
            log.debug("sched_getparam pid={}, param={}", pid, param);
        }
        param.setInt(0, ANDROID_PRIORITY_NORMAL);
        return 0;
    }
    protected int sched_yield(Emulator<AndroidFileIO> emulator) {
        if (log.isDebugEnabled()) {
            log.debug("sched_yield");
        }
        if (emulator.getThreadDispatcher().getTaskCount() <= 1) {
            return 0;
        } else {
            throw new ThreadContextSwitchException().setReturnValue(0);
        }
    }
    private static final int ANDROID_PRIORITY_NORMAL = 0; 
    protected int getpriority(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int which = context.getIntArg(0);
        int who = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("getpriority which={}, who={}", which, who);
        }
        return ANDROID_PRIORITY_NORMAL;
    }
    protected int setpriority(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int which = context.getIntArg(0);
        int who = context.getIntArg(1);
        int prio = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("setpriority which={}, who={}, prio={}", which, who, prio);
        }
        return 0;
    }
    private static final int SIG_BLOCK = 0;
    private static final int SIG_UNBLOCK = 1;
    private static final int SIG_SETMASK = 2;
    @Override
    protected int sigprocmask(Emulator<?> emulator, int how, Pointer set, Pointer oldset) {
        Task task = emulator.get(Task.TASK_KEY);
        SignalOps signalOps = task.isMainThread() ? emulator.getThreadDispatcher() : task;
        SigSet old = signalOps.getSigMaskSet();
        if (oldset != null && old != null) {
            if (emulator.is32Bit()) {
                oldset.setInt(0, (int) old.getMask());
            } else {
                oldset.setLong(0, old.getMask());
            }
        }
        if (set == null) {
            return 0;
        }
        long mask = emulator.is32Bit() ? set.getInt(0) : set.getLong(0);
        switch (how) {
            case SIG_BLOCK:
                if (old == null) {
                    SigSet sigSet = new UnixSigSet(mask);
                    SigSet sigPendingSet = new UnixSigSet(0);
                    signalOps.setSigMaskSet(sigSet);
                    signalOps.setSigPendingSet(sigPendingSet);
                } else {
                    old.blockSigSet(mask);
                }
                return 0;
            case SIG_UNBLOCK:
                if (old != null) {
                    old.unblockSigSet(mask);
                }
                return 0;
            case SIG_SETMASK:
                SigSet sigSet = new UnixSigSet(mask);
                SigSet sigPendingSet = new UnixSigSet(0);
                signalOps.setSigMaskSet(sigSet);
                signalOps.setSigPendingSet(sigPendingSet);
                return 0;
        }
        return super.sigprocmask(emulator, how, set, oldset);
    }
    protected int rt_sigpending(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer set = context.getPointerArg(0);
        if (log.isDebugEnabled()) {
            log.debug("rt_sigpending set={}", set);
        }
        Task task = emulator.get(Task.TASK_KEY);
        SignalOps signalOps = task.isMainThread() ? emulator.getThreadDispatcher() : task;
        SigSet sigSet = signalOps.getSigPendingSet();
        if (set != null && sigSet != null) {
            if (emulator.is32Bit()) {
                set.setInt(0, (int) sigSet.getMask());
            } else {
                set.setLong(0, sigSet.getMask());
            }
        }
        return 0;
    }
    private static final int FUTEX_CMD_MASK = 0x7f;
    private static final int FUTEX_PRIVATE_FLAG = 0x80;
    private static final int MUTEX_SHARED_MASK = 0x2000;
    private static final int MUTEX_TYPE_MASK = 0xc000;
    private static final int FUTEX_WAIT = 0;
    private static final int FUTEX_WAKE = 1;
    private static final int FUTEX_FD = 2;
    private static final int FUTEX_REQUEUE = 3;
    private static final int FUTEX_CMP_REQUEUE = 4;
    public static final int ETIMEDOUT = 110;
    protected int futex(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer uaddr = context.getPointerArg(0);
        int futex_op = context.getIntArg(1);
        int val = context.getIntArg(2);
        int old = uaddr.getInt(0);
        boolean isPrivate = (futex_op & FUTEX_PRIVATE_FLAG) != 0;
        int cmd = futex_op & FUTEX_CMD_MASK;
        if (log.isDebugEnabled()) {
            log.debug("futex uaddr={}, isPrivate={}, cmd={}, val=0x{}, old=0x{}, LR={}", uaddr, isPrivate, cmd, Integer.toHexString(val), Integer.toHexString(old), context.getLRPointer());
        }
        Task task = emulator.get(Task.TASK_KEY);
        switch (cmd) {
            case FUTEX_WAIT:
                if (old != val) {
                    return -UnixEmulator.EAGAIN;
                }
                Pointer timeout = context.getPointerArg(3);
                TimeSpec timeSpec = timeout == null ? null : TimeSpec.createTimeSpec(emulator, timeout);
                int mtype = val & MUTEX_TYPE_MASK;
                int shared = val & MUTEX_SHARED_MASK;
                if (log.isDebugEnabled()) {
                    log.debug("futex FUTEX_WAIT mtype=0x{}, shared={}, timeSpec={}, test={}, task={}", Integer.toHexString(mtype), shared, timeSpec, mtype | shared, task);
                }
                RunnableTask runningTask = emulator.getThreadDispatcher().getRunningTask();
                if (threadDispatcherEnabled && runningTask != null) {
                    if (timeSpec == null) {
                        runningTask.setWaiter(emulator, new FutexIndefinitelyWaiter(uaddr, val));
                    } else {
                        runningTask.setWaiter(emulator, new FutexNanoSleepWaiter(uaddr, val, timeSpec));
                    }
                    throw new ThreadContextSwitchException();
                }
                if (threadDispatcherEnabled && emulator.getThreadDispatcher().getTaskCount() > 1) {
                    throw new ThreadContextSwitchException().setReturnValue(-ETIMEDOUT);
                } else {
                    return 0;
                }
            case FUTEX_WAKE:
                if (log.isDebugEnabled()) {
                    log.debug("futex FUTEX_WAKE val=0x{}, old={}, task={}", Integer.toHexString(val), old, task);
                }
                if (emulator.getThreadDispatcher().getTaskCount() <= 1) {
                    return 0;
                }
                int count = 0;
                for (Task t : emulator.getThreadDispatcher().getTaskList()) {
                    Waiter waiter = t.getWaiter();
                    if (waiter instanceof FutexWaiter) {
                        if (((FutexWaiter) waiter).wakeUp(uaddr)) {
                            if (++count >= val) {
                                break;
                            }
                        }
                    }
                }
                if (count > 0) {
                    throw new ThreadContextSwitchException().setReturnValue(count);
                }
                if (threadDispatcherEnabled && task != null) {
                    throw new ThreadContextSwitchException().setReturnValue(1);
                }
                return 0;
            case FUTEX_CMP_REQUEUE:
                if (log.isDebugEnabled()) {
                    log.debug("futex FUTEX_CMP_REQUEUE val=0x{}, old={}, task={}", Integer.toHexString(val), old, task);
                }
                return 0;
            default:
                if (log.isDebugEnabled()) {
                    emulator.attach().debug();
                }
                throw new AbstractMethodError("futex_op=0x" + Integer.toHexString(futex_op));
        }
    }
    protected int rt_sigtimedwait(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer set = context.getPointerArg(0);
        Pointer info = context.getPointerArg(1);
        Pointer timeout = context.getPointerArg(2);
        int sigsetsize = context.getIntArg(3);
        long mask = emulator.is32Bit() ? set.getInt(0) : set.getLong(0);
        Task task = emulator.get(Task.TASK_KEY);
        SigSet sigSet = new UnixSigSet(mask);
        SignalOps signalOps = task.isMainThread() ? emulator.getThreadDispatcher() : task;
        SigSet sigPendingSet = signalOps.getSigPendingSet();
        if (sigPendingSet != null) {
            for (Integer signum : sigSet) {
                if (sigPendingSet.containsSigNumber(signum)) {
                    sigPendingSet.removeSigNumber(signum);
                    return signum;
                }
            }
        }
        if (!task.isMainThread()) {
            throw new ThreadContextSwitchException().setReturnValue(-UnixEmulator.EINTR);
        }
        log.info("rt_sigtimedwait set={}, info={}, timeout={}, sigsetsize={}, sigSet={}, task={}", set, info, timeout, sigsetsize, sigSet, task);
        Logger log = LoggerFactory.getLogger(AbstractEmulator.class);
        if (log.isDebugEnabled()) {
            emulator.attach().debug();
        }
        return 0;
    }
    protected int rt_sigqueue(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int tgid = context.getIntArg(0);
        int sig = context.getIntArg(1);
        UnidbgPointer info = context.getPointerArg(2);
        if (log.isDebugEnabled()) {
            log.debug("rt_sigqueue tgid={}, sig={}", tgid, sig);
        }
        Task task = emulator.get(Task.TASK_KEY);
        if (!(tgid == 0 || tgid == -1 || Math.abs(tgid) == emulator.getPid())) {
            return -UnixEmulator.ESRCH;
        }
        if (sig == 0) {
            return 0;
        }
        if (sig < 0 || sig > 64) {
            return -UnixEmulator.EINVAL;
        }
        if (task != null) {
            SigAction sigAction = sigActionMap.get(sig);
            return processSignal(emulator.getThreadDispatcher(), sig, task, sigAction, info);
        }
        throw new UnsupportedOperationException();
    }
    @Override
    protected FileResult<AndroidFileIO> createFdDir(int oflags, String pathname) {
        List<DirectoryFileIO.DirectoryEntry> list = new ArrayList<>();
        for (Map.Entry<Integer, AndroidFileIO> entry : fdMap.entrySet()) {
            list.add(new DirectoryFileIO.DirectoryEntry(DirectoryFileIO.DirentType.DT_LNK, entry.getKey().toString()));
        }
        return FileResult.<AndroidFileIO>success(new DirectoryFileIO(oflags, pathname, list.toArray(new DirectoryFileIO.DirectoryEntry[0])));
    }
    @Override
    protected FileResult<AndroidFileIO> createTaskDir(Emulator<AndroidFileIO> emulator, int oflags, String pathname) {
        return FileResult.<AndroidFileIO>success(new DirectoryFileIO(oflags, pathname, new DirectoryFileIO.DirectoryEntry(false, Integer.toString(emulator.getPid()))));
    }
    protected long statfs64(Emulator<AndroidFileIO> emulator, String path, Pointer buf) {
        FileResult<AndroidFileIO> result = resolve(emulator, path, IOConstants.O_RDONLY);
        if (result == null) {
            log.info("statfs64 buf={}, path={}", buf, path);
            emulator.getMemory().setErrno(UnixEmulator.ENOENT);
            return -1;
        }
        if (result.isSuccess()) {
            StatFS statFS = emulator.is64Bit() ? new StatFS64(buf) : new StatFS32(buf);
            int ret = result.io.statfs(statFS);
            if (ret != 0) {
                log.info("statfs64 buf={}, path={}, ret={}", buf, path, ret);
            } else {
                if (verbose) {
                    System.out.printf("File statfs '%s' from %s%n", result.io, emulator.getContext().getLRPointer());
                }
                if (log.isDebugEnabled()) {
                    log.debug("statfs64 buf={}, path={}", buf, path);
                }
            }
            return ret;
        } else {
            log.info("statfs64 buf={}, path={}", buf, path);
            emulator.getMemory().setErrno(result.errno);
            return -1;
        }
    }
    protected int pipe2(Emulator<?> emulator) {
        try {
            RegisterContext context = emulator.getContext();
            Pointer pipefd = context.getPointerArg(0);
            int flags = context.getIntArg(1);
            int writefd = getMinFd();
            Pair<AndroidFileIO, AndroidFileIO> pair = getPipePair(emulator, writefd);
            this.fdMap.put(writefd, pair.getLeft());
            int readfd = getMinFd();
            this.fdMap.put(readfd, pair.getRight());
            pipefd.setInt(0, readfd);
            pipefd.setInt(4, writefd);
            if (log.isDebugEnabled()) {
                log.debug("pipe2 pipefd={}, flags=0x{}, readfd={}, writefd={}", pipefd, flags, readfd, writefd);
            }
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
        return 0;
    }
    protected Pair<AndroidFileIO, AndroidFileIO> getPipePair(Emulator<?> emulator, int writefd) throws IOException {
        PipedInputStream inputStream = new PipedInputStream();
        PipedOutputStream outputStream = new PipedOutputStream(inputStream);
        AndroidFileIO writeIO = new PipedWriteFileIO(outputStream, writefd);
        AndroidFileIO readIO = new PipedReadFileIO(inputStream, writefd);
        log.info("Return default pipe pair.");
        return new Pair<>(writeIO, readIO);
    }
    protected int fchmodat(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname_p = context.getPointerArg(1);
        int mode = context.getIntArg(2);
        int flags = context.getIntArg(3);
        String pathname = pathname_p.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("fchmodat dirfd={}, pathname={}, mode=0x{}, flags=0x{}", dirfd, pathname, Integer.toHexString(mode), Integer.toHexString(flags));
        }
        return 0;
    }
    protected int fchownat(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname_p = context.getPointerArg(1);
        int owner = context.getIntArg(2);
        int group = context.getIntArg(3);
        int flags = context.getIntArg(4);
        String pathname = pathname_p.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("fchownat dirfd={}, pathname={}, owner={}, group={}, flags=0x{}", dirfd, pathname, owner, group, Integer.toHexString(flags));
        }
        return 0;
    }
    protected int mkdirat(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname_p = context.getPointerArg(1);
        int mode = context.getIntArg(2);
        String pathname = pathname_p.getString(0);
        if (log.isDebugEnabled()) {
            log.debug("mkdirat dirfd={}, pathname={}, mode={}", dirfd, pathname, Integer.toHexString(mode));
        }
        if (dirfd != IO.AT_FDCWD) {
            throw new BackendException();
        }
        if (emulator.getFileSystem().mkdir(pathname, mode)) {
            if (log.isDebugEnabled()) {
                log.debug("mkdir pathname={}, mode={}", pathname, mode);
            }
            return 0;
        } else {
            log.info("mkdir pathname={}, mode={}", pathname, mode);
            emulator.getMemory().setErrno(UnixEmulator.EACCES);
            return -1;
        }
    }
    final int select(int nfds, Pointer checkfds, Pointer clearfds, boolean checkRead) {
        int count = 0;
        for (int i = 0; i < nfds; i++) {
            int mask = checkfds.getInt(i / 32);
            if (((mask >> i) & 1) == 1) {
                AndroidFileIO io = fdMap.get(i);
                if (!checkRead || io.canRead()) {
                    count++;
                } else {
                    mask &= ~(1 << i);
                    checkfds.setInt(i / 32, mask);
                }
            }
        }
        if (count > 0) {
            if (clearfds != null) {
                for (int i = 0; i < nfds; i++) {
                    clearfds.setInt(i / 32, 0);
                }
            }
        }
        return count;
    }
    protected int sigaltstack(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer ss = context.getPointerArg(0);
        Pointer old_ss = context.getPointerArg(1);
        if (log.isDebugEnabled()) {
            log.debug("sigaltstack ss={}, old_ss={}", ss, old_ss);
        }
        return 0;
    }
    protected int renameat(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int olddirfd = context.getIntArg(0);
        String oldpath = context.getPointerArg(1).getString(0);
        int newdirfd = context.getIntArg(2);
        String newpath = context.getPointerArg(3).getString(0);
        int ret = emulator.getFileSystem().rename(oldpath, newpath);
        if (ret != 0) {
            log.info("renameat olddirfd={}, oldpath={}, newdirfd={}, newpath={}", olddirfd, oldpath, newdirfd, newpath);
        } else {
            log.debug("renameat olddirfd={}, oldpath={}, newdirfd={}, newpath={}", olddirfd, oldpath, newdirfd, newpath);
        }
        return 0;
    }
    protected int unlinkat(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int dirfd = context.getIntArg(0);
        Pointer pathname = context.getPointerArg(1);
        int flags = context.getIntArg(2);
        emulator.getFileSystem().unlink(pathname.getString(0));
        if (log.isDebugEnabled()) {
            log.info("unlinkat dirfd={}, pathname={}, flags={}", dirfd, pathname.getString(0), flags);
        }
        return 0;
    }
    protected void exit(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int status = context.getIntArg(0);
        Task task = emulator.get(Task.TASK_KEY);
        if (task instanceof ThreadTask) {
            ThreadTask threadTask = (ThreadTask) task;
            threadTask.setExitStatus(status);
            throw new ThreadContextSwitchException().setReturnValue(0);
        }
        System.out.println("exit status=" + status);
        if (LoggerFactory.getLogger(AbstractEmulator.class).isDebugEnabled()) {
            emulator.attach().debug();
        }
        emulator.getBackend().emu_stop();
    }
    private static final int SIGKILL = 9;
    private static final int SIGSTOP = 19;
    private static final int SIG_ERR = -1;
    private final Map<Integer, SigAction> sigActionMap = new HashMap<>();
    @Override
    public MainTask createSignalHandlerTask(Emulator<?> emulator, int sig) {
        SigAction action = sigActionMap.get(sig);
        if (action != null) {
            return new SignalFunction(emulator, sig, action);
        }
        return super.createSignalHandlerTask(emulator, sig);
    }
    @Override
    protected int sigaction(Emulator<?> emulator, int signum, Pointer act, Pointer oldact) {
        SigAction action = SigAction.create(emulator, act);
        SigAction oldAction = SigAction.create(emulator, oldact);
        if (log.isDebugEnabled()) {
            log.debug("sigaction signum={}, action={}, oldAction={}", signum, action, oldAction);
        }
        if (SIGKILL == signum || SIGSTOP == signum) {
            if (oldAction != null) {
                oldAction.setSaHandler(SIG_ERR);
                oldAction.pack();
            }
            return -UnixEmulator.EINVAL;
        }
        SigAction lastAction = sigActionMap.put(signum, action);
        if (oldAction != null) {
            if (lastAction == null) {
                oldact.write(0, new byte[oldAction.size()], 0, oldAction.size());
            } else {
                oldAction.setSaHandler(lastAction.getSaHandler());
                oldAction.setSaRestorer(lastAction.getSaRestorer());
                oldAction.setFlags(lastAction.getFlags());
                oldAction.setMask(lastAction.getMask());
                oldAction.pack();
            }
        }
        return 0;
    }
    protected int kill(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int pid = context.getIntArg(0);
        int sig = context.getIntArg(1);
        if (log.isDebugEnabled()) {
            log.debug("kill pid={}, sig={}", pid, sig);
        }
        if (sig == 0) {
            return 0;
        }
        if (sig < 0 || sig > 64) {
            return -UnixEmulator.EINVAL;
        }
        Task task = emulator.get(Task.TASK_KEY);
        if ((pid == 0 || pid == emulator.getPid()) && task != null) {
            SigAction action = sigActionMap.get(sig);
            return processSignal(emulator.getThreadDispatcher(), sig, task, action, null);
        }
        throw new UnsupportedOperationException("kill pid=" + pid + ", sig=" + sig + ", LR=" + context.getLRPointer());
    }
    private int processSignal(ThreadDispatcher threadDispatcher, int sig, Task task, SigAction action, Pointer sig_info) {
        if (action != null) {
            SignalOps signalOps = task.isMainThread() ? threadDispatcher : task;
            SigSet sigMaskSet = signalOps.getSigMaskSet();
            SigSet sigPendingSet = signalOps.getSigPendingSet();
            if (sigMaskSet == null || !sigMaskSet.containsSigNumber(sig)) {
                task.addSignalTask(new SignalTask(sig, action, sig_info));
                throw new ThreadContextSwitchException().setReturnValue(0);
            } else if (sigPendingSet != null) {
                sigPendingSet.addSigNumber(sig);
            }
        }
        return 0;
    }
    protected int tgkill(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        int tgid = context.getIntArg(0);
        int tid = context.getIntArg(1);
        int sig = context.getIntArg(2);
        if (log.isDebugEnabled()) {
            log.debug("tgkill tgid={}, tid={}, sig={}", tgid, tid, sig);
        }
        if (sig == 0) {
            return 0;
        }
        if (sig < 0 || sig > 64) {
            return -UnixEmulator.EINVAL;
        }
        SigAction action = sigActionMap.get(sig);
        if (threadDispatcherEnabled &&
                emulator.getThreadDispatcher().sendSignal(tid, sig, action == null || action.getSaHandler() == 0L ? null : new SignalTask(sig, action))) {
            throw new ThreadContextSwitchException().setReturnValue(0);
        }
        return 0;
    }
    protected int set_tid_address(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer tidptr = context.getPointerArg(0);
        if (log.isDebugEnabled()) {
            log.debug("set_tid_address tidptr={}", tidptr);
        }
        Task task = emulator.get(Task.TASK_KEY);
        if (task instanceof MarshmallowThread) {
            MarshmallowThread thread = (MarshmallowThread) task;
            thread.set_tid_address(tidptr);
        }
        return 0;
    }
    private int threadId;
    protected final int incrementThreadId(Emulator<?> emulator) {
        if (threadId == 0) {
            threadId = emulator.getPid();
        }
        return (++threadId) & 0xffff; 
    }
    protected int nanosleep(Emulator<?> emulator) {
        RegisterContext context = emulator.getContext();
        Pointer req = context.getPointerArg(0);
        Pointer rem = context.getPointerArg(1);
        TimeSpec timeSpec = TimeSpec.createTimeSpec(emulator, req);
        if (log.isDebugEnabled()) {
            log.debug("nanosleep req={}, rem={}, timeSpec={}", req, rem, timeSpec);
        }
        RunnableTask runningTask = emulator.getThreadDispatcher().getRunningTask();
        if (threadDispatcherEnabled && runningTask != null) {
            runningTask.setWaiter(emulator, new NanoSleepWaiter(emulator, rem, timeSpec));
            throw new ThreadContextSwitchException().setReturnValue(0);
        } else {
            try {
                java.lang.Thread.sleep(timeSpec.toMillis());
            } catch (InterruptedException ignored) {
            }
            return 0;
        }
    }
    protected int fallocate(Emulator<AndroidFileIO> emulator) {
        RegisterContext context = emulator.getContext();
        int fd = context.getIntArg(0);
        int mode = context.getIntArg(1);
        int offset = context.getIntArg(2);
        int len = context.getIntArg(3);
        if (log.isDebugEnabled()) {
            log.debug("fallocate fd={}, mode=0x{}, offset={}, len={}", fd, Integer.toHexString(mode), offset, len);
        }
        return 0;
    }
}
package com.github.unidbg.unix;
import com.github.unidbg.Emulator;
import com.github.unidbg.file.FileIO;
public interface FileListener {
    void onOpenSuccess(Emulator<?> emulator, String pathname, FileIO io);
    void onRead(Emulator<?> emulator, String pathname, byte[] bytes);
    void onWrite(Emulator<?> emulator, String pathname, byte[] bytes);
    void onClose(Emulator<?> emulator, FileIO io);
}
package com.github.unidbg.unix.struct;
import com.github.unidbg.pointer.UnidbgStructure;
import com.sun.jna.Pointer;
import java.util.Arrays;
import java.util.List;
public class TimeZone extends UnidbgStructure {
    public TimeZone(Pointer p) {
        super(p);
    }
    public int tz_minuteswest;
    public int tz_dsttime;
    @Override
    protected List<String> getFieldOrder() {
        return Arrays.asList("tz_minuteswest", "tz_dsttime");
    }
}
package com.github.unidbg.linux.android;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Family;
import com.github.unidbg.arm.AbstractARM64Emulator;
import com.github.unidbg.arm.backend.BackendFactory;
import com.github.unidbg.file.FileSystem;
import com.github.unidbg.file.linux.AndroidFileIO;
import com.github.unidbg.file.linux.LinuxFileSystem;
import com.github.unidbg.linux.ARM64SyscallHandler;
import com.github.unidbg.linux.AndroidElfLoader;
import com.github.unidbg.linux.android.dvm.DalvikVM64;
import com.github.unidbg.linux.android.dvm.VM;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.memory.SvcMemory;
import com.github.unidbg.spi.Dlfcn;
import com.github.unidbg.spi.LibraryFile;
import com.github.unidbg.unix.UnixSyscallHandler;
import com.github.unidbg.unwind.Unwinder;
import java.io.File;
import java.net.URL;
import java.util.Collection;
public class AndroidARM64Emulator extends AbstractARM64Emulator<AndroidFileIO> implements AndroidEmulator {
    protected AndroidARM64Emulator(String processName, File rootDir, Collection<BackendFactory> backendFactories) {
        super(processName, rootDir, Family.Android64, backendFactories);
    }
    @Override
    protected FileSystem<AndroidFileIO> createFileSystem(File rootDir) {
        return new LinuxFileSystem(this, rootDir);
    }
    @Override
    protected Memory createMemory(UnixSyscallHandler<AndroidFileIO> syscallHandler, String[] envs) {
        return new AndroidElfLoader(this, syscallHandler);
    }
    @Override
    protected Dlfcn createDyld(SvcMemory svcMemory) {
        return new ArmLD64(backend, svcMemory);
    }
    @Override
    protected UnixSyscallHandler<AndroidFileIO> createSyscallHandler(SvcMemory svcMemory) {
        return new ARM64SyscallHandler(svcMemory);
    }
    private VM createDalvikVMInternal(File apkFile) {
        return new DalvikVM64(this, apkFile);
    }
    @Override
    public LibraryFile createURLibraryFile(URL url, String libName) {
        return new URLibraryFile(url, libName, -1, true);
    }
    @Override
    protected boolean isPaddingArgument() {
        return false;
    }
    private VM vm;
    @Override
    public VM createDalvikVM() {
        return createDalvikVM((File) null);
    }
    @Override
    public final VM createDalvikVM(File apkFile) {
        if (vm != null) {
            throw new IllegalStateException("vm is already created");
        }
        vm = createDalvikVMInternal(apkFile);
        return vm;
    }
    @Override
    public VM createDalvikVM(Class<?> callingClass) {
        return createDalvikVM(new File(callingClass.getProtectionDomain().getCodeSource().getLocation().getPath()));
    }
    @Override
    public final VM getDalvikVM() {
        return vm;
    }
    @Override
    public Unwinder getUnwinder() {
        return new AndroidARM64Unwinder(this);
    }
}