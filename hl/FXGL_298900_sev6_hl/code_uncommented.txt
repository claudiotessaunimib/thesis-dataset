/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.box2d.collision.AABB;
import com.almasb.fxgl.physics.box2d.collision.RayCastInput;
import com.almasb.fxgl.physics.box2d.collision.RayCastOutput;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.shapes.MassData;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.collision.shapes.ShapeType;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
/**
 * A fixture is used to attach a shape to a body for collision detection. A fixture inherits its
 * transform from its parent. Fixtures hold additional non-geometric data such as friction,
 * collision filters, etc. Fixtures are created via Body::CreateFixture.
 * Note: you cannot reuse fixtures.
 *
 * @author daniel
 */
public final class Fixture {
    private final Filter filter = new Filter();
    private final Body body;
    private final Shape shape;
    private Object userData;
    private HitBox hitBox;
    private float density;
    private float friction;
    private float restitution;
    private boolean isSensor;
    private FixtureProxy[] proxies;
    private int proxyCount = 0;
    Fixture(Body body, FixtureDef def) {
        this.body = body;
        shape = def.getShape().clone();
        userData = def.getUserData();
        density = def.getDensity();
        friction = def.getFriction();
        restitution = def.getRestitution();
        isSensor = def.isSensor();
        filter.set(def.getFilter());
        // Reserve proxy space
        int childCount = shape.getChildCount();
        proxies = new FixtureProxy[childCount];
        for (int i = 0; i < childCount; i++) {
            proxies[i] = new FixtureProxy();
        }
    }
    /**
     * @return the parent body of this fixture
     */
    public Body getBody() {
        return body;
    }
    /**
     * You can modify the child shape, however you should not change the number
     * of vertices because this will crash some collision caching mechanisms.
     *
     * @return child shape
     */
    public Shape getShape() {
        return shape;
    }
    /**
     * @return the type of the child shape. You can use this to down cast to the concrete shape.
     */
    public ShapeType getType() {
        return shape.getType();
    }
    /**
     * @return the contact filtering data
     */
    public Filter getFilterData() {
        return filter;
    }
    /**
     * Set the contact filtering data.
     * This will not update contacts until the next time step when either parent body is awake.
     * This automatically calls refilter.
     * This is an expensive operation and should not be called frequently.
     *
     * @param filter filter
     */
    public void setFilterData(final Filter filter) {
        this.filter.set(filter);
        refilter();
    }
    /**
     * The same as in the fixture definition, unless explicitly changed.
     * Use this to store your application specific data.
     *
     * @return user data
     */
    public Object getUserData() {
        return userData;
    }
    /**
     * Set the user data.
     * Use this to store your application specific data.
     *
     * @param data user data
     */
    public void setUserData(Object data) {
        userData = data;
    }
    public HitBox getHitBox() {
        return hitBox;
    }
    public void setHitBox(HitBox hitBox) {
        this.hitBox = hitBox;
    }
    public float getDensity() {
        return density;
    }
    public void setDensity(float density) {
        this.density = density;
    }
    public float getFriction() {
        return friction;
    }
    /**
     * This will <b>NOT</b> change the friction of existing contacts.
     */
    public void setFriction(float friction) {
        this.friction = friction;
    }
    public float getRestitution() {
        return restitution;
    }
    /**
     * This will <b>NOT</b> change the restitution of existing contacts.
     */
    public void setRestitution(float restitution) {
        this.restitution = restitution;
    }
    /**
     * @return true if the fixture / shape is a sensor (non-solid)
     */
    public boolean isSensor() {
        return isSensor;
    }
    /**
     * Set if this fixture is a sensor.
     */
    public void setSensor(boolean sensor) {
        if (sensor != isSensor) {
            body.setAwake(true);
            isSensor = sensor;
        }
    }
    public int getProxyCount() {
        return proxyCount;
    }
    public int getProxyId(int index) {
        return proxies[index].proxyId;
    }
    /**
     * Call this if you want to establish collision that was previously disabled by
     * ContactFilter::ShouldCollide.
     */
    public void refilter() {
        // Flag associated contacts for filtering.
        ContactEdge edge = body.getContactList();
        while (edge != null) {
            Contact contact = edge.contact;
            if (contact.getFixtureA() == this || contact.getFixtureB() == this) {
                contact.flagForFiltering();
            }
            edge = edge.next;
        }
        World world = body.getWorld();
        if (world == null) {
            return;
        }
        // Touch each proxy so that new pairs may be created
        BroadPhase broadPhase = world.getContactManager().broadPhase;
        for (int i = 0; i < proxyCount; ++i) {
            broadPhase.touchProxy(proxies[i].proxyId);
        }
    }
    /**
     * Test a point for containment in this fixture.
     * This only works for convex shapes.
     *
     * @param p a point in world coordinates
     */
    public boolean containsPoint(Vec2 p) {
        return shape.containsPoint(body.m_xf, p);
    }
    /**
     * Cast a ray against this shape.
     *
     * @param output the ray-cast results
     * @param input the ray-cast input parameters
     */
    public boolean raycast(RayCastOutput output, RayCastInput input, int childIndex) {
        return shape.raycast(output, input, body.m_xf, childIndex);
    }
    /**
     * Get the mass data for this fixture.
     * The mass data is based on the density and the shape.
     * The rotational inertia is about the shape's origin.
     */
    public void getMassData(MassData massData) {
        shape.computeMass(massData, density);
    }
    /**
     * This AABB may be enlarged and/or stale.
     * If you need a more accurate AABB, compute it using the shape and the body transform.
     *
     * @return the fixture's AABB
     */
    public AABB getAABB(int childIndex) {
        return proxies[childIndex].aabb;
    }
    /**
     * Compute the distance from this fixture.
     *
     * @param p a point in world coordinates.
     * @return distance
     */
    public float computeDistance(Vec2 p, int childIndex, Vec2 normalOut) {
        return shape.computeDistanceToOut(body.getTransform(), p, childIndex, normalOut);
    }
    // These support body activation/deactivation.
    void createProxies(BroadPhase broadPhase, final Transform xf) {
        // Create proxies in the broad-phase.
        proxyCount = shape.getChildCount();
        for (int i = 0; i < proxyCount; ++i) {
            FixtureProxy proxy = proxies[i];
            shape.computeAABB(proxy.aabb, xf, i);
            proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
            proxy.fixture = this;
            proxy.childIndex = i;
        }
    }
    void destroyProxies(BroadPhase broadPhase) {
        // Destroy proxies in the broad-phase.
        for (int i = 0; i < proxyCount; ++i) {
            FixtureProxy proxy = proxies[i];
            broadPhase.destroyProxy(proxy.proxyId);
            proxy.proxyId = BroadPhase.NULL_PROXY;
        }
        proxyCount = 0;
    }
    private final AABB pool1 = new AABB();
    private final AABB pool2 = new AABB();
    private final Vec2 displacement = new Vec2();
    void synchronize(BroadPhase broadPhase, Transform transform1, Transform transform2) {
        if (proxyCount == 0) {
            return;
        }
        for (int i = 0; i < proxyCount; ++i) {
            FixtureProxy proxy = proxies[i];
            // Compute an AABB that covers the swept shape (may miss some rotation effect).
            AABB aabb1 = pool1;
            AABB aabb2 = pool2;
            shape.computeAABB(aabb1, transform1, proxy.childIndex);
            shape.computeAABB(aabb2, transform2, proxy.childIndex);
            proxy.aabb.combine(aabb1, aabb2);
            displacement.x = transform2.p.x - transform1.p.x;
            displacement.y = transform2.p.y - transform1.p.y;
            broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);
        }
    }
    // The proxies must be destroyed before calling this.
    void destroy() {
        proxies = null;
    }
    /**
     * This proxy is used internally to connect fixtures to the broad-phase.
     */
    static class FixtureProxy {
        final AABB aabb = new AABB();
        Fixture fixture = null;
        int proxyId = BroadPhase.NULL_PROXY;
        int childIndex;
        // only we can create these
        private FixtureProxy() { }
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.collision.shapes;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.collision.AABB;
import com.almasb.fxgl.physics.box2d.collision.RayCastInput;
import com.almasb.fxgl.physics.box2d.collision.RayCastOutput;
import com.almasb.fxgl.physics.box2d.common.Transform;
/**
 * A shape is used for collision detection.
 * You can create a shape however you like.
 * Shapes used for simulation in World are created automatically when a Fixture is created.
 * Shapes may encapsulate one or more child shapes.
 */
public abstract class Shape {
    private final ShapeType type;
    private float radius;
    public Shape(ShapeType type, float radius) {
        this.type = type;
        this.radius = radius;
    }
    @Override
    public abstract Shape clone();
    /**
     * Get the type of this shape. You can use this to down cast to the concrete shape.
     *
     * @return the shape type
     */
    public ShapeType getType() {
        return type;
    }
    /**
     * The radius of the underlying shape. This can refer to different things depending on the shape
     * implementation.
     *
     * @return shape radius
     */
    public float getRadius() {
        return radius;
    }
    /**
     * Sets the radius of the underlying shape. This can refer to different things depending on the
     * implementation.
     *
     * @param radius shape radius
     */
    public void setRadius(float radius) {
        this.radius = radius;
    }
    /**
     * @return the number of child primitives
     */
    public abstract int getChildCount();
    /**
     * Test a point for containment in this shape. This only works for convex shapes.
     *
     * @param xf the shape world transform.
     * @param point a point in world coordinates.
     */
    public abstract boolean containsPoint(Transform xf, Vec2 point);
    /**
     * Cast a ray against a child shape.
     *
     * @param output the ray-cast results.
     * @param input the ray-cast input parameters.
     * @param transform the transform to be applied to the shape.
     * @param childIndex the child shape index
     * @return if hit
     */
    public abstract boolean raycast(RayCastOutput output, RayCastInput input, Transform transform,
                                    int childIndex);
    /**
     * Given a transform, compute the associated axis aligned bounding box for a child shape.
     *
     * @param aabb returns the axis aligned box
     * @param xf the world transform of the shape
     * @param childIndex the child shape index
     */
    public abstract void computeAABB(final AABB aabb, final Transform xf, int childIndex);
    /**
     * Compute the mass properties of this shape using its dimensions and density. The inertia tensor
     * is computed about the local origin.
     *
     * @param massData returns the mass data for this shape.
     * @param density the density in kilograms per meter squared.
     */
    public abstract void computeMass(final MassData massData, final float density);
    /**
     * Compute the distance from the current shape to the specified point. This only works for convex
     * shapes.
     *
     * @param xf the shape world transform.
     * @param p a point in world coordinates.
     * @param normalOut returns the direction in which the distance increases.
     * @return the distance from the current shape.
     */
    public abstract float computeDistanceToOut(Transform xf, Vec2 p, int childIndex, Vec2 normalOut);
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.core.collection.Array;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.callbacks.*;
import com.almasb.fxgl.physics.box2d.collision.AABB;
import com.almasb.fxgl.physics.box2d.collision.RayCastInput;
import com.almasb.fxgl.physics.box2d.collision.RayCastOutput;
import com.almasb.fxgl.physics.box2d.collision.TimeOfImpact.TOIInput;
import com.almasb.fxgl.physics.box2d.collision.TimeOfImpact.TOIOutput;
import com.almasb.fxgl.physics.box2d.collision.TimeOfImpact.TOIOutputState;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.broadphase.DefaultBroadPhaseBuffer;
import com.almasb.fxgl.physics.box2d.collision.broadphase.DynamicTree;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.JBoxSettings;
import com.almasb.fxgl.physics.box2d.common.Sweep;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
import com.almasb.fxgl.physics.box2d.dynamics.joints.Joint;
import com.almasb.fxgl.physics.box2d.dynamics.joints.JointDef;
import com.almasb.fxgl.physics.box2d.dynamics.joints.JointEdge;
import com.almasb.fxgl.physics.box2d.particle.*;
import com.almasb.fxgl.physics.box2d.pooling.DefaultWorldPool;
import com.almasb.fxgl.physics.box2d.pooling.IWorldPool;
/**
 * The world class manages all physics entities, dynamic simulation, and asynchronous queries.
 * The world also contains efficient memory management facilities.
 *
 * @author Daniel Murphy
 */
public final class World {
    private static final int WORLD_POOL_SIZE = 100;
    private static final int WORLD_POOL_CONTAINER_SIZE = 10;
    private final ContactManager contactManager;
    private final ParticleSystem particleSystem;
    private final IWorldPool pool;
    private DestructionListener destructionListener = null;
    private ParticleDestructionListener particleDestructionListener = null;
    private boolean newFixture = false;
    private boolean locked = false;
    private boolean autoClearForces = true;
    private boolean allowSleep = true;
    // these are for debugging the solver
    private boolean warmStarting = true;
    private boolean continuousPhysics = true;
    private boolean subStepping = false;
    private boolean stepComplete = true;
    private Array<Body> bodies = new Array<>(WORLD_POOL_SIZE);
    private Array<Joint> joints = new Array<>();
    private final Vec2 gravity = new Vec2();
    public World(Vec2 gravity) {
        this.gravity.set(gravity);
        pool = new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE);
        contactManager = new ContactManager(pool, new DefaultBroadPhaseBuffer(new DynamicTree()));
        particleSystem = new ParticleSystem(this);
    }
    /**
     * Create a rigid body given a definition.
     * No reference to the definition is retained.
     * This function is locked during callbacks.
     *
     * @param def body definition
     * @return rigid body
     */
    public Body createBody(BodyDef def) {
        assertNotLocked();
        Body b = new Body(def, this);
        bodies.add(b);
        return b;
    }
    /**
     * Destroy a rigid body.
     * This automatically deletes all associated shapes and joints.
     * This function is locked during callbacks.
     *
     * @param body body to destroy
     */
    public void destroyBody(Body body) {
        assertNotLocked();
        body.destroy();
        bodies.removeValueByIdentity(body);
        // jbox2dTODO djm recycle body
    }
    /**
     * Create a joint to constrain bodies together.
     * No reference to the definition is retained.
     * This may cause the connected bodies to cease colliding.
     * This function is locked during callbacks.
     * Note: creating a joint doesn't wake the bodies.
     *
     * @param def joint definition
     * @return joint
     */
    public <T extends Joint> T createJoint(JointDef<T> def) {
        assertNotLocked();
        T j = Joint.create(this, def);
        joints.add(j);
        // Connect to the bodies' doubly linked lists.
        j.m_edgeA.joint = j;
        j.m_edgeA.other = j.getBodyB();
        j.m_edgeA.prev = null;
        j.m_edgeA.next = j.getBodyA().m_jointList;
        if (j.getBodyA().m_jointList != null) {
            j.getBodyA().m_jointList.prev = j.m_edgeA;
        }
        j.getBodyA().m_jointList = j.m_edgeA;
        j.m_edgeB.joint = j;
        j.m_edgeB.other = j.getBodyA();
        j.m_edgeB.prev = null;
        j.m_edgeB.next = j.getBodyB().m_jointList;
        if (j.getBodyB().m_jointList != null) {
            j.getBodyB().m_jointList.prev = j.m_edgeB;
        }
        j.getBodyB().m_jointList = j.m_edgeB;
        Body bodyA = def.getBodyA();
        Body bodyB = def.getBodyB();
        // If the joint prevents collisions, then flag any contacts for filtering.
        if (!def.isBodyCollisionAllowed()) {
            flagContactsForFiltering(bodyA, bodyB);
        }
        return j;
    }
    /**
     * Destroy a joint. This may cause the connected bodies to begin colliding.
     * This function is locked during callbacks.
     *
     * @param j joint
     */
    public void destroyJoint(Joint j) {
        assertNotLocked();
        boolean collideConnected = j.getCollideConnected();
        joints.removeValueByIdentity(j);
        // Disconnect from island graph.
        Body bodyA = j.getBodyA();
        Body bodyB = j.getBodyB();
        // Wake up connected bodies.
        bodyA.setAwake(true);
        bodyB.setAwake(true);
        // Remove from body 1.
        if (j.m_edgeA.prev != null) {
            j.m_edgeA.prev.next = j.m_edgeA.next;
        }
        if (j.m_edgeA.next != null) {
            j.m_edgeA.next.prev = j.m_edgeA.prev;
        }
        if (j.m_edgeA == bodyA.m_jointList) {
            bodyA.m_jointList = j.m_edgeA.next;
        }
        j.m_edgeA.prev = null;
        j.m_edgeA.next = null;
        // Remove from body 2
        if (j.m_edgeB.prev != null) {
            j.m_edgeB.prev.next = j.m_edgeB.next;
        }
        if (j.m_edgeB.next != null) {
            j.m_edgeB.next.prev = j.m_edgeB.prev;
        }
        if (j.m_edgeB == bodyB.m_jointList) {
            bodyB.m_jointList = j.m_edgeB.next;
        }
        j.m_edgeB.prev = null;
        j.m_edgeB.next = null;
        Joint.destroy(j);
        // If the joint prevents collisions, then flag any contacts for filtering.
        if (!collideConnected) {
            flagContactsForFiltering(bodyA, bodyB);
        }
    }
    private void flagContactsForFiltering(Body bodyA, Body bodyB) {
        ContactEdge edge = bodyB.getContactList();
        while (edge != null) {
            if (edge.other == bodyA) {
                // Flag the contact for filtering at the next time step (where either body is awake).
                edge.contact.flagForFiltering();
            }
            edge = edge.next;
        }
    }
    private final TimeStep step = new TimeStep();
    /**
     * This is used to compute the time step ratio to support a variable time step.
     */
    private float dtInverse = 0;
    /**
     * Take a time step.
     * This performs collision detection, integration, and constraint solution.
     *
     * @param dt the amount of time to simulate, this should not vary
     * @param velocityIterations for the velocity constraint solver
     * @param positionIterations for the position constraint solver
     */
    public void step(float dt, int velocityIterations, int positionIterations) {
        // If new fixtures were added, we need to find the new contacts.
        if (newFixture) {
            contactManager.findNewContacts();
            newFixture = false;
        }
        locked = true;
        step.dt = dt;
        step.velocityIterations = velocityIterations;
        step.positionIterations = positionIterations;
        if (dt > 0.0f) {
            step.inv_dt = 1.0f / dt;
        } else {
            step.inv_dt = 0.0f;
        }
        step.dtRatio = dtInverse * dt;
        step.warmStarting = warmStarting;
        // Update contacts. This is where some contacts are destroyed.
        contactManager.collide();
        if (step.dt > 0) {
            if (stepComplete) {
                // Integrate velocities, solve velocity constraints, and integrate positions
                particleSystem.solve(step); // Particle Simulation
                solve(step);
            }
            if (continuousPhysics) {
                // Handle TOI events.
                solveTOI(step);
            }
            dtInverse = step.inv_dt;
        }
        if (isAutoClearForces()) {
            clearForces();
        }
        locked = false;
    }
    private final Island island = new Island();
    private Body[] stack = new Body[10];
    private void solve(TimeStep step) {
        // update previous transforms
        for (Body b : bodies) {
            b.m_xf0.set(b.m_xf);
        }
        // Size the island for the worst case.
        island.init(getBodyCount(), contactManager.contactCount, getJointCount(), contactManager.getContactListener());
        // Clear all the island flags.
        for (Body b : bodies) {
            b.setIslandFlag(false);
        }
        for (Contact c = contactManager.contactList; c != null; c = c.m_next) {
            c.m_flags &= ~Contact.ISLAND_FLAG;
        }
        for (Joint j : joints) {
            j.m_islandFlag = false;
        }
        // Build and simulate all awake islands.
        int stackSize = getBodyCount();
        if (stack.length < stackSize) {
            stack = new Body[stackSize];
        }
        for (Body seed : bodies) {
            if (seed.isIslandFlagOn2()) {
                continue;
            }
            if (!seed.isAwake() || !seed.isActive()) {
                continue;
            }
            // The seed can be dynamic or kinematic.
            if (seed.getType() == BodyType.STATIC) {
                continue;
            }
            // Reset island and stack.
            island.clear();
            int stackCount = 0;
            stack[stackCount++] = seed;
            seed.setIslandFlag(true);
            // Perform a depth first search (DFS) on the constraint graph.
            while (stackCount > 0) {
                // Grab the next body off the stack and add it to the island.
                Body b = stack[--stackCount];
                island.add(b);
                // Make sure the body is awake.
                b.setAwake(true);
                // To keep islands as small as possible, we don't
                // propagate islands across static bodies.
                if (b.getType() == BodyType.STATIC) {
                    continue;
                }
                // Search all contacts connected to this body.
                for (ContactEdge ce = b.m_contactList; ce != null; ce = ce.next) {
                    Contact contact = ce.contact;
                    // Has this contact already been added to an island?
                    if ((contact.m_flags & Contact.ISLAND_FLAG) == Contact.ISLAND_FLAG) {
                        continue;
                    }
                    // Is this contact solid and touching?
                    if (!contact.isEnabled() || !contact.isTouching()) {
                        continue;
                    }
                    // Skip sensors.
                    boolean sensorA = contact.m_fixtureA.isSensor();
                    boolean sensorB = contact.m_fixtureB.isSensor();
                    if (sensorA || sensorB) {
                        continue;
                    }
                    island.add(contact);
                    contact.m_flags |= Contact.ISLAND_FLAG;
                    Body other = ce.other;
                    // Was the other body already added to this island?
                    if (other.isIslandFlagOn2()) {
                        continue;
                    }
                    assert stackCount < stackSize;
                    stack[stackCount++] = other;
                    other.setIslandFlag(true);
                }
                // Search all joints connect to this body.
                for (JointEdge je = b.m_jointList; je != null; je = je.next) {
                    if (je.joint.m_islandFlag) {
                        continue;
                    }
                    Body other = je.other;
                    // Don't simulate joints connected to inactive bodies.
                    if (!other.isActive()) {
                        continue;
                    }
                    island.add(je.joint);
                    je.joint.m_islandFlag = true;
                    if (other.isIslandFlagOn2()) {
                        continue;
                    }
                    assert stackCount < stackSize;
                    stack[stackCount++] = other;
                    other.setIslandFlag(true);
                }
            }
            island.solve(step, gravity, allowSleep);
            island.postSolveCleanup();
        }
        // Synchronize fixtures, check for out of range bodies.
        for (Body b : bodies) {
            // If a body was not in an island then it did not move.
            if (b.isIslandFlagOff()) {
                continue;
            }
            if (b.getType() == BodyType.STATIC) {
                continue;
            }
            // Update fixtures (for broad-phase).
            b.synchronizeFixtures();
        }
        // Look for new contacts.
        contactManager.findNewContacts();
    }
    private final Island toiIsland = new Island();
    private final TOIInput toiInput = new TOIInput();
    private final TOIOutput toiOutput = new TOIOutput();
    private final TimeStep subStep = new TimeStep();
    private final Body[] tempBodies = new Body[2];
    private final Sweep backup1 = new Sweep();
    private final Sweep backup2 = new Sweep();
    private void solveTOI(final TimeStep step) {
        final Island island = toiIsland;
        island.init(2 * JBoxSettings.maxTOIContacts, JBoxSettings.maxTOIContacts, 0, contactManager.getContactListener());
        if (stepComplete) {
            for (Body b : bodies) {
                b.setIslandFlag(false);
                b.m_sweep.alpha0 = 0.0f;
            }
            for (Contact c = contactManager.contactList; c != null; c = c.m_next) {
                // Invalidate TOI
                c.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);
                c.m_toiCount = 0;
                c.m_toi = 1.0f;
            }
        }
        // Find TOI events and solve them.
        for (; ; ) {
            // Find the first TOI.
            Contact minContact = null;
            float minAlpha = 1.0f;
            for (Contact c = contactManager.contactList; c != null; c = c.m_next) {
                // Is this contact disabled?
                if (!c.isEnabled()) {
                    continue;
                }
                // Prevent excessive sub-stepping.
                if (c.m_toiCount > JBoxSettings.maxSubSteps) {
                    continue;
                }
                float alpha = 1.0f;
                if ((c.m_flags & Contact.TOI_FLAG) != 0) {
                    // This contact has a valid cached TOI.
                    alpha = c.m_toi;
                } else {
                    Fixture fA = c.getFixtureA();
                    Fixture fB = c.getFixtureB();
                    // Is there a sensor?
                    if (fA.isSensor() || fB.isSensor()) {
                        continue;
                    }
                    Body bA = fA.getBody();
                    Body bB = fB.getBody();
                    BodyType typeA = bA.getType();
                    BodyType typeB = bB.getType();
                    assert typeA == BodyType.DYNAMIC || typeB == BodyType.DYNAMIC;
                    boolean activeA = bA.isAwake() && typeA != BodyType.STATIC;
                    boolean activeB = bB.isAwake() && typeB != BodyType.STATIC;
                    // Is at least one body active (awake and dynamic or kinematic)?
                    if (!activeA && !activeB) {
                        continue;
                    }
                    boolean collideA = bA.isBullet() || typeA != BodyType.DYNAMIC;
                    boolean collideB = bB.isBullet() || typeB != BodyType.DYNAMIC;
                    // Are these two non-bullet dynamic bodies?
                    if (!collideA && !collideB) {
                        continue;
                    }
                    // Compute the TOI for this contact.
                    // Put the sweeps onto the same time interval.
                    float alpha0 = bA.m_sweep.alpha0;
                    if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
                        alpha0 = bB.m_sweep.alpha0;
                        bA.m_sweep.advance(alpha0);
                    } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
                        alpha0 = bA.m_sweep.alpha0;
                        bB.m_sweep.advance(alpha0);
                    }
                    assert alpha0 < 1.0f;
                    int indexA = c.getChildIndexA();
                    int indexB = c.getChildIndexB();
                    // Compute the time of impact in interval [0, minTOI]
                    final TOIInput input = toiInput;
                    input.setProxyA(fA.getShape(), indexA);
                    input.setProxyB(fB.getShape(), indexB);
                    input.sweepA.set(bA.m_sweep);
                    input.sweepB.set(bB.m_sweep);
                    input.tMax = 1.0f;
                    pool.getTimeOfImpact().timeOfImpact(toiOutput, input);
                    // Beta is the fraction of the remaining portion of the .
                    float beta = toiOutput.t;
                    if (toiOutput.state == TOIOutputState.TOUCHING) {
                        alpha = Math.min(alpha0 + (1.0f - alpha0) * beta, 1.0f);
                    } else {
                        alpha = 1.0f;
                    }
                    c.m_toi = alpha;
                    c.m_flags |= Contact.TOI_FLAG;
                }
                if (alpha < minAlpha) {
                    // This is the minimum TOI found so far.
                    minContact = c;
                    minAlpha = alpha;
                }
            }
            if (minContact == null || 1.0f - 10.0f * JBoxSettings.EPSILON < minAlpha) {
                // No more TOI events. Done!
                stepComplete = true;
                break;
            }
            // Advance the bodies to the TOI.
            Fixture fA = minContact.getFixtureA();
            Fixture fB = minContact.getFixtureB();
            Body bA = fA.getBody();
            Body bB = fB.getBody();
            backup1.set(bA.m_sweep);
            backup2.set(bB.m_sweep);
            bA.advance(minAlpha);
            bB.advance(minAlpha);
            // The TOI contact likely has some new contact points.
            minContact.update(contactManager.getContactListener());
            minContact.m_flags &= ~Contact.TOI_FLAG;
            ++minContact.m_toiCount;
            // Is the contact solid?
            if (!minContact.isEnabled() || !minContact.isTouching()) {
                // Restore the sweeps.
                minContact.setEnabled(false);
                bA.m_sweep.set(backup1);
                bB.m_sweep.set(backup2);
                bA.synchronizeTransform();
                bB.synchronizeTransform();
                continue;
            }
            bA.setAwake(true);
            bB.setAwake(true);
            // Build the island
            island.clear();
            island.add(bA);
            island.add(bB);
            island.add(minContact);
            bA.setIslandFlag(true);
            bB.setIslandFlag(true);
            minContact.m_flags |= Contact.ISLAND_FLAG;
            // Get contacts on bodyA and bodyB.
            tempBodies[0] = bA;
            tempBodies[1] = bB;
            for (int i = 0; i < 2; ++i) {
                Body body = tempBodies[i];
                if (body.getType() == BodyType.DYNAMIC) {
                    for (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {
                        if (island.isBodyCountEqualToCapacity()) {
                            break;
                        }
                        if (island.isContactCountEqualToCapacity()) {
                            break;
                        }
                        Contact contact = ce.contact;
                        // Has this contact already been added to the island?
                        if ((contact.m_flags & Contact.ISLAND_FLAG) != 0) {
                            continue;
                        }
                        // Only add static, kinematic, or bullet bodies.
                        Body other = ce.other;
                        if (other.getType() == BodyType.DYNAMIC && !body.isBullet() && !other.isBullet()) {
                            continue;
                        }
                        // Skip sensors.
                        boolean sensorA = contact.m_fixtureA.isSensor();
                        boolean sensorB = contact.m_fixtureB.isSensor();
                        if (sensorA || sensorB) {
                            continue;
                        }
                        // Tentatively advance the body to the TOI.
                        backup1.set(other.m_sweep);
                        if (other.isIslandFlagOff()) {
                            other.advance(minAlpha);
                        }
                        // Update the contact points
                        contact.update(contactManager.getContactListener());
                        // Was the contact disabled by the user?
                        if (!contact.isEnabled()) {
                            other.m_sweep.set(backup1);
                            other.synchronizeTransform();
                            continue;
                        }
                        // Are there contact points?
                        if (!contact.isTouching()) {
                            other.m_sweep.set(backup1);
                            other.synchronizeTransform();
                            continue;
                        }
                        // Add the contact to the island
                        contact.m_flags |= Contact.ISLAND_FLAG;
                        island.add(contact);
                        // Has the other body already been added to the island?
                        if (other.isIslandFlagOn()) {
                            continue;
                        }
                        // Add the other body to the island.
                        other.setIslandFlag(true);
                        if (other.getType() != BodyType.STATIC) {
                            other.setAwake(true);
                        }
                        island.add(other);
                    }
                }
            }
            subStep.dt = (1.0f - minAlpha) * step.dt;
            subStep.inv_dt = 1.0f / subStep.dt;
            subStep.dtRatio = 1.0f;
            subStep.positionIterations = 20;
            subStep.velocityIterations = step.velocityIterations;
            subStep.warmStarting = false;
            island.solveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);
            island.resetFlagsAndSynchronizeBroadphaseProxies();
            // Commit fixture proxy movements to the broad-phase so that new contacts are created.
            // Also, some contacts can be destroyed.
            contactManager.findNewContacts();
            if (subStepping) {
                stepComplete = false;
                break;
            }
        }
    }
    private final WorldQueryWrapper wqwrapper = new WorldQueryWrapper();
    /**
     * Query the world for all fixtures and particles that potentially overlap the provided AABB.
     *
     * @param callback a user implemented callback class
     * @param particleCallback callback for particles
     * @param aabb the query box
     */
    public void queryAABB(QueryCallback callback, ParticleQueryCallback particleCallback, AABB aabb) {
        queryAABB(callback, aabb);
        queryAABB(particleCallback, aabb);
    }
    /**
     * Query the world for all fixtures that potentially overlap the provided AABB.
     *
     * @param callback a user implemented callback class
     * @param aabb the query box
     */
    public void queryAABB(QueryCallback callback, AABB aabb) {
        wqwrapper.broadPhase = contactManager.broadPhase;
        wqwrapper.callback = callback;
        contactManager.broadPhase.query(wqwrapper, aabb);
    }
    /**
     * Query the world for all particles that potentially overlap the provided AABB.
     *
     * @param particleCallback callback for particles
     * @param aabb the query box
     */
    public void queryAABB(ParticleQueryCallback particleCallback, AABB aabb) {
        particleSystem.queryAABB(particleCallback, aabb);
    }
    private final WorldRayCastWrapper wrcwrapper = new WorldRayCastWrapper();
    private final RayCastInput input = new RayCastInput();
    /**
     * Ray-cast the world for all fixtures and particles in the path of the ray.
     * Your callback controls whether you get the closest point, any point, or n-points.
     * The ray-cast ignores shapes that contain the starting point.
     *
     * @param callback a user implemented callback class
     * @param particleCallback the particle callback class
     * @param point1 the ray starting point
     * @param point2 the ray ending point
     */
    public void raycast(RayCastCallback callback, ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {
        raycast(callback, point1, point2);
        raycast(particleCallback, point1, point2);
    }
    /**
     * Ray-cast the world for all fixtures in the path of the ray.
     * Your callback controls whether you get the closest point, any point, or n-points.
     * The ray-cast ignores shapes that contain the starting point.
     *
     * @param callback a user implemented callback class
     * @param point1 the ray starting point
     * @param point2 the ray ending point
     */
    public void raycast(RayCastCallback callback, Vec2 point1, Vec2 point2) {
        wrcwrapper.broadPhase = contactManager.broadPhase;
        wrcwrapper.callback = callback;
        input.maxFraction = 1.0f;
        input.p1.set(point1);
        input.p2.set(point2);
        contactManager.broadPhase.raycast(wrcwrapper, input);
    }
    /**
     * Ray-cast the world for all particles in the path of the ray.
     * Your callback controls whether you get the closest point, any point, or n-points.
     *
     * @param particleCallback the particle callback class
     * @param point1 the ray starting point
     * @param point2 the ray ending point
     */
    public void raycast(ParticleRaycastCallback particleCallback, Vec2 point1, Vec2 point2) {
        particleSystem.raycast(particleCallback, point1, point2);
    }
    /**
     * Call this after you are done with time steps to clear the forces.
     * You normally call this after each call to Step, unless you are performing sub-steps.
     * By default, forces will be automatically cleared, so you don't need to call this function.
     *
     * @see #setAutoClearForces(boolean)
     */
    public void clearForces() {
        for (Body body : bodies) {
            body.clearForces();
        }
    }
    /**
     * Create a particle whose properties have been defined. No reference to the definition is
     * retained. A simulation step must occur before it's possible to interact with a newly created
     * particle. For example, DestroyParticleInShape() will not destroy a particle until Step() has
     * been called. This function is locked during callbacks.
     *
     * @return the index of the particle.
     */
    public int createParticle(ParticleDef def) {
        assertNotLocked();
        return particleSystem.createParticle(def);
    }
    /**
     * Destroy a particle. The particle is removed after the next step.
     *
     * @param index particle index
     */
    public void destroyParticle(int index) {
        destroyParticle(index, false);
    }
    /**
     * Destroy a particle. The particle is removed after the next step.
     *
     * @param index of the particle to destroy
     * @param callDestructionListener whether to call the destruction listener just before the particle is destroyed
     */
    public void destroyParticle(int index, boolean callDestructionListener) {
        particleSystem.destroyParticle(index, callDestructionListener);
    }
    /**
     * Destroy particles inside a shape without enabling the destruction callback for destroyed
     * particles. This function is locked during callbacks. For more information see
     * DestroyParticleInShape(Shape&, Transform&,bool).
     * This function is locked during callbacks.
     *
     * @param shape which encloses particles that should be destroyed.
     * @param xf transform applied to the shape.
     * @return Number of particles destroyed.
     */
    public int destroyParticlesInShape(Shape shape, Transform xf) {
        return destroyParticlesInShape(shape, xf, false);
    }
    /**
     * Destroy particles inside a shape. This function is locked during callbacks. In addition, this
     * function immediately destroys particles in the shape in contrast to DestroyParticle() which
     * defers the destruction until the next simulation step. This function is locked during callbacks.
     *
     * @param shape which encloses particles that should be destroyed.
     * @param xf transform applied to the shape.
     * @param callDestructionListener whether to call the world b2DestructionListener for each particle destroyed.
     * @return Number of particles destroyed.
     */
    public int destroyParticlesInShape(Shape shape, Transform xf, boolean callDestructionListener) {
        assertNotLocked();
        return particleSystem.destroyParticlesInShape(shape, xf, callDestructionListener);
    }
    /**
     * Create a particle group whose properties have been defined. No reference to the definition is
     * retained. This function is locked during callbacks.
     *
     * @param def particle group definition
     * @return particle group
     */
    public ParticleGroup createParticleGroup(ParticleGroupDef def) {
        assertNotLocked();
        return particleSystem.createParticleGroup(def);
    }
    /**
     * Join two particle groups. This function is locked during callbacks.
     *
     * @param groupA the first group. Expands to encompass the second group.
     * @param groupB the second group. It is destroyed.
     */
    public void joinParticleGroups(ParticleGroup groupA, ParticleGroup groupB) {
        assertNotLocked();
        particleSystem.joinParticleGroups(groupA, groupB);
    }
    /**
     * Destroy particles in a group. This function is locked during callbacks.
     *
     * @param group the particle group to destroy.
     * @param callDestructionListener Whether to call the world b2DestructionListener for each particle is destroyed.
     */
    public void destroyParticlesInGroup(ParticleGroup group, boolean callDestructionListener) {
        assertNotLocked();
        particleSystem.destroyParticlesInGroup(group, callDestructionListener);
    }
    /**
     * Destroy particles in a group without enabling the destruction callback for destroyed particles.
     * This function is locked during callbacks.
     *
     * @param group the particle group to destroy.
     */
    public void destroyParticlesInGroup(ParticleGroup group) {
        destroyParticlesInGroup(group, false);
    }
    /**
     * Get the world particle group list. With the returned group, use ParticleGroup::GetNext to get
     * the next group in the world list. A NULL group indicates the end of the list.
     *
     * @return the head of the world particle group list.
     */
    public ParticleGroup[] getParticleGroupList() {
        return particleSystem.getParticleGroupList();
    }
    /**
     * @return the number of particle groups
     */
    public int getParticleGroupCount() {
        return particleSystem.getParticleGroupCount();
    }
    /**
     * @return the number of particles
     */
    public int getParticleCount() {
        return particleSystem.getParticleCount();
    }
    /**
     * @return the maximum number of particles
     */
    public int getParticleMaxCount() {
        return particleSystem.getParticleMaxCount();
    }
    /**
     * Set the maximum number of particles.
     *
     * @param count number
     */
    public void setParticleMaxCount(int count) {
        particleSystem.setParticleMaxCount(count);
    }
    /**
     * Change the particle density.
     *
     * @param density particle density
     */
    public void setParticleDensity(float density) {
        particleSystem.setParticleDensity(density);
    }
    /**
     * @return the particle density
     */
    public float getParticleDensity() {
        return particleSystem.getParticleDensity();
    }
    /**
     * Change the particle gravity scale. Adjusts the effect of the global gravity vector on
     * particles. Default value is 1.0f.
     *
     * @param gravityScale gravity scale
     */
    public void setParticleGravityScale(float gravityScale) {
        particleSystem.setParticleGravityScale(gravityScale);
    }
    /**
     * @return the particle gravity scale
     */
    public float getParticleGravityScale() {
        return particleSystem.getParticleGravityScale();
    }
    /**
     * Damping is used to reduce the velocity of particles. The damping parameter can be larger than
     * 1.0f but the damping effect becomes sensitive to the time step when the damping parameter is
     * large.
     *
     * @param damping particle damping
     */
    public void setParticleDamping(float damping) {
        particleSystem.setParticleDamping(damping);
    }
    /**
     * @return damping for particles
     */
    public float getParticleDamping() {
        return particleSystem.getParticleDamping();
    }
    /**
     * Change the particle radius. You should set this only once, on world start. If you change the
     * radius during execution, existing particles may explode, shrink, or behave unexpectedly.
     *
     * @param radius particle radius
     */
    public void setParticleRadius(float radius) {
        particleSystem.setParticleRadius(radius);
    }
    /**
     * @return the particle radius
     */
    public float getParticleRadius() {
        return particleSystem.getParticleRadius();
    }
    /**
     * Get the particle data. Returns the pointer to the head of the particle data.
     *
     * @return particle flags buffer
     */
    public int[] getParticleFlagsBuffer() {
        return particleSystem.getParticleFlagsBuffer();
    }
    public Vec2[] getParticlePositionBuffer() {
        return particleSystem.getParticlePositionBuffer();
    }
    public Vec2[] getParticleVelocityBuffer() {
        return particleSystem.getParticleVelocityBuffer();
    }
    public ParticleColor[] getParticleColorBuffer() {
        return particleSystem.getParticleColorBuffer();
    }
    public ParticleGroup[] getParticleGroupBuffer() {
        return particleSystem.getParticleGroupBuffer();
    }
    public Object[] getParticleUserDataBuffer() {
        return particleSystem.getParticleUserDataBuffer();
    }
    /**
     * @return contacts between particles
     */
    public ParticleContact[] getParticleContacts() {
        return particleSystem.m_contactBuffer;
    }
    public int getParticleContactCount() {
        return particleSystem.m_contactCount;
    }
    /**
     * @return contacts between particles and bodies
     */
    public ParticleBodyContact[] getParticleBodyContacts() {
        return particleSystem.m_bodyContactBuffer;
    }
    public int getParticleBodyContactCount() {
        return particleSystem.m_bodyContactCount;
    }
    /**
     * @return the kinetic energy that can be lost by damping force
     */
    public float computeParticleCollisionEnergy() {
        return particleSystem.computeParticleCollisionEnergy();
    }
    /**
     * DO NOT MODIFY.
     *
     * @return all world bodies
     */
    public Array<Body> getBodies() {
        return bodies;
    }
    /**
     * Get the world contact list. With the returned contact, use Contact.getNext to get the next
     * contact in the world list. A null contact indicates the end of the list.
     * Contacts are created and destroyed in the middle of a time step.
     * Use ContactListener to avoid missing contacts.
     *
     * @return the head of the world contact list.
     */
    public Contact getContactList() {
        return contactManager.contactList;
    }
    public boolean isSleepingAllowed() {
        return allowSleep;
    }
    public void setSleepingAllowed(boolean sleepingAllowed) {
        allowSleep = sleepingAllowed;
    }
    /**
     * Enable/disable warm starting. For testing.
     *
     * @param flag warm starting flag
     */
    public void setWarmStarting(boolean flag) {
        warmStarting = flag;
    }
    public boolean isWarmStarting() {
        return warmStarting;
    }
    /**
     * Enable/disable continuous physics. For testing.
     *
     * @param flag continuous physics flag
     */
    public void setContinuousPhysics(boolean flag) {
        continuousPhysics = flag;
    }
    public boolean isContinuousPhysics() {
        return continuousPhysics;
    }
    /**
     * @return the number of bodies
     */
    public int getBodyCount() {
        return bodies.size();
    }
    /**
     * @return the number of joints
     */
    public int getJointCount() {
        return joints.size();
    }
    /**
     * @return the number of contacts (each may have 0 or more contact points)
     */
    public int getContactCount() {
        return contactManager.contactCount;
    }
    /**
     * Change the global gravity vector.
     *
     * @param gravity gravity vector
     */
    public void setGravity(Vec2 gravity) {
        this.gravity.set(gravity);
    }
    /**
     * @return global gravity vector
     */
    public Vec2 getGravity() {
        return gravity;
    }
    ContactManager getContactManager() {
        return contactManager;
    }
    public IWorldPool getPool() {
        return pool;
    }
    public DestructionListener getDestructionListener() {
        return destructionListener;
    }
    /**
     * Register a destruction listener. The listener is owned by you and must remain in scope.
     *
     * @param listener destruction listener
     */
    public void setDestructionListener(DestructionListener listener) {
        destructionListener = listener;
    }
    public ParticleDestructionListener getParticleDestructionListener() {
        return particleDestructionListener;
    }
    public void setParticleDestructionListener(ParticleDestructionListener listener) {
        particleDestructionListener = listener;
    }
    public boolean isAllowSleep() {
        return allowSleep;
    }
    public void setAllowSleep(boolean flag) {
        if (flag == allowSleep) {
            return;
        }
        allowSleep = flag;
        if (!allowSleep) {
            for (Body b : bodies) {
                b.setAwake(true);
            }
        }
    }
    public void setSubStepping(boolean subStepping) {
        this.subStepping = subStepping;
    }
    public boolean isSubStepping() {
        return subStepping;
    }
    public ParticleSystem getParticleSystem() {
        return particleSystem;
    }
    /**
     * Set flag to control automatic clearing of forces after each time step.
     *
     * @param flag automatically clear forces flag
     */
    public void setAutoClearForces(boolean flag) {
        autoClearForces = flag;
    }
    /**
     * @return the flag that controls automatic clearing of forces after each time step
     */
    public boolean isAutoClearForces() {
        return autoClearForces;
    }
    /**
     * Register a contact filter to provide specific control over collision.
     * Otherwise the default filter is used (_defaultFilter).
     * The listener is owned by you and must remain in scope.
     *
     * @param filter contact filter
     */
    public void setContactFilter(ContactFilter filter) {
        contactManager.setContactFilter(filter);
    }
    /**
     * Register a contact event listener. The listener is owned by you and must remain in scope.
     *
     * @param listener contact listener
     */
    public void setContactListener(ContactListener listener) {
        contactManager.setContactListener(listener);
    }
    void notifyNewFixture() {
        newFixture = true;
    }
    /**
     * @return is the world locked (in the middle of a time step)
     */
    public boolean isLocked() {
        return locked;
    }
    void assertNotLocked() {
        if (isLocked())
            throw new IllegalStateException("Physics world is locked during time step");
    }
    private static class WorldQueryWrapper implements TreeCallback {
        BroadPhase broadPhase;
        QueryCallback callback;
        @Override
        public boolean treeCallback(int nodeId) {
            Fixture.FixtureProxy proxy = (Fixture.FixtureProxy) broadPhase.getUserData(nodeId);
            return callback.reportFixture(proxy.fixture);
        }
    }
    private static class WorldRayCastWrapper implements TreeRayCastCallback {
        // djm pooling
        private final RayCastOutput output = new RayCastOutput();
        private final Vec2 temp = new Vec2();
        private final Vec2 point = new Vec2();
        BroadPhase broadPhase;
        RayCastCallback callback;
        @Override
        public float raycastCallback(RayCastInput input, int nodeId) {
            Object userData = broadPhase.getUserData(nodeId);
            Fixture.FixtureProxy proxy = (Fixture.FixtureProxy) userData;
            Fixture fixture = proxy.fixture;
            int index = proxy.childIndex;
            boolean hit = fixture.raycast(output, input, index);
            if (hit) {
                float fraction = output.fraction;
                // Vec2 point = (1.0f - fraction) * input.p1 + fraction * input.p2;
                temp.set(input.p2).mulLocal(fraction);
                point.set(input.p1).mulLocal(1 - fraction).addLocal(temp);
                return callback.reportFixture(fixture, point, output.normal, fraction);
            }
            return input.maxFraction;
        }
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.collision;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.JBoxSettings;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.pooling.IWorldPool;
/**
 * @author Almas Baimagambetov (almaslvl@gmail.com)
 */
public final class GenericCollision {
    private static final DistanceInput input = new DistanceInput();
    private static final Distance.SimplexCache cache = new Distance.SimplexCache();
    private static final DistanceOutput output = new DistanceOutput();
    /**
     * @return true if two generic shapes (shapeA and shapeB) overlap
     */
    public static boolean testOverlap(
            IWorldPool pool,
            Shape shapeA, int indexA,
            Shape shapeB, int indexB,
            Transform xfA, Transform xfB) {
        input.proxyA.set(shapeA, indexA);
        input.proxyB.set(shapeB, indexB);
        input.transformA.set(xfA);
        input.transformB.set(xfB);
        input.useRadii = true;
        cache.count = 0;
        pool.getDistance().distance(output, cache, input);
        return output.distance < 10.0f * JBoxSettings.EPSILON;
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.common;
import com.almasb.fxgl.core.math.Vec2;
import java.io.Serializable;
/**
 * A transform contains translation and rotation. It is used to represent the position and
 * orientation of rigid frames.
 */
public final class Transform implements Serializable {
    private static final long serialVersionUID = 1L;
    /** The translation caused by the transform */
    public final Vec2 p = new Vec2();
    /** A matrix representing a rotation */
    public final Rotation q = new Rotation();
    /** Set this to equal another transform. */
    public Transform set(final Transform xf) {
        p.set(xf.p);
        q.set(xf.q);
        return this;
    }
    /**
     * Set this based on the position and angle.
     */
    public void set(Vec2 p, float angle) {
        this.p.set(p);
        q.set(angle);
    }
    /** Set this to the identity transform. */
    public void setIdentity() {
        p.setZero();
        q.setIdentity();
    }
    /**
     * @param v the vector to transform
     * @return x of the vector rotated and translated by this transform
     */
    public float mulX(Vec2 v) {
        return q.c * v.x - q.s * v.y + p.x;
    }
    /**
     * @param v the vector to transform
     * @return y of the vector rotated and translated by this transform
     */
    public float mulY(Vec2 v) {
        return q.s * v.x + q.c * v.y + p.y;
    }
    public void shift(Vec2 v) {
        p.x -= q.c * v.x - q.s * v.y;
        p.y -= q.s * v.x + q.c * v.y;
    }
    public static Vec2 mul(Transform T, Vec2 v) {
        return new Vec2(T.q.c * v.x - T.q.s * v.y + T.p.x, T.q.s * v.x + T.q.c * v.y + T.p.y);
    }
    public static void mulToOut(Transform T, Vec2 v, Vec2 out) {
        float tempy = T.q.s * v.x + T.q.c * v.y + T.p.y;
        out.x = T.q.c * v.x - T.q.s * v.y + T.p.x;
        out.y = tempy;
    }
    public static void mulToOutUnsafe(Transform T, Vec2 v, Vec2 out) {
        assert v != out;
        out.x = T.q.c * v.x - T.q.s * v.y + T.p.x;
        out.y = T.q.s * v.x + T.q.c * v.y + T.p.y;
    }
    public static void mulTransToOut(Transform T, Vec2 v, Vec2 out) {
        float px = v.x - T.p.x;
        float py = v.y - T.p.y;
        float tempy = -T.q.s * px + T.q.c * py;
        out.x = T.q.c * px + T.q.s * py;
        out.y = tempy;
    }
    public static void mulTransToOutUnsafe(Transform T, Vec2 v, Vec2 out) {
        assert v != out;
        float px = v.x - T.p.x;
        float py = v.y - T.p.y;
        out.x = T.q.c * px + T.q.s * py;
        out.y = -T.q.s * px + T.q.c * py;
    }
    public static void mulToOut(Transform A, Transform B, Transform out) {
        assert out != A;
        Rotation.mul(A.q, B.q, out.q);
        Rotation.mulToOut(A.q, B.p, out.p);
        out.p.addLocal(A.p);
    }
    private static Vec2 pool = new Vec2();
    public static void mulTransToOutUnsafe(Transform A, Transform B,
                                                 Transform out) {
        assert out != A;
        assert out != B;
        Rotation.mulTransUnsafe(A.q, B.q, out.q);
        pool.set(B.p).subLocal(A.p);
        Rotation.mulTransUnsafe(A.q, pool, out.p);
    }
    @Override
    public String toString() {
        String s = "XForm:\n";
        s += "Position: " + p + "\n";
        s += "R: \n" + q + "\n";
        return s;
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.shapes.MassData;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.Rotation;
import com.almasb.fxgl.physics.box2d.common.Sweep;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
import com.almasb.fxgl.physics.box2d.dynamics.joints.JointEdge;
import java.util.ArrayList;
import java.util.List;
/**
 * A rigid body.
 * These are created via World.createBody.
 *
 * @author Daniel Murphy
 */
public final class Body {
    private static final int e_islandFlag = 0x0001;
    private static final int e_awakeFlag = 0x0002;
    private static final int e_bulletFlag = 0x0008;
    private static final int e_fixedRotationFlag = 0x0010;
    private static final int e_activeFlag = 0x0020;
    private final World world;
    private BodyType type;
    private List<Fixture> fixtures = new ArrayList<>();
    public JointEdge m_jointList = null;
    public ContactEdge m_contactList = null;
    public int m_flags = 0;
    private boolean isSleepingAllowed = false;
    public int m_islandIndex;
    /**
     * The body origin transform.
     */
    public final Transform m_xf = new Transform();
    /**
     * The previous transform for particle simulation
     */
    public final Transform m_xf0 = new Transform();
    /**
     * The swept motion for CCD
     */
    public final Sweep m_sweep = new Sweep();
    private final Vec2 linearVelocity = new Vec2();
    private float angularVelocity;
    private final Vec2 m_force = new Vec2();
    private float m_torque = 0;
    private float m_mass;
    public float m_invMass;
    // Rotational inertia about the center of mass.
    private float m_I = 0;
    public float m_invI = 0;
    private float linearDamping;
    private float angularDamping;
    private float gravityScale;
    private float sleepTime = 0;
    private final BroadPhase broadPhase;
    private Object userData;
    private Entity entity;
    Body(BodyDef bd, World world) {
        checkValid(bd);
        this.world = world;
        broadPhase = world.getContactManager().broadPhase;
        userData = bd.getUserData();
        if (bd.isBullet()) {
            m_flags |= e_bulletFlag;
        }
        if (bd.isFixedRotation()) {
            m_flags |= e_fixedRotationFlag;
        }
        if (bd.isAllowSleep()) {
            isSleepingAllowed = true;
        }
        if (bd.isAwake()) {
            m_flags |= e_awakeFlag;
        }
        if (bd.isActive()) {
            m_flags |= e_activeFlag;
        }
        m_xf.p.set(bd.getPosition());
        m_xf.q.set(bd.getAngle());
        m_sweep.localCenter.setZero();
        m_sweep.c0.set(m_xf.p);
        m_sweep.c.set(m_xf.p);
        m_sweep.a0 = bd.getAngle();
        m_sweep.a = bd.getAngle();
        m_sweep.alpha0 = 0.0f;
        linearVelocity.set(bd.getLinearVelocity());
        angularVelocity = bd.getAngularVelocity();
        linearDamping = bd.getLinearDamping();
        angularDamping = bd.getAngularDamping();
        gravityScale = bd.getGravityScale();
        type = bd.getType();
        if (type == BodyType.DYNAMIC) {
            m_mass = 1f;
            m_invMass = 1f;
        } else {
            m_mass = 0f;
            m_invMass = 0f;
        }
    }
    private void checkValid(BodyDef def) {
        if (def.getGravityScale() < 0)
            throw new IllegalArgumentException("Gravity scale is invalid");
        if (def.getAngularDamping() < 0)
            throw new IllegalArgumentException("Angular damping is invalid");
        if (def.getLinearDamping() < 0)
            throw new IllegalArgumentException("Linear damping is invalid");
    }
    public float getTorque() {
        return m_torque;
    }
    public void setTorque(float torque) {
        m_torque = torque;
    }
    /**
     * Set entity to which this body belongs.
     */
    public void setEntity(Entity entity) {
        this.entity = entity;
    }
    /**
     * @return entity to which this body belongs
     */
    public Entity getEntity() {
        return entity;
    }
    /**
     * @return reference to the underlying list of fixtures attached to this body
     */
    public List<Fixture> getFixtures() {
        return fixtures;
    }
    /**
     * Creates a fixture and attach it to this body.
     * Use this function if you need to set some fixture parameters, like friction.
     * Otherwise you can create the fixture directly from a shape.
     * If the density is non-zero, this function automatically updates the mass of the body.
     * Contacts are not created until the next time step.
     * Note: This function is locked during callbacks.
     *
     * @param def the fixture definition
     */
    public Fixture createFixture(FixtureDef def) {
        world.assertNotLocked();
        Fixture fixture = new Fixture(this, def);
        if ((m_flags & e_activeFlag) == e_activeFlag) {
            fixture.createProxies(broadPhase, m_xf);
        }
        fixtures.add(fixture);
        // Adjust mass properties if needed.
        if (fixture.getDensity() > 0) {
            resetMassData();
        }
        // Let the world know we have a new fixture. This will cause new contacts
        // to be created at the beginning of the next time step.
        world.notifyNewFixture();
        return fixture;
    }
    private final FixtureDef fixDef = new FixtureDef();
    /**
     * Creates a fixture from a shape and attach it to this body.
     * This is a convenience function.
     * Use FixtureDef if you need to set parameters like friction, restitution, user data, or filtering.
     * If the density is non-zero, this function automatically updates the mass of the body.
     * Note: this function is locked during callbacks.
     *
     *
     * @param shape the shape to be cloned.
     * @param density the shape density (set to zero for static bodies).
     */
    public Fixture createFixture(Shape shape, float density) {
        fixDef.setShape(shape);
        fixDef.setDensity(density);
        return createFixture(fixDef);
    }
    /**
     * Destroy a fixture.
     * This removes the fixture from the broad-phase and destroys all contacts
     * associated with this fixture.
     * This will automatically adjust the mass of the body if the body
     * is dynamic and the fixture has positive density.
     * All fixtures attached to a body are implicitly destroyed when the body is destroyed.
     * Note: this function is locked during callbacks.
     *
     * @param fixture the fixture to be removed
     */
    public void destroyFixture(Fixture fixture) {
        world.assertNotLocked();
        fixtures.remove(fixture);
        // Destroy any contacts associated with the fixture.
        ContactEdge edge = m_contactList;
        while (edge != null) {
            Contact c = edge.contact;
            edge = edge.next;
            if (fixture == c.getFixtureA() || fixture == c.getFixtureB()) {
                // This destroys the contact and removes it from this body's contact list.
                world.getContactManager().destroy(c);
            }
        }
        if ((m_flags & e_activeFlag) == e_activeFlag) {
            fixture.destroyProxies(broadPhase);
        }
        fixture.destroy();
        resetMassData();
    }
    /**
     * Set the position of the body's origin and rotation.
     * This breaks any contacts and wakes the other bodies.
     * Manipulating a body's transform may cause non-physical behavior.
     * Note: contacts are updated on the next call to World.step().
     *
     * @param position the world position of the body's local origin
     * @param angle the world rotation in radians
     */
    public void setTransform(Vec2 position, float angle) {
        world.assertNotLocked();
        m_xf.q.set(angle);
        m_xf.p.set(position);
        // m_sweep.c0 = m_sweep.c = Mul(m_xf, m_sweep.localCenter);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c);
        m_sweep.a = angle;
        m_sweep.c0.set(m_sweep.c);
        m_sweep.a0 = m_sweep.a;
        for (Fixture f : fixtures) {
            f.synchronize(broadPhase, m_xf, m_xf);
        }
    }
    /**
     * @return the world transform of the body's origin.
     */
    public Transform getTransform() {
        return m_xf;
    }
    /**
     * Get the world body origin position. Do not modify.
     *
     * @return the world position of the body's origin.
     */
    public Vec2 getPosition() {
        return m_xf.p;
    }
    /**
     * Get the angle in radians.
     *
     * @return the current world rotation angle in radians.
     */
    public float getAngle() {
        return m_sweep.a;
    }
    /**
     * Get the world position of the center of mass. Do not modify.
     */
    public Vec2 getWorldCenter() {
        return m_sweep.c;
    }
    /**
     * Get the local position of the center of mass. Do not modify.
     */
    public Vec2 getLocalCenter() {
        return m_sweep.localCenter;
    }
    /**
     * Set the linear velocity of the center of mass.
     *
     * @param v the new linear velocity of the center of mass.
     */
    public void setLinearVelocity(Vec2 v) {
        if (type == BodyType.STATIC) {
            return;
        }
        if (Vec2.dot(v, v) > 0) {
            setAwake(true);
        }
        linearVelocity.set(v);
    }
    void setLinearVelocityDirectly(float vx, float vy) {
        linearVelocity.set(vx, vy);
    }
    /**
     * Get the linear velocity of the center of mass. Do not modify, instead use
     * {@link #setLinearVelocity(Vec2)}.
     *
     * @return the linear velocity of the center of mass.
     */
    public Vec2 getLinearVelocity() {
        return linearVelocity;
    }
    /**
     * Set the angular velocity.
     *
     * @param w the new angular velocity in radians/second.
     */
    public void setAngularVelocity(float w) {
        if (type == BodyType.STATIC) {
            return;
        }
        if (w * w > 0f) {
            setAwake(true);
        }
        angularVelocity = w;
    }
    void setAngularVelocityDirectly(float angularVelocity) {
        this.angularVelocity = angularVelocity;
    }
    /**
     * Get the angular velocity.
     *
     * @return the angular velocity in radians/second.
     */
    public float getAngularVelocity() {
        return angularVelocity;
    }
    /**
     * @return the gravity scale of the body
     */
    public float getGravityScale() {
        return gravityScale;
    }
    /**
     * Set the gravity scale of the body.
     *
     * @param gravityScale gravity scale
     */
    public void setGravityScale(float gravityScale) {
        this.gravityScale = gravityScale;
    }
    /**
     * Apply a force at a world point.
     * If the force is not applied at the center of mass, it will generate a torque and affect the angular velocity.
     * This wakes up the body.
     *
     * @param force the world force vector, usually in Newtons (N)
     * @param point the world position of the point of application
     */
    public void applyForce(Vec2 force, Vec2 point) {
        applyForceToCenter(force);
        m_torque += (point.x - m_sweep.c.x) * force.y - (point.y - m_sweep.c.y) * force.x;
    }
    /**
     * Apply a force to the center of mass.
     * This wakes up the body.
     *
     * @param force the world force vector, usually in Newtons (N)
     */
    public void applyForceToCenter(Vec2 force) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        m_force.addLocal(force);
    }
    /**
     * Apply a torque.
     * This affects the angular velocity without affecting the linear velocity of the center of mass.
     * This wakes up the body.
     *
     * @param torque about the z-axis (out of the screen), usually in N-m
     */
    public void applyTorque(float torque) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        m_torque += torque;
    }
    /**
     * Apply an impulse at a point.
     * This immediately modifies the velocity.
     * It also modifies the angular velocity if the point of application is not at the center of mass.
     * This wakes up the body if 'wake' is set to true.
     * If the body is sleeping and 'wake' is false, then there is no effect.
     *
     * @param impulse the world impulse vector, usually in N-seconds or kg-m/s
     * @param point the world position of the point of application
     * @param wake also wake up the body
     */
    public void applyLinearImpulse(Vec2 impulse, Vec2 point, boolean wake) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            if (wake) {
                setAwake(true);
            } else {
                return;
            }
        }
        linearVelocity.x += impulse.x * m_invMass;
        linearVelocity.y += impulse.y * m_invMass;
        angularVelocity += m_invI * ((point.x - m_sweep.c.x) * impulse.y - (point.y - m_sweep.c.y) * impulse.x);
    }
    /**
     * Apply an angular impulse.
     *
     * @param impulse the angular impulse in units of kg*m*m/s
     */
    public void applyAngularImpulse(float impulse) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        angularVelocity += m_invI * impulse;
    }
    /**
     * @return total mass of the body, usually in kilograms (kg)
     */
    public float getMass() {
        return m_mass;
    }
    /**
     * @return central rotational inertia of the body, usually in kg-m^2
     */
    public float getInertia() {
        return m_I + m_mass * Vec2.dot(m_sweep.localCenter, m_sweep.localCenter);
    }
    /**
     * Get the mass data of the body.
     * The rotational inertia is relative to the center of mass.
     * Fills in a struct containing the mass, inertia and center of the body.
     */
    public void getMassData(MassData data) {
        data.mass = m_mass;
        data.I = getInertia();
        data.center.set(m_sweep.localCenter);
    }
    /**
     * Set the mass properties to override the mass properties of the fixtures.
     * Note that this changes the center of mass position.
     * Note that creating or destroying fixtures can also alter the mass.
     * This function has no effect if the body isn't dynamic.
     *
     * @param massData the mass properties.
     */
    public void setMassData(MassData massData) {
        world.assertNotLocked();
        if (type != BodyType.DYNAMIC) {
            return;
        }
        m_I = 0;
        m_invI = 0;
        m_mass = massData.mass;
        if (m_mass <= 0) {
            m_mass = 1;
        }
        m_invMass = 1.0f / m_mass;
        if (massData.I > 0 && (m_flags & e_fixedRotationFlag) == 0) {
            m_I = massData.I - m_mass * Vec2.dot(massData.center, massData.center);
            assert m_I > 0;
            m_invI = 1.0f / m_I;
        }
        final Vec2 oldCenter = world.getPool().popVec2();
        // Move center of mass.
        oldCenter.set(m_sweep.c);
        m_sweep.localCenter.set(massData.center);
        // m_sweep.c0 = m_sweep.c = Mul(m_xf, m_sweep.localCenter);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c0);
        m_sweep.c.set(m_sweep.c0);
        // Update center of mass velocity.
        // m_linearVelocity += Cross(m_angularVelocity, m_sweep.c - oldCenter);
        final Vec2 temp = world.getPool().popVec2();
        temp.set(m_sweep.c).subLocal(oldCenter);
        // crossToOut(m_angularVelocity, temp, temp);
        final float tempY = angularVelocity * temp.x;
        temp.x = -angularVelocity * temp.y;
        temp.y = tempY;
        linearVelocity.addLocal(temp);
        world.getPool().pushVec2(2);
    }
    private final MassData pmd = new MassData();
    /**
     * This resets the mass properties to the sum of the mass properties of the fixtures.
     * This normally does not need to be called unless you called setMassData to override the mass and you
     * later want to reset the mass.
     */
    public void resetMassData() {
        // Compute mass data from shapes. Each shape has its own density.
        m_mass = 0;
        m_invMass = 0;
        m_I = 0;
        m_invI = 0;
        m_sweep.localCenter.setZero();
        // Static and kinematic bodies have zero mass.
        if (type == BodyType.STATIC || type == BodyType.KINEMATIC) {
            m_sweep.c0.set(m_xf.p);
            m_sweep.c.set(m_xf.p);
            m_sweep.a0 = m_sweep.a;
            return;
        }
        // Accumulate mass over all fixtures.
        final Vec2 localCenter = world.getPool().popVec2();
        localCenter.setZero();
        final Vec2 temp = world.getPool().popVec2();
        final MassData massData = pmd;
        for (Fixture f : fixtures) {
            if (f.getDensity() == 0.0f) {
                continue;
            }
            f.getMassData(massData);
            m_mass += massData.mass;
            // center += massData.mass * massData.center;
            temp.set(massData.center).mulLocal(massData.mass);
            localCenter.addLocal(temp);
            m_I += massData.I;
        }
        // Compute center of mass.
        if (m_mass > 0.0f) {
            m_invMass = 1.0f / m_mass;
            localCenter.mulLocal(m_invMass);
        } else {
            // Force all dynamic bodies to have a positive mass.
            m_mass = 1.0f;
            m_invMass = 1.0f;
        }
        if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0) {
            // Center the inertia about the center of mass.
            m_I -= m_mass * Vec2.dot(localCenter, localCenter);
            assert m_I > 0.0f;
            m_invI = 1.0f / m_I;
        } else {
            m_I = 0.0f;
            m_invI = 0.0f;
        }
        Vec2 oldCenter = world.getPool().popVec2();
        // Move center of mass.
        oldCenter.set(m_sweep.c);
        m_sweep.localCenter.set(localCenter);
        // m_sweep.c0 = m_sweep.c = Mul(m_xf, m_sweep.localCenter);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c0);
        m_sweep.c.set(m_sweep.c0);
        // Update center of mass velocity.
        // m_linearVelocity += Cross(m_angularVelocity, m_sweep.c - oldCenter);
        temp.set(m_sweep.c).subLocal(oldCenter);
        final Vec2 temp2 = oldCenter;
        Vec2.crossToOutUnsafe(angularVelocity, temp, temp2);
        linearVelocity.addLocal(temp2);
        world.getPool().pushVec2(3);
    }
    /**
     * Get the world coordinates of a point given the local coordinates.
     *
     * @param localPoint a point on the body measured relative the the body's origin.
     * @return the same point expressed in world coordinates.
     */
    public Vec2 getWorldPoint(Vec2 localPoint) {
        Vec2 v = new Vec2();
        getWorldPointToOut(localPoint, v);
        return v;
    }
    public void getWorldPointToOut(Vec2 localPoint, Vec2 out) {
        Transform.mulToOut(m_xf, localPoint, out);
    }
    /**
     * Get the world coordinates of a vector given the local coordinates.
     *
     * @param localVector a vector fixed in the body.
     * @return the same vector expressed in world coordinates.
     */
    public Vec2 getWorldVector(Vec2 localVector) {
        Vec2 out = new Vec2();
        getWorldVectorToOut(localVector, out);
        return out;
    }
    public void getWorldVectorToOut(Vec2 localVector, Vec2 out) {
        Rotation.mulToOut(m_xf.q, localVector, out);
    }
    public void getWorldVectorToOutUnsafe(Vec2 localVector, Vec2 out) {
        Rotation.mulToOutUnsafe(m_xf.q, localVector, out);
    }
    /**
     * Gets a local point relative to the body's origin given a world point.
     *
     * @param worldPoint point in world coordinates.
     * @return the corresponding local point relative to the body's origin.
     */
    public Vec2 getLocalPoint(Vec2 worldPoint) {
        Vec2 out = new Vec2();
        getLocalPointToOut(worldPoint, out);
        return out;
    }
    public void getLocalPointToOut(Vec2 worldPoint, Vec2 out) {
        Transform.mulTransToOut(m_xf, worldPoint, out);
    }
    /**
     * Gets a local vector given a world vector.
     *
     * @param worldVector vector in world coordinates.
     * @return the corresponding local vector.
     */
    public Vec2 getLocalVector(Vec2 worldVector) {
        Vec2 out = new Vec2();
        getLocalVectorToOut(worldVector, out);
        return out;
    }
    public void getLocalVectorToOut(Vec2 worldVector, Vec2 out) {
        Rotation.mulTrans(m_xf.q, worldVector, out);
    }
    public void getLocalVectorToOutUnsafe(Vec2 worldVector, Vec2 out) {
        Rotation.mulTransUnsafe(m_xf.q, worldVector, out);
    }
    /**
     * Get the world linear velocity of a world point attached to this body.
     *
     * @param worldPoint point in world coordinates.
     * @return the world velocity of a point.
     */
    public Vec2 getLinearVelocityFromWorldPoint(Vec2 worldPoint) {
        Vec2 out = new Vec2();
        getLinearVelocityFromWorldPointToOut(worldPoint, out);
        return out;
    }
    public void getLinearVelocityFromWorldPointToOut(Vec2 worldPoint, Vec2 out) {
        final float tempX = worldPoint.x - m_sweep.c.x;
        final float tempY = worldPoint.y - m_sweep.c.y;
        out.x = -angularVelocity * tempY + linearVelocity.x;
        out.y = angularVelocity * tempX + linearVelocity.y;
    }
    /**
     * Get the world velocity of a local point.
     *
     * @param localPoint point in local coordinates.
     * @return the world velocity of a point.
     */
    public Vec2 getLinearVelocityFromLocalPoint(Vec2 localPoint) {
        Vec2 out = new Vec2();
        getLinearVelocityFromLocalPointToOut(localPoint, out);
        return out;
    }
    public void getLinearVelocityFromLocalPointToOut(Vec2 localPoint, Vec2 out) {
        getWorldPointToOut(localPoint, out);
        getLinearVelocityFromWorldPointToOut(out, out);
    }
    /**
     * Get the linear damping of the body.
     **/
    public float getLinearDamping() {
        return linearDamping;
    }
    /**
     * Set the linear damping of the body.
     **/
    public void setLinearDamping(float linearDamping) {
        this.linearDamping = linearDamping;
    }
    /**
     * Get the angular damping of the body.
     **/
    public float getAngularDamping() {
        return angularDamping;
    }
    /**
     * Set the angular damping of the body.
     **/
    public void setAngularDamping(float angularDamping) {
        this.angularDamping = angularDamping;
    }
    public float getSleepTime() {
        return sleepTime;
    }
    void setSleepTime(float sleepTime) {
        this.sleepTime = sleepTime;
    }
    /**
     * @return body type
     */
    public BodyType getType() {
        return type;
    }
    /**
     * Set the type of this body.
     * This may alter the mass and velocity.
     *
     * @param type body type
     */
    public void setType(BodyType type) {
        world.assertNotLocked();
        if (this.type == type) {
            return;
        }
        this.type = type;
        resetMassData();
        if (this.type == BodyType.STATIC) {
            linearVelocity.setZero();
            angularVelocity = 0.0f;
            m_sweep.a0 = m_sweep.a;
            m_sweep.c0.set(m_sweep.c);
            synchronizeFixtures();
        }
        setAwake(true);
        clearForces();
        destroyAttachedContacts();
        // Touch the proxies so that new contacts will be created (when appropriate)
        for (Fixture f : fixtures) {
            int proxyCount = f.getProxyCount();
            for (int i = 0; i < proxyCount; ++i) {
                broadPhase.touchProxy(f.getProxyId(i));
            }
        }
    }
    void clearForces() {
        m_force.setZero();
        m_torque = 0.0f;
    }
    Vec2 getForce() {
        return m_force;
    }
    void destroy() {
        destroyAttachedJoints();
        destroyAttachedContacts();
        destroyFixtures();
    }
    private void destroyAttachedJoints() {
        JointEdge je = this.m_jointList;
        while (je != null) {
            JointEdge je0 = je;
            je = je.next;
            if (world.getDestructionListener() != null) {
                world.getDestructionListener().onDestroy(je0.joint);
            }
            world.destroyJoint(je0.joint);
            this.m_jointList = je;
        }
        this.m_jointList = null;
    }
    private void destroyAttachedContacts() {
        // Delete the attached contacts.
        ContactEdge ce = m_contactList;
        while (ce != null) {
            ContactEdge ce0 = ce;
            ce = ce.next;
            world.getContactManager().destroy(ce0.contact);
        }
        m_contactList = null;
    }
    private void destroyFixtures() {
        for (Fixture f : getFixtures()) {
            if (world.getDestructionListener() != null) {
                world.getDestructionListener().onDestroy(f);
            }
            f.destroyProxies(broadPhase);
            f.destroy();
            // jbox2dTODO djm recycle fixtures (here or in that destroy method)
        }
        getFixtures().clear();
    }
    /**
     * @return is this body treated like a bullet for continuous collision detection?
     **/
    public boolean isBullet() {
        return (m_flags & e_bulletFlag) == e_bulletFlag;
    }
    /**
     * Should this body be treated like a bullet for continuous collision detection?
     **/
    public void setBullet(boolean flag) {
        if (flag) {
            m_flags |= e_bulletFlag;
        } else {
            m_flags &= ~e_bulletFlag;
        }
    }
    boolean isIslandFlagOff() {
        return (m_flags & e_islandFlag) == 0;
    }
    boolean isIslandFlagOn() {
        return (m_flags & e_islandFlag) != 0;
    }
    boolean isIslandFlagOn2() {
        return (m_flags & e_islandFlag) == e_islandFlag;
    }
    void setIslandFlag(boolean flag) {
        if (flag) {
            m_flags |= e_islandFlag;
        } else {
            m_flags &= ~e_islandFlag;
        }
    }
    /**
     * You can disable sleeping on this body.
     * If you disable sleeping, the body will be woken.
     *
     * @param flag sleep flag
     */
    public void setSleepingAllowed(boolean flag) {
        isSleepingAllowed = flag;
        if (!isSleepingAllowed) {
            setAwake(true);
        }
    }
    /**
     * @return whether this body is allowed to sleep
     */
    public boolean isSleepingAllowed() {
        return isSleepingAllowed;
    }
    /**
     * Set the sleep state of the body.
     * A sleeping body has very low CPU cost.
     *
     * @param flag set to true to put body to sleep, false to wake it
     */
    public void setAwake(boolean flag) {
        if (flag) {
            if ((m_flags & e_awakeFlag) == 0) {
                m_flags |= e_awakeFlag;
                sleepTime = 0.0f;
            }
        } else {
            m_flags &= ~e_awakeFlag;
            sleepTime = 0.0f;
            linearVelocity.setZero();
            angularVelocity = 0.0f;
            clearForces();
        }
    }
    /**
     * Get the sleeping state of this body.
     *
     * @return true if the body is awake.
     */
    public boolean isAwake() {
        return (m_flags & e_awakeFlag) == e_awakeFlag;
    }
    /**
     * Set the active state of the body.
     * An inactive body is not simulated and cannot be collided with or woken up.
     * If you pass a flag of true, all fixtures will be added to the broad-phase.
     * If you pass a flag of false, all fixtures will be removed from the broad-phase and all contacts will be destroyed.
     * Fixtures and joints are otherwise unaffected.
     * You may continue to create/destroy fixtures and joints on inactive bodies.
     * Fixtures on an inactive body are implicitly inactive
     * and will not participate in collisions, ray-casts, or queries.
     * Joints connected to an inactive body are implicitly inactive.
     * An inactive body is still owned by a World object and remains in the body list.
     *
     * @param flag active flag
     */
    public void setActive(boolean flag) {
        world.assertNotLocked();
        if (flag == isActive()) {
            return;
        }
        if (flag) {
            m_flags |= e_activeFlag;
            // Create all proxies.
            for (Fixture f : fixtures) {
                f.createProxies(broadPhase, m_xf);
            }
            // Contacts are created the next time step.
        } else {
            m_flags &= ~e_activeFlag;
            // Destroy all proxies.
            for (Fixture f : fixtures) {
                f.destroyProxies(broadPhase);
            }
            destroyAttachedContacts();
        }
    }
    /**
     * @return the active state of the body
     */
    public boolean isActive() {
        return (m_flags & e_activeFlag) == e_activeFlag;
    }
    /**
     * Set this body to have fixed rotation. This causes the mass to be reset.
     *
     * @param flag fixed rotation flag
     */
    public void setFixedRotation(boolean flag) {
        if (flag) {
            m_flags |= e_fixedRotationFlag;
        } else {
            m_flags &= ~e_fixedRotationFlag;
        }
        resetMassData();
    }
    /**
     * @return does this body have fixed rotation
     */
    public boolean isFixedRotation() {
        return (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
    }
    /**
     * Get the list of all joints attached to this body.
     **/
    public JointEdge getJointList() {
        return m_jointList;
    }
    /**
     * Get the list of all contacts attached to this body.
     * Note: this list changes during the time step and you may miss some collisions if you don't
     * use ContactListener.
     */
    public ContactEdge getContactList() {
        return m_contactList;
    }
    /**
     * Get the user data pointer that was provided in the body definition.
     **/
    public Object getUserData() {
        return userData;
    }
    /**
     * Set the user data. Use this to store your application specific data.
     */
    public void setUserData(Object data) {
        userData = data;
    }
    /**
     * Get the parent world of this body.
     */
    public World getWorld() {
        return world;
    }
    // djm pooling
    private final Transform pxf = new Transform();
    void synchronizeFixtures() {
        final Transform xf1 = pxf;
        // xf1.position = m_sweep.c0 - Mul(xf1.R, m_sweep.localCenter);
        // xf1.q.set(m_sweep.a0);
        // Rot.mulToOutUnsafe(xf1.q, m_sweep.localCenter, xf1.p);
        // xf1.p.mulLocal(-1).addLocal(m_sweep.c0);
        // inlined:
        xf1.q.set(m_sweep.a0);
        xf1.p.x = m_sweep.c0.x - xf1.q.c * m_sweep.localCenter.x + xf1.q.s * m_sweep.localCenter.y;
        xf1.p.y = m_sweep.c0.y - xf1.q.s * m_sweep.localCenter.x - xf1.q.c * m_sweep.localCenter.y;
        // end inline
        for (Fixture f : fixtures) {
            f.synchronize(broadPhase, xf1, m_xf);
        }
    }
    void synchronizeTransform() {
        // m_xf.position = m_sweep.c - Mul(m_xf.R, m_sweep.localCenter);
        // Rot.mulToOutUnsafe(m_xf.q, m_sweep.localCenter, m_xf.p);
        // m_xf.p.mulLocal(-1).addLocal(m_sweep.c);
        m_xf.q.set(m_sweep.a);
        Rotation q = m_xf.q;
        Vec2 v = m_sweep.localCenter;
        m_xf.p.x = m_sweep.c.x - q.c * v.x + q.s * v.y;
        m_xf.p.y = m_sweep.c.y - q.s * v.x - q.c * v.y;
    }
    /**
     * This is used to prevent connected bodies from colliding.
     * It may lie, depending on the collideConnected flag.
     *
     * @param other other body
     * @return if they should collide
     */
    public boolean shouldCollide(Body other) {
        // At least one body should be dynamic.
        if (type != BodyType.DYNAMIC && other.type != BodyType.DYNAMIC) {
            return false;
        }
        // Does a joint prevent collision?
        for (JointEdge jn = m_jointList; jn != null; jn = jn.next) {
            if (jn.other == other && !jn.joint.getCollideConnected()) {
                return false;
            }
        }
        return true;
    }
    void advance(float t) {
        // Advance to the new safe time. This doesn't sync the broad-phase.
        m_sweep.advance(t);
        m_sweep.c.set(m_sweep.c0);
        m_sweep.a = m_sweep.a0;
        m_xf.q.set(m_sweep.a);
        // m_xf.position = m_sweep.c - Mul(m_xf.R, m_sweep.localCenter);
        Rotation.mulToOutUnsafe(m_xf.q, m_sweep.localCenter, m_xf.p);
        m_xf.p.mulLocal(-1).addLocal(m_sweep.c);
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.dynamics.contacts;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.collision.Manifold;
import com.almasb.fxgl.physics.box2d.collision.ManifoldPoint;
import com.almasb.fxgl.physics.box2d.collision.WorldManifold;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.JBoxSettings;
import com.almasb.fxgl.physics.box2d.common.Mat22;
import com.almasb.fxgl.physics.box2d.common.Rotation;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.Body;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
import com.almasb.fxgl.physics.box2d.dynamics.TimeStep;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactVelocityConstraint.VelocityConstraintPoint;
/**
 * @author Daniel
 */
public final class ContactSolver {
    /**
     * For each solver, this is the initial number of constraints in the array, which expands as
     * needed.
     */
    private static final int INITIAL_NUM_CONSTRAINTS = 256;
    /**
     * Ensure a reasonable condition number. for the block solver
     */
    private static final float k_maxConditionNumber = 100.0f;
    private Position[] m_positions;
    private Velocity[] m_velocities;
    private ContactPositionConstraint[] m_positionConstraints = new ContactPositionConstraint[INITIAL_NUM_CONSTRAINTS];
    private ContactVelocityConstraint[] m_velocityConstraints = new ContactVelocityConstraint[INITIAL_NUM_CONSTRAINTS];
    private Contact[] m_contacts;
    private int m_count;
    public ContactSolver() {
        for (int i = 0; i < INITIAL_NUM_CONSTRAINTS; i++) {
            m_positionConstraints[i] = new ContactPositionConstraint();
            m_velocityConstraints[i] = new ContactVelocityConstraint();
        }
    }
    public ContactVelocityConstraint[] getVelocityConstraints() {
        return m_velocityConstraints;
    }
    public void init(ContactSolverDef def) {
        TimeStep step = def.step;
        m_count = def.count;
        if (m_positionConstraints.length < m_count) {
            ContactPositionConstraint[] old = m_positionConstraints;
            m_positionConstraints = new ContactPositionConstraint[Math.max(old.length * 2, m_count)];
            System.arraycopy(old, 0, m_positionConstraints, 0, old.length);
            for (int i = old.length; i < m_positionConstraints.length; i++) {
                m_positionConstraints[i] = new ContactPositionConstraint();
            }
        }
        if (m_velocityConstraints.length < m_count) {
            ContactVelocityConstraint[] old = m_velocityConstraints;
            m_velocityConstraints = new ContactVelocityConstraint[Math.max(old.length * 2, m_count)];
            System.arraycopy(old, 0, m_velocityConstraints, 0, old.length);
            for (int i = old.length; i < m_velocityConstraints.length; i++) {
                m_velocityConstraints[i] = new ContactVelocityConstraint();
            }
        }
        m_positions = def.positions;
        m_velocities = def.velocities;
        m_contacts = def.contacts;
        for (int i = 0; i < m_count; ++i) {
            final Contact contact = m_contacts[i];
            final Fixture fixtureA = contact.m_fixtureA;
            final Fixture fixtureB = contact.m_fixtureB;
            final Shape shapeA = fixtureA.getShape();
            final Shape shapeB = fixtureB.getShape();
            final float radiusA = shapeA.getRadius();
            final float radiusB = shapeB.getRadius();
            final Body bodyA = fixtureA.getBody();
            final Body bodyB = fixtureB.getBody();
            final Manifold manifold = contact.getManifold();
            int pointCount = manifold.pointCount;
            assert pointCount > 0;
            ContactVelocityConstraint vc = m_velocityConstraints[i];
            vc.friction = contact.getFriction();
            vc.restitution = contact.getRestitution();
            vc.tangentSpeed = contact.getTangentSpeed();
            vc.indexA = bodyA.m_islandIndex;
            vc.indexB = bodyB.m_islandIndex;
            vc.invMassA = bodyA.m_invMass;
            vc.invMassB = bodyB.m_invMass;
            vc.invIA = bodyA.m_invI;
            vc.invIB = bodyB.m_invI;
            vc.contactIndex = i;
            vc.pointCount = pointCount;
            vc.K.setZero();
            vc.normalMass.setZero();
            ContactPositionConstraint pc = m_positionConstraints[i];
            pc.indexA = bodyA.m_islandIndex;
            pc.indexB = bodyB.m_islandIndex;
            pc.invMassA = bodyA.m_invMass;
            pc.invMassB = bodyB.m_invMass;
            pc.localCenterA.set(bodyA.m_sweep.localCenter);
            pc.localCenterB.set(bodyB.m_sweep.localCenter);
            pc.invIA = bodyA.m_invI;
            pc.invIB = bodyB.m_invI;
            pc.localNormal.set(manifold.localNormal);
            pc.localPoint.set(manifold.localPoint);
            pc.pointCount = pointCount;
            pc.radiusA = radiusA;
            pc.radiusB = radiusB;
            pc.type = manifold.type;
            for (int j = 0; j < pointCount; j++) {
                ManifoldPoint cp = manifold.points[j];
                VelocityConstraintPoint vcp = vc.points[j];
                if (step.warmStarting) {
                    vcp.normalImpulse = step.dtRatio * cp.normalImpulse;
                    vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;
                } else {
                    vcp.normalImpulse = 0;
                    vcp.tangentImpulse = 0;
                }
                vcp.rA.setZero();
                vcp.rB.setZero();
                vcp.normalMass = 0;
                vcp.tangentMass = 0;
                vcp.velocityBias = 0;
                pc.localPoints[j].x = cp.localPoint.x;
                pc.localPoints[j].y = cp.localPoint.y;
            }
        }
    }
    public void warmStart() {
        // Warm start.
        for (int i = 0; i < m_count; ++i) {
            final ContactVelocityConstraint vc = m_velocityConstraints[i];
            int indexA = vc.indexA;
            int indexB = vc.indexB;
            float mA = vc.invMassA;
            float iA = vc.invIA;
            float mB = vc.invMassB;
            float iB = vc.invIB;
            int pointCount = vc.pointCount;
            Vec2 vA = m_velocities[indexA].v;
            float wA = m_velocities[indexA].w;
            Vec2 vB = m_velocities[indexB].v;
            float wB = m_velocities[indexB].w;
            Vec2 normal = vc.normal;
            float tangentx = 1.0f * normal.y;
            float tangenty = -1.0f * normal.x;
            for (int j = 0; j < pointCount; ++j) {
                VelocityConstraintPoint vcp = vc.points[j];
                float Px = tangentx * vcp.tangentImpulse + normal.x * vcp.normalImpulse;
                float Py = tangenty * vcp.tangentImpulse + normal.y * vcp.normalImpulse;
                wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                vA.x -= Px * mA;
                vA.y -= Py * mA;
                wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
                vB.x += Px * mB;
                vB.y += Py * mB;
            }
            m_velocities[indexA].w = wA;
            m_velocities[indexB].w = wB;
        }
    }
    // djm pooling, and from above
    private final Transform xfA = new Transform();
    private final Transform xfB = new Transform();
    private final WorldManifold worldManifold = new WorldManifold();
    public void initializeVelocityConstraints() {
        // Warm start.
        for (int i = 0; i < m_count; ++i) {
            ContactVelocityConstraint vc = m_velocityConstraints[i];
            ContactPositionConstraint pc = m_positionConstraints[i];
            float radiusA = pc.radiusA;
            float radiusB = pc.radiusB;
            Manifold manifold = m_contacts[vc.contactIndex].getManifold();
            int indexA = vc.indexA;
            int indexB = vc.indexB;
            float mA = vc.invMassA;
            float mB = vc.invMassB;
            float iA = vc.invIA;
            float iB = vc.invIB;
            Vec2 localCenterA = pc.localCenterA;
            Vec2 localCenterB = pc.localCenterB;
            Vec2 cA = m_positions[indexA].c;
            float aA = m_positions[indexA].a;
            Vec2 vA = m_velocities[indexA].v;
            float wA = m_velocities[indexA].w;
            Vec2 cB = m_positions[indexB].c;
            float aB = m_positions[indexB].a;
            Vec2 vB = m_velocities[indexB].v;
            float wB = m_velocities[indexB].w;
            assert manifold.pointCount > 0;
            final Rotation xfAq = xfA.q;
            final Rotation xfBq = xfB.q;
            xfAq.set(aA);
            xfBq.set(aB);
            xfA.p.x = cA.x - (xfAq.c * localCenterA.x - xfAq.s * localCenterA.y);
            xfA.p.y = cA.y - (xfAq.s * localCenterA.x + xfAq.c * localCenterA.y);
            xfB.p.x = cB.x - (xfBq.c * localCenterB.x - xfBq.s * localCenterB.y);
            xfB.p.y = cB.y - (xfBq.s * localCenterB.x + xfBq.c * localCenterB.y);
            worldManifold.initialize(manifold, xfA, radiusA, xfB, radiusB);
            final Vec2 vcnormal = vc.normal;
            vcnormal.set(worldManifold.getNormalX(), worldManifold.getNormalY());
            int pointCount = vc.pointCount;
            for (int j = 0; j < pointCount; ++j) {
                VelocityConstraintPoint vcp = vc.points[j];
                Vec2 wmPj = worldManifold.getPoint(j);
                final Vec2 vcprA = vcp.rA;
                final Vec2 vcprB = vcp.rB;
                vcprA.x = wmPj.x - cA.x;
                vcprA.y = wmPj.y - cA.y;
                vcprB.x = wmPj.x - cB.x;
                vcprB.y = wmPj.y - cB.y;
                float rnA = vcprA.x * vcnormal.y - vcprA.y * vcnormal.x;
                float rnB = vcprB.x * vcnormal.y - vcprB.y * vcnormal.x;
                float kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                vcp.normalMass = kNormal > 0.0f ? 1.0f / kNormal : 0.0f;
                float tangentx = 1.0f * vcnormal.y;
                float tangenty = -1.0f * vcnormal.x;
                float rtA = vcprA.x * tangenty - vcprA.y * tangentx;
                float rtB = vcprB.x * tangenty - vcprB.y * tangentx;
                float kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
                vcp.tangentMass = kTangent > 0.0f ? 1.0f / kTangent : 0.0f;
                // Setup a velocity bias for restitution.
                vcp.velocityBias = 0.0f;
                float tempx = vB.x + -wB * vcprB.y - vA.x - (-wA * vcprA.y);
                float tempy = vB.y + wB * vcprB.x - vA.y - (wA * vcprA.x);
                float vRel = vcnormal.x * tempx + vcnormal.y * tempy;
                if (vRel < -JBoxSettings.velocityThreshold) {
                    vcp.velocityBias = -vc.restitution * vRel;
                }
            }
            // If we have two points, then prepare the block solver.
            if (vc.pointCount == 2) {
                VelocityConstraintPoint vcp1 = vc.points[0];
                VelocityConstraintPoint vcp2 = vc.points[1];
                float rn1A = vcp1.rA.x * vcnormal.y - vcp1.rA.y * vcnormal.x;
                float rn1B = vcp1.rB.x * vcnormal.y - vcp1.rB.y * vcnormal.x;
                float rn2A = vcp2.rA.x * vcnormal.y - vcp2.rA.y * vcnormal.x;
                float rn2B = vcp2.rB.x * vcnormal.y - vcp2.rB.y * vcnormal.x;
                float k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
                float k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
                float k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                    // K is safe to invert.
                    vc.K.ex.x = k11;
                    vc.K.ex.y = k12;
                    vc.K.ey.x = k12;
                    vc.K.ey.y = k22;
                    vc.K.invertToOut(vc.normalMass);
                } else {
                    // The constraints are redundant, just use one.
                    // TODO_ERIN use deepest?
                    vc.pointCount = 1;
                }
            }
        }
    }
    @SuppressWarnings("PMD.AvoidBranchingStatementAsLastInLoop")
    public void solveVelocityConstraints() {
        for (int i = 0; i < m_count; ++i) {
            final ContactVelocityConstraint vc = m_velocityConstraints[i];
            int indexA = vc.indexA;
            int indexB = vc.indexB;
            float mA = vc.invMassA;
            float mB = vc.invMassB;
            float iA = vc.invIA;
            float iB = vc.invIB;
            int pointCount = vc.pointCount;
            Vec2 vA = m_velocities[indexA].v;
            float wA = m_velocities[indexA].w;
            Vec2 vB = m_velocities[indexB].v;
            float wB = m_velocities[indexB].w;
            Vec2 normal = vc.normal;
            final float normalx = normal.x;
            final float normaly = normal.y;
            float tangentx = 1.0f * vc.normal.y;
            float tangenty = -1.0f * vc.normal.x;
            final float friction = vc.friction;
            assert pointCount == 1 || pointCount == 2;
            // Solve tangent constraints
            for (int j = 0; j < pointCount; ++j) {
                final VelocityConstraintPoint vcp = vc.points[j];
                final Vec2 a = vcp.rA;
                float dvx = -wB * vcp.rB.y + vB.x - vA.x + wA * a.y;
                float dvy = wB * vcp.rB.x + vB.y - vA.y - wA * a.x;
                // Compute tangent force
                final float vt = dvx * tangentx + dvy * tangenty - vc.tangentSpeed;
                float lambda = vcp.tangentMass * (-vt);
                // Clamp the accumulated force
                final float maxFriction = friction * vcp.normalImpulse;
                final float newImpulse = FXGLMath.clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
                lambda = newImpulse - vcp.tangentImpulse;
                vcp.tangentImpulse = newImpulse;
                // Apply contact impulse
                // Vec2 P = lambda * tangent;
                final float Px = tangentx * lambda;
                final float Py = tangenty * lambda;
                // vA -= invMassA * P;
                vA.x -= Px * mA;
                vA.y -= Py * mA;
                wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                // vB += invMassB * P;
                vB.x += Px * mB;
                vB.y += Py * mB;
                wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
            }
            // Solve normal constraints
            if (vc.pointCount == 1) {
                final VelocityConstraintPoint vcp = vc.points[0];
                // Relative velocity at contact
                // Vec2 dv = vB + Cross(wB, vcp.rB) - vA - Cross(wA, vcp.rA);
                float dvx = -wB * vcp.rB.y + vB.x - vA.x + wA * vcp.rA.y;
                float dvy = wB * vcp.rB.x + vB.y - vA.y - wA * vcp.rA.x;
                // Compute normal impulse
                final float vn = dvx * normalx + dvy * normaly;
                float lambda = -vcp.normalMass * (vn - vcp.velocityBias);
                // Clamp the accumulated impulse
                float a = vcp.normalImpulse + lambda;
                final float newImpulse = a > 0.0f ? a : 0.0f;
                lambda = newImpulse - vcp.normalImpulse;
                vcp.normalImpulse = newImpulse;
                // Apply contact impulse
                float Px = normalx * lambda;
                float Py = normaly * lambda;
                // vA -= invMassA * P;
                vA.x -= Px * mA;
                vA.y -= Py * mA;
                wA -= iA * (vcp.rA.x * Py - vcp.rA.y * Px);
                // vB += invMassB * P;
                vB.x += Px * mB;
                vB.y += Py * mB;
                wB += iB * (vcp.rB.x * Py - vcp.rB.y * Px);
            } else {
                // Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).
                // Build the mini LCP for this contact patch
                //
                // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2
                //
                // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
                // b = vn_0 - velocityBias
                //
                // The system is solved using the "Total enumeration method" (s. Murty). The complementary
                // constraint vn_i * x_i
                // implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D
                // contact problem the cases
                // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and vn1 = 0 need to be
                // tested. The first valid
                // solution that satisfies the problem is chosen.
                //
                // In order to account of the accumulated impulse 'a' (because of the iterative nature of
                // the solver which only requires
                // that the accumulated impulse is clamped and not the incremental impulse) we change the
                // impulse variable (x_i).
                //
                // Substitute:
                //
                // x = a + d
                //
                // a := old total impulse
                // x := new total impulse
                // d := incremental impulse
                //
                // For the current iteration we extend the formula for the incremental impulse
                // to compute the new total impulse:
                //
                // vn = A * d + b
                // = A * (x - a) + b
                // = A * x + b - A * a
                // = A * x + b'
                // b' = b - A * a;
                final VelocityConstraintPoint cp1 = vc.points[0];
                final VelocityConstraintPoint cp2 = vc.points[1];
                final Vec2 cp1rA = cp1.rA;
                final Vec2 cp1rB = cp1.rB;
                final Vec2 cp2rA = cp2.rA;
                final Vec2 cp2rB = cp2.rB;
                float ax = cp1.normalImpulse;
                float ay = cp2.normalImpulse;
                assert ax >= 0.0f && ay >= 0.0f;
                // Relative velocity at contact
                // Vec2 dv1 = vB + Cross(wB, cp1.rB) - vA - Cross(wA, cp1.rA);
                float dv1x = -wB * cp1rB.y + vB.x - vA.x + wA * cp1rA.y;
                float dv1y = wB * cp1rB.x + vB.y - vA.y - wA * cp1rA.x;
                // Vec2 dv2 = vB + Cross(wB, cp2.rB) - vA - Cross(wA, cp2.rA);
                float dv2x = -wB * cp2rB.y + vB.x - vA.x + wA * cp2rA.y;
                float dv2y = wB * cp2rB.x + vB.y - vA.y - wA * cp2rA.x;
                // Compute normal velocity
                float vn1 = dv1x * normalx + dv1y * normaly;
                float vn2 = dv2x * normalx + dv2y * normaly;
                float bx = vn1 - cp1.velocityBias;
                float by = vn2 - cp2.velocityBias;
                // Compute b'
                Mat22 R = vc.K;
                bx -= R.ex.x * ax + R.ey.x * ay;
                by -= R.ex.y * ax + R.ey.y * ay;
                // final float k_errorTol = 1e-3f;
                // B2_NOT_USED(k_errorTol);
                for (; ; ) {
                    //
                    // Case 1: vn = 0
                    //
                    // 0 = A * x' + b'
                    //
                    // Solve for x':
                    //
                    // x' = - inv(A) * b'
                    //
                    // Vec2 x = - Mul(c.normalMass, b);
                    Mat22 R1 = vc.normalMass;
                    float xx = R1.ex.x * bx + R1.ey.x * by;
                    float xy = R1.ex.y * bx + R1.ey.y * by;
                    xx *= -1;
                    xy *= -1;
                    if (xx >= 0.0f && xy >= 0.0f) {
                        // Get the incremental impulse
                        // Vec2 d = x - a;
                        float dx = xx - ax;
                        float dy = xy - ay;
                        // Apply incremental impulse
                        // Vec2 P1 = d.x * normal;
                        // Vec2 P2 = d.y * normal;
                        float P1x = dx * normalx;
                        float P1y = dx * normaly;
                        float P2x = dy * normalx;
                        float P2y = dy * normaly;
            /*
             * vA -= invMassA * (P1 + P2); wA -= invIA * (Cross(cp1.rA, P1) + Cross(cp2.rA, P2));
             * 
             * vB += invMassB * (P1 + P2); wB += invIB * (Cross(cp1.rB, P1) + Cross(cp2.rB, P2));
             */
                        vA.x -= mA * (P1x + P2x);
                        vA.y -= mA * (P1y + P2y);
                        vB.x += mB * (P1x + P2x);
                        vB.y += mB * (P1y + P2y);
                        wA -= iA * (cp1rA.x * P1y - cp1rA.y * P1x + (cp2rA.x * P2y - cp2rA.y * P2x));
                        wB += iB * (cp1rB.x * P1y - cp1rB.y * P1x + (cp2rB.x * P2y - cp2rB.y * P2x));
                        // Accumulate
                        cp1.normalImpulse = xx;
                        cp2.normalImpulse = xy;
                        break;
                    }
                    //
                    // Case 2: vn1 = 0 and x2 = 0
                    //
                    // 0 = a11 * x1' + a12 * 0 + b1'
                    // vn2 = a21 * x1' + a22 * 0 + '
                    //
                    xx = -cp1.normalMass * bx;
                    xy = 0.0f;
                    vn1 = 0.0f;
                    vn2 = vc.K.ex.y * xx + by;
                    if (xx >= 0.0f && vn2 >= 0.0f) {
                        // Get the incremental impulse
                        float dx = xx - ax;
                        float dy = xy - ay;
                        // Apply incremental impulse
                        // Vec2 P1 = d.x * normal;
                        // Vec2 P2 = d.y * normal;
                        float P1x = normalx * dx;
                        float P1y = normaly * dx;
                        float P2x = normalx * dy;
                        float P2y = normaly * dy;
            /*
             * Vec2 P1 = d.x * normal; Vec2 P2 = d.y * normal; vA -= invMassA * (P1 + P2); wA -=
             * invIA * (Cross(cp1.rA, P1) + Cross(cp2.rA, P2));
             * 
             * vB += invMassB * (P1 + P2); wB += invIB * (Cross(cp1.rB, P1) + Cross(cp2.rB, P2));
             */
                        vA.x -= mA * (P1x + P2x);
                        vA.y -= mA * (P1y + P2y);
                        vB.x += mB * (P1x + P2x);
                        vB.y += mB * (P1y + P2y);
                        wA -= iA * (cp1rA.x * P1y - cp1rA.y * P1x + (cp2rA.x * P2y - cp2rA.y * P2x));
                        wB += iB * (cp1rB.x * P1y - cp1rB.y * P1x + (cp2rB.x * P2y - cp2rB.y * P2x));
                        // Accumulate
                        cp1.normalImpulse = xx;
                        cp2.normalImpulse = xy;
                        break;
                    }
                    //
                    // Case 3: wB = 0 and x1 = 0
                    //
                    // vn1 = a11 * 0 + a12 * x2' + b1'
                    // 0 = a21 * 0 + a22 * x2' + '
                    //
                    xx = 0.0f;
                    xy = -cp2.normalMass * by;
                    vn1 = vc.K.ey.x * xy + bx;
                    vn2 = 0.0f;
                    if (xy >= 0.0f && vn1 >= 0.0f) {
                        // Resubstitute for the incremental impulse
                        float dx = xx - ax;
                        float dy = xy - ay;
                        // Apply incremental impulse
            /*
             * Vec2 P1 = d.x * normal; Vec2 P2 = d.y * normal; vA -= invMassA * (P1 + P2); wA -=
             * invIA * (Cross(cp1.rA, P1) + Cross(cp2.rA, P2));
             * 
             * vB += invMassB * (P1 + P2); wB += invIB * (Cross(cp1.rB, P1) + Cross(cp2.rB, P2));
             */
                        float P1x = normalx * dx;
                        float P1y = normaly * dx;
                        float P2x = normalx * dy;
                        float P2y = normaly * dy;
                        vA.x -= mA * (P1x + P2x);
                        vA.y -= mA * (P1y + P2y);
                        vB.x += mB * (P1x + P2x);
                        vB.y += mB * (P1y + P2y);
                        wA -= iA * (cp1rA.x * P1y - cp1rA.y * P1x + (cp2rA.x * P2y - cp2rA.y * P2x));
                        wB += iB * (cp1rB.x * P1y - cp1rB.y * P1x + (cp2rB.x * P2y - cp2rB.y * P2x));
                        // Accumulate
                        cp1.normalImpulse = xx;
                        cp2.normalImpulse = xy;
                        break;
                    }
                    //
                    // Case 4: x1 = 0 and x2 = 0
                    //
                    // vn1 = b1
                    // vn2 = ;
                    xx = 0.0f;
                    xy = 0.0f;
                    vn1 = bx;
                    vn2 = by;
                    if (vn1 >= 0.0f && vn2 >= 0.0f) {
                        // Resubstitute for the incremental impulse
                        float dx = xx - ax;
                        float dy = xy - ay;
                        // Apply incremental impulse
            /*
             * Vec2 P1 = d.x * normal; Vec2 P2 = d.y * normal; vA -= invMassA * (P1 + P2); wA -=
             * invIA * (Cross(cp1.rA, P1) + Cross(cp2.rA, P2));
             * 
             * vB += invMassB * (P1 + P2); wB += invIB * (Cross(cp1.rB, P1) + Cross(cp2.rB, P2));
             */
                        float P1x = normalx * dx;
                        float P1y = normaly * dx;
                        float P2x = normalx * dy;
                        float P2y = normaly * dy;
                        vA.x -= mA * (P1x + P2x);
                        vA.y -= mA * (P1y + P2y);
                        vB.x += mB * (P1x + P2x);
                        vB.y += mB * (P1y + P2y);
                        wA -= iA * (cp1rA.x * P1y - cp1rA.y * P1x + (cp2rA.x * P2y - cp2rA.y * P2x));
                        wB += iB * (cp1rB.x * P1y - cp1rB.y * P1x + (cp2rB.x * P2y - cp2rB.y * P2x));
                        // Accumulate
                        cp1.normalImpulse = xx;
                        cp2.normalImpulse = xy;
                        break;
                    }
                    // No solution, give up. This is hit sometimes, but it doesn't seem to matter.
                    break;
                }
            }
            // m_velocities[indexA].v.set(vA);
            m_velocities[indexA].w = wA;
            // m_velocities[indexB].v.set(vB);
            m_velocities[indexB].w = wB;
        }
    }
    public void storeImpulses() {
        for (int i = 0; i < m_count; i++) {
            final ContactVelocityConstraint vc = m_velocityConstraints[i];
            final Manifold manifold = m_contacts[vc.contactIndex].getManifold();
            for (int j = 0; j < vc.pointCount; j++) {
                manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
                manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
            }
        }
    }
  /*
   * #if 0 // Sequential solver. bool ContactSolver::SolvePositionConstraints(float baumgarte) {
   * float minSeparation = 0.0f;
   * 
   * for (int i = 0; i < m_constraintCount; ++i) { ContactConstraint* c = m_constraints + i; Body*
   * bodyA = c.bodyA; Body* bodyB = c.bodyB; float invMassA = bodyA.m_mass * bodyA.m_invMass; float
   * invIA = bodyA.m_mass * bodyA.m_invI; float invMassB = bodyB.m_mass * bodyB.m_invMass; float
   * invIB = bodyB.m_mass * bodyB.m_invI;
   * 
   * Vec2 normal = c.normal;
   * 
   * // Solve normal constraints for (int j = 0; j < c.pointCount; ++j) { ContactConstraintPoint*
   * ccp = c.points + j;
   * 
   * Vec2 r1 = Mul(bodyA.GetXForm().R, ccp.localAnchorA - bodyA.GetLocalCenter()); Vec2 r2 =
   * Mul(bodyB.GetXForm().R, ccp.localAnchorB - bodyB.GetLocalCenter());
   * 
   * Vec2 p1 = bodyA.m_sweep.c + r1; Vec2 p2 = bodyB.m_sweep.c + r2; Vec2 dp = p2 - p1;
   * 
   * // Approximate the current separation. float separation = Dot(dp, normal) + ccp.separation;
   * 
   * // Track max constraint error. minSeparation = Min(minSeparation, separation);
   * 
   * // Prevent large corrections and allow slop. float C = Clamp(baumgarte * (separation +
   * _linearSlop), -_maxLinearCorrection, 0.0f);
   * 
   * // Compute normal impulse float impulse = -ccp.equalizedMass * C;
   * 
   * Vec2 P = impulse * normal;
   * 
   * bodyA.m_sweep.c -= invMassA * P; bodyA.m_sweep.a -= invIA * Cross(r1, P);
   * bodyA.SynchronizeTransform();
   * 
   * bodyB.m_sweep.c += invMassB * P; bodyB.m_sweep.a += invIB * Cross(r2, P);
   * bodyB.SynchronizeTransform(); } }
   * 
   * // We can't expect minSpeparation >= -_linearSlop because we don't // push the separation above
   * -_linearSlop. return minSeparation >= -1.5f * _linearSlop; }
   */
    private final PositionSolverManifold psolver = new PositionSolverManifold();
    /**
     * Sequential solver.
     */
    public boolean solvePositionConstraints() {
        float minSeparation = 0.0f;
        for (int i = 0; i < m_count; ++i) {
            ContactPositionConstraint pc = m_positionConstraints[i];
            int indexA = pc.indexA;
            int indexB = pc.indexB;
            float mA = pc.invMassA;
            float iA = pc.invIA;
            final float localCenterAx = pc.localCenterA.x;
            final float localCenterAy = pc.localCenterA.y;
            float mB = pc.invMassB;
            float iB = pc.invIB;
            final float localCenterBx = pc.localCenterB.x;
            final float localCenterBy = pc.localCenterB.y;
            int pointCount = pc.pointCount;
            Vec2 cA = m_positions[indexA].c;
            float aA = m_positions[indexA].a;
            Vec2 cB = m_positions[indexB].c;
            float aB = m_positions[indexB].a;
            // Solve normal constraints
            for (int j = 0; j < pointCount; ++j) {
                final Rotation xfAq = xfA.q;
                final Rotation xfBq = xfB.q;
                xfAq.set(aA);
                xfBq.set(aB);
                xfA.p.x = cA.x - xfAq.c * localCenterAx + xfAq.s * localCenterAy;
                xfA.p.y = cA.y - xfAq.s * localCenterAx - xfAq.c * localCenterAy;
                xfB.p.x = cB.x - xfBq.c * localCenterBx + xfBq.s * localCenterBy;
                xfB.p.y = cB.y - xfBq.s * localCenterBx - xfBq.c * localCenterBy;
                psolver.initialize(pc, xfA, xfB, j);
                final Vec2 normal = psolver.normal;
                final Vec2 point = psolver.point;
                final float separation = psolver.separation;
                float rAx = point.x - cA.x;
                float rAy = point.y - cA.y;
                float rBx = point.x - cB.x;
                float rBy = point.y - cB.y;
                // Track max constraint error.
                minSeparation = Math.min(minSeparation, separation);
                // Prevent large corrections and allow slop.
                final float C =
                        FXGLMath.clamp(JBoxSettings.baumgarte * (separation + JBoxSettings.linearSlop),
                                -JBoxSettings.maxLinearCorrection, 0.0f);
                // Compute the effective mass.
                final float rnA = rAx * normal.y - rAy * normal.x;
                final float rnB = rBx * normal.y - rBy * normal.x;
                final float K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                // Compute normal impulse
                final float impulse = K > 0.0f ? -C / K : 0.0f;
                float Px = normal.x * impulse;
                float Py = normal.y * impulse;
                cA.x -= Px * mA;
                cA.y -= Py * mA;
                aA -= iA * (rAx * Py - rAy * Px);
                cB.x += Px * mB;
                cB.y += Py * mB;
                aB += iB * (rBx * Py - rBy * Px);
            }
            m_positions[indexA].a = aA;
            m_positions[indexB].a = aB;
        }
        // We can't expect minSpeparation >= -linearSlop because we don't
        // push the separation above -linearSlop.
        return minSeparation >= -3.0f * JBoxSettings.linearSlop;
    }
    // Sequential position solver for position constraints.
    public boolean solveTOIPositionConstraints(int toiIndexA, int toiIndexB) {
        float minSeparation = 0.0f;
        for (int i = 0; i < m_count; ++i) {
            ContactPositionConstraint pc = m_positionConstraints[i];
            int indexA = pc.indexA;
            int indexB = pc.indexB;
            Vec2 localCenterA = pc.localCenterA;
            Vec2 localCenterB = pc.localCenterB;
            final float localCenterAx = localCenterA.x;
            final float localCenterAy = localCenterA.y;
            final float localCenterBx = localCenterB.x;
            final float localCenterBy = localCenterB.y;
            int pointCount = pc.pointCount;
            float mA = 0.0f;
            float iA = 0.0f;
            if (indexA == toiIndexA || indexA == toiIndexB) {
                mA = pc.invMassA;
                iA = pc.invIA;
            }
            float mB = 0f;
            float iB = 0f;
            if (indexB == toiIndexA || indexB == toiIndexB) {
                mB = pc.invMassB;
                iB = pc.invIB;
            }
            Vec2 cA = m_positions[indexA].c;
            float aA = m_positions[indexA].a;
            Vec2 cB = m_positions[indexB].c;
            float aB = m_positions[indexB].a;
            // Solve normal constraints
            for (int j = 0; j < pointCount; ++j) {
                final Rotation xfAq = xfA.q;
                final Rotation xfBq = xfB.q;
                xfAq.set(aA);
                xfBq.set(aB);
                xfA.p.x = cA.x - xfAq.c * localCenterAx + xfAq.s * localCenterAy;
                xfA.p.y = cA.y - xfAq.s * localCenterAx - xfAq.c * localCenterAy;
                xfB.p.x = cB.x - xfBq.c * localCenterBx + xfBq.s * localCenterBy;
                xfB.p.y = cB.y - xfBq.s * localCenterBx - xfBq.c * localCenterBy;
                final PositionSolverManifold psm = psolver;
                psm.initialize(pc, xfA, xfB, j);
                Vec2 normal = psm.normal;
                Vec2 point = psm.point;
                float separation = psm.separation;
                float rAx = point.x - cA.x;
                float rAy = point.y - cA.y;
                float rBx = point.x - cB.x;
                float rBy = point.y - cB.y;
                // Track max constraint error.
                minSeparation = Math.min(minSeparation, separation);
                // Prevent large corrections and allow slop.
                float C =
                        FXGLMath.clamp(JBoxSettings.toiBaugarte * (separation + JBoxSettings.linearSlop),
                                -JBoxSettings.maxLinearCorrection, 0.0f);
                // Compute the effective mass.
                float rnA = rAx * normal.y - rAy * normal.x;
                float rnB = rBx * normal.y - rBy * normal.x;
                float K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
                // Compute normal impulse
                float impulse = K > 0.0f ? -C / K : 0.0f;
                float Px = normal.x * impulse;
                float Py = normal.y * impulse;
                cA.x -= Px * mA;
                cA.y -= Py * mA;
                aA -= iA * (rAx * Py - rAy * Px);
                cB.x += Px * mB;
                cB.y += Py * mB;
                aB += iB * (rBx * Py - rBy * Px);
            }
            m_positions[indexA].a = aA;
            m_positions[indexB].a = aB;
        }
        // We can't expect minSpeparation >= -_linearSlop because we don't
        // push the separation above -_linearSlop.
        return minSeparation >= -1.5f * JBoxSettings.linearSlop;
    }
    public static class ContactSolverDef {
        public TimeStep step;
        public Contact[] contacts;
        public int count;
        public Position[] positions;
        public Velocity[] velocities;
    }
    private static class PositionSolverManifold {
        final Vec2 normal = new Vec2();
        final Vec2 point = new Vec2();
        float separation;
        @SuppressWarnings("PMD.UselessParentheses")
        public void initialize(ContactPositionConstraint pc, Transform xfA, Transform xfB, int index) {
            assert pc.pointCount > 0;
            final Rotation xfAq = xfA.q;
            final Rotation xfBq = xfB.q;
            final Vec2 pcLocalPointsI = pc.localPoints[index];
            switch (pc.type) {
                case CIRCLES: {
                    // Transform.mulToOutUnsafe(xfA, pc.localPoint, pointA);
                    // Transform.mulToOutUnsafe(xfB, pc.localPoints[0], pointB);
                    // normal.set(pointB).subLocal(pointA);
                    // normal.normalize();
                    //
                    // point.set(pointA).addLocal(pointB).mulLocal(.5f);
                    // temp.set(pointB).subLocal(pointA);
                    // separation = Vec2.dot(temp, normal) - pc.radiusA - pc.radiusB;
                    final Vec2 plocalPoint = pc.localPoint;
                    final Vec2 pLocalPoints0 = pc.localPoints[0];
                    final float pointAx = (xfAq.c * plocalPoint.x - xfAq.s * plocalPoint.y) + xfA.p.x;
                    final float pointAy = (xfAq.s * plocalPoint.x + xfAq.c * plocalPoint.y) + xfA.p.y;
                    final float pointBx = (xfBq.c * pLocalPoints0.x - xfBq.s * pLocalPoints0.y) + xfB.p.x;
                    final float pointBy = (xfBq.s * pLocalPoints0.x + xfBq.c * pLocalPoints0.y) + xfB.p.y;
                    normal.x = pointBx - pointAx;
                    normal.y = pointBy - pointAy;
                    normal.getLengthAndNormalize();
                    point.x = (pointAx + pointBx) * .5f;
                    point.y = (pointAy + pointBy) * .5f;
                    final float tempx = pointBx - pointAx;
                    final float tempy = pointBy - pointAy;
                    separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;
                    break;
                }
                case FACE_A: {
                    // Rot.mulToOutUnsafe(xfAq, pc.localNormal, normal);
                    // Transform.mulToOutUnsafe(xfA, pc.localPoint, planePoint);
                    //
                    // Transform.mulToOutUnsafe(xfB, pc.localPoints[index], clipPoint);
                    // temp.set(clipPoint).subLocal(planePoint);
                    // separation = Vec2.dot(temp, normal) - pc.radiusA - pc.radiusB;
                    // point.set(clipPoint);
                    final Vec2 pcLocalNormal = pc.localNormal;
                    final Vec2 pcLocalPoint = pc.localPoint;
                    normal.x = xfAq.c * pcLocalNormal.x - xfAq.s * pcLocalNormal.y;
                    normal.y = xfAq.s * pcLocalNormal.x + xfAq.c * pcLocalNormal.y;
                    final float planePointx = (xfAq.c * pcLocalPoint.x - xfAq.s * pcLocalPoint.y) + xfA.p.x;
                    final float planePointy = (xfAq.s * pcLocalPoint.x + xfAq.c * pcLocalPoint.y) + xfA.p.y;
                    final float clipPointx = (xfBq.c * pcLocalPointsI.x - xfBq.s * pcLocalPointsI.y) + xfB.p.x;
                    final float clipPointy = (xfBq.s * pcLocalPointsI.x + xfBq.c * pcLocalPointsI.y) + xfB.p.y;
                    final float tempx = clipPointx - planePointx;
                    final float tempy = clipPointy - planePointy;
                    separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;
                    point.x = clipPointx;
                    point.y = clipPointy;
                    break;
                }
                case FACE_B: {
                    // Rot.mulToOutUnsafe(xfBq, pc.localNormal, normal);
                    // Transform.mulToOutUnsafe(xfB, pc.localPoint, planePoint);
                    //
                    // Transform.mulToOutUnsafe(xfA, pcLocalPointsI, clipPoint);
                    // temp.set(clipPoint).subLocal(planePoint);
                    // separation = Vec2.dot(temp, normal) - pc.radiusA - pc.radiusB;
                    // point.set(clipPoint);
                    //
                    // // Ensure normal points from A to B
                    // normal.negateLocal();
                    final Vec2 pcLocalNormal = pc.localNormal;
                    final Vec2 pcLocalPoint = pc.localPoint;
                    normal.x = xfBq.c * pcLocalNormal.x - xfBq.s * pcLocalNormal.y;
                    normal.y = xfBq.s * pcLocalNormal.x + xfBq.c * pcLocalNormal.y;
                    final float planePointx = (xfBq.c * pcLocalPoint.x - xfBq.s * pcLocalPoint.y) + xfB.p.x;
                    final float planePointy = (xfBq.s * pcLocalPoint.x + xfBq.c * pcLocalPoint.y) + xfB.p.y;
                    final float clipPointx = (xfAq.c * pcLocalPointsI.x - xfAq.s * pcLocalPointsI.y) + xfA.p.x;
                    final float clipPointy = (xfAq.s * pcLocalPointsI.x + xfAq.c * pcLocalPointsI.y) + xfA.p.y;
                    final float tempx = clipPointx - planePointx;
                    final float tempy = clipPointy - planePointy;
                    separation = tempx * normal.x + tempy * normal.y - pc.radiusA - pc.radiusB;
                    point.x = clipPointx;
                    point.y = clipPointy;
                    normal.x *= -1;
                    normal.y *= -1;
                }
                break;
            }
        }
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.dynamics.contacts;
import com.almasb.fxgl.physics.box2d.dynamics.Body;
/**
 * A contact edge is used to connect bodies and contacts together in a contact graph where each body
 * is a node and each contact is an edge. A contact edge belongs to a doubly linked list maintained
 * in each attached body. Each contact has two contact nodes, one for each attached body.
 *
 * @author daniel
 */
public class ContactEdge {
    /**
     * provides quick access to the other body attached.
     */
    public Body other = null;
    /**
     * the contact
     */
    public Contact contact = null;
    /**
     * the previous contact edge in the body's contact list
     */
    public ContactEdge prev = null;
    /**
     * the next contact edge in the body's contact list
     */
    public ContactEdge next = null;
    void reset() {
        other = null;
        contact = null;
        prev = null;
        next = null;
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.physics.box2d.callbacks.ContactFilter;
import com.almasb.fxgl.physics.box2d.callbacks.ContactListener;
import com.almasb.fxgl.physics.box2d.callbacks.PairCallback;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.shapes.ShapeType;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
import com.almasb.fxgl.physics.box2d.pooling.IDynamicStack;
import com.almasb.fxgl.physics.box2d.pooling.IWorldPool;
/**
 * Delegate of World.
 *
 * @author Daniel Murphy
 */
class ContactManager implements PairCallback {
    Contact contactList = null;
    int contactCount = 0;
    private ContactListener contactListener = null;
    private ContactFilter contactFilter = new ContactFilter();
    private final IWorldPool pool;
    final BroadPhase broadPhase;
    private ContactRegister[][] contactStacks = new ContactRegister[ShapeType.values().length][ShapeType.values().length];
    ContactManager(IWorldPool pool, BroadPhase broadPhase) {
        this.pool = pool;
        this.broadPhase = broadPhase;
        initializeRegisters();
    }
    private void initializeRegisters() {
        addType(pool.getCircleContactStack(), ShapeType.CIRCLE, ShapeType.CIRCLE);
        addType(pool.getPolyCircleContactStack(), ShapeType.POLYGON, ShapeType.CIRCLE);
        addType(pool.getPolyContactStack(), ShapeType.POLYGON, ShapeType.POLYGON);
        addType(pool.getEdgeCircleContactStack(), ShapeType.EDGE, ShapeType.CIRCLE);
        addType(pool.getEdgePolyContactStack(), ShapeType.EDGE, ShapeType.POLYGON);
        addType(pool.getChainCircleContactStack(), ShapeType.CHAIN, ShapeType.CIRCLE);
        addType(pool.getChainPolyContactStack(), ShapeType.CHAIN, ShapeType.POLYGON);
    }
    private void addType(IDynamicStack<Contact> creator, ShapeType type1, ShapeType type2) {
        contactStacks[type1.ordinal()][type2.ordinal()] = new ContactRegister(creator, true);
        if (type1 != type2) {
            contactStacks[type2.ordinal()][type1.ordinal()] = new ContactRegister(creator, false);
        }
    }
    void setContactFilter(ContactFilter contactFilter) {
        this.contactFilter = contactFilter;
    }
    void setContactListener(ContactListener contactListener) {
        this.contactListener = contactListener;
    }
    ContactListener getContactListener() {
        return contactListener;
    }
    /**
     * Broad-phase callback.
     *
     * @param proxyUserDataA proxy user data A
     * @param proxyUserDataB proxy user data B
     */
    @Override
    public void addPair(Object proxyUserDataA, Object proxyUserDataB) {
        Fixture.FixtureProxy proxyA = (Fixture.FixtureProxy) proxyUserDataA;
        Fixture.FixtureProxy proxyB = (Fixture.FixtureProxy) proxyUserDataB;
        Fixture fixtureA = proxyA.fixture;
        Fixture fixtureB = proxyB.fixture;
        int indexA = proxyA.childIndex;
        int indexB = proxyB.childIndex;
        Body bodyA = fixtureA.getBody();
        Body bodyB = fixtureB.getBody();
        // Are the fixtures on the same body?
        if (bodyA == bodyB) {
            return;
        }
        // TODO_ERIN use a hash table to remove a potential bottleneck when both
        // bodies have a lot of contacts.
        // Does a contact already exist?
        ContactEdge edge = bodyB.getContactList();
        while (edge != null) {
            if (edge.other == bodyA) {
                Fixture fA = edge.contact.getFixtureA();
                Fixture fB = edge.contact.getFixtureB();
                int iA = edge.contact.getChildIndexA();
                int iB = edge.contact.getChildIndexB();
                if (fA == fixtureA && iA == indexA && fB == fixtureB && iB == indexB) {
                    // A contact already exists.
                    return;
                }
                if (fA == fixtureB && iA == indexB && fB == fixtureA && iB == indexA) {
                    // A contact already exists.
                    return;
                }
            }
            edge = edge.next;
        }
        // Does a joint override collision? is at least one body dynamic?
        if (!bodyB.shouldCollide(bodyA)) {
            return;
        }
        // Check user filtering.
        if (contactFilter != null && !contactFilter.shouldCollide(fixtureA, fixtureB)) {
            return;
        }
        // Call the factory.
        Contact c = popContact(fixtureA, indexA, fixtureB, indexB);
        if (c == null) {
            return;
        }
        // Contact creation may swap fixtures.
        fixtureA = c.getFixtureA();
        fixtureB = c.getFixtureB();
        bodyA = fixtureA.getBody();
        bodyB = fixtureB.getBody();
        // Insert into the world.
        c.m_prev = null;
        c.m_next = contactList;
        if (contactList != null) {
            contactList.m_prev = c;
        }
        contactList = c;
        // Connect to island graph.
        // Connect to body A
        c.m_nodeA.contact = c;
        c.m_nodeA.other = bodyB;
        c.m_nodeA.prev = null;
        c.m_nodeA.next = bodyA.m_contactList;
        if (bodyA.m_contactList != null) {
            bodyA.m_contactList.prev = c.m_nodeA;
        }
        bodyA.m_contactList = c.m_nodeA;
        // Connect to body B
        c.m_nodeB.contact = c;
        c.m_nodeB.other = bodyA;
        c.m_nodeB.prev = null;
        c.m_nodeB.next = bodyB.m_contactList;
        if (bodyB.m_contactList != null) {
            bodyB.m_contactList.prev = c.m_nodeB;
        }
        bodyB.m_contactList = c.m_nodeB;
        // wake up the bodies
        if (!fixtureA.isSensor() && !fixtureB.isSensor()) {
            bodyA.setAwake(true);
            bodyB.setAwake(true);
        }
        ++contactCount;
    }
    void findNewContacts() {
        broadPhase.updatePairs(this);
    }
    void destroy(Contact c) {
        Body bodyA = c.getFixtureA().getBody();
        Body bodyB = c.getFixtureB().getBody();
        if (contactListener != null && c.isTouching()) {
            contactListener.endContact(c);
        }
        // Remove from the world.
        if (c.m_prev != null) {
            c.m_prev.m_next = c.m_next;
        }
        if (c.m_next != null) {
            c.m_next.m_prev = c.m_prev;
        }
        if (c == contactList) {
            contactList = c.m_next;
        }
        // Remove from body 1
        if (c.m_nodeA.prev != null) {
            c.m_nodeA.prev.next = c.m_nodeA.next;
        }
        if (c.m_nodeA.next != null) {
            c.m_nodeA.next.prev = c.m_nodeA.prev;
        }
        if (c.m_nodeA == bodyA.m_contactList) {
            bodyA.m_contactList = c.m_nodeA.next;
        }
        // Remove from body 2
        if (c.m_nodeB.prev != null) {
            c.m_nodeB.prev.next = c.m_nodeB.next;
        }
        if (c.m_nodeB.next != null) {
            c.m_nodeB.next.prev = c.m_nodeB.prev;
        }
        if (c.m_nodeB == bodyB.m_contactList) {
            bodyB.m_contactList = c.m_nodeB.next;
        }
        // Call the factory.
        pushContact(c);
        --contactCount;
    }
    /**
     * This is the top level collision call for the time step. Here all the narrow phase collision is
     * processed for the world contact list.
     */
    void collide() {
        // Update awake contacts.
        Contact c = contactList;
        while (c != null) {
            Fixture fixtureA = c.getFixtureA();
            Fixture fixtureB = c.getFixtureB();
            int indexA = c.getChildIndexA();
            int indexB = c.getChildIndexB();
            Body bodyA = fixtureA.getBody();
            Body bodyB = fixtureB.getBody();
            // is this contact flagged for filtering?
            if ((c.m_flags & Contact.FILTER_FLAG) == Contact.FILTER_FLAG) {
                // Should these bodies collide?
                if (!bodyB.shouldCollide(bodyA)) {
                    Contact cNuke = c;
                    c = cNuke.getNext();
                    destroy(cNuke);
                    continue;
                }
                // Check user filtering.
                if (contactFilter != null && !contactFilter.shouldCollide(fixtureA, fixtureB)) {
                    Contact cNuke = c;
                    c = cNuke.getNext();
                    destroy(cNuke);
                    continue;
                }
                // Clear the filtering flag.
                c.m_flags &= ~Contact.FILTER_FLAG;
            }
            boolean activeA = bodyA.isAwake() && bodyA.getType() != BodyType.STATIC;
            boolean activeB = bodyB.isAwake() && bodyB.getType() != BodyType.STATIC;
            // At least one body must be awake and it must be dynamic or kinematic.
            if (!activeA && !activeB) {
                c = c.getNext();
                continue;
            }
            int proxyIdA = fixtureA.getProxyId(indexA);
            int proxyIdB = fixtureB.getProxyId(indexB);
            boolean overlap = broadPhase.testOverlap(proxyIdA, proxyIdB);
            // Here we destroy contacts that cease to overlap in the broad-phase.
            if (!overlap) {
                Contact cNuke = c;
                c = cNuke.getNext();
                destroy(cNuke);
                continue;
            }
            // The contact persists.
            c.update(contactListener);
            c = c.getNext();
        }
    }
    private Contact popContact(Fixture fixtureA, int indexA, Fixture fixtureB, int indexB) {
        final ShapeType type1 = fixtureA.getType();
        final ShapeType type2 = fixtureB.getType();
        final ContactRegister reg = contactStacks[type1.ordinal()][type2.ordinal()];
        if (reg == null)
            return null;
        Contact c = reg.creator.pop();
        if (reg.primary) {
            c.init(fixtureA, indexA, fixtureB, indexB);
        } else {
            c.init(fixtureB, indexB, fixtureA, indexA);
        }
        return c;
    }
    private void pushContact(Contact contact) {
        Fixture fixtureA = contact.getFixtureA();
        Fixture fixtureB = contact.getFixtureB();
        if (contact.getManifold().pointCount > 0 && !fixtureA.isSensor() && !fixtureB.isSensor()) {
            fixtureA.getBody().setAwake(true);
            fixtureB.getBody().setAwake(true);
        }
        ShapeType type1 = fixtureA.getType();
        ShapeType type2 = fixtureB.getType();
        IDynamicStack<Contact> creator = contactStacks[type1.ordinal()][type2.ordinal()].creator;
        creator.push(contact);
    }
    private static class ContactRegister {
        final IDynamicStack<Contact> creator;
        final boolean primary;
        ContactRegister(IDynamicStack<Contact> creator, boolean primary) {
            this.creator = creator;
            this.primary = primary;
        }
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.dynamics.contacts;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.physics.box2d.callbacks.ContactListener;
import com.almasb.fxgl.physics.box2d.collision.ContactID;
import com.almasb.fxgl.physics.box2d.collision.GenericCollision;
import com.almasb.fxgl.physics.box2d.collision.Manifold;
import com.almasb.fxgl.physics.box2d.collision.ManifoldPoint;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.Body;
import com.almasb.fxgl.physics.box2d.dynamics.Fixture;
import com.almasb.fxgl.physics.box2d.pooling.IWorldPool;
/**
 * The class manages contact between two shapes.
 * A contact exists for each overlapping AABB in the broad-phase (except if filtered).
 * Therefore a contact object may exist that has no contact points.
 *
 * @author daniel
 */
public abstract class Contact {
    // Flags stored in m_flags
    // Used when crawling contact graph when forming islands.
    public static final int ISLAND_FLAG = 0x0001;
    // Set when the shapes are touching.
    public static final int TOUCHING_FLAG = 0x0002;
    // This contact can be disabled (by user)
    public static final int ENABLED_FLAG = 0x0004;
    // This contact needs filtering because a fixture filter was changed.
    public static final int FILTER_FLAG = 0x0008;
    public static final int TOI_FLAG = 0x0020;
    public int m_flags;
    // World pool and list pointers.
    public Contact m_prev;
    public Contact m_next;
    // Nodes for connecting bodies.
    public ContactEdge m_nodeA = new ContactEdge();
    public ContactEdge m_nodeB = new ContactEdge();
    public Fixture m_fixtureA = null;
    public Fixture m_fixtureB = null;
    public int m_indexA;
    public int m_indexB;
    private final Manifold m_manifold = new Manifold();
    public float m_toiCount;
    public float m_toi;
    private float m_friction;
    private float m_restitution;
    private float m_tangentSpeed;
    protected final IWorldPool pool;
    protected Contact(IWorldPool argPool) {
        pool = argPool;
    }
    /** initialization for pooling */
    public void init(Fixture fA, int indexA, Fixture fB, int indexB) {
        m_flags = ENABLED_FLAG;
        m_fixtureA = fA;
        m_fixtureB = fB;
        m_indexA = indexA;
        m_indexB = indexB;
        m_manifold.pointCount = 0;
        m_prev = null;
        m_next = null;
        m_nodeA.reset();
        m_nodeB.reset();
        m_toiCount = 0;
        m_friction = mixFriction(fA.getFriction(), fB.getFriction());
        m_restitution = mixRestitution(fA.getRestitution(), fB.getRestitution());
        m_tangentSpeed = 0;
    }
    /**
     * Get the contact manifold. Do not set the point count to zero. Instead call Disable.
     */
    public Manifold getManifold() {
        return m_manifold;
    }
    /**
     * @return is this contact touching
     */
    public boolean isTouching() {
        return (m_flags & TOUCHING_FLAG) == TOUCHING_FLAG;
    }
    /**
     * Enable/disable this contact. This can be used inside the pre-solve contact listener. The
     * contact is only disabled for the current time step (or sub-step in continuous collisions).
     *
     * @param flag
     */
    public void setEnabled(boolean flag) {
        if (flag) {
            m_flags |= ENABLED_FLAG;
        } else {
            m_flags &= ~ENABLED_FLAG;
        }
    }
    public boolean isEnabled() {
        return (m_flags & ENABLED_FLAG) == ENABLED_FLAG;
    }
    /**
     * @return the next contact in the world's contact list
     */
    public Contact getNext() {
        return m_next;
    }
    /**
     * @return the first fixture in this contact
     */
    public Fixture getFixtureA() {
        return m_fixtureA;
    }
    public int getChildIndexA() {
        return m_indexA;
    }
    /**
     * @return the second fixture in this contact
     */
    public Fixture getFixtureB() {
        return m_fixtureB;
    }
    public int getChildIndexB() {
        return m_indexB;
    }
    public void setFriction(float friction) {
        m_friction = friction;
    }
    public float getFriction() {
        return m_friction;
    }
    public void resetFriction() {
        m_friction = mixFriction(m_fixtureA.getFriction(), m_fixtureB.getFriction());
    }
    public void setRestitution(float restitution) {
        m_restitution = restitution;
    }
    public float getRestitution() {
        return m_restitution;
    }
    public void resetRestitution() {
        m_restitution = mixRestitution(m_fixtureA.getRestitution(), m_fixtureB.getRestitution());
    }
    public void setTangentSpeed(float speed) {
        m_tangentSpeed = speed;
    }
    public float getTangentSpeed() {
        return m_tangentSpeed;
    }
    public abstract void evaluate(Manifold manifold, Transform xfA, Transform xfB);
    /**
     * Flag this contact for filtering. Filtering will occur the next time step.
     */
    public void flagForFiltering() {
        m_flags |= FILTER_FLAG;
    }
    // djm pooling
    private final Manifold oldManifold = new Manifold();
    public void update(ContactListener listener) {
        oldManifold.set(m_manifold);
        // Re-enable this contact.
        m_flags |= ENABLED_FLAG;
        boolean wasTouching = (m_flags & TOUCHING_FLAG) == TOUCHING_FLAG;
        boolean sensorA = m_fixtureA.isSensor();
        boolean sensorB = m_fixtureB.isSensor();
        boolean sensor = sensorA || sensorB;
        Body bodyA = m_fixtureA.getBody();
        Body bodyB = m_fixtureB.getBody();
        Transform xfA = bodyA.getTransform();
        Transform xfB = bodyB.getTransform();
        boolean touching;
        if (sensor) {
            Shape shapeA = m_fixtureA.getShape();
            Shape shapeB = m_fixtureB.getShape();
            touching = GenericCollision.testOverlap(pool, shapeA, m_indexA, shapeB, m_indexB, xfA, xfB);
            // Sensors don't generate manifolds.
            m_manifold.pointCount = 0;
        } else {
            evaluate(m_manifold, xfA, xfB);
            touching = m_manifold.pointCount > 0;
            // Match old contact ids to new contact ids and copy the
            // stored impulses to warm start the solver.
            for (int i = 0; i < m_manifold.pointCount; ++i) {
                ManifoldPoint mp2 = m_manifold.points[i];
                mp2.normalImpulse = 0.0f;
                mp2.tangentImpulse = 0.0f;
                ContactID id2 = mp2.id;
                for (int j = 0; j < oldManifold.pointCount; ++j) {
                    ManifoldPoint mp1 = oldManifold.points[j];
                    if (mp1.id.isEqual(id2)) {
                        mp2.normalImpulse = mp1.normalImpulse;
                        mp2.tangentImpulse = mp1.tangentImpulse;
                        break;
                    }
                }
            }
            if (touching != wasTouching) {
                bodyA.setAwake(true);
                bodyB.setAwake(true);
            }
        }
        if (touching) {
            m_flags |= TOUCHING_FLAG;
        } else {
            m_flags &= ~TOUCHING_FLAG;
        }
        if (listener == null) {
            return;
        }
        if (!wasTouching && touching) {
            listener.beginContact(this);
        }
        if (wasTouching && !touching) {
            listener.endContact(this);
        }
        if (!sensor && touching) {
            listener.preSolve(this, oldManifold);
        }
    }
    /**
     * Friction mixing law.
     * The idea is to allow either fixture to drive the restitution to zero.
     * For example, anything slides on ice.
     */
    private static float mixFriction(float friction1, float friction2) {
        return FXGLMath.sqrtF(friction1 * friction2);
    }
    /**
     * Restitution mixing law.
     * The idea is allow for anything to bounce off an inelastic surface.
     * For example, a superball bounces on anything.
     */
    private static float mixRestitution(float restitution1, float restitution2) {
        return restitution1 > restitution2 ? restitution1 : restitution2;
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.pooling;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.core.math.Vec3;
import com.almasb.fxgl.physics.box2d.collision.Collision;
import com.almasb.fxgl.physics.box2d.collision.Distance;
import com.almasb.fxgl.physics.box2d.collision.TimeOfImpact;
import com.almasb.fxgl.physics.box2d.common.Mat22;
import com.almasb.fxgl.physics.box2d.common.Mat33;
import com.almasb.fxgl.physics.box2d.common.Rotation;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
/**
 * World pool interface
 * @author Daniel
 *
 */
public interface IWorldPool {
    IDynamicStack<Contact> getPolyContactStack();
    IDynamicStack<Contact> getCircleContactStack();
    IDynamicStack<Contact> getPolyCircleContactStack();
    IDynamicStack<Contact> getEdgeCircleContactStack();
    IDynamicStack<Contact> getEdgePolyContactStack();
    IDynamicStack<Contact> getChainCircleContactStack();
    IDynamicStack<Contact> getChainPolyContactStack();
    Vec2 popVec2();
    Vec2[] popVec2(int num);
    void pushVec2(int num);
    Vec3 popVec3();
    Vec3[] popVec3(int num);
    void pushVec3(int num);
    Mat22 popMat22();
    Mat22[] popMat22(int num);
    void pushMat22(int num);
    Mat33 popMat33();
    void pushMat33(int num);
    Rotation popRot();
    void pushRot(int num);
    Collision getCollision();
    TimeOfImpact getTimeOfImpact();
    Distance getDistance();
    Vec2[] getVec2Array(int argLength);
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.core.math;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.paint.Color;
import java.util.List;
import java.util.Optional;
import java.util.Random;
/**
 * Utility and fast math functions.
 * Thanks to Riven on JavaGaming.org for the basis of sin/cos/floor/ceil.
 * Some functions also come from jbox2d.
 *
 * @author Nathan Sweet
 * @author Almas Baimagambetov (AlmasB) (almaslvl@gmail.com)
 */
public final class FXGLMath {
    private FXGLMath() {}
    /**
     * A "close to zero" double epsilon value for use.
     */
    public static final double EPSILON = 1.1920928955078125E-7;
    public static final double PI = Math.PI;
    public static final double PI2 = PI * 2;
    public static final double HALF_PI = PI / 2;
    public static final float PI_F = (float) Math.PI;
    public static final float PI2_F = (float) (Math.PI * 2);
    public static final float HALF_PI_F = PI_F / 2;
    public static final double E = Math.E;
    private static final int SIN_BITS = 14; // 16KB. Adjust for accuracy.
    private static final int SIN_MASK = ~(-1 << SIN_BITS);
    private static final int SIN_COUNT = SIN_MASK + 1;
    private static final double radFull = PI * 2;
    private static final double degFull = 360;
    private static final double radToIndex = SIN_COUNT / radFull;
    private static final double degToIndex = SIN_COUNT / degFull;
    private static class Sin {
        static final double[] table = new double[SIN_COUNT];
        static {
            for (int i = 0; i < SIN_COUNT; i++)
                table[i] = Math.sin((i + 0.5f) / SIN_COUNT * radFull);
            for (int i = 0; i < 360; i += 90)
                table[(int) (i * degToIndex) & SIN_MASK] = Math.sin(toRadians(i));
        }
    }
    /**
     * @param radians angle in radians
     * @return the sine in radians from a lookup table
     */
    public static double sin(double radians) {
        return Sin.table[(int) (radians * radToIndex) & SIN_MASK];
    }
    /**
     * @param radians angle in radians
     * @return the cosine in radians from a lookup table
     */
    public static double cos(double radians) {
        return Sin.table[(int) ((radians + PI / 2) * radToIndex) & SIN_MASK];
    }
    /**
     * @param degrees angle in degrees
     * @return the sine in radians from a lookup table
     */
    public static double sinDeg(double degrees) {
        return Sin.table[(int) (degrees * degToIndex) & SIN_MASK];
    }
    /**
     * @param degrees angle in degrees
     * @return the cosine in radians from a lookup table
     */
    public static double cosDeg(double degrees) {
        return Sin.table[(int) ((degrees + 90) * degToIndex) & SIN_MASK];
    }
    /**
     * @param radians angle in radians
     * @return the sine in radians from a lookup table
     */
    public static float sinF(double radians) {
        return (float) sin(radians);
    }
    /**
     * @param radians angle in radians
     * @return the cosine in radians from a lookup table
     */
    public static float cosF(double radians) {
        return (float) cos(radians);
    }
    /**
     * @param degrees angle in degrees
     * @return the sine in radians from a lookup table
     */
    public static float sinDegF(double degrees) {
        return (float) sinDeg(degrees);
    }
    /**
     * @param degrees angle in degrees
     * @return the cosine in radians from a lookup table
     */
    public static float cosDegF(double degrees) {
        return (float) cosDeg(degrees);
    }
    private static final double radiansToDegrees = 180 / PI;
    private static final double degreesToRadians = PI / 180;
    public static double toDegrees(double radians) {
        return radiansToDegrees * radians;
    }
    public static double toRadians(double degrees) {
        return degreesToRadians * degrees;
    }
    /**
     * Average error of 0.00231 radians (0.1323 degrees),
     * largest error of 0.00488 radians (0.2796 degrees).
     *
     * @param y y component
     * @param x x component
     * @return atan2 in radians, faster but less accurate than Math.atan2
     */
    public static double atan2(double y, double x) {
        if (x == 0.0) {
            if (y > 0) return HALF_PI;
            if (y == 0.0) return 0.0;
            return -HALF_PI;
        }
        final double atan;
        final double z = y / x;
        if (Math.abs(z) < 1) {
            atan = z / (1 + 0.28 * z * z);
            if (x < 0) return atan + (y < 0 ? -PI : PI);
            return atan;
        }
        atan = HALF_PI - z / (z * z + 0.28);
        return y < 0 ? atan - PI : atan;
    }
    /**
     * Average error of 0.00231 radians (0.1323 degrees),
     * largest error of 0.00488 radians (0.2796 degrees).
     *
     * @param y y component
     * @param x x component
     * @return atan2 in degrees, range [-180..180], faster but less accurate than Math.atan2
     */
    public static double atan2Deg(double y, double x) {
        return toDegrees(atan2(y, x));
    }
    /**
     * @param point the point or vector to rotate
     * @param pivot the point around which to rotate
     * @param angle amount in degrees to rotate
     * @return the rotated point
     */
    public static Point2D rotate(Point2D point, Point2D pivot, double angle) {
        // translate point so that rotation origin (pivot) is at (0, 0)
        double px = point.getX() - pivot.getX();
        double py = point.getY() - pivot.getY();
        double c = cosDeg(angle);
        double s = sinDeg(angle);
        // rotate around (0, 0)
        double pxNew = px * c - py * s;
        double pyNew = px * s + py * c;
        // translate point back to pivot
        return new Point2D(pxNew + pivot.getX(), pyNew + pivot.getY());
    }
    /**
     * @param point the point to scale
     * @param pivot the point around which to scale
     * @param factor the scale factor
     * @return the scaled point
     */
    public static Point2D scale(Point2D point, Point2D pivot, double factor) {
        return new Point2D(
                scale1D(point.getX(), pivot.getX(), factor),
                scale1D(point.getY(), pivot.getY(), factor)
        );
    }
    /**
     * @param x a component of a point, e.g. x or y
     * @param pivot the pivot value in the same axis as the component
     * @param factor scale factor
     * @return scaled value
     */
    public static double scale1D(double x, double pivot, double factor) {
        // 1. treat the pivot as the origin, so x is relative to this origin
        // 2. scale (multiply) by factor
        // 3. translate the scaled x back
        return (x - pivot) * factor + pivot;
    }
    /* RANDOM BEGIN */
    private static Random random = new Random();
    public static void setRandom(Random random) {
        FXGLMath.random = random;
    }
    /**
     * @return random object used to generate random sequences
     */
    public static Random getRandom() {
        return random;
    }
    /**
     * @return object used to generate random sequences using given seed
     */
    public static Random getRandom(long seed) {
        return new Random(seed);
    }
    /**
     * @param start start value
     * @param end end value
     * @return a random number between start (inclusive) and end (inclusive)
     */
    public static int random(int start, int end) {
        return start + random.nextInt(end - start + 1);
    }
    /**
     * @param start start value
     * @param end end value
     * @return a random number between start (inclusive) and end (inclusive)
     */
    public static long random(long start, long end) {
        return start + (long) (random.nextDouble() * (end - start));
    }
    /**
     * @param start start inclusive value
     * @param end end exclusive value
     * @return a random number between start (inclusive) and end (exclusive)
     */
    public static double random(double start, double end) {
        return start + random.nextDouble() * (end - start);
    }
    /**
     * @return random number between 0.0 (inclusive) and 1.0 (exclusive)
     */
    public static double randomDouble() {
        return random.nextDouble();
    }
    /**
     * @return random number between 0.0 (inclusive) and 1.0 (exclusive)
     */
    public static float randomFloat() {
        return random.nextFloat();
    }
    /**
     * @return random boolean value
     */
    public static boolean randomBoolean() {
        return random.nextBoolean();
    }
    /**
     * @param chance chance to check
     * @return true if a random value between 0 and 1 is less than the specified value
     */
    public static boolean randomBoolean(double chance) {
        return randomDouble() < chance;
    }
    /**
     * @return random sign, either -1 or 1
     */
    public static int randomSign() {
        return 1 | (random.nextInt() >> 31);
    }
    /**
     * @return random point within given bounds (minX <= x < maxX, minY <= y < maxY)
     */
    public static Point2D randomPoint(Rectangle2D bounds) {
        return new Point2D(
                random(bounds.getMinX(), bounds.getMaxX()),
                random(bounds.getMinY(), bounds.getMaxY())
        );
    }
    /**
     * @return new random vector of unit length as Point2D
     */
    public static Point2D randomPoint2D() {
        return randomVec2().toPoint2D();
    }
    /**
     * @return new random vector of unit length as Vec2
     */
    public static Vec2 randomVec2() {
        return new Vec2(random(-1.0, 1.0), random(-1.0, 1.0)).normalizeLocal();
    }
    /**
     * @return random color using RGB color model
     */
    public static Color randomColor() {
        return Color.color(randomDouble(), randomDouble(), randomDouble());
    }
    /**
     * @return random color using HSB color model
     */
    public static Color randomColorHSB(double saturation, double brightness) {
        return Color.hsb(random(0, 360), saturation, brightness);
    }
    /**
     * @return random element of the given array or Optional.empty() if empty
     */
    public static <T> Optional<T> random(T[] array) {
        if (array.length == 0)
            return Optional.empty();
        return Optional.of(array[random(0, array.length - 1)]);
    }
    /**
     * @return random element of the given list or Optional.empty() if empty
     */
    public static <T> Optional<T> random(List<T> list) {
        if (list.isEmpty())
            return Optional.empty();
        return Optional.of(list.get(random(0, list.size() - 1)));
    }
    /* RANDOM END */
    public static double sqrt(double x) {
        return Math.sqrt(x);
    }
    public static float sqrtF(float x) {
        return (float) StrictMath.sqrt(x);
    }
    /**
     * Map value of a given range to a target range.
     *
     * @param value the value to map
     * @return mapped value
     */
    public static double map(double value, double currentRangeStart, double currentRangeStop, double targetRangeStart, double targetRangeStop) {
        return targetRangeStart + (targetRangeStop - targetRangeStart) * ((value - currentRangeStart) / (currentRangeStop - currentRangeStart));
    }
    /**
     * @return the closest value to 'a' that is between 'low' and 'high'
     */
    public static float clamp(float a, float low, float high) {
        return Math.max(low, Math.min(a, high));
    }
    public static int floor(float x) {
        int y = (int) x;
        if (x < y) {
            return y - 1;
        }
        return y;
    }
    public static float abs(float value) {
        return value > 0 ? value : -value;
    }
    public static double abs(double value) {
        return value > 0 ? value : -value;
    }
    /**
     * @return min of two floats using a direct (a < b ? a : b) check, without NaN check
     */
    public static float min(float a, float b) {
        return a < b ? a : b;
    }
    /**
     * @return max of two floats using a direct (a > b ? a : b) check, without NaN check
     */
    public static float max(float a, float b) {
        return a > b ? a : b;
    }
    public static Point2D bezier(Point2D p1, Point2D p2, Point2D p3, double t) {
        double x = (1 - t) * (1 - t) * p1.getX() + 2 * (1 - t) * t * p2.getX() + t * t * p3.getX();
        double y = (1 - t) * (1 - t) * p1.getY() + 2 * (1 - t) * t * p2.getY() + t * t * p3.getY();
        return new Point2D(x, y);
    }
    public static Point2D bezier(Point2D p1, Point2D p2, Point2D p3, Point2D p4, double t) {
        double x = Math.pow(1 - t, 3) * p1.getX() + 3 * t * Math.pow(1 - t, 2) * p2.getX() + 3 * t*t * (1 - t) * p3.getX() + t*t*t*p4.getX();
        double y = Math.pow(1 - t, 3) * p1.getY() + 3 * t * Math.pow(1 - t, 2) * p2.getY() + 3 * t*t * (1 - t) * p3.getY() + t*t*t*p4.getY();
        return new Point2D(x, y);
    }
    private static final PerlinNoiseGenerator generator = getNoise1DGenerator(0L);
    /**
     * @param t current time * frequency (lower frequency -> smoother output)
     * @return perlin noise in 1D quality in [0..1)
     */
    public static double noise1D(double t) { return generator.noise1D(t); }
    /**
     * @param seed used to create unique noise generator with replicable output
     * @return seeded perlin noise generator used to call noise1D(t)
     */
    public static PerlinNoiseGenerator getNoise1DGenerator(long seed) {
        return new PerlinNoiseGenerator(seed);
    }
    /**
     * A typical usage would be to pass 2d coordinates multiplied by a frequency (lower frequency -> smoother output) value, like:
     *
     * double noise = noise2D(x * freq, y * freq)
     *
     * @return a value in [-1,1]
     */
    public static double noise2D(double x, double y) {
        return SimplexNoise.noise2D(x, y);
    }
    /**
     * Simplex noise 3d.
     * @return a value in [-1,1]
     */
    public static double noise3D(double x, double y, double z) {
        return SimplexNoise.noise3D(x, y, z);
    }
    public static double distance(Rectangle2D rect1, Rectangle2D rect2) {
        return Distances.INSTANCE.distance(rect1, rect2);
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
/*
 * JBox2D - A Java Port of Erin Catto's Box2D
 * 
 * JBox2D homepage: http://jbox2d.sourceforge.net/
 * Box2D homepage: http://www.box2d.org
 * 
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * 
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */
package com.almasb.fxgl.physics.box2d.collision;
import com.almasb.fxgl.core.math.Vec2;
/**
 * A manifold point is a contact point belonging to a contact
 * manifold. It holds details related to the geometry and dynamics
 * of the contact points.
 * The local point usage depends on the manifold type:
 * <ul><li>e_circles: the local center of circleB</li>
 * <li>e_faceA: the local center of cirlceB or the clip point of polygonB</li>
 * <li>e_faceB: the clip point of polygonA</li></ul>
 * This structure is stored across time steps, so we keep it small.<br/>
 * Note: the impulses are used for internal caching and may not
 * provide reliable contact forces, especially for high speed collisions.
 */
public class ManifoldPoint {
    /** usage depends on manifold type */
    public final Vec2 localPoint = new Vec2();
    /** the non-penetration impulse */
    public float normalImpulse = 0f;
    /** the friction impulse */
    public float tangentImpulse = 0f;
    /** uniquely identifies a contact point between two shapes */
    public final ContactID id = new ContactID();
    /**
     * Sets this manifold point form the given one
     * @param cp the point to copy from
     */
    public void set(final ManifoldPoint cp) {
        localPoint.set(cp.localPoint);
        normalImpulse = cp.normalImpulse;
        tangentImpulse = cp.tangentImpulse;
        id.set(cp.id);
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.collision;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.common.JBoxSettings;
/**
 * A manifold for two touching convex shapes. Box2D supports multiple types of contact:
 * <ul>
 * <li>clip point versus plane with radius</li>
 * <li>point versus point with radius (circles)</li>
 * </ul>
 * The local point usage depends on the manifold type:
 * <ul>
 * <li>e_circles: the local center of circleA</li>
 * <li>e_faceA: the center of faceA</li>
 * <li>e_faceB: the center of faceB</li>
 * </ul>
 * Similarly the local normal usage:
 * <ul>
 * <li>e_circles: not used</li>
 * <li>e_faceA: the normal on polygonA</li>
 * <li>e_faceB: the normal on polygonB</li>
 * </ul>
 * We store contacts in this way so that position correction can account for movement, which is
 * critical for continuous physics. All contact scenarios must be expressed in one of these types.
 * This structure is stored across time steps, so we keep it small.
 */
public class Manifold {
    public enum ManifoldType {
        CIRCLES, FACE_A, FACE_B
    }
    /** The points of contact. */
    public final ManifoldPoint[] points = new ManifoldPoint[JBoxSettings.maxManifoldPoints];
    /** not use for Type::e_points */
    public final Vec2 localNormal = new Vec2();
    /** usage depends on manifold type */
    public final Vec2 localPoint = new Vec2();
    public ManifoldType type;
    /** The number of manifold points. */
    public int pointCount = 0;
    /**
     * creates a manifold with 0 points, with it's points array full of instantiated ManifoldPoints.
     */
    public Manifold() {
        for (int i = 0; i < JBoxSettings.maxManifoldPoints; i++) {
            points[i] = new ManifoldPoint();
        }
    }
    /**
     * copies this manifold from the given one
     *
     * @param cp manifold to copy from
     */
    public void set(Manifold cp) {
        for (int i = 0; i < cp.pointCount; i++) {
            points[i].set(cp.points[i]);
        }
        type = cp.type;
        localNormal.set(cp.localNormal);
        localPoint.set(cp.localPoint);
        pointCount = cp.pointCount;
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
/**
 * Created at 3:26:14 AM Jan 11, 2011
 */
package com.almasb.fxgl.physics.box2d.pooling;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.core.math.Vec3;
import com.almasb.fxgl.physics.box2d.collision.Collision;
import com.almasb.fxgl.physics.box2d.collision.Distance;
import com.almasb.fxgl.physics.box2d.collision.TimeOfImpact;
import com.almasb.fxgl.physics.box2d.common.Mat22;
import com.almasb.fxgl.physics.box2d.common.Mat33;
import com.almasb.fxgl.physics.box2d.common.Rotation;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.*;
import java.util.HashMap;
/**
 * Provides object pooling for all objects used in the engine. Objects retrieved from here should
 * only be used temporarily, and then pushed back (with the exception of arrays).
 *
 * @author Daniel Murphy
 */
public class DefaultWorldPool implements IWorldPool {
    private static final int CONTACT_STACK_INIT_SIZE = 10;
    private final OrderedStack<Vec2> vecs;
    private final OrderedStack<Vec3> vec3s;
    private final OrderedStack<Mat22> mats;
    private final OrderedStack<Mat33> mat33s;
    private final OrderedStack<Rotation> rots;
    private final HashMap<Integer, Vec2[]> avecs = new HashMap<>();
    private final IWorldPool world = this;
    private final MutableStack<Contact> pcstack =
            new MutableStack<Contact>(CONTACT_STACK_INIT_SIZE) {
                protected Contact newInstance() {
                    return new PolygonContact(world);
                }
                protected Contact[] newArray(int size) {
                    return new PolygonContact[size];
                }
            };
    private final MutableStack<Contact> ccstack =
            new MutableStack<Contact>(CONTACT_STACK_INIT_SIZE) {
                protected Contact newInstance() {
                    return new CircleContact(world);
                }
                protected Contact[] newArray(int size) {
                    return new CircleContact[size];
                }
            };
    private final MutableStack<Contact> cpstack =
            new MutableStack<Contact>(CONTACT_STACK_INIT_SIZE) {
                protected Contact newInstance() {
                    return new PolygonAndCircleContact(world);
                }
                protected Contact[] newArray(int size) {
                    return new PolygonAndCircleContact[size];
                }
            };
    private final MutableStack<Contact> ecstack =
            new MutableStack<Contact>(CONTACT_STACK_INIT_SIZE) {
                protected Contact newInstance() {
                    return new EdgeAndCircleContact(world);
                }
                protected Contact[] newArray(int size) {
                    return new EdgeAndCircleContact[size];
                }
            };
    private final MutableStack<Contact> epstack =
            new MutableStack<Contact>(CONTACT_STACK_INIT_SIZE) {
                protected Contact newInstance() {
                    return new EdgeAndPolygonContact(world);
                }
                protected Contact[] newArray(int size) {
                    return new EdgeAndPolygonContact[size];
                }
            };
    private final MutableStack<Contact> chcstack =
            new MutableStack<Contact>(CONTACT_STACK_INIT_SIZE) {
                protected Contact newInstance() {
                    return new ChainAndCircleContact(world);
                }
                protected Contact[] newArray(int size) {
                    return new ChainAndCircleContact[size];
                }
            };
    private final MutableStack<Contact> chpstack =
            new MutableStack<Contact>(CONTACT_STACK_INIT_SIZE) {
                protected Contact newInstance() {
                    return new ChainAndPolygonContact(world);
                }
                protected Contact[] newArray(int size) {
                    return new ChainAndPolygonContact[size];
                }
            };
    private final Collision collision;
    private final TimeOfImpact toi;
    private final Distance dist = new Distance();
    public DefaultWorldPool(int argSize, int argContainerSize) {
        vecs = new OrderedStack<Vec2>(argSize, argContainerSize) {
            protected Vec2 newInstance() {
                return new Vec2();
            }
        };
        vec3s = new OrderedStack<Vec3>(argSize, argContainerSize) {
            protected Vec3 newInstance() {
                return new Vec3();
            }
        };
        mats = new OrderedStack<Mat22>(argSize, argContainerSize) {
            protected Mat22 newInstance() {
                return new Mat22();
            }
        };
        rots = new OrderedStack<Rotation>(argSize, argContainerSize) {
            protected Rotation newInstance() {
                return new Rotation();
            }
        };
        mat33s = new OrderedStack<Mat33>(argSize, argContainerSize) {
            protected Mat33 newInstance() {
                return new Mat33();
            }
        };
        collision = new Collision();
        toi = new TimeOfImpact(this);
    }
    public final IDynamicStack<Contact> getPolyContactStack() {
        return pcstack;
    }
    public final IDynamicStack<Contact> getCircleContactStack() {
        return ccstack;
    }
    public final IDynamicStack<Contact> getPolyCircleContactStack() {
        return cpstack;
    }
    @Override
    public IDynamicStack<Contact> getEdgeCircleContactStack() {
        return ecstack;
    }
    @Override
    public IDynamicStack<Contact> getEdgePolyContactStack() {
        return epstack;
    }
    @Override
    public IDynamicStack<Contact> getChainCircleContactStack() {
        return chcstack;
    }
    @Override
    public IDynamicStack<Contact> getChainPolyContactStack() {
        return chpstack;
    }
    public final Vec2 popVec2() {
        return vecs.pop();
    }
    public final Vec2[] popVec2(int argNum) {
        return vecs.pop(argNum);
    }
    public final void pushVec2(int argNum) {
        vecs.push(argNum);
    }
    public final Vec3 popVec3() {
        return vec3s.pop();
    }
    public final Vec3[] popVec3(int argNum) {
        return vec3s.pop(argNum);
    }
    public final void pushVec3(int argNum) {
        vec3s.push(argNum);
    }
    public final Mat22 popMat22() {
        return mats.pop();
    }
    public final Mat22[] popMat22(int argNum) {
        return mats.pop(argNum);
    }
    public final void pushMat22(int argNum) {
        mats.push(argNum);
    }
    public final Mat33 popMat33() {
        return mat33s.pop();
    }
    public final void pushMat33(int argNum) {
        mat33s.push(argNum);
    }
    public final Rotation popRot() {
        return rots.pop();
    }
    public final void pushRot(int num) {
        rots.push(num);
    }
    public final Collision getCollision() {
        return collision;
    }
    public final TimeOfImpact getTimeOfImpact() {
        return toi;
    }
    public final Distance getDistance() {
        return dist;
    }
    public final Vec2[] getVec2Array(int argLength) {
        if (!avecs.containsKey(argLength)) {
            Vec2[] ray = new Vec2[argLength];
            for (int i = 0; i < argLength; i++) {
                ray[i] = new Vec2();
            }
            avecs.put(argLength, ray);
        }
        assert avecs.get(argLength).length == argLength : "Array not built with correct length";
        return avecs.get(argLength);
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
/*
 * Copyright (c) 2013, Daniel Murphy
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 	* Redistributions of source code must retain the above copyright notice,
 * 	  this list of conditions and the following disclaimer.
 * 	* Redistributions in binary form must reproduce the above copyright notice,
 * 	  this list of conditions and the following disclaimer in the documentation
 * 	  and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package com.almasb.fxgl.physics.box2d.callbacks;
import com.almasb.fxgl.physics.box2d.collision.Manifold;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
/**
 * Implement this class to get contact information. You can use these results for
 * things like sounds and game logic. You can also get contact results by
 * traversing the contact lists after the time step. However, you might miss
 * some contacts because continuous physics leads to sub-stepping.
 * Additionally you may receive multiple callbacks for the same contact in a
 * single time step.
 * You should strive to make your callbacks efficient because there may be
 * many callbacks per time step.
 *
 * @warning You cannot create/destroy Box2D entities inside these callbacks.
 * @author Daniel Murphy
 */
public interface ContactListener {
    /**
     * Called when two fixtures begin to touch.
     *
     * @param contact contact info
     */
    void beginContact(Contact contact);
    /**
     * Called when two fixtures cease to touch.
     *
     * @param contact contact info
     */
    void endContact(Contact contact);
    /**
     * This is called after a contact is updated. This allows you to inspect a
     * contact before it goes to the solver. If you are careful, you can modify the
     * contact manifold (e.g. disable contact).
     * A copy of the old manifold is provided so that you can detect changes.
     * <p>
     * Note:
     * <ul>
     *     <li>This is called only for awake bodies.</li>
     *     <li>This is called even when the number of contact points is zero.</li>
     *     <li>This is not called for sensors.</li>
     *     <li>If you set the number of contact points to zero, you will not
     * get an EndContact callback. However, you may get a BeginContact callback the next step.</li>
     *     <li>The oldManifold parameter is pooled, so it will be the same object for every callback
     * for each thread.</li>
     * </ul>
     *
     * @param contact contact info
     * @param oldManifold the old manifold
     */
    void preSolve(Contact contact, Manifold oldManifold);
    /**
     * This lets you inspect a contact after the solver is finished. This is useful
     * for inspecting impulses.
     * <p>
     *     Note:
     *     <ul>
     *         <li>The contact manifold does not include time of impact impulses, which can be
     * arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly
     * in a separate data structure.</li>
     *         <li>This is only called for contacts that are touching, solid, and awake.</li>
     *         <li>The impulse parameter is usually a pooled variable, so it will be modified after
     * this call.</li>
     *     </ul>
     * </p>
     *
     * @param contact contact info
     * @param impulse contact impulse
     */
    void postSolve(Contact contact, ContactImpulse impulse);
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics;
import com.almasb.fxgl.core.collection.Array;
import com.almasb.fxgl.core.collection.UnorderedArray;
import com.almasb.fxgl.core.collection.UnorderedPairMap;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.core.pool.Pool;
import com.almasb.fxgl.core.pool.Pools;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.entity.EntityWorldListener;
import com.almasb.fxgl.entity.components.BoundingBoxComponent;
import com.almasb.fxgl.entity.components.CollidableComponent;
import com.almasb.fxgl.logging.Logger;
import com.almasb.fxgl.physics.box2d.callbacks.ContactFilter;
import com.almasb.fxgl.physics.box2d.callbacks.ContactImpulse;
import com.almasb.fxgl.physics.box2d.callbacks.ContactListener;
import com.almasb.fxgl.physics.box2d.collision.Manifold;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.dynamics.*;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.joints.*;
import javafx.beans.value.ChangeListener;
import javafx.geometry.Point2D;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
/**
 * Manages collision handling and performs the physics tick.
 * Contains methods to convert pixel coordinates to meters and vice versa.
 * Collision handling unifies how different collisions (with and without PhysicsComponent) are processed.
 *
 * @author Almas Baimagambetov (AlmasB) (almaslvl@gmail.com)
 */
public final class PhysicsWorld implements EntityWorldListener, ContactListener, PhysicsUnitConverter {
    private static final Logger log = Logger.get(PhysicsWorld.class);
    private final double PIXELS_PER_METER;
    private final double METERS_PER_PIXELS;
    private World jboxWorld = new World(new Vec2(0, -10));
    private Array<Entity> entities = new UnorderedArray<>(128);
    private UnorderedPairMap<Object, CollisionHandler> collisionHandlers = new UnorderedPairMap<>(16);
    // stores active collisions
    private UnorderedPairMap<Entity, CollisionPair> collisionsMap = new UnorderedPairMap<>(128);
    private CollisionDetectionStrategy strategy;
    private int appHeight;
    public PhysicsWorld(int appHeight, double ppm) {
        this(appHeight, ppm, CollisionDetectionStrategy.BRUTE_FORCE);
    }
    public PhysicsWorld(int appHeight, double ppm, CollisionDetectionStrategy strategy) {
        this.appHeight = appHeight;
        this.strategy = strategy;
        PIXELS_PER_METER = ppm;
        METERS_PER_PIXELS = 1 / PIXELS_PER_METER;
        initCollisionPool();
        initContactListener();
        initParticles();
        jboxWorld.setContactFilter(new CollisionFilterCallback());
        log.debugf("Physics world initialized: appHeight=%d, physics.ppm=%.1f",
                appHeight, ppm);
        log.debug("Using strategy: " + strategy);
    }
    private void initCollisionPool() {
        Pools.set(CollisionPair.class, new Pool<CollisionPair>() {
            @Override
            protected CollisionPair newObject() {
                return new CollisionPair();
            }
        });
    }
    /**
     * Registers contact listener to JBox2D world so that collisions are
     * registered for subsequent notification.
     * Only collidable entities are checked.
     */
    private void initContactListener() {
        jboxWorld.setContactListener(this);
    }
    private void initParticles() {
        jboxWorld.setParticleGravityScale(1f);
        jboxWorld.setParticleDensity(1.2f);
        jboxWorld.setParticleRadius(toMetersF(1));    // 0.5 for super realistic effect, but slow
    }
    private Array<Entity> delayedBodiesAdd = new UnorderedArray<>();
    private Array<Body> delayedBodiesRemove = new UnorderedArray<>();
    private Map<Entity, ChangeListener<Number> > scaleListeners = new HashMap<>();
    @Override
    public void onEntityAdded(Entity entity) {
        entities.add(entity);
        if (entity.hasComponent(PhysicsComponent.class)) {
            onPhysicsEntityAdded(entity);
        }
    }
    private void onPhysicsEntityAdded(Entity entity) {
        if (!jboxWorld.isLocked()) {
            createBody(entity);
        } else {
            delayedBodiesAdd.add(entity);
        }
        ChangeListener<Number> scaleChangeListener = (observable, oldValue, newValue) -> {
            Body b = entity.getComponent(PhysicsComponent.class).body;
            if (b != null) {
                List<Fixture> fixtures = List.copyOf(b.getFixtures());
                fixtures.forEach(b::destroyFixture);
                createFixtures(entity);
                createSensors(entity);
            }
        };
        scaleListeners.put(entity, scaleChangeListener);
        entity.getTransformComponent().scaleXProperty().addListener(scaleChangeListener);
        entity.getTransformComponent().scaleYProperty().addListener(scaleChangeListener);
    }
    @Override
    public void onEntityRemoved(Entity entity) {
        entities.removeValueByIdentity(entity);
        if (entity.hasComponent(PhysicsComponent.class)) {
            onPhysicsEntityRemoved(entity);
        }
    }
    private void onPhysicsEntityRemoved(Entity entity) {
        if (scaleListeners.containsKey(entity)) {
            ChangeListener<Number> scaleChangeListener = scaleListeners.get(entity);
            entity.getTransformComponent().scaleXProperty().removeListener(scaleChangeListener);
            entity.getTransformComponent().scaleYProperty().removeListener(scaleChangeListener);
            scaleListeners.remove(entity);
        }
        if (!jboxWorld.isLocked()) {
            destroyBody(entity);
        } else {
            delayedBodiesRemove.add(entity.getComponent(PhysicsComponent.class).getBody());
        }
    }
    public void onUpdate(double tpf) {
        jboxWorld.step((float) tpf, 8, 3);
        postStep();
        checkCollisions();
        notifyCollisions();
    }
    private void postStep() {
        for (Entity e : delayedBodiesAdd)
            createBody(e);
        delayedBodiesAdd.clear();
        for (Body body : delayedBodiesRemove)
            jboxWorld.destroyBody(body);
        delayedBodiesRemove.clear();
    }
    /**
     * Clears collidable entities and active collisions.
     * Does not clear collision handlers.
     */
    public void clear() {
        log.debug("Clearing physics world");
        entities.clear();
        collisionsMap.clear();
    }
    public void clearCollisionHandlers() {
        collisionHandlers.clear();
    }
    @Override
    public void beginContact(Contact contact) {
        Entity e1 = contact.getFixtureA().getBody().getEntity();
        Entity e2 = contact.getFixtureB().getBody().getEntity();
        // check sensors first
        if (contact.getFixtureA().isSensor()) {
            notifySensorCollisionBegin(e1, e2, contact.getFixtureA().getHitBox());
            return;
        } else if (contact.getFixtureB().isSensor()) {
            notifySensorCollisionBegin(e2, e1, contact.getFixtureB().getHitBox());
            return;
        }
        if (!areCollidable(e1, e2))
            return;
        CollisionHandler handler = getHandler(e1, e2);
        if (handler != null) {
            HitBox a = contact.getFixtureA().getHitBox();
            HitBox b = contact.getFixtureB().getHitBox();
            collisionBeginFor(handler, e1, e2, a, b);
        }
    }
    @Override
    public void endContact(Contact contact) {
        Entity e1 = contact.getFixtureA().getBody().getEntity();
        Entity e2 = contact.getFixtureB().getBody().getEntity();
        // check sensors first
        if (contact.getFixtureA().isSensor()) {
            notifySensorCollisionEnd(e1, e2, contact.getFixtureA().getHitBox());
            return;
        } else if (contact.getFixtureB().isSensor()) {
            notifySensorCollisionEnd(e2, e1, contact.getFixtureB().getHitBox());
            return;
        }
        if (!areCollidable(e1, e2))
            return;
        CollisionHandler handler = getHandler(e1, e2);
        if (handler != null) {
            collisionEndFor(e1, e2);
        }
    }
    /**
     * Note: certain modifications to the jbox2d world directly may not be
     * recognized by FXGL.
     *
     * @return raw jbox2d physics world
     */
    public World getJBox2DWorld() {
        return jboxWorld;
    }
    private boolean isCollidable(Entity e) {
        if (!e.isActive())
            return false;
        return e.getComponentOptional(CollidableComponent.class)
                .map(CollidableComponent::getValue)
                .orElse(false);
    }
    private boolean areCollidable(Entity e1, Entity e2) {
        return isCollidable(e1) && isCollidable(e2);
    }
    @SuppressWarnings("PMD.UselessParentheses")
    private boolean needManualCheck(Entity e1, Entity e2) {
        // if no physics -> check manually
        BodyType type1 = e1.getComponentOptional(PhysicsComponent.class)
                .map(p -> p.body.getType())
                .orElse(null);
        if (type1 == null)
            return true;
        BodyType type2 = e2.getComponentOptional(PhysicsComponent.class)
                .map(p -> p.body.getType())
                .orElse(null);
        if (type2 == null)
            return true;
        // if one is kinematic and the other is static -> check manually
        return (type1 == BodyType.KINEMATIC && type2 == BodyType.STATIC)
                || (type2 == BodyType.KINEMATIC && type1 == BodyType.STATIC);
    }
    /**
     * @param e1 entity 1
     * @param e2 entity 2
     * @return collision handler for e1 and e2 based on their types or null if no such handler exists
     */
    private CollisionHandler getHandler(Entity e1, Entity e2) {
        if (!e1.isActive() || !e2.isActive())
            return null;
        return collisionHandlers.get(e1.getType(), e2.getType());
    }
    private void notifySensorCollisionBegin(Entity eWithSensor, Entity eTriggered, HitBox box) {
        var handler = eWithSensor.getComponent(PhysicsComponent.class).getSensorHandlers().get(box);
        handler.onCollisionBegin(eTriggered);
    }
    private void notifySensorCollisionEnd(Entity eWithSensor, Entity eTriggered, HitBox box) {
        var handler = eWithSensor.getComponent(PhysicsComponent.class).getSensorHandlers().get(box);
        handler.onCollisionEnd(eTriggered);
    }
    @Override
    public void preSolve(Contact contact, Manifold oldManifold) { }
    @Override
    public void postSolve(Contact contact, ContactImpulse impulse) { }
    private Array<Entity> collidables = new UnorderedArray<>(128);
    private CollisionResult collisionResult = new CollisionResult();
    private CollisionGrid collisionGrid = new CollisionGrid(64, 64);
    /**
     * Perform collision detection for all entities that have
     * setCollidable(true) and if at least one entity does not have PhysicsComponent.
     * Subsequently fire collision handlers for all entities that have
     * setCollidable(true).
     */
    private void checkCollisions() {
        if (strategy == CollisionDetectionStrategy.GRID_INDEXING) {
            for (Entity e : entities) {
                if (isCollidable(e)) {
                    e.getBoundingBoxComponent().applyTransformToHitBoxes$fxgl_entity();
                    collisionGrid.insert(e);
                }
            }
            collisionGrid.getCells().forEach((p, cell) -> {
                checkCollisionsInGroup(cell.getEntities());
            });
            collisionGrid.getCells().clear();
        } else {
            for (Entity e : entities) {
                if (isCollidable(e)) {
                    e.getBoundingBoxComponent().applyTransformToHitBoxes$fxgl_entity();
                    collidables.add(e);
                }
            }
            checkCollisionsInGroup(collidables);
            collidables.clear();
        }
    }
    private void checkCollisionsInGroup(Array<Entity> group) {
        for (int i = 0; i < group.size(); i++) {
            Entity e1 = group.get(i);
            for (int j = i + 1; j < group.size(); j++) {
                Entity e2 = group.get(j);
                CollisionHandler handler = getHandler(e1, e2);
                // if no handler registered, no need to check for this pair
                if (handler == null)
                    continue;
                // if no need for manual check, let jbox handle it
                if (!needManualCheck(e1, e2)) {
                    continue;
                }
                // check if e1 ignores e2, or e2 ignores e1
                if (isIgnored(e1, e2))
                    continue;
                // check if colliding
                var collision = e1.getBoundingBoxComponent().checkCollisionPAT(e2.getBoundingBoxComponent(), collisionResult);
                if (collision) {
                    collisionBeginFor(handler, e1, e2, collisionResult.getBoxA(), collisionResult.getBoxB());
                } else {
                    collisionEndFor(e1, e2);
                }
            }
        }
    }
    private boolean isIgnored(Entity e1, Entity e2) {
        if (!e1.hasComponent(CollidableComponent.class) || !e2.hasComponent(CollidableComponent.class))
            return false;
        CollidableComponent c1 = e1.getComponent(CollidableComponent.class);
        for (Serializable t1 : c1.getIgnoredTypes()) {
            if (e2.isType(t1)) {
                return true;
            }
        }
        CollidableComponent c2 = e2.getComponent(CollidableComponent.class);
        for (Serializable t2 : c2.getIgnoredTypes()) {
            if (e1.isType(t2)) {
                return true;
            }
        }
        return false;
    }
    private void collisionBeginFor(CollisionHandler handler, Entity e1, Entity e2, HitBox a, HitBox b) {
        CollisionPair pair = collisionsMap.get(e1, e2);
        // null means e1 and e2 were not colliding before
        // if not null, then ignore because e1 and e2 are still colliding
        if (pair == null) {
            pair = Pools.obtain(CollisionPair.class);
            pair.init(e1, e2, handler);
            // add pair to list of collisions so we still use it
            collisionsMap.put(pair.getA(), pair.getB(), pair);
            handler.onHitBoxTrigger(
                    pair.getA(), pair.getB(),
                    e1 == pair.getA() ? a : b,
                    e2 == pair.getB() ? b : a
            );
            pair.collisionBegin();
        }
    }
    private void collisionEndFor(Entity e1, Entity e2) {
        CollisionPair pair = collisionsMap.get(e1, e2);
        // if not null, then collision registered, so end the collision
        // and remove it and put pair back to pool
        // if null then collision was not present before either
        if (pair != null) {
            collisionsMap.remove(pair.getA(), pair.getB());
            pair.collisionEnd();
            Pools.free(pair);
        }
    }
    private void notifyCollisions() {
        for (Iterator<CollisionPair> it = collisionsMap.getValues().iterator(); it.hasNext(); ) {
            CollisionPair pair = it.next();
            // if a pair no longer qualifies for collision then just remove it
            if (!isCollidable(pair.getA()) || !isCollidable(pair.getB())) {
                // tell the pair that collision ended
                pair.collisionEnd();
                it.remove();
                Pools.free(pair);
                continue;
            }
            pair.collision();
        }
    }
    /**
     * Registers a collision handler.
     * The order in which the types are passed to this method
     * decides the order of objects being passed into the collision handler
     * <p>
     * <pre>
     * Example:
     * PhysicsWorld physics = ...
     * physics.addCollisionHandler(new CollisionHandler(Type.PLAYER, Type.ENEMY) {
     *      public void onCollisionBegin(Entity a, Entity b) {
     *          // called when entities start touching
     *      }
     *      public void onCollision(Entity a, Entity b) {
     *          // called when entities are touching
     *      }
     *      public void onCollisionEnd(Entity a, Entity b) {
     *          // called when entities are separated and no longer touching
     *      }
     * });
     *
     * </pre>
     *
     * @param handler collision handler
     */
    public void addCollisionHandler(CollisionHandler handler) {
        collisionHandlers.put(handler.getA(), handler.getB(), handler);
    }
    /**
     * Removes a collision handler
     *
     * @param handler collision handler to remove
     */
    public void removeCollisionHandler(CollisionHandler handler) {
        collisionHandlers.remove(handler.getA(), handler.getB());
    }
    /**
     * Set global world gravity.
     *
     * @param x x component (in pixels)
     * @param y y component (in pixels)
     */
    public void setGravity(double x, double y) {
        jboxWorld.setGravity(toVector(new Point2D(x, y)));
    }
    /**
     * Create physics body and attach to physics world.
     *
     * @param e physics entity
     */
    private void createBody(Entity e) {
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        physics.setWorld(this);
        // if position is 0, 0 then probably not set, so set ourselves
        if (physics.bodyDef.getPosition().x == 0 && physics.bodyDef.getPosition().y == 0) {
            physics.bodyDef.getPosition().set(toPoint(e.getCenter()));
        }
        if (physics.bodyDef.getAngle() == 0) {
            physics.bodyDef.setAngle((float) -Math.toRadians(e.getRotation()));
        }
        physics.body = jboxWorld.createBody(physics.bodyDef);
        createFixtures(e);
        createSensors(e);
        physics.body.setEntity(e);
        physics.onInitPhysics();
    }
    private void createFixtures(Entity e) {
        BoundingBoxComponent bbox = e.getBoundingBoxComponent();
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        FixtureDef fd = physics.fixtureDef;
        for (HitBox box : bbox.hitBoxesProperty()) {
            Shape b2Shape = createShape(box, e);
            // we use definitions from user, but override shape
            fd.setShape(b2Shape);
            Fixture fixture = physics.body.createFixture(fd);
            fixture.setHitBox(box);
        }
    }
    private void createSensors(Entity e) {
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        if (physics.getSensorHandlers().isEmpty())
            return;
        physics.getSensorHandlers().keySet().forEach(box -> {
            box.bindXY(e.getTransformComponent());
            Shape polygonShape = createShape(box, e);
            FixtureDef fd = new FixtureDef()
                    .sensor(true)
                    .shape(polygonShape);
            Fixture f = physics.body.createFixture(fd);
            f.setHitBox(box);
        });
    }
    private Shape createShape(HitBox box, Entity e) {
        if (e.getComponent(PhysicsComponent.class).body.getType() != BodyType.STATIC
                && box.getShape() instanceof ChainShapeData) {
            throw new IllegalArgumentException("BoundingShape.chain() can only be used with BodyType.STATIC");
        }
        return box.toBox2DShape(e.getBoundingBoxComponent(), this);
    }
    void destroyFixture(Body body, HitBox box) {
        body.getFixtures()
                .stream()
                .filter(f -> f.getHitBox() == box)
                .findAny()
                .ifPresent(body::destroyFixture);
    }
    /**
     * Destroy body and remove from physics world.
     *
     * @param e physics entity
     */
    private void destroyBody(Entity e) {
        jboxWorld.destroyBody(e.getComponent(PhysicsComponent.class).body);
    }
    private EdgeCallback raycastCallback = new EdgeCallback();
    /**
     * Performs a ray cast from start point to end point.
     *
     * @param start start point
     * @param end end point
     * @return ray cast result
     */
    public RaycastResult raycast(Point2D start, Point2D end) {
        raycastCallback.reset();
        jboxWorld.raycast(raycastCallback, toPoint(start), toPoint(end));
        Entity entity = null;
        Point2D point = null;
        if (raycastCallback.getFixture() != null)
            entity = raycastCallback.getFixture().getBody().getEntity();
        if (raycastCallback.getPoint() != null)
            point = toPoint(raycastCallback.getPoint());
        if (entity == null && point == null)
            return RaycastResult.NONE;
        return new RaycastResult(entity, point);
    }
    /* JOINTS BEGIN */
    /**
     * Add revolute joint between two entities.
     *
     * @param e1 entity1
     * @param e2 entity2
     * @param localAnchor1 point in entity1 local coordinate system to which entity2 is attached
     * @param localAnchor2 point in entity2 local coordinate system to which entity1 is attached
     */
    public RevoluteJoint addRevoluteJoint(Entity e1, Entity e2, Point2D localAnchor1, Point2D localAnchor2) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        RevoluteJointDef def = new RevoluteJointDef();
        def.localAnchorA = toPoint(e1.getAnchoredPosition().add(localAnchor1)).subLocal(p1.getBody().getWorldCenter());
        def.localAnchorB = toPoint(e2.getAnchoredPosition().add(localAnchor2)).subLocal(p2.getBody().getWorldCenter());
        return addJoint(e1, e2, def);
    }
    /**
     * Add rope joint between two entities.
     * The joint runs between the center of e1 to the center of e2, using this distance as max length.
     */
    public RopeJoint addRopeJoint(Entity e1, Entity e2) {
        var c1 = e1.getBoundingBoxComponent().getCenterLocal();
        var c2 = e2.getBoundingBoxComponent().getCenterLocal();
        return addRopeJoint(e1, e2, c1, c2, e1.getCenter().distance(e2.getCenter()));
    }
    /**
     * Add rope joint between two entities.
     *
     * @param e1 entity1
     * @param e2 entity2
     * @param localAnchor1 point in entity1 local coordinate system to which entity2 is attached
     * @param localAnchor2 point in entity2 local coordinate system to which entity1 is attached
     * @param length the maximum length of the rope joint in pixels
     */
    public RopeJoint addRopeJoint(Entity e1, Entity e2, Point2D localAnchor1, Point2D localAnchor2, double length) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        RopeJointDef def = new RopeJointDef();
        def.localAnchorA.set(toPoint(e1.getAnchoredPosition().add(localAnchor1)).subLocal(p1.getBody().getWorldCenter()));
        def.localAnchorB.set(toPoint(e2.getAnchoredPosition().add(localAnchor2)).subLocal(p2.getBody().getWorldCenter()));
        def.maxLength = toMetersF(length);
        return addJoint(e1, e2, def);
    }
    /**
     * Add a prismatic joint (a slider along a given axis) between two entities.
     * More details: https://en.wikipedia.org/wiki/Prismatic_joint
     *
     * @param e1 entity1
     * @param e2 entity2
     * @param axis the axis along which to slide
     * @param limit max slide distance in pixels
     * @return joint
     */
    public PrismaticJoint addPrismaticJoint(Entity e1, Entity e2, Point2D axis, double limit) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        var def = new PrismaticJointDef();
        def.initialize(p1.getBody(), p2.getBody(), p2.getBody().getWorldCenter(), toVector(axis));
        def.enableLimit = true;
        def.upperTranslation = toMetersF(limit);
        return addJoint(e1, e2, def);
    }
    /**
     * Add a joint constraining two entities with PhysicsComponent.
     * The entities must already be in the game world.
     *
     * @return joint created using the provided definition
     */
    public <T extends Joint> T addJoint(Entity e1, Entity e2, JointDef<T> def) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        def.setBodyA(p1.body);
        def.setBodyB(p2.body);
        return jboxWorld.createJoint(def);
    }
    private void checkJointRequirements(Entity e1, Entity e2) {
        if (!e1.hasComponent(PhysicsComponent.class) || !e2.hasComponent(PhysicsComponent.class)) {
            throw new IllegalArgumentException("Cannot create a joint: both entities must have PhysicsComponent");
        }
    }
    /**
     * Remove given joint from the physics world.
     */
    public void removeJoint(Joint joint) {
        jboxWorld.destroyJoint(joint);
    }
    /* JOINTS END */
    @Override
    public double toMeters(double pixels) {
        return pixels * METERS_PER_PIXELS;
    }
    @Override
    public double toPixels(double meters) {
        return meters * PIXELS_PER_METER;
    }
    /**
     * Converts a point in pixel space to a point in physics space.
     *
     * @param p point in pixel space
     * @return point in physics space
     */
    @Override
    public Vec2 toPoint(Point2D p) {
        return new Vec2(toMetersF(p.getX()), toMetersF(appHeight - p.getY()));
    }
    /**
     * Converts a point in physics space to a point in pixel space.
     *
     * @param p point in physics space
     * @return point in pixel space
     */
    @Override
    public Point2D toPoint(Vec2 p) {
        return new Point2D(toPixels(p.x), toPixels(toMeters(appHeight) - p.y));
    }
    private class CollisionFilterCallback extends ContactFilter {
        @Override
        public boolean shouldCollide(Fixture fixtureA, Fixture fixtureB) {
            Entity e1 = fixtureA.getBody().getEntity();
            Entity e2 = fixtureB.getBody().getEntity();
            if (areCollidable(e1, e2) && isIgnored(e1, e2))
                return false;
            return super.shouldCollide(fixtureA, fixtureB);
        }
    }
}
/*
 * FXGL - JavaFX Game Library. The MIT License (MIT).
 * Copyright (c) AlmasB (almaslvl@gmail.com).
 * See LICENSE for details.
 */
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.physics.box2d.callbacks.ContactImpulse;
import com.almasb.fxgl.physics.box2d.callbacks.ContactListener;
import com.almasb.fxgl.physics.box2d.common.Sweep;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.*;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactSolver.ContactSolverDef;
import com.almasb.fxgl.physics.box2d.dynamics.joints.Joint;
import static com.almasb.fxgl.physics.box2d.common.JBoxSettings.*;
/*
 Position Correction Notes
 =========================
 I tried the several algorithms for position correction of the 2D revolute joint.
 I looked at these systems:
 - simple pendulum (1m diameter sphere on massless 5m stick) with initial angular velocity of 100 rad/s.
 - suspension bridge with 30 1m long planks of length 1m.
 - multi-link chain with 30 1m long links.
 Here are the algorithms:
 Baumgarte - A fraction of the position error is added to the velocity error. There is no
 separate position solver.
 Pseudo Velocities - After the velocity solver and position integration,
 the position error, Jacobian, and effective mass are recomputed. Then
 the velocity constraints are solved with pseudo velocities and a fraction
 of the position error is added to the pseudo velocity error. The pseudo
 velocities are initialized to zero and there is no warm-starting. After
 the position solver, the pseudo velocities are added to the positions.
 This is also called the First Order World method or the Position LCP method.
 Modified Nonlinear Gauss-Seidel (NGS) - Like Pseudo Velocities except the
 position error is re-computed for each raint and the positions are updated
 after the raint is solved. The radius vectors (aka Jacobians) are
 re-computed too (otherwise the algorithm has horrible instability). The pseudo
 velocity states are not needed because they are effectively zero at the beginning
 of each iteration. Since we have the current position error, we allow the
 iterations to terminate early if the error becomes smaller than JBoxSettings.linearSlop.
 Full NGS or just NGS - Like Modified NGS except the effective mass are re-computed
 each time a raint is solved.
 Here are the results:
 Baumgarte - this is the cheapest algorithm but it has some stability problems,
 especially with the bridge. The chain links separate easily close to the root
 and they jitter as they struggle to pull together. This is one of the most common
 methods in the field. The big drawback is that the position correction artificially
 affects the momentum, thus leading to instabilities and false bounce. I used a
 bias factor of 0.2. A larger bias factor makes the bridge less stable, a smaller
 factor makes joints and contacts more spongy.
 Pseudo Velocities - the is more stable than the Baumgarte method. The bridge is
 stable. However, joints still separate with large angular velocities. Drag the
 simple pendulum in a circle quickly and the joint will separate. The chain separates
 easily and does not recover. I used a bias factor of 0.2. A larger value lead to
 the bridge collapsing when a heavy cube drops on it.
 Modified NGS - this algorithm is better in some ways than Baumgarte and Pseudo
 Velocities, but in other ways it is worse. The bridge and chain are much more
 stable, but the simple pendulum goes unstable at high angular velocities.
 Full NGS - stable in all tests. The joints display good stiffness. The bridge
 still sags, but this is better than infinite forces.
 Recommendations
 Pseudo Velocities are not really worthwhile because the bridge and chain cannot
 recover from joint separation. In other cases the benefit over Baumgarte is small.
 Modified NGS is not a robust method for the revolute joint due to the violent
 instability seen in the simple pendulum. Perhaps it is viable with other raint
 types, especially scalar constraints where the effective mass is a scalar.
 This leaves Baumgarte and Full NGS. Baumgarte has small, but manageable instabilities
 and is very fast. I don't think we can escape Baumgarte, especially in highly
 demanding cases where high raint fidelity is not needed.
 Full NGS is robust and easy on the eyes. I recommend this as an option for
 higher fidelity simulation and certainly for suspension bridges and long chains.
 Full NGS might be a good choice for ragdolls, especially motorized ragdolls where
 joint separation can be problematic. The number of NGS iterations can be reduced
 for better performance without harming robustness much.
 Each joint in a can be handled differently in the position solver. So I recommend
 a system where the user can select the algorithm on a per joint basis. I would
 probably default to the slower Full NGS and let the user select the faster
 Baumgarte method in performance critical scenarios.
 */
/*
 Cache Performance
 The Box2D solvers are dominated by cache misses. Data structures are designed
 to increase the number of cache hits. Much of misses are due to random access
 to body data. The raint structures are iterated over linearly, which leads
 to few cache misses.
 The bodies are not accessed during iteration. Instead read only data, such as
 the mass values are stored with the constraints. The mutable data are the raint
 impulses and the bodies velocities/positions. The impulses are held inside the
 raint structures. The body velocities/positions are held in compact, temporary
 arrays to increase the number of cache hits. Linear and angular velocity are
 stored in a single array since multiple arrays lead to multiple misses.
 */
/*
 2D Rotation
 R = [cos(theta) -sin(theta)]
 [sin(theta) cos(theta) ]
 thetaDot = omega
 Let q1 = cos(theta), q2 = sin(theta).
 R = [q1 -q2]
 [q2  q1]
 q1Dot = -thetaDot * q2
 q2Dot = thetaDot * q1
 q1_new = q1_old - dt * w * q2
 q2_new = q2_old + dt * w * q1
 then normalize.
 This might be faster than computing sin+cos.
 However, we can compute sin+cos of the same angle fast.
 */
/**
 * This is an internal class.
 *
 * @author Daniel Murphy
 */
class Island {
    private ContactListener listener;
    private Body[] bodies;
    private Contact[] contacts;
    private Joint[] joints;
    private Position[] positions;
    private Velocity[] velocities;
    private int bodyCount;
    private int jointCount;
    private int contactCount;
    private int bodyCapacity;
    private int contactCapacity;
    void init(int bodyCapacity, int contactCapacity, int jointCapacity, ContactListener listener) {
        this.bodyCapacity = bodyCapacity;
        this.contactCapacity = contactCapacity;
        this.listener = listener;
        clear();
        if (bodies == null || bodyCapacity > bodies.length) {
            bodies = new Body[bodyCapacity];
        }
        if (joints == null || jointCapacity > joints.length) {
            joints = new Joint[jointCapacity];
        }
        if (contacts == null || contactCapacity > contacts.length) {
            contacts = new Contact[contactCapacity];
        }
        // dynamic array
        if (velocities == null || bodyCapacity > velocities.length) {
            final Velocity[] old = velocities == null ? new Velocity[0] : velocities;
            velocities = new Velocity[bodyCapacity];
            System.arraycopy(old, 0, velocities, 0, old.length);
            for (int i = old.length; i < velocities.length; i++) {
                velocities[i] = new Velocity();
            }
        }
        // dynamic array
        if (positions == null || bodyCapacity > positions.length) {
            final Position[] old = positions == null ? new Position[0] : positions;
            positions = new Position[bodyCapacity];
            System.arraycopy(old, 0, positions, 0, old.length);
            for (int i = old.length; i < positions.length; i++) {
                positions[i] = new Position();
            }
        }
    }
    void clear() {
        bodyCount = 0;
        contactCount = 0;
        jointCount = 0;
    }
    private final ContactSolver contactSolver = new ContactSolver();
    private final SolverData solverData = new SolverData();
    private final ContactSolverDef solverDef = new ContactSolverDef();
    void solve(TimeStep step, Vec2 gravity, boolean allowSleep) {
        float h = step.dt;
        // Integrate velocities and apply damping. Initialize the body state.
        for (int i = 0; i < bodyCount; ++i) {
            final Body b = bodies[i];
            final Sweep bm_sweep = b.m_sweep;
            final Vec2 c = bm_sweep.c;
            float a = bm_sweep.a;
            final Vec2 v = b.getLinearVelocity();
            float w = b.getAngularVelocity();
            // Store positions for continuous collision.
            bm_sweep.c0.set(bm_sweep.c);
            bm_sweep.a0 = bm_sweep.a;
            if (b.getType() == BodyType.DYNAMIC) {
                // Integrate velocities.
                // v += h * (b.m_gravityScale * gravity + b.m_invMass * b.m_force);
                v.x += h * (b.getGravityScale() * gravity.x + b.m_invMass * b.getForce().x);
                v.y += h * (b.getGravityScale() * gravity.y + b.m_invMass * b.getForce().y);
                w += h * b.m_invI * b.getTorque();
                // Apply damping.
                // ODE: dv/dt + c * v = 0
                // Solution: v(t) = v0 * exp(-c * t)
                // Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v *
                // exp(-c * dt)
                // v2 = exp(-c * dt) * v1
                // Pade approximation:
                // v2 = v1 * 1 / (1 + c * dt)
                v.x *= 1.0f / (1.0f + h * b.getLinearDamping());
                v.y *= 1.0f / (1.0f + h * b.getLinearDamping());
                w *= 1.0f / (1.0f + h * b.getAngularDamping());
            }
            positions[i].c.x = c.x;
            positions[i].c.y = c.y;
            positions[i].a = a;
            velocities[i].v.x = v.x;
            velocities[i].v.y = v.y;
            velocities[i].w = w;
        }
        // Solver data
        solverData.step = step;
        solverData.positions = positions;
        solverData.velocities = velocities;
        // Initialize velocity constraints.
        solverDef.step = step;
        solverDef.contacts = contacts;
        solverDef.count = contactCount;
        solverDef.positions = positions;
        solverDef.velocities = velocities;
        contactSolver.init(solverDef);
        contactSolver.initializeVelocityConstraints();
        if (step.warmStarting) {
            contactSolver.warmStart();
        }
        for (int i = 0; i < jointCount; ++i) {
            joints[i].initVelocityConstraints(solverData);
        }
        // Solve velocity constraints
        for (int i = 0; i < step.velocityIterations; ++i) {
            for (int j = 0; j < jointCount; ++j) {
                joints[j].solveVelocityConstraints(solverData);
            }
            contactSolver.solveVelocityConstraints();
        }
        // Store impulses for warm starting
        contactSolver.storeImpulses();
        // Integrate positions
        for (int i = 0; i < bodyCount; ++i) {
            Vec2 v = velocities[i].v;
            // Check for large velocities
            float tX = v.x * h;
            float tY = v.y * h;
            float translationSquared = tX * tX + tY * tY;
            if (translationSquared > maxTranslationSquared) {
                float ratio = maxTranslation / FXGLMath.sqrtF(translationSquared);
                v.mulLocal(ratio);
            }
            float w = velocities[i].w;
            float rotation = h * w;
            if (rotation * rotation > maxRotationSquared) {
                float ratio = maxRotation / FXGLMath.abs(rotation);
                w *= ratio;
            }
            Vec2 c = positions[i].c;
            // Integrate
            c.x += h * v.x;
            c.y += h * v.y;
            positions[i].a = positions[i].a + h * w;
            velocities[i].w = w;
        }
        // Solve position constraints
        boolean positionSolved = false;
        for (int i = 0; i < step.positionIterations; ++i) {
            boolean contactsOkay = contactSolver.solvePositionConstraints();
            boolean jointsOkay = true;
            for (int j = 0; j < jointCount; ++j) {
                boolean jointOkay = joints[j].solvePositionConstraints(solverData);
                jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
                // Exit early if the position errors are small.
                positionSolved = true;
                break;
            }
        }
        // Copy state buffers back to the bodies
        for (int i = 0; i < bodyCount; ++i) {
            Body body = bodies[i];
            body.m_sweep.c.x = positions[i].c.x;
            body.m_sweep.c.y = positions[i].c.y;
            body.m_sweep.a = positions[i].a;
            body.setLinearVelocityDirectly(velocities[i].v.x, velocities[i].v.y);
            body.setAngularVelocityDirectly(velocities[i].w);
            body.synchronizeTransform();
        }
        report(contactSolver.getVelocityConstraints());
        if (allowSleep) {
            float minSleepTime = Float.MAX_VALUE;
            final float linTolSqr = linearSleepTolerance * linearSleepTolerance;
            final float angTolSqr = angularSleepTolerance * angularSleepTolerance;
            for (int i = 0; i < bodyCount; ++i) {
                Body b = bodies[i];
                if (b.getType() == BodyType.STATIC) {
                    continue;
                }
                if (!b.isSleepingAllowed()
                        || b.getAngularVelocity() * b.getAngularVelocity() > angTolSqr
                        || Vec2.dot(b.getLinearVelocity(), b.getLinearVelocity()) > linTolSqr) {
                    b.setSleepTime(0);
                    minSleepTime = 0.0f;
                } else {
                    b.setSleepTime(b.getSleepTime() + h);
                    minSleepTime = Math.min(minSleepTime, b.getSleepTime());
                }
            }
            if (minSleepTime >= timeToSleep && positionSolved) {
                for (int i = 0; i < bodyCount; ++i) {
                    Body b = bodies[i];
                    b.setAwake(false);
                }
            }
        }
    }
    private final ContactSolver toiContactSolver = new ContactSolver();
    private final ContactSolverDef toiSolverDef = new ContactSolverDef();
    void solveTOI(TimeStep subStep, int toiIndexA, int toiIndexB) {
        assert toiIndexA < bodyCount;
        assert toiIndexB < bodyCount;
        // Initialize the body state.
        for (int i = 0; i < bodyCount; ++i) {
            positions[i].c.x = bodies[i].m_sweep.c.x;
            positions[i].c.y = bodies[i].m_sweep.c.y;
            positions[i].a = bodies[i].m_sweep.a;
            velocities[i].v.x = bodies[i].getLinearVelocity().x;
            velocities[i].v.y = bodies[i].getLinearVelocity().y;
            velocities[i].w = bodies[i].getAngularVelocity();
        }
        toiSolverDef.contacts = contacts;
        toiSolverDef.count = contactCount;
        toiSolverDef.step = subStep;
        toiSolverDef.positions = positions;
        toiSolverDef.velocities = velocities;
        toiContactSolver.init(toiSolverDef);
        // Solve position constraints.
        for (int i = 0; i < subStep.positionIterations; ++i) {
            boolean contactsOkay = toiContactSolver.solveTOIPositionConstraints(toiIndexA, toiIndexB);
            if (contactsOkay) {
                break;
            }
        }
        // Leap of faith to new safe state.
        bodies[toiIndexA].m_sweep.c0.x = positions[toiIndexA].c.x;
        bodies[toiIndexA].m_sweep.c0.y = positions[toiIndexA].c.y;
        bodies[toiIndexA].m_sweep.a0 = positions[toiIndexA].a;
        bodies[toiIndexB].m_sweep.c0.set(positions[toiIndexB].c);
        bodies[toiIndexB].m_sweep.a0 = positions[toiIndexB].a;
        // No warm starting is needed for TOI events because warm
        // starting impulses were applied in the discrete solver.
        toiContactSolver.initializeVelocityConstraints();
        // Solve velocity constraints.
        for (int i = 0; i < subStep.velocityIterations; ++i) {
            toiContactSolver.solveVelocityConstraints();
        }
        // Don't store the TOI contact forces for warm starting
        // because they can be quite large.
        float h = subStep.dt;
        // Integrate positions
        for (int i = 0; i < bodyCount; ++i) {
            Vec2 v = velocities[i].v;
            // Check for large velocities
            float tX = v.x * h;
            float tY = v.y * h;
            float translationSquared = tX * tX + tY * tY;
            if (translationSquared > maxTranslationSquared) {
                float ratio = maxTranslation / FXGLMath.sqrtF(translationSquared);
                v.mulLocal(ratio);
            }
            float w = velocities[i].w;
            float rotation = h * w;
            if (rotation * rotation > maxRotationSquared) {
                float ratio = maxRotation / FXGLMath.abs(rotation);
                w *= ratio;
            }
            Vec2 c = positions[i].c;
            // Integrate
            c.x += v.x * h;
            c.y += v.y * h;
            float a = positions[i].a;
            a += h * w;
            positions[i].c.x = c.x;
            positions[i].c.y = c.y;
            positions[i].a = a;
            velocities[i].v.x = v.x;
            velocities[i].v.y = v.y;
            velocities[i].w = w;
            // Sync bodies
            Body body = bodies[i];
            body.m_sweep.c.x = c.x;
            body.m_sweep.c.y = c.y;
            body.m_sweep.a = a;
            body.setLinearVelocityDirectly(v.x, v.y);
            body.setAngularVelocityDirectly(w);
            body.synchronizeTransform();
        }
        report(toiContactSolver.getVelocityConstraints());
    }
    void add(Body body) {
        body.m_islandIndex = bodyCount;
        bodies[bodyCount] = body;
        ++bodyCount;
    }
    void add(Contact contact) {
        contacts[contactCount++] = contact;
    }
    void add(Joint joint) {
        joints[jointCount++] = joint;
    }
    boolean isBodyCountEqualToCapacity() {
        return bodyCount == bodyCapacity;
    }
    boolean isContactCountEqualToCapacity() {
        return contactCount == contactCapacity;
    }
    private final ContactImpulse impulse = new ContactImpulse();
    private void report(ContactVelocityConstraint[] constraints) {
        if (listener == null) {
            return;
        }
        for (int i = 0; i < contactCount; ++i) {
            Contact c = contacts[i];
            ContactVelocityConstraint vc = constraints[i];
            impulse.count = vc.pointCount;
            for (int j = 0; j < vc.pointCount; ++j) {
                impulse.normalImpulses[j] = vc.points[j].normalImpulse;
                impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;
            }
            listener.postSolve(c, impulse);
        }
    }
    void resetFlagsAndSynchronizeBroadphaseProxies() {
        for (int i = 0; i < bodyCount; ++i) {
            Body body = bodies[i];
            body.setIslandFlag(false);
            if (body.getType() != BodyType.DYNAMIC) {
                continue;
            }
            body.synchronizeFixtures();
            // Invalidate all contact TOIs on this displaced body.
            for (ContactEdge ce = body.m_contactList; ce != null; ce = ce.next) {
                ce.contact.m_flags &= ~(Contact.TOI_FLAG | Contact.ISLAND_FLAG);
            }
        }
    }
    void postSolveCleanup() {
        for (int i = 0; i < bodyCount; ++i) {
            // Allow static bodies to participate in other islands.
            Body b = bodies[i];
            if (b.getType() == BodyType.STATIC) {
                b.setIslandFlag(false);
            }
        }
    }
}