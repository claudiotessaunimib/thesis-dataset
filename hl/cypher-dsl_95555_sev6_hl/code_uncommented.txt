package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.internal.RelationshipLength;
import org.neo4j.cypherdsl.core.internal.RelationshipTypes;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
@API(status = STABLE, since = "1.0")
public interface Relationship extends RelationshipPattern, PropertyContainer, ExposesProperties<Relationship>,
	ExposesPatternLengthAccessors<Relationship> {
	@API(status = INTERNAL, since = "1.0")
	enum Direction {
		LTR("-", "->"),
		RTL("<-", "-"),
		UNI("-", "-");
		Direction(String symbolLeft, String symbolRight) {
			this.symbolLeft = symbolLeft;
			this.symbolRight = symbolRight;
		}
		private final String symbolLeft;
		private final String symbolRight;
		@API(status = INTERNAL)
		public String getSymbolLeft() {
			return symbolLeft;
		}
		@API(status = INTERNAL)
		public String getSymbolRight() {
			return symbolRight;
		}
	}
	@API(status = STABLE, since = "1.0")
	final class Details implements Visitable {
		private final Direction direction;
		@SuppressWarnings("squid:S3077") 
		private volatile SymbolicName symbolicName;
		private final RelationshipTypes types;
		private final RelationshipLength length;
		private final Properties properties;
		private final Where innerPredicate;
		static Details create(Direction direction, SymbolicName symbolicName, String... types) {
			List<String> listOfTypes = Arrays.stream(types)
				.filter(type -> !(type == null || type.isEmpty())).toList();
			return create(direction, symbolicName, 	listOfTypes.isEmpty()  ? null : RelationshipTypes.of(types));
		}
		static Details create(Direction direction, SymbolicName symbolicName, RelationshipTypes types) {
			return new Details(direction, symbolicName, types, null, null, null);
		}
		private Details(Direction direction,
			SymbolicName symbolicName,
			RelationshipTypes types,
			RelationshipLength length,
			Properties properties,
			Where innerPredicate
		) {
			this.direction = Optional.ofNullable(direction).orElse(Direction.UNI);
			this.symbolicName = symbolicName;
			this.types = types;
			this.length = length;
			this.properties = properties;
			this.innerPredicate = innerPredicate;
		}
		public boolean hasContent() {
			return this.symbolicName != null || this.types != null || this.length != null || this.properties != null;
		}
		Details named(SymbolicName newSymbolicName) {
			Assertions.notNull(newSymbolicName, "Symbolic name is required.");
			return new Details(this.direction, newSymbolicName, this.types, this.length, this.properties, this.innerPredicate);
		}
		Details with(Properties newProperties) {
			return new Details(this.direction, this.symbolicName, this.types, this.length, newProperties, this.innerPredicate);
		}
		Details unbounded() {
			return new Details(this.direction, this.symbolicName, this.types, RelationshipLength.unbounded(), this.properties, this.innerPredicate);
		}
		Details inverse() {
			if (this.direction == Direction.UNI) {
				return this;
			}
			return new Details(this.direction == Direction.LTR ? Direction.RTL : Direction.LTR, null, this.types, this.length, this.properties, this.innerPredicate);
		}
		Details where(Expression predicate) {
			return new Details(this.direction, this.symbolicName, this.types, this.length, this.properties, Where.from(predicate));
		}
		Details min(Integer minimum) {
			if (minimum == null && (this.length == null || this.length.getMinimum() == null)) {
				return this;
			}
			RelationshipLength newLength = Optional.ofNullable(this.length)
				.map(l -> RelationshipLength.of(minimum, l.getMaximum()))
				.orElseGet(() -> RelationshipLength.of(minimum, null));
			return new Details(this.direction, this.symbolicName, this.types, newLength, properties, this.innerPredicate);
		}
		Details max(Integer maximum) {
			if (maximum == null && (this.length == null || this.length.getMaximum() == null)) {
				return this;
			}
			RelationshipLength newLength = Optional.ofNullable(this.length)
				.map(l -> RelationshipLength.of(l.getMinimum(), maximum))
				.orElseGet(() -> RelationshipLength.of(null, maximum));
			return new Details(this.direction, this.symbolicName, this.types, newLength, properties, this.innerPredicate);
		}
		@API(status = INTERNAL)
		public Direction getDirection() {
			return direction;
		}
		Optional<SymbolicName> getSymbolicName() {
			return Optional.ofNullable(symbolicName);
		}
		SymbolicName getRequiredSymbolicName() {
			SymbolicName requiredSymbolicName = this.symbolicName;
			if (requiredSymbolicName == null) {
				synchronized (this) {
					requiredSymbolicName = this.symbolicName;
					if (requiredSymbolicName == null) {
						this.symbolicName = SymbolicName.unresolved();
						requiredSymbolicName = this.symbolicName;
					}
				}
			}
			return requiredSymbolicName;
		}
		@API(status = INTERNAL)
		public List<String> getTypes() {
			return types == null ? List.of() : List.copyOf(types.getValues());
		}
		@API(status = INTERNAL)
		public Properties getProperties() {
			return properties;
		}
		@Override
		public void accept(Visitor visitor) {
			visitor.enter(this);
			Visitable.visitIfNotNull(this.symbolicName, visitor);
			Visitable.visitIfNotNull(this.types, visitor);
			Visitable.visitIfNotNull(this.length, visitor);
			Visitable.visitIfNotNull(this.properties, visitor);
			Visitable.visitIfNotNull(this.innerPredicate, visitor);
			visitor.leave(this);
		}
		@Override
		public String toString() {
			return RendererBridge.render(this);
		}
	}
	Node getLeft();
	@NotNull @Contract(pure = true)
	Details getDetails();
	@NotNull @Contract(pure = true)
	Node getRight();
	@Nullable @Contract(pure = true)
	QuantifiedPathPattern.Quantifier getQuantifier();
	@NotNull @Contract(pure = true)
	Relationship named(String newSymbolicName);
	@NotNull @Contract(pure = true)
	Relationship named(SymbolicName newSymbolicName);
	@NotNull @Contract(pure = true)
	Relationship inverse();
}
package org.neo4j.cypherdsl.core.internal;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.Arrays;
import java.util.List;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.Visitable;
@API(status = INTERNAL, since = "1.0")
public final class RelationshipTypes implements Visitable {
	private final List<String> values;
	public static RelationshipTypes of(String... types) {
		List<String> listOfTypes = Arrays.stream(types)
			.filter(type -> !(type == null || type.isEmpty()))
			.toList();
		return new RelationshipTypes(listOfTypes);
	}
	private RelationshipTypes(List<String> values) {
		this.values = values;
	}
	public List<String> getValues() {
		return values;
	}
	@Override
	public String toString() {
		return "RelationshipTypes{values=" + values + '}';
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.LinkedList;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.utils.Assertions;
@API(status = STABLE, since = "1.0")
public final class RelationshipChain implements RelationshipPattern, ExposesPatternLengthAccessors<RelationshipChain> {
	private final LinkedList<Relationship> relationships;
	static RelationshipChain create(Relationship firstElement) {
		return new RelationshipChain(firstElement);
	}
	private RelationshipChain(Relationship firstElement) {
		this.relationships = new LinkedList<>();
		this.relationships.add(firstElement);
	}
	private RelationshipChain(List<Relationship> firstElements, Relationship lastElement) {
		this.relationships = new LinkedList<>(firstElements);
		this.relationships.add(lastElement);
	}
	private RelationshipChain(List<Relationship> elements) {
		this.relationships = new LinkedList<>(elements);
	}
	RelationshipChain add(Relationship element) {
		Assertions.notNull(element, "Elements of a relationship chain must not be null.");
		return new RelationshipChain(this.relationships, element);
	}
	RelationshipChain replaceLast(Relationship element) {
		Assertions.notNull(element, "Elements of a relationship chain must not be null.");
		RelationshipChain newChain = new RelationshipChain(this.relationships);
		newChain.relationships.removeLast();
		newChain.relationships.add(element);
		return newChain;
	}
	@NotNull
	@Override
	public RelationshipChain relationshipTo(Node other, String... types) {
		return this.add(this.relationships.getLast().getRight().relationshipTo(other, types));
	}
	@NotNull
	@Override
	public RelationshipChain relationshipFrom(Node other, String... types) {
		return this.add(this.relationships.getLast().getRight().relationshipFrom(other, types));
	}
	@NotNull
	@Override
	public RelationshipChain relationshipBetween(Node other, String... types) {
		return this.add(this.relationships.getLast().getRight().relationshipBetween(other, types));
	}
	@NotNull
	@Override
	public RelationshipChain named(String newSymbolicName) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.named(newSymbolicName));
	}
	@NotNull
	@Override
	public RelationshipChain named(SymbolicName newSymbolicName) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.named(newSymbolicName));
	}
	@NotNull
	@Override
	public RelationshipChain where(@Nullable Expression predicate) {
		if (predicate == null) {
			return this;
		}
		var lastElement = this.relationships.getLast();
		return this.replaceLast((Relationship) lastElement.where(predicate));
	}
	@NotNull
	@Override
	public RelationshipPattern quantifyRelationship(@Nullable QuantifiedPathPattern.Quantifier quantifier) {
		if (quantifier == null) {
			return this;
		}
		var lastElement = this.relationships.getLast();
		return this.replaceLast((Relationship) lastElement.quantifyRelationship(quantifier));
	}
	@NotNull
	@Override
	public QuantifiedPathPattern quantify(@Nullable QuantifiedPathPattern.Quantifier newQuantifier) {
		return QuantifiedPathPattern.of(this, newQuantifier);
	}
	@NotNull @Contract(pure = true)
	@Override
	public RelationshipChain unbounded() {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.unbounded());
	}
	@NotNull @Contract(pure = true)
	@Override
	public RelationshipChain min(Integer minimum) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.min(minimum));
	}
	@NotNull @Contract(pure = true)
	@Override
	public RelationshipChain max(Integer maximum) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.max(maximum));
	}
	@NotNull @Contract(pure = true)
	@Override
	public RelationshipChain length(Integer minimum, Integer maximum) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.length(minimum, maximum));
	}
	@NotNull @Contract(pure = true)
	public RelationshipChain properties(MapExpression newProperties) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.withProperties(newProperties));
	}
	@NotNull @Contract(pure = true)
	public RelationshipChain properties(Object... keysAndValues) {
		Relationship lastElement = this.relationships.getLast();
		return this.replaceLast(lastElement.withProperties(keysAndValues));
	}
	@NotNull
	@Override
	public Condition asCondition() {
		return RelationshipPatternCondition.of(this);
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		Node lastNode = null;
		for (Relationship relationship : relationships) {
			visitor.enter(relationship);
			relationship.getLeft().accept(visitor);
			relationship.getDetails().accept(visitor);
			Visitable.visitIfNotNull(relationship.getQuantifier(), visitor);
			visitor.leave(relationship);
			lastNode = relationship.getRight();
		}
		Visitable.visitIfNotNull(lastNode, visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.annotations.CheckReturnValue;
@API(status = STABLE, since = "1.0")
public interface RelationshipPattern extends PatternElement, ExposesRelationships<RelationshipChain> {
	@NotNull @CheckReturnValue
	ExposesRelationships<RelationshipChain> named(String name);
	@NotNull @CheckReturnValue
	ExposesRelationships<RelationshipChain> named(SymbolicName name);
	@NotNull @Contract(pure = true)
	Condition asCondition();
	@NotNull @Contract(pure = true)
	default PatternElement quantifyRelationship(@Nullable QuantifiedPathPattern.Quantifier quantifier) {
		throw new UnsupportedOperationException();
	}
	@NotNull @Contract(pure = true)
	default PatternElement quantify(@Nullable QuantifiedPathPattern.Quantifier quantifier) {
		throw new UnsupportedOperationException();
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
@API(status = STABLE, since = "2021.2.3")
public interface ExposesPatternLengthAccessors<T extends RelationshipPattern> {
	@NotNull @Contract(pure = true)
	T unbounded();
	@NotNull @Contract(pure = true)
	T min(Integer minimum);
	@NotNull @Contract(pure = true)
	T max(Integer maximum);
	@NotNull @Contract(pure = true)
	T length(Integer minimum, Integer maximum);
}
package org.neo4j.cypherdsl.core.ast;
public interface Visitable {
	static void visitIfNotNull(Visitable visitable, Visitor visitor) {
		if (visitable != null) {
			visitable.accept(visitor);
		}
	}
	default void accept(Visitor visitor) {
		visitor.enter(this);
		visitor.leave(this);
	}
	String toString();
}
package org.neo4j.cypherdsl.core;
import java.util.Map;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
public interface ExposesProperties<T extends ExposesProperties<?> & PropertyContainer> {
	@NotNull @Contract(pure = true)
	T withProperties(MapExpression newProperties);
	@NotNull @Contract(pure = true)
	T withProperties(Object... keysAndValues);
	@NotNull @Contract(pure = true)
	T withProperties(Map<String, Object> newProperties);
}
package org.neo4j.cypherdsl.core.utils;
import java.util.Arrays;
import java.util.Objects;
import org.apiguardian.api.API;
@API(status = API.Status.INTERNAL, since = "2020.0.0")
public final class Assertions {
	public static void hasText(String text, String message) {
		if (!Strings.hasText(text)) {
			throw new IllegalArgumentException(message);
		}
	}
	public static void isTrue(boolean expression, String message) {
		if (!expression) {
			throw new IllegalArgumentException(message);
		}
	}
	public static void notNull(Object object, String message) {
		if (object == null) {
			throw new IllegalArgumentException(message);
		}
	}
	public static void isInstanceOf(Class<?> type, Object obj, String message) {
		notNull(type, "Type to check against must not be null");
		if (!type.isInstance(obj)) {
			throw new IllegalArgumentException(message);
		}
	}
	public static void notEmpty(Object[] array, String message) {
		if (isEmpty(array)) {
			throw new IllegalArgumentException(message);
		}
	}
	private static boolean isEmpty(Object[] array) {
		return array == null || array.length == 0 || Arrays.stream(array).allMatch(Objects::isNull);
	}
	private Assertions() {
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import org.apiguardian.api.API;
import org.apiguardian.api.API.Status;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.utils.Assertions;
import org.neo4j.cypherdsl.core.utils.LRUCache;
@API(status = Status.EXPERIMENTAL, since = "1.0")
public final class SymbolicName implements Expression, IdentifiableElement {
	private static final Map<String, SymbolicName> CACHE = Collections.synchronizedMap(new LRUCache<>(32));
	static SymbolicName of(String name) {
		Assertions.hasText(name, "Name must not be empty.");
		return CACHE.computeIfAbsent(name, SymbolicName::new);
	}
	static SymbolicName unsafe(String name) {
		Assertions.hasText(name, "Name must not be empty.");
		return new SymbolicName(name);
	}
	static SymbolicName unresolved() {
		return new SymbolicName(null);
	}
	private final String value;
	private SymbolicName(String value) {
		this.value = value;
	}
	@API(status = INTERNAL)
	public String getValue() {
		return value;
	}
	@NotNull @Contract(pure = true)
	public SymbolicName concat(String otherValue) {
		Assertions.notNull(otherValue, "Value to concat must not be null.");
		if (otherValue.isEmpty()) {
			return this;
		}
		return SymbolicName.of(this.value + otherValue);
	}
	@NotNull @Contract(pure = true)
	public MapProjection project(List<Object> entries) {
		return project(entries.toArray());
	}
	@NotNull @Contract(pure = true)
	public MapProjection project(Object... entries) {
		return MapProjection.create(this, entries);
	}
	@Override
	public String toString() {
		return value != null ? RendererBridge.render(this) : "Unresolved SymbolicName";
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		if (value == null) {
			return false;
		}
		SymbolicName that = (SymbolicName) o;
		return value.equals(that.value);
	}
	@Override
	public int hashCode() {
		return value == null ? super.hashCode() : Objects.hash(value);
	}
	@NotNull
	@Override
	public Expression asExpression() {
		return this;
	}
}
package org.neo4j.cypherdsl.parser;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.UnaryOperator;
import java.util.stream.Stream;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypher.internal.ast.factory.ASTFactory;
import org.neo4j.cypher.internal.ast.factory.ASTFactory.NULL;
import org.neo4j.cypher.internal.parser.common.ast.factory.AccessType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ActionType;
import org.neo4j.cypher.internal.parser.common.ast.factory.CallInTxsOnErrorBehaviourType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ConstraintType;
import org.neo4j.cypher.internal.parser.common.ast.factory.CreateIndexTypes;
import org.neo4j.cypher.internal.parser.common.ast.factory.HintIndexType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParameterType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserCypherTypeName;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserNormalForm;
import org.neo4j.cypher.internal.parser.common.ast.factory.ParserTrimSpecification;
import org.neo4j.cypher.internal.parser.common.ast.factory.ScopeType;
import org.neo4j.cypher.internal.parser.common.ast.factory.ShowCommandFilterTypes;
import org.neo4j.cypher.internal.parser.common.ast.factory.SimpleEither;
import org.neo4j.cypherdsl.core.Case;
import org.neo4j.cypherdsl.core.Clause;
import org.neo4j.cypherdsl.core.Clauses;
import org.neo4j.cypherdsl.core.Cypher;
import org.neo4j.cypherdsl.core.ExposesRelationships;
import org.neo4j.cypherdsl.core.Expression;
import org.neo4j.cypherdsl.core.Finish;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.Hint;
import org.neo4j.cypherdsl.core.KeyValueMapEntry;
import org.neo4j.cypherdsl.core.LabelExpression;
import org.neo4j.cypherdsl.core.MapExpression;
import org.neo4j.cypherdsl.core.MapProjection;
import org.neo4j.cypherdsl.core.MergeAction;
import org.neo4j.cypherdsl.core.NamedPath;
import org.neo4j.cypherdsl.core.Node;
import org.neo4j.cypherdsl.core.Operation;
import org.neo4j.cypherdsl.core.Parameter;
import org.neo4j.cypherdsl.core.PatternComprehension;
import org.neo4j.cypherdsl.core.PatternElement;
import org.neo4j.cypherdsl.core.Property;
import org.neo4j.cypherdsl.core.PropertyLookup;
import org.neo4j.cypherdsl.core.QuantifiedPathPattern;
import org.neo4j.cypherdsl.core.Relationship;
import org.neo4j.cypherdsl.core.RelationshipPattern;
import org.neo4j.cypherdsl.core.Return;
import org.neo4j.cypherdsl.core.Set;
import org.neo4j.cypherdsl.core.SortItem;
import org.neo4j.cypherdsl.core.Statement;
import org.neo4j.cypherdsl.core.StringLiteral;
import org.neo4j.cypherdsl.core.SymbolicName;
import org.neo4j.cypherdsl.core.Where;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
@API(status = INTERNAL, since = "2021.3.0")
final class CypherDslASTFactory implements ASTFactory<
	Statements,
	Statement,
	Statement,
	Clause,
	Finish,
	Return,
	Expression,
	List<Expression>,
	SortItem,
	PatternElement,
	NodeAtom,
	PathAtom,
	PathLength,
	Clause,
	Expression,
	Expression,
	Expression,
	Hint,
	Expression,
	LabelExpression,
	Expression,
	Parameter<?>,
	Expression,
	Property,
	Expression,
	Clause,
	Statement,
	Statement,
	Statement,
	Clause,
	Where,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	InputPosition,
	EntityType,
	QuantifiedPathPattern.Quantifier,
	PatternAtom,
	DatabaseName,
	NULL,
	NULL,
	PatternElement> {
	private static CypherDslASTFactory instanceFromDefaultOptions;
	static CypherDslASTFactory getInstance(Options options) {
		CypherDslASTFactory instance;
		if (options != null && !options.areDefault()) {
			instance = new CypherDslASTFactory(options);
		} else {
			instance = instanceFromDefaultOptions;
			if (instance == null) {
				synchronized (CypherDslASTFactory.class) {
					instance = instanceFromDefaultOptions;
					if (instance == null) {
						instanceFromDefaultOptions = new CypherDslASTFactory(Optional.ofNullable(options).orElseGet(Options::defaultOptions));
						instance = instanceFromDefaultOptions;
					}
				}
			}
		}
		return instance;
	}
	private final Options options;
	private CypherDslASTFactory(Options options) {
		this.options = options;
	}
	private String[] computeFinalLabelList(LabelParsedEventType event, List<StringPos<InputPosition>> inputLabels) {
		return inputLabels == null ? new String[0] : this.options.getLabelFilter()
			.apply(event, inputLabels.stream().map(v -> v.string).toList())
			.toArray(new String[0]);
	}
	private Optional<String[]> computeFinalLabelList(LabelParsedEventType event, LabelExpression inputLabels) {
		if (inputLabels == null) {
			return Optional.of(new String[0]);
		}
		if (inputLabels.type() == LabelExpression.Type.COLON_CONJUNCTION || (inputLabels.type() == LabelExpression.Type.LEAF && inputLabels.value() != null)) {
			return Optional.of(this.options.getLabelFilter()
				.apply(event, inputLabels.value())
				.toArray(new String[0]));
		}
		return Optional.empty();
	}
	private String[] computeFinalTypeList(TypeParsedEventType event, LabelExpression inputTypes) {
		if (inputTypes == null) {
			return new String[0];
		}
		if ((inputTypes.negated() && inputTypes.value().size() > 1) || inputTypes.type() == LabelExpression.Type.CONJUNCTION) {
			throw new UnsupportedOperationException("Expressions for relationship types are not supported in Cypher-DSL");
		}
		List<String> types = new ArrayList<>();
		traverseTypeExpression(types, inputTypes);
		return this.options.getTypeFilter()
			.apply(event, types)
			.toArray(new String[0]);
	}
	void traverseTypeExpression(List<String> types, LabelExpression expression) {
		if (expression.type() == LabelExpression.Type.LEAF || expression.type() == LabelExpression.Type.COLON_DISJUNCTION) {
			types.addAll(expression.value());
		} else {
			traverseTypeExpression(types, expression.lhs());
			traverseTypeExpression(types, expression.rhs());
		}
	}
	static void isInstanceOf(Class<?> type, Object obj, String message) {
		if (type == null) {
			throw new IllegalArgumentException("Type to check against must not be null");
		}
		if (!type.isInstance(obj)) {
			throw new IllegalArgumentException(message);
		}
	}
	private static void notNull(Object object, String message) {
		if (object == null) {
			throw new IllegalArgumentException(message);
		}
	}
	private <T extends Expression> T applyCallbacksFor(ExpressionCreatedEventType type, T newExpression) {
		return applyCallbacksFor(type, List.of(newExpression)).get(0);
	}
	@SuppressWarnings("unchecked")
	private <T extends Expression> List<T> applyCallbacksFor(ExpressionCreatedEventType type, List<T> expressions) {
		var callbacks = this.options.getOnNewExpressionCallbacks().getOrDefault(type, List.of());
		if (callbacks.isEmpty()) {
			return expressions;
		}
		var chainedCallbacks = callbacks.stream().reduce(Function.identity(), Function::andThen);
		return expressions.stream().map(e -> (T) chainedCallbacks.apply(e)).toList();
	}
	@SuppressWarnings("unchecked")
	private <T extends Visitable> T applyCallbacksFor(InvocationCreatedEventType type, T newExpression) {
		var callbacks = this.options.getOnNewInvocationCallbacks().getOrDefault(type, List.of());
		if (callbacks.isEmpty()) {
			return newExpression;
		}
		Visitable result = newExpression;
		for (UnaryOperator<Visitable> callback : callbacks) {
			result = callback.apply(result);
		}
		return (T) result;
	}
	private static SymbolicName assertSymbolicName(@Nullable Expression v) {
		if (v == null) {
			return null;
		}
		isInstanceOf(SymbolicName.class, v,  "An invalid type has been generated where a SymbolicName was required. Generated type was " + v.getClass().getName());
		return (SymbolicName) v;
	}
	@Override
	public Statements statements(List<Statement> statements) {
		return new Statements(statements);
	}
	@Override
	public Statement newSingleQuery(InputPosition p, List<Clause> clauses) {
		return newSingleQuery(clauses);
	}
	@Override
	public Statement newSingleQuery(List<Clause> clauses) {
		return Statement.of(clauses);
	}
	@Override
	public Statement newUnion(InputPosition p, Statement lhs, Statement rhs, boolean all) {
		if (all) {
			return Cypher.unionAll(lhs, rhs);
		} else {
			return Cypher.union(lhs, rhs);
		}
	}
	@Override
	public Clause directUseClause(InputPosition p, DatabaseName databaseName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause functionUseClause(InputPosition p, Expression function) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Finish newFinishClause(InputPosition p) {
		return Finish.create();
	}
	public List<Expression> newReturnItems(InputPosition p, boolean returnAll, List<Expression> returnItems) {
		var finalReturnItems = returnItems;
		if (returnAll) {
			finalReturnItems = Stream.concat(Stream.of(Cypher.asterisk()), finalReturnItems.stream()).toList();
		}
		if (finalReturnItems.isEmpty()) {
			if (!returnAll) {
				throw new IllegalArgumentException("Cannot return nothing.");
			}
			finalReturnItems = Collections.singletonList(Cypher.asterisk());
		}
		return finalReturnItems;
	}
	@Override
	public Return newReturnClause(InputPosition p, boolean distinct, List<Expression> returnItems, List<SortItem> sortItems,
		InputPosition orderPos, Expression skip, InputPosition skipPosition, Expression limit,
		InputPosition limitPosition) {
		return options.getReturnClauseFactory().apply(new ReturnDefinition(distinct, returnItems, sortItems, skip, limit));
	}
	@Override
	public Expression newReturnItem(InputPosition p, Expression e, Expression v) {
		var s = assertSymbolicName(v);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_RETURN_ITEM, e.as(s));
	}
	@Override
	public Expression newReturnItem(InputPosition p, Expression e, int eStartOffset, int eEndOffset) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_RETURN_ITEM, e);
	}
	@Override
	public SortItem orderDesc(InputPosition p, Expression e) {
		return e.descending();
	}
	@Override
	public SortItem orderAsc(InputPosition p, Expression e) {
		return e.ascending();
	}
	@Override
	public Clause withClause(InputPosition p, Return returnClause, Where where) {
		return Clauses.with(returnClause, where);
	}
	@Override
	public Clause matchClause(InputPosition p, boolean optional, NULL matchMode, List<PatternElement> patternElements, InputPosition patternPos, List<Hint> hints, Where whereIn) {
		var patternElementCallbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_MATCH, List.of());
		List<PatternElement> openForTransformation = new ArrayList<>();
		for (PatternElement patternElement : patternElements) {
			if (patternElement instanceof NodeAtom nodeAtom) {
				openForTransformation.add(nodeAtom.value());
			} else {
				openForTransformation.add(patternElement);
			}
		}
		var transformedPatternElements = transformIfPossible(patternElementCallbacks, openForTransformation);
		return options.getMatchClauseFactory().apply(new MatchDefinition(optional, transformedPatternElements, whereIn, hints));
	}
	private List<PatternElement> transformIfPossible(List<UnaryOperator<PatternElement>> callbacks,
		List<PatternElement> patternElements) {
		if (callbacks.isEmpty()) {
			return patternElements;
		}
		@SuppressWarnings("squid:S4276") 
		var transformer = Function.<PatternElement>identity();
		for (UnaryOperator<PatternElement> callback : callbacks) {
			transformer = transformer.andThen(callback);
		}
		return patternElements.stream().map(transformer)
			.filter(Objects::nonNull)
			.toList();
	}
	@Override
	public Hint usingIndexHint(InputPosition p, Expression v, String labelOrRelType, List<String> properties,
		boolean seekOnly, HintIndexType indexType) {
		var node = Cypher.node(labelOrRelType).named(assertSymbolicName(v));
		return Hint.useIndexFor(seekOnly, properties.stream().map(node::property).toArray(Property[]::new));
	}
	@Override
	public Hint usingJoin(InputPosition p, List<Expression> joinVariables) {
		return Hint.useJoinOn(joinVariables.stream().map(CypherDslASTFactory::assertSymbolicName).toArray(SymbolicName[]::new));
	}
	@Override
	public Hint usingScan(InputPosition p, Expression v, String label) {
		var s = assertSymbolicName(v);
		return Hint.useScanFor(Cypher.node(label).named(s));
	}
	@Override
	public Clause createClause(InputPosition p, List<PatternElement> patternElements) {
		var callbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_CREATE, List.of());
		return Clauses.create(transformIfPossible(callbacks, patternElements.stream().map(v -> v instanceof NodeAtom n ? n.value() : v).toList()));
	}
	@Override
	public Clause insertClause(InputPosition p, List<PatternElement> patternElements) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause setClause(InputPosition p, List<Expression> setItems) {
		return Clauses.set(setItems);
	}
	@Override
	public Operation setProperty(Property property, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_PROPERTY, property.to(value));
	}
	@Override
	public Expression setDynamicProperty(Expression dynamicProperty, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_PROPERTY, Cypher.set(dynamicProperty, value));
	}
	@Override
	public Operation setVariable(Expression v, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_VARIABLE, Cypher.set(v, value));
	}
	@Override
	public Operation addAndSetVariable(Expression v, Expression value) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_ADD_AND_SET_VARIABLE, Cypher.mutate(v, value));
	}
	@Override
	public Expression setLabels(Expression v, List<StringPos<InputPosition>> values, List<Expression> dynamicLabels, boolean containsIs) {
		var s = assertSymbolicName(v);
		var labels = computeFinalLabelList(LabelParsedEventType.ON_SET, values);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_SET_LABELS, Cypher.setLabel(Cypher.anyNode(s), labels));
	}
	@Override
	public Clause removeClause(InputPosition p, List<Expression> removeItems) {
		return Clauses.remove(removeItems);
	}
	@Override
	public Expression removeProperty(Property property) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_PROPERTY, property);
	}
	@Override
	public Expression removeDynamicProperty(Expression dynamicProperty) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_PROPERTY, dynamicProperty);
	}
	@Override
	public Expression removeLabels(Expression v, List<StringPos<InputPosition>> values,
		List<Expression> dynamicLabels, boolean containsIs) {
		var s = assertSymbolicName(v);
		var labels = computeFinalLabelList(LabelParsedEventType.ON_REMOVE, values);
		return applyCallbacksFor(ExpressionCreatedEventType.ON_REMOVE_LABELS, Cypher.removeLabel(Cypher.anyNode(s), labels));
	}
	@Override
	public Clause deleteClause(InputPosition p, boolean detach, List<Expression> expressions) {
		return Clauses.delete(detach, applyCallbacksFor(ExpressionCreatedEventType.ON_DELETE_ITEM, expressions));
	}
	@Override
	public Clause unwindClause(InputPosition p, Expression e, Expression v) {
		return Clauses.unwind(e, assertSymbolicName(v));
	}
	@Override
	public Clause mergeClause(InputPosition p, PatternElement patternElementIn, List<Clause> setClauses,
		List<MergeActionType> actionTypes, List<InputPosition> positions) {
		var patternElement = patternElementIn instanceof NodeAtom n ? n.value() : patternElementIn;
		var mergeActions = new ArrayList<MergeAction>();
		if (setClauses != null && !setClauses.isEmpty() && actionTypes != null && !actionTypes.isEmpty()) {
			var iteratorClauses = setClauses.iterator();
			var iteratorTypes = actionTypes.iterator();
			while (iteratorClauses.hasNext() && iteratorTypes.hasNext()) {
				var type = iteratorTypes.next();
				switch (type) {
					case OnCreate ->
						mergeActions.add(MergeAction.of(MergeAction.Type.ON_CREATE, (Set) iteratorClauses.next()));
					case OnMatch ->
						mergeActions.add(MergeAction.of(MergeAction.Type.ON_MATCH, (Set) iteratorClauses.next()));
					default -> throw new IllegalArgumentException("Unsupported MergeActionType: " + type);
				}
			}
		}
		var callbacks = this.options.getOnNewPatternElementCallbacks().getOrDefault(PatternElementCreatedEventType.ON_MERGE, List.of());
		return Clauses.merge(transformIfPossible(callbacks, List.of(patternElement)), mergeActions);
	}
	@Override
	public Clause callClause(InputPosition p, InputPosition namespacePosition, InputPosition procedureNamePosition,
		InputPosition procedureResultPosition, List<String> namespace, String name, List<Expression> arguments,
		boolean yieldAll, List<Expression> resultItems, Where where, boolean optional) {
		var intermediateResult = Clauses.callClause(namespace, name, arguments,
			yieldAll && resultItems == null ? List.of(Cypher.asterisk()) : resultItems, where);
		if (optional) {
			throw new IllegalArgumentException("Cannot render optional call clause");
		}
		return applyCallbacksFor(InvocationCreatedEventType.ON_CALL, intermediateResult);
	}
	@Override
	public Expression callResultItem(InputPosition p, String name, Expression alias) {
		var finalName = Cypher.name(name);
		if (alias != null) {
			return finalName.as(assertSymbolicName(alias));
		}
		return finalName;
	}
	@Override
	public PatternElement patternWithSelector(NULL aNull, PatternElement patternPart) {
		return null;
	}
	@Override
	public PatternElement namedPattern(Expression v, PatternElement patternElement) {
		return Cypher.path(assertSymbolicName(v)).definedBy(patternElement);
	}
	@Override
	public PatternElement shortestPathPattern(InputPosition p, PatternElement patternElement) {
		isInstanceOf(RelationshipPattern.class, patternElement,
			"Only relationship patterns are supported for the shortestPath function.");
		return new ExpressionAsPatternElementWrapper(
			FunctionInvocation.create(PatternElementFunctions.SHORTEST_PATH, patternElement));
	}
	@Override
	public PatternElement allShortestPathsPattern(InputPosition p, PatternElement patternElement) {
		isInstanceOf(RelationshipPattern.class, patternElement,
			"Only relationship patterns are supported for the allShortestPaths function.");
		return new ExpressionAsPatternElementWrapper(
			FunctionInvocation.create(PatternElementFunctions.ALL_SHORTEST_PATHS, patternElement));
	}
	@Override
	public PatternElement pathPattern(PatternElement patternElement) {
		return patternElement;
	}
	@Override
	public PatternElement insertPathPattern(List<PatternAtom> patternAtoms) {
		throw new UnsupportedOperationException();
	}
	static class PatternJuxtaposition extends TypedSubtree<PatternElement> implements PatternElement {
		PatternJuxtaposition(Collection<PatternElement> children) {
			super(children);
		}
		@Override
		public String separator() {
			return " ";
		}
	}
	static class PatternList extends TypedSubtree<PatternElement> implements PatternElement {
		PatternList(Collection<PatternElement> children) {
			super(children);
		}
	}
	@SuppressWarnings("squid:S3776") 
	@Override
	public PatternElement patternElement(List<PatternAtom> atoms) {
		if (atoms.isEmpty()) {
			throw new IllegalArgumentException(
				"Cannot create a PatternElement from an empty list of patterns.");
		}
		if (atoms.size() == 1 && atoms.get(0) instanceof ParenthesizedPathPatternAtom atom) {
			return atom.asPatternElement();
		}
		List<PatternElement> patternElements = new ArrayList<>();
		NodeAtom lastNodeAtom = null;
		PathAtom lastPathAtom = null;
		ExposesRelationships<?> relationshipPattern = null;
		List<PatternElement> patternList = null;
		for (PatternAtom atom : atoms) {
			if (atom instanceof ParenthesizedPathPatternAtom specificAtom) {
				if (lastNodeAtom != null) {
					patternElements.add(lastNodeAtom.value());
				}
				if (relationshipPattern != null) {
					patternElements.add((PatternElement) relationshipPattern);
				}
				if (patternList != null) {
					patternElements.add(new PatternList(patternList));
				}
				lastNodeAtom = null;
				lastPathAtom = null;
				relationshipPattern = null;
				patternList = null;
				patternElements.add(specificAtom.asPatternElement());
			} else if (atom instanceof NodeAtom nodeAtom) {
				if (relationshipPattern != null) {
					relationshipPattern = lastPathAtom.asRelationshipBetween(relationshipPattern, nodeAtom,
						options.isAlwaysCreateRelationshipsLTR());
				} else if (lastNodeAtom == null) {
					lastNodeAtom = nodeAtom;
				} else {
					relationshipPattern = lastNodeAtom.value();
					lastNodeAtom = null;
					relationshipPattern = lastPathAtom.asRelationshipBetween(relationshipPattern, nodeAtom,
						options.isAlwaysCreateRelationshipsLTR());
					if ((lastPathAtom.getDirection() == Relationship.Direction.RTL || patternList != null)
						&& options.isAlwaysCreateRelationshipsLTR()) {
						if (patternList == null) {
							patternList = new ArrayList<>();
						}
						patternList.add(((PatternElement) relationshipPattern));
						relationshipPattern = null;
						lastNodeAtom = nodeAtom;
					}
				}
			} else if (atom instanceof PathAtom pathAtom) {
				lastPathAtom = pathAtom;
			}
		}
		if (relationshipPattern == null && patternList != null && patternList.size() == 1 && patternList.get(0) instanceof RelationshipPattern singleListItem) {
			relationshipPattern = singleListItem;
			patternList = null;
		}
		if (relationshipPattern != null) {
			patternElements.add((PatternElement) relationshipPattern);
		} else if (patternList != null) {
			patternElements.add(new PatternList(patternList));
		} else if (lastNodeAtom != null) {
			patternElements.add(lastNodeAtom.value());
		}
		return patternElements.size() == 1 ? patternElements.get(0) : new PatternJuxtaposition(patternElements);
	}
	@Override
	public NULL anyPathSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allPathSelector(InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL anyShortestPathSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allShortestPathSelector(InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL shortestGroupsSelector(String count, InputPosition countPosition, InputPosition position) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NodeAtom nodePattern(InputPosition p, Expression v, LabelExpression labels, Expression properties, Expression predicate) {
		Node node;
		if (labels == null) {
			node = Cypher.anyNode();
		} else {
			var finalLabels = computeFinalLabelList(LabelParsedEventType.ON_NODE_PATTERN, labels);
			node = finalLabels.map(l -> {
				var primaryLabel = l[0];
				var additionalLabels = Arrays.stream(l).skip(1).toList();
				return Cypher.node(primaryLabel, additionalLabels);
			}).orElseGet(() -> Cypher.node(labels));
		}
		if (v != null) {
			node = node.named(assertSymbolicName(v));
		}
		if (properties != null) {
			node = node.withProperties((MapExpression) properties);
		}
		if (predicate != null) {
			node = (Node) node.where(predicate);
		}
		return new NodeAtom(node);
	}
	@Override
	public PathAtom relationshipPattern(InputPosition p, boolean left, boolean right, Expression v, LabelExpression relTypes, PathLength pathLength, Expression properties, Expression predicate) {
		return PathAtom.of(assertSymbolicName(v), pathLength, left, right,
			computeFinalTypeList(TypeParsedEventType.ON_RELATIONSHIP_PATTERN, relTypes), (MapExpression) properties,
			relTypes != null && relTypes.negated(), predicate);
	}
	@Override
	public PathLength pathLength(InputPosition p, InputPosition pMin, InputPosition pMax, String minLength,
		String maxLength) {
		return PathLength.of(minLength, maxLength);
	}
	@Override
	public QuantifiedPathPattern.Quantifier intervalPathQuantifier(InputPosition p, InputPosition posLowerBound, InputPosition posUpperBound, String lowerBound, String upperBound) {
		return QuantifiedPathPattern.interval(lowerBound == null ? null : Integer.parseInt(lowerBound), upperBound == null ? null : Integer.parseInt(upperBound));
	}
	@Override
	public QuantifiedPathPattern.Quantifier fixedPathQuantifier(InputPosition p, InputPosition valuePos, String value) {
		throw new UnsupportedOperationException();
	}
	@Override
	public QuantifiedPathPattern.Quantifier plusPathQuantifier(InputPosition p) {
		return QuantifiedPathPattern.plus();
	}
	@Override
	public QuantifiedPathPattern.Quantifier starPathQuantifier(InputPosition p) {
		return QuantifiedPathPattern.star();
	}
	@Override
	public NULL repeatableElements(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL differentRelationships(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public PatternAtom parenthesizedPathPattern(InputPosition p, PatternElement internalPattern, Expression where, QuantifiedPathPattern.Quantifier pathPatternQuantifier) {
		return new ParenthesizedPathPatternAtom((RelationshipPattern) internalPattern, pathPatternQuantifier, where);
	}
	@Override
	public PatternAtom quantifiedRelationship(PathAtom rel, QuantifiedPathPattern.Quantifier pathPatternQuantifier) {
		return rel.withQuantifier(pathPatternQuantifier);
	}
	@Override
	public Clause loadCsvClause(InputPosition p, boolean headers, Expression source, Expression v,
		String fieldTerminator) {
		isInstanceOf(StringLiteral.class, source, "Only string literals are supported as source for the LOAD CSV clause.");
		return Clauses.loadCSV(headers, (StringLiteral) source, assertSymbolicName(v), fieldTerminator);
	}
	@Override
	public Clause foreachClause(InputPosition p, Expression v, Expression list, List<Clause> objects) {
		return Clauses.forEach(assertSymbolicName(v), list, objects);
	}
	@Override
	public Clause subqueryClause(InputPosition p, Statement subquery, NULL inTransactions, boolean scopeAll,
		boolean hasScope, List<Expression> expressions, boolean optional) {
		if (optional) {
			throw new IllegalArgumentException("Cannot render optional subquery clause");
		}
		return Clauses.callClause(subquery);
	}
	@Override
	public NULL subqueryInTransactionsParams(InputPosition p, NULL batchParams, NULL concurrencyParams,
		NULL errorParams, NULL reportParams) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause yieldClause(InputPosition p, boolean returnAll, List<Expression> expressions,
		InputPosition returnItemsPosition, List<SortItem> orderBy, InputPosition orderPos, Expression skip,
		InputPosition skipPosition, Expression limit, InputPosition limitPosition, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showIndexClause(InputPosition p, ShowCommandFilterTypes indexType, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showConstraintClause(InputPosition p, ShowCommandFilterTypes constraintType, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showProcedureClause(InputPosition p, boolean currentUser, String user, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showFunctionClause(InputPosition p, ShowCommandFilterTypes functionType, boolean currentUser,
		String user, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement useGraph(Statement command, Clause useGraph) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showRoles(InputPosition p, boolean withUsers, boolean showAll, Clause yieldExpr,
		Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement grantRoles(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement revokeRoles(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createUser(InputPosition p, boolean replace, boolean ifNotExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Boolean suspended, DatabaseName homeDatabase,
		List<NULL> nulls, List<NULL> systemAuthAttributes) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropUser(InputPosition p, boolean ifExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameUser(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> fromUserName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> toUserName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement setOwnPassword(InputPosition p, Expression currentPassword, Expression newPassword) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL auth(String provider, List<NULL> nulls, InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL authId(InputPosition s, Expression id) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL password(InputPosition p, Expression password, boolean encrypted) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL passwordChangeRequired(InputPosition p, boolean changeRequired) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterUser(InputPosition p, boolean ifExists,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Boolean suspended, DatabaseName homeDatabase,
		boolean removeHome, List<NULL> nulls, List<NULL> systemAuthAttributes, boolean removeAllAuth,
		List<Expression> removeAuths) {
		throw new UnsupportedOperationException();
	}
	@Override public Expression passwordExpression(Parameter<?> password) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression passwordExpression(InputPosition s, InputPosition e, String password) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showUsers(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where,
		boolean withAuth) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showCurrentUser(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showSupportedPrivileges(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showAllPrivileges(InputPosition p, boolean asCommand, boolean asRevoke, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showRolePrivileges(InputPosition p,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles, boolean asCommand, boolean asRevoke,
		Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showUserPrivileges(InputPosition p,
		List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users, boolean asCommand, boolean asRevoke,
		Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement grantPrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement denyPrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement revokePrivilege(InputPosition p, List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> roles,
		NULL privilege, boolean revokeGrant, boolean revokeDeny) {
		throw new UnsupportedOperationException();
	}
	@SuppressWarnings("HiddenField") 
	public Statement createDatabase(InputPosition p, boolean replace, DatabaseName databaseName, boolean ifNotExists,
		NULL aNull, SimpleEither<Map<String, Expression>, Parameter<?>> options,
		SimpleEither<Integer, Parameter<?>> topologyPrimaries,
		SimpleEither<Integer, Parameter<?>> topologySecondaries) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createCompositeDatabase(InputPosition p, boolean replace, DatabaseName compositeDatabaseName,
		boolean ifNotExists, SimpleEither<Map<String, Expression>, Parameter<?>> databaseOptions, NULL aNull) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropDatabase(InputPosition p, DatabaseName databaseName, boolean ifExists, boolean composite,
		boolean aliasAction, boolean dumpData, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@SuppressWarnings("HiddenField") 
	@Override
	public Statement alterDatabase(InputPosition p, DatabaseName databaseName, boolean ifExists, AccessType accessType,
		SimpleEither<Integer, Parameter<?>> topologyPrimaries, SimpleEither<Integer, Parameter<?>> topologySecondaries,
		Map<String, Expression> options, java.util.Set<String> optionsToRemove, NULL aNull) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showDatabase(InputPosition p, NULL scope, Clause yieldExpr, Return returnWithoutGraph,
		Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement startDatabase(InputPosition p, DatabaseName databaseName, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement stopDatabase(InputPosition p, DatabaseName databaseName, NULL wait) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databaseScope(InputPosition p, DatabaseName databaseName, boolean isDefault, boolean isHome) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropAlias(InputPosition p, DatabaseName aliasName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showAliases(InputPosition p, DatabaseName aliasName, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void addDeprecatedIdentifierUnicodeNotification(InputPosition p, Character character, String identifier) {
	}
	@Override
	public NULL wait(boolean wait, long seconds) {
		throw new UnsupportedOperationException();
	}
	@Override
	public DatabaseName databaseName(InputPosition p, List<String> names) {
		if (names.isEmpty()) {
			throw new IllegalArgumentException("No database name");
		}
		if (names.size() == 1) {
			return new DatabaseName(Cypher.literalOf(names.get(0)));
		}
		return new DatabaseName(Cypher.literalOf(names));
	}
	@Override
	public DatabaseName databaseName(Parameter<?> param) {
		return new DatabaseName(param);
	}
	@Override
	public Statement createLocalDatabaseAlias(InputPosition p, boolean replace, DatabaseName aliasName,
		DatabaseName targetName, boolean ifNotExists, SimpleEither<Map<String, Expression>, Parameter<?>> properties
	) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createRemoteDatabaseAlias(InputPosition p, boolean replace, DatabaseName aliasName,
		DatabaseName targetName, boolean ifNotExists, SimpleEither<String, Parameter<?>> url,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Expression password,
		SimpleEither<Map<String, Expression>, Parameter<?>> driverSettings,
		SimpleEither<Map<String, Expression>, Parameter<?>> properties) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterLocalDatabaseAlias(InputPosition p, DatabaseName aliasName, DatabaseName targetName,
		boolean ifExists, SimpleEither<Map<String, Expression>, Parameter<?>> properties
	) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterRemoteDatabaseAlias(InputPosition p, DatabaseName aliasName, DatabaseName targetName,
		boolean ifExists, SimpleEither<String, Parameter<?>> url,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> username, Expression password,
		SimpleEither<Map<String, Expression>, Parameter<?>> driverSettings,
		SimpleEither<Map<String, Expression>, Parameter<?>> properties) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression newVariable(InputPosition p, String name) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_VARIABLE, Cypher.name(name));
	}
	@Override
	public Parameter<?> newParameter(InputPosition p, Expression v, ParameterType type) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_PARAMETER, parameterFromSymbolicName(v));
	}
	@Override
	public Parameter<?> newParameter(InputPosition p, String v, ParameterType type) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_PARAMETER, parameterFromSymbolicName(Cypher.name(v)));
	}
	@Override
	public Parameter<?> newSensitiveStringParameter(InputPosition p, Expression v) {
		throw new UnsupportedOperationException("The Cypher-DSL does not support sensitive parameters.");
	}
	@Override
	public Parameter<?> newSensitiveStringParameter(InputPosition p, String v) {
		throw new UnsupportedOperationException("The Cypher-DSL does not support sensitive parameters.");
	}
	@NotNull
	Parameter<?> parameterFromSymbolicName(Expression v) {
		var symbolicName = assertSymbolicName(v);
		if (symbolicName == null) {
			return Cypher.anonParameter(Cypher.literalNull());
		}
		var name = symbolicName.getValue();
		return options.getParameterValues().containsKey(name) ? Cypher.parameter(name, options.getParameterValues().get(name)) : Cypher.parameter(name);
	}
	@Override
	public Expression newDouble(InputPosition p, String image) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Double.parseDouble(image)));
	}
	@Override
	public Expression newDecimalInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image) * (negated ? -1 : 1)));
	}
	@Override public Expression newHexInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image.replaceFirst("(?i)0x", ""), 16) * (negated ? -1 : 1)));
	}
	@Override public Expression newOctalInteger(InputPosition p, String image, boolean negated) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(Long.parseUnsignedLong(image.replaceFirst("(?i)0o", ""), 8) * (negated ? -1 : 1)));
	}
	@Override
	public Expression newString(InputPosition start, InputPosition end, String image) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalOf(image));
	}
	@Override
	public Expression newTrueLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalTrue());
	}
	@Override
	public Expression newFalseLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalFalse());
	}
	@Override
	public Expression newInfinityLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, InfinityLiteral.INSTANCE);
	}
	@Override
	public Expression newNaNLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, NaNLiteral.INSTANCE);
	}
	@Override
	public Expression newNullLiteral(InputPosition p) {
		return applyCallbacksFor(ExpressionCreatedEventType.ON_NEW_LITERAL, Cypher.literalNull());
	}
	@Override
	public Expression listLiteral(InputPosition p, List<Expression> values) {
		return Cypher.listOf(values.toArray(new Expression[0]));
	}
	@Override
	public MapExpression mapLiteral(InputPosition p, List<StringPos<InputPosition>> keys, List<Expression> values) {
		Object[] keysAndValues = new Object[keys.size() * 2];
		int i = 0;
		Iterator<Expression> valueIterator = values.iterator();
		for (StringPos<InputPosition> key : keys) {
			keysAndValues[i++] = key.string;
			keysAndValues[i++] = valueIterator.next();
		}
		return options.isCreateSortedMaps() ? Cypher.sortedMapOf(keysAndValues) : Cypher.mapOf(keysAndValues);
	}
	@Override
	public Property property(Expression subject, StringPos<InputPosition> propertyKeyName) {
		return subject.property(propertyKeyName.string);
	}
	@Override
	public Expression or(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().or(rhs.asCondition());
	}
	@Override
	public Expression xor(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().xor(rhs.asCondition());
	}
	@Override
	public Expression and(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.asCondition().and(rhs.asCondition());
	}
	@Override
	public LabelExpression labelConjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return lhs.and(rhs);
	}
	@Override
	public LabelExpression labelDisjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return lhs.or(rhs);
	}
	@Override
	public LabelExpression labelNegation(InputPosition p, LabelExpression e, boolean containsIs) {
		return e.negate();
	}
	@Override
	public LabelExpression labelWildcard(InputPosition p, boolean containsIs) {
		throw new UnsupportedOperationException();
	}
	@Override
	public LabelExpression labelLeaf(InputPosition p, String e, EntityType entityType, boolean containsIs) {
		return new LabelExpression(e);
	}
	@Override
	public LabelExpression labelColonConjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return colonJunjction(lhs, rhs, LabelExpression.Type.COLON_CONJUNCTION);
	}
	@Override
	public LabelExpression labelColonDisjunction(InputPosition p, LabelExpression lhs, LabelExpression rhs, boolean containsIs) {
		return colonJunjction(lhs, rhs, LabelExpression.Type.COLON_DISJUNCTION);
	}
	@NotNull
	private static LabelExpression colonJunjction(LabelExpression lhs, LabelExpression rhs, LabelExpression.Type colonDisjunction) {
		List<String> value = new ArrayList<>();
		value.addAll(lhs.value());
		value.addAll(rhs.value());
		return new LabelExpression(colonDisjunction, false, value, null, null);
	}
	@Override
	public Expression labelExpressionPredicate(Expression subject, LabelExpression exp) {
		if (!(subject instanceof SymbolicName symbolicName)) {
			throw new IllegalArgumentException("Expected an symbolic name to create a label based expression predicate!");
		} else {
			List<String> values = new ArrayList<>();
			LabelExpression current = exp;
			while (current != null) {
				values.addAll(current.value());
				current = current.rhs();
			}
			return Cypher.hasLabelsOrType(symbolicName, values.toArray(String[]::new));
		}
	}
	@Override
	public Expression ands(List<Expression> exprs) {
		return exprs.stream().reduce(Cypher.noCondition(), (l, r) -> l.asCondition().and(r.asCondition()));
	}
	@Override
	public Expression not(InputPosition p, Expression e) {
		return e.asCondition().not();
	}
	@Override
	public Expression plus(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.add(rhs);
	}
	@Override
	public Expression minus(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.subtract(rhs);
	}
	@Override
	public Expression concatenate(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.concat(rhs);
	}
	@Override
	public Expression multiply(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.multiply(rhs);
	}
	@Override
	public Expression divide(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.divide(rhs);
	}
	@Override
	public Expression modulo(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.remainder(rhs);
	}
	@Override
	public Expression pow(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.pow(rhs);
	}
	@Override public Expression unaryPlus(Expression e) {
		return Cypher.plus(e);
	}
	@Override
	public Expression unaryPlus(InputPosition inputPosition, Expression expression) {
		return Cypher.plus(expression);
	}
	@Override
	public Expression unaryMinus(InputPosition inputPosition, Expression expression) {
		return Cypher.minus(expression);
	}
	@Override
	public Expression eq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.eq(rhs);
	}
	@Override
	public Expression neq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.ne(rhs);
	}
	@Override
	public Expression neq2(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.ne(rhs);
	}
	@Override
	public Expression lte(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.lte(rhs);
	}
	@Override
	public Expression gte(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.gte(rhs);
	}
	@Override
	public Expression lt(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.lt(rhs);
	}
	@Override
	public Expression gt(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.gt(rhs);
	}
	@Override
	public Expression regeq(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.matches(rhs);
	}
	@Override
	public Expression startsWith(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.startsWith(rhs);
	}
	@Override
	public Expression endsWith(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.endsWith(rhs);
	}
	@Override
	public Expression contains(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.contains(rhs);
	}
	@Override
	public Expression in(InputPosition p, Expression lhs, Expression rhs) {
		return lhs.in(rhs);
	}
	@Override
	public Expression isNull(InputPosition p, Expression e) {
		return e.isNull();
	}
	@Override
	public Expression isNotNull(InputPosition p, Expression e) {
		return e.isNotNull();
	}
	@Override
	public Expression isTyped(InputPosition p, Expression e, ParserCypherTypeName typeName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNotTyped(InputPosition p, Expression e, ParserCypherTypeName typeName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNormalized(InputPosition p, Expression e, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression isNotNormalized(InputPosition p, Expression e, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression listLookup(Expression list, Expression index) {
		return Cypher.valueAt(list, index);
	}
	@Override
	public Expression listSlice(InputPosition p, Expression list, Expression start, Expression end) {
		return Cypher.subList(list, start, end);
	}
	@Override
	public Expression newCountStar(InputPosition p) {
		return Cypher.count(Cypher.asterisk());
	}
	@Override
	public Expression functionInvocation(InputPosition p, InputPosition functionNamePosition, List<String> namespace,
		String name, boolean distinct, List<Expression> arguments, boolean calledFromUseClause) {
		String[] parts = new String[namespace.size() + 1];
		for (int i = 0; i < namespace.size(); i++) {
			parts[i] = namespace.get(i);
		}
		parts[parts.length - 1] = name;
		var expression = Cypher.call(parts).withArgs(arguments.toArray(Expression[]::new)).asFunction(distinct);
		return applyCallbacksFor(InvocationCreatedEventType.ON_INVOCATION, expression);
	}
	@Override
	public Expression listComprehension(InputPosition p, Expression v, Expression list, Expression where,
		Expression projection) {
		var in = Cypher.listWith(assertSymbolicName(v)).in(list);
		if (where != null) {
			var ongoingComprehension = in.where(where.asCondition());
			if (projection != null) {
				return ongoingComprehension.returning(projection);
			}
			return ongoingComprehension.returning();
		}
		return in.returning(projection);
	}
	@Override
	public Expression patternComprehension(InputPosition p, InputPosition relationshipPatternPosition, Expression v, PatternElement patternElement,
		Expression where, Expression projection) {
		PatternComprehension.OngoingDefinitionWithoutReturn ongoingDefinitionWithPattern;
		if (patternElement instanceof RelationshipPattern relationshipPattern) {
			if (v != null) {
				ongoingDefinitionWithPattern = Cypher.listBasedOn(Cypher.path(assertSymbolicName(v)).definedBy(relationshipPattern));
			} else {
				ongoingDefinitionWithPattern = Cypher.listBasedOn(relationshipPattern);
			}
		} else if (patternElement instanceof NamedPath namedPath) {
			ongoingDefinitionWithPattern = Cypher.listBasedOn(namedPath);
		} else {
			throw new IllegalArgumentException(
				"Cannot build a pattern comprehension around " + patternElement.getClass().getSimpleName());
		}
		if (where != null) {
			ongoingDefinitionWithPattern = ((PatternComprehension.OngoingDefinitionWithPattern) ongoingDefinitionWithPattern)
				.where(where.asCondition());
		}
		return ongoingDefinitionWithPattern.returning(projection);
	}
	@Override
	public Expression reduceExpression(InputPosition p, Expression acc, Expression accExpr, Expression v,
		Expression list, Expression innerExpr) {
		var variable = assertSymbolicName(v);
		if (variable == null) {
			throw new IllegalArgumentException("A variable to be reduced must be present.");
		}
		return Cypher.reduce(variable)
			.in(list)
			.map(innerExpr)
			.accumulateOn(assertSymbolicName(acc))
			.withInitialValueOf(accExpr);
	}
	@Override
	public Expression allExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "all(...) requires a WHERE predicate");
		return Cypher.all(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression anyExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "any(...) requires a WHERE predicate");
		return Cypher.any(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression noneExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "none(...) requires a WHERE predicate");
		return Cypher.none(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression singleExpression(InputPosition p, Expression v, Expression list, Expression where) {
		notNull(where, "single(...) requires a WHERE predicate");
		return Cypher.single(assertSymbolicName(v)).in(list).where(where.asCondition());
	}
	@Override
	public Expression normalizeExpression(InputPosition p, Expression i, ParserNormalForm normalForm) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression trimFunction(InputPosition inputPosition, ParserTrimSpecification parserTrimSpecification,
		Expression expression, Expression expression1) {
		var call = switch (parserTrimSpecification) {
			case BOTH -> Cypher.call("trim");
			case LEADING -> Cypher.call("ltrim");
			case TRAILING -> Cypher.call("rtrim");
		};
		return call.withArgs(
				expression == null ? new Expression[] {expression1} : new Expression[] {expression1, expression})
			.asFunction();
	}
	@Override
	public Expression patternExpression(InputPosition p, PatternElement patternElement) {
		if (patternElement instanceof ExpressionAsPatternElementWrapper wrapper) {
			return wrapper.getExpression();
		}
		if (patternElement instanceof RelationshipPattern relationshipPattern) {
			return new PatternElementAsExpressionWrapper(relationshipPattern);
		}
		throw new UnsupportedOperationException();
	}
	@Override
	public Expression existsExpression(InputPosition p, NULL matchMode, List<PatternElement> patternElements, Statement q, Where where) {
		if (q == null) {
			return Cypher.exists(patternElements, where);
		} else {
			return Cypher.exists(q);
		}
	}
	@Override
	public Expression countExpression(InputPosition p, NULL matchMode, List<PatternElement> patternElements, Statement q, Where where) {
		if (q == null) {
			return Cypher.count(patternElements, where);
		} else {
			return Cypher.count(q);
		}
	}
	@Override
	public Expression collectExpression(InputPosition inputPosition, Statement statement) {
		return Cypher.collect(statement);
	}
	@Override
	public Expression mapProjection(InputPosition p, Expression v, List<Expression> items) {
		return options.isCreateSortedMaps() ?
			MapProjection.sorted(assertSymbolicName(v), items.toArray(new Object[0])) :
			MapProjection.create(assertSymbolicName(v), items.toArray(new Object[0]));
	}
	@Override
	public Expression mapProjectionLiteralEntry(StringPos<InputPosition> property, Expression value) {
		return KeyValueMapEntry.create(property.string, value);
	}
	@Override
	public Expression mapProjectionProperty(StringPos<InputPosition> property) {
		return PropertyLookup.forName(property.string);
	}
	@Override
	public Expression mapProjectionVariable(Expression v) {
		return v;
	}
	@Override
	public Expression mapProjectionAll(InputPosition p) {
		return Cypher.asterisk();
	}
	@Override
	public Expression caseExpression(InputPosition p, Expression e, List<Expression> whens, List<Expression> thens,
		Expression elze) {
		if (whens != null && thens != null && whens.size() != thens.size()) {
			throw new IllegalArgumentException("Cannot combine lists of whens with a different sized list of thens.");
		}
		var aCase = Cypher.caseExpression(e);
		if (whens != null && thens != null) {
			var iteratorWhens = whens.iterator();
			var iteratorThens = thens.iterator();
			while (iteratorWhens.hasNext() && iteratorThens.hasNext()) {
				aCase = aCase.when(iteratorWhens.next()).then(iteratorThens.next());
			}
			if (elze != null) {
				return ((Case.CaseEnding) aCase).elseDefault(elze);
			}
			return aCase;
		}
		return aCase;
	}
	@Override
	public InputPosition inputPosition(int offset, int line, int column) {
		return new InputPosition(offset, line, column);
	}
	@Override
	public EntityType nodeType() {
		return EntityType.NODE;
	}
	@Override
	public EntityType relationshipType() {
		return EntityType.RELATIONSHIP;
	}
	@Override
	public EntityType nodeOrRelationshipType() {
		return EntityType.LOLWHAT;
	}
	@Override
	public Where whereClause(InputPosition p, Expression optionalWhere) {
		return Where.from(optionalWhere);
	}
	@Override
	public NULL subqueryInTransactionsBatchParameters(InputPosition p, Expression batchSize) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsConcurrencyParameters(InputPosition p, Expression concurrency) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsErrorParameters(InputPosition p, CallInTxsOnErrorBehaviourType onErrorBehaviour) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL subqueryInTransactionsReportParameters(InputPosition p, Expression v) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause orderBySkipLimitClause(InputPosition inputPosition, List<SortItem> list, InputPosition pos1,
		Expression expression, InputPosition pos2, Expression expression1, InputPosition pos3) {
		return null;
	}
	@Override
	public Clause showTransactionsClause(InputPosition p, SimpleEither<List<String>, Expression> ids, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause terminateTransactionsClause(InputPosition p, SimpleEither<List<String>, Expression> ids, Where where, Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause showSettingsClause(InputPosition p, SimpleEither<List<String>, Expression> names, Where where,
		Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Clause turnYieldToWith(Clause yieldClause) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createConstraint(InputPosition p, ConstraintType constraintType, boolean replace,
		boolean ifNotExists, SimpleEither<StringPos<InputPosition>, Parameter<?>> constraintName, Expression expression,
		StringPos<InputPosition> label, List<Property> properties, ParserCypherTypeName propertyType,
		SimpleEither<Map<String, Expression>, Parameter<?>> constraintOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropConstraint(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> name,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createLookupIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		StringPos<InputPosition> functionName, Expression functionParameter,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		StringPos<InputPosition> label, List<Property> properties,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions, CreateIndexTypes indexType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createFulltextIndex(InputPosition p, boolean replace, boolean ifNotExists, boolean isNode,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> indexName, Expression expression,
		List<StringPos<InputPosition>> labels, List<Property> properties,
		SimpleEither<Map<String, Expression>, Parameter<?>> indexOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropIndex(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> name,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement createRole(InputPosition p, boolean replace,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> roleName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> fromRole, boolean ifNotExists, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropRole(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> roleName,
		boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameRole(InputPosition p, SimpleEither<StringPos<InputPosition>, Parameter<?>> fromRoleName,
		SimpleEither<StringPos<InputPosition>, Parameter<?>> toRoleName, boolean ifExists) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databasePrivilege(InputPosition p, NULL aNull, NULL aNull2, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL dbmsPrivilege(InputPosition p, NULL aNull, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL loadPrivilege(InputPosition inputPosition, SimpleEither<String, Parameter<?>> simpleEither,
		SimpleEither<String, Parameter<?>> simpleEither1, boolean b) {
		return null;
	}
	@Override
	public NULL graphPrivilege(InputPosition inputPosition, NULL aNull, NULL aNull2, NULL aNull3, List<NULL> qualifier, boolean immutable) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL privilegeAction(ActionType action) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL propertiesResource(InputPosition p, List<String> property) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allPropertiesResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL labelsResource(InputPosition p, List<String> label) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allLabelsResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databaseResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL noResource(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL labelQualifier(InputPosition p, String label) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL relationshipQualifier(InputPosition p, String relationshipType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL elementQualifier(InputPosition p, String name) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allElementsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL patternQualifier(List<NULL> list, Expression expression, Expression expression2) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allLabelsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL allRelationshipsQualifier(InputPosition p) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allDatabasesQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> userQualifier(List<SimpleEither<StringPos<InputPosition>, Parameter<?>>> users) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> allUsersQualifier() {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> functionQualifier(InputPosition p, List<String> functions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> procedureQualifier(InputPosition p, List<String> procedures) {
		throw new UnsupportedOperationException();
	}
	@Override
	public List<NULL> settingQualifier(InputPosition inputPosition, List<String> list) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL graphScope(InputPosition inputPosition, List<DatabaseName> graphNames, ScopeType scopeType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public NULL databasePrivilegeScope(InputPosition inputPosition, List<DatabaseName> list, ScopeType scopeType) {
		throw new UnsupportedOperationException();
	}
	@Override
	public LabelExpression dynamicLabelLeaf(InputPosition p, Expression e, EntityType entityType, boolean all,
		boolean containsIs) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement enableServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<Map<String, Expression>, Parameter<?>> serverOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement alterServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<Map<String, Expression>, Parameter<?>> serverOptions) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement renameServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName, SimpleEither<String, Parameter<?>> newName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement dropServer(InputPosition p, SimpleEither<String, Parameter<?>> serverName) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement showServers(InputPosition p, Clause yieldExpr, Return returnWithoutGraph, Where where) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement deallocateServers(InputPosition p, boolean dryRun, List<SimpleEither<String, Parameter<?>>> serverNames) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Statement reallocateDatabases(InputPosition p, boolean dryRun) {
		throw new UnsupportedOperationException();
	}
}
package org.neo4j.cypherdsl.core;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import org.neo4j.cypherdsl.core.ast.ProvidesAffixes;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
public final class Hint implements Visitable {
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
	private enum Type implements Visitable {
		INDEX, INDEX_SEEK, SCAN, JOIN_ON;
		@Override
		public String toString() {
			return RendererBridge.render(this);
		}
	}
	private static final class IndexReference implements Visitable {
		private final SymbolicName symbolicName;
		private final NodeLabel optionalLabel;
		IndexReference(SymbolicName symbolicName) {
			this(symbolicName, null);
		}
		IndexReference(SymbolicName symbolicName, NodeLabel optionalLabel) {
			this.symbolicName = symbolicName;
			this.optionalLabel = optionalLabel;
		}
		boolean pointsToSameContainer(SymbolicName otherSymbolicName, NodeLabel otherLabel) {
			return this.symbolicName.equals(otherSymbolicName) && Objects.equals(this.optionalLabel, otherLabel);
		}
		@Override
		public void accept(Visitor visitor) {
			visitor.enter(this);
			this.symbolicName.accept(visitor);
			Visitable.visitIfNotNull(this.optionalLabel, visitor);
			visitor.leave(this);
		}
		@Override
		public String toString() {
			return RendererBridge.render(this);
		}
	}
	private static final class IndexReferences extends TypedSubtree<IndexReference> {
		IndexReferences(List<IndexReference> indexReferences) {
			super(indexReferences);
		}
	}
	private static final class IndexProperties extends TypedSubtree<SymbolicName> implements ProvidesAffixes {
		IndexProperties(List<SymbolicName> properties) {
			super(properties);
		}
		@Override
		public Optional<String> getPrefix() {
			return Optional.of("(");
		}
		@Override
		public Optional<String> getSuffix() {
			return Optional.of(")");
		}
	}
	public static Hint useIndexFor(boolean seek, Property... properties) {
		Assertions.notEmpty(properties, "Cannot use an index without properties!");
		List<SymbolicName> deferencedProperties = new ArrayList<>();
		IndexReference indexReference = null;
		for (Property property : properties) {
			Named container = property.getContainer();
			Assertions.notNull(container, "Cannot use a property without a reference to a container inside an index hint.");
			Assertions.isTrue(property.getNames().size() == 1,
				"One single property is required. Nested properties are not supported.");
			NodeLabel label;
			if (container instanceof Node node) {
				List<NodeLabel> labels = node.getLabels();
				Assertions.isTrue(labels.size() == 1, "Exactly one label is required to define the index.");
				label = labels.get(0);
			} else if (container instanceof Relationship relationship) {
				List<String> types = relationship.getDetails().getTypes();
				Assertions.isTrue(types.size() == 1, "Exactly one type is required to define the index.");
				label = new NodeLabel(types.get(0));
			} else {
				throw new IllegalArgumentException("A property index can only be used for Nodes or Relationships.");
			}
			SymbolicName symbolicName = container.getRequiredSymbolicName();
			if (indexReference == null) {
				indexReference = new IndexReference(symbolicName, label);
			} else if (!indexReference.pointsToSameContainer(symbolicName, label)) {
				throw new IllegalStateException(
					"If you want to use more than one index on different nodes you must use multiple `USING INDEX` statements.");
			}
			deferencedProperties.add(property.getNames().get(0).getPropertyKeyName());
		}
		return new Hint(seek ? Type.INDEX_SEEK : Type.INDEX, Collections.singletonList(indexReference),
			new IndexProperties(deferencedProperties));
	}
	public static Hint useScanFor(Node node) {
		Assertions.notNull(node, "Cannot apply a SCAN hint without a node.");
		List<NodeLabel> labels = node.getLabels();
		Assertions.isTrue(labels.size() == 1, "Exactly one label is required for a SCAN hint.");
		return new Hint(Type.SCAN,
			Collections.singletonList(new IndexReference(node.getRequiredSymbolicName(), labels.get(0))),
			null);
	}
	public static Hint useJoinOn(SymbolicName... name) {
		Assertions.notEmpty(name, "At least one name is required to define a JOIN hint.");
		return new Hint(Type.JOIN_ON, Arrays.stream(name).map(IndexReference::new).toList(), null);
	}
	private final Type type;
	private final IndexReferences indexReferences;
	private final IndexProperties optionalProperties;
	private Hint(Type type, List<IndexReference> indexReferences, IndexProperties optionalProperties) {
		this.type = type;
		this.indexReferences = new IndexReferences(indexReferences);
		this.optionalProperties = optionalProperties;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.type.accept(visitor);
		this.indexReferences.accept(visitor);
		Visitable.visitIfNotNull(this.optionalProperties, visitor);
		visitor.leave(this);
	}
}
package org.neo4j.cypherdsl.core.internal;
import static org.apiguardian.api.API.Status.INTERNAL;
import org.apiguardian.api.API;
import org.neo4j.cypherdsl.core.ast.Visitable;
@API(status = INTERNAL, since = "1.0")
public final class RelationshipLength implements Visitable {
	private final Integer minimum;
	private final Integer maximum;
	private final boolean unbounded;
	public static RelationshipLength unbounded() {
		return new RelationshipLength(null, null);
	}
	public static RelationshipLength of(Integer minimum, Integer maximum) {
		return new RelationshipLength(minimum, maximum);
	}
	private RelationshipLength(Integer minimum, Integer maximum) {
		this.minimum = minimum;
		this.maximum = maximum;
		this.unbounded = minimum == null && maximum == null;
	}
	@API(status = INTERNAL)
	public Integer getMinimum() {
		return minimum;
	}
	@API(status = INTERNAL)
	public Integer getMaximum() {
		return maximum;
	}
	@API(status = INTERNAL)
	public boolean isUnbounded() {
		return unbounded;
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
@API(status = STABLE, since = "1.0")
public interface Node extends PatternElement, PropertyContainer, ExposesProperties<Node>, ExposesRelationships<Relationship> {
	@NotNull @Contract(pure = true)
	List<NodeLabel> getLabels();
	@NotNull @Contract(pure = true)
	Node named(String newSymbolicName);
	@NotNull @Contract(pure = true)
	Node named(SymbolicName newSymbolicName);
	@NotNull @Contract(pure = true)
	Condition hasLabels(String... labelsToQuery);
	@NotNull @Contract(pure = true)
	Condition hasLabels(LabelExpression labels);
	@NotNull @Contract(pure = true)
	Condition isEqualTo(Node otherNode);
	@NotNull @Contract(pure = true)
	Condition isNotEqualTo(Node otherNode);
	@NotNull @Contract(pure = true)
	Condition isNull();
	@NotNull @Contract(pure = true)
	Condition isNotNull();
	@NotNull @Contract(pure = true)
	SortItem descending();
	@NotNull @Contract(pure = true)
	SortItem ascending();
	@NotNull @Contract(pure = true)
	AliasedExpression as(String alias);
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2022.6.0")
	@SuppressWarnings({ "DeprecatedIsStillUsed", "squid:S1133" }) 
	FunctionInvocation internalId();
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default FunctionInvocation elementId() {
		return Functions.elementId(this);
	}
	@NotNull @Contract(pure = true)
	FunctionInvocation labels();
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.utils.Assertions;
@API(status = STABLE, since = "1.0")
public interface Expression extends Visitable, PropertyAccessor {
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition includesAll(Expression rhs) {
		return Conditions.includesAll(this, rhs);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition includesAny(Expression rhs) {
		return Conditions.includesAny(this, rhs);
	}
	@NotNull @Contract(pure = true)
	default AliasedExpression as(String alias) {
		Assertions.hasText(alias, "The alias may not be null or empty.");
		return new AliasedExpression(this, alias);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Expression size() {
		return Functions.size(this);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition hasSize(Expression expectedSize) {
		return Functions.size(this).isEqualTo(expectedSize);
	}
	@NotNull @Contract(pure = true)
	default AliasedExpression as(SymbolicName alias) {
		Assertions.notNull(alias, "The alias may not be null.");
		return as(alias.getValue());
	}
	@NotNull @Contract(pure = true)
	default Condition asCondition() {
		return this instanceof Condition condition ? condition : new ExpressionCondition(this);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isEqualTo(Expression rhs) {
		return Conditions.isEqualTo(this, rhs);
	}
	@NotNull @Contract(pure = true)
	default Condition eq(Expression rhs) {
		return isEqualTo(rhs);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNotEqualTo(Expression rhs) {
		return Conditions.isNotEqualTo(this, rhs);
	}
	@NotNull @Contract(pure = true)
	default Condition ne(Expression rhs) {
		return isNotEqualTo(rhs);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition lt(Expression rhs) {
		return Conditions.lt(this, rhs);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition lte(Expression rhs) {
		return Conditions.lte(this, rhs);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition gt(Expression rhs) {
		return Conditions.gt(this, rhs);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition gte(Expression rhs) {
		return Conditions.gte(this, rhs);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isTrue() {
		return Conditions.isEqualTo(this, Cypher.literalTrue());
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isFalse() {
		return Conditions.isEqualTo(this, Cypher.literalFalse());
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition matches(Expression expression) {
		return Conditions.matches(this, expression);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition matches(String pattern) {
		return Conditions.matches(this, Cypher.literalOf(pattern));
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition startsWith(Expression expression) {
		return Conditions.startsWith(this, expression);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition contains(Expression expression) {
		return Conditions.contains(this, expression);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition endsWith(Expression expression) {
		return Conditions.endsWith(this, expression);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation concat(Expression expression) {
		return Operations.concat(this, expression);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation add(Expression addend) {
		return Operations.add(this, addend);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation subtract(Expression subtrahend) {
		return Operations.subtract(this, subtrahend);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation multiply(Expression multiplicand) {
		return Operations.multiply(this, multiplicand);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation divide(Expression dividend) {
		return Operations.divide(this, dividend);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation remainder(Expression dividend) {
		return Operations.remainder(this, dividend);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Operation pow(Expression n) {
		return Operations.pow(this, n);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNull() {
		return Conditions.isNull(this);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isNotNull() {
		return Conditions.isNotNull(this);
	}
	@NotNull @Contract(pure = true)
	default Condition in(Expression haystack) {
		return Comparison.create(this, Operator.IN, haystack);
	}
	@NotNull @Contract(pure = true)
	@SuppressWarnings("deprecation")
	default Condition isEmpty() {
		return Functions.size(this).isEqualTo(Cypher.literalOf(0L));
	}
	@NotNull @Contract(pure = true)
	default SortItem descending() {
		return SortItem.create(this, SortItem.Direction.DESC);
	}
	@NotNull @Contract(pure = true)
	default SortItem ascending() {
		return SortItem.create(this, SortItem.Direction.ASC);
	}
	@NotNull @Contract(pure = true)
	default SortItem sorted(SortItem.Direction direction) {
		return SortItem.create(this, direction);
	}
	@Override @NotNull
	default Property property(String... names) {
		return InternalPropertyImpl.create(this, names);
	}
	@Override @NotNull
	default Property property(@NotNull Expression lookup) {
		return InternalPropertyImpl.create(this, lookup);
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
@API(status = STABLE, since = "1.0")
public final class Where implements Visitable {
	private final Condition condition;
	@Nullable
	public static Where from(@Nullable Expression optionalWhere) {
		return optionalWhere == null ? null : new Where(optionalWhere.asCondition());
	}
	Where(Condition condition) {
		this.condition = condition;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.condition.accept(visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
package org.neo4j.cypherdsl.core;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.renderer.Configuration;
import org.neo4j.cypherdsl.core.renderer.Dialect;
import org.neo4j.cypherdsl.core.renderer.GeneralizedRenderer;
import org.neo4j.cypherdsl.core.renderer.Renderer;
class RendererBridge {
	private static final Configuration CONFIGURATION = Configuration.newConfig()
		.withDialect(Dialect.NEO4J_5)
		.alwaysEscapeNames(false).build();
	static String render(Visitable visitable) {
		String name;
		Class<? extends Visitable> clazz = visitable.getClass();
		if (clazz.isAnonymousClass()) {
			name = clazz.getName();
		} else {
			name = clazz.getSimpleName();
		}
		return "%s{cypher=%s}".formatted(name, Renderer.getRenderer(CONFIGURATION, GeneralizedRenderer.class).render(visitable));
	}
	private RendererBridge() {
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.cypherdsl.core.querydsl.CypherContext;
import org.neo4j.cypherdsl.core.querydsl.ToCypherFormatStringVisitor;
import com.querydsl.core.BooleanBuilder;
import com.querydsl.core.types.Path;
import com.querydsl.core.types.Predicate;
@API(status = INTERNAL, since = "2021.1.0")
@SuppressWarnings("unused")
@RegisterForReflection(allDeclaredConstructors = true)
final class QueryDSLAdapter implements ForeignAdapter<com.querydsl.core.types.Expression<?>> {
	private final com.querydsl.core.types.Expression<?> expression;
	QueryDSLAdapter(com.querydsl.core.types.Expression<?> expression) {
		this.expression = expression;
	}
	@Override
	@NotNull
	@SuppressWarnings("deprecation")
	public Condition asCondition() {
		if (!(expression instanceof Predicate)) {
			throw new IllegalArgumentException("Only Query-DSL predicates can be turned into Cypher-DSL's predicates.");
		}
		if (expression instanceof BooleanBuilder booleanBuilder && !booleanBuilder.hasValue()) {
			return Conditions.noCondition();
		}
		CypherContext context = new CypherContext();
		String formatString = expression.accept(ToCypherFormatStringVisitor.INSTANCE, context);
		return new ExpressionCondition(Cypher.raw(formatString, (Object[]) context.getExpressions()));
	}
	@Override
	@NotNull
	public Expression asExpression() {
		CypherContext context = new CypherContext();
		String formatString = expression.accept(ToCypherFormatStringVisitor.INSTANCE, context);
		return Cypher.raw(formatString, (Object[]) context.getExpressions());
	}
	@Override
	@NotNull
	public Node asNode() {
		if (!(expression instanceof Path<?> entityPath)) {
			throw new IllegalArgumentException("Only Query-DSL paths can be turned into nodes.");
		}
		return Cypher.node(entityPath.getRoot().getType().getSimpleName()).named(entityPath.getMetadata().getName());
	}
	@NotNull
	@Override
	public Relationship asRelationship() {
		throw new UnsupportedOperationException("Not yet implemented.");
	}
	@Override
	@NotNull
	public SymbolicName asName() {
		if (!(expression instanceof Path<?> entityPath)) {
			throw new IllegalArgumentException("Only Query-DSL paths can be turned into names.");
		}
		return Cypher.name(entityPath.getMetadata().getName());
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.FunctionInvocation.FunctionDefinition;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.utils.Assertions;
@API(status = STABLE, since = "1.1")
public final class NamedPath implements PatternElement, Named {
	private final SymbolicName name;
	private final Visitable optionalPattern;
	static OngoingDefinitionWithName named(String name) {
		return named(SymbolicName.of(name));
	}
	static OngoingDefinitionWithName named(SymbolicName name) {
		Assertions.notNull(name, "A name is required");
		return new Builder(name);
	}
	static OngoingShortestPathDefinitionWithName named(String name, FunctionDefinition algorithm) {
		return new ShortestPathBuilder(SymbolicName.of(name), algorithm);
	}
	static OngoingShortestPathDefinitionWithName named(SymbolicName name, FunctionDefinition algorithm) {
		Assertions.notNull(name, "A name is required");
		return new ShortestPathBuilder(name, algorithm);
	}
	public interface OngoingDefinitionWithName {
		@NotNull @Contract(pure = true)
		NamedPath definedBy(PatternElement patternElement);
		@NotNull @Contract(pure = true)
		NamedPath get();
	}
	public interface OngoingShortestPathDefinitionWithName {
		NamedPath definedBy(Relationship relationship);
	}
	private record Builder(SymbolicName name) implements OngoingDefinitionWithName {
		@NotNull
		@Override
		public NamedPath definedBy(PatternElement pattern) {
			if (pattern instanceof NamedPath namedPath) {
				return namedPath;
			}
			return new NamedPath(name, pattern);
		}
		@NotNull
		@Override
		public NamedPath get() {
			return new NamedPath(name);
		}
	}
	private record ShortestPathBuilder(
		SymbolicName name, FunctionDefinition algorithm) implements OngoingShortestPathDefinitionWithName {
		@Override
		public NamedPath definedBy(Relationship relationship) {
			return new NamedPath(name, FunctionInvocation.create(algorithm, relationship));
		}
	}
	private NamedPath(SymbolicName name) {
		this.name = name;
		this.optionalPattern = null;
	}
	private NamedPath(SymbolicName name, PatternElement optionalPattern) {
		this.name = name;
		this.optionalPattern = optionalPattern;
	}
	private NamedPath(SymbolicName name, FunctionInvocation algorithm) {
		this.name = name;
		this.optionalPattern = algorithm;
	}
	@Override
	@NotNull
	public Optional<SymbolicName> getSymbolicName() {
		return Optional.of(name);
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.name.accept(visitor);
		if (optionalPattern != null) {
			Operator.ASSIGMENT.accept(visitor);
			this.optionalPattern.accept(visitor);
		}
		visitor.leave(this);
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
@API(status = STABLE, since = "2021.1.0")
public interface ForeignAdapter<FE> {
	@NotNull @Contract(pure = true)
	Condition asCondition();
	@NotNull @Contract(pure = true)
	Expression asExpression();
	@NotNull @Contract(pure = true)
	Node asNode();
	@NotNull @Contract(pure = true)
	Relationship asRelationship();
	@NotNull @Contract(pure = true)
	SymbolicName asName();
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.lang.reflect.Array;
import java.net.URI;
import java.time.Duration;
import java.time.Period;
import java.time.temporal.TemporalAccessor;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.ResourceBundle;
import java.util.TimeZone;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ListComprehension.OngoingDefinitionWithVariable;
import org.neo4j.cypherdsl.core.Literal.UnsupportedLiteralException;
import org.neo4j.cypherdsl.core.PatternComprehension.OngoingDefinitionWithPattern;
import org.neo4j.cypherdsl.core.Statement.SingleQuery;
import org.neo4j.cypherdsl.core.Statement.UnionQuery;
import org.neo4j.cypherdsl.core.Statement.UseStatement;
import org.neo4j.cypherdsl.core.StatementBuilder.OngoingStandaloneCallWithoutArguments;
import org.neo4j.cypherdsl.core.utils.Assertions;
@SuppressWarnings("unused") @API(status = STABLE, since = "1.0")
public final class Cypher {
	static final ResourceBundle MESSAGES = ResourceBundle.getBundle("org.neo4j.cypherdsl.core.messages");
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, String... additionalLabels) {
		return new InternalNodeImpl(primaryLabel, additionalLabels);
	}
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, List<String> additionalLabels) {
		return new InternalNodeImpl(primaryLabel, additionalLabels.toArray(new String[] {}));
	}
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, MapExpression properties, String... additionalLabels) {
		return new InternalNodeImpl(null, primaryLabel, properties, additionalLabels);
	}
	@NotNull @Contract(pure = true)
	public static Node node(String primaryLabel, MapExpression properties, Collection<String> additionalLabels) {
		return node(primaryLabel, properties, additionalLabels.toArray(new String[] {}));
	}
	@NotNull @Contract(pure = true)
	public static Node anyNode() {
		return new InternalNodeImpl();
	}
	@NotNull @Contract(pure = true)
	public static Node node(LabelExpression labelExpression) {
		return new InternalNodeImpl(Objects.requireNonNull(labelExpression), null);
	}
	@NotNull @Contract(pure = true)
	public static Asterisk asterisk() {
		return Asterisk.INSTANCE;
	}
	@NotNull @Contract(pure = true)
	public static Node anyNode(String symbolicName) {
		return new InternalNodeImpl().named(symbolicName);
	}
	@NotNull @Contract(pure = true)
	public static Node anyNode(SymbolicName symbolicName) {
		return new InternalNodeImpl().named(symbolicName);
	}
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, String... names) {
		return property(name(containerName), names);
	}
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, Collection<String> names) {
		return property(name(containerName), names.toArray(new String[] {}));
	}
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, String... names) {
		return InternalPropertyImpl.create(expression, names);
	}
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, Collection<String> names) {
		return property(expression, names.toArray(new String[] {}));
	}
	@NotNull @Contract(pure = true)
	public static Property property(String containerName, Expression lookup) {
		return property(name(containerName), lookup);
	}
	@NotNull @Contract(pure = true)
	public static Property property(Expression expression, Expression lookup) {
		return InternalPropertyImpl.create(expression, lookup);
	}
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingDefinitionWithName path(String name) {
		return NamedPath.named(name);
	}
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingDefinitionWithName path(SymbolicName name) {
		return NamedPath.named(name);
	}
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingShortestPathDefinitionWithName shortestPath(String name) {
		return NamedPath.named(name, BuiltInFunctions.Scalars.SHORTEST_PATH);
	}
	@NotNull @Contract(pure = true)
	public static NamedPath.OngoingShortestPathDefinitionWithName shortestPath(SymbolicName name) {
		return NamedPath.named(name, BuiltInFunctions.Scalars.SHORTEST_PATH);
	}
	@NotNull @Contract(pure = true)
	public static SymbolicName name(String value) {
		return SymbolicName.of(value);
	}
	@NotNull @Contract(pure = true)
	public static Parameter<Object> parameter(String name) {
		return Parameter.create(name);
	}
	@NotNull @Contract(pure = true)
	public static <T> Parameter<T> parameter(String name, T value) {
		return Parameter.create(name, value);
	}
	@NotNull @Contract(pure = true)
	public static <T> Parameter<T> anonParameter(T value) {
		return Parameter.anon(value);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere optionalMatch(PatternElement... pattern) {
		return Statement.builder().optionalMatch(pattern);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere optionalMatch(
		Collection<? extends PatternElement> pattern) {
		return optionalMatch(pattern.toArray(new PatternElement[] {}));
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(PatternElement... pattern) {
		return Statement.builder().match(pattern);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(Collection<? extends PatternElement> pattern) {
		return match(pattern.toArray(new PatternElement[] {}));
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(boolean optional, PatternElement... pattern) {
		return Statement.builder().match(optional, pattern);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere match(boolean optional,
		Collection<? extends PatternElement> pattern) {
		return match(optional, pattern.toArray(new PatternElement[] {}));
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUpdate create(PatternElement... pattern) {
		return Statement.builder().create(pattern);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUpdate create(Collection<? extends PatternElement> pattern) {
		return create(pattern.toArray(new PatternElement[] {}));
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(String... variables) {
		return Statement.builder().with(variables);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(IdentifiableElement... elements) {
		return Statement.builder().with(elements);
	}
	public static SubqueryExpressionBuilder subqueryWith(String... identifiableElements) {
		return subqueryWith(Arrays.stream(identifiableElements).map(SymbolicName::of).toArray(SymbolicName[]::new));
	}
	public static SubqueryExpressionBuilder subqueryWith(IdentifiableElement... identifiableElements) {
		return Expressions.with(identifiableElements);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OrderableOngoingReadingAndWithWithoutWhere with(
		Collection<IdentifiableElement> elements) {
		return Statement.builder().with(elements);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingMerge merge(PatternElement... pattern) {
		return Statement.builder().merge(pattern);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingMerge merge(Collection<? extends PatternElement> pattern) {
		return merge(pattern.toArray(new PatternElement[] {}));
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Expression expression) {
		return Statement.builder().unwind(expression);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Expression... expressions) {
		return Statement.builder().unwind(Cypher.listOf(expressions));
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingUnwind unwind(Collection<? extends Expression> expressions) {
		return unwind(expressions.toArray(new Expression[] {}));
	}
	@NotNull @Contract(pure = true)
	public static SortItem sort(Expression expression) {
		return SortItem.create(expression, null);
	}
	@NotNull @Contract(pure = true)
	public static SortItem sort(Expression expression, SortItem.Direction direction) {
		return SortItem.create(expression, direction);
	}
	@NotNull @Contract(pure = true)
	public static MapExpression mapOf(Object... keysAndValues) {
		return MapExpression.create(false, keysAndValues);
	}
	@NotNull @Contract(pure = true)
	public static MapExpression sortedMapOf(Object... keysAndValues) {
		return MapExpression.create(true, keysAndValues);
	}
	@NotNull @Contract(pure = true)
	public static MapExpression asExpression(Map<String, Object> map) {
		return MapExpression.create(map);
	}
	@NotNull @Contract(pure = true)
	public static ListExpression listOf(Expression... expressions) {
		return ListExpression.create(expressions);
	}
	@NotNull @Contract(pure = true)
	public static ListExpression listOf(Collection<? extends Expression> expressions) {
		return Cypher.listOf(expressions.toArray(new Expression[0]));
	}
	@SuppressWarnings("unchecked")
	@NotNull @Contract(pure = true)
	public static <T> Literal<T> literalOf(Object object) {
		if (object == null) {
			return (Literal<T>) NullLiteral.INSTANCE;
		}
		if (object instanceof Literal<?>) {
			return (Literal<T>) object;
		}
		if (object instanceof CharSequence charSequence) {
			return (Literal<T>) new StringLiteral(charSequence);
		}
		if (object instanceof Character) {
			return (Literal<T>) new StringLiteral(String.valueOf(object));
		}
		if (object instanceof Number number) {
			return (Literal<T>) new NumberLiteral(number);
		}
		if (object instanceof TemporalAccessor temporalAccessor) {
			return (Literal<T>) new TemporalLiteral(temporalAccessor);
		}
		if (object instanceof Duration duration) {
			return (Literal<T>) DurationLiteral.of(duration);
		}
		if (object instanceof Period period) {
			return (Literal<T>) PeriodLiteral.of(period);
		}
		if (object instanceof Iterable || object.getClass().isArray()) {
			List<Literal<?>> elements = new ArrayList<>();
			Consumer<Object> handleElement = element -> {
				if (element instanceof Literal) {
					elements.add((Literal<?>) element);
				} else {
					try {
						elements.add(Cypher.literalOf(element));
					} catch (UnsupportedLiteralException e) {
						throw new UnsupportedLiteralException("Unsupported literal type in iterable.", element);
					}
				}
			};
			if (object.getClass().isArray()) {
				for (int i = 0; i < Array.getLength(object); i++) {
					handleElement.accept(Array.get(object, i));
				}
			} else {
				((Iterable<?>) object).forEach(handleElement);
			}
			ListLiteral listLiteral = new ListLiteral(elements);
			return (Literal<T>) listLiteral;
		}
		if (object instanceof Map) {
			Map<String, Literal<?>> map = new LinkedHashMap<>();
			BiConsumer<Object, Object> handleEntry = (key, value) -> {
				if (!(key instanceof CharSequence || key instanceof Character)) {
					throw new UnsupportedLiteralException(
						"Unsupported literal map key (not a string/char type).", key);
				}
				if (value instanceof Literal) {
					map.put(key.toString(), (Literal<?>) value);
				} else {
					try {
						map.put(key.toString(), Cypher.literalOf(value));
					} catch (UnsupportedLiteralException e) {
						throw new UnsupportedLiteralException("Unsupported literal type in map.", value);
					}
				}
			};
			((Map<?, ?>) object).forEach(handleEntry);
			MapLiteral mapLiteral = new MapLiteral(map);
			return (Literal<T>) mapLiteral;
		}
		if (object instanceof Boolean b) {
			return (Literal<T>) BooleanLiteral.of(b);
		}
		throw new UnsupportedLiteralException(object);
	}
	@NotNull @Contract(pure = true)
	public static Literal<Boolean> literalTrue() {
		return BooleanLiteral.TRUE;
	}
	@NotNull @Contract(pure = true)
	public static Literal<Boolean> literalFalse() {
		return BooleanLiteral.FALSE;
	}
	@NotNull @Contract(pure = true)
	public static Literal<Void> literalNull() {
		return NullLiteral.INSTANCE;
	}
	@NotNull @Contract(pure = true)
	public static UnionQuery union(Statement... statements) {
		return unionImpl(false, statements);
	}
	@NotNull @Contract(pure = true)
	public static UnionQuery union(Collection<Statement> statements) {
		return union(statements.toArray(new Statement[] {}));
	}
	@NotNull @Contract(pure = true)
	public static Statement unionAll(Statement... statements) {
		return unionImpl(true, statements);
	}
	@NotNull @Contract(pure = true)
	public static Statement unionAll(Collection<Statement> statements) {
		return unionAll(statements.toArray(new Statement[] {}));
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returning(Expression... expressions) {
		return Statement.builder().returning(expressions);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returning(Collection<? extends Expression> expressions) {
		return Statement.builder().returning(expressions);
	}
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithPattern listBasedOn(RelationshipPattern relationshipPattern) {
		return PatternComprehension.basedOn(relationshipPattern);
	}
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithPattern listBasedOn(NamedPath namedPath) {
		return PatternComprehension.basedOn(namedPath);
	}
	@NotNull @Contract(pure = true)
	public static OngoingDefinitionWithVariable listWith(SymbolicName variable) {
		return ListComprehension.with(variable);
	}
	@NotNull @Contract(pure = true)
	public static String quote(String unquotedString) {
		return literalOf(unquotedString).asString();
	}
	@NotNull @Contract(pure = true)
	public static Case caseExpression() {
		return Case.create(null);
	}
	@NotNull @Contract(pure = true)
	public static Case caseExpression(@Nullable Expression expression) {
		return Case.create(expression);
	}
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(String procedureName) {
		Assertions.hasText(procedureName, "The procedure name must not be null or empty.");
		return call(procedureName.split("\\."));
	}
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(String... namespaceAndProcedure) {
		return Statement.call(namespaceAndProcedure);
	}
	@NotNull @Contract(pure = true)
	public static OngoingStandaloneCallWithoutArguments call(Collection<String> namespaceAndProcedure) {
		return call(namespaceAndProcedure.toArray(new String[] {}));
	}
	@Neo4jVersion(minimum = "4.0.0")
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingWithoutWhere call(Statement subquery) {
		return Statement.builder().call(subquery);
	}
	@NotNull @Contract(pure = true)
	public static Expression subList(Expression targetExpression, Integer start, Integer end) {
		return ListOperator.subList(targetExpression, Cypher.literalOf(start), Cypher.literalOf(end));
	}
	@NotNull @Contract(pure = true)
	public static Expression subList(Expression targetExpression, Expression start, Expression end) {
		return ListOperator.subList(targetExpression, start, end);
	}
	@NotNull @Contract(pure = true)
	public static Expression subListFrom(Expression targetExpression, Integer start) {
		return ListOperator.subListFrom(targetExpression, Cypher.literalOf(start));
	}
	@NotNull @Contract(pure = true)
	public static Expression subListFrom(Expression targetExpression, Expression start) {
		return ListOperator.subListFrom(targetExpression, start);
	}
	@NotNull @Contract(pure = true)
	public static Expression subListUntil(Expression targetExpression, Integer end) {
		return ListOperator.subListUntil(targetExpression, Cypher.literalOf(end));
	}
	@NotNull @Contract(pure = true)
	public static Expression subListUntil(Expression targetExpression, Expression end) {
		return ListOperator.subListUntil(targetExpression, end);
	}
	@NotNull @Contract(pure = true)
	public static ListOperator valueAt(Expression targetExpression, Integer index) {
		return valueAt(targetExpression, Cypher.literalOf(index));
	}
	@NotNull @Contract(pure = true)
	public static ListOperator valueAt(Expression targetExpression, Expression index) {
		return ListOperator.valueAt(targetExpression, index);
	}
	@NotNull @Contract(pure = true)
	public static Expression raw(String format, Object... mixedArgs) {
		return RawLiteral.create(format, mixedArgs);
	}
	public static ExposesSubqueryCall.BuildableSubquery callRawCypher(String rawCypher, Object... args) {
		return Statement.builder().callRawCypher(rawCypher, args);
	}
	@NotNull @Contract(pure = true)
	public static StatementBuilder.OngoingReadingAndReturn returningRaw(Expression rawExpression) {
		return Statement.builder().returningRaw(rawExpression);
	}
	@SuppressWarnings("squid:S3077")
	private static volatile ForeignAdapterFactory foreignAdapterFactory;
	@NotNull @Contract(pure = true)
	public static <FE> ForeignAdapter<FE> adapt(FE expression) {
		ForeignAdapterFactory initializedForeignAdapterFactory = foreignAdapterFactory;
		if (initializedForeignAdapterFactory == null) {
			synchronized (Cypher.class) {
				initializedForeignAdapterFactory = foreignAdapterFactory;
				if (initializedForeignAdapterFactory == null) {
					foreignAdapterFactory = new ForeignAdapterFactory();
					initializedForeignAdapterFactory = foreignAdapterFactory;
				}
			}
		}
		return initializedForeignAdapterFactory.getAdapterFor(expression);
	}
	@NotNull @Contract(pure = true)
	public static ExposesLoadCSV usingPeriodicCommit() {
		return usingPeriodicCommit(null);
	}
	@NotNull @Contract(pure = true)
	public static ExposesLoadCSV usingPeriodicCommit(@Nullable Integer rate) {
		return LoadCSVStatementBuilder.usingPeriodicCommit(rate);
	}
	public static LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from) {
		return loadCSV(from, false);
	}
	public static LoadCSVStatementBuilder.OngoingLoadCSV loadCSV(URI from, boolean withHeaders) {
		return LoadCSVStatementBuilder.loadCSV(from, withHeaders);
	}
	private static UnionQuery unionImpl(boolean unionAll, Statement... statements) {
		Assertions.isTrue(statements != null && statements.length >= 2, "At least two statements are required!");
		int i = 0;
		UnionQueryImpl existingUnionQuery = null;
		@SuppressWarnings("squid:S2259") 
		boolean isUnionQuery = statements[0] instanceof UnionQueryImpl;
		if (isUnionQuery) {
			existingUnionQuery = (UnionQueryImpl) statements[0];
			Assertions.isTrue(existingUnionQuery.isAll() == unionAll, "Cannot mix union and union all!");
			i = 1;
		}
		List<Statement> listOfQueries = new ArrayList<>();
		do {
			Assertions.isTrue(statements[i] instanceof SingleQuery || statements[i] instanceof ClausesBasedStatement,
				"Can only union single queries!");
			listOfQueries.add(statements[i]);
		} while (++i < statements.length);
		if (existingUnionQuery == null) {
			return UnionQueryImpl.create(unionAll, listOfQueries);
		} else {
			return existingUnionQuery.addAdditionalQueries(listOfQueries);
		}
	}
	@SuppressWarnings("deprecation")
	public static String format(Expression expression) {
		return Expressions.format(expression);
	}
	public static UseStatement use(String target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	public static UseStatement use(Parameter<?> target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	public static UseStatement use(StringLiteral target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	public static UseStatement use(Expression target, Statement statement) {
		return DecoratedQuery.decorate(statement, UseClauseImpl.of(target));
	}
	@SuppressWarnings("deprecation")
	public static Condition includesAll(Expression lhs, Expression rhs) {
		return Conditions.includesAll(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition includesAny(Expression lhs, Expression rhs) {
		return Conditions.includesAny(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition matching(RelationshipPattern relationshipPattern) {
		return Conditions.matching(relationshipPattern);
	}
	@SuppressWarnings("deprecation")
	public static Condition matches(Expression lhs, Expression rhs) {
		return Conditions.matches(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition isEqualTo(Expression lhs, Expression rhs) {
		return Conditions.isEqualTo(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition isNotEqualTo(Expression lhs, Expression rhs) {
		return Conditions.isNotEqualTo(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition lt(Expression lhs, Expression rhs) {
		return Conditions.lt(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition lte(Expression lhs, Expression rhs) {
		return Conditions.lte(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition gte(Expression lhs, Expression rhs) {
		return Conditions.gte(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition gt(Expression lhs, Expression rhs) {
		return Conditions.gt(lhs, rhs);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition not(@NotNull Condition condition) {
		return Conditions.not(condition);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition not(@NotNull RelationshipPattern pattern) {
		return Conditions.not(pattern);
	}
	@SuppressWarnings("deprecation")
	public static Condition startsWith(Expression lhs, Expression rhs) {
		return Conditions.startsWith(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition contains(Expression lhs, Expression rhs) {
		return Conditions.contains(lhs, rhs);
	}
	@SuppressWarnings("deprecation")
	public static Condition endsWith(Expression lhs, Expression rhs) {
		return Conditions.endsWith(lhs, rhs);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition noCondition() {
		return Conditions.noCondition();
	}
	@SuppressWarnings("deprecation")
	public static Condition isNull(Expression expression) {
		return Conditions.isNull(expression);
	}
	@SuppressWarnings("deprecation")
	public static Condition isNotNull(Expression expression) {
		return Conditions.isNotNull(expression);
	}
	@SuppressWarnings("deprecation")
	public static Condition isEmpty(Expression expression) {
		return Predicates.isEmpty(expression);
	}
	@SuppressWarnings("deprecation")
	public static Condition isTrue() {
		return Conditions.isTrue();
	}
	@SuppressWarnings("deprecation")
	public static Condition isFalse() {
		return Conditions.isFalse();
	}
	@SuppressWarnings("deprecation")
	public static Condition hasLabelsOrType(SymbolicName symbolicName, String... labelsOrTypes) {
		return Conditions.hasLabelsOrType(symbolicName, labelsOrTypes);
	}
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(PatternElement requiredPattern, PatternElement... patternElement) {
		return Expressions.count(requiredPattern, patternElement);
	}
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(UnionQuery union) {
		return Expressions.count(union);
	}
	@NotNull
	@SuppressWarnings("deprecation")
	public static CountExpression count(Statement statement, IdentifiableElement... imports) {
		return Expressions.count(statement, imports);
	}
	@SuppressWarnings("deprecation")
	public static CountExpression count(List<PatternElement> pattern, @Nullable Where where) {
		return Expressions.count(pattern, where);
	}
	@SuppressWarnings("deprecation")
	@NotNull public static Expression collect(Statement statement) {
		return Expressions.collect(statement);
	}
	@SuppressWarnings("deprecation")
	public static <T extends Expression> Expression nameOrExpression(T expression) {
		return Expressions.nameOrExpression(expression);
	}
	@SuppressWarnings("deprecation")
	public static SymbolicName[] createSymbolicNames(String[] variables) {
		return Expressions.createSymbolicNames(variables);
	}
	@SuppressWarnings("deprecation")
	public static SymbolicName[] createSymbolicNames(Named[] variables) {
		return Expressions.createSymbolicNames(variables);
	}
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation elementId(
		@NotNull Node node) {
		return Functions.elementId(node);
	}
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation elementId(
		@NotNull Relationship relationship) {
		return Functions.elementId(relationship);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Node node) {
		return Functions.keys(node);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Relationship relationship) {
		return Functions.keys(relationship);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation keys(@NotNull Expression expression) {
		return Functions.keys(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation labels(@NotNull Node node) {
		return Functions.labels(node);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation labels(@NotNull SymbolicName node) {
		return Functions.labels(node);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation type(@NotNull Relationship relationship) {
		return Functions.type(relationship);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation type(@NotNull SymbolicName relationship) {
		return Functions.type(relationship);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation count(@NotNull Node node) {
		return Functions.count(node);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation count(Expression expression) {
		return Functions.count(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation countDistinct(@NotNull Node node) {
		return Functions.countDistinct(node);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation countDistinct(Expression expression) {
		return Functions.countDistinct(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(Node node) {
		return Functions.properties(node);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(Relationship relationship) {
		return Functions.properties(relationship);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation properties(MapExpression map) {
		return Functions.properties(map);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation coalesce(Expression... expressions) {
		return Functions.coalesce(expressions);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation left(Expression expression, Expression length) {
		return Functions.left(expression, length);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ltrim(@NotNull Expression expression) {
		return Functions.ltrim(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation replace(Expression original, Expression search,
		Expression replace) {
		return Functions.replace(original, search, replace);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation reverse(@NotNull Expression original) {
		return Functions.reverse(original);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation right(Expression expression, Expression length) {
		return Functions.right(expression, length);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation rtrim(@NotNull Expression expression) {
		return Functions.rtrim(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation substring(Expression original, Expression start,
		Expression length) {
		return Functions.substring(original, start, length);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toLower(@NotNull Expression expression) {
		return Functions.toLower(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toUpper(@NotNull Expression expression) {
		return Functions.toUpper(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation trim(@NotNull Expression expression) {
		return Functions.trim(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation split(@NotNull Expression expression,
		@NotNull Expression delimiter) {
		return Functions.split(expression, delimiter);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation split(@NotNull Expression expression,
		@NotNull String delimiter) {
		return Functions.split(expression, delimiter);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation size(Expression expression) {
		return Functions.size(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation size(RelationshipPattern pattern) {
		return Functions.size(pattern);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation exists(Expression expression) {
		return Functions.exists(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation distance(@NotNull Expression point1,
		@NotNull Expression point2) {
		return Functions.distance(point1, point2);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(MapExpression parameterMap) {
		return Functions.point(parameterMap);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(Expression expression) {
		return Functions.point(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation point(Parameter<?> parameter) {
		return Functions.point(parameter);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cartesian(double x, double y) {
		return Functions.cartesian(x, y);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation coordinate(double longitude, double latitude) {
		return Functions.coordinate(longitude, latitude);
	}
	@SuppressWarnings("deprecation")
	public static FunctionInvocation withinBBox(Expression point, Expression lowerLeft, Expression upperRight) {
		return Functions.withinBBox(point, lowerLeft, upperRight);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation avg(Expression expression) {
		return Functions.avg(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation avgDistinct(Expression expression) {
		return Functions.avgDistinct(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collect(@NotNull Named variable) {
		return Functions.collect(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collectDistinct(@NotNull Named variable) {
		return Functions.collectDistinct(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collect(Expression expression) {
		return Functions.collect(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation collectDistinct(Expression expression) {
		return Functions.collectDistinct(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation max(Expression expression) {
		return Functions.max(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation maxDistinct(Expression expression) {
		return Functions.maxDistinct(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation min(Expression expression) {
		return Functions.min(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation minDistinct(Expression expression) {
		return Functions.minDistinct(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileCont(Expression expression,
		Number percentile) {
		return Functions.percentileCont(expression, percentile);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileContDistinct(Expression expression,
		Number percentile) {
		return Functions.percentileContDistinct(expression, percentile);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileDisc(Expression expression,
		Number percentile) {
		return Functions.percentileDisc(expression, percentile);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation percentileDiscDistinct(Expression expression,
		Number percentile) {
		return Functions.percentileDiscDistinct(expression, percentile);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDev(Expression expression) {
		return Functions.stDev(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevDistinct(Expression expression) {
		return Functions.stDevDistinct(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevP(Expression expression) {
		return Functions.stDevP(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation stDevPDistinct(Expression expression) {
		return Functions.stDevPDistinct(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sum(Expression expression) {
		return Functions.sum(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sumDistinct(Expression expression) {
		return Functions.sumDistinct(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(Integer start, Integer end) {
		return Functions.range(start, end);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Expression start,
		@NotNull Expression end) {
		return Functions.range(start, end);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Integer start, @NotNull Integer end,
		Integer step) {
		return Functions.range(start, end, step);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation range(@NotNull Expression start,
		@NotNull Expression end, Expression step) {
		return Functions.range(start, end, step);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation head(Expression expression) {
		return Functions.head(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation last(Expression expression) {
		return Functions.last(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation nodes(@NotNull NamedPath path) {
		return Functions.nodes(path);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation nodes(@NotNull SymbolicName symbolicName) {
		return Functions.nodes(symbolicName);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation relationships(@NotNull NamedPath path) {
		return Functions.relationships(path);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation relationships(@NotNull SymbolicName symbolicName) {
		return Functions.relationships(symbolicName);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation startNode(@NotNull Relationship relationship) {
		return Functions.startNode(relationship);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation endNode(@NotNull Relationship relationship) {
		return Functions.endNode(relationship);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date() {
		return Functions.date();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation calendarDate(Integer year, Integer month,
		Integer day) {
		return Functions.calendarDate(year, month, day);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation weekDate(Integer year, Integer week,
		Integer dayOfWeek) {
		return Functions.weekDate(year, week, dayOfWeek);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation quarterDate(Integer year, Integer quarter,
		Integer dayOfQuarter) {
		return Functions.quarterDate(year, quarter, dayOfQuarter);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ordinalDate(Integer year, Integer ordinalDay) {
		return Functions.ordinalDate(year, ordinalDay);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull MapExpression components) {
		return Functions.date(components);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull String temporalValue) {
		return Functions.date(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation date(@NotNull Expression temporalValue) {
		return Functions.date(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime() {
		return Functions.datetime();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull TimeZone timeZone) {
		return Functions.datetime(timeZone);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull MapExpression components) {
		return Functions.datetime(components);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull String temporalValue) {
		return Functions.datetime(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation datetime(@NotNull Expression temporalValue) {
		return Functions.datetime(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime() {
		return Functions.localdatetime();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull TimeZone timeZone) {
		return Functions.localdatetime(timeZone);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull MapExpression components) {
		return Functions.localdatetime(components);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull String temporalValue) {
		return Functions.localdatetime(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localdatetime(@NotNull Expression temporalValue) {
		return Functions.localdatetime(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime() {
		return Functions.localtime();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull TimeZone timeZone) {
		return Functions.localtime(timeZone);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull MapExpression components) {
		return Functions.localtime(components);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull String temporalValue) {
		return Functions.localtime(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation localtime(@NotNull Expression temporalValue) {
		return Functions.localtime(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time() {
		return Functions.time();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull TimeZone timeZone) {
		return Functions.time(timeZone);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull MapExpression components) {
		return Functions.time(components);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull String temporalValue) {
		return Functions.time(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation time(@NotNull Expression temporalValue) {
		return Functions.time(temporalValue);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull MapExpression components) {
		return Functions.duration(components);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull String temporalAmount) {
		return Functions.duration(temporalAmount);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation duration(@NotNull Expression temporalAmount) {
		return Functions.duration(temporalAmount);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation shortestPath(Relationship relationship) {
		return Functions.shortestPath(relationship);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Reduction.OngoingDefinitionWithVariable reduce(
		@NotNull SymbolicName variable) {
		return Functions.reduce(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation abs(@NotNull Expression expression) {
		return Functions.abs(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation ceil(@NotNull Expression expression) {
		return Functions.ceil(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation floor(@NotNull Expression expression) {
		return Functions.floor(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation rand() {
		return Functions.rand();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation round(Expression value, Expression... expression) {
		return Functions.round(value, expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sign(@NotNull Expression expression) {
		return Functions.sign(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation e() {
		return Functions.e();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation exp(@NotNull Expression expression) {
		return Functions.exp(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation log(@NotNull Expression expression) {
		return Functions.log(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation log10(@NotNull Expression expression) {
		return Functions.log10(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sqrt(@NotNull Expression expression) {
		return Functions.sqrt(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation acos(@NotNull Expression expression) {
		return Functions.acos(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation asin(@NotNull Expression expression) {
		return Functions.asin(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation atan(@NotNull Expression expression) {
		return Functions.atan(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation atan2(@NotNull Expression y,
		@NotNull Expression x) {
		return Functions.atan2(y, x);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cos(@NotNull Expression expression) {
		return Functions.cos(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation cot(@NotNull Expression expression) {
		return Functions.cot(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation degrees(@NotNull Expression expression) {
		return Functions.degrees(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation haversin(@NotNull Expression expression) {
		return Functions.haversin(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation pi() {
		return Functions.pi();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation radians(@NotNull Expression expression) {
		return Functions.radians(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation sin(@NotNull Expression expression) {
		return Functions.sin(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation tan(@NotNull Expression expression) {
		return Functions.tan(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toInteger(@NotNull Expression expression) {
		return Functions.toInteger(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toString(@NotNull Expression expression) {
		return Functions.toString(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toStringOrNull(@NotNull Expression expression) {
		return Functions.toStringOrNull(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toFloat(@NotNull Expression expression) {
		return Functions.toFloat(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation toBoolean(@NotNull Expression expression) {
		return Functions.toBoolean(expression);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation linenumber() {
		return Functions.linenumber();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation file() {
		return Functions.file();
	}
	@SuppressWarnings("deprecation")
	public static FunctionInvocation randomUUID() {
		return Functions.randomUUID();
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation length(@NotNull NamedPath path) {
		return Functions.length(path);
	}
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphNames() {
		return Functions.graphNames();
	}
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphPropertiesByName(Expression name) {
		return Functions.graphPropertiesByName(name);
	}
	@Neo4jVersion(minimum = "5.0.0") @Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static FunctionInvocation graphByName(
		Expression name) {
		return Functions.graphByName(name);
	}
	public static MapProjection createProjection(SymbolicName name, Object... content) {
		return MapProjection.create(name, content);
	}
	@SuppressWarnings("deprecation")
	public static Operation minus(Expression e) {
		return Operations.minus(e);
	}
	@SuppressWarnings("deprecation")
	public static Expression plus(Expression e) {
		return Operations.plus(e);
	}
	@SuppressWarnings("deprecation")
	public static Operation concat(Expression op1, Expression op2) {
		return Operations.concat(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation add(Expression op1, Expression op2) {
		return Operations.add(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation subtract(Expression op1, Expression op2) {
		return Operations.subtract(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation multiply(Expression op1, Expression op2) {
		return Operations.multiply(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation divide(Expression op1, Expression op2) {
		return Operations.divide(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation remainder(Expression op1, Expression op2) {
		return Operations.remainder(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation pow(Expression op1, Expression op2) {
		return Operations.pow(op1, op2);
	}
	@SuppressWarnings("deprecation")
	public static Operation set(Expression target, Expression value) {
		return Operations.set(target, value);
	}
	@SuppressWarnings("deprecation")
	public static Operation mutate(Expression target, MapExpression value) {
		return Operations.mutate(target, value);
	}
	public static Operation mutate(Expression target, Expression value) {
		return Operations.mutate(target, value);
	}
	public static Operation setLabel(Node target, String... label) {
		return Operations.set(target, label);
	}
	@SuppressWarnings("deprecation")
	public static Operation removeLabel(Node target, String... label) {
		return Operations.remove(target, label);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition exists(Property property) {
		return Predicates.exists(property);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static Condition exists(RelationshipPattern pattern) {
		return Predicates.exists(pattern);
	}
	@SuppressWarnings("deprecation")
	public static Condition exists(Statement statement, IdentifiableElement... imports) {
		return Predicates.exists(statement, imports);
	}
	@SuppressWarnings("deprecation")
	public static Condition exists(PatternElement pattern) {
		return Predicates.exists(pattern);
	}
	@SuppressWarnings("deprecation")
	public static Condition exists(List<PatternElement> pattern) {
		return Predicates.exists(pattern);
	}
	@SuppressWarnings("deprecation")
	public static Condition exists(List<PatternElement> pattern, @Nullable Where where) {
		return Predicates.exists(pattern, where);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction all(String variable) {
		return Predicates.all(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction all(
		SymbolicName variable) {
		return Predicates.all(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction any(String variable) {
		return Predicates.any(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction any(
		SymbolicName variable) {
		return Predicates.any(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction none(String variable) {
		return Predicates.none(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction none(
		SymbolicName variable) {
		return Predicates.none(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction single(String variable) {
		return Predicates.single(variable);
	}
	@Contract(pure = true) @NotNull
	@SuppressWarnings("deprecation")
	public static OngoingListBasedPredicateFunction single(
		SymbolicName variable) {
		return Predicates.single(variable);
	}
	private Cypher() {
	}
}
package org.neo4j.cypherdsl.core.ast;
@FunctionalInterface
public interface Visitor {
	void enter(Visitable segment);
	default EnterResult enterWithResult(Visitable segment) {
		enter(segment);
		return EnterResult.CONTINUE;
	}
	default void leave(Visitable segment) {
	}
}
package org.neo4j.cypherdsl.core;
import java.util.TimeZone;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Aggregates;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Lists;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Predicates;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Scalars;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Spatials;
import org.neo4j.cypherdsl.core.BuiltInFunctions.Strings;
import org.neo4j.cypherdsl.core.utils.Assertions;
final class Functions {
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2023.3.0")
	@SuppressWarnings({ "squid:S1133" }) 
	static FunctionInvocation id(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.ID, node.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	@Deprecated(since = "2023.3.0")
	@SuppressWarnings({ "squid:S1133" }) 
	static FunctionInvocation id(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.ID, relationship.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation elementId(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.ELEMENT_ID, node.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation elementId(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.ELEMENT_ID, relationship.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return keys(node.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return keys(relationship.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation keys(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Expression param = expression instanceof Named named ? named.getRequiredSymbolicName() : expression;
		return FunctionInvocation.create(Lists.KEYS, param);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation labels(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return labels(node.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation labels(@NotNull SymbolicName node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Lists.LABELS, node);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation type(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return type(relationship.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation type(@NotNull SymbolicName relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.TYPE, relationship);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation count(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Aggregates.COUNT, node.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation count(Expression expression) {
		return FunctionInvocation.create(Aggregates.COUNT, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation countDistinct(@NotNull Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.createDistinct(Aggregates.COUNT, node.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation countDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.COUNT, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(Node node) {
		Assertions.notNull(node, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NODE_REQUIRED));
		return FunctionInvocation.create(Scalars.PROPERTIES, node.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(Relationship relationship) {
		Assertions.notNull(relationship, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_RELATIONSHIP_REQUIRED));
		return FunctionInvocation.create(Scalars.PROPERTIES, relationship.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation properties(MapExpression map) {
		return FunctionInvocation.create(Scalars.PROPERTIES, map);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation coalesce(Expression... expressions) {
		return FunctionInvocation.create(Scalars.COALESCE, expressions);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation left(Expression expression, Expression length) {
		if (expression != null && length == null) {
			throw new IllegalArgumentException("length might not be null when the expression is not null");
		}
		return FunctionInvocation.create(Strings.LEFT,
			expressionOrNullLit(expression),
			expressionOrNullLit(length)
		);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation ltrim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.LTRIM, expressionOrNullLit(expression));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation replace(Expression original, Expression search, Expression replace) {
		return FunctionInvocation.create(Strings.REPLACE, expressionOrNullLit(original), expressionOrNullLit(search),
			expressionOrNullLit(replace));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation reverse(@NotNull Expression original) {
		Assertions.notNull(original, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.REVERSE, expressionOrNullLit(original));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation right(Expression expression, Expression length) {
		if (expression != null && length == null) {
			throw new IllegalArgumentException("length might not be null when the expression is not null");
		}
		return FunctionInvocation.create(Strings.RIGHT,
			expressionOrNullLit(expression),
			expressionOrNullLit(length)
		);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation rtrim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.RTRIM, expressionOrNullLit(expression));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation substring(Expression original, Expression start, Expression length) {
		Assertions.notNull(start, "start is required");
		if (length != null) {
			return FunctionInvocation.create(Strings.SUBSTRING, expressionOrNullLit(original), start, length);
		}
		return FunctionInvocation.create(Strings.SUBSTRING, expressionOrNullLit(original), start);
	}
	private static Expression expressionOrNullLit(Expression expression) {
		return expression == null ? Cypher.literalNull() : expression;
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation toLower(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_LOWER, expressionOrNullLit(expression));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation toUpper(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_UPPER, expressionOrNullLit(expression));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation trim(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TRIM, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation split(@NotNull Expression expression, @NotNull Expression delimiter) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Assertions.notNull(delimiter, "The delimiter is required.");
		return FunctionInvocation.create(Strings.SPLIT, expression, delimiter);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation split(@NotNull Expression expression, @NotNull String delimiter) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		Assertions.notNull(delimiter, "The delimiter is required.");
		return split(expression, Cypher.literalOf(delimiter));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation size(Expression expression) {
		return FunctionInvocation.create(Scalars.SIZE, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation size(RelationshipPattern pattern) {
		return FunctionInvocation.create(Scalars.SIZE, pattern);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation exists(Expression expression) {
		return FunctionInvocation.create(Predicates.EXISTS, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation distance(@NotNull Expression point1, @NotNull Expression point2) {
		Assertions.notNull(point1, "The distance function requires two points.");
		Assertions.notNull(point2, "The distance function requires two points.");
		return FunctionInvocation.create(Spatials.DISTANCE, point1, point2);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(MapExpression parameterMap) {
		return point((Expression) parameterMap);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(Expression expression) {
		return FunctionInvocation.create(Spatials.POINT, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation point(Parameter<?> parameter) {
		return FunctionInvocation.create(Spatials.POINT, parameter);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation cartesian(double x, double y) {
		return point(Cypher.mapOf("x", Cypher.literalOf(x), "y", Cypher.literalOf(y)));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation coordinate(double longitude, double latitude) {
		return point(Cypher.mapOf("longitude", Cypher.literalOf(longitude), "latitude", Cypher.literalOf(latitude)));
	}
	static FunctionInvocation withinBBox(Expression point, Expression lowerLeft, Expression upperRight) {
		return FunctionInvocation.create(() -> "point.withinBBox", point, lowerLeft, upperRight);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation avg(Expression expression) {
		return FunctionInvocation.create(Aggregates.AVG, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation avgDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.AVG, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation collect(@NotNull Named variable) {
		Assertions.notNull(variable, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_VARIABLE_REQUIRED));
		return FunctionInvocation.create(Aggregates.COLLECT, variable.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation collectDistinct(@NotNull Named variable) {
		Assertions.notNull(variable, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_VARIABLE_REQUIRED));
		return FunctionInvocation.createDistinct(Aggregates.COLLECT, variable.getRequiredSymbolicName());
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation collect(Expression expression) {
		return FunctionInvocation.create(Aggregates.COLLECT, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation collectDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.COLLECT, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation max(Expression expression) {
		return FunctionInvocation.create(Aggregates.MAX, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation maxDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.MAX, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation min(Expression expression) {
		return FunctionInvocation.create(Aggregates.MIN, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation minDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.MIN, expression);
	}
	private static void assertPercentileArguments(Aggregates builtIn, Expression expression, Number percentile) {
		Assertions
			.notNull(expression, "The numeric expression for " + builtIn.getImplementationName() + " is required.");
		Assertions.notNull(percentile, "The percentile for " + builtIn.getImplementationName() + " is required.");
		final double p = percentile.doubleValue();
		Assertions.isTrue(p >= 0D && p <= 1D,
			"The percentile for " + builtIn.getImplementationName() + " must be between 0.0 and 1.0.");
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileCont(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_CONT, expression, percentile);
		return FunctionInvocation.create(Aggregates.PERCENTILE_CONT, expression, new NumberLiteral(percentile));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileContDistinct(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_CONT, expression, percentile);
		return FunctionInvocation.createDistinct(Aggregates.PERCENTILE_CONT, expression, new NumberLiteral(percentile));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileDisc(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_DISC, expression, percentile);
		return FunctionInvocation.create(Aggregates.PERCENTILE_DISC, expression, new NumberLiteral(percentile));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation percentileDiscDistinct(Expression expression, Number percentile) {
		assertPercentileArguments(Aggregates.PERCENTILE_DISC, expression, percentile);
		return FunctionInvocation.createDistinct(Aggregates.PERCENTILE_DISC, expression, new NumberLiteral(percentile));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDev(Expression expression) {
		return FunctionInvocation.create(Aggregates.ST_DEV, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.ST_DEV, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevP(Expression expression) {
		return FunctionInvocation.create(Aggregates.ST_DEV_P, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation stDevPDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.ST_DEV_P, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation sum(Expression expression) {
		return FunctionInvocation.create(Aggregates.SUM, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation sumDistinct(Expression expression) {
		return FunctionInvocation.createDistinct(Aggregates.SUM, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(Integer start, Integer end) {
		return range(Cypher.literalOf(start), Cypher.literalOf(end));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Expression start, @NotNull Expression end) {
		return range(start, end, null);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Integer start, @NotNull Integer end, Integer step) {
		return range(Cypher.literalOf(start), Cypher.literalOf(end), Cypher.literalOf(step));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation range(@NotNull Expression start, @NotNull Expression end, Expression step) {
		Assertions.notNull(start, "The expression for range is required.");
		Assertions.notNull(end, "The expression for range is required.");
		if (step == null) {
			return FunctionInvocation.create(Lists.RANGE, start, end);
		} else {
			return FunctionInvocation.create(Lists.RANGE, start, end, step);
		}
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation head(Expression expression) {
		return FunctionInvocation.create(Scalars.HEAD, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation last(Expression expression) {
		return FunctionInvocation.create(Scalars.LAST, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation nodes(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for nodes is required.");
		return FunctionInvocation.create(Lists.NODES,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation nodes(@NotNull SymbolicName symbolicName) {
		Assertions.notNull(symbolicName, "The symbolic name of the path for nodes is required.");
		return FunctionInvocation.create(Lists.NODES, symbolicName);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation relationships(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for relationships is required.");
		return FunctionInvocation.create(Lists.RELATIONSHIPS,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation relationships(@NotNull SymbolicName symbolicName) {
		Assertions.notNull(symbolicName, "The symbolic name of the path for relationships is required.");
		return FunctionInvocation.create(Lists.RELATIONSHIPS, symbolicName);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation startNode(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, "The relationship for endNode is required.");
		return FunctionInvocation.create(Scalars.START_NODE,
			relationship.getSymbolicName()
				.orElseThrow(() -> new IllegalArgumentException("The relationship needs to be named!")));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation endNode(@NotNull Relationship relationship) {
		Assertions.notNull(relationship, "The relationship for endNode is required.");
		return FunctionInvocation.create(Scalars.END_NODE,
			relationship.getSymbolicName()
				.orElseThrow(() -> new IllegalArgumentException("The relationship needs to be named!")));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation date() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation calendarDate(Integer year, Integer month, Integer day) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Assertions.notNull(month, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_MONTH_REQUIRED));
		Assertions.notNull(day, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_DAY_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher
			.mapOf("year", Cypher.literalOf(year), "month", Cypher.literalOf(month), "day", Cypher.literalOf(day)));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation weekDate(Integer year, Integer week, Integer dayOfWeek) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (week == null ? 0 : 2) + (dayOfWeek == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (week != null) {
			parameters[i++] = "week";
			parameters[i++] = Cypher.literalOf(week);
		}
		if (dayOfWeek != null) {
			if (week == null) {
				throw new IllegalArgumentException("week is required when using dayOfWeek.");
			}
			parameters[i++] = "dayOfWeek";
			parameters[i] = Cypher.literalOf(dayOfWeek);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation quarterDate(Integer year, Integer quarter, Integer dayOfQuarter) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (quarter == null ? 0 : 2) + (dayOfQuarter == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (quarter != null) {
			parameters[i++] = "quarter";
			parameters[i++] = Cypher.literalOf(quarter);
		}
		if (dayOfQuarter != null) {
			parameters[i++] = "dayOfQuarter";
			parameters[i] = Cypher.literalOf(dayOfQuarter);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation ordinalDate(Integer year, Integer ordinalDay) {
		Assertions.notNull(year, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_YEAR_REQUIRED));
		Object[] parameters = new Object[2 + (ordinalDay == null ? 0 : 2)];
		int i = 0;
		parameters[i++] = "year";
		parameters[i++] = Cypher.literalOf(year);
		if (ordinalDay != null) {
			parameters[i++] = "ordinalDay";
			parameters[i] = Cypher.literalOf(ordinalDay);
		}
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.mapOf(parameters));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, components);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, Cypher.literalOf(temporalValue));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation date(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATE, temporalValue);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.DATETIME, timezoneMapLiteralOf(timeZone));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, components);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, Cypher.literalOf(temporalValue));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation datetime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DATETIME, temporalValue);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.LOCALDATETIME, timezoneMapLiteralOf(timeZone));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, components);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, Cypher.literalOf(temporalValue));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localdatetime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALDATETIME, temporalValue);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.LOCALTIME, timezoneMapLiteralOf(timeZone));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, components);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, Cypher.literalOf(temporalValue));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation localtime(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.LOCALTIME, temporalValue);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation time() {
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull TimeZone timeZone) {
		Assertions.notNull(timeZone, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TZ_REQUIRED));
		return FunctionInvocation
			.create(BuiltInFunctions.Temporals.TIME, timezoneMapLiteralOf(timeZone));
	}
	private static Expression timezoneMapLiteralOf(TimeZone timeZone) {
		return Cypher.mapOf("timezone", Cypher.literalOf(timeZone.getID()));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, components);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull String temporalValue) {
		Assertions.hasText(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, Cypher.literalOf(temporalValue));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation time(@NotNull Expression temporalValue) {
		Assertions.notNull(temporalValue, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_TEMPORAL_VALUE_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.TIME, temporalValue);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull MapExpression components) {
		Assertions.notNull(components, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_COMPONENTS_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, components);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull String temporalAmount) {
		Assertions.hasText(temporalAmount, "The temporalAmount is required.");
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, Cypher.literalOf(temporalAmount));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation duration(@NotNull Expression temporalAmount) {
		Assertions.notNull(temporalAmount, "The temporalAmount is required.");
		return FunctionInvocation.create(BuiltInFunctions.Temporals.DURATION, temporalAmount);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation shortestPath(Relationship relationship) {
		return FunctionInvocation.create(Scalars.SHORTEST_PATH, relationship);
	}
	@NotNull @Contract(pure = true)
	static Reduction.OngoingDefinitionWithVariable reduce(@NotNull SymbolicName variable) {
		return Reduction.of(variable);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation abs(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ABS, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation ceil(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.CEIL, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation floor(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.FLOOR, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation rand() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.RAND);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation round(Expression value, Expression... expression) {
		if (expression == null || expression.length == 0) {
			return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ROUND, value);
		} else if (expression.length == 1) {
			return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ROUND, value, expression[0]);
		} else if (expression.length == 2) {
			return FunctionInvocation
				.create(BuiltInFunctions.MathematicalFunctions.ROUND, value, expression[0], expression[1]);
		} else {
			throw new IllegalArgumentException(
				"round() must be called with 1, 2 or 3 arguments (value, value + precision or value + precision + rounding mode.");
		}
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation sign(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SIGN, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation e() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.E);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation exp(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.EXP, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation log(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.LOG, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation log10(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.LOG10, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation sqrt(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SQRT, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation acos(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ACOS, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation asin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ASIN, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation atan(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ATAN, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation atan2(@NotNull Expression y, @NotNull Expression x) {
		Assertions.notNull(y, "y is required.");
		Assertions.notNull(x, "x is required.");
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.ATAN2, y, x);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation cos(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.COS, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation cot(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.COT, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation degrees(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.DEGREES, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation haversin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.HAVERSIN, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation pi() {
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.PI);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation radians(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.RADIANS, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation sin(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.SIN, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation tan(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(BuiltInFunctions.MathematicalFunctions.TAN, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation toInteger(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_INTEGER, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation toString(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_STRING, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation toStringOrNull(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Strings.TO_STRING_OR_NULL, expressionOrNullLit(expression));
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation toFloat(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_FLOAT, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation toBoolean(@NotNull Expression expression) {
		Assertions.notNull(expression, Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_EXPRESSION_REQUIRED));
		return FunctionInvocation.create(Scalars.TO_BOOLEAN, expression);
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation linenumber() {
		return FunctionInvocation.create(() -> "linenumber");
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation file() {
		return FunctionInvocation.create(() -> "file");
	}
	static FunctionInvocation randomUUID() {
		return FunctionInvocation.create(() -> "randomUUID");
	}
	@NotNull @Contract(pure = true)
	static FunctionInvocation length(@NotNull NamedPath path) {
		Assertions.notNull(path, "The path for length is required.");
		return FunctionInvocation.create(Scalars.LENGTH,
			path.getSymbolicName().orElseThrow(() -> new IllegalArgumentException(
				Cypher.MESSAGES.getString(MessageKeys.ASSERTIONS_NAMED_PATH_REQUIRED))));
	}
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphNames() {
		return FunctionInvocation.create(BuiltInFunctions.Graph.NAMES);
	}
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphPropertiesByName(Expression name) {
		return FunctionInvocation.create(BuiltInFunctions.Graph.PROPERTIES_BY_NAME, name);
	}
	@NotNull
	@Contract(pure = true)
	@Neo4jVersion(minimum = "5.0.0")
	static FunctionInvocation graphByName(Expression name) {
		return FunctionInvocation.create(BuiltInFunctions.Graph.BY_NAME, name);
	}
	private Functions() {
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.List;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
@API(status = STABLE, since = "1.1")
public interface PropertyContainer extends Named, PropertyAccessor {
	@NotNull @Contract(pure = true)
	Operation mutate(Parameter<?> parameter);
	@NotNull @Contract(pure = true)
	Operation mutate(MapExpression properties);
	@NotNull @Contract(pure = true)
	Operation set(Parameter<?> parameter);
	@NotNull @Contract(pure = true)
	Operation set(MapExpression properties);
	@NotNull @Contract(pure = true)
	MapProjection project(List<Object> entries);
	@NotNull @Contract(pure = true)
	MapProjection project(Object... entries);
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;
@API(status = STABLE, since = "1.0")
public interface ExposesRelationships<T extends RelationshipPattern & ExposesPatternLengthAccessors<?>> {
	@NotNull @Contract(pure = true)
	T relationshipTo(Node other, String... types);
	@NotNull @Contract(pure = true)
	T relationshipFrom(Node other, String... types);
	@NotNull @Contract(pure = true)
	T relationshipBetween(Node other, String... types);
	default T relationshipWith(Node other, Relationship.Direction direction, String... types) {
		return switch (direction) {
			case LTR -> this.relationshipTo(other, types);
			case RTL -> this.relationshipFrom(other, types);
			case UNI -> this.relationshipBetween(other, types);
		};
	}
}
package org.neo4j.cypherdsl.parser;
import org.neo4j.cypherdsl.core.ExposesPatternLengthAccessors;
import org.neo4j.cypherdsl.core.ExposesProperties;
import org.neo4j.cypherdsl.core.ExposesRelationships;
import org.neo4j.cypherdsl.core.Expression;
import org.neo4j.cypherdsl.core.MapExpression;
import org.neo4j.cypherdsl.core.Node;
import org.neo4j.cypherdsl.core.QuantifiedPathPattern;
import org.neo4j.cypherdsl.core.Relationship;
import org.neo4j.cypherdsl.core.Relationship.Direction;
import org.neo4j.cypherdsl.core.RelationshipChain;
import org.neo4j.cypherdsl.core.SymbolicName;
final class PathAtom implements PatternAtom {
	@SuppressWarnings("squid:S107") 
	static PathAtom of(SymbolicName name, PathLength length, boolean left, boolean right,
		String[] relTypes, MapExpression properties, boolean negatedType, Expression predicate) {
		if (left && right) {
			throw new IllegalArgumentException("Only left-to-right, right-to-left or unidirectional path elements are supported.");
		}
		Direction direction;
		if (left) {
			direction = Direction.RTL;
		} else if (right) {
			direction = Direction.LTR;
		} else {
			direction = Direction.UNI;
		}
		return new PathAtom(name, length, direction, negatedType, relTypes, properties, predicate, null);
	}
	private final SymbolicName name;
	private final PathLength length;
	private final Direction direction;
	private final boolean negatedType;
	private final String[] types;
	private final MapExpression properties;
	private final Expression predicate;
	private final QuantifiedPathPattern.Quantifier quantifier;
	private PathAtom(SymbolicName name, PathLength length, Direction direction, boolean negatedType, String[] types,
		MapExpression properties, Expression predicate, QuantifiedPathPattern.Quantifier quantifier) {
		this.name = name;
		this.length = length;
		this.direction = direction;
		this.negatedType = negatedType;
		this.types = types;
		this.properties = properties;
		this.predicate = predicate;
		this.quantifier = quantifier;
	}
	ExposesRelationships<?> asRelationshipBetween(ExposesRelationships<?> previous, NodeAtom nodeAtom, boolean alwaysLtr) {
		var node = nodeAtom.value();
		ExposesRelationships<?> relationshipPattern = switch (this.getDirection()) {
			case LTR -> previous.relationshipTo(node, this.getTypes());
			case RTL -> alwaysLtr ?
				node.relationshipTo((Node) previous, this.getTypes()) :
				previous.relationshipFrom(node, this.getTypes());
			case UNI -> previous.relationshipBetween(node, this.getTypes());
		};
		relationshipPattern = applyOptionalName(relationshipPattern);
		relationshipPattern = applyOptionalProperties(relationshipPattern);
		relationshipPattern = applyOptionalPredicate(relationshipPattern);
		relationshipPattern = applyOptionalLength(relationshipPattern);
		return applyOptionalQuantifier(relationshipPattern);
	}
	private ExposesRelationships<?> applyOptionalLength(ExposesRelationships<?> relationshipPattern) {
		if (length == null) {
			return relationshipPattern;
		}
		if (length.isUnbounded()) {
			return ((ExposesPatternLengthAccessors<?>) relationshipPattern).unbounded();
		}
		return ((ExposesPatternLengthAccessors<?>) relationshipPattern).length(length.getMinimum(), length.getMaximum());
	}
	private ExposesRelationships<?> applyOptionalProperties(ExposesRelationships<?> relationshipPattern) {
		if (properties == null) {
			return relationshipPattern;
		}
		if (relationshipPattern instanceof ExposesProperties<?> exposesProperties) {
			return (ExposesRelationships<?>) exposesProperties.withProperties(properties);
		}
		return ((RelationshipChain) relationshipPattern).properties(properties);
	}
	private ExposesRelationships<?> applyOptionalName(ExposesRelationships<?> relationshipPattern) {
		if (name == null) {
			return relationshipPattern;
		}
		if (relationshipPattern instanceof Relationship relationship) {
			return relationship.named(name);
		}
		return ((RelationshipChain) relationshipPattern).named(name);
	}
	private ExposesRelationships<?> applyOptionalPredicate(ExposesRelationships<?> relationshipPattern) {
		if (predicate == null) {
			return relationshipPattern;
		}
		if (relationshipPattern instanceof Relationship relationship) {
			return (ExposesRelationships<?>) relationship.where(predicate);
		}
		return ((RelationshipChain) relationshipPattern).where(predicate);
	}
	private ExposesRelationships<?> applyOptionalQuantifier(ExposesRelationships<?> relationshipPattern) {
		if (quantifier == null) {
			return relationshipPattern;
		}
		if (relationshipPattern instanceof Relationship relationship) {
			return (ExposesRelationships<?>) relationship.quantifyRelationship(quantifier);
		}
		return ((RelationshipChain) relationshipPattern).quantifyRelationship(quantifier);
	}
	public Direction getDirection() {
		return direction;
	}
	public String[] getTypes() {
		return types;
	}
	public MapExpression getProperties() {
		return this.properties;
	}
	public SymbolicName getName() {
		return name;
	}
	public PathAtom withQuantifier(QuantifiedPathPattern.Quantifier newQuantifier) {
		return newQuantifier == null ?
			this :
			new PathAtom(name, length, direction, negatedType, types, properties, predicate, newQuantifier);
	}
}
package org.neo4j.cypherdsl.core.renderer;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.EnumSet;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.cypherdsl.core.AliasedExpression;
import org.neo4j.cypherdsl.core.Case;
import org.neo4j.cypherdsl.core.CollectExpression;
import org.neo4j.cypherdsl.core.Condition;
import org.neo4j.cypherdsl.core.CountExpression;
import org.neo4j.cypherdsl.core.Create;
import org.neo4j.cypherdsl.core.Delete;
import org.neo4j.cypherdsl.core.ExistentialSubquery;
import org.neo4j.cypherdsl.core.Foreach;
import org.neo4j.cypherdsl.core.FunctionInvocation;
import org.neo4j.cypherdsl.core.Hint;
import org.neo4j.cypherdsl.core.InTransactions;
import org.neo4j.cypherdsl.core.KeyValueMapEntry;
import org.neo4j.cypherdsl.core.LabelExpression;
import org.neo4j.cypherdsl.core.Limit;
import org.neo4j.cypherdsl.core.ListComprehension;
import org.neo4j.cypherdsl.core.ListExpression;
import org.neo4j.cypherdsl.core.Literal;
import org.neo4j.cypherdsl.core.MapExpression;
import org.neo4j.cypherdsl.core.Match;
import org.neo4j.cypherdsl.core.Merge;
import org.neo4j.cypherdsl.core.MergeAction;
import org.neo4j.cypherdsl.core.Named;
import org.neo4j.cypherdsl.core.NestedExpression;
import org.neo4j.cypherdsl.core.Node;
import org.neo4j.cypherdsl.core.NodeLabel;
import org.neo4j.cypherdsl.core.Operation;
import org.neo4j.cypherdsl.core.Operator;
import org.neo4j.cypherdsl.core.Order;
import org.neo4j.cypherdsl.core.Parameter;
import org.neo4j.cypherdsl.core.PatternExpression;
import org.neo4j.cypherdsl.core.QuantifiedPathPattern;
import org.neo4j.cypherdsl.core.PatternComprehension;
import org.neo4j.cypherdsl.core.ProcedureCall;
import org.neo4j.cypherdsl.core.Properties;
import org.neo4j.cypherdsl.core.PropertyLookup;
import org.neo4j.cypherdsl.core.Relationship;
import org.neo4j.cypherdsl.core.Remove;
import org.neo4j.cypherdsl.core.Return;
import org.neo4j.cypherdsl.core.Set;
import org.neo4j.cypherdsl.core.Skip;
import org.neo4j.cypherdsl.core.SortItem;
import org.neo4j.cypherdsl.core.Subquery;
import org.neo4j.cypherdsl.core.SubqueryExpression;
import org.neo4j.cypherdsl.core.SymbolicName;
import org.neo4j.cypherdsl.core.UnionPart;
import org.neo4j.cypherdsl.core.Unwind;
import org.neo4j.cypherdsl.core.Use;
import org.neo4j.cypherdsl.core.Where;
import org.neo4j.cypherdsl.core.With;
import org.neo4j.cypherdsl.core.internal.NameResolvingStrategy;
import org.neo4j.cypherdsl.core.internal.SchemaNamesBridge;
import org.neo4j.cypherdsl.core.ast.ProvidesAffixes;
import org.neo4j.cypherdsl.core.ast.TypedSubtree;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.CaseElse;
import org.neo4j.cypherdsl.core.internal.CaseWhenThen;
import org.neo4j.cypherdsl.core.internal.ConstantParameterHolder;
import org.neo4j.cypherdsl.core.internal.Distinct;
import org.neo4j.cypherdsl.core.internal.LoadCSV;
import org.neo4j.cypherdsl.core.internal.Namespace;
import org.neo4j.cypherdsl.core.internal.ProcedureName;
import org.neo4j.cypherdsl.core.internal.ReflectiveVisitor;
import org.neo4j.cypherdsl.core.internal.RelationshipLength;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.internal.RelationshipTypes;
import org.neo4j.cypherdsl.core.internal.ScopingStrategy;
import org.neo4j.cypherdsl.core.StatementContext;
import org.neo4j.cypherdsl.core.internal.UsingPeriodicCommit;
import org.neo4j.cypherdsl.core.internal.YieldItems;
@SuppressWarnings({ "unused", "squid:S1172" })
@RegisterForReflection
class DefaultVisitor extends ReflectiveVisitor implements RenderingVisitor {
	private static final EnumSet<Operator> SKIP_SPACES = EnumSet.of(Operator.EXPONENTIATION, Operator.UNARY_MINUS,
		Operator.UNARY_PLUS);
	protected final StringBuilder builder = new StringBuilder();
	record SeparatorAndSupplier(AtomicReference<String> seperator, Supplier<String> supplier) {
	}
	private final Map<Integer, SeparatorAndSupplier> separatorOnLevel = new ConcurrentHashMap<>();
	private final ScopingStrategy scopingStrategy;
	protected final java.util.Set<AliasedExpression> visitableToAliased = new HashSet<>();
	private final Deque<AliasedExpression> currentAliasedElements = new ArrayDeque<>();
	private final Map<Class<? extends Visitor>, Visitor> delegateCache = new ConcurrentHashMap<>();
	private final NameResolvingStrategy nameResolvingStrategy;
	private final boolean enforceSchema;
	private final Map<String, List<Configuration.RelationshipDefinition>> relationshipDefinitions;
	private int currentLevel = 0;
	private boolean skipNodeContent = false;
	private boolean skipRelationshipContent = false;
	private boolean inRelationshipCondition = false;
	private final Deque<Boolean> inPatternExpression = new ArrayDeque<>();
	private final boolean renderConstantsAsParameters;
	private final boolean alwaysEscapeNames;
	private final Dialect dialect;
	private boolean inEntity;
	private boolean inPropertyLookup;
	private Relationship.Direction directionOverride;
	DefaultVisitor(StatementContext statementContext) {
		this(statementContext, false);
	}
	DefaultVisitor(StatementContext statementContext, boolean renderConstantsAsParameters) {
		this(statementContext, renderConstantsAsParameters, Configuration.newConfig().alwaysEscapeNames(true).build());
	}
	DefaultVisitor(StatementContext statementContext, boolean renderConstantsAsParameters,
		Configuration configuration) {
		this.nameResolvingStrategy = configuration.isUseGeneratedNames() ?
			NameResolvingStrategy.useGeneratedNames(statementContext, configuration.getGeneratedNames()) :
			NameResolvingStrategy.useGivenNames(statementContext);
		this.scopingStrategy = ScopingStrategy.create(
			List.of(nameResolvingStrategy::enterScope),
			List.of(nameResolvingStrategy::leaveScope)
		);
		this.renderConstantsAsParameters = renderConstantsAsParameters;
		this.alwaysEscapeNames = configuration.isAlwaysEscapeNames();
		this.dialect = configuration.getDialect();
		this.enforceSchema = configuration.isEnforceSchema();
		this.relationshipDefinitions = configuration.getRelationshipDefinitions();
	}
	private void enableSeparator(int level, boolean on, Supplier<String> supplier) {
		if (on) {
			separatorOnLevel.put(level,
				new SeparatorAndSupplier(new AtomicReference<>(""), supplier == null ? () -> "" : supplier));
		} else {
			separatorOnLevel.remove(level);
		}
	}
	private Optional<SeparatorAndSupplier> separatorOnCurrentLevel() {
		return Optional.ofNullable(separatorOnLevel.get(currentLevel));
	}
	@Override
	protected boolean preEnter(Visitable visitable) {
		Visitable lastAliased = currentAliasedElements.peek();
		if (skipNodeContent || visitableToAliased.contains(lastAliased)) {
			return false;
		}
		if (visitable instanceof AliasedExpression aliasedExpression) {
			currentAliasedElements.push(aliasedExpression);
		}
		int nextLevel = ++currentLevel + 1;
		if (visitable instanceof TypedSubtree<?> ts) {
			enableSeparator(nextLevel, true, ts::separator);
		}
		separatorOnCurrentLevel().ifPresent(ref -> builder.append(ref.seperator().getAndSet("")));
		if (visitable instanceof ProvidesAffixes providesAffixes) {
			providesAffixes.getPrefix().ifPresent(this::doWithPrefix);
		}
		boolean doEnter = !skipNodeContent;
		if (doEnter) {
			scopingStrategy.doEnter(visitable);
		}
		return doEnter;
	}
	@Override
	protected final PreEnterResult getPreEnterResult(Visitable visitable) {
		boolean doEnter = preEnter(visitable);
		if (!doEnter) {
			return PreEnterResult.skip();
		}
		Class<? extends Visitor> handlerType = dialect.getHandler(visitable);
		if (handlerType != null) {
			Visitor handler = this.delegateCache.computeIfAbsent(handlerType, this::newHandler);
			return PreEnterResult.delegateTo(handler);
		}
		return PreEnterResult.doEnter();
	}
	private Visitor newHandler(Class<? extends Visitor> handlerType) {
		try {
			Constructor<? extends Visitor> ctor = handlerType.getDeclaredConstructor(DefaultVisitor.class);
			return ctor.newInstance(this);
		} catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
			throw new IllegalArgumentException(
				dialect.name() + " has defined an illegal handler not providing a constructor accepting a delegate.");
		}
	}
	@Override
	protected void postLeave(Visitable visitable) {
		scopingStrategy.doLeave(visitable);
		separatorOnCurrentLevel().ifPresent(ref -> ref.seperator().set(ref.supplier().get()));
		if (visitable instanceof ProvidesAffixes providesAffixes) {
			providesAffixes.getSuffix().ifPresent(this::doWithSuffix);
		}
		if (visitable instanceof TypedSubtree) {
			enableSeparator(currentLevel + 1, false, null);
		}
		if (currentAliasedElements.peek() == visitable) {
			currentAliasedElements.pop();
		}
		if (visitable instanceof AliasedExpression aliasedExpression) {
			visitableToAliased.add(aliasedExpression);
		}
		--currentLevel;
	}
	protected void doWithPrefix(String prefix) {
		this.builder.append(prefix);
	}
	protected void doWithSuffix(String suffix) {
		this.builder.append(suffix);
	}
	void enter(Match match) {
		if (match.isOptional()) {
			builder.append("OPTIONAL ");
		}
		builder.append("MATCH ");
	}
	void leave(Match match) {
		builder.append(" ");
	}
	void enter(Where where) {
		builder.append(" WHERE ");
	}
	void enter(Create create) {
		builder.append("CREATE ");
	}
	void leave(Create create) {
		builder.append(" ");
	}
	void enter(Merge merge) {
		builder.append("MERGE ");
	}
	void leave(Merge merge) {
		if (!merge.hasEvents()) { 
			builder.append(" ");
		}
	}
	void enter(MergeAction onCreateOrMatchEvent) {
		switch (onCreateOrMatchEvent.getType()) {
			case ON_CREATE -> builder.append("ON CREATE");
			case ON_MATCH -> builder.append("ON MATCH");
		}
		builder.append(" ");
	}
	void enter(Condition condition) {
		inRelationshipCondition = condition instanceof RelationshipPatternCondition;
	}
	void leave(Condition condition) {
		inRelationshipCondition = false;
	}
	void enter(Distinct distinct) {
		builder.append("DISTINCT ");
	}
	boolean inReturn;
	void enter(Return returning) {
		inReturn = true;
		if (!returning.isRaw()) {
			builder.append("RETURN ");
		}
	}
	void leave(Return returning) {
		inReturn = false;
	}
	void enter(With with) {
		builder.append("WITH ");
	}
	void leave(With with) {
		builder.append(" ");
	}
	void enter(Delete delete) {
		if (delete.isDetach()) {
			builder.append("DETACH ");
		}
		builder.append("DELETE ");
	}
	void leave(Delete match) {
		builder.append(" ");
	}
	boolean inLastReturn() {
		return inReturn && !inSubquery;
	}
	void enter(AliasedExpression aliased) {
		if (this.visitableToAliased.contains(aliased)) {
			builder.append(escapeIfNecessary(nameResolvingStrategy.resolve(aliased, false, inLastReturn())));
		}
	}
	void leave(AliasedExpression aliased) {
		if (!(this.visitableToAliased.contains(aliased) || scopingStrategy.isSkipAliasing())) {
			builder.append(" AS ").append(escapeIfNecessary(nameResolvingStrategy.resolve(aliased, true, inLastReturn())));
		}
	}
	void enter(NestedExpression nested) {
		builder.append("(");
	}
	void leave(NestedExpression nested) {
		builder.append(")");
	}
	void enter(Order order) {
		builder.append(" ORDER BY ");
	}
	void enter(Skip skip) {
		builder.append(" SKIP ");
	}
	void enter(Limit limit) {
		builder.append(" LIMIT ");
	}
	void enter(SortItem.Direction direction) {
		builder
			.append(" ")
			.append(direction.getSymbol());
	}
	void enter(PropertyLookup propertyLookup) {
		inPropertyLookup = true;
		if (propertyLookup.isDynamicLookup()) {
			builder.append("[");
		} else {
			builder.append(".");
		}
	}
	void leave(PropertyLookup propertyLookup) {
		inPropertyLookup = false;
		if (propertyLookup.isDynamicLookup()) {
			builder.append("]");
		}
	}
	void enter(FunctionInvocation functionInvocation) {
		String functionName = functionInvocation.getFunctionName();
		if ("elementId".equals(functionName)) {
			functionName = "toString(id";
		}
		builder
			.append(functionName)
			.append("(");
	}
	void leave(FunctionInvocation functionInvocation) {
		String functionName = functionInvocation.getFunctionName();
		if ("elementId".equals(functionName)) {
			builder.append(")");
		}
		builder.append(")");
	}
	void enter(Operation operation) {
		if (operation.needsGrouping()) {
			builder.append("(");
		}
	}
	void enter(Operator operator) {
		Operator.Type type = operator.getType();
		if (type == Operator.Type.LABEL) {
			return;
		}
		boolean skipSpaces = SKIP_SPACES.contains(operator);
		if (type != Operator.Type.PREFIX && !skipSpaces) {
			builder.append(" ");
		}
		builder.append(operator.getRepresentation());
		if (type != Operator.Type.POSTFIX && !skipSpaces) {
			builder.append(" ");
		}
	}
	void leave(Operation operation) {
		if (operation.needsGrouping()) {
			builder.append(")");
		}
	}
	void enter(Literal<?> expression) {
		builder.append(expression.asString());
	}
	void enter(Node node) {
		builder.append("(");
		skipNodeContent = scopingStrategy.hasVisitedBefore(node);
		if (skipNodeContent) {
			builder.append(nameResolvingStrategy.resolve(
				node.getSymbolicName().orElseGet(node::getRequiredSymbolicName), true, false));
		}
		inEntity = true;
	}
	void leave(Node node) {
		builder.append(")");
		skipNodeContent = false;
		inEntity = false;
	}
	void enter(NodeLabel nodeLabel) {
		escapeName(nodeLabel.getValue()).ifPresent(label -> builder.append(Symbols.NODE_LABEL_START).append(label));
	}
	void enter(LabelExpression labelExpression) {
		builder.append(":");
		renderLabelExpression(labelExpression, null);
	}
	@SuppressWarnings("squid:S3776")
	void renderLabelExpression(LabelExpression l, LabelExpression.Type parent) {
		if (l == null) {
			return;
		}
		if (l.negated()) {
			builder.append("!");
		}
		var current = l.type();
		boolean close = false;
		if (current != LabelExpression.Type.LEAF) {
			close = (parent != null || l.negated()) && l.type() != parent;
			if (close && !l.negated() && (current == LabelExpression.Type.CONJUNCTION || parent == LabelExpression.Type.DISJUNCTION)) {
				close = false;
			}
		}
		if (close) {
			builder.append("(");
		}
		renderLabelExpression(l.lhs(), current);
		if (current == LabelExpression.Type.LEAF) {
			l.value().forEach(v ->
				escapeName(v).ifPresent(builder::append)
			);
		}  else {
			builder.append(current.getValue());
		}
		renderLabelExpression(l.rhs(), current);
		if (close) {
			builder.append(")");
		}
	}
	void enter(Properties properties) {
		builder.append(" ");
	}
	void enter(SymbolicName symbolicName) {
		if (!inRelationshipCondition || nameResolvingStrategy.isResolved(symbolicName)) {
			if (Boolean.TRUE.equals(inPatternExpression.peek()) && !scopingStrategy.hasVisitedBefore(new Named() {
				@Override
				public @NotNull Optional<SymbolicName> getSymbolicName() {
					return Optional.of(symbolicName);
				}
			})) {
				return;
			}
			builder.append(nameResolvingStrategy.resolve(symbolicName, inEntity, inPropertyLookup));
		}
	}
	void enter(PatternExpression p) {
		this.inPatternExpression.push(true);
	}
	void leave(PatternExpression p) {
		this.inPatternExpression.pop();
	}
	void enter(Relationship relationship) {
		skipRelationshipContent = scopingStrategy.hasVisitedBefore(relationship);
		if (enforceSchema && relationship.getDetails().getDirection() != Relationship.Direction.UNI) {
			directionOverride = computeDirectionOverride(relationship);
		}
	}
	private java.util.Set<String> getLabels(Node node) {
		var nl = node.getLabels();
		if (nl.isEmpty()) {
			var patternElement = scopingStrategy.lookup(node);
			if (patternElement instanceof Node boundNode) {
				nl = boundNode.getLabels();
			}
		}
		return nl.stream().map(NodeLabel::getValue).collect(Collectors.toSet());
	}
	Relationship.Direction computeDirectionOverride(Relationship relationship) {
		var sourceLabels = getLabels(relationship.getLeft());
		var targetLabels = getLabels(relationship.getRight());
		var details = relationship.getDetails();
		if (sourceLabels.equals(targetLabels)) {
			return details.getDirection();
		}
		for (String type : details.getTypes()) {
			outer:
			if (relationshipDefinitions.containsKey(type)) {
				var knownRelationships = relationshipDefinitions.get(type).stream().toList();
				for (var knownRelationship : knownRelationships) {
					if (knownRelationship.selfReferential() && (sourceLabels.isEmpty() || targetLabels.isEmpty())) {
						break outer;
					}
					if (
						sourceLabels.contains(knownRelationship.targetLabel()) && (targetLabels.isEmpty() || targetLabels.contains(knownRelationship.sourceLabel())) ||
						targetLabels.contains(knownRelationship.sourceLabel()) && (sourceLabels.isEmpty() || sourceLabels.contains(knownRelationship.sourceLabel()))
					) {
						return Relationship.Direction.RTL;
					} else if (
						sourceLabels.contains(knownRelationship.sourceLabel()) && (targetLabels.isEmpty() || targetLabels.contains(knownRelationship.targetLabel())) ||
						targetLabels.contains(knownRelationship.targetLabel()) && (sourceLabels.isEmpty() || sourceLabels.contains(knownRelationship.sourceLabel()))
					) {
						return Relationship.Direction.LTR;
					}
				}
			}
			if (!sourceLabels.isEmpty() && !targetLabels.isEmpty()) {
				throw new SchemaEnforcementFailedException();
			}
		}
		if (details.getTypes().isEmpty()) {
			var knownRelationships = this.relationshipDefinitions.values().stream().flatMap(List::stream).toList();
			for (var knownRelationship : knownRelationships) {
				if (sourceLabels.contains(knownRelationship.targetLabel()) && targetLabels.contains(knownRelationship.sourceLabel())) {
					return Relationship.Direction.RTL;
				} else if (sourceLabels.contains(knownRelationship.sourceLabel()) && targetLabels.contains(knownRelationship.targetLabel())) {
					return Relationship.Direction.LTR;
				}
			}
		}
		return details.getDirection();
	}
	void enter(Relationship.Details details) {
		Relationship.Direction direction = Optional.ofNullable(directionOverride).orElseGet(details::getDirection);
		builder.append(direction.getSymbolLeft());
		if (details.hasContent()) {
			builder.append("[");
		}
		inEntity = true;
	}
	void enter(RelationshipTypes types) {
		if (skipRelationshipContent) {
			return;
		}
		builder
			.append(types.getValues().stream()
				.map(this::escapeName)
				.map(Optional::orElseThrow)
				.collect(Collectors.joining(Symbols.REL_TYP_SEPARATOR, Symbols.REL_TYPE_START, "")));
	}
	void enter(RelationshipLength length) {
		if (skipRelationshipContent) {
			return;
		}
		Integer minimum = length.getMinimum();
		Integer maximum = length.getMaximum();
		if (length.isUnbounded()) {
			builder.append("*");
			return;
		}
		if (minimum == null && maximum == null) {
			return;
		}
		builder.append("*");
		if (minimum != null) {
			builder.append(minimum);
		}
		builder.append("..");
		if (maximum != null) {
			builder.append(maximum);
		}
	}
	void leave(Relationship.Details details) {
		Relationship.Direction direction = Optional.ofNullable(directionOverride).orElseGet(details::getDirection);
		if (details.hasContent()) {
			builder.append("]");
		}
		builder.append(direction.getSymbolRight());
		inEntity = false;
	}
	void leave(Relationship relationship) {
		skipRelationshipContent = false;
		directionOverride = null;
	}
	void enter(Parameter<?> parameter) {
		Object value = parameter.getValue();
		if (value instanceof ConstantParameterHolder constantParameterHolder && !renderConstantsAsParameters) {
			builder.append(constantParameterHolder.asString());
		} else {
			builder.append("$").append(nameResolvingStrategy.resolve(parameter));
		}
	}
	void enter(MapExpression map) {
		builder.append("{");
	}
	void enter(KeyValueMapEntry map) {
		builder.append(escapeIfNecessary(map.getKey())).append(": ");
	}
	void leave(MapExpression map) {
		builder.append("}");
	}
	void enter(ListExpression list) {
		builder.append("[");
	}
	void leave(ListExpression list) {
		builder.append("]");
	}
	void enter(Unwind unwind) {
		builder.append("UNWIND ");
	}
	void leave(Unwind unwind) {
		builder
			.append(" ");
	}
	void enter(UnionPart unionPart) {
		builder.append(" UNION ");
		if (unionPart.isAll()) {
			builder.append("ALL ");
		}
	}
	void enter(Set set) {
		builder.append("SET ");
	}
	void leave(Set set) {
		builder.append(" ");
	}
	void enter(Remove remove) {
		builder.append("REMOVE ");
	}
	void leave(Remove remove) {
		builder.append(" ");
	}
	void enter(PatternComprehension patternComprehension) {
		builder.append("[");
	}
	void leave(PatternComprehension patternComprehension) {
		builder.append("]");
	}
	void enter(ListComprehension listComprehension) {
		builder.append("[");
	}
	void leave(ListComprehension listComprehension) {
		builder.append("]");
	}
	void enter(Case genericCase) {
		builder.append("CASE");
	}
	void enter(Case.SimpleCase simpleCase) {
		builder.append("CASE ");
	}
	void enter(CaseWhenThen caseWhenExpression) {
		builder.append(" WHEN ");
	}
	void leave(CaseWhenThen caseWhenExpression) {
		builder.append(" THEN ");
	}
	void enter(CaseElse caseElseExpression) {
		builder.append(" ELSE ");
	}
	void leave(Case caseExpression) {
		builder.append(" END");
	}
	void enter(ProcedureCall procedureCall) {
		builder.append("CALL ");
	}
	void leave(Namespace namespace) {
		builder.append(".");
	}
	void leave(ProcedureName procedureName) {
		builder.append(procedureName.getValue());
	}
	void enter(YieldItems yieldItems) {
		builder.append(" YIELD ");
	}
	void leave(ProcedureCall procedureCall) {
		builder.append(" ");
	}
	void enter(Enum<?> anEnum) {
		builder.append(anEnum.name().replace("_", " ")).append(" ");
	}
	boolean inSubquery;
	void enter(Subquery subquery) {
		this.inSubquery = true;
		builder.append("CALL {");
	}
	void leave(Subquery subquery) {
		this.inSubquery = false;
		int l = builder.length() - 1;
		if (builder.charAt(l) == ' ' && !subquery.doesReturnOrYield()) {
			builder.replace(l, builder.length(), "} ");
		} else {
			builder.append("} ");
		}
	}
	void leave(InTransactions inTransactions) {
		int l = builder.length() - 1;
		if (builder.charAt(l) != ' ') {
			builder.append(" ");
		}
		builder.append("IN TRANSACTIONS ");
		if (inTransactions.getRows() != null) {
			builder.append("OF ").append(inTransactions.getRows()).append(" ROWS ");
		}
	}
	void enter(Foreach foreach) {
		builder.append("FOREACH (");
	}
	void leave(Foreach foreach) {
		builder.setCharAt(builder.length() - 1, ')'); 
		builder.append(" ");
	}
	void enter(SubqueryExpression subquery) {
		if (subquery instanceof CountExpression) {
			builder.append("COUNT");
		} else if (subquery instanceof ExistentialSubquery) {
			builder.append("EXISTS");
		} else if (subquery instanceof CollectExpression) {
			builder.append("COLLECT");
		}
		builder.append(" { ");
	}
	void leave(SubqueryExpression subquery) {
		if (builder.charAt(builder.length() - 1) == ' ') {
			builder.replace(builder.length() - 1, builder.length(), " }");
		} else {
			builder.append(" }");
		}
	}
	void enter(Hint hint) {
		builder.append(" USING ");
	}
	void enter(LoadCSV loadCSV) {
		builder.append("LOAD CSV");
		if (loadCSV.isWithHeaders()) {
			builder.append(" WITH HEADERS");
		}
		builder.append(" FROM '")
			.append(loadCSV.getUri().toString())
			.append("' AS ")
			.append(loadCSV.getAlias());
		if (loadCSV.getFieldTerminator() != null) {
			builder.append(" FIELDTERMINATOR '")
				.append(loadCSV.getFieldTerminator())
				.append("'");
		}
		builder.append(" ");
	}
	void enter(UsingPeriodicCommit usingPeriodicCommit) {
		builder.append("USING PERIODIC COMMIT ");
		if (usingPeriodicCommit.rate() != null) {
			builder.append(usingPeriodicCommit.rate()).append(" ");
		}
	}
	void enter(Use use) {
		builder.append("USE ");
		if (use.dynamic()) {
			builder.append("graph.byName(");
		}
	}
	void leave(Use use) {
		if (use.dynamic()) {
			builder.append(")");
		}
		builder.append(" ");
	}
	void enter(QuantifiedPathPattern.TargetPattern qpp) {
		builder.append("(");
	}
	void leave(QuantifiedPathPattern.TargetPattern qpp) {
		builder.append(")");
	}
	void enter(QuantifiedPathPattern.Quantifier quantifier) {
		builder.append(quantifier.toString());
	}
	@Override
	public String getRenderedContent() {
		return this.builder.toString();
	}
	protected final Optional<String> escapeName(String unescapedName) {
		return SchemaNamesBridge.sanitize(unescapedName, alwaysEscapeNames);
	}
	protected final String escapeIfNecessary(String potentiallyNonIdentifier) {
		return SchemaNamesBridge.sanitize(potentiallyNonIdentifier, false).orElse(null);
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import org.apiguardian.api.API;
import org.jetbrains.annotations.Contract;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
@API(status = STABLE, since = "1.0")
public final class Properties implements Visitable {
	private final MapExpression value;
	@Contract(pure = true)
	public static Properties create(MapExpression expression) {
		return expression == null ? null : new Properties(expression);
	}
	private Properties(MapExpression value) {
		this.value = value;
	}
	@Override
	public void accept(Visitor visitor) {
		visitor.enter(this);
		this.value.accept(visitor);
		visitor.leave(this);
	}
	public String toString() {
		return RendererBridge.render(this);
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.STABLE;
import java.util.Map;
import java.util.Optional;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.RelationshipPatternCondition;
import org.neo4j.cypherdsl.core.utils.Assertions;
@API(status = STABLE, since = "2021.1.0")
public abstract class RelationshipBase<S extends NodeBase<?>, E extends NodeBase<?>, SELF extends RelationshipBase<S, E, SELF>>
		extends AbstractPropertyContainer implements Relationship {
	final Node left;
	final Node right;
	final Details details;
	@Nullable
	final QuantifiedPathPattern.Quantifier quantifier;
	protected RelationshipBase(S start, String type, E end, String... additionalTypes) {
		this(null, start, Direction.LTR, null, end, mergeTypesIfNecessary(type, additionalTypes));
	}
	private static String[] mergeTypesIfNecessary(String type, String... additionalTypes) {
		if (additionalTypes != null && additionalTypes.length > 0) {
			String[] result = new String[1 + additionalTypes.length];
			result[0] = type;
			System.arraycopy(additionalTypes, 0, result, 1, additionalTypes.length);
			return result;
		}
		return new String[] { type };
	}
	protected RelationshipBase(SymbolicName symbolicName, Node start, String type, Properties properties, Node end,
		String... additionalTypes) {
		this(symbolicName, start, Direction.LTR, properties, null, end, mergeTypesIfNecessary(type, additionalTypes));
	}
	protected RelationshipBase(SymbolicName symbolicName, String type, Node start, Properties properties, Node end) {
		this(symbolicName, start, Direction.LTR, properties, null, end, type);
	}
	@NotNull
	@Override
	public final SELF named(String newSymbolicName) {
		Assertions.hasText(newSymbolicName, "Symbolic name is required.");
		return named(SymbolicName.of(newSymbolicName));
	}
	@NotNull
	@Override
	public abstract SELF named(SymbolicName newSymbolicName);
	@NotNull
	@Override
	public final SELF withProperties(Object... keysAndValues) {
		MapExpression newProperties = null;
		if (keysAndValues != null && keysAndValues.length != 0) {
			newProperties = MapExpression.create(false, keysAndValues);
		}
		return withProperties(newProperties);
	}
	@NotNull
	@Override
	public final SELF withProperties(Map<String, Object> newProperties) {
		return withProperties(MapExpression.create(newProperties));
	}
	@NotNull
	@Override
	public abstract SELF withProperties(MapExpression newProperties);
	@NotNull
	@Override
	public final Node getLeft() {
		return left;
	}
	@NotNull
	@Override
	public final Node getRight() {
		return right;
	}
	@Nullable
	@Override
	public final QuantifiedPathPattern.Quantifier getQuantifier() {
		return quantifier;
	}
	@NotNull
	@Override
	public final Details getDetails() {
		return details;
	}
	@NotNull
	@Override
	public final Relationship unbounded() {
		return new InternalRelationshipImpl(this.left, this.details.unbounded(), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public final Relationship min(Integer minimum) {
		return new InternalRelationshipImpl(this.left, this.details.min(minimum), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public final Relationship max(Integer maximum) {
		return new InternalRelationshipImpl(this.left, this.details.max(maximum), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public final Relationship length(Integer minimum, Integer maximum) {
		return new InternalRelationshipImpl(this.left, this.details.min(minimum).max(maximum), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public final Relationship inverse() {
		return new InternalRelationshipImpl(this.right, this.details.inverse(), this.quantifier, this.left);
	}
	@NotNull
	@Override
	public final Optional<SymbolicName> getSymbolicName() {
		return details.getSymbolicName();
	}
	@NotNull
	@Override
	public final SymbolicName getRequiredSymbolicName() {
		return details.getRequiredSymbolicName();
	}
	@NotNull
	@Override
	public final RelationshipChain relationshipTo(Node other, String... types) {
		return RelationshipChain
				.create(this)
				.add(this.right.relationshipTo(other, types));
	}
	@NotNull
	@Override
	public final RelationshipChain relationshipFrom(Node other, String... types) {
		return RelationshipChain
				.create(this)
				.add(this.right.relationshipFrom(other, types));
	}
	@NotNull
	@Override
	public final RelationshipChain relationshipBetween(Node other, String... types) {
		return RelationshipChain
				.create(this)
				.add(this.right.relationshipBetween(other, types));
	}
	@NotNull
	@Override
	public final Condition asCondition() {
		return RelationshipPatternCondition.of(this);
	}
	RelationshipBase(SymbolicName symbolicName, Node left, Direction direction, QuantifiedPathPattern.Quantifier quantifier, Node right, String... types) {
		this(symbolicName, left, direction, null, quantifier, right, types);
	}
	RelationshipBase(SymbolicName symbolicName, Node left, Direction direction, Properties properties, QuantifiedPathPattern.Quantifier quantifier, Node right, String... types) {
		this(left, Details.create(direction, symbolicName, types).with(properties), quantifier, right);
	}
	RelationshipBase(Node left, Details details, QuantifiedPathPattern.Quantifier quantifier, Node right) {
		Assertions.notNull(left, "Left node is required.");
		Assertions.notNull(details, "Details are required.");
		Assertions.notNull(right, "Right node is required.");
		this.left = left;
		this.right = right;
		this.details = details;
		this.quantifier = quantifier;
	}
	@Override
	public final void accept(Visitor visitor) {
		visitor.enter(this);
		left.accept(visitor);
		details.accept(visitor);
		Visitable.visitIfNotNull(this.quantifier, visitor);
		right.accept(visitor);
		visitor.leave(this);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
	@Override
	public @NotNull Relationship where(@Nullable Expression predicate) {
		if (predicate == null) {
			return this;
		}
		return new InternalRelationshipImpl(this.left, this.details.where(predicate), this.quantifier, this.right);
	}
	@NotNull
	@Override
	public RelationshipPattern quantifyRelationship(@Nullable QuantifiedPathPattern.Quantifier newQuantifier) {
		if (newQuantifier == null) {
			return this;
		}
		return new InternalRelationshipImpl(this.left, this.details, newQuantifier, this.right);
	}
	@NotNull
	@Override
	public QuantifiedPathPattern quantify(@Nullable QuantifiedPathPattern.Quantifier newQuantifier) {
		return QuantifiedPathPattern.of(this, newQuantifier);
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
@API(status = INTERNAL, since = "2021.1.0")
final class InternalRelationshipImpl extends RelationshipBase<NodeBase<?>, NodeBase<?>, InternalRelationshipImpl> {
	InternalRelationshipImpl(SymbolicName symbolicName, Node left,
		Direction direction, QuantifiedPathPattern.Quantifier quantifier, Node right, String... types) {
		super(symbolicName, left, direction, quantifier, right, types);
	}
	InternalRelationshipImpl(SymbolicName symbolicName, Node left,
		Direction direction, Properties properties, QuantifiedPathPattern.Quantifier quantifier, Node right, String... types) {
		super(symbolicName, left, direction, properties, quantifier, right, types);
	}
	InternalRelationshipImpl(Node left, Details details, QuantifiedPathPattern.Quantifier quantifier, Node right) {
		super(left, details, quantifier, right);
	}
	@NotNull
	@Override
	public InternalRelationshipImpl named(SymbolicName newSymbolicName) {
		return new InternalRelationshipImpl(this.left, this.details.named(newSymbolicName), quantifier, this.right);
	}
	@NotNull
	@Override
	public InternalRelationshipImpl withProperties(MapExpression newProperties) {
		return new InternalRelationshipImpl(this.left, this.details.with(Properties.create(newProperties)), quantifier, this.right);
	}
}
package org.neo4j.cypherdsl.core;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import static org.apiguardian.api.API.Status.INTERNAL;
@API(status = INTERNAL, since = "2021.1.0")
abstract class AbstractNode extends AbstractPropertyContainer implements Node {
	@NotNull
	@Override
	public final Condition hasLabels(String... labelsToQuery) {
		return HasLabelCondition.create(this.getSymbolicName()
						.orElseThrow(() -> new IllegalStateException("Cannot query a node without a symbolic name.")),
				labelsToQuery);
	}
	@NotNull
	@Override
	public final Condition hasLabels(LabelExpression labels) {
		return new HasLabelExpressionCondition(this.getSymbolicName()
			.orElseThrow(() -> new IllegalStateException("Cannot query a node without a symbolic name.")),
			labels);
	}
	@NotNull
	@Override
	public final Condition isEqualTo(Node otherNode) {
		return this.getRequiredSymbolicName().isEqualTo(otherNode.getRequiredSymbolicName());
	}
	@NotNull
	@Override
	public final Condition isNotEqualTo(Node otherNode) {
		return this.getRequiredSymbolicName().isNotEqualTo(otherNode.getRequiredSymbolicName());
	}
	@NotNull
	@Override
	public final Condition isNull() {
		return this.getRequiredSymbolicName().isNull();
	}
	@NotNull
	@Override
	public final Condition isNotNull() {
		return this.getRequiredSymbolicName().isNotNull();
	}
	@NotNull
	@Override
	public final SortItem descending() {
		return this.getRequiredSymbolicName().descending();
	}
	@NotNull
	@Override
	public final SortItem ascending() {
		return this.getRequiredSymbolicName().ascending();
	}
	@NotNull
	@Override
	public final AliasedExpression as(String alias) {
		return this.getRequiredSymbolicName().as(alias);
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation") 
	public final FunctionInvocation internalId() {
		return Functions.id(this);
	}
	@NotNull
	@Override
	@SuppressWarnings("deprecation")
	public final FunctionInvocation labels() {
		return Functions.labels(this);
	}
	@NotNull
	@Override
	public final Relationship relationshipTo(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.LTR, null, other, types);
	}
	@NotNull
	@Override
	public final Relationship relationshipFrom(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.RTL, null, other, types);
	}
	@NotNull
	@Override
	public final Relationship relationshipBetween(Node other, String... types) {
		return new InternalRelationshipImpl(null, this, Relationship.Direction.UNI, null, other, types);
	}
	@Override
	public String toString() {
		return RendererBridge.render(this);
	}
}
package org.neo4j.cypherdsl.core;
import static org.apiguardian.api.API.Status.INTERNAL;
import java.time.Duration;
import java.time.Period;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalAmount;
import java.time.temporal.TemporalUnit;
import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;
import java.util.function.BiFunction;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;
import org.apiguardian.api.API;
import org.jetbrains.annotations.NotNull;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.driver.Value;
import org.neo4j.driver.types.TypeSystem;
@API(status = INTERNAL, since = "2023.2.1")
@SuppressWarnings("unused")
@RegisterForReflection(allDeclaredConstructors = true)
class DriverValueAdapter implements ForeignAdapter<Value> {
	private final Value value;
	DriverValueAdapter(Value value) {
		this.value = value;
	}
	@Override
	@NotNull
	public Condition asCondition() {
		if (value.hasType(TypeSystem.getDefault().BOOLEAN())) {
			return asExpression().asCondition();
		}
		throw new UnsupportedOperationException("Only Boolean values can be adapted as condition");
	}
	@Override
	@NotNull
	public Expression asExpression() {
		return asExpression0(value);
	}
	private static Expression asExpression0(Value value) {
		var typeSystem = TypeSystem.getDefault();
		if (value.hasType(typeSystem.NODE())) {
			throw new IllegalArgumentException("Node values can only be adapted with asNode");
		}
		if (value.hasType(typeSystem.RELATIONSHIP())) {
			throw new IllegalArgumentException("Relationship values can only be adapted with asRelationship");
		}
		if (value.hasType(typeSystem.POINT())) {
			var p = value.asPoint();
			if (Double.isNaN(p.z())) {
				return new PointLiteral(new TreeMap<>(Map.of("srid", p.srid(), "x", p.x(), "y", p.y())));
			} else {
				return new PointLiteral(new TreeMap<>(Map.of("srid", p.srid(), "x", p.x(), "y", p.y(), "z", p.z())));
			}
		}
		if (value.hasType(typeSystem.FLOAT())) {
			return asFloatOrDouble(value);
		}
		if (value.hasType(typeSystem.DURATION())) {
			var d = value.asIsoDuration();
			return Cypher.literalOf(new TemporalAmountAdapter().apply(d));
		}
		if (value.hasType(typeSystem.BYTES())) {
			throw new IllegalArgumentException("byte[] values cannot be represented as expression.");
		}
		if (value.hasType(typeSystem.LIST())) {
			return Cypher.literalOf(value.asList(DriverValueAdapter::asExpression0));
		}
		if (value.hasType(typeSystem.MAP())) {
			return Cypher.literalOf(value.asMap(DriverValueAdapter::asExpression0));
		}
		return Cypher.literalOf(value.asObject());
	}
	@SuppressWarnings("squid:S1872") 
	private static Literal<Object> asFloatOrDouble(Value value) {
		Number number;
		try {
			number = value.asFloat();
		} catch (Exception e) {
			if (!"org.neo4j.driver.exceptions.value.LossyCoercion".equals(e.getClass().getName())) {
				throw e;
			}
			number = value.asDouble();
		}
		return Cypher.literalOf(number);
	}
	@Override
	@NotNull
	public Node asNode() {
		if (!value.hasType(TypeSystem.getDefault().NODE())) {
			throw new IllegalArgumentException("Cannot adopt value with type " + value.type().name() + " as node");
		}
		var node = value.asNode();
		var labels = node.labels();
		String primaryLabel = null;
		var additionalLabels = new ArrayList<String>();
		for (String label : labels) {
			if (primaryLabel == null) {
				primaryLabel = label;
			} else {
				additionalLabels.add(label);
			}
		}
		var properties = node.size() == 0 ? null : MapExpression.create(node.asMap(DriverValueAdapter::asExpression0));
		if (primaryLabel != null) {
			return Cypher.node(primaryLabel, properties, additionalLabels);
		}
		return Cypher.anyNode().withProperties(properties);
	}
	@Override
	@NotNull
	public Relationship asRelationship() {
		if (!value.hasType(TypeSystem.getDefault().RELATIONSHIP())) {
			throw new IllegalArgumentException("Cannot adopt value with type " + value.type().name() + " as relationship");
		}
		var relationship = value.asRelationship();
		var properties = relationship.size() == 0 ? null : MapExpression.create(relationship.asMap(DriverValueAdapter::asExpression0));
		return Cypher.anyNode()
			.relationshipTo(Cypher.anyNode(), relationship.type()).withProperties(properties);
	}
	@Override
	@NotNull
	public SymbolicName asName() {
		throw new UnsupportedOperationException();
	}
	static final class TemporalAmountAdapter implements UnaryOperator<TemporalAmount> {
		private static final int PERIOD_MASK = 0b11100;
		private static final int DURATION_MASK = 0b00011;
		private static final TemporalUnit[] SUPPORTED_UNITS = {ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS,
			ChronoUnit.SECONDS, ChronoUnit.NANOS};
		private static final short FIELD_YEAR = 0;
		private static final short FIELD_MONTH = 1;
		private static final short FIELD_DAY = 2;
		private static final short FIELD_SECONDS = 3;
		private static final short FIELD_NANOS = 4;
		private static final BiFunction<TemporalAmount, TemporalUnit, Integer> TEMPORAL_UNIT_EXTRACTOR = (d, u) -> {
			if (!d.getUnits().contains(u)) {
				return 0;
			}
			return Math.toIntExact(d.get(u));
		};
		@Override
		public TemporalAmount apply(TemporalAmount internalTemporalAmountRepresentation) {
			int[] values = new int[SUPPORTED_UNITS.length];
			int type = 0;
			for (int i = 0; i < SUPPORTED_UNITS.length; ++i) {
				values[i] = TEMPORAL_UNIT_EXTRACTOR.apply(internalTemporalAmountRepresentation, SUPPORTED_UNITS[i]);
				type |= (values[i] == 0) ? 0 : (0b10000 >> i);
			}
			boolean couldBePeriod = couldBePeriod(type);
			boolean couldBeDuration = couldBeDuration(type);
			if (couldBePeriod && !couldBeDuration) {
				return Period.of(values[FIELD_YEAR], values[FIELD_MONTH], values[FIELD_DAY]).normalized();
			} else if (couldBeDuration && !couldBePeriod) {
				return Duration.ofSeconds(values[FIELD_SECONDS]).plusNanos(values[FIELD_NANOS]);
			} else {
				return internalTemporalAmountRepresentation;
			}
		}
		private static boolean couldBePeriod(int type) {
			return (PERIOD_MASK & type) > 0;
		}
		private static boolean couldBeDuration(int type) {
			return (DURATION_MASK & type) > 0;
		}
	}
	private static final class PointLiteral extends LiteralBase<Map<String, Object>> {
		private PointLiteral(Map<String, Object> content) {
			super(content);
		}
		@Override
		@NotNull
		public String asString() {
			return content.entrySet().stream()
				.map(e -> e.getKey() + ": " + e.getValue())
				.collect(Collectors.joining(", ", "point({", "})"));
		}
	}
}
package org.neo4j.cypherdsl.core;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;
import java.util.stream.Collectors;
import org.neo4j.cypherdsl.build.annotations.RegisterForReflection;
import org.neo4j.cypherdsl.core.ParameterCollectingVisitor.ParameterInformation;
import org.neo4j.cypherdsl.core.StatementCatalog.Clause;
import org.neo4j.cypherdsl.core.StatementCatalog.PropertyFilter;
import org.neo4j.cypherdsl.core.StatementCatalog.Token;
import org.neo4j.cypherdsl.core.ast.Visitable;
import org.neo4j.cypherdsl.core.ast.Visitor;
import org.neo4j.cypherdsl.core.internal.Namespace;
import org.neo4j.cypherdsl.core.internal.ReflectiveVisitor;
import org.neo4j.cypherdsl.core.internal.ScopingStrategy;
@RegisterForReflection
@SuppressWarnings({"unused", "squid:S1172"})
class StatementCatalogBuildingVisitor extends ReflectiveVisitor {
	private static final String TYPE_OF_COMPOUND_CONDITION = "org.neo4j.cypherdsl.core.CompoundCondition";
	private final AtomicReference<Clause> currentClause = new AtomicReference<>(Clause.UNKNOWN);
	private final Deque<PatternElement> currentPatternElement = new ArrayDeque<>();
	private final Set<Token> tokens = new LinkedHashSet<>();
	private final Set<StatementCatalog.Property> properties = new LinkedHashSet<>();
	private final Set<StatementCatalog.LabelFilter> labelFilters = new LinkedHashSet<>();
	private final Map<StatementCatalog.Property, Set<PropertyFilter>> propertyFilters = new LinkedHashMap<>();
	private final Deque<Map<SymbolicName, PatternElement>> patternLookup = new ArrayDeque<>();
	private final Deque<org.neo4j.cypherdsl.core.Condition> currentConditions = new ArrayDeque<>();
	private final AtomicReference<Set<Token>> currentHasLabelCondition = new AtomicReference<>();
	private final StatementContext statementContext;
	private final boolean renderConstantsAsParameters;
	private final ScopingStrategy scopingStrategy;
	private final ParameterCollectingVisitor allParameters;
	private final Map<Node, Set<Token>> currentUndirectedRelations = new HashMap<>();
	private final Map<Node, Set<Token>> currentIncomingRelations = new HashMap<>();
	private final Map<Node, Set<Token>> currentOutgoingRelations = new HashMap<>();
	private final Map<Token, Relationships> relationships = new HashMap<>();
	private final Set<Literal<?>> literals = new LinkedHashSet<>();
	StatementCatalogBuildingVisitor(StatementContext statementContext, boolean renderConstantsAsParameters) {
		this.statementContext = statementContext;
		this.renderConstantsAsParameters = renderConstantsAsParameters;
		this.scopingStrategy = ScopingStrategy.create(
			List.of((cause, imports) -> patternLookup.push(createNewScope(imports))),
			List.of((cause, exports) -> importIntoCurrentScope(exports))
		);
		this.patternLookup.push(new HashMap<>());
		this.allParameters = new ParameterCollectingVisitor(statementContext, renderConstantsAsParameters);
	}
	private Map<SymbolicName, PatternElement> createNewScope(Collection<IdentifiableElement> imports) {
		addRelationsInCurrentScope();
		Map<SymbolicName, PatternElement> currentScope = patternLookup.isEmpty() ? Collections.emptyMap() : patternLookup.peek();
		Map<SymbolicName, PatternElement> newScope = new HashMap<>();
		copyIdentifiableElements(imports, currentScope, newScope);
		return newScope;
	}
	private void importIntoCurrentScope(Collection<IdentifiableElement> exports) {
		Map<SymbolicName, PatternElement> previousScope = patternLookup.pop();
		Map<SymbolicName, PatternElement> currentScope = patternLookup.isEmpty() ? new HashMap<>() : patternLookup.peek();
		copyIdentifiableElements(exports, previousScope, currentScope);
	}
	private static void copyIdentifiableElements(Collection<IdentifiableElement> elements, Map<SymbolicName, PatternElement> source, Map<SymbolicName, PatternElement> target) {
		for (IdentifiableElement e : elements) {
			if (e instanceof SymbolicName s && source.containsKey(s)) {
				target.put(s, source.get(s));
			} else if (e instanceof Named n && e instanceof PatternElement p) {
				target.put(n.getRequiredSymbolicName(), p);
			}
		}
	}
	record Relationships(Set<Token> outgoing, Set<Token> incoming, Set<Token> undirected) {
		static Relationships empty() {
			return new Relationships(Set.of(), Set.of(), Set.of());
		}
		Relationships() {
			this(new HashSet<>(), new HashSet<>(), new HashSet<>());
		}
		Relationships copy() {
			return new Relationships(Set.copyOf(this.outgoing), Set.copyOf(this.incoming), Set.copyOf(this.undirected));
		}
	}
	StatementCatalog getResult() {
		addRelationsInCurrentScope();
		var parameterInformation = allParameters.getResult();
		return new DefaultStatementCatalog(this.tokens, this.labelFilters, this.properties, this.propertyFilters, scopingStrategy.getIdentifiables(), parameterInformation, relationships, literals);
	}
	void addRelationsInCurrentScope() {
		finish(currentOutgoingRelations, Relationships::outgoing);
		finish(currentIncomingRelations, Relationships::incoming);
		finish(currentUndirectedRelations, Relationships::undirected);
	}
	private void finish(Map<Node, Set<Token>> nodesToRelations, Function<Relationships, Set<Token>> targetProvider) {
		nodesToRelations.forEach((k, v) -> {
			var labels = getAllLabels((Node) k.getSymbolicName().map(this::lookup).orElse(k));
			labels.forEach(t -> {
				var rels = relationships.computeIfAbsent(t, unused -> new Relationships());
				targetProvider.apply(rels).addAll(v);
			});
		});
		nodesToRelations.clear();
	}
	@Override
	protected boolean preEnter(Visitable visitable) {
		scopingStrategy.doEnter(visitable);
		return true;
	}
	@Override
	protected void postLeave(Visitable visitable) {
		scopingStrategy.doLeave(visitable);
	}
	void enter(Match match) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.MATCH);
	}
	void leave(Match match) {
		currentClause.compareAndSet(Clause.MATCH, Clause.UNKNOWN);
	}
	void enter(Create create) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.CREATE);
	}
	void leave(Create create) {
		currentClause.compareAndSet(Clause.CREATE, Clause.UNKNOWN);
	}
	void enter(Merge merge) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.MERGE);
	}
	void leave(Merge merge) {
		currentClause.compareAndSet(Clause.MERGE, Clause.UNKNOWN);
	}
	void enter(Delete delete) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.DELETE);
	}
	void leave(Delete delete) {
		currentClause.compareAndSet(Clause.DELETE, Clause.UNKNOWN);
	}
	void enter(With with) {
		currentClause.compareAndSet(Clause.UNKNOWN, Clause.WITH);
	}
	void leave(With with) {
		currentClause.compareAndSet(Clause.WITH, Clause.UNKNOWN);
	}
	void enter(Node node) {
		node.getSymbolicName().ifPresent(s -> store(s, node));
		currentPatternElement.push(node);
	}
	void enter(KeyValueMapEntry mapEntry) {
		var owner = currentPatternElement.peek();
		if (owner == null) {
			return;
		}
		StatementCatalog.Property property;
		if (owner instanceof Node node) {
			property = new StatementCatalog.Property(getAllLabels(node), mapEntry.getKey());
		} else if (owner instanceof Relationship relationship) {
			property = new StatementCatalog.Property(relationship.getDetails().getTypes().stream().map(Token::type).collect(Collectors.toSet()), mapEntry.getKey());
		} else {
			property = null;
		}
		if (property == null) {
			return;
		}
		this.properties.add(property);
		Expression left;
		if (((PropertyContainer) owner).getSymbolicName().isPresent()) {
			left = ((PropertyContainer) owner).property(mapEntry.getKey());
		} else {
			left = PropertyLookup.forName(mapEntry.getKey());
		}
		var parameterInformation = extractParameters(mapEntry.getValue());
		this.propertyFilters.computeIfAbsent(property, ignored -> new HashSet<>())
			.add(new PropertyFilter(currentClause.get(), left, Operator.EQUALITY, mapEntry.getValue(), parameterInformation.names, parameterInformation.values));
	}
	void leave(Node node) {
		currentPatternElement.removeFirstOccurrence(node);
	}
	void enter(Relationship relationship) {
		relationship.getSymbolicName().ifPresent(s -> store(s, relationship));
		currentPatternElement.push(relationship);
		var types = relationship.getDetails().getTypes().stream().map(Token::type).toList();
		tokens.addAll(types);
		storeRelations(relationship.getLeft(), relationship.getRight(), types, relationship.getDetails().getDirection());
	}
	private void storeRelations(Node left, Node right, List<Token> types, Relationship.Direction direction) {
		final Function<Node, Set<Token>> targetSupplier = unused -> new HashSet<>();
		switch (direction) {
			case UNI -> {
				currentUndirectedRelations.computeIfAbsent(left, targetSupplier).addAll(types);
				currentUndirectedRelations.computeIfAbsent(right, targetSupplier).addAll(types);
			}
			case LTR -> {
				currentOutgoingRelations.computeIfAbsent(left, targetSupplier).addAll(types);
				currentIncomingRelations.computeIfAbsent(right, targetSupplier).addAll(types);
			}
			case RTL -> {
				currentIncomingRelations.computeIfAbsent(left, targetSupplier).addAll(types);
				currentOutgoingRelations.computeIfAbsent(right, targetSupplier).addAll(types);
			}
		}
	}
	void leave(Relationship relationship) {
		currentPatternElement.removeFirstOccurrence(relationship);
	}
	void enter(org.neo4j.cypherdsl.core.Property property) {
		if (property.getNames().size() != 1) {
			return;
		}
		var lookup = property.getNames().get(0);
		if (lookup.isDynamicLookup()) {
			return;
		}
		if (!(property.getContainerReference() instanceof SymbolicName s)) {
			return;
		}
		var propertyName = new AtomicReference<String>();
		lookup.accept(segment -> {
			if (segment instanceof SymbolicName name) {
				propertyName.compareAndSet(null, name.getValue());
			}
		});
		StatementCatalog.Property newProperty;
		var patternElement = lookup(s);
		if (patternElement instanceof Node node) {
			newProperty = new StatementCatalog.Property(
				getAllLabels(node),
				propertyName.get()
			);
		} else if (patternElement instanceof Relationship relationship) {
			newProperty = new StatementCatalog.Property(
				relationship.getDetails().getTypes().stream().map(Token::type).collect(Collectors.toSet()),
				propertyName.get()
			);
		} else {
			return;
		}
		properties.add(newProperty);
		if (inCurrentCondition(property)) {
			propertyFilters.computeIfAbsent(newProperty, ignored -> new HashSet<>())
				.add(extractPropertyCondition(newProperty, currentConditions.peek()));
		}
	}
	private static Set<Token> getAllLabels(Node node) {
		Set<Token> result = new TreeSet<>();
		if (node.getLabels().isEmpty()) {
			node.accept(segment -> {
				if (segment instanceof LabelExpression l) {
					collectLabels(l, null, result);
				}
			});
		} else {
			node.getLabels().stream()
				.map(NodeLabel::getValue)
				.map(Token::label)
				.forEach(result::add);
		}
		return result;
	}
	private static void collectLabels(LabelExpression l, LabelExpression.Type parent, Set<Token> labels) {
		if (l == null) {
			return;
		}
		var current = l.type();
		collectLabels(l.lhs(), current, labels);
		if (current == LabelExpression.Type.LEAF) {
			l.value().stream().map(Token::label).forEach(labels::add);
		}
		collectLabels(l.rhs(), current, labels);
	}
	void enter(Parameter<?> parameter) {
		this.allParameters.enter(parameter);
	}
	private boolean inCurrentCondition(org.neo4j.cypherdsl.core.Property property) {
		var currentCondition = this.currentConditions.peek();
		if (currentCondition == null) {
			return false;
		}
		var result = new AtomicBoolean();
		currentCondition.accept(segment -> {
			if (segment == property) {
				result.compareAndSet(false, true);
			}
		});
		return result.get();
	}
	private PropertyFilter extractPropertyCondition(StatementCatalog.Property property, org.neo4j.cypherdsl.core.Condition condition) {
		var left = new AtomicReference<Expression>();
		var op = new AtomicReference<Operator>();
		var right = new AtomicReference<Expression>();
		condition.accept(new Visitor() {
			int cnt;
			@Override
			public void enter(Visitable segment) {
				if (++cnt != 2) {
					return;
				}
				if (segment instanceof Operator operator) {
					op.compareAndSet(null, operator);
				} else if (segment instanceof Expression expression && !left.compareAndSet(null, expression)) {
					right.compareAndSet(null, expression);
				}
			}
			@Override
			public void leave(Visitable segment) {
				--cnt;
			}
		});
		var parameterInformation = extractParameters(left.get(), right.get());
		return new PropertyFilter(currentClause.get(), left.get(), op.get(), right.get(), parameterInformation.names, parameterInformation.values);
	}
	void enter(NodeLabel label) {
		this.tokens.add(new Token(Token.Type.NODE_LABEL, label.getValue()));
		var currentCondition = currentConditions.peek();
		if (currentCondition instanceof HasLabelCondition hasLabelCondition) {
			this.currentHasLabelCondition.get().add(Token.label(label));
		}
	}
	void enter(LabelExpression labelExpression) {
		collectLabels(labelExpression, null, tokens);
	}
	PatternElement lookup(SymbolicName s) {
		if (patternLookup.isEmpty()) {
			throw new IllegalStateException("Invalid scope");
		}
		return patternLookup.peek().get(s);
	}
	void enter(org.neo4j.cypherdsl.core.Condition condition) {
		if (TYPE_OF_COMPOUND_CONDITION.equals(condition.getClass().getName())) {
			return;
		}
		this.currentConditions.push(condition);
		if (condition instanceof HasLabelCondition) {
			this.currentHasLabelCondition.compareAndSet(null, new TreeSet<>());
		}
	}
	void enter(Literal<?> literal) {
		if (literal instanceof Asterisk || literal instanceof PeriodLiteral || literal instanceof RawLiteral.RawElement || literal == LiteralBase.BLANK || literal == ListOperator.DOTS || literal instanceof Namespace) {
			return;
		}
		this.literals.add(literal);
	}
	void leave(org.neo4j.cypherdsl.core.Condition condition) {
		if (TYPE_OF_COMPOUND_CONDITION.equals(condition.getClass().getName())) {
			return;
		}
		this.currentConditions.pop();
		var setOfRequiredTokens = currentHasLabelCondition.getAndSet(null);
		if (condition instanceof HasLabelCondition hasLabelCondition && setOfRequiredTokens != null) {
			AtomicReference<String> symbolicName = new AtomicReference<>();
			hasLabelCondition.accept(segment -> {
				if (segment instanceof SymbolicName s) {
					symbolicName.compareAndSet(null, s.getValue());
				}
			});
			this.labelFilters.add(new StatementCatalog.LabelFilter(symbolicName.get(), setOfRequiredTokens));
		}
	}
	void store(SymbolicName s, PatternElement patternElement) {
		if (patternLookup.isEmpty()) {
			throw new IllegalStateException("Invalid scope");
		}
		var currentScope = patternLookup.peek();
		if (currentScope.containsKey(s) && (scopingStrategy.getCurrentImports().contains(s) || patternLookup.size() == 1)) {
			return;
		}
		currentScope.put(s, patternElement);
	}
	private ParameterInformation extractParameters(Expression... expressions) {
		var parameterCollectingVisitor = new ParameterCollectingVisitor(this.statementContext, this.renderConstantsAsParameters);
		for (Expression expression : expressions) {
			if (expression == null) {
				continue;
			}
			expression.accept(parameterCollectingVisitor);
		}
		return parameterCollectingVisitor.getResult();
	}
	static final class DefaultStatementCatalog implements StatementCatalog {
		private final Set<Token> tokens;
		private final Set<Property> properties;
		private final Collection<LabelFilter> labelFilters;
		private final Map<Property, Collection<PropertyFilter>> propertyFilters;
		private final Set<Expression> identifiableExpressions;
		private final ParameterInformation parameterInformation;
		private final Map<Token, Relationships> relationships;
		private final Set<Literal<?>> literals;
		@SuppressWarnings("squid:S107") 
		DefaultStatementCatalog(
			Set<Token> tokens,
			Set<LabelFilter> labelFilters,
			Set<Property> properties,
			Map<Property, Set<PropertyFilter>> propertyFilters,
			Collection<Expression> identifiableExpressions,
			ParameterInformation parameterInformation,
			Map<Token, Relationships> relationships,
			Set<Literal<?>> literals
		) {
			this.tokens = Collections.unmodifiableSet(tokens);
			this.labelFilters = Collections.unmodifiableSet(labelFilters);
			this.properties = Collections.unmodifiableSet(properties);
			this.propertyFilters = propertyFilters.entrySet().stream()
				.collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, e -> Collections.unmodifiableSet(e.getValue())));
			this.identifiableExpressions = identifiableExpressions instanceof Set<Expression> s ? Collections.unmodifiableSet(s) : Set.copyOf(identifiableExpressions);
			this.parameterInformation = parameterInformation;
			this.relationships = relationships.entrySet().stream()
				.collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, e -> e.getValue().copy()));
			this.literals = Collections.unmodifiableSet(literals);
		}
		@Override
		public Set<Token> getAllTokens() {
			return tokens;
		}
		@Override
		public Set<Property> getProperties() {
			return properties;
		}
		@Override
		public Collection<LabelFilter> getAllLabelFilters() {
			return this.labelFilters;
		}
		@Override
		public Map<Property, Collection<PropertyFilter>> getAllPropertyFilters() {
			return this.propertyFilters;
		}
		@Override
		public Set<Expression> getIdentifiableExpressions() {
			return identifiableExpressions;
		}
		@Override
		public Map<String, Object> getParameters() {
			return parameterInformation.values;
		}
		@Override
		public Collection<String> getParameterNames() {
			return parameterInformation.names;
		}
		@Override
		public Map<String, String> getRenamedParameters() {
			return parameterInformation.renames;
		}
		@Override
		public Collection<Token> getOutgoingRelations(Token label) {
			return extractRelations(label, Relationships::outgoing);
		}
		private Collection<Token> extractRelations(Token label, Function<Relationships, Set<Token>> tokenProvider) {
			if (label.type() != Token.Type.NODE_LABEL) {
				throw new IllegalArgumentException(label + " must be a node label, not a relationship type");
			}
			return tokenProvider.apply(relationships.getOrDefault(label, Relationships.empty()));
		}
		@Override
		public Collection<Token> getTargetNodes(Token type) {
			if (type.type() != Token.Type.RELATIONSHIP_TYPE) {
				throw new IllegalArgumentException(type + " must be a relationship type, not a node label");
			}
			return relationships
				.entrySet()
				.stream()
				.filter(e -> e.getValue().incoming().contains(type))
				.map(Map.Entry::getKey)
				.collect(Collectors.toSet());
		}
		@Override
		public Collection<Token> getIncomingRelations(Token label) {
			return extractRelations(label, Relationships::incoming);
		}
		@Override
		public Collection<Token> getSourceNodes(Token type) {
			if (type.type() != Token.Type.RELATIONSHIP_TYPE) {
				throw new IllegalArgumentException(type + " must be a relationship type, not a node label");
			}
			return relationships
				.entrySet()
				.stream()
				.filter(e -> e.getValue().outgoing().contains(type))
				.map(Map.Entry::getKey)
				.collect(Collectors.toSet());
		}
		@Override
		public Collection<Token> getUndirectedRelations(Token label) {
			return extractRelations(label, Relationships::undirected);
		}
		@Override
		public Set<Literal<?>> getLiterals() {
			return literals;
		}
	}
}