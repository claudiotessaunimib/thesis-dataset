package intermediate;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.dsl.components.OffscreenCleanComponent;
import com.almasb.fxgl.dsl.components.ProjectileComponent;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.entity.components.CollidableComponent;
import com.almasb.fxgl.physics.CollisionHandler;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import javafx.geometry.Point2D;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Text;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class CollisionFilterSample extends GameApplication {
    private enum EType {
        PLAYER, ENEMY, BULLET
    }
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setDeveloperMenuEnabled(true);
    }
    private int i = 0;
    @Override
    protected void initGame() {
        entityBuilder()
                .type(EType.PLAYER)
                .viewWithBBox(new Rectangle(40, 40, Color.BLUE))
                .view(new Text("PLAYER"))
                .at(100, 100)
                .with(new CollidableComponent(true), new PhysicsComponent())
                .buildAndAttach();
        entityBuilder()
                .type(EType.ENEMY)
                .viewWithBBox(new Rectangle(40, 40, Color.RED))
                .view(new Text("ENEMY"))
                .at(400, 100)
                .with(new CollidableComponent(true), new PhysicsComponent())
                .buildAndAttach();
        run(() -> {
            CollidableComponent collidable = new CollidableComponent(true);
            CollidableComponent collidable2 = new CollidableComponent(true);
            if (i == 0) {
                debug("No collision with player");
                collidable.addIgnoredType(EType.PLAYER);
                collidable2.addIgnoredType(EType.PLAYER);
            } else if (i == 1) {
                debug("No collision with enemy");
                collidable.addIgnoredType(EType.ENEMY);
                collidable2.addIgnoredType(EType.ENEMY);
            } else if (i == 2) {
                debug("No collision with player and enemy");
                collidable.addIgnoredType(EType.PLAYER);
                collidable.addIgnoredType(EType.ENEMY);
                collidable2.addIgnoredType(EType.PLAYER);
                collidable2.addIgnoredType(EType.ENEMY);
            }
            i++;
            if (i == 3)
                i = 0;
            entityBuilder()
                    .type(EType.BULLET)
                    .viewWithBBox(new Rectangle(20, 10, Color.BLACK))
                    .at(0, 100)
                    .with(new ProjectileComponent(new Point2D(1, 0), 100))
                    .with(new OffscreenCleanComponent())
                    .with(collidable)
                    .buildAndAttach();
            PhysicsComponent physics = new PhysicsComponent();
            physics.setBodyType(BodyType.DYNAMIC);
            physics.setOnPhysicsInitialized(() -> physics.setLinearVelocity(100, 0));
            entityBuilder()
                    .type(EType.BULLET)
                    .viewWithBBox(new Rectangle(20, 10, Color.BLACK))
                    .at(0, 130)
                    .with(physics)
                    .with(new OffscreenCleanComponent())
                    .with(collidable2)
                    .buildAndAttach();
        }, Duration.seconds(4));
    }
    @Override
    protected void initPhysics() {
        getPhysicsWorld().setGravity(0, 0);
        getPhysicsWorld().addCollisionHandler(new CollisionHandler(EType.PLAYER, EType.BULLET) {
            @Override
            protected void onCollisionBegin(Entity a, Entity b) {
                b.removeFromWorld();
            }
        });
        getPhysicsWorld().addCollisionHandler(new CollisionHandler(EType.ENEMY, EType.BULLET) {
            @Override
            protected void onCollisionBegin(Entity a, Entity b) {
                b.removeFromWorld();
            }
        });
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package com.almasb.fxgl.physics;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.core.pool.Pools;
import com.almasb.fxgl.core.util.EmptyRunnable;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.entity.component.Component;
import com.almasb.fxgl.physics.box2d.dynamics.Body;
import com.almasb.fxgl.physics.box2d.dynamics.BodyDef;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.beans.property.ReadOnlyBooleanProperty;
import javafx.beans.property.ReadOnlyBooleanWrapper;
import javafx.geometry.Point2D;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public final class PhysicsComponent extends Component {
    FixtureDef fixtureDef = new FixtureDef();
    BodyDef bodyDef = new BodyDef();
    Body body;
    private List<Entity> groundedList = new ArrayList<>();
    private ReadOnlyBooleanWrapper onGroundProperty = new ReadOnlyBooleanWrapper(false);
    private boolean raycastIgnored = false;
    private Runnable onInitPhysics = EmptyRunnable.INSTANCE;
    private PhysicsWorld physicsWorld;
    void setWorld(PhysicsWorld world) {
        physicsWorld = world;
    }
    private PhysicsWorld getPhysicsWorld() {
        if (physicsWorld == null)
            throw new IllegalStateException("Physics not initialized yet! Use setOnPhysicsInitialized() instead");
        return physicsWorld;
    }
    void onInitPhysics() {
        onInitPhysics.run();
    }
    public boolean isOnGround() {
        return !groundedList.isEmpty();
    }
    public ReadOnlyBooleanProperty onGroundProperty() {
        return onGroundProperty.getReadOnlyProperty();
    }
    public Body getBody() {
        if (body == null)
            throw new IllegalStateException("Physics not initialized yet! Use setOnPhysicsInitialized() instead");
        return body;
    }
    public void setOnPhysicsInitialized(Runnable code) {
        onInitPhysics = code;
    }
    private Map<HitBox, SensorCollisionHandler> sensorHandlers = new HashMap<>();
    public Map<HitBox, SensorCollisionHandler> getSensorHandlers() {
        return sensorHandlers;
    }
    public void addGroundSensor(HitBox box) {
        sensorHandlers.put(box, new SensorCollisionHandler() {
            @Override
            protected void onCollisionBegin(Entity other) {
                groundedList.add(other);
                onGroundProperty.setValue(isOnGround());
            }
            @Override
            protected void onCollisionEnd(Entity other) {
                groundedList.remove(other);
                onGroundProperty.setValue(isOnGround());
            }
        });
    }
    public void addSensor(HitBox box, SensorCollisionHandler handler) {
        sensorHandlers.put(box, handler);
    }
    public void removeSensor(HitBox box) {
        box.unbind();
        getPhysicsWorld().destroyFixture(body, box);
        sensorHandlers.remove(box);
    }
    public void setFixtureDef(FixtureDef def) {
        fixtureDef = def;
    }
    public void setBodyDef(BodyDef def) {
        bodyDef = def;
    }
    public void setBodyType(BodyType type) {
        bodyDef.setType(type);
    }
    public boolean isMovingX() {
        return FXGLMath.abs(getVelocityX()) > 0;
    }
    public boolean isMovingY() {
        return FXGLMath.abs(getVelocityY()) > 0;
    }
    public boolean isMoving() {
        return isMovingX() || isMovingY();
    }
    public void setLinearVelocity(Point2D vector) {
        setBodyLinearVelocity(getPhysicsWorld().toVector(vector));
    }
    public void setLinearVelocity(double x, double y) {
        setLinearVelocity(new Point2D(x, y));
    }
    public void setVelocityX(double x) {
        setLinearVelocity(x, getVelocityY());
    }
    public void setVelocityY(double y) {
        setLinearVelocity(getVelocityX(), y);
    }
    public double getVelocityX() {
        return getLinearVelocity().getX();
    }
    public double getVelocityY() {
        return getLinearVelocity().getY();
    }
    public void setBodyLinearVelocity(Vec2 vector) {
        getBody().setLinearVelocity(vector);
    }
    public Point2D getLinearVelocity() {
        return getPhysicsWorld().toVector(getBody().getLinearVelocity());
    }
    public void setAngularVelocity(double velocity) {
        getBody().setAngularVelocity((float) -FXGLMath.toRadians(velocity));
    }
    public void applyLinearImpulse(Point2D impulse, Point2D point, boolean wake) {
        applyBodyLinearImpulse(getPhysicsWorld().toVector(impulse), getPhysicsWorld().toPoint(point), wake);
    }
    public void applyBodyLinearImpulse(Vec2 impulse, Vec2 point, boolean wake) {
        getBody().applyLinearImpulse(impulse, point, wake);
    }
    public void applyForce(Point2D force, Point2D point) {
        applyBodyForce(getPhysicsWorld().toVector(force), getPhysicsWorld().toPoint(point));
    }
    public void applyBodyForce(Vec2 force, Vec2 point) {
        getBody().applyForce(force, point);
    }
    public void applyForceToCenter(Point2D force) {
        applyBodyForceToCenter(getPhysicsWorld().toVector(force));
    }
    public void applyBodyForceToCenter(Vec2 force) {
        getBody().applyForceToCenter(force);
    }
    public void setRaycastIgnored(boolean b) {
        raycastIgnored = b;
    }
    public boolean isRaycastIgnored() {
        return raycastIgnored;
    }
    private Vec2 minMeters = Pools.obtain(Vec2.class);
    @Override
    public void onUpdate(double tpf) {
        if (body == null)
            return;
        minMeters.set(
                getBody().getPosition().x - getPhysicsWorld().toMetersF(entity.getWidth() / 2),
                getBody().getPosition().y + getPhysicsWorld().toMetersF(entity.getHeight() / 2)
        );
        Point2D minWorld = getPhysicsWorld().toPoint(minMeters);
        entity.setX(
                Math.round(minWorld.getX() - entity.getBoundingBoxComponent().getMinXLocal())
        );
        entity.setY(
                Math.round(minWorld.getY() - entity.getBoundingBoxComponent().getMinYLocal())
        );
        entity.setRotation(-Math.toDegrees(getBody().getAngle()));
    }
    @Override
    public void onRemoved() {
        Pools.free(minMeters);
    }
    public void overwritePosition(Point2D point) {
        double w = getEntity().getWidth();
        double h = getEntity().getHeight();
        Vec2 positionMeters = getPhysicsWorld().toPoint(new Point2D(
                point.getX() + w / 2,
                point.getY() + h / 2
        ));
        getBody().setTransform(positionMeters, getBody().getAngle());
    }
    public void overwriteAngle(double angDegrees) {
        getBody().setTransform(getBody().getPosition(), (float) -FXGLMath.toRadians(angDegrees));
    }
    @Override
    public boolean isComponentInjectionRequired() {
        return false;
    }
}
package com.almasb.fxgl.entity;
import com.almasb.fxgl.animation.Animatable;
import com.almasb.fxgl.core.Copyable;
import com.almasb.fxgl.core.collection.PropertyMap;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.core.reflect.ReflectionUtils;
import com.almasb.fxgl.core.util.EmptyRunnable;
import com.almasb.fxgl.entity.component.*;
import com.almasb.fxgl.entity.components.BoundingBoxComponent;
import com.almasb.fxgl.entity.components.TransformComponent;
import com.almasb.fxgl.entity.components.TypeComponent;
import com.almasb.fxgl.entity.components.ViewComponent;
import com.almasb.fxgl.logging.Logger;
import javafx.beans.property.*;
import javafx.geometry.Point2D;
import javafx.geometry.Point3D;
import javafx.geometry.Rectangle2D;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.*;
import static com.almasb.fxgl.core.reflect.ReflectionUtils.*;
public class Entity implements Animatable, Copyable<Entity> {
    private static class ComponentMap {
        private Map<Class<? extends Component>, Component> components = new HashMap<>();
        private List<Component> componentList = new ArrayList<>();
        void update(double tpf) {
            for (int i = 0; i < componentList.size(); i++) {
                Component c = componentList.get(i);
                if (!c.isPaused()) {
                    c.onUpdate(tpf);
                }
            }
        }
        <T extends Component> boolean has(Class<T> type) {
            return components.containsKey(type);
        }
        void add(Component c) {
            components.put(c.getClass(), c);
            componentList.add(c);
        }
        void remove(Class<? extends Component> type) {
            var c = components.remove(type);
            componentList.remove(c);
        }
        <T extends Component> Component get(Class<T> type) {
            return components.get(type);
        }
        Set<Class<? extends Component>> types() {
            return components.keySet();
        }
        List<Component> getAll() {
            return new ArrayList<>(componentList);
        }
        void clear() {
            components.clear();
            componentList.clear();
        }
    }
    private static class ComponentMethod {
        private Method method;
        private Component component;
        ComponentMethod(Component component, Method method) {
            this.component = component;
            this.method = method;
        }
        <T> T call(Object... args) throws Exception {
            return (T) method.invoke(component, args);
        }
    }
    private static final Logger log = Logger.get(Entity.class);
    private PropertyMap properties = new PropertyMap();
    private ComponentMap components = new ComponentMap();
    private Map<String, ComponentMethod> componentMethods = new HashMap<>();
    private List<ComponentListener> componentListeners = new ArrayList<>();
    private ReadOnlyBooleanWrapper active = new ReadOnlyBooleanWrapper(false);
    private Runnable onActive = EmptyRunnable.INSTANCE;
    private Runnable onNotActive = EmptyRunnable.INSTANCE;
    private boolean isEverUpdated = true;
    private boolean isUpdateEnabled = true;
    private boolean isUpdating = false;
    private boolean isReusable = false;
    private TypeComponent type = new TypeComponent();
    private TransformComponent transform = new TransformComponent();
    private BoundingBoxComponent bbox = new BoundingBoxComponent();
    private ViewComponent view = new ViewComponent();
    private GameWorld world = null;
    public Entity() {
        addComponentNoChecks(type);
        addComponentNoChecks(transform);
        addComponentNoChecks(bbox);
        addComponentNoChecks(view);
    }
    public final GameWorld getWorld() {
        return world;
    }
    void init(GameWorld world) {
        this.world = world;
        onActive.run();
        active.set(true);
    }
    void clean() {
        if (isReusable) {
            world = null;
            return;
        }
        removeAllComponents();
        properties.clear();
        componentListeners.clear();
        componentMethods.clear();
        world = null;
        onActive = EmptyRunnable.INSTANCE;
        onNotActive = EmptyRunnable.INSTANCE;
        isUpdateEnabled = true;
        isUpdating = false;
    }
    public final void removeFromWorld() {
        if (world != null)
            world.removeEntity(this);
    }
    public final boolean isEverUpdated() {
        return isEverUpdated;
    }
    public final void setEverUpdated(boolean everUpdated) {
        isEverUpdated = everUpdated;
    }
    public final void setUpdateEnabled(boolean b) {
        isUpdateEnabled = b;
    }
    public boolean isReusable() {
        return isReusable;
    }
    public void setReusable(boolean isReusable) {
        this.isReusable = isReusable;
    }
    void update(double tpf) {
        if (!isUpdateEnabled)
            return;
        isUpdating = true;
        components.update(tpf);
        isUpdating = false;
    }
    void markForRemoval() {
        onNotActive.run();
        active.set(false);
    }
    public final ReadOnlyBooleanProperty activeProperty() {
        return active.getReadOnlyProperty();
    }
    public final boolean isActive() {
        return active.get();
    }
    public final void setOnActive(Runnable action) {
        onActive = action;
    }
    public final void setOnNotActive(Runnable action) {
        onNotActive = action;
    }
    public final PropertyMap getProperties() {
        return properties;
    }
    public final void setProperty(String key, Object value) {
        properties.setValue(key, value);
    }
    public final <T> Optional<T> getPropertyOptional(String key) {
        return properties.getValueOptional(key);
    }
    public final int getInt(String key) {
        return properties.getInt(key);
    }
    public final double getDouble(String key) {
        return properties.getDouble(key);
    }
    public final boolean getBoolean(String key) {
        return properties.getBoolean(key);
    }
    public final String getString(String key) {
        return properties.getString(key);
    }
    public final <T> T getObject(String key) {
        return properties.getObject(key);
    }
    public final void addComponentListener(ComponentListener listener) {
        componentListeners.add(listener);
    }
    public final void removeComponentListener(ComponentListener listener) {
        componentListeners.remove(listener);
    }
    public final boolean hasComponent(Class<? extends Component> type) {
        return components.has(type);
    }
    public final <T extends Component> Optional<T> getComponentOptional(Class<T> type) {
        return Optional.ofNullable(type.cast(components.get(type)));
    }
    public final <T extends Component> T getComponent(Class<T> type) {
        Component component = components.get(type);
        if (component == null) {
            throw new IllegalArgumentException("Component " + type.getSimpleName() + " not found!");
        }
        return type.cast(component);
    }
    public final List<Component> getComponents() {
        return components.getAll();
    }
    public final void addComponent(Component component) {
        if (isUpdating) {
            log.warning("Cannot add / remove components during updating");
            return;
        }
        if (checkRequirementsMet(component.getClass())) {
            addComponentNoChecks(component);
        }
    }
    private void addComponentNoChecks(Component component) {
        injectFields(component);
        component.onAdded();
        notifyComponentAdded(component);
        components.add(component);
    }
    public final boolean removeComponent(Class<? extends Component> type) {
        if (!hasComponent(type))
            return false;
        if (isCoreComponent(type)) {
            log.warning("Removing a core component: " + type + " is not allowed. Ignoring");
            return false;
        }
        if (isUpdating) {
            log.warning("Cannot add / remove components during updating");
            return false;
        }
        checkNotRequiredByAny(type);
        removeComponent(getComponent(type));
        components.remove(type);
        return true;
    }
    public <T> T call(String componentMethodName, Object... args) {
        ComponentMethod method;
        if (componentMethods.containsKey(componentMethodName)) {
            method = componentMethods.get(componentMethodName);
        } else {
            var types = Arrays.stream(args)
                    .map(Object::getClass)
                    .map(ReflectionUtils::convertToPrimitive)
                    .toArray(Class[]::new);
            method = findMethod(componentMethodName, types)
                    .orElseThrow(() -> new IllegalArgumentException("Cannot find method: " + format(componentMethodName, types)));
            componentMethods.put(componentMethodName, method);
        }
        try {
            return method.call(args);
        } catch (Exception e) {
            String message = "Failed to call: " + format(componentMethodName, args) + " Cause: " + getRootCause(e);
            throw new IllegalArgumentException(message, e);
        }
    }
    private String format(String methodName, Object[] args) {
        String argsString = Arrays.toString(args);
        return methodName + "(" + argsString.substring(1, argsString.length() - 1) + ")";
    }
    private Optional<ComponentMethod> findMethod(String name, Class<?>... types) {
        for (Component c : components.getAll()) {
            try {
                var method = c.getClass().getDeclaredMethod(name, types);
                return Optional.of(new ComponentMethod(c, method));
            } catch (NoSuchMethodException e) {
                continue;
            }
        }
        return Optional.empty();
    }
    private void removeAllComponents() {
        getComponents().forEach(this::removeComponent);
        components.clear();
    }
    @SuppressWarnings("unchecked")
    private void injectFields(Component component) {
        ComponentHelper.setEntity(component, this);
        if (!component.isComponentInjectionRequired())
            return;
        findFieldsByTypeRecursive(component, Component.class).forEach(field -> {
            getComponentOptional((Class<? extends Component>) field.getType()).ifPresent(comp -> {
                inject(field, component, comp);
            });
        });
    }
    private void removeComponent(Component component) {
        notifyComponentRemoved(component);
        component.onRemoved();
        ComponentHelper.setEntity(component, null);
    }
    private <T extends Component> void notifyComponentAdded(T c) {
        componentListeners.forEach(l -> l.onAdded(c));
    }
    private <T extends Component> void notifyComponentRemoved(T c) {
        componentListeners.forEach(l -> l.onRemoved(c));
    }
    private boolean isCoreComponent(Class<? extends Component> type) {
        return type.getAnnotation(CoreComponent.class) != null;
    }
    private boolean checkRequirementsMet(Class<? extends Component> type) {
        if (hasComponent(type)) {
            log.warning("Entity already has component: " + type.getCanonicalName());
            return false;
        }
        for (Required r : type.getAnnotationsByType(Required.class)) {
            if (!hasComponent(r.value())) {
                throw new IllegalStateException("Required component: [" + r.value().getSimpleName() + "] for: " + type.getSimpleName() + " is missing");
            }
        }
        return true;
    }
    private void checkNotRequiredByAny(Class<? extends Component> type) {
        for (Class<? extends Component> t : components.types()) {
            checkNotRequiredBy(t, type);
        }
    }
    private void checkNotRequiredBy(Class<? extends Component> requiringType, Class<? extends Component> type) {
        for (Required required : requiringType.getAnnotationsByType(Required.class)) {
            if (required.value().equals(type)) {
                throw new IllegalArgumentException("Required component: [" + required.value().getSimpleName() + "] by: " + requiringType.getSimpleName());
            }
        }
    }
    public final TypeComponent getTypeComponent() {
        return type;
    }
    public final TransformComponent getTransformComponent() {
        return transform;
    }
    public final BoundingBoxComponent getBoundingBoxComponent() {
        return bbox;
    }
    public final ViewComponent getViewComponent() {
        return view;
    }
    public final Serializable getType() {
        return type.getValue();
    }
    public final void setType(Serializable type) {
        this.type.setValue(type);
    }
    public final boolean isType(Object type) {
        return this.type.isType(type);
    }
    public final ObjectProperty<Serializable> typeProperty() {
        return type.valueProperty();
    }
    public final Point2D getPosition() {
        return transform.getPosition();
    }
    public final Point3D getPosition3D() {
        return transform.getPosition3D();
    }
    public final void setPosition(Point2D position) {
        transform.setPosition(position);
    }
    public final void setPosition(Vec2 position) {
        transform.setPosition(position.x, position.y);
    }
    public final void setPosition3D(Point3D position) {
        transform.setPosition3D(position);
    }
    public final void setPosition(double x, double y) {
        transform.setPosition(x, y);
    }
    public final void setPosition3D(double x, double y, double z) {
        transform.setPosition3D(x, y, z);
    }
    public final double getX() {
        return transform.getX();
    }
    public final double getY() {
        return transform.getY();
    }
    public final double getZ() {
        return transform.getZ();
    }
    public final void setX(double x) {
        transform.setX(x);
    }
    public final void setY(double y) {
        transform.setY(y);
    }
    public final void setZ(double z) {
        transform.setZ(z);
    }
    @Override
    public final DoubleProperty xProperty() {
        return transform.xProperty();
    }
    @Override
    public final DoubleProperty yProperty() {
        return transform.yProperty();
    }
    @Override
    public final DoubleProperty zProperty() {
        return transform.zProperty();
    }
    public final Point2D getLocalAnchor() {
        return transform.getLocalAnchor();
    }
    public final void setLocalAnchorFromCenter() {
        setLocalAnchor(bbox.getCenterLocal());
    }
    public final void setLocalAnchor(Point2D localAnchor) {
        transform.setLocalAnchor(localAnchor);
    }
    public final void setAnchoredPosition(double x, double y) {
        transform.setAnchoredPosition(new Point2D(x, y));
    }
    public final void setAnchoredPosition(Point2D p) {
        transform.setAnchoredPosition(p);
    }
    public final void setAnchoredPosition(double x, double y, Point2D localAnchor) {
        setPosition(x - localAnchor.getX(), y - localAnchor.getY());
    }
    public final Point2D getAnchoredPosition() {
        return transform.getAnchoredPosition();
    }
    public final Point2D getAnchoredPosition(Point2D localAnchor) {
        return new Point2D(getX() + localAnchor.getX(), getY() + localAnchor.getY());
    }
    public final void translate(Point2D vector) {
        transform.translate(vector);
    }
    public final void translate(Vec2 vector) {
        transform.translate(vector.x, vector.y);
    }
    public final void translate(double dx, double dy) {
        transform.translate(dx, dy);
    }
    public final void translate3D(Point3D vector) {
        transform.translate3D(vector);
    }
    public final void translate3D(double dx, double dy, double dz) {
        transform.translate3D(dx, dy, dz);
    }
    public final void translateX(double dx) {
        transform.translateX(dx);
    }
    public final void translateY(double dy) {
        transform.translateY(dy);
    }
    public final void translateZ(double dz) {
        transform.translateZ(dz);
    }
    public final void translateTowards(Point2D point, double distance) {
        transform.translateTowards(point, distance);
    }
    public final double distance(Entity other) {
        return transform.distance(other.transform);
    }
    public final double distanceBBox(Entity other) {
        var rect1 = bbox.range(0, 0);
        var rect2 = other.bbox.range(0, 0);
        return FXGLMath.distance(rect1, rect2);
    }
    public final double getRotation() {
        return transform.getAngle();
    }
    public final void setRotation(double angle) {
        transform.setAngle(angle);
    }
    public final DoubleProperty angleProperty() {
        return transform.angleProperty();
    }
    public final void rotateBy(double angle) {
        transform.rotateBy(angle);
    }
    public final void rotateToVector(Point2D vector) {
        transform.rotateToVector(vector);
    }
    public final void setScaleUniform(double scale) {
        setScaleX(scale);
        setScaleY(scale);
        setScaleZ(scale);
    }
    public final void setScaleX(double scaleX) {
        transform.setScaleX(scaleX);
    }
    public final void setScaleY(double scaleY) {
        transform.setScaleY(scaleY);
    }
    public final void setScaleZ(double scaleZ) {
        transform.setScaleZ(scaleZ);
    }
    public final double getScaleX() {
        return transform.getScaleX();
    }
    public final double getScaleY() {
        return transform.getScaleY();
    }
    public final double getScaleZ() {
        return transform.getScaleZ();
    }
    public final double getWidth() {
        return bbox.getWidth();
    }
    public final double getHeight() {
        return bbox.getHeight();
    }
    public final ReadOnlyDoubleProperty widthProperty() {
        return bbox.widthProperty();
    }
    public final ReadOnlyDoubleProperty heightProperty() {
        return bbox.heightProperty();
    }
    public final double getRightX() {
        return bbox.getMaxXWorld();
    }
    public final double getBottomY() {
        return bbox.getMaxYWorld();
    }
    public final Point2D getCenter() {
        return bbox.getCenterWorld();
    }
    public final boolean isColliding(Entity other) {
        return bbox.isCollidingWith(other.bbox);
    }
    public final boolean isWithin(Rectangle2D bounds) {
        return bbox.isWithin(bounds);
    }
    public final void setOpacity(double opacity) {
        view.setOpacity(opacity);
    }
    public final double getOpacity() {
        return view.getOpacity();
    }
    public final void setVisible(boolean isVisible) {
        view.setVisible(isVisible);
    }
    public final boolean isVisible() {
        return view.isVisible();
    }
    public final void setZIndex(int z) {
        view.setZIndex(z);
    }
    public final int getZIndex() {
        return view.getZIndex();
    }
    @Override
    public DoubleProperty scaleXProperty() {
        return transform.scaleXProperty();
    }
    @Override
    public DoubleProperty scaleYProperty() {
        return transform.scaleYProperty();
    }
    @Override
    public DoubleProperty scaleZProperty() {
        return transform.scaleZProperty();
    }
    @Override
    public DoubleProperty rotationXProperty() {
        return transform.rotationXProperty();
    }
    @Override
    public DoubleProperty rotationYProperty() {
        return transform.rotationYProperty();
    }
    @Override
    public DoubleProperty rotationZProperty() {
        return transform.rotationZProperty();
    }
    @Override
    public DoubleProperty opacityProperty() {
        return view.opacityProperty();
    }
    public void setScaleOrigin(Point2D pivotPoint) {
        transform.setScaleOrigin(pivotPoint);
    }
    public void setRotationOrigin(Point2D pivotPoint) {
        transform.setRotationOrigin(pivotPoint);
    }
    @Override
    public void setScaleOrigin(Point3D pivotPoint) {
        transform.setScaleOrigin3D(pivotPoint);
    }
    @Override
    public void setRotationOrigin(Point3D pivotPoint) {
        transform.setRotationOrigin3D(pivotPoint);
    }
    @Override
    public Entity copy() {
        return EntityHelper.INSTANCE.copy(this);
    }
    @Override
    public String toString() {
        List<Component> comps = getComponents();
        List<String> coreComponentsAsString = new ArrayList<>(comps.size());
        List<String> otherComponentsAsString = new ArrayList<>(comps.size());
        comps.forEach(c -> {
            if (isCoreComponent(c.getClass())) {
                coreComponentsAsString.add(c.toString());
            } else {
                otherComponentsAsString.add(c.toString());
            }
        });
        Collections.sort(coreComponentsAsString);
        Collections.sort(otherComponentsAsString);
        return "Entity(" + coreComponentsAsString + otherComponentsAsString + ")";
    }
}
package sandbox.joints;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.dsl.components.ExpireCleanComponent;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyDef;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import com.almasb.fxgl.physics.box2d.dynamics.joints.DistanceJointDef;
import com.almasb.fxgl.physics.box2d.dynamics.joints.GearJointDef;
import com.almasb.fxgl.physics.box2d.dynamics.joints.RopeJoint;
import javafx.geometry.HorizontalDirection;
import javafx.geometry.Point2D;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class DistanceJointSample extends GameApplication {
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
    }
    @Override
    protected void initInput() {
        getInput().addAction(new UserAction("LMB") {
            private double x;
            private double y;
            @Override
            protected void onActionBegin() {
                x = getInput().getMouseXWorld();
                y = getInput().getMouseYWorld();
            }
            @Override
            protected void onActionEnd() {
                var endx = getInput().getMouseXWorld();
                var endy = getInput().getMouseYWorld();
                spawnBullet(x, y, endx - x, endy - y);
            }
        }, MouseButton.PRIMARY);
        onKeyDown(KeyCode.F, () -> {
            Entity box = createPhysicsEntity();
            box.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Left", BoundingShape.box(40, 40)));
            box.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Right", new Point2D(40, 0), BoundingShape.box(40, 40)));
            box.getViewComponent().addChild(texture("brick.png", 40, 40).superTexture(texture("brick.png", 40, 40), HorizontalDirection.RIGHT));
            box.setRotationOrigin(new Point2D(40, 20));
            box.setScaleX(random(0.1, 1.5));
            box.setScaleY(random(0.1, 1.5));
            getGameWorld().addEntity(box);
        });
        onBtnDown(MouseButton.SECONDARY, () -> {
            Entity ball = createPhysicsEntity();
            ball.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Test", BoundingShape.circle(20)));
            ball.getViewComponent().addChild(texture("ball.png", 40, 40));
            ball.setRotationOrigin(new Point2D(20, 20));
            getGameWorld().addEntity(ball);
            joint = getPhysicsWorld().addRopeJoint(ball, theball);
            line = new Line();
            addUINode(line);
            line.startXProperty().bind(ball.xProperty().add(20));
            line.startYProperty().bind(ball.yProperty().add(20));
            line.endXProperty().bind(theball.xProperty().add(20));
            line.endYProperty().bind(theball.yProperty().add(20));
        });
        onKeyDown(KeyCode.G, () -> {
        });
    }
    private Line line;
    private RopeJoint joint;
    private Entity theball;
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.LIGHTGRAY);
        entityBuilder()
                .buildScreenBoundsAndAttach(50);
        Entity first = null;
        for (int i = 0; i < 15; i++) {
            var b = createPhysicsEntity();
            b.setPosition(
                    270 + i * 50, 350
            );
            b.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Test", BoundingShape.circle(20)));
            b.getViewComponent().addChild(texture("ball.png", 40, 40));
            b.setRotationOrigin(new Point2D(20, 20));
            if (first == null) {
                first = b;
                first.getComponent(PhysicsComponent.class).setBodyType(BodyType.STATIC);
                getGameWorld().addEntity(b);
            } else {
                if (i == 14) {
                    b.getComponent(PhysicsComponent.class).setBodyType(BodyType.STATIC);
                }
                getGameWorld().addEntity(b);
                var jointDef = new DistanceJointDef();
                jointDef.length = 1f;
                jointDef.dampingRatio = 0.5f;
                var distanceJoint = getPhysicsWorld().addJoint(first, b, jointDef);
                first = b;
            }
        }
    }
    private void spawnBullet(double x, double y, double vx, double vy) {
        var physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(25.5f).restitution(0.5f));
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setOnPhysicsInitialized(() -> {
            physics.setLinearVelocity(vx * 10, vy * 10);
        });
        entityBuilder()
                .at(x, y)
                .bbox(new HitBox(BoundingShape.circle(450 / 15.0 / 2.0)))
                .view(texture("ball.png", 450 / 15.0, 449 / 15.0).multiplyColor(Color.RED))
                .with(physics)
                .with(new ExpireCleanComponent(Duration.seconds(5)).animateOpacity())
                .buildAndAttach();
    }
    private Entity createPhysicsEntity() {
        PhysicsComponent physics = new PhysicsComponent();
        physics.setBodyType(BodyType.DYNAMIC);
        var bd = new BodyDef();
        bd.setFixedRotation(true);
        bd.setType(BodyType.DYNAMIC);
        physics.setFixtureDef(new FixtureDef().density(0.1f).restitution(0.3f));
        return entityBuilder()
                .at(getInput().getMousePositionWorld())
                .with(physics)
                .build();
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package com.almasb.fxgl.physics;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.entity.components.BoundingBoxComponent;
import com.almasb.fxgl.entity.components.TransformComponent;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import javafx.beans.binding.Bindings;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.Point2D;
import java.io.Serializable;
import static com.almasb.fxgl.core.math.FXGLMath.cosDegF;
import static com.almasb.fxgl.core.math.FXGLMath.sinDegF;
public final class HitBox implements Serializable {
    private String name;
    private BoundingShape shape;
    private Bounds bounds;
    Vec2[] axes = new Vec2[2];
    Vec2[] corners = new Vec2[4];
    public HitBox(BoundingShape shape) {
        this(String.valueOf(shape.hashCode()), shape);
    }
    public HitBox(Point2D localOrigin, BoundingShape shape){
        this(String.valueOf(shape.hashCode()), localOrigin, shape);
    }
    public HitBox(String name, BoundingShape shape) {
        this(name, Point2D.ZERO, shape);
    }
    public HitBox(String name, Point2D localOrigin, BoundingShape shape) {
        this.name = name;
        this.shape = shape;
        this.bounds = new BoundingBox(localOrigin.getX(), localOrigin.getY(),
                shape.getSize().getWidth(), shape.getSize().getHeight());
        axes[0] = new Vec2();
        axes[1] = new Vec2();
        for (int i = 0; i < 4; i++) {
            corners[i] = new Vec2();
        }
    }
    public Bounds getBounds() {
        return bounds;
    }
    public BoundingShape getShape() {
        return shape;
    }
    public double getMinX() {
        return bounds.getMinX();
    }
    public double getMinY() {
        return bounds.getMinY();
    }
    public double getMaxX() {
        return bounds.getMaxX();
    }
    public double getMaxY() {
        return bounds.getMaxY();
    }
    public double getWidth() {
        return getMaxXWorld() - getMinXWorld();
    }
    public double getHeight() {
        return getMaxYWorld() - getMinYWorld();
    }
    public String getName() {
        return name;
    }
    private transient DoubleProperty minXWorld = new SimpleDoubleProperty();
    private transient DoubleProperty maxXWorld = new SimpleDoubleProperty();
    private transient DoubleProperty minYWorld = new SimpleDoubleProperty();
    private transient DoubleProperty maxYWorld = new SimpleDoubleProperty();
    public void bindXY(TransformComponent transform) {
        var x1 = Bindings.createDoubleBinding(() ->
                        transform.getScaleOrigin().getX() - (transform.getScaleOrigin().getX() - getMinX()) * transform.getScaleX() + transform.getX(),
                transform.scaleOriginXProperty(), transform.scaleXProperty(), transform.xProperty()
        );
        var x2 = Bindings.createDoubleBinding(() ->
                        transform.getScaleOrigin().getX() - (transform.getScaleOrigin().getX() - getMaxX()) * transform.getScaleX() + transform.getX(),
                transform.scaleOriginXProperty(), transform.scaleXProperty(), transform.xProperty()
        );
        var y1 = Bindings.createDoubleBinding(() ->
                        transform.getScaleOrigin().getY() - (transform.getScaleOrigin().getY() - getMinY()) * transform.getScaleY() + transform.getY(),
                transform.scaleOriginYProperty(), transform.scaleYProperty(), transform.yProperty()
        );
        var y2 = Bindings.createDoubleBinding(() ->
                        transform.getScaleOrigin().getY() - (transform.getScaleOrigin().getY() - getMaxY()) * transform.getScaleY() + transform.getY(),
                transform.scaleOriginYProperty(), transform.scaleYProperty(), transform.yProperty()
        );
        var isX1GreaterX2 = x1.greaterThan(x2);
        var isY1GreaterY2 = y1.greaterThan(y2);
        minXWorld.bind(
                Bindings.when(isX1GreaterX2).then(x2).otherwise(x1)
        );
        maxXWorld.bind(
                Bindings.when(isX1GreaterX2).then(x1).otherwise(x2)
        );
        minYWorld.bind(
                Bindings.when(isY1GreaterY2).then(y2).otherwise(y1)
        );
        maxYWorld.bind(
                Bindings.when(isY1GreaterY2).then(y1).otherwise(y2)
        );
    }
    public void unbind() {
        minXWorld.unbind();
        maxXWorld.unbind();
        minYWorld.unbind();
        maxYWorld.unbind();
    }
    public double getMinXWorld() {
        return minXWorld.get();
    }
    public double getMaxXWorld() {
        return maxXWorld.get();
    }
    public double getMinYWorld() {
        return minYWorld.get();
    }
    public double getMaxYWorld() {
        return maxYWorld.get();
    }
    public Point2D getCenterWorld() {
        return new Point2D((getMinXWorld() + getMaxXWorld()) / 2, (getMinYWorld() + getMaxYWorld()) / 2);
    }
    public Point2D centerLocal() {
        return new Point2D((bounds.getMinX() + bounds.getMaxX()) / 2,
                (bounds.getMinY() + bounds.getMaxY()) / 2);
    }
    public Point2D centerWorld(double x, double y) {
        return centerLocal().add(x, y);
    }
    public Shape toBox2DShape(BoundingBoxComponent bbox, PhysicsUnitConverter converter) {
        return shape.toBox2DShape(this, bbox, converter);
    }
    float fastMinX;
    float fastMinY;
    float fastMaxX;
    float fastMaxY;
    public float getFastMinX() {
        return fastMinX;
    }
    public float getFastMinY() {
        return fastMinY;
    }
    public float getFastMaxX() {
        return fastMaxX;
    }
    public float getFastMaxY() {
        return fastMaxY;
    }
    SAT.MinMax axis1MinMax = new SAT.MinMax();
    SAT.MinMax axis2MinMax = new SAT.MinMax();
    public void applyTransform(TransformComponent transform) {
        double x1 = transform.getScaleOrigin().getX() - (transform.getScaleOrigin().getX() - getMinX()) * transform.getScaleX() + transform.getX();
        double x2 = transform.getScaleOrigin().getX() - (transform.getScaleOrigin().getX() - getMaxX()) * transform.getScaleX() + transform.getX();
        double y1 = transform.getScaleOrigin().getY() - (transform.getScaleOrigin().getY() - getMinY()) * transform.getScaleY() + transform.getY();
        double y2 = transform.getScaleOrigin().getY() - (transform.getScaleOrigin().getY() - getMaxY()) * transform.getScaleY() + transform.getY();
        fastMinX = (float) Math.min(x1, x2);
        fastMinY = (float) Math.min(y1, y2);
        fastMaxX = (float) Math.max(x1, x2);
        fastMaxY = (float) Math.max(y1, y2);
        double angle = transform.getAngle();
        float cos = cosDegF(angle);
        float sin = sinDegF(angle);
        axes[0].set(cos, sin).normalizeLocal();
        axes[1].set(cosDegF(angle + 90), sinDegF(angle + 90)).normalizeLocal();
        corners[0].set(fastMinX, fastMinY);
        corners[1].set(fastMaxX, fastMinY);
        corners[2].set(fastMaxX, fastMaxY);
        corners[3].set(fastMinX, fastMaxY);
        if (angle != 0.0) {
            var origin = transform.getRotationOrigin();
            double originX = origin.getX() + transform.getX();
            double originY = origin.getY() + transform.getY();
            for (Vec2 v : corners) {
                v.subLocal(originX, originY);
                v.set(v.x * cos - v.y * sin, v.x * sin + v.y * cos);
                v.addLocal(originX, originY);
            }
        }
        SAT.computeMinMax(corners, axes[0], axis1MinMax);
        SAT.computeMinMax(corners, axes[1], axis2MinMax);
    }
    @Override
    public String toString() {
        return "HitBox(" + name + "," + shape + ")";
    }
}
package sandbox.joints;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.dsl.components.ExpireCleanComponent;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.geometry.HorizontalDirection;
import javafx.geometry.Point2D;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class RopeJointSample extends GameApplication {
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
    }
    @Override
    protected void initInput() {
        getInput().addAction(new UserAction("LMB") {
            private double x;
            private double y;
            @Override
            protected void onActionBegin() {
                x = getInput().getMouseXWorld();
                y = getInput().getMouseYWorld();
            }
            @Override
            protected void onActionEnd() {
                var endx = getInput().getMouseXWorld();
                var endy = getInput().getMouseYWorld();
                spawnBullet(x, y, endx - x, endy - y);
            }
        }, MouseButton.PRIMARY);
        onKeyDown(KeyCode.F, () -> {
            Entity box = createPhysicsEntity();
            box.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Left", BoundingShape.box(40, 40)));
            box.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Right", new Point2D(40, 0), BoundingShape.box(40, 40)));
            box.getViewComponent().addChild(texture("brick.png", 40, 40).superTexture(texture("brick.png", 40, 40), HorizontalDirection.RIGHT));
            box.setRotationOrigin(new Point2D(40, 20));
            getGameWorld().addEntity(box);
        });
        onBtnDown(MouseButton.SECONDARY, () -> {
            Entity ball = createPhysicsEntity();
            ball.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Test", BoundingShape.circle(20)));
            ball.getViewComponent().addChild(texture("ball.png", 40, 40));
            ball.setRotationOrigin(new Point2D(20, 20));
            getGameWorld().addEntity(ball);
        });
    }
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.LIGHTGRAY);
        entityBuilder()
                .buildScreenBoundsAndAttach(50);
        entityBuilder()
                .at(400, 400)
                .viewWithBBox(new Rectangle(500, 20, Color.BROWN))
                .with(new PhysicsComponent())
                .buildAndAttach();
        PhysicsComponent physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(1.1f));
        physics.setBodyType(BodyType.DYNAMIC);
        Entity last = null;
        for (int i = 0; i < 10; i++) {
            PhysicsComponent physics2 = new PhysicsComponent();
            if (last != null) {
                physics2.setBodyType(BodyType.DYNAMIC);
            }
            FixtureDef fd = new FixtureDef();
            fd.setDensity(1.0f);
            physics2.setFixtureDef(fd);
            Entity ball = entityBuilder()
                    .at(400 + i * 30, 160)
                    .bbox(new HitBox("main", BoundingShape.circle(15)))
                    .view(texture("ball.png", 30, 30))
                    .with(physics2)
                    .buildAndAttach();
            physics2.getBody().setAngularDamping(1f);
            if (last != null) {
                var joint = getPhysicsWorld().addRopeJoint(last, ball);
            }
            last = ball;
        }
    }
    private void spawnBullet(double x, double y, double vx, double vy) {
        var physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(25.5f).restitution(0.5f));
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setOnPhysicsInitialized(() -> {
            physics.setLinearVelocity(vx * 10, vy * 10);
        });
        entityBuilder()
                .at(x, y)
                .bbox(new HitBox(BoundingShape.circle(450 / 15.0 / 2.0)))
                .view(texture("ball.png", 450 / 15.0, 449 / 15.0))
                .with(physics)
                .with(new ExpireCleanComponent(Duration.seconds(5)).animateOpacity())
                .buildAndAttach();
    }
    private Entity createPhysicsEntity() {
        PhysicsComponent physics = new PhysicsComponent();
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setFixtureDef(new FixtureDef().density(0.1f).restitution(0.3f));
        return entityBuilder()
                .at(getInput().getMousePositionWorld())
                .with(physics)
                .build();
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package advanced.physics;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.scene.control.Button;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class FlyingKeysPhysicsSample extends GameApplication {
    private static final String ALPHABET = "abcdefghijklmnopqrstuvwxyz";
    private static final int BUTTON_WIDTH = 40;
    private static final int BUTTON_HEIGHT = 50;
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
        settings.setRandomSeed(4321);
    }
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.BLACK);
        entityBuilder().buildScreenBoundsAndAttach(50);
        for (int i = 0; i < ALPHABET.length(); i++) {
            addButtonEntity(5 + i * (BUTTON_WIDTH + 6), 250, ALPHABET.charAt(i));
        }
        run(() -> {
            getPhysicsWorld().setGravity(FXGLMath.random(-10, 10) * 55, FXGLMath.random(-10, 10) * 55);
        }, Duration.seconds(2.1));
    }
    private void addButtonEntity(double x, double y, char c) {
        PhysicsComponent physics = new PhysicsComponent();
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setFixtureDef(new FixtureDef().density(0.7f).restitution(0.3f));
        Button button = new Button(c + "");
        button.setFont(Font.font(18));
        button.setPrefWidth(BUTTON_WIDTH);
        button.setPrefHeight(BUTTON_HEIGHT);
        entityBuilder()
                .at(x, y)
                .bbox(BoundingShape.box(BUTTON_WIDTH, BUTTON_HEIGHT))
                .view(button)
                .with(physics)
                .buildAndAttach();
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package com.almasb.fxgl.core.math;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.paint.Color;
import java.util.List;
import java.util.Optional;
import java.util.Random;
public final class FXGLMath {
    private FXGLMath() {}
    public static final double EPSILON = 1.1920928955078125E-7;
    public static final double PI = Math.PI;
    public static final double PI2 = PI * 2;
    public static final double HALF_PI = PI / 2;
    public static final float PI_F = (float) Math.PI;
    public static final float PI2_F = (float) (Math.PI * 2);
    public static final float HALF_PI_F = PI_F / 2;
    public static final double E = Math.E;
    private static final int SIN_BITS = 14; 
    private static final int SIN_MASK = ~(-1 << SIN_BITS);
    private static final int SIN_COUNT = SIN_MASK + 1;
    private static final double radFull = PI * 2;
    private static final double degFull = 360;
    private static final double radToIndex = SIN_COUNT / radFull;
    private static final double degToIndex = SIN_COUNT / degFull;
    private static class Sin {
        static final double[] table = new double[SIN_COUNT];
        static {
            for (int i = 0; i < SIN_COUNT; i++)
                table[i] = Math.sin((i + 0.5f) / SIN_COUNT * radFull);
            for (int i = 0; i < 360; i += 90)
                table[(int) (i * degToIndex) & SIN_MASK] = Math.sin(toRadians(i));
        }
    }
    public static double sin(double radians) {
        return Sin.table[(int) (radians * radToIndex) & SIN_MASK];
    }
    public static double cos(double radians) {
        return Sin.table[(int) ((radians + PI / 2) * radToIndex) & SIN_MASK];
    }
    public static double sinDeg(double degrees) {
        return Sin.table[(int) (degrees * degToIndex) & SIN_MASK];
    }
    public static double cosDeg(double degrees) {
        return Sin.table[(int) ((degrees + 90) * degToIndex) & SIN_MASK];
    }
    public static float sinF(double radians) {
        return (float) sin(radians);
    }
    public static float cosF(double radians) {
        return (float) cos(radians);
    }
    public static float sinDegF(double degrees) {
        return (float) sinDeg(degrees);
    }
    public static float cosDegF(double degrees) {
        return (float) cosDeg(degrees);
    }
    private static final double radiansToDegrees = 180 / PI;
    private static final double degreesToRadians = PI / 180;
    public static double toDegrees(double radians) {
        return radiansToDegrees * radians;
    }
    public static double toRadians(double degrees) {
        return degreesToRadians * degrees;
    }
    public static double atan2(double y, double x) {
        if (x == 0.0) {
            if (y > 0) return HALF_PI;
            if (y == 0.0) return 0.0;
            return -HALF_PI;
        }
        final double atan;
        final double z = y / x;
        if (Math.abs(z) < 1) {
            atan = z / (1 + 0.28 * z * z);
            if (x < 0) return atan + (y < 0 ? -PI : PI);
            return atan;
        }
        atan = HALF_PI - z / (z * z + 0.28);
        return y < 0 ? atan - PI : atan;
    }
    public static double atan2Deg(double y, double x) {
        return toDegrees(atan2(y, x));
    }
    public static Point2D rotate(Point2D point, Point2D pivot, double angle) {
        double px = point.getX() - pivot.getX();
        double py = point.getY() - pivot.getY();
        double c = cosDeg(angle);
        double s = sinDeg(angle);
        double pxNew = px * c - py * s;
        double pyNew = px * s + py * c;
        return new Point2D(pxNew + pivot.getX(), pyNew + pivot.getY());
    }
    public static Point2D scale(Point2D point, Point2D pivot, double factor) {
        return new Point2D(
                scale1D(point.getX(), pivot.getX(), factor),
                scale1D(point.getY(), pivot.getY(), factor)
        );
    }
    public static double scale1D(double x, double pivot, double factor) {
        return (x - pivot) * factor + pivot;
    }
    private static Random random = new Random();
    public static void setRandom(Random random) {
        FXGLMath.random = random;
    }
    public static Random getRandom() {
        return random;
    }
    public static Random getRandom(long seed) {
        return new Random(seed);
    }
    public static int random(int start, int end) {
        return start + random.nextInt(end - start + 1);
    }
    public static long random(long start, long end) {
        return start + (long) (random.nextDouble() * (end - start));
    }
    public static double random(double start, double end) {
        return start + random.nextDouble() * (end - start);
    }
    public static double randomDouble() {
        return random.nextDouble();
    }
    public static float randomFloat() {
        return random.nextFloat();
    }
    public static boolean randomBoolean() {
        return random.nextBoolean();
    }
    public static boolean randomBoolean(double chance) {
        return randomDouble() < chance;
    }
    public static int randomSign() {
        return 1 | (random.nextInt() >> 31);
    }
    public static Point2D randomPoint(Rectangle2D bounds) {
        return new Point2D(
                random(bounds.getMinX(), bounds.getMaxX()),
                random(bounds.getMinY(), bounds.getMaxY())
        );
    }
    public static Point2D randomPoint2D() {
        return randomVec2().toPoint2D();
    }
    public static Vec2 randomVec2() {
        return new Vec2(random(-1.0, 1.0), random(-1.0, 1.0)).normalizeLocal();
    }
    public static Color randomColor() {
        return Color.color(randomDouble(), randomDouble(), randomDouble());
    }
    public static Color randomColorHSB(double saturation, double brightness) {
        return Color.hsb(random(0, 360), saturation, brightness);
    }
    public static <T> Optional<T> random(T[] array) {
        if (array.length == 0)
            return Optional.empty();
        return Optional.of(array[random(0, array.length - 1)]);
    }
    public static <T> Optional<T> random(List<T> list) {
        if (list.isEmpty())
            return Optional.empty();
        return Optional.of(list.get(random(0, list.size() - 1)));
    }
    public static double sqrt(double x) {
        return Math.sqrt(x);
    }
    public static float sqrtF(float x) {
        return (float) StrictMath.sqrt(x);
    }
    public static double map(double value, double currentRangeStart, double currentRangeStop, double targetRangeStart, double targetRangeStop) {
        return targetRangeStart + (targetRangeStop - targetRangeStart) * ((value - currentRangeStart) / (currentRangeStop - currentRangeStart));
    }
    public static float clamp(float a, float low, float high) {
        return Math.max(low, Math.min(a, high));
    }
    public static int floor(float x) {
        int y = (int) x;
        if (x < y) {
            return y - 1;
        }
        return y;
    }
    public static float abs(float value) {
        return value > 0 ? value : -value;
    }
    public static double abs(double value) {
        return value > 0 ? value : -value;
    }
    public static float min(float a, float b) {
        return a < b ? a : b;
    }
    public static float max(float a, float b) {
        return a > b ? a : b;
    }
    public static Point2D bezier(Point2D p1, Point2D p2, Point2D p3, double t) {
        double x = (1 - t) * (1 - t) * p1.getX() + 2 * (1 - t) * t * p2.getX() + t * t * p3.getX();
        double y = (1 - t) * (1 - t) * p1.getY() + 2 * (1 - t) * t * p2.getY() + t * t * p3.getY();
        return new Point2D(x, y);
    }
    public static Point2D bezier(Point2D p1, Point2D p2, Point2D p3, Point2D p4, double t) {
        double x = Math.pow(1 - t, 3) * p1.getX() + 3 * t * Math.pow(1 - t, 2) * p2.getX() + 3 * t*t * (1 - t) * p3.getX() + t*t*t*p4.getX();
        double y = Math.pow(1 - t, 3) * p1.getY() + 3 * t * Math.pow(1 - t, 2) * p2.getY() + 3 * t*t * (1 - t) * p3.getY() + t*t*t*p4.getY();
        return new Point2D(x, y);
    }
    private static final PerlinNoiseGenerator generator = getNoise1DGenerator(0L);
    public static double noise1D(double t) { return generator.noise1D(t); }
    public static PerlinNoiseGenerator getNoise1DGenerator(long seed) {
        return new PerlinNoiseGenerator(seed);
    }
    public static double noise2D(double x, double y) {
        return SimplexNoise.noise2D(x, y);
    }
    public static double noise3D(double x, double y, double z) {
        return SimplexNoise.noise3D(x, y, z);
    }
    public static double distance(Rectangle2D rect1, Rectangle2D rect2) {
        return Distances.INSTANCE.distance(rect1, rect2);
    }
}
package com.almasb.fxgl.physics.box2d.dynamics;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.physics.box2d.collision.broadphase.BroadPhase;
import com.almasb.fxgl.physics.box2d.collision.shapes.MassData;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.common.Rotation;
import com.almasb.fxgl.physics.box2d.common.Sweep;
import com.almasb.fxgl.physics.box2d.common.Transform;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.ContactEdge;
import com.almasb.fxgl.physics.box2d.dynamics.joints.JointEdge;
import java.util.ArrayList;
import java.util.List;
public final class Body {
    private static final int e_islandFlag = 0x0001;
    private static final int e_awakeFlag = 0x0002;
    private static final int e_bulletFlag = 0x0008;
    private static final int e_fixedRotationFlag = 0x0010;
    private static final int e_activeFlag = 0x0020;
    private final World world;
    private BodyType type;
    private List<Fixture> fixtures = new ArrayList<>();
    public JointEdge m_jointList = null;
    public ContactEdge m_contactList = null;
    public int m_flags = 0;
    private boolean isSleepingAllowed = false;
    public int m_islandIndex;
    public final Transform m_xf = new Transform();
    public final Transform m_xf0 = new Transform();
    public final Sweep m_sweep = new Sweep();
    private final Vec2 linearVelocity = new Vec2();
    private float angularVelocity;
    private final Vec2 m_force = new Vec2();
    private float m_torque = 0;
    private float m_mass;
    public float m_invMass;
    private float m_I = 0;
    public float m_invI = 0;
    private float linearDamping;
    private float angularDamping;
    private float gravityScale;
    private float sleepTime = 0;
    private final BroadPhase broadPhase;
    private Object userData;
    private Entity entity;
    Body(BodyDef bd, World world) {
        checkValid(bd);
        this.world = world;
        broadPhase = world.getContactManager().broadPhase;
        userData = bd.getUserData();
        if (bd.isBullet()) {
            m_flags |= e_bulletFlag;
        }
        if (bd.isFixedRotation()) {
            m_flags |= e_fixedRotationFlag;
        }
        if (bd.isAllowSleep()) {
            isSleepingAllowed = true;
        }
        if (bd.isAwake()) {
            m_flags |= e_awakeFlag;
        }
        if (bd.isActive()) {
            m_flags |= e_activeFlag;
        }
        m_xf.p.set(bd.getPosition());
        m_xf.q.set(bd.getAngle());
        m_sweep.localCenter.setZero();
        m_sweep.c0.set(m_xf.p);
        m_sweep.c.set(m_xf.p);
        m_sweep.a0 = bd.getAngle();
        m_sweep.a = bd.getAngle();
        m_sweep.alpha0 = 0.0f;
        linearVelocity.set(bd.getLinearVelocity());
        angularVelocity = bd.getAngularVelocity();
        linearDamping = bd.getLinearDamping();
        angularDamping = bd.getAngularDamping();
        gravityScale = bd.getGravityScale();
        type = bd.getType();
        if (type == BodyType.DYNAMIC) {
            m_mass = 1f;
            m_invMass = 1f;
        } else {
            m_mass = 0f;
            m_invMass = 0f;
        }
    }
    private void checkValid(BodyDef def) {
        if (def.getGravityScale() < 0)
            throw new IllegalArgumentException("Gravity scale is invalid");
        if (def.getAngularDamping() < 0)
            throw new IllegalArgumentException("Angular damping is invalid");
        if (def.getLinearDamping() < 0)
            throw new IllegalArgumentException("Linear damping is invalid");
    }
    public float getTorque() {
        return m_torque;
    }
    public void setTorque(float torque) {
        m_torque = torque;
    }
    public void setEntity(Entity entity) {
        this.entity = entity;
    }
    public Entity getEntity() {
        return entity;
    }
    public List<Fixture> getFixtures() {
        return fixtures;
    }
    public Fixture createFixture(FixtureDef def) {
        world.assertNotLocked();
        Fixture fixture = new Fixture(this, def);
        if ((m_flags & e_activeFlag) == e_activeFlag) {
            fixture.createProxies(broadPhase, m_xf);
        }
        fixtures.add(fixture);
        if (fixture.getDensity() > 0) {
            resetMassData();
        }
        world.notifyNewFixture();
        return fixture;
    }
    private final FixtureDef fixDef = new FixtureDef();
    public Fixture createFixture(Shape shape, float density) {
        fixDef.setShape(shape);
        fixDef.setDensity(density);
        return createFixture(fixDef);
    }
    public void destroyFixture(Fixture fixture) {
        world.assertNotLocked();
        fixtures.remove(fixture);
        ContactEdge edge = m_contactList;
        while (edge != null) {
            Contact c = edge.contact;
            edge = edge.next;
            if (fixture == c.getFixtureA() || fixture == c.getFixtureB()) {
                world.getContactManager().destroy(c);
            }
        }
        if ((m_flags & e_activeFlag) == e_activeFlag) {
            fixture.destroyProxies(broadPhase);
        }
        fixture.destroy();
        resetMassData();
    }
    public void setTransform(Vec2 position, float angle) {
        world.assertNotLocked();
        m_xf.q.set(angle);
        m_xf.p.set(position);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c);
        m_sweep.a = angle;
        m_sweep.c0.set(m_sweep.c);
        m_sweep.a0 = m_sweep.a;
        for (Fixture f : fixtures) {
            f.synchronize(broadPhase, m_xf, m_xf);
        }
    }
    public Transform getTransform() {
        return m_xf;
    }
    public Vec2 getPosition() {
        return m_xf.p;
    }
    public float getAngle() {
        return m_sweep.a;
    }
    public Vec2 getWorldCenter() {
        return m_sweep.c;
    }
    public Vec2 getLocalCenter() {
        return m_sweep.localCenter;
    }
    public void setLinearVelocity(Vec2 v) {
        if (type == BodyType.STATIC) {
            return;
        }
        if (Vec2.dot(v, v) > 0) {
            setAwake(true);
        }
        linearVelocity.set(v);
    }
    void setLinearVelocityDirectly(float vx, float vy) {
        linearVelocity.set(vx, vy);
    }
    public Vec2 getLinearVelocity() {
        return linearVelocity;
    }
    public void setAngularVelocity(float w) {
        if (type == BodyType.STATIC) {
            return;
        }
        if (w * w > 0f) {
            setAwake(true);
        }
        angularVelocity = w;
    }
    void setAngularVelocityDirectly(float angularVelocity) {
        this.angularVelocity = angularVelocity;
    }
    public float getAngularVelocity() {
        return angularVelocity;
    }
    public float getGravityScale() {
        return gravityScale;
    }
    public void setGravityScale(float gravityScale) {
        this.gravityScale = gravityScale;
    }
    public void applyForce(Vec2 force, Vec2 point) {
        applyForceToCenter(force);
        m_torque += (point.x - m_sweep.c.x) * force.y - (point.y - m_sweep.c.y) * force.x;
    }
    public void applyForceToCenter(Vec2 force) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        m_force.addLocal(force);
    }
    public void applyTorque(float torque) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        m_torque += torque;
    }
    public void applyLinearImpulse(Vec2 impulse, Vec2 point, boolean wake) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            if (wake) {
                setAwake(true);
            } else {
                return;
            }
        }
        linearVelocity.x += impulse.x * m_invMass;
        linearVelocity.y += impulse.y * m_invMass;
        angularVelocity += m_invI * ((point.x - m_sweep.c.x) * impulse.y - (point.y - m_sweep.c.y) * impulse.x);
    }
    public void applyAngularImpulse(float impulse) {
        if (type != BodyType.DYNAMIC) {
            return;
        }
        if (!isAwake()) {
            setAwake(true);
        }
        angularVelocity += m_invI * impulse;
    }
    public float getMass() {
        return m_mass;
    }
    public float getInertia() {
        return m_I + m_mass * Vec2.dot(m_sweep.localCenter, m_sweep.localCenter);
    }
    public void getMassData(MassData data) {
        data.mass = m_mass;
        data.I = getInertia();
        data.center.set(m_sweep.localCenter);
    }
    public void setMassData(MassData massData) {
        world.assertNotLocked();
        if (type != BodyType.DYNAMIC) {
            return;
        }
        m_I = 0;
        m_invI = 0;
        m_mass = massData.mass;
        if (m_mass <= 0) {
            m_mass = 1;
        }
        m_invMass = 1.0f / m_mass;
        if (massData.I > 0 && (m_flags & e_fixedRotationFlag) == 0) {
            m_I = massData.I - m_mass * Vec2.dot(massData.center, massData.center);
            assert m_I > 0;
            m_invI = 1.0f / m_I;
        }
        final Vec2 oldCenter = world.getPool().popVec2();
        oldCenter.set(m_sweep.c);
        m_sweep.localCenter.set(massData.center);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c0);
        m_sweep.c.set(m_sweep.c0);
        final Vec2 temp = world.getPool().popVec2();
        temp.set(m_sweep.c).subLocal(oldCenter);
        final float tempY = angularVelocity * temp.x;
        temp.x = -angularVelocity * temp.y;
        temp.y = tempY;
        linearVelocity.addLocal(temp);
        world.getPool().pushVec2(2);
    }
    private final MassData pmd = new MassData();
    public void resetMassData() {
        m_mass = 0;
        m_invMass = 0;
        m_I = 0;
        m_invI = 0;
        m_sweep.localCenter.setZero();
        if (type == BodyType.STATIC || type == BodyType.KINEMATIC) {
            m_sweep.c0.set(m_xf.p);
            m_sweep.c.set(m_xf.p);
            m_sweep.a0 = m_sweep.a;
            return;
        }
        final Vec2 localCenter = world.getPool().popVec2();
        localCenter.setZero();
        final Vec2 temp = world.getPool().popVec2();
        final MassData massData = pmd;
        for (Fixture f : fixtures) {
            if (f.getDensity() == 0.0f) {
                continue;
            }
            f.getMassData(massData);
            m_mass += massData.mass;
            temp.set(massData.center).mulLocal(massData.mass);
            localCenter.addLocal(temp);
            m_I += massData.I;
        }
        if (m_mass > 0.0f) {
            m_invMass = 1.0f / m_mass;
            localCenter.mulLocal(m_invMass);
        } else {
            m_mass = 1.0f;
            m_invMass = 1.0f;
        }
        if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0) {
            m_I -= m_mass * Vec2.dot(localCenter, localCenter);
            assert m_I > 0.0f;
            m_invI = 1.0f / m_I;
        } else {
            m_I = 0.0f;
            m_invI = 0.0f;
        }
        Vec2 oldCenter = world.getPool().popVec2();
        oldCenter.set(m_sweep.c);
        m_sweep.localCenter.set(localCenter);
        Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c0);
        m_sweep.c.set(m_sweep.c0);
        temp.set(m_sweep.c).subLocal(oldCenter);
        final Vec2 temp2 = oldCenter;
        Vec2.crossToOutUnsafe(angularVelocity, temp, temp2);
        linearVelocity.addLocal(temp2);
        world.getPool().pushVec2(3);
    }
    public Vec2 getWorldPoint(Vec2 localPoint) {
        Vec2 v = new Vec2();
        getWorldPointToOut(localPoint, v);
        return v;
    }
    public void getWorldPointToOut(Vec2 localPoint, Vec2 out) {
        Transform.mulToOut(m_xf, localPoint, out);
    }
    public Vec2 getWorldVector(Vec2 localVector) {
        Vec2 out = new Vec2();
        getWorldVectorToOut(localVector, out);
        return out;
    }
    public void getWorldVectorToOut(Vec2 localVector, Vec2 out) {
        Rotation.mulToOut(m_xf.q, localVector, out);
    }
    public void getWorldVectorToOutUnsafe(Vec2 localVector, Vec2 out) {
        Rotation.mulToOutUnsafe(m_xf.q, localVector, out);
    }
    public Vec2 getLocalPoint(Vec2 worldPoint) {
        Vec2 out = new Vec2();
        getLocalPointToOut(worldPoint, out);
        return out;
    }
    public void getLocalPointToOut(Vec2 worldPoint, Vec2 out) {
        Transform.mulTransToOut(m_xf, worldPoint, out);
    }
    public Vec2 getLocalVector(Vec2 worldVector) {
        Vec2 out = new Vec2();
        getLocalVectorToOut(worldVector, out);
        return out;
    }
    public void getLocalVectorToOut(Vec2 worldVector, Vec2 out) {
        Rotation.mulTrans(m_xf.q, worldVector, out);
    }
    public void getLocalVectorToOutUnsafe(Vec2 worldVector, Vec2 out) {
        Rotation.mulTransUnsafe(m_xf.q, worldVector, out);
    }
    public Vec2 getLinearVelocityFromWorldPoint(Vec2 worldPoint) {
        Vec2 out = new Vec2();
        getLinearVelocityFromWorldPointToOut(worldPoint, out);
        return out;
    }
    public void getLinearVelocityFromWorldPointToOut(Vec2 worldPoint, Vec2 out) {
        final float tempX = worldPoint.x - m_sweep.c.x;
        final float tempY = worldPoint.y - m_sweep.c.y;
        out.x = -angularVelocity * tempY + linearVelocity.x;
        out.y = angularVelocity * tempX + linearVelocity.y;
    }
    public Vec2 getLinearVelocityFromLocalPoint(Vec2 localPoint) {
        Vec2 out = new Vec2();
        getLinearVelocityFromLocalPointToOut(localPoint, out);
        return out;
    }
    public void getLinearVelocityFromLocalPointToOut(Vec2 localPoint, Vec2 out) {
        getWorldPointToOut(localPoint, out);
        getLinearVelocityFromWorldPointToOut(out, out);
    }
    public float getLinearDamping() {
        return linearDamping;
    }
    public void setLinearDamping(float linearDamping) {
        this.linearDamping = linearDamping;
    }
    public float getAngularDamping() {
        return angularDamping;
    }
    public void setAngularDamping(float angularDamping) {
        this.angularDamping = angularDamping;
    }
    public float getSleepTime() {
        return sleepTime;
    }
    void setSleepTime(float sleepTime) {
        this.sleepTime = sleepTime;
    }
    public BodyType getType() {
        return type;
    }
    public void setType(BodyType type) {
        world.assertNotLocked();
        if (this.type == type) {
            return;
        }
        this.type = type;
        resetMassData();
        if (this.type == BodyType.STATIC) {
            linearVelocity.setZero();
            angularVelocity = 0.0f;
            m_sweep.a0 = m_sweep.a;
            m_sweep.c0.set(m_sweep.c);
            synchronizeFixtures();
        }
        setAwake(true);
        clearForces();
        destroyAttachedContacts();
        for (Fixture f : fixtures) {
            int proxyCount = f.getProxyCount();
            for (int i = 0; i < proxyCount; ++i) {
                broadPhase.touchProxy(f.getProxyId(i));
            }
        }
    }
    void clearForces() {
        m_force.setZero();
        m_torque = 0.0f;
    }
    Vec2 getForce() {
        return m_force;
    }
    void destroy() {
        destroyAttachedJoints();
        destroyAttachedContacts();
        destroyFixtures();
    }
    private void destroyAttachedJoints() {
        JointEdge je = this.m_jointList;
        while (je != null) {
            JointEdge je0 = je;
            je = je.next;
            if (world.getDestructionListener() != null) {
                world.getDestructionListener().onDestroy(je0.joint);
            }
            world.destroyJoint(je0.joint);
            this.m_jointList = je;
        }
        this.m_jointList = null;
    }
    private void destroyAttachedContacts() {
        ContactEdge ce = m_contactList;
        while (ce != null) {
            ContactEdge ce0 = ce;
            ce = ce.next;
            world.getContactManager().destroy(ce0.contact);
        }
        m_contactList = null;
    }
    private void destroyFixtures() {
        for (Fixture f : getFixtures()) {
            if (world.getDestructionListener() != null) {
                world.getDestructionListener().onDestroy(f);
            }
            f.destroyProxies(broadPhase);
            f.destroy();
        }
        getFixtures().clear();
    }
    public boolean isBullet() {
        return (m_flags & e_bulletFlag) == e_bulletFlag;
    }
    public void setBullet(boolean flag) {
        if (flag) {
            m_flags |= e_bulletFlag;
        } else {
            m_flags &= ~e_bulletFlag;
        }
    }
    boolean isIslandFlagOff() {
        return (m_flags & e_islandFlag) == 0;
    }
    boolean isIslandFlagOn() {
        return (m_flags & e_islandFlag) != 0;
    }
    boolean isIslandFlagOn2() {
        return (m_flags & e_islandFlag) == e_islandFlag;
    }
    void setIslandFlag(boolean flag) {
        if (flag) {
            m_flags |= e_islandFlag;
        } else {
            m_flags &= ~e_islandFlag;
        }
    }
    public void setSleepingAllowed(boolean flag) {
        isSleepingAllowed = flag;
        if (!isSleepingAllowed) {
            setAwake(true);
        }
    }
    public boolean isSleepingAllowed() {
        return isSleepingAllowed;
    }
    public void setAwake(boolean flag) {
        if (flag) {
            if ((m_flags & e_awakeFlag) == 0) {
                m_flags |= e_awakeFlag;
                sleepTime = 0.0f;
            }
        } else {
            m_flags &= ~e_awakeFlag;
            sleepTime = 0.0f;
            linearVelocity.setZero();
            angularVelocity = 0.0f;
            clearForces();
        }
    }
    public boolean isAwake() {
        return (m_flags & e_awakeFlag) == e_awakeFlag;
    }
    public void setActive(boolean flag) {
        world.assertNotLocked();
        if (flag == isActive()) {
            return;
        }
        if (flag) {
            m_flags |= e_activeFlag;
            for (Fixture f : fixtures) {
                f.createProxies(broadPhase, m_xf);
            }
        } else {
            m_flags &= ~e_activeFlag;
            for (Fixture f : fixtures) {
                f.destroyProxies(broadPhase);
            }
            destroyAttachedContacts();
        }
    }
    public boolean isActive() {
        return (m_flags & e_activeFlag) == e_activeFlag;
    }
    public void setFixedRotation(boolean flag) {
        if (flag) {
            m_flags |= e_fixedRotationFlag;
        } else {
            m_flags &= ~e_fixedRotationFlag;
        }
        resetMassData();
    }
    public boolean isFixedRotation() {
        return (m_flags & e_fixedRotationFlag) == e_fixedRotationFlag;
    }
    public JointEdge getJointList() {
        return m_jointList;
    }
    public ContactEdge getContactList() {
        return m_contactList;
    }
    public Object getUserData() {
        return userData;
    }
    public void setUserData(Object data) {
        userData = data;
    }
    public World getWorld() {
        return world;
    }
    private final Transform pxf = new Transform();
    void synchronizeFixtures() {
        final Transform xf1 = pxf;
        xf1.q.set(m_sweep.a0);
        xf1.p.x = m_sweep.c0.x - xf1.q.c * m_sweep.localCenter.x + xf1.q.s * m_sweep.localCenter.y;
        xf1.p.y = m_sweep.c0.y - xf1.q.s * m_sweep.localCenter.x - xf1.q.c * m_sweep.localCenter.y;
        for (Fixture f : fixtures) {
            f.synchronize(broadPhase, xf1, m_xf);
        }
    }
    void synchronizeTransform() {
        m_xf.q.set(m_sweep.a);
        Rotation q = m_xf.q;
        Vec2 v = m_sweep.localCenter;
        m_xf.p.x = m_sweep.c.x - q.c * v.x + q.s * v.y;
        m_xf.p.y = m_sweep.c.y - q.s * v.x - q.c * v.y;
    }
    public boolean shouldCollide(Body other) {
        if (type != BodyType.DYNAMIC && other.type != BodyType.DYNAMIC) {
            return false;
        }
        for (JointEdge jn = m_jointList; jn != null; jn = jn.next) {
            if (jn.other == other && !jn.joint.getCollideConnected()) {
                return false;
            }
        }
        return true;
    }
    void advance(float t) {
        m_sweep.advance(t);
        m_sweep.c.set(m_sweep.c0);
        m_sweep.a = m_sweep.a0;
        m_xf.q.set(m_sweep.a);
        Rotation.mulToOutUnsafe(m_xf.q, m_sweep.localCenter, m_xf.p);
        m_xf.p.mulLocal(-1).addLocal(m_sweep.c);
    }
}
package com.almasb.fxgl.core.math;
import com.almasb.fxgl.core.pool.Poolable;
import javafx.geometry.Point2D;
import java.io.Serializable;
public final class Vec2 implements Serializable, Poolable {
    private static final long serialVersionUID = 1L;
    public float x, y;
    public Vec2() {
        this(0, 0);
    }
    public Vec2(float x, float y) {
        this.x = x;
        this.y = y;
    }
    public Vec2(double x, double y) {
        this((float) x, (float) y);
    }
    public Vec2(Vec2 toCopy) {
        this(toCopy.x, toCopy.y);
    }
    public Vec2(Point2D toCopy) {
        this(toCopy.getX(), toCopy.getY());
    }
    public void setZero() {
        x = 0.0f;
        y = 0.0f;
    }
    public Vec2 set(float x, float y) {
        this.x = x;
        this.y = y;
        return this;
    }
    public Vec2 set(Vec2 v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    public Vec2 set(Point2D vector) {
        this.x = (float) vector.getX();
        this.y = (float) vector.getY();
        return this;
    }
    public Vec2 setFromAngle(double degrees) {
        this.x = (float) FXGLMath.cosDeg(degrees);
        this.y = (float) FXGLMath.sinDeg(degrees);
        return this;
    }
    public Vec2 add(Vec2 v) {
        return new Vec2(x + v.x, y + v.y);
    }
    public Vec2 add(Point2D vector) {
        return add(vector.getX(), vector.getY());
    }
    public Vec2 add(double otherX, double otherY) {
        return new Vec2(x + otherX, y + otherY);
    }
    public Vec2 sub(Vec2 v) {
        return new Vec2(x - v.x, y - v.y);
    }
    public Vec2 sub(Point2D vector) {
        return sub(vector.getX(), vector.getY());
    }
    public Vec2 sub(double otherX, double otherY) {
        return new Vec2(x - otherX, y - otherY);
    }
    public Vec2 mul(double a) {
        return new Vec2(x * a, y * a);
    }
    public Vec2 negate() {
        return new Vec2(-x, -y);
    }
    public Vec2 negateLocal() {
        x = -x;
        y = -y;
        return this;
    }
    public Vec2 addLocal(Vec2 v) {
        x += v.x;
        y += v.y;
        return this;
    }
    public Vec2 addLocal(double x, double y) {
        this.x += x;
        this.y += y;
        return this;
    }
    public Vec2 subLocal(Vec2 v) {
        x -= v.x;
        y -= v.y;
        return this;
    }
    public Vec2 subLocal(double x, double y) {
        this.x -= x;
        this.y -= y;
        return this;
    }
    public Vec2 mulLocal(double a) {
        x *= a;
        y *= a;
        return this;
    }
    public Vec2 perpendicularCCW() {
        return new Vec2(y, -x);
    }
    public Vec2 perpendicularCW() {
        return new Vec2(-y, x);
    }
    public Vec2 setLength(double length) {
        return normalizeLocal().mulLocal(length);
    }
    public float length() {
        return (float) FXGLMath.sqrt(x * x + y * y);
    }
    public float lengthSquared() {
        return x * x + y * y;
    }
    public double distance(Vec2 other) {
        return distance(other.x, other.y);
    }
    public float distanceF(Vec2 other) {
        return FXGLMath.sqrtF(distanceSquared(other));
    }
    public double distance(Point2D other) {
        return distance(other.getX(), other.getY());
    }
    public double distance(double otherX, double otherY) {
        double dx = otherX - x;
        double dy = otherY - y;
        return Math.sqrt(dx * dx + dy * dy);
    }
    public float distanceSquared(Vec2 v) {
        float dx = x - v.x;
        float dy = y - v.y;
        return dx * dx + dy * dy;
    }
    public double distanceSquared(double otherX, double otherY) {
        double dx = otherX - x;
        double dy = otherY - y;
        return dx * dx + dy * dy;
    }
    public Vec2 normalize() {
        float length = length();
        if (length < FXGLMath.EPSILON) {
            return new Vec2();
        }
        float invLength = 1.0f / length;
        return new Vec2(x * invLength, y * invLength);
    }
    public float getLengthAndNormalize() {
        float length = length();
        if (length < FXGLMath.EPSILON) {
            return 0f;
        }
        float invLength = 1.0f / length;
        x *= invLength;
        y *= invLength;
        return length;
    }
    public Vec2 normalizeLocal() {
        getLengthAndNormalize();
        return this;
    }
    public Vec2 midpoint(Vec2 other) {
        return new Vec2(
                x + (other.x - x) / 2,
                y + (other.y - y) / 2
        );
    }
    public Vec2 midpoint(Point2D other) {
        return new Vec2(
                x + (other.getX() - x) / 2,
                y + (other.getY() - y) / 2
        );
    }
    public Vec2 abs() {
        return new Vec2(FXGLMath.abs(x), FXGLMath.abs(y));
    }
    public Vec2 absLocal() {
        x = FXGLMath.abs(x);
        y = FXGLMath.abs(y);
        return this;
    }
    public float angle() {
        return angle(1, 0);
    }
    public float angle(Vec2 other) {
        return angle(other.x, other.y);
    }
    public float angle(Point2D other) {
        return angle(other.getX(), other.getY());
    }
    public float angle(double otherX, double otherY) {
        double angle1 = Math.toDegrees(Math.atan2(y, x));
        double angle2 = Math.toDegrees(Math.atan2(otherY, otherX));
        return (float) (angle1 - angle2);
    }
    public Vec2 copy() {
        return new Vec2(x, y);
    }
    public Point2D toPoint2D() {
        return new Point2D(x, y);
    }
    @Override
    public String toString() {
        return "(" + x + "," + y + ")";
    }
    @Override
    public void reset() {
        setZero();
    }
    public static Vec2 fromAngle(double degrees) {
        return new Vec2(FXGLMath.cosDeg((float)degrees), FXGLMath.sinDeg((float)degrees));
    }
    public static float dot(final Vec2 a, final Vec2 b) {
        return a.x * b.x + a.y * b.y;
    }
    public static float cross(final Vec2 a, final Vec2 b) {
        return a.x * b.y - a.y * b.x;
    }
    public static void crossToOutUnsafe(Vec2 in, float scale, Vec2 out) {
        out.x = scale * in.y;
        out.y = -scale * in.x;
    }
    public static void crossToOutUnsafe(float scale, Vec2 in, Vec2 out) {
        out.x = -scale * in.y;
        out.y = scale * in.x;
    }
    public static void minToOut(Vec2 a, Vec2 b, Vec2 out) {
        out.x = a.x < b.x ? a.x : b.x;
        out.y = a.y < b.y ? a.y : b.y;
    }
    public static void maxToOut(Vec2 a, Vec2 b, Vec2 out) {
        out.x = a.x > b.x ? a.x : b.x;
        out.y = a.y > b.y ? a.y : b.y;
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + Float.floatToIntBits(x);
        result = prime * result + Float.floatToIntBits(y);
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (obj == this)
            return true;
        if (obj instanceof Vec2) {
            Vec2 other = (Vec2) obj;
            return Float.floatToIntBits(x) == Float.floatToIntBits(other.x)
                    && Float.floatToIntBits(y) == Float.floatToIntBits(other.y);
        }
        return false;
    }
    public boolean isNearlyEqualTo(Point2D p) {
        return isCloseTo(p, 0.1);
    }
    public boolean isCloseTo(Point2D p, double tolerance) {
        return Math.abs(distance(p)) <= tolerance;
    }
}
package com.almasb.fxgl.entity.component;
import com.almasb.fxgl.entity.Entity;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
public abstract class Component {
    protected Entity entity;
    private BooleanProperty paused = new SimpleBooleanProperty(false);
    public final Entity getEntity() {
        return entity;
    }
    final void setEntity(Entity entity) {
        this.entity = entity;
    }
    public final boolean isPaused() {
        return paused.getValue();
    }
    public final void pause() {
        paused.setValue(true);
    }
    public final void resume() {
        paused.setValue(false);
    }
    public BooleanProperty pausedProperty() {
        return paused;
    }
    public void onAdded() {
    }
    public void onUpdate(double tpf) {
    }
    public void onRemoved() {
    }
    public boolean isComponentInjectionRequired() {
        return true;
    }
    @Override
    public String toString() {
        String simpleName = getClass().getSimpleName();
        int index = simpleName.indexOf("Component");
        if (index != -1) {
            simpleName = simpleName.substring(0, index);
        }
        return simpleName + "()";
    }
}
package sandbox.joints;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.dsl.components.ExpireCleanComponent;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.geometry.HorizontalDirection;
import javafx.geometry.Point2D;
import javafx.scene.effect.BlendMode;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class RopeJointSample2 extends GameApplication {
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
    }
    @Override
    protected void initInput() {
        getInput().addAction(new UserAction("LMB") {
            private double x;
            private double y;
            @Override
            protected void onActionBegin() {
                x = getInput().getMouseXWorld();
                y = getInput().getMouseYWorld();
            }
            @Override
            protected void onActionEnd() {
                var endx = getInput().getMouseXWorld();
                var endy = getInput().getMouseYWorld();
                spawnBullet(x, y, endx - x, endy - y);
            }
        }, MouseButton.PRIMARY);
        onKeyDown(KeyCode.F, () -> {
            Entity box = createPhysicsEntity();
            box.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Left", BoundingShape.box(40, 40)));
            box.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Right", new Point2D(40, 0), BoundingShape.box(40, 40)));
            box.getViewComponent().addChild(texture("brick.png", 40, 40).superTexture(texture("brick.png", 40, 40), HorizontalDirection.RIGHT));
            box.setRotationOrigin(new Point2D(40, 20));
            getGameWorld().addEntity(box);
        });
        onBtnDown(MouseButton.SECONDARY, () -> {
            Entity ball = createPhysicsEntity();
            ball.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Test", BoundingShape.circle(20)));
            ball.getViewComponent().addChild(texture("ball.png", 40, 40));
            ball.setRotationOrigin(new Point2D(20, 20));
            getGameWorld().addEntity(ball);
        });
    }
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.BLACK);
        entityBuilder()
                .buildScreenBoundsAndAttach(50);
        entityBuilder()
                .at(400, 400)
                .viewWithBBox(new Rectangle(500, 20, Color.BROWN))
                .with(new PhysicsComponent())
                .buildAndAttach();
        PhysicsComponent physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(1.1f));
        physics.setBodyType(BodyType.DYNAMIC);
        Entity last = null;
        var color = FXGLMath.randomColorHSB(0.8, 0.9);
        var c1 = color.deriveColor(0, 1, random(0.65, 0.95), random(0.65, 0.95)).brighter().brighter();
        for (int x = 0; x < 4; x++) {
            last = null;
            for (int i = 0; i < 10; i++) {
                PhysicsComponent physics2 = new PhysicsComponent();
                if (last != null) {
                    physics2.setBodyType(BodyType.DYNAMIC);
                }
                FixtureDef fd = new FixtureDef();
                fd.setDensity(1.0f);
                physics2.setFixtureDef(fd);
                var texture = texture("particles/circle_05.png", 128, 128);
                texture = texture.multiplyColor(c1);
                texture.setBlendMode(BlendMode.ADD);
                Entity ball = entityBuilder()
                        .at(400 + i * 30 + x * 30, 160)
                        .bbox(new HitBox("main", BoundingShape.circle(15)))
                        .view(texture)
                        .with(physics2)
                        .buildAndAttach();
                physics2.getBody().setAngularDamping(1f);
                if (last != null) {
                    var joint = getPhysicsWorld().addRopeJoint(last, ball);
                }
                last = ball;
            }
        }
    }
    private void spawnBullet(double x, double y, double vx, double vy) {
        var physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(25.5f).restitution(0.5f));
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setOnPhysicsInitialized(() -> {
            physics.setLinearVelocity(vx * 10, vy * 10);
        });
        entityBuilder()
                .at(x, y)
                .bbox(new HitBox(BoundingShape.circle(450 / 15.0 / 2.0)))
                .view(texture("ball.png", 450 / 15.0, 449 / 15.0))
                .with(physics)
                .with(new ExpireCleanComponent(Duration.seconds(5)).animateOpacity())
                .buildAndAttach();
    }
    private Entity createPhysicsEntity() {
        PhysicsComponent physics = new PhysicsComponent();
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setFixtureDef(new FixtureDef().density(0.1f).restitution(0.3f));
        return entityBuilder()
                .at(getInput().getMousePositionWorld())
                .with(physics)
                .build();
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package sandbox.joints;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.dsl.components.ExpireCleanComponent;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import com.almasb.fxgl.physics.box2d.dynamics.joints.RevoluteJoint;
import javafx.geometry.HorizontalDirection;
import javafx.geometry.Point2D;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class RevoluteJointSample extends GameApplication {
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
    }
    @Override
    protected void initInput() {
        getInput().addAction(new UserAction("LMB") {
            private double x;
            private double y;
            @Override
            protected void onActionBegin() {
                x = getInput().getMouseXWorld();
                y = getInput().getMouseYWorld();
            }
            @Override
            protected void onActionEnd() {
                var endx = getInput().getMouseXWorld();
                var endy = getInput().getMouseYWorld();
                spawnBullet(x, y, endx - x, endy - y);
            }
        }, MouseButton.PRIMARY);
        onKeyDown(KeyCode.F, () -> {
            Entity box = createPhysicsEntity();
            box.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Left", BoundingShape.box(40, 40)));
            box.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Right", new Point2D(40, 0), BoundingShape.box(40, 40)));
            box.getViewComponent().addChild(texture("brick.png", 40, 40).superTexture(texture("brick.png", 40, 40), HorizontalDirection.RIGHT));
            box.setRotationOrigin(new Point2D(40, 20));
            getGameWorld().addEntity(box);
        });
        onBtnDown(MouseButton.SECONDARY, () -> {
            Entity ball = createPhysicsEntity();
            ball.getBoundingBoxComponent()
                    .addHitBox(new HitBox("Test", BoundingShape.circle(20)));
            ball.getViewComponent().addChild(texture("ball.png", 40, 40));
            ball.setRotationOrigin(new Point2D(20, 20));
            getGameWorld().addEntity(ball);
        });
    }
    private RevoluteJoint joint;
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.LIGHTGRAY);
        entityBuilder()
                .buildScreenBoundsAndAttach(50);
        entityBuilder()
                .at(400, 400)
                .viewWithBBox(new Rectangle(500, 20, Color.BROWN))
                .with(new PhysicsComponent())
                .buildAndAttach();
        PhysicsComponent physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(1.1f));
        physics.setBodyType(BodyType.DYNAMIC);
        Entity block = entityBuilder()
                .at(600, 100)
                .viewWithBBox(new Rectangle(80, 50))
                .with(physics)
                .buildAndAttach();
        PhysicsComponent physics2 = new PhysicsComponent();
        physics2.setBodyType(BodyType.DYNAMIC);
        FixtureDef fd = new FixtureDef();
        fd.setDensity(1.0f);
        physics2.setFixtureDef(fd);
        Entity ball1 = entityBuilder()
                .at(600, 360)
                .bbox(new HitBox("main", BoundingShape.circle(15)))
                .view(texture("ball.png", 30, 30))
                .with(physics2)
                .buildAndAttach();
        PhysicsComponent physics3 = new PhysicsComponent();
        physics3.setBodyType(BodyType.DYNAMIC);
        physics3.setFixtureDef(fd);
        Entity ball2 = entityBuilder()
                .at(700, 360)
                .bbox(new HitBox("main", BoundingShape.circle(15)))
                .view(texture("ball.png", 30, 30))
                .with(physics3)
                .buildAndAttach();
        physics2.getBody().setAngularDamping(1f);
        physics3.getBody().setAngularDamping(1f);
        getPhysicsWorld().addRevoluteJoint(block, ball1, new Point2D(80, 50), new Point2D(15, 15));
        getPhysicsWorld().addRevoluteJoint(block, ball2, new Point2D(0, 50), new Point2D(15, 15));
    }
    private void spawnBullet(double x, double y, double vx, double vy) {
        var physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(25.5f).restitution(0.5f));
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setOnPhysicsInitialized(() -> {
            physics.setLinearVelocity(vx * 10, vy * 10);
        });
        entityBuilder()
                .at(x, y)
                .bbox(new HitBox(BoundingShape.circle(450 / 15.0 / 2.0)))
                .view(texture("ball.png", 450 / 15.0, 449 / 15.0))
                .with(physics)
                .with(new ExpireCleanComponent(Duration.seconds(5)).animateOpacity())
                .buildAndAttach();
    }
    private Entity createPhysicsEntity() {
        PhysicsComponent physics = new PhysicsComponent();
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setFixtureDef(new FixtureDef().density(0.1f).restitution(0.3f));
        return entityBuilder()
                .at(getInput().getMousePositionWorld())
                .with(physics)
                .build();
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package com.almasb.fxgl.core.pool;
import java.util.HashMap;
import java.util.Map;
public final class Pools {
    private Pools() {
    }
    private static final Map<Class, Pool> typePools = new HashMap<>();
    @SuppressWarnings("unchecked")
    private static <T> Pool<T> get(Class<T> type, int max) {
        Pool pool = typePools.get(type);
        if (pool == null) {
            pool = new ReflectionPool<>(type, 16, max);
            typePools.put(type, pool);
        }
        return pool;
    }
    private static <T> Pool<T> get(Class<T> type) {
        return get(type, 100);
    }
    public static <T> void set(Class<T> type, Pool<T> pool) {
        typePools.put(type, pool);
    }
    public static <T> T obtain(Class<T> type) {
        return get(type).obtain();
    }
    @SuppressWarnings("unchecked")
    public static void free(Object object) {
        Pool pool = typePools.get(object.getClass());
        if (pool == null)
            return; 
        pool.free(object);
    }
}
package com.almasb.fxgl.physics;
import com.almasb.fxgl.core.math.Vec2;
import javafx.geometry.Point2D;
public interface PhysicsUnitConverter {
    default float toMetersF(double pixels) {
        return (float) toMeters(pixels);
    }
    double toMeters(double pixels);
    default float toPixelsF(double meters) {
        return (float) toPixels(meters);
    }
    double toPixels(double meters);
    default Vec2 toVector(Point2D v) {
        return new Vec2(toMetersF(v.getX()), toMetersF(-v.getY()));
    }
    default Point2D toVector(Vec2 v) {
        return new Point2D(toPixels(v.x), toPixels(-v.y));
    }
    Vec2 toPoint(Point2D p);
    Point2D toPoint(Vec2 p);
}
package advanced;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.entity.component.Component;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyDef;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.geometry.Point2D;
import javafx.scene.effect.InnerShadow;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.StrokeType;
import static com.almasb.fxgl.dsl.FXGL.*;
import static com.almasb.fxgl.physics.BoundingShape.box;
public class SnookerPhysicsSample extends GameApplication {
    private static final double TABLE_FRICTION = 0.7;
    private static final float BALL_DENSITY = 45f;
    private static final float BALL_ELASTICITY = 0.3f;
    private static final float ANGULAR_VELOCITY_DECAY = 0.99f;
    private static final double LINEAR_VELOCITY_THRESHOLD = 0.01;
    private static final double ANGULAR_VELOCITY_THRESHOLD = 0.01;
    private static final int MAX_CUE_FORCE_DISTANCE = 145;
    private static final int MAX_CUE_FORCE = 75000;
    private Entity cueBall;
    private Line cue;
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
    }
    @Override
    protected void initInput() {
        getInput().addAction(new UserAction("Cue") {
            @Override
            protected void onActionBegin() {
                cue.setVisible(true);
            }
            @Override
            protected void onActionEnd() {
                cue.setVisible(false);
                var physics = cueBall.getComponent(PhysicsComponent.class);
                Point2D force = cueBall.getCenter().subtract(getInput().getMousePositionWorld());
                double forcePower = Math.min(force.magnitude(), MAX_CUE_FORCE_DISTANCE);
                double forceRatio = forcePower / MAX_CUE_FORCE_DISTANCE;
                physics.applyLinearImpulse(force.normalize().multiply(forceRatio * MAX_CUE_FORCE), cueBall.getCenter(), true);
            }
        }, MouseButton.PRIMARY);
    }
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.LIGHTGRAY);
        getPhysicsWorld().setGravity(0, 0);
        spawnTable(200, 150);
        cueBall = spawnBall(220, getAppHeight() / 2 - 15, Color.WHITE);
        for (int x = 1; x <= 5; x++) {
            int numBalls = x;
            for (int y = 1; y <= numBalls; y++) {
                int offsetY = getAppHeight() / 2 - numBalls * 15;
                spawnBall(800 + x * 32, offsetY + (y-1) * 32, Color.RED);
            }
        }
        spawnBall(450, getAppHeight() / 2 - 100 - 15, Color.GREEN);
        spawnBall(450, getAppHeight() / 2 - 15, Color.BROWN);
        spawnBall(450, getAppHeight() / 2 + 100 - 15, Color.YELLOW);
        spawnBall(getAppWidth() / 2 - 15, getAppHeight() / 2 - 15, Color.BLUE);
        spawnBall(750, getAppHeight() / 2 - 15, Color.PINK);
        spawnBall(800 + 200, getAppHeight() / 2 - 15, Color.color(0.1, 0.1, 0.1));
        cue = new Line();
        cue.setVisible(false);
        cue.setStrokeWidth(2);
        cue.startXProperty().bind(cueBall.xProperty().add(15));
        cue.startYProperty().bind(cueBall.yProperty().add(15));
        cue.endXProperty().bind(getInput().mouseXWorldProperty());
        cue.endYProperty().bind(getInput().mouseYWorldProperty());
        addUINode(cue);
    }
    private Entity spawnTable(double x, double y) {
        var rect = new Rectangle(getAppWidth() - 200 - 200, getAppHeight() - 150 - 150, Color.LIGHTSEAGREEN);
        rect.setArcWidth(15);
        rect.setArcHeight(15);
        rect.setStroke(Color.BLACK);
        rect.setStrokeWidth(10);
        rect.setStrokeType(StrokeType.OUTSIDE);
        return entityBuilder()
                .at(x, y)
                .bbox(new HitBox(new Point2D(-40, 0), box(40, rect.getHeight())))
                .bbox(new HitBox(new Point2D(rect.getWidth(), 0), box(40, rect.getHeight())))
                .bbox(new HitBox(new Point2D(0, -40), box(rect.getWidth(), 40)))
                .bbox(new HitBox(new Point2D(0, rect.getHeight()), box(rect.getWidth(), 40)))
                .view(rect)
                .with(new PhysicsComponent())
                .buildAndAttach();
    }
    private Entity spawnBall(double x, double y, Color color) {
        var bd = new BodyDef();
        bd.setBullet(true);
        bd.setType(BodyType.DYNAMIC);
        var p = new PhysicsComponent();
        p.setBodyDef(bd);
        p.setFixtureDef(new FixtureDef().density(BALL_DENSITY).restitution(BALL_ELASTICITY));
        var shadow = new InnerShadow(3, Color.BLACK);
        shadow.setOffsetX(-3);
        shadow.setOffsetY(-3);
        var c = new Circle(15, 15, 15, color);
        c.setEffect(shadow);
        var shine = new Circle(3, 3, 3, Color.color(0.7, 0.7, 0.7, 0.7));
        shine.setTranslateX(5);
        shine.setTranslateY(5);
        return entityBuilder()
                .at(x, y)
                .bbox(new HitBox(BoundingShape.circle(15)))
                .view(c)
                .view(shine)
                .with(p)
                .with(new BallComponent())
                .buildAndAttach();
    }
    private static class BallComponent extends Component {
        private PhysicsComponent p;
        @Override
        public void onUpdate(double tpf) {
            double frictionPerFrame = TABLE_FRICTION * tpf;
            var vx = p.getVelocityX();
            var vy = p.getVelocityY();
            if (FXGLMath.abs(vx) > LINEAR_VELOCITY_THRESHOLD) {
                vx -= vx * frictionPerFrame;
                p.setVelocityX(vx);
            } else {
                p.setVelocityX(0);
            }
            if (FXGLMath.abs(vy) > LINEAR_VELOCITY_THRESHOLD) {
                vy -= vy * frictionPerFrame;
                p.setVelocityY(vy);
            } else {
                p.setVelocityY(0);
            }
            var a = p.getBody().getAngularVelocity();
            if (FXGLMath.abs(a) > ANGULAR_VELOCITY_THRESHOLD) {
                p.getBody().setAngularVelocity(a * ANGULAR_VELOCITY_DECAY);
            } else {
                p.getBody().setAngularVelocity(0);
            }
        }
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package com.almasb.fxgl.physics;
import com.almasb.fxgl.core.collection.Array;
import com.almasb.fxgl.core.collection.UnorderedArray;
import com.almasb.fxgl.core.collection.UnorderedPairMap;
import com.almasb.fxgl.core.math.Vec2;
import com.almasb.fxgl.core.pool.Pool;
import com.almasb.fxgl.core.pool.Pools;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.entity.EntityWorldListener;
import com.almasb.fxgl.entity.components.BoundingBoxComponent;
import com.almasb.fxgl.entity.components.CollidableComponent;
import com.almasb.fxgl.logging.Logger;
import com.almasb.fxgl.physics.box2d.callbacks.ContactFilter;
import com.almasb.fxgl.physics.box2d.callbacks.ContactImpulse;
import com.almasb.fxgl.physics.box2d.callbacks.ContactListener;
import com.almasb.fxgl.physics.box2d.collision.Manifold;
import com.almasb.fxgl.physics.box2d.collision.shapes.Shape;
import com.almasb.fxgl.physics.box2d.dynamics.*;
import com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact;
import com.almasb.fxgl.physics.box2d.dynamics.joints.*;
import javafx.beans.value.ChangeListener;
import javafx.geometry.Point2D;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
public final class PhysicsWorld implements EntityWorldListener, ContactListener, PhysicsUnitConverter {
    private static final Logger log = Logger.get(PhysicsWorld.class);
    private final double PIXELS_PER_METER;
    private final double METERS_PER_PIXELS;
    private World jboxWorld = new World(new Vec2(0, -10));
    private Array<Entity> entities = new UnorderedArray<>(128);
    private UnorderedPairMap<Object, CollisionHandler> collisionHandlers = new UnorderedPairMap<>(16);
    private UnorderedPairMap<Entity, CollisionPair> collisionsMap = new UnorderedPairMap<>(128);
    private CollisionDetectionStrategy strategy;
    private int appHeight;
    public PhysicsWorld(int appHeight, double ppm) {
        this(appHeight, ppm, CollisionDetectionStrategy.BRUTE_FORCE);
    }
    public PhysicsWorld(int appHeight, double ppm, CollisionDetectionStrategy strategy) {
        this.appHeight = appHeight;
        this.strategy = strategy;
        PIXELS_PER_METER = ppm;
        METERS_PER_PIXELS = 1 / PIXELS_PER_METER;
        initCollisionPool();
        initContactListener();
        initParticles();
        jboxWorld.setContactFilter(new CollisionFilterCallback());
        log.debugf("Physics world initialized: appHeight=%d, physics.ppm=%.1f",
                appHeight, ppm);
        log.debug("Using strategy: " + strategy);
    }
    private void initCollisionPool() {
        Pools.set(CollisionPair.class, new Pool<CollisionPair>() {
            @Override
            protected CollisionPair newObject() {
                return new CollisionPair();
            }
        });
    }
    private void initContactListener() {
        jboxWorld.setContactListener(this);
    }
    private void initParticles() {
        jboxWorld.setParticleGravityScale(1f);
        jboxWorld.setParticleDensity(1.2f);
        jboxWorld.setParticleRadius(toMetersF(1));    
    }
    private Array<Entity> delayedBodiesAdd = new UnorderedArray<>();
    private Array<Body> delayedBodiesRemove = new UnorderedArray<>();
    private Map<Entity, ChangeListener<Number> > scaleListeners = new HashMap<>();
    @Override
    public void onEntityAdded(Entity entity) {
        entities.add(entity);
        if (entity.hasComponent(PhysicsComponent.class)) {
            onPhysicsEntityAdded(entity);
        }
    }
    private void onPhysicsEntityAdded(Entity entity) {
        if (!jboxWorld.isLocked()) {
            createBody(entity);
        } else {
            delayedBodiesAdd.add(entity);
        }
        ChangeListener<Number> scaleChangeListener = (observable, oldValue, newValue) -> {
            Body b = entity.getComponent(PhysicsComponent.class).body;
            if (b != null) {
                List<Fixture> fixtures = List.copyOf(b.getFixtures());
                fixtures.forEach(b::destroyFixture);
                createFixtures(entity);
                createSensors(entity);
            }
        };
        scaleListeners.put(entity, scaleChangeListener);
        entity.getTransformComponent().scaleXProperty().addListener(scaleChangeListener);
        entity.getTransformComponent().scaleYProperty().addListener(scaleChangeListener);
    }
    @Override
    public void onEntityRemoved(Entity entity) {
        entities.removeValueByIdentity(entity);
        if (entity.hasComponent(PhysicsComponent.class)) {
            onPhysicsEntityRemoved(entity);
        }
    }
    private void onPhysicsEntityRemoved(Entity entity) {
        if (scaleListeners.containsKey(entity)) {
            ChangeListener<Number> scaleChangeListener = scaleListeners.get(entity);
            entity.getTransformComponent().scaleXProperty().removeListener(scaleChangeListener);
            entity.getTransformComponent().scaleYProperty().removeListener(scaleChangeListener);
            scaleListeners.remove(entity);
        }
        if (!jboxWorld.isLocked()) {
            destroyBody(entity);
        } else {
            delayedBodiesRemove.add(entity.getComponent(PhysicsComponent.class).getBody());
        }
    }
    public void onUpdate(double tpf) {
        jboxWorld.step((float) tpf, 8, 3);
        postStep();
        checkCollisions();
        notifyCollisions();
    }
    private void postStep() {
        for (Entity e : delayedBodiesAdd)
            createBody(e);
        delayedBodiesAdd.clear();
        for (Body body : delayedBodiesRemove)
            jboxWorld.destroyBody(body);
        delayedBodiesRemove.clear();
    }
    public void clear() {
        log.debug("Clearing physics world");
        entities.clear();
        collisionsMap.clear();
    }
    public void clearCollisionHandlers() {
        collisionHandlers.clear();
    }
    @Override
    public void beginContact(Contact contact) {
        Entity e1 = contact.getFixtureA().getBody().getEntity();
        Entity e2 = contact.getFixtureB().getBody().getEntity();
        if (contact.getFixtureA().isSensor()) {
            notifySensorCollisionBegin(e1, e2, contact.getFixtureA().getHitBox());
            return;
        } else if (contact.getFixtureB().isSensor()) {
            notifySensorCollisionBegin(e2, e1, contact.getFixtureB().getHitBox());
            return;
        }
        if (!areCollidable(e1, e2))
            return;
        CollisionHandler handler = getHandler(e1, e2);
        if (handler != null) {
            HitBox a = contact.getFixtureA().getHitBox();
            HitBox b = contact.getFixtureB().getHitBox();
            collisionBeginFor(handler, e1, e2, a, b);
        }
    }
    @Override
    public void endContact(Contact contact) {
        Entity e1 = contact.getFixtureA().getBody().getEntity();
        Entity e2 = contact.getFixtureB().getBody().getEntity();
        if (contact.getFixtureA().isSensor()) {
            notifySensorCollisionEnd(e1, e2, contact.getFixtureA().getHitBox());
            return;
        } else if (contact.getFixtureB().isSensor()) {
            notifySensorCollisionEnd(e2, e1, contact.getFixtureB().getHitBox());
            return;
        }
        if (!areCollidable(e1, e2))
            return;
        CollisionHandler handler = getHandler(e1, e2);
        if (handler != null) {
            collisionEndFor(e1, e2);
        }
    }
    public World getJBox2DWorld() {
        return jboxWorld;
    }
    private boolean isCollidable(Entity e) {
        if (!e.isActive())
            return false;
        return e.getComponentOptional(CollidableComponent.class)
                .map(CollidableComponent::getValue)
                .orElse(false);
    }
    private boolean areCollidable(Entity e1, Entity e2) {
        return isCollidable(e1) && isCollidable(e2);
    }
    @SuppressWarnings("PMD.UselessParentheses")
    private boolean needManualCheck(Entity e1, Entity e2) {
        BodyType type1 = e1.getComponentOptional(PhysicsComponent.class)
                .map(p -> p.body.getType())
                .orElse(null);
        if (type1 == null)
            return true;
        BodyType type2 = e2.getComponentOptional(PhysicsComponent.class)
                .map(p -> p.body.getType())
                .orElse(null);
        if (type2 == null)
            return true;
        return (type1 == BodyType.KINEMATIC && type2 == BodyType.STATIC)
                || (type2 == BodyType.KINEMATIC && type1 == BodyType.STATIC);
    }
    private CollisionHandler getHandler(Entity e1, Entity e2) {
        if (!e1.isActive() || !e2.isActive())
            return null;
        return collisionHandlers.get(e1.getType(), e2.getType());
    }
    private void notifySensorCollisionBegin(Entity eWithSensor, Entity eTriggered, HitBox box) {
        var handler = eWithSensor.getComponent(PhysicsComponent.class).getSensorHandlers().get(box);
        handler.onCollisionBegin(eTriggered);
    }
    private void notifySensorCollisionEnd(Entity eWithSensor, Entity eTriggered, HitBox box) {
        var handler = eWithSensor.getComponent(PhysicsComponent.class).getSensorHandlers().get(box);
        handler.onCollisionEnd(eTriggered);
    }
    @Override
    public void preSolve(Contact contact, Manifold oldManifold) { }
    @Override
    public void postSolve(Contact contact, ContactImpulse impulse) { }
    private Array<Entity> collidables = new UnorderedArray<>(128);
    private CollisionResult collisionResult = new CollisionResult();
    private CollisionGrid collisionGrid = new CollisionGrid(64, 64);
    private void checkCollisions() {
        if (strategy == CollisionDetectionStrategy.GRID_INDEXING) {
            for (Entity e : entities) {
                if (isCollidable(e)) {
                    e.getBoundingBoxComponent().applyTransformToHitBoxes$fxgl_entity();
                    collisionGrid.insert(e);
                }
            }
            collisionGrid.getCells().forEach((p, cell) -> {
                checkCollisionsInGroup(cell.getEntities());
            });
            collisionGrid.getCells().clear();
        } else {
            for (Entity e : entities) {
                if (isCollidable(e)) {
                    e.getBoundingBoxComponent().applyTransformToHitBoxes$fxgl_entity();
                    collidables.add(e);
                }
            }
            checkCollisionsInGroup(collidables);
            collidables.clear();
        }
    }
    private void checkCollisionsInGroup(Array<Entity> group) {
        for (int i = 0; i < group.size(); i++) {
            Entity e1 = group.get(i);
            for (int j = i + 1; j < group.size(); j++) {
                Entity e2 = group.get(j);
                CollisionHandler handler = getHandler(e1, e2);
                if (handler == null)
                    continue;
                if (!needManualCheck(e1, e2)) {
                    continue;
                }
                if (isIgnored(e1, e2))
                    continue;
                var collision = e1.getBoundingBoxComponent().checkCollisionPAT(e2.getBoundingBoxComponent(), collisionResult);
                if (collision) {
                    collisionBeginFor(handler, e1, e2, collisionResult.getBoxA(), collisionResult.getBoxB());
                } else {
                    collisionEndFor(e1, e2);
                }
            }
        }
    }
    private boolean isIgnored(Entity e1, Entity e2) {
        if (!e1.hasComponent(CollidableComponent.class) || !e2.hasComponent(CollidableComponent.class))
            return false;
        CollidableComponent c1 = e1.getComponent(CollidableComponent.class);
        for (Serializable t1 : c1.getIgnoredTypes()) {
            if (e2.isType(t1)) {
                return true;
            }
        }
        CollidableComponent c2 = e2.getComponent(CollidableComponent.class);
        for (Serializable t2 : c2.getIgnoredTypes()) {
            if (e1.isType(t2)) {
                return true;
            }
        }
        return false;
    }
    private void collisionBeginFor(CollisionHandler handler, Entity e1, Entity e2, HitBox a, HitBox b) {
        CollisionPair pair = collisionsMap.get(e1, e2);
        if (pair == null) {
            pair = Pools.obtain(CollisionPair.class);
            pair.init(e1, e2, handler);
            collisionsMap.put(pair.getA(), pair.getB(), pair);
            handler.onHitBoxTrigger(
                    pair.getA(), pair.getB(),
                    e1 == pair.getA() ? a : b,
                    e2 == pair.getB() ? b : a
            );
            pair.collisionBegin();
        }
    }
    private void collisionEndFor(Entity e1, Entity e2) {
        CollisionPair pair = collisionsMap.get(e1, e2);
        if (pair != null) {
            collisionsMap.remove(pair.getA(), pair.getB());
            pair.collisionEnd();
            Pools.free(pair);
        }
    }
    private void notifyCollisions() {
        for (Iterator<CollisionPair> it = collisionsMap.getValues().iterator(); it.hasNext(); ) {
            CollisionPair pair = it.next();
            if (!isCollidable(pair.getA()) || !isCollidable(pair.getB())) {
                pair.collisionEnd();
                it.remove();
                Pools.free(pair);
                continue;
            }
            pair.collision();
        }
    }
    public void addCollisionHandler(CollisionHandler handler) {
        collisionHandlers.put(handler.getA(), handler.getB(), handler);
    }
    public void removeCollisionHandler(CollisionHandler handler) {
        collisionHandlers.remove(handler.getA(), handler.getB());
    }
    public void setGravity(double x, double y) {
        jboxWorld.setGravity(toVector(new Point2D(x, y)));
    }
    private void createBody(Entity e) {
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        physics.setWorld(this);
        if (physics.bodyDef.getPosition().x == 0 && physics.bodyDef.getPosition().y == 0) {
            physics.bodyDef.getPosition().set(toPoint(e.getCenter()));
        }
        if (physics.bodyDef.getAngle() == 0) {
            physics.bodyDef.setAngle((float) -Math.toRadians(e.getRotation()));
        }
        physics.body = jboxWorld.createBody(physics.bodyDef);
        createFixtures(e);
        createSensors(e);
        physics.body.setEntity(e);
        physics.onInitPhysics();
    }
    private void createFixtures(Entity e) {
        BoundingBoxComponent bbox = e.getBoundingBoxComponent();
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        FixtureDef fd = physics.fixtureDef;
        for (HitBox box : bbox.hitBoxesProperty()) {
            Shape b2Shape = createShape(box, e);
            fd.setShape(b2Shape);
            Fixture fixture = physics.body.createFixture(fd);
            fixture.setHitBox(box);
        }
    }
    private void createSensors(Entity e) {
        PhysicsComponent physics = e.getComponent(PhysicsComponent.class);
        if (physics.getSensorHandlers().isEmpty())
            return;
        physics.getSensorHandlers().keySet().forEach(box -> {
            box.bindXY(e.getTransformComponent());
            Shape polygonShape = createShape(box, e);
            FixtureDef fd = new FixtureDef()
                    .sensor(true)
                    .shape(polygonShape);
            Fixture f = physics.body.createFixture(fd);
            f.setHitBox(box);
        });
    }
    private Shape createShape(HitBox box, Entity e) {
        if (e.getComponent(PhysicsComponent.class).body.getType() != BodyType.STATIC
                && box.getShape() instanceof ChainShapeData) {
            throw new IllegalArgumentException("BoundingShape.chain() can only be used with BodyType.STATIC");
        }
        return box.toBox2DShape(e.getBoundingBoxComponent(), this);
    }
    void destroyFixture(Body body, HitBox box) {
        body.getFixtures()
                .stream()
                .filter(f -> f.getHitBox() == box)
                .findAny()
                .ifPresent(body::destroyFixture);
    }
    private void destroyBody(Entity e) {
        jboxWorld.destroyBody(e.getComponent(PhysicsComponent.class).body);
    }
    private EdgeCallback raycastCallback = new EdgeCallback();
    public RaycastResult raycast(Point2D start, Point2D end) {
        raycastCallback.reset();
        jboxWorld.raycast(raycastCallback, toPoint(start), toPoint(end));
        Entity entity = null;
        Point2D point = null;
        if (raycastCallback.getFixture() != null)
            entity = raycastCallback.getFixture().getBody().getEntity();
        if (raycastCallback.getPoint() != null)
            point = toPoint(raycastCallback.getPoint());
        if (entity == null && point == null)
            return RaycastResult.NONE;
        return new RaycastResult(entity, point);
    }
    public RevoluteJoint addRevoluteJoint(Entity e1, Entity e2, Point2D localAnchor1, Point2D localAnchor2) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        RevoluteJointDef def = new RevoluteJointDef();
        def.localAnchorA = toPoint(e1.getAnchoredPosition().add(localAnchor1)).subLocal(p1.getBody().getWorldCenter());
        def.localAnchorB = toPoint(e2.getAnchoredPosition().add(localAnchor2)).subLocal(p2.getBody().getWorldCenter());
        return addJoint(e1, e2, def);
    }
    public RopeJoint addRopeJoint(Entity e1, Entity e2) {
        var c1 = e1.getBoundingBoxComponent().getCenterLocal();
        var c2 = e2.getBoundingBoxComponent().getCenterLocal();
        return addRopeJoint(e1, e2, c1, c2, e1.getCenter().distance(e2.getCenter()));
    }
    public RopeJoint addRopeJoint(Entity e1, Entity e2, Point2D localAnchor1, Point2D localAnchor2, double length) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        RopeJointDef def = new RopeJointDef();
        def.localAnchorA.set(toPoint(e1.getAnchoredPosition().add(localAnchor1)).subLocal(p1.getBody().getWorldCenter()));
        def.localAnchorB.set(toPoint(e2.getAnchoredPosition().add(localAnchor2)).subLocal(p2.getBody().getWorldCenter()));
        def.maxLength = toMetersF(length);
        return addJoint(e1, e2, def);
    }
    public PrismaticJoint addPrismaticJoint(Entity e1, Entity e2, Point2D axis, double limit) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        var def = new PrismaticJointDef();
        def.initialize(p1.getBody(), p2.getBody(), p2.getBody().getWorldCenter(), toVector(axis));
        def.enableLimit = true;
        def.upperTranslation = toMetersF(limit);
        return addJoint(e1, e2, def);
    }
    public <T extends Joint> T addJoint(Entity e1, Entity e2, JointDef<T> def) {
        checkJointRequirements(e1, e2);
        var p1 = e1.getComponent(PhysicsComponent.class);
        var p2 = e2.getComponent(PhysicsComponent.class);
        def.setBodyA(p1.body);
        def.setBodyB(p2.body);
        return jboxWorld.createJoint(def);
    }
    private void checkJointRequirements(Entity e1, Entity e2) {
        if (!e1.hasComponent(PhysicsComponent.class) || !e2.hasComponent(PhysicsComponent.class)) {
            throw new IllegalArgumentException("Cannot create a joint: both entities must have PhysicsComponent");
        }
    }
    public void removeJoint(Joint joint) {
        jboxWorld.destroyJoint(joint);
    }
    @Override
    public double toMeters(double pixels) {
        return pixels * METERS_PER_PIXELS;
    }
    @Override
    public double toPixels(double meters) {
        return meters * PIXELS_PER_METER;
    }
    @Override
    public Vec2 toPoint(Point2D p) {
        return new Vec2(toMetersF(p.getX()), toMetersF(appHeight - p.getY()));
    }
    @Override
    public Point2D toPoint(Vec2 p) {
        return new Point2D(toPixels(p.x), toPixels(toMeters(appHeight) - p.y));
    }
    private class CollisionFilterCallback extends ContactFilter {
        @Override
        public boolean shouldCollide(Fixture fixtureA, Fixture fixtureB) {
            Entity e1 = fixtureA.getBody().getEntity();
            Entity e2 = fixtureB.getBody().getEntity();
            if (areCollidable(e1, e2) && isIgnored(e1, e2))
                return false;
            return super.shouldCollide(fixtureA, fixtureB);
        }
    }
}
package intermediate;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.dsl.components.ExpireCleanComponent;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.geometry.Rectangle2D;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class RigidBodyPhysicsSample extends GameApplication {
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
    }
    @Override
    protected void initInput() {
        getInput().addAction(new UserAction("LMB") {
            private double x;
            private double y;
            @Override
            protected void onActionBegin() {
                x = getInput().getMouseXWorld();
                y = getInput().getMouseYWorld();
            }
            @Override
            protected void onActionEnd() {
                var endx = getInput().getMouseXWorld();
                var endy = getInput().getMouseYWorld();
                spawnBullet(x, y, endx - x, endy - y);
            }
        }, MouseButton.PRIMARY);
    }
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.BLACK);
        entityBuilder()
                .buildScreenBoundsAndAttach(40);
        for (int y = 9; y <= 20; y++) {
            for (int x = 30; x < 51; x++) {
                spawnVertical(x * 25, y * 35 - 10);
            }
        }
        for (int y = 9; y <= 20; y++) {
            for (int x = 10; x < 18; x++) {
                spawnHorizontal(x * 64 + 105, y * 35 - 10 - 5);
            }
        }
    }
    private void spawnBullet(double x, double y, double vx, double vy) {
        var physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(25.5f).restitution(0.5f));
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setOnPhysicsInitialized(() -> {
            physics.setLinearVelocity(vx * 10, vy * 10);
        });
        entityBuilder()
                .at(x, y)
                .bbox(new HitBox(BoundingShape.circle(450 / 15.0 / 2.0)))
                .view(texture("ball.png", 450 / 15.0, 449 / 15.0))
                .with(physics)
                .with(new ExpireCleanComponent(Duration.seconds(5)).animateOpacity())
                .buildAndAttach();
    }
    private void spawnHorizontal(double x, double y) {
        var physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(4.5f).friction(1.0f).restitution(0.05f));
        physics.setBodyType(BodyType.DYNAMIC);
        var t = texture("brick.png").subTexture(new Rectangle2D(0, 0, 64, 5));
        entityBuilder()
                .at(x, y)
                .viewWithBBox(t)
                .with(physics)
                .buildAndAttach();
    }
    private void spawnVertical(double x, double y) {
        var physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(6.5f).friction(1.0f).restitution(0.05f));
        physics.setBodyType(BodyType.DYNAMIC);
        var t = texture("brick.png")
                .subTexture(new Rectangle2D(0, 0, 10, 30))
                .multiplyColor(Color.RED);
        entityBuilder()
                .at(x, y)
                .viewWithBBox(t)
                .with(physics)
                .buildAndAttach();
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package com.almasb.fxgl.physics;
import com.almasb.fxgl.entity.Entity;
public abstract class SensorCollisionHandler {
    protected void onCollisionBegin(Entity other) {
    }
    protected void onCollision(Entity other) {
    }
    protected void onCollisionEnd(Entity other) {
    }
}
package intermediate;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.collections.FXCollections;
import javafx.geometry.Point2D;
import javafx.geometry.Rectangle2D;
import javafx.scene.Node;
import javafx.scene.control.ChoiceBox;
import javafx.scene.control.TextField;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Text;
import static com.almasb.fxgl.dsl.FXGL.*;
public class PhysicsPlaygroundSample extends GameApplication {
    private FloatTextField fieldFriction;
    private FloatTextField fieldDensity;
    private FloatTextField fieldRestitution;
    private ChoiceBox<ShapeType> cb;
    private enum ShapeType {
        BOX, CIRCLE, TRIANGLE
    }
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
    }
    @Override
    protected void initInput() {
        onBtnDown(MouseButton.SECONDARY, () -> {
            spawnBlock(getInput().getMouseXWorld(), getInput().getMouseYWorld());
        });
        getInput().addAction(new UserAction("Drag") {
            private Entity selected = null;
            private double offsetX = 0;
            private double offsetY = 0;
            @Override
            protected void onActionBegin() {
                var selectionSize = 4;
                getGameWorld().getEntitiesInRange(
                            new Rectangle2D(
                                    getInput().getMouseXWorld() - selectionSize / 2.0,
                                    getInput().getMouseYWorld() - selectionSize / 2.0,
                                    selectionSize,
                                    selectionSize
                            )
                        )
                        .stream()
                        .filter(e -> e.isType(ShapeType.BOX) || e.isType(ShapeType.CIRCLE) || e.isType(ShapeType.TRIANGLE))
                        .findFirst()
                        .ifPresent(e -> {
                            selected = e;
                            offsetX = getInput().getMouseXWorld() - selected.getX();
                            offsetY = getInput().getMouseYWorld() - selected.getY();
                        });
            }
            @Override
            protected void onAction() {
                if (selected != null) {
                    var p1 = getInput().getMousePositionWorld().subtract(offsetX, offsetY);
                    var p0 = selected.getPosition();
                    var scale = 2.5;
                    selected.getComponent(PhysicsComponent.class).setLinearVelocity(
                            (p1.getX() - p0.getX()) * scale,
                            (p1.getY() - p0.getY()) * scale
                    );
                }
            }
            @Override
            protected void onActionEnd() {
                selected = null;
            }
        }, MouseButton.PRIMARY);
    }
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.BLACK);
        entityBuilder()
                .buildScreenBoundsAndAttach(40);
    }
    @Override
    protected void initUI() {
        fieldFriction = new FloatTextField();
        fieldDensity = new FloatTextField();
        fieldRestitution = new FloatTextField();
        cb = new ChoiceBox<>(FXCollections.observableArrayList(ShapeType.BOX, ShapeType.CIRCLE, ShapeType.TRIANGLE));
        cb.setValue(ShapeType.BOX);
        VBox box = new VBox(5,
                new Text("Friction"),
                fieldFriction,
                new Text("Density"),
                fieldDensity,
                new Text("Restitution"),
                fieldRestitution,
                new Text("Shape type"),
                cb
        );
        addUINode(new Rectangle(1280 - 1100, getAppHeight() - 250, Color.LIGHTGREY), 1100, 0);
        addUINode(box, 1100, 0);
        entityBuilder()
                .at(1100, 0)
                .bbox(new HitBox(BoundingShape.box(1280 - 1100, getAppHeight() - 250)))
                .with(new PhysicsComponent())
                .buildAndAttach();
    }
    private void spawnBlock(double x, double y) {
        var p = new PhysicsComponent();
        p.setBodyType(BodyType.DYNAMIC);
        p.setFixtureDef(new FixtureDef()
                .friction(fieldFriction.getFloat())
                .density(fieldDensity.getFloat())
                .restitution(fieldRestitution.getFloat())
        );
        BoundingShape shape;
        Node view;
        switch (cb.getValue()) {
            case BOX:
                shape = BoundingShape.box(40, 40);
                break;
            case CIRCLE:
                shape = BoundingShape.circle(20);
                break;
            case TRIANGLE:
            default:
                shape = BoundingShape.polygon(new Point2D(0, 40), new Point2D(20, 0), new Point2D(40, 40));
                break;
        }
        switch (cb.getValue()) {
            case BOX:
                view = new Rectangle(40, 40, Color.BLUE);
                ((Rectangle) view).setStroke(Color.DARKBLUE);
                break;
            case CIRCLE:
                view = new Circle(20, 20, 20, Color.YELLOW);
                ((Circle) view).setStroke(Color.ORANGE);
                break;
            case TRIANGLE:
            default:
                view = new Polygon(0, 40, 20, 0, 40, 40);
                ((Polygon) view).setFill(Color.RED);
                ((Polygon) view).setStroke(Color.DARKRED);
                break;
        }
        entityBuilder()
                .type(cb.getValue())
                .at(x, y)
                .bbox(shape)
                .view(view)
                .with(p)
                .buildAndAttach();
    }
    private static class FloatTextField extends TextField {
        FloatTextField() {
            setText("0.2");
        }
        float getFloat() {
            try {
                return Float.parseFloat(getText());
            } catch (Exception e) {
                return 0.2f;
            }
        }
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package advanced.platformer;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.entity.EntityFactory;
import com.almasb.fxgl.entity.SpawnData;
import com.almasb.fxgl.entity.Spawns;
import com.almasb.fxgl.entity.state.StateComponent;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyDef;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.geometry.Point2D;
import static com.almasb.fxgl.dsl.FXGL.entityBuilder;
public class RobotFactory implements EntityFactory {
    @Spawns("robot")
    public Entity newRobot(SpawnData data) {
        BodyDef bd = new BodyDef();
        bd.setFixedRotation(true);
        bd.setType(BodyType.DYNAMIC);
        PhysicsComponent physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().friction(0).density(0.25f));
        physics.setBodyDef(bd);
        physics.addGroundSensor(new HitBox("GROUND_SENSOR", new Point2D(275 / 2 - 3, 260 - 5), BoundingShape.box(6, 10)));
        return entityBuilder(data)
                .from(data)
                .bbox(new HitBox("head", new Point2D(110, 50), BoundingShape.box(70, 70)))
                .bbox(new HitBox("body", new Point2D(110, 120), BoundingShape.box(40, 130)))
                .bbox(new HitBox("legs", new Point2D(275 / 2 - 25, 125*2), BoundingShape.box(40, 10)))
                .scaleOrigin(275 / 2, 125*2)
                .collidable()
                .with(new StateComponent())
                .with(physics)
                .with(new RobotComponent())
                .build();
    }
    @Spawns("platform")
    public Entity newPlatform(SpawnData data) {
        return entityBuilder(data)
                .bbox(new HitBox(BoundingShape.box(data.<Integer>get("width"), data.<Integer>get("height"))))
                .with(new PhysicsComponent())
                .build();
    }
}
package advanced.platformer;
import com.almasb.fxgl.core.math.FXGLMath;
import com.almasb.fxgl.entity.component.Component;
import com.almasb.fxgl.entity.components.ViewComponent;
import com.almasb.fxgl.entity.state.EntityState;
import com.almasb.fxgl.entity.state.StateComponent;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.texture.AnimatedTexture;
import com.almasb.fxgl.texture.AnimationChannel;
import javafx.util.Duration;
import java.util.Map;
import static com.almasb.fxgl.dsl.FXGL.image;
public class RobotComponent extends Component {
    private StateComponent state;
    private PhysicsComponent physics;
    private ViewComponent view;
    private AnimatedTexture animatedTexture;
    private AnimationChannel animStand,
            animWalk,
            animRun,
            animJump,
            animFall,
            animCrouch,
            animRoll,
            animDeath;
    private final EntityState STAND = new EntityState("STAND");
    private final EntityState WALK = new EntityState("WALK");
    private final EntityState RUN = new EntityState("RUN");
    private final EntityState CROUCH = new EntityState("CROUCH");
    private final EntityState JUMP = new EntityState("JUMP") {
        @Override
        protected void onUpdate(double tpf) {
            if (physics.getVelocityY() > 0) {
                state.changeState(FALL);
            }
        }
    };
    private final EntityState FALL = new EntityState("FALL") {
        @Override
        protected void onUpdate(double tpf) {
            if (physics.isOnGround()) {
                physics.setVelocityX(0);
                state.changeState(STAND);
            }
        }
    };
    private final EntityState ROLL = new EntityState("ROLL") {
        @Override
        public void onExitingTo(EntityState entityState) {
            physics.setVelocityX(0);
        }
    };
    private final EntityState DEATH = new EntityState("DEATH");
    private static class StateData {
        private AnimationChannel channel;
        private int moveSpeed;
        public StateData(AnimationChannel channel, int moveSpeed) {
            this.channel = channel;
            this.moveSpeed = moveSpeed;
        }
    }
    private Map<EntityState, StateData> stateData;
    public RobotComponent() {
        animWalk = new AnimationChannel(image("robot_walk.png"), 7, 275, 275, Duration.seconds(0.8), 0, 15);
        animRun = new AnimationChannel(image("robot_run.png"), 7, 275, 275, Duration.seconds(0.8), 0, 15);
        animStand = new AnimationChannel(image("robot_stand.png"), 7, 275, 275, Duration.seconds(1.5), 0, 29);
        animJump = new AnimationChannel(image("robot_jump.png"), 7, 275, 275, Duration.seconds(0.4), 0, 25);
        animFall = new AnimationChannel(image("robot_jump.png"), 7, 275, 275, Duration.seconds(0.95), 25, 25);
        animCrouch = new AnimationChannel(image("robot_crouch.png"), 7, 275, 275, Duration.seconds(0.8), 0, 20);
        animRoll = new AnimationChannel(image("robot_roll.png"), 7, 275, 275, Duration.seconds(0.9), 0, 23);
        animDeath = new AnimationChannel(image("robot_death.png"), 7, 275, 275, Duration.seconds(1.1), 0, 26);
        stateData = Map.of(
                STAND, new StateData(animStand, 0),
                WALK, new StateData(animWalk, 170),
                RUN, new StateData(animRun, 340),
                JUMP, new StateData(animJump, 580),
                FALL, new StateData(animFall, 0),
                CROUCH, new StateData(animCrouch, 70),
                ROLL, new StateData(animRoll, 400),
                DEATH, new StateData(animDeath, 0)
        );
        animatedTexture = new AnimatedTexture(animStand);
        animatedTexture.loop();
        animatedTexture.setOnCycleFinished(() -> {
            if (animatedTexture.getAnimationChannel() == animJump) {
                state.changeState(FALL);
            } else if (animatedTexture.getAnimationChannel() == animRoll) {
                state.changeState(STAND);
            }
        });
    }
    @Override
    public void onAdded() {
        state = entity.getComponent(StateComponent.class);
        physics = entity.getComponent(PhysicsComponent.class);
        view = entity.getComponent(ViewComponent.class);
        view.addChild(animatedTexture);
        state.changeState(STAND);
        state.currentStateProperty().addListener((o, oldState, newState) -> {
            System.out.println("new state: " + newState);
            var data = stateData.get(newState);
            animatedTexture.loopAnimationChannel(data.channel);
        });
    }
    public void walkLeft() {
        tryMovingState(WALK, -1);
    }
    public void walkRight() {
        tryMovingState(WALK, +1);
    }
    public void runLeft() {
        tryMovingState(RUN, -1);
    }
    public void runRight() {
        tryMovingState(RUN, +1);
    }
    public void crouchLeft() {
        tryMovingState(CROUCH, -1);
    }
    public void crouchRight() {
        tryMovingState(CROUCH, +1);
    }
    private void tryMovingState(EntityState newState, int scale) {
        if (state.isIn(STAND, WALK, RUN, CROUCH)) {
            getEntity().setScaleX(scale * FXGLMath.abs(getEntity().getScaleX()));
            physics.setVelocityX(scale * stateData.get(newState).moveSpeed);
            if (state.getCurrentState() != newState) {
                state.changeState(newState);
            }
        }
    }
    public void stop() {
        if (state.isIn(WALK, RUN, CROUCH)) {
            physics.setVelocityX(0);
            state.changeState(STAND);
        }
    }
    public void jump() {
        if (state.isIn(ROLL, JUMP))
            return;
        physics.setVelocityY(-580);
        state.changeState(JUMP);
    }
    public void roll() {
        if (state.isIn(ROLL, JUMP))
            return;
        physics.setVelocityX(getEntity().getScaleX() * 400);
        state.changeState(ROLL);
    }
    public void die() {
        state.changeState(DEATH);
    }
    @Override
    public boolean isComponentInjectionRequired() {
        return false;
    }
}
package sandbox;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.controllerinput.ControllerInputService;
import com.almasb.fxgl.dsl.components.FollowComponent;
import com.almasb.fxgl.dsl.views.MinimapView;
import com.almasb.fxgl.entity.Entity;
import com.almasb.fxgl.input.Input;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.input.virtual.VirtualButton;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import javafx.geometry.Point2D;
import javafx.scene.Group;
import javafx.scene.input.KeyCode;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class PlatformerSample extends GameApplication {
    private Entity player;
    private Entity poly;
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1200);
        settings.setHeight(600);
        settings.setTitle("PlatformerSample");
        settings.setVersion("0.1");
    }
    @Override
    protected void initInput() {
        Input input = getInput();
        input.addAction(new UserAction("Left") {
            @Override
            protected void onActionBegin() {
                player.getComponent(PhysicsComponent.class).setVelocityX(-200);
            }
        }, KeyCode.A, VirtualButton.LEFT);
        input.addAction(new UserAction("Right") {
            @Override
            protected void onActionBegin() {
                player.getComponent(PhysicsComponent.class).setVelocityX(200);
            }
        }, KeyCode.D, VirtualButton.RIGHT);
        input.addAction(new UserAction("Jump") {
            @Override
            protected void onActionBegin() {
                PhysicsComponent physics = player.getComponent(PhysicsComponent.class);
                if (physics.isOnGround()) {
                    physics.setVelocityY(-500);
                }
            }
        }, KeyCode.W, VirtualButton.A);
        onKeyDown(KeyCode.I, "Info", () -> System.out.println(player.getCenter()));
        input.addAction(new UserAction("Grow") {
            @Override
            protected void onActionBegin() {
                player.setScaleX(player.getScaleX() * 1.25);
                player.setScaleY(player.getScaleY() * 1.25);
            }
        }, KeyCode.SPACE);
        input.addAction(new UserAction("Grow Poly") {
            @Override
            protected void onActionBegin() {
                poly.setScaleX(poly.getScaleX() * 1.25);
                poly.setScaleY(poly.getScaleY() * 1.25);
            }
        }, KeyCode.G);
    }
    @Override
    protected void initGame() {
        entityBuilder().buildScreenBoundsAndAttach(40);
        createPlatforms();
        player = createPlayer(100, 100, 40, 60);
        player.getTransformComponent().setScaleOrigin(new Point2D(20, 30));
        player.getComponent(PhysicsComponent.class).onGroundProperty().addListener((o, oldValue, newValue) -> {
            System.out.println(newValue ? "On Ground" : "In the air");
        });
        entityBuilder()
                .at(300, 150)
                .view(new Circle(25, Color.RED))
                .with(new FollowComponent(player, 150, 50, 60).setMoveDelay(Duration.seconds(2)))
                .buildAndAttach();
    }
    private void createPlatforms() {
        entityBuilder()
                .at(0, 500)
                .view(new Rectangle(120, 100, Color.GRAY))
                .bbox(new HitBox("Main", BoundingShape.chain(
                        new Point2D(0, 0),
                        new Point2D(120, 0),
                        new Point2D(120, 100),
                        new Point2D(0, 100)
                )))
                .with(new PhysicsComponent())
                .buildAndAttach();
        entityBuilder()
                .at(180, 500)
                .view(new Rectangle(400, 100, Color.GRAY))
                .bbox(new HitBox("Main", BoundingShape.chain(
                        new Point2D(0, 0),
                        new Point2D(400, 0),
                        new Point2D(400, 100),
                        new Point2D(0, 100)
                )))
                .with(new PhysicsComponent())
                .buildAndAttach();
        var view = new Group();
        var first = new Polygon(
                0, 0, 200, 0, 250, 100, 0, 30
        );
        first.setTranslateX(-15);
        first.setTranslateY(10);
        view.getChildren().add(first);
        Polygon second = new Polygon(
                0, -30, 30, -30, 60, 30, 0, 30
        );
        second.setTranslateX(280);
        second.setTranslateY(50);
        view.getChildren().add(second);
        var third = new Rectangle(30, 30);
        third.setTranslateX(250);
        third.setTranslateY(-30);
        view.getChildren().add(third);
        poly = entityBuilder()
                .at(180, 350)
                .view(view)
                .bbox(new HitBox("Main", new Point2D(-15, 10), BoundingShape.polygon(
                        new Point2D(0, 0),
                        new Point2D(200, 0),
                        new Point2D(250, 100),
                        new Point2D(0, 30)
                )))
                .bbox(new HitBox("2nd", new Point2D(250, -30), BoundingShape.box(30, 30)))
                .bbox(new HitBox("3rd", new Point2D(280, 50), BoundingShape.polygon(
                        new Point2D(0, -30),
                        new Point2D(30, -30),
                        new Point2D(60, 30),
                        new Point2D(0, 30)
                )))
                .with(new PhysicsComponent())
                .buildAndAttach();
    }
    private Entity createPlayer(double x, double y, double width, double height) {
        PhysicsComponent physics = new PhysicsComponent();
        physics.addGroundSensor(new HitBox(new Point2D(5, height - 5), BoundingShape.box(width - 10, 10)));
        physics.setBodyType(BodyType.DYNAMIC);
        return entityBuilder()
                .at(x, y)
                .viewWithBBox(new Rectangle(width, height, Color.BLUE))
                .with(physics)
                .buildAndAttach();
    }
    @Override
    protected void initUI() {
        var minimap = new MinimapView(getGameWorld(), 800, 600, 200, 100);
        minimap.setEntityColor(Color.GREEN);
        addUINode(minimap, getAppWidth() - 210, getAppHeight() - 110);
    }
    private int count = 0;
    @Override
    protected void onUpdate(double tpf) {
        if (count >= 500)
            return;
        System.out.println(tpf);
        count++;
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package advanced;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.app.scene.GameView;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.RaycastResult;
import javafx.geometry.Point2D;
import javafx.scene.paint.Color;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import static com.almasb.fxgl.dsl.FXGL.*;
public class RaycastSample extends GameApplication {
    @Override
    protected void initSettings(GameSettings settings) { }
    private Line laser;
    private double endY;
    @Override
    protected void initGame() {
        spawnWall(500, 100, 50, 50);
        spawnWall(550, 150, 50, 50);
        spawnWall(600, 200, 50, 50);
        spawnWall(600, 400, 50, 50);
        spawnWall(300, 450, 50, 50);
        spawnWall(500, 550, 50, 50);
        spawnWall(300, 300, 50, 50);
        laser = new Line();
        laser.setStroke(Color.RED);
        laser.setStrokeWidth(2);
        laser.setStartY(300);
        getGameScene().addGameView(new GameView(laser, 0));
        endY = -300;
    }
    @Override
    protected void onUpdate(double tpf) {
        laser.setEndX(getAppWidth());
        laser.setEndY(endY);
        RaycastResult result = getPhysicsWorld().raycast(new Point2D(0, 300), new Point2D(getAppWidth(), endY));
        result.getPoint().ifPresent(p -> {
            laser.setEndX(p.getX());
            laser.setEndY(p.getY());
        });
        endY += 2;
        if (endY >= getAppHeight() + 300)
            endY = -300;
    }
    private void spawnWall(double x, double y, double w, double h) {
        entityBuilder()
                .at(x, y)
                .viewWithBBox(new Rectangle(w, h))
                .with(new PhysicsComponent())
                .buildAndAttach();
    }
    public static void main(String[] args) {
        launch(args);
    }
}
package sandbox;
import com.almasb.fxgl.app.GameApplication;
import com.almasb.fxgl.app.GameSettings;
import com.almasb.fxgl.dsl.components.ExpireCleanComponent;
import com.almasb.fxgl.entity.components.CollidableComponent;
import com.almasb.fxgl.input.UserAction;
import com.almasb.fxgl.physics.BoundingShape;
import com.almasb.fxgl.physics.HitBox;
import com.almasb.fxgl.physics.PhysicsComponent;
import com.almasb.fxgl.physics.box2d.dynamics.BodyType;
import com.almasb.fxgl.physics.box2d.dynamics.FixtureDef;
import javafx.scene.input.MouseButton;
import javafx.scene.paint.Color;
import javafx.util.Duration;
import static com.almasb.fxgl.dsl.FXGL.*;
public class PhysicsBounceSample extends GameApplication {
    private enum TType {
        BULLET, WALL
    }
    @Override
    protected void initSettings(GameSettings settings) {
        settings.setWidth(1280);
        settings.setHeight(720);
    }
    @Override
    protected void initInput() {
        getInput().addAction(new UserAction("LMB") {
            private double x;
            private double y;
            @Override
            protected void onActionBegin() {
                x = getInput().getMouseXWorld();
                y = getInput().getMouseYWorld();
            }
            @Override
            protected void onActionEnd() {
                var endx = getInput().getMouseXWorld();
                var endy = getInput().getMouseYWorld();
                spawnBullet(x, y, endx - x, endy - y);
            }
        }, MouseButton.PRIMARY);
    }
    @Override
    protected void initGame() {
        getGameScene().setBackgroundColor(Color.LIGHTGRAY);
        var screenBounds = entityBuilder().buildScreenBoundsAndAttach(50);
        screenBounds.addComponent(new CollidableComponent(true));
        screenBounds.setType(TType.WALL);
    }
    @Override
    protected void initPhysics() {
        onCollisionBegin(TType.WALL, TType.BULLET, (wall, bullet) -> {
            var vx = bullet.getComponent(PhysicsComponent.class).getVelocityX();
            var vy = bullet.getComponent(PhysicsComponent.class).getVelocityY();
            if (getGameWorld().getEntitiesInRange(bullet.getBoundingBoxComponent().range(100, 100)).size() < 10) {
                spawnBullet(bullet.getX() + 30 * -Math.signum(vx), bullet.getY() + 30 * -Math.signum(vy), -Math.signum(vx) * 20, -Math.signum(vy) * 20);
            }
        });
    }
    private void spawnBullet(double x, double y, double vx, double vy) {
        var physics = new PhysicsComponent();
        physics.setFixtureDef(new FixtureDef().density(25.5f).restitution(0.36f));
        physics.setBodyType(BodyType.DYNAMIC);
        physics.setOnPhysicsInitialized(() -> {
            physics.setLinearVelocity(vx * 10, vy * 10);
        });
        entityBuilder()
                .at(x, y)
                .type(TType.BULLET)
                .bbox(new HitBox(BoundingShape.circle(450 / 15.0 / 2.0)))
                .view(texture("ball.png", 450 / 15.0, 449 / 15.0))
                .with(physics)
                .with(new ExpireCleanComponent(Duration.seconds(5)).animateOpacity())
                .collidable()
                .buildAndAttach();
    }
    public static void main(String[] args) {
        launch(args);
    }
}