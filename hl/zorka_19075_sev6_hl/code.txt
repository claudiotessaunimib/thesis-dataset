package bsh;
/**
	Static routines supporing type comparison and conversion in BeanShell.
 The following are notes on type comparison and conversion in BeanShell.
*/
public class Types
{
	/*
		Type conversion identifiers.  An ASSIGNMENT allows conversions that would
		normally happen on assignment.  A CAST performs numeric conversions to smaller
		types (as in an explicit Java cast) and things allowed only in variable and array
		declarations (e.g. byte b = 42;)
	*/
	public static final int CAST=0, ASSIGNMENT=1;
	
	static final int 
		JAVA_BASE_ASSIGNABLE = 1,
		JAVA_BOX_TYPES_ASSIGABLE = 2,
		JAVA_VARARGS_ASSIGNABLE = 3,
		BSH_ASSIGNABLE = 4;
	static final int
		FIRST_ROUND_ASSIGNABLE = JAVA_BASE_ASSIGNABLE,
		LAST_ROUND_ASSIGNABLE = BSH_ASSIGNABLE;
	/**
		Special value that indicates by identity that the result of a cast
		operation was a valid cast.  This is used by castObject() and
		castPrimitive() in the checkOnly mode of operation.  This value is a
		Primitive type so that it can be returned by castPrimitive.
	*/
	static Primitive VALID_CAST = new Primitive(1);
	static Primitive INVALID_CAST = new Primitive(-1);
	/**
		Get the Java types of the arguments.
	*/
    public static Class[] getTypes( Object[] args )
    {
        if ( args == null )
            return new Class[0];
        Class[] types = new Class[ args.length ];
        for( int i=0; i<args.length; i++ )
        {
			if ( args[i] == null )
				types[i] = null;
            else
			if ( args[i] instanceof Primitive )
                types[i] = ((Primitive)args[i]).getType();
            else
                types[i] = args[i].getClass();
        }
        return types;
    }
	/**
	 Is the 'from' signature (argument types) assignable to the 'to'
	 signature (candidate method types)
	 This method handles the special case of null values in 'to' types
	 indicating a loose type and matching anything.
	 */
	/* Should check for strict java here and limit to isJavaAssignable() */
	public static boolean isSignatureAssignable( Class[] from, Class[] to, int round )
	{
		if ( round != JAVA_VARARGS_ASSIGNABLE && from.length != to.length )
			return false;
		switch ( round )
		{
			case JAVA_BASE_ASSIGNABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isJavaBaseAssignable( to[i], from[i] ) )
						return false;
				return true;
			case JAVA_BOX_TYPES_ASSIGABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isJavaBoxTypesAssignable( to[i], from[i] ) )
						return false;
				return true;
			case JAVA_VARARGS_ASSIGNABLE:
				return isSignatureVarargsAssignable( from, to );
			case BSH_ASSIGNABLE:
				for( int i=0; i<from.length; i++ )
					if ( !isBshAssignable( to[i], from[i] ) )
						return false;
				return true;
			default:
				throw new InterpreterError("bad case");
		}
	}
	private static boolean isSignatureVarargsAssignable(
		Class[] from, Class[] to )
	{
		return false;
	}
	/**
		Test if a conversion of the rhsType type to the lhsType type is legal via
	 standard Java assignment conversion rules (i.e. without a cast).
	 The rules include Java 5 autoboxing/unboxing.
		<p/>
		For Java primitive TYPE classes this method takes primitive promotion
		into account.  The ordinary Class.isAssignableFrom() does not take
		primitive promotion conversions into account.  Note that Java allows
		additional assignments without a cast in combination with variable
		declarations and array allocations.  Those are handled elsewhere
	 	(maybe should be here with a flag?)
		<p/>
		This class accepts a null rhsType type indicating that the rhsType was the
		value Primitive.NULL and allows it to be assigned to any reference lhsType
		type (non primitive).
		<p/>
		Note that the getAssignableForm() method is the primary bsh method for
		checking assignability.  It adds additional bsh conversions, etc.
		@see #isBshAssignable( Class, Class )
		@param lhsType assigning from rhsType to lhsType
		@param rhsType assigning from rhsType to lhsType
	*/
	public static boolean isJavaAssignable( Class lhsType, Class rhsType ) {
		return isJavaBaseAssignable( lhsType, rhsType )
			|| isJavaBoxTypesAssignable( lhsType, rhsType );
	}
	/**
		Is the assignment legal via original Java (up to version 1.4)
		assignment rules, not including auto-boxing/unboxing.
	 @param rhsType may be null to indicate primitive null value
	*/
	public static boolean isJavaBaseAssignable( Class<?> lhsType, Class<?> rhsType )
	{
		/*
			Assignment to loose type, defer to bsh extensions
			Note: we could shortcut this here:
			if ( lhsType == null ) return true;
			rather than forcing another round.  It's not strictly a Java issue,
			so does it belong here?
		*/
		if ( lhsType == null )
			return false;
		// null rhs type corresponds to type of Primitive.NULL
		// assignable to any object type
		if ( rhsType == null )
			return !lhsType.isPrimitive();
		if ( lhsType.isPrimitive() && rhsType.isPrimitive() )
		{
			if ( lhsType == rhsType )
				return true;
			// handle primitive widening conversions - JLS 5.1.2
			if ( (rhsType == Byte.TYPE) &&
				(lhsType == Short.TYPE || lhsType == Integer.TYPE
				|| lhsType == Long.TYPE || lhsType == Float.TYPE
				|| lhsType == Double.TYPE))
                    return true;
            if ( (rhsType == Short.TYPE) &&
				(lhsType == Integer.TYPE || lhsType == Long.TYPE ||
                lhsType == Float.TYPE || lhsType == Double.TYPE))
                    return true;
            if ((rhsType == Character.TYPE) &&
				(lhsType == Integer.TYPE || lhsType == Long.TYPE ||
                lhsType == Float.TYPE || lhsType == Double.TYPE))
                    return true;
            if ((rhsType == Integer.TYPE) &&
				(lhsType == Long.TYPE || lhsType == Float.TYPE ||
                lhsType == Double.TYPE))
                    return true;
            if ((rhsType == Long.TYPE) &&
				(lhsType == Float.TYPE || lhsType == Double.TYPE))
                return true;
            if ((rhsType == Float.TYPE) && (lhsType == Double.TYPE))
                return true;
        }
        else
            if ( lhsType.isAssignableFrom(rhsType) )
                return true;
        return false;
    }
	/**
		Determine if the type is assignable via Java boxing/unboxing rules.
	*/
	public static boolean isJavaBoxTypesAssignable(
		Class lhsType, Class rhsType )
	{
		// Assignment to loose type... defer to bsh extensions
		if ( lhsType == null )
			return false;
		// prim can be boxed and assigned to Object
		if ( lhsType == Object.class )
			return true;
		// prim numeric type can be boxed and assigned to number
		if ( lhsType == Number.class
			&& rhsType != Character.TYPE
			&& rhsType != Boolean.TYPE
		)
			return true;
		// General case prim type to wrapper or vice versa.
		// I don't know if this is faster than a flat list of 'if's like above.
		// wrapperMap maps both prim to wrapper and wrapper to prim types,
		// so this test is symmetric
		if ( Primitive.wrapperMap.get( lhsType ) == rhsType )
			return true;
		return false;
	}
	/**
	 Test if a type can be converted to another type via BeanShell
	 extended syntax rules (a superset of Java conversion rules).
	 */
	public static boolean isBshAssignable( Class toType, Class fromType )
	{
		try {
			return castObject(
				toType, fromType, null/*fromValue*/,
				ASSIGNMENT, true/*checkOnly*/
			) == VALID_CAST;
		} catch ( UtilEvalError e ) {
			// This should not happen with checkOnly true
			throw new InterpreterError("err in cast check: "+e);
		}
	}
	/**
		Attempt to cast an object instance to a new type if possible via
	 BeanShell extended syntax rules.  These rules are always a superset of
	 Java conversion rules.  If you wish to impose context sensitive
	 conversion rules then you must test before calling this method.
	 <p/>
		This method can handle fromValue Primitive types (representing
		primitive casts) as well as fromValue object casts requiring interface
		generation, etc.
		@param toType the class type of the cast result, which may include
		primitive types, e.g. Byte.TYPE
		@param fromValue an Object or bsh.Primitive primitive value (including
			Primitive.NULL or Primitive.VOID )
		@see #isBshAssignable( Class, Class )
	*/
	public static Object castObject(
		Object fromValue, Class toType, int operation )
		throws UtilEvalError
	{
		if ( fromValue == null )
			throw new InterpreterError("null fromValue");
		Class fromType =
			fromValue instanceof Primitive ?
				((Primitive)fromValue).getType()
				: fromValue.getClass();
		return castObject(
			toType, fromType, fromValue, operation, false/*checkonly*/ );
	}
	/**
	 Perform a type conversion or test if a type conversion is possible with
	 respect to BeanShell extended rules.  These rules are always a superset of
	 the Java language rules, so this method can also perform (but not test)
	 any Java language assignment or cast conversion.
	 <p/>
	 This method can perform the functionality of testing if an assignment
	 or cast is ultimately possible (with respect to BeanShell) as well as the
	 functionality of performing the necessary conversion of a value based
	 on the specified target type.  This combined functionality is done for
	 expediency and could be separated later.
	 <p/>
	 Other methods such as isJavaAssignable() should be used to determine the
	 suitability of an assignment in a fine grained or restrictive way based
	 on context before calling this method
	 <p/>
	 A CAST is stronger than an ASSIGNMENT operation in that it will attempt to
	 perform primtive operations that cast to a smaller type. e.g. (byte)myLong;
	 These are used in explicit primitive casts, primitive delclarations and
	 array declarations. I don't believe there are any object conversions which are
	 different between  ASSIGNMENT and CAST (e.g. scripted object to interface proxy
	 in bsh is done on assignment as well as cast).
	 <p/>
	 This method does not obey strictJava(), you must test first before
	 using this method if you care. (See #isJavaAssignable()).
	 <p/>
		@param toType the class type of the cast result, which may include
			primitive types, e.g. Byte.TYPE.  toType may be null to indicate a
			loose type assignment (which matches any fromType).
		@param fromType is the class type of the value to be cast including
			java primitive TYPE classes for primitives.
			If fromValue is (or would be) Primitive.NULL then fromType should be null.
		@param fromValue an Object or bsh.Primitive primitive value (including
			Primitive.NULL or Primitive.VOID )
		@param checkOnly If checkOnly is true then fromValue must be null.
			FromType is checked for the cast to toType...
			If checkOnly is false then fromValue must be non-null
			(Primitive.NULL is ok) and the actual cast is performed.
		@throws UtilEvalError on invalid assignment (when operation is
			assignment ).
		@throws UtilTargetError wrapping ClassCastException on cast error
			(when operation is cast)
		@param operation is Types.CAST or Types.ASSIGNMENT
		@see bsh.Primitive.getType()
	*/
	/*
		Notes: This method is currently responsible for auto-boxing/unboxing
		conversions...  Where does that need to go?
	*/
	private static Object castObject(
		Class<?> toType, Class<?> fromType, Object fromValue,
		int operation, boolean checkOnly )
		throws UtilEvalError
	{
		/*
			Lots of preconditions checked here...
			Once things are running smoothly we might comment these out
			(That's what assertions are for).
		*/
		if ( checkOnly && fromValue != null )
			throw new InterpreterError("bad cast params 1");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError("bad cast params 2");
		if ( fromType == Primitive.class )
			throw new InterpreterError("bad from Type, need to unwrap");
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError("inconsistent args 1");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError("inconsistent args 2");
		if ( toType == Void.TYPE )
			throw new InterpreterError("loose toType should be null");
		
		// assignment to loose type, void type, or exactly same type
		if ( toType == null || toType == fromType )
			return checkOnly ? VALID_CAST :
				fromValue;
		// Casting to primitive type
        if ( toType.isPrimitive() )
		{
			if ( fromType == Void.TYPE || fromType == null 
				|| fromType.isPrimitive() )
			{
				// Both primitives, do primitive cast
				return Primitive.castPrimitive( 
					toType, fromType, (Primitive)fromValue, 
					checkOnly, operation );
			} else
			{
				if ( Primitive.isWrapperType( fromType ) )
				{
					// wrapper to primitive
					// Convert value to Primitive and check/cast it.
					//Object r = checkOnly ? VALID_CAST :
					Class unboxedFromType = Primitive.unboxType( fromType );
					Primitive primFromValue;
					if ( checkOnly ) 
						primFromValue = null; // must be null in checkOnly
					else
						primFromValue = (Primitive)Primitive.wrap( 
							fromValue, unboxedFromType );
					return Primitive.castPrimitive( 
						toType, unboxedFromType, primFromValue, 
						checkOnly, operation );
				} else
				{
					// Cannot cast from arbitrary object to primitive
					if ( checkOnly )
						return INVALID_CAST;
					else
						throw castError( toType, fromType, operation );
				}
			}
        }
		// Else, casting to reference type
		// Casting from primitive or void (to reference type)
		if ( fromType == Void.TYPE || fromType == null
			|| fromType.isPrimitive() )
		{
			// cast from primitive to wrapper type
			if ( Primitive.isWrapperType( toType )
				&& fromType != Void.TYPE && fromType != null )
			{
				// primitive to wrapper type
				return checkOnly ? VALID_CAST :
					Primitive.castWrapper( 
						Primitive.unboxType(toType), 
						((Primitive)fromValue).getValue() );
			}
			// Primitive (not null or void) to Object.class type
			if ( toType == Object.class 
				&& fromType != Void.TYPE && fromType != null )
			{
				// box it
				return checkOnly ? VALID_CAST :
					((Primitive)fromValue).getValue();
			}
			// Primitive to arbitrary object type. 
			// Allow Primitive.castToType() to handle it as well as cases of 
			// Primitive.NULL and Primitive.VOID
			return Primitive.castPrimitive( 
				toType, fromType, (Primitive)fromValue, checkOnly, operation );
		}
		// If type already assignable no cast necessary
		// We do this last to allow various errors above to be caught.
		// e.g cast Primitive.Void to Object would pass this
		if ( toType.isAssignableFrom( fromType ) )
			return checkOnly ? VALID_CAST : 
				fromValue;
		// Can we use the proxy mechanism to cast a bsh.This to 
		// the correct interface?
		if ( toType.isInterface() 
			&& bsh.This.class.isAssignableFrom( fromType ) 
		)
			return checkOnly ? VALID_CAST : 
				((bsh.This)fromValue).getInterface( toType );
		// Both numeric wrapper types? 
		// Try numeric style promotion wrapper cast
		if ( Primitive.isWrapperType( toType ) 
			&& Primitive.isWrapperType( fromType ) 
		)
			return checkOnly ? VALID_CAST :
				Primitive.castWrapper( toType, fromValue );
		
		if ( checkOnly )
			return INVALID_CAST;
		else
			throw castError( toType, fromType , operation  );
	}
	/**
		Return a UtilEvalError or UtilTargetError wrapping a ClassCastException
		describing an illegal assignment or illegal cast, respectively.	
	*/
    public static UtilEvalError castError(
		Class lhsType, Class rhsType, int operation   ) 
    {
		return castError( 
			Reflect.normalizeClassName(lhsType),
			Reflect.normalizeClassName(rhsType), operation  );
    }
    public static UtilEvalError castError(
		String lhs, String rhs, int operation   ) 
    {
		if ( operation == ASSIGNMENT )
			return new UtilEvalError (
				"Can't assign " + rhs + " to "+ lhs );
		Exception cce = new ClassCastException(
			"Cannot cast " + rhs + " to " + lhs );
		return new UtilTargetError( cce );
    }
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.ArrayList;
/**
 * All of the reflection API code lies here.  It is in the form of static
 * utilities.  Maybe this belongs in LHS.java or a generic object
 * wrapper class.
 */
/*
	Note: This class is messy.  The method and field resolution need to be
	rewritten.  Various methods in here catch NoSuchMethod or NoSuchField
	exceptions during their searches.  These should be rewritten to avoid
	having to catch the exceptions.  Method lookups are now cached at a high 
	level so they are less important, however the logic is messy.
*/
public final class Reflect {
	/**
	 * Invoke method on arbitrary object instance.
	 * invocation may be static (through the object instance) or dynamic.
	 * Object may be a bsh scripted object (bsh.This type).
	 *
	 * @return the result of the method call
	 */
	public static Object invokeObjectMethod(Object object, String methodName, Object[] args, BshEvaluatingVisitor visitor, SimpleNode callerInfo) throws ReflectError, EvalError, InvocationTargetException {
		// Bsh scripted object
		if (object instanceof This && !This.isExposedThisMethod(methodName)) {
			return ((This) object).invokeMethod(methodName, args, visitor.getInterpreter(), visitor.getCallstack(), callerInfo, false/*delcaredOnly*/);
		}
		// Plain Java object, find the java method
		try {
			BshClassManager bcm = visitor.getInterpreter() == null ? null : visitor.getInterpreter().getClassManager();
			Class clas = object.getClass();
			Method method = resolveExpectedJavaMethod(bcm, clas, object, methodName, args, false);
			return invokeMethod(method, object, args);
		} catch (UtilEvalError e) {
			throw e.toEvalError(callerInfo, visitor.getCallstack());
		}
	}
	/**
	 * Invoke a method known to be static.
	 * No object instance is needed and there is no possibility of the
	 * method being a bsh scripted method.
	 */
	public static Object invokeStaticMethod(BshClassManager bcm, Class clas, String methodName, Object[] args) throws ReflectError, UtilEvalError, InvocationTargetException {
		Interpreter.debug("invoke static Method");
		Method method = resolveExpectedJavaMethod(bcm, clas, null, methodName, args, true);
		return invokeMethod(method, null, args);
	}
	/**
	 * Invoke the Java method on the specified object, performing needed
	 * type mappings on arguments and return values.
	 *
	 * @param args may be null
	 */
	public static Object invokeMethod(Method method, Object object, Object[] args) throws ReflectError, InvocationTargetException {
		if (args == null) {
			args = new Object[0];
		}
		logInvokeMethod("Invoking method (entry): ", method, args);
		boolean isVarArgs = method.isVarArgs();
		// Map types to assignable forms, need to keep this fast...
		Class[] types = method.getParameterTypes();
		Object[] tmpArgs = new Object[types.length];
		int fixedArgLen = types.length;
		if (isVarArgs) {
			if (fixedArgLen == args.length && types[fixedArgLen - 1].isAssignableFrom(args[fixedArgLen - 1].getClass())) {
				isVarArgs = false;
			} else {
				fixedArgLen--;
			}
		}
		try {
			for (int i = 0; i < fixedArgLen; i++) {
				tmpArgs[i] = Types.castObject(args[i]/*rhs*/, types[i]/*lhsType*/, Types.ASSIGNMENT);
			}
			if (isVarArgs) {
				Class varType = types[fixedArgLen].getComponentType();
				Object varArgs = Array.newInstance(varType, args.length - fixedArgLen);
				for (int i = fixedArgLen, j = 0; i < args.length; i++, j++) {
					Array.set(varArgs, j, Primitive.unwrap(Types.castObject(args[i]/*rhs*/, varType/*lhsType*/, Types.ASSIGNMENT)));
				}
				tmpArgs[fixedArgLen] = varArgs;
			}
		} catch (UtilEvalError e) {
			throw new InterpreterError("illegal argument type in method invocation: " + e);
		}
		// unwrap any primitives
		tmpArgs = Primitive.unwrap(tmpArgs);
		logInvokeMethod("Invoking method (after massaging values): ", method, tmpArgs);
		try {
			Object returnValue = method.invoke(object, tmpArgs);
			if (returnValue == null) {
				returnValue = Primitive.NULL;
			}
			Class returnType = method.getReturnType();
			return Primitive.wrap(returnValue, returnType);
		} catch (IllegalAccessException e) {
			throw new ReflectError("Cannot access method " + StringUtil.methodString(method.getName(), method.getParameterTypes()) + " in '" + method.getDeclaringClass() + "' :" + e, e);
		}
	}
	public static Object getIndex(Object array, int index) throws ReflectError, UtilTargetError {
		if (Interpreter.DEBUG) {
			Interpreter.debug("getIndex: " + array + ", index=" + index);
		}
		try {
			Object val = Array.get(array, index);
			return Primitive.wrap(val, array.getClass().getComponentType());
		} catch (ArrayIndexOutOfBoundsException e1) {
			throw new UtilTargetError(e1);
		} catch (Exception e) {
			throw new ReflectError("Array access:" + e);
		}
	}
	public static void setIndex(Object array, int index, Object val) throws ReflectError, UtilTargetError {
		try {
			val = Primitive.unwrap(val);
			Array.set(array, index, val);
		} catch (ArrayStoreException e2) {
			throw new UtilTargetError(e2);
		} catch (IllegalArgumentException e1) {
			//noinspection ThrowableInstanceNeverThrown
			throw new UtilTargetError(new ArrayStoreException(e1.toString()));
		} catch (Exception e) {
			throw new ReflectError("Array access:" + e);
		}
	}
	public static Object getStaticFieldValue(Class clas, String fieldName) throws UtilEvalError, ReflectError {
		return getFieldValue(clas, null, fieldName, true/*onlystatic*/);
	}
	/**
	 */
	public static Object getObjectFieldValue(Object object, String fieldName) throws UtilEvalError, ReflectError {
		if (object instanceof This) {
			return ((This) object).namespace.getVariable(fieldName);
		} else if (object == Primitive.NULL) {
			//noinspection ThrowableInstanceNeverThrown
			throw new UtilTargetError(new NullPointerException("Attempt to access field '" + fieldName + "' on null value"));
		} else {
			try {
				return getFieldValue(object.getClass(), object, fieldName, false/*onlystatic*/);
			} catch (ReflectError e) {
				// no field, try property acces
				if (hasObjectPropertyGetter(object.getClass(), fieldName)) {
					return getObjectProperty(object, fieldName);
				} else {
					throw e;
				}
			}
		}
	}
	public static LHS getLHSStaticField(Class clas, String fieldName) throws UtilEvalError, ReflectError {
		Field f = resolveExpectedJavaField(clas, fieldName, true/*onlystatic*/);
		return new LHS(f);
	}
	/**
	 * Get an LHS reference to an object field.
	 * <p/>
	 * This method also deals with the field style property access.
	 * In the field does not exist we check for a property setter.
	 */
	public static LHS getLHSObjectField(Object object, String fieldName) throws UtilEvalError, ReflectError {
		if (object instanceof This) {
			// I guess this is when we pass it as an argument?
			// Setting locally
			boolean recurse = false;
			return new LHS(((This) object).namespace, fieldName, recurse);
		}
		try {
			Field f = resolveExpectedJavaField(object.getClass(), fieldName, false/*staticOnly*/);
			return new LHS(object, f);
		} catch (ReflectError e) {
			// not a field, try property access
			if (hasObjectPropertySetter(object.getClass(), fieldName)) {
				return new LHS(object, fieldName);
			} else {
				throw e;
			}
		}
	}
	private static Object getFieldValue(Class clas, Object object, String fieldName, boolean staticOnly) throws UtilEvalError, ReflectError {
		try {
			Field f = resolveExpectedJavaField(clas, fieldName, staticOnly);
			Object value = f.get(object);
			Class returnType = f.getType();
			return Primitive.wrap(value, returnType);
		} catch (NullPointerException e) { // shouldn't happen
			throw new ReflectError("???" + fieldName + " is not a static field.");
		} catch (IllegalAccessException e) {
			throw new ReflectError("Can't access field: " + fieldName);
		}
	}
	/*
			 Note: this method and resolveExpectedJavaField should be rewritten
			 to invert this logic so that no exceptions need to be caught
			 unecessarily.  This is just a temporary impl.
			 @return the field or null if not found
		 */
	protected static Field resolveJavaField(Class clas, String fieldName, boolean staticOnly) throws UtilEvalError {
		try {
			return resolveExpectedJavaField(clas, fieldName, staticOnly);
		} catch (ReflectError e) {
			return null;
		}
	}
	/**
	 * @throws ReflectError if the field is not found.
	 */
	/*
			 Note: this should really just throw NoSuchFieldException... need
			 to change related signatures and code.
		 */
	protected static Field resolveExpectedJavaField(Class clas, String fieldName, boolean staticOnly) throws UtilEvalError, ReflectError {
		Field field;
		try {
			if (Capabilities.haveAccessibility()) {
				field = findAccessibleField(clas, fieldName);
			} else
			// Class getField() finds only public (and in interfaces, etc.)
			{
				field = clas.getField(fieldName);
			}
		} catch (NoSuchFieldException e) {
			throw new ReflectError("No such field: " + fieldName, e);
		} catch (SecurityException e) {
			throw new UtilTargetError("Security Exception while searching fields of: " + clas, e);
		}
		if (staticOnly && !Modifier.isStatic(field.getModifiers())) {
			throw new UtilEvalError("Can't reach instance field: " + fieldName + " from static context: " + clas.getName());
		}
		return field;
	}
	/**
	 * Used when accessibility capability is available to locate an occurrance
	 * of the field in the most derived class or superclass and set its
	 * accessibility flag.
	 * Note that this method is not needed in the simple non accessible
	 * case because we don't have to hunt for fields.
	 * Note that classes may declare overlapping private fields, so the
	 * distinction about the most derived is important.  Java doesn't normally
	 * allow this kind of access (super won't show private variables) so
	 * there is no real syntax for specifying which class scope to use...
	 *
	 * @return the Field or throws NoSuchFieldException
	 * @throws NoSuchFieldException if the field is not found
	 */
	/*
			 This method should be rewritten to use getFields() and avoid catching
			 exceptions during the search.
		 */
	private static Field findAccessibleField(Class clas, String fieldName) throws UtilEvalError, NoSuchFieldException {
		Field field;
		// Quick check catches public fields include those in interfaces
		try {
			field = clas.getField(fieldName);
			field.setAccessible(true);
			return field;
		} catch (NoSuchFieldException e) {
			// fallthrough
		}
		// Now, on with the hunt...
		while (clas != null) {
			try {
				field = clas.getDeclaredField(fieldName);
				field.setAccessible(true);
				return field;
				// Not found, fall through to next class
			} catch (NoSuchFieldException e) {
				// fallthrough
			}
			clas = clas.getSuperclass();
		}
		throw new NoSuchFieldException(fieldName);
	}
	/**
	 * This method wraps resolveJavaMethod() and expects a non-null method
	 * result. If the method is not found it throws a descriptive ReflectError.
	 */
	protected static Method resolveExpectedJavaMethod(BshClassManager bcm, Class clas, Object object, String name, Object[] args, boolean staticOnly) throws ReflectError, UtilEvalError {
		if (object == Primitive.NULL) {
			//noinspection ThrowableInstanceNeverThrown
			throw new UtilTargetError(new NullPointerException("Attempt to invoke method " + name + " on null value"));
		}
		Class[] types = Types.getTypes(args);
		Method method = resolveJavaMethod(bcm, clas, name, types, staticOnly);
		if (method == null) {
			throw new ReflectError((staticOnly ? "Static method " : "Method ") + StringUtil.methodString(name, types) + " not found in class'" + clas.getName() + "'");
		}
		return method;
	}
	/**
	 * The full blown resolver method.  All other method invocation methods
	 * delegate to this.  The method may be static or dynamic unless
	 * staticOnly is set (in which case object may be null).
	 * If staticOnly is set then only static methods will be located.
	 * <p/>
	 * <p/>
	 * This method performs caching (caches discovered methods through the
	 * class manager and utilizes cached methods.)
	 * <p/>
	 * <p/>
	 * This method determines whether to attempt to use non-public methods
	 * based on Capabilities.haveAccessibility() and will set the accessibilty
	 * flag on the method as necessary.
	 * <p/>
	 * <p/>
	 * If, when directed to find a static method, this method locates a more
	 * specific matching instance method it will throw a descriptive exception
	 * analogous to the error that the Java compiler would produce.
	 * Note: as of 2.0.x this is a problem because there is no way to work
	 * around this with a cast.
	 * <p/>
	 *
	 * @param staticOnly The method located must be static, the object param may be null.
	 * @return the method or null if no matching method was found.
	 */
	protected static Method resolveJavaMethod(BshClassManager bcm, Class clas, String name, Class[] types, boolean staticOnly) throws UtilEvalError {
		if (clas == null) {
			throw new InterpreterError("null class");
		}
		// Lookup previously cached method
		Method method = null;
		if (bcm == null) {
			Interpreter.debug("resolveJavaMethod UNOPTIMIZED lookup");
		} else {
			method = bcm.getResolvedMethod(clas, name, types, staticOnly);
		}
		if (method == null) {
			boolean publicOnly = !Capabilities.haveAccessibility();
			// Searching for the method may, itself be a priviledged action
			try {
				method = findOverloadedMethod(clas, name, types, publicOnly);
			} catch (SecurityException e) {
				throw new UtilTargetError("Security Exception while searching methods of: " + clas, e);
			}
			checkFoundStaticMethod(method, staticOnly, clas);
			// This is the first time we've seen this method, set accessibility
			// Note: even if it's a public method, we may have found it in a
			// non-public class
			if (method != null && (!publicOnly || isPublic(method))) {
				method.setAccessible(true);
			}
			// If succeeded cache the resolved method.
			if (method != null && bcm != null) {
				bcm.cacheResolvedMethod(clas, types, method);
			}
		}
		return method;
	}
	/**
	 * Get the candidate methods by searching the class and interface graph
	 * of baseClass and resolve the most specific.
	 *
	 * @return the method or null for not found
	 */
	private static Method findOverloadedMethod(Class baseClass, String methodName, Class[] types, boolean publicOnly) {
		if (Interpreter.DEBUG) {
			Interpreter.debug("Searching for method: " + StringUtil.methodString(methodName, types) + " in '" + baseClass.getName() + "'");
		}
		List<Method> publicMethods = new ArrayList<Method>();
		List<Method> nonPublicMethods = publicOnly ? null : new ArrayList<Method>();
		gatherMethodsRecursive(baseClass, methodName, types.length, publicMethods, nonPublicMethods);
		if (Interpreter.DEBUG) {
			Interpreter.debug("Looking for most specific method: " + methodName);
		}
		Method method = findMostSpecificMethod(types, publicMethods);
		if (method == null && nonPublicMethods != null) {
			method = findMostSpecificMethod(types, nonPublicMethods);
		}
		return method;
	}
	/*
			 Climb the class and interface inheritence graph of the type and collect
			 all methods matching the specified name and criterion.  If publicOnly
			 is true then only public methods in *public* classes or interfaces will
			 be returned.  In the normal (non-accessible) case this addresses the
			 problem that arises when a package private class or private inner class
			 implements a public interface or derives from a public type.
			  <p/>
			 preseving old comments for deleted getCandidateMethods() - fschmidt
		 */
	/**
	 * Accumulate all methods, optionally including non-public methods,
	 * class and interface, in the inheritence tree of baseClass.
	 * <p/>
	 * This method is analogous to Class getMethods() which returns all public
	 * methods in the inheritence tree.
	 * <p/>
	 * In the normal (non-accessible) case this also addresses the problem
	 * that arises when a package private class or private inner class
	 * implements a public interface or derives from a public type.  In other
	 * words, sometimes we'll find public methods that we can't use directly
	 * and we have to find the same public method in a parent class or
	 * interface.
	 *
	 * @return the candidate methods vector
	 */
	private static void gatherMethodsRecursive(Class baseClass, String methodName, int numArgs, List<Method> publicMethods, List<Method> nonPublicMethods) {
		// Do we have a superclass? (interfaces don't, etc.)
		Class superclass = baseClass.getSuperclass();
		if (superclass != null) {
			gatherMethodsRecursive(superclass, methodName, numArgs, publicMethods, nonPublicMethods);
		}
		// Add methods of the current class to the list.
		// In public case be careful to only add methods from a public class
		// and to use getMethods() instead of getDeclaredMethods()
		// (This addresses secure environments)
		boolean isPublicClass = isPublic(baseClass);
		if (isPublicClass || nonPublicMethods != null) {
			Method[] methods = nonPublicMethods == null ? baseClass.getMethods() : baseClass.getDeclaredMethods();
			for (Method m : methods) {
				if (m.getName().equals(methodName) && (m.isVarArgs() ? m.getParameterTypes().length - 1 <= numArgs : m.getParameterTypes().length == numArgs)) {
					if (isPublicClass && isPublic(m)) {
						publicMethods.add(m);
					} else if (nonPublicMethods != null) {
						nonPublicMethods.add(m);
					}
				}
			}
		}
		// Does the class or interface implement interfaces?
		for (Class intf : baseClass.getInterfaces()) {
			gatherMethodsRecursive(intf, methodName, numArgs, publicMethods, nonPublicMethods);
		}
	}
	/**
	 * Primary object constructor
	 * This method is simpler than those that must resolve general method
	 * invocation because constructors are not inherited.
	 * <p/>
	 * This method determines whether to attempt to use non-public constructors
	 * based on Capabilities.haveAccessibility() and will set the accessibilty
	 * flag on the method as necessary.
	 * <p/>
	 */
	public static Object constructObject(Class clas, Object[] args) throws ReflectError, InvocationTargetException {
		if (clas.isInterface()) {
			throw new ReflectError("Can't create instance of an interface: " + clas);
		}
		Class[] types = Types.getTypes(args);
		// Find the constructor.
		// (there are no inherited constructors to worry about)
		Constructor[] constructors = Capabilities.haveAccessibility() ? clas.getDeclaredConstructors() : clas.getConstructors();
		if (Interpreter.DEBUG) {
			Interpreter.debug("Looking for most specific constructor: " + clas);
		}
		Constructor con = findMostSpecificConstructor(types, constructors);
		if (con == null) {
			throw cantFindConstructor(clas, types);
		}
		if (!isPublic(con)) {
			con.setAccessible(true);
		}
		args = Primitive.unwrap(args);
		try {
			return con.newInstance(args);
		} catch (InstantiationException e) {
			throw new ReflectError("The class " + clas + " is abstract ");
		} catch (IllegalAccessException e) {
			throw new ReflectError("We don't have permission to create an instance." + "Use setAccessibility(true) to enable access.");
		} catch (IllegalArgumentException e) {
			throw new ReflectError("The number of arguments was wrong");
		}
	}
	/*
			This method should parallel findMostSpecificMethod()
			The only reason it can't be combined is that Method and Constructor
			don't have a common interface for their signatures
		*/
	static Constructor findMostSpecificConstructor(Class[] idealMatch, Constructor[] constructors) {
		int match = findMostSpecificConstructorIndex(idealMatch, constructors);
		return (match == -1) ? null : constructors[match];
	}
	static int findMostSpecificConstructorIndex(Class[] idealMatch, Constructor[] constructors) {
		Class[][] candidates = new Class[constructors.length][];
		for (int i = 0; i < candidates.length; i++) {
			candidates[i] = constructors[i].getParameterTypes();
		}
		return findMostSpecificSignature(idealMatch, candidates);
	}
	/**
	 * Find the best match for signature idealMatch.
	 * It is assumed that the methods array holds only valid candidates
	 * (e.g. method name and number of args already matched).
	 * This method currently does not take into account Java 5 covariant
	 * return types... which I think will require that we find the most
	 * derived return type of otherwise identical best matches.
	 *
	 * @param methods the set of candidate method which differ only in the
	 *                types of their arguments.
	 * @see #findMostSpecificSignature(Class[], Class[][])
	 */
	private static Method findMostSpecificMethod(Class[] idealMatch, List<Method> methods) {
		// copy signatures into array for findMostSpecificMethod()
		List<Class[]> candidateSigs = new ArrayList<Class[]>();
		List<Method> methodList = new ArrayList<Method>();
		for (Method method : methods) {
			Class[] parameterTypes = method.getParameterTypes();
			methodList.add(method);
			candidateSigs.add(parameterTypes);
			if (method.isVarArgs()) {
				Class[] candidateSig = new Class[idealMatch.length];
				int j = 0;
				for (; j < parameterTypes.length - 1; j++) {
					candidateSig[j] = parameterTypes[j];
				}
				Class varType = parameterTypes[j].getComponentType();
				for (; j < idealMatch.length; j++) {
					candidateSig[j] = varType;
				}
				methodList.add(method);
				candidateSigs.add(candidateSig);
			}
		}
		int match = findMostSpecificSignature(idealMatch, candidateSigs.toArray(new Class[candidateSigs.size()][]));
		return match == -1 ? null : methodList.get(match);
	}
	/**
	 * Implement JLS 15.11.2
	 * Return the index of the most specific arguments match or -1 if no
	 * match is found.
	 * This method is used by both methods and constructors (which
	 * unfortunately don't share a common interface for signature info).
	 *
	 * @return the index of the most specific candidate
	 */
	/*
		  Note: Two methods which are equally specific should not be allowed by
		  the Java compiler.  In this case BeanShell currently chooses the first
		  one it finds.  We could add a test for this case here (I believe) by
		  adding another isSignatureAssignable() in the other direction between
		  the target and "best" match.  If the assignment works both ways then
		  neither is more specific and they are ambiguous.  I'll leave this test
		  out for now because I'm not sure how much another test would impact
		  performance.  Method selection is now cached at a high level, so a few
		  friendly extraneous tests shouldn't be a problem.
		 */
	static int findMostSpecificSignature(Class[] idealMatch, Class[][] candidates) {
		for (int round = Types.FIRST_ROUND_ASSIGNABLE; round <= Types.LAST_ROUND_ASSIGNABLE; round++) {
			Class[] bestMatch = null;
			int bestMatchIndex = -1;
			for (int i = 0; i < candidates.length; i++) {
				Class[] targetMatch = candidates[i];
				// If idealMatch fits targetMatch and this is the first match
				// or targetMatch is more specific than the best match, make it
				// the new best match.
				if (Types.isSignatureAssignable(idealMatch, targetMatch, round) && ((bestMatch == null) || Types.isSignatureAssignable(targetMatch, bestMatch, Types.JAVA_BASE_ASSIGNABLE))) {
					bestMatch = targetMatch;
					bestMatchIndex = i;
				}
			}
			if (bestMatch != null) {
				return bestMatchIndex;
			}
		}
		return -1;
	}
	private static String accessorName(String getorset, String propName) {
		return getorset + String.valueOf(Character.toUpperCase(propName.charAt(0))) + propName.substring(1);
	}
	public static boolean hasObjectPropertyGetter(Class clas, String propName) {
		if (clas == Primitive.class) {
			return false;
		}
		String getterName = accessorName("get", propName);
		try {
			clas.getMethod(getterName, new Class[0]);
			return true;
		} catch (NoSuchMethodException e) { /* fall through */ }
		getterName = accessorName("is", propName);
		try {
			Method m = clas.getMethod(getterName, new Class[0]);
			return (m.getReturnType() == Boolean.TYPE);
		} catch (NoSuchMethodException e) {
			return false;
		}
	}
	public static boolean hasObjectPropertySetter(Class clas, String propName) {
		String setterName = accessorName("set", propName);
		Method[] methods = clas.getMethods();
		// we don't know the right hand side of the assignment yet.
		// has at least one setter of the right name?
		for (Method method : methods) {
			if (method.getName().equals(setterName)) {
				return true;
			}
		}
		return false;
	}
	public static Object getObjectProperty(Object obj, String propName) throws UtilEvalError, ReflectError {
		Object[] args = new Object[]{};
		Interpreter.debug("property access: ");
		Method method = null;
		Exception e1 = null, e2 = null;
		try {
			String accessorName = accessorName("get", propName);
			method = resolveExpectedJavaMethod(null/*bcm*/, obj.getClass(), obj, accessorName, args, false);
		} catch (Exception e) {
			e1 = e;
		}
		if (method == null) {
			try {
				String accessorName = accessorName("is", propName);
				method = resolveExpectedJavaMethod(null/*bcm*/, obj.getClass(), obj, accessorName, args, false);
				if (method.getReturnType() != Boolean.TYPE) {
					method = null;
				}
			} catch (Exception e) {
				e2 = e;
			}
		}
		if (method == null) {
			throw new ReflectError("Error in property getter: " + e1 + (e2 != null ? " : " + e2 : ""));
		}
		try {
			return invokeMethod(method, obj, args);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Property accessor threw exception: " + e.getTargetException());
		}
	}
	public static void setObjectProperty(Object obj, String propName, Object value) throws ReflectError, UtilEvalError {
		String accessorName = accessorName("set", propName);
		Object[] args = new Object[]{value};
		Interpreter.debug("property access: ");
		try {
			Method method = resolveExpectedJavaMethod(null/*bcm*/, obj.getClass(), obj, accessorName, args, false);
			invokeMethod(method, obj, args);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Property accessor threw exception: " + e.getTargetException());
		}
	}
	/**
	 * Return a more human readable version of the type name.
	 * Specifically, array types are returned with postfix "[]" dimensions.
	 * e.g. return "int []" for integer array instead of "class [I" as
	 * would be returned by Class getName() in that case.
	 */
	public static String normalizeClassName(Class type) {
		if (!type.isArray()) {
			return type.getName();
		}
		StringBuilder className = new StringBuilder();
		try {
			className.append(getArrayBaseType(type).getName()).append(' ');
			for (int i = 0; i < getArrayDimensions(type); i++) {
				className.append("[]");
			}
		} catch (ReflectError e) {
			/*shouldn't happen*/
		}
		return className.toString();
	}
	/**
	 * returns the dimensionality of the Class
	 * returns 0 if the Class is not an array class
	 */
	public static int getArrayDimensions(Class arrayClass) {
		if (!arrayClass.isArray()) {
			return 0;
		}
		return arrayClass.getName().lastIndexOf('[') + 1;  // why so cute?
	}
	/**
	 * Returns the base type of an array Class.
	 * throws ReflectError if the Class is not an array class.
	 */
	public static Class getArrayBaseType(Class arrayClass) throws ReflectError {
		if (!arrayClass.isArray()) {
			throw new ReflectError("The class is not an array.");
		}
		return arrayClass.getComponentType();
	}
	/**
	 * A command may be implemented as a compiled Java class containing one or
	 * more static invoke() methods of the correct signature.  The invoke()
	 * methods must accept two additional leading arguments of the interpreter
	 * and callstack, respectively. e.g. invoke(interpreter, callstack, ... )
	 * This method adds the arguments and invokes the static method, returning
	 * the result.
	 */
	public static Object invokeCompiledCommand(Class commandClass, Object[] args, BshEvaluatingVisitor visitor) throws UtilEvalError {
		// add interpereter and namespace to args list
		Object[] invokeArgs = new Object[args.length + 2];
		invokeArgs[0] = visitor.getInterpreter();
		invokeArgs[1] = visitor.getCallstack();
		System.arraycopy(args, 0, invokeArgs, 2, args.length);
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		try {
			return Reflect.invokeStaticMethod(bcm, commandClass, "invoke", invokeArgs);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Error in compiled command: " + e.getTargetException(), e);
		} catch (ReflectError e) {
			throw new UtilEvalError("Error invoking compiled command: " + e, e);
		}
	}
	private static void logInvokeMethod(String msg, Method method, Object[] args) {
		if (Interpreter.DEBUG) {
			Interpreter.debug(msg + method + " with args:");
			for (int i = 0; i < args.length; i++) {
				final Object arg = args[i];
				Interpreter.debug("args[" + i + "] = " + arg + " type = " + (arg == null ? "<unkown>" : arg.getClass()));
			}
		}
	}
	private static void checkFoundStaticMethod(Method method, boolean staticOnly, Class clas) throws UtilEvalError {
		// We're looking for a static method but found an instance method
		if (method != null && staticOnly && !isStatic(method)) {
			throw new UtilEvalError("Cannot reach instance method: " + StringUtil.methodString(method.getName(), method.getParameterTypes()) + " from static context: " + clas.getName());
		}
	}
	private static ReflectError cantFindConstructor(Class clas, Class[] types) {
		if (types.length == 0) {
			return new ReflectError("Can't find default constructor for: " + clas);
		} else {
			return new ReflectError("Can't find constructor: " + StringUtil.methodString(clas.getName(), types) + " in class: " + clas.getName());
		}
	}
	private static boolean isPublic(Class c) {
		return Modifier.isPublic(c.getModifiers());
	}
	private static boolean isPublic(Method m) {
		return Modifier.isPublic(m.getModifiers());
	}
	private static boolean isPublic(Constructor c) {
		return Modifier.isPublic(c.getModifiers());
	}
	private static boolean isStatic(Method m) {
		return Modifier.isStatic(m.getModifiers());
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.*;
import java.util.Map;
import java.util.HashMap;
/**
	'This' is the type of bsh scripted objects.
	A 'This' object is a bsh scripted object context.  It holds a namespace 
	reference and implements event listeners and various other interfaces.
	This holds a reference to the declaring interpreter for callbacks from
	outside of bsh.
*/
public final class This implements java.io.Serializable, Runnable 
{
	/**
		The namespace that this This reference wraps.
	*/
	final NameSpace namespace;
	/**
		This is the interpreter running when the This ref was created.
		It's used as a default interpreter for callback through the This
		where there is no current interpreter instance 
		e.g. interface proxy or event call backs from outside of bsh.
	*/
	transient Interpreter declaringInterpreter;
	/**
		A cache of proxy interface handlers.
		Currently just one per interface.
	*/
	private Map<Integer,Object> interfaces;
	private final InvocationHandler invocationHandler = new Handler();
	/**
		getThis() is a factory for bsh.This type references.  The capabilities
		of ".this" references in bsh are version dependent up until jdk1.3.
		The version dependence was to support different default interface
		implementations.  i.e. different sets of listener interfaces which
		scripted objects were capable of implementing.  In jdk1.3 the 
		reflection proxy mechanism was introduced which allowed us to 
		implement arbitrary interfaces.  This is fantastic.
		A This object is a thin layer over a namespace, comprising a bsh object
		context.  We create it here only if needed for the namespace.
		Note: this method could be considered slow because of the way it 
		dynamically factories objects.  However I've also done tests where 
		I hard-code the factory to return JThis and see no change in the 
		rough test suite time.  This references are also cached in NameSpace.  
	*/
    static This getThis( 
		NameSpace namespace, Interpreter declaringInterpreter ) 
	{
		return new This( namespace, declaringInterpreter );
    }
	/**
		Get a version of this scripted object implementing the specified 
		interface.
	*/
	/**
		Get dynamic proxy for interface, caching those it creates.
	*/
	public Object getInterface( Class clas ) 
	{
		return getInterface( new Class[] { clas } );
	}
	/**
		Get dynamic proxy for interface, caching those it creates.
	*/
	public Object getInterface( Class [] ca ) 
	{
		if ( interfaces == null )
			interfaces = new HashMap<Integer,Object>();
		// Make a hash of the interface hashcodes in order to cache them
		int hash = 21;
		for(int i=0; i<ca.length; i++)
			hash *= ca[i].hashCode() + 3;
		Integer hashKey = new Integer(hash);
		Object interf = interfaces.get( hashKey );
		if ( interf == null ) 
		{
			ClassLoader classLoader = ca[0].getClassLoader(); // ?
			interf = Proxy.newProxyInstance( 
				classLoader, ca, invocationHandler );
			interfaces.put( hashKey, interf );
		}
		return interf;
	}
	/**
		This is the invocation handler for the dynamic proxy.
		<p>
		Notes:
		Inner class for the invocation handler seems to shield this unavailable
		interface from JDK1.2 VM...  
		
		I don't understand this.  JThis works just fine even if those
		classes aren't there (doesn't it?)  This class shouldn't be loaded
		if an XThis isn't instantiated in NameSpace.java, should it?
	*/
	class Handler implements InvocationHandler, java.io.Serializable 
	{
		public Object invoke( Object proxy, Method method, Object[] args ) 
			throws Throwable
		{
			try { 
				return invokeImpl( proxy, method, args );
			} catch ( TargetError te ) {
				// Unwrap target exception.  If the interface declares that 
				// it throws the ex it will be delivered.  If not it will be 
				// wrapped in an UndeclaredThrowable
				// This isn't simple because unwrapping this loses all context info.
				// So rewrap is better than unwrap.  - fschmidt
				Throwable t = te.getTarget();
				Class<? extends Throwable> c = t.getClass();
				String msg = t.getMessage();
				try {
					Throwable t2 = msg==null 
						? c.getConstructor().newInstance()
						: c.getConstructor(String.class).newInstance(msg)
					;
					t2.initCause(te);
					throw t2;
				} catch(NoSuchMethodException e) {
					throw t;
				}
			} catch ( EvalError ee ) {
				// Ease debugging...
				// XThis.this refers to the enclosing class instance
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( "EvalError in scripted interface: "
					+ This.this.toString() + ": "+ ee );
				throw ee;
			}
		}
		public Object invokeImpl( Object proxy, Method method, Object[] args ) 
			throws EvalError 
		{
			String methodName = method.getName();
			CallStack callstack = new CallStack( namespace );
			/*
				If equals() is not explicitly defined we must override the 
				default implemented by the This object protocol for scripted
				object.  To support XThis equals() must test for equality with 
				the generated proxy object, not the scripted bsh This object;
				otherwise callers from outside in Java will not see a the 
				proxy object as equal to itself.
			*/
			BshMethod equalsMethod = null;
			try {
				equalsMethod = namespace.getMethod( 
					"equals", new Class [] { Object.class } );
			} catch ( UtilEvalError e ) {/*leave null*/ }
			if ( methodName.equals("equals" ) && equalsMethod == null ) {
				Object obj = args[0];
				return proxy == obj;
			}
			/*
				If toString() is not explicitly defined override the default 
				to show the proxy interfaces.
			*/
			BshMethod toStringMethod = null;
			try {
				toStringMethod = 
					namespace.getMethod( "toString", new Class [] { } );
			} catch ( UtilEvalError e ) {/*leave null*/ }
			if ( methodName.equals("toString" ) && toStringMethod == null)
			{
				Class [] ints = proxy.getClass().getInterfaces();
				// XThis.this refers to the enclosing class instance
				StringBuilder sb = new StringBuilder( 
					This.this.toString() + "\nimplements:" );
				for(int i=0; i<ints.length; i++)
					sb.append( " "+ ints[i].getName() 
						+ ((ints.length > 1)?",":"") );
				return sb.toString();
			}
			Class [] paramTypes = method.getParameterTypes();
			return Primitive.unwrap( 
				invokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );
		}
	}
	This( NameSpace namespace, Interpreter declaringInterpreter ) {
		this.namespace = namespace; 
		this.declaringInterpreter = declaringInterpreter;
		//initCallStack( namespace );
	}
	public NameSpace getNameSpace() {
		return namespace;
	}
	public String toString() {
		return "'this' reference to Bsh object: " + namespace;
	}
	public void run() {
		try {
			invokeMethod( "run", new Object[0] );
		} catch( EvalError e ) {
			declaringInterpreter.error(
				"Exception in runnable:" + e );
		}
	}
	/**
		Invoke specified method as from outside java code, using the 
		declaring interpreter and current namespace.
		The call stack will indicate that the method is being invoked from
		outside of bsh in native java code.
		Note: you must still wrap/unwrap args/return values using 
		Primitive/Primitive.unwrap() for use outside of BeanShell.
		@see bsh.Primitive
	*/
	public Object invokeMethod( String name, Object [] args ) 
		throws EvalError
	{
		// null callstack, one will be created for us 
		return invokeMethod( 
			name, args, null/*declaringInterpreter*/, null, null, 
			false/*declaredOnly*/ );
	}
	/**
		Invoke a method in this namespace with the specified args,
		interpreter reference, callstack, and caller info.
		<p>
		Note: If you use this method outside of the bsh package and wish to 
		use variables with primitive values you will have to wrap them using 
		bsh.Primitive.  Consider using This getInterface() to make a true Java
		interface for invoking your scripted methods.
		<p>
		This method also implements the default object protocol of toString(), 
		hashCode() and equals() and the invoke() meta-method handling as a 
		last resort.
		<p>
		Note: The invoke() meta-method will not catch the Object protocol
		methods (toString(), hashCode()...).  If you want to override them you 
		have to script them directly.
		<p>
		@param callstack if callStack is null a new CallStack will be created and
			initialized with this namespace.
		@param declaredOnly if true then only methods declared directly in the
			namespace will be visible - no inherited or imported methods will
			be visible.
		@see bsh.Primitive
	*/
	/*
		invokeMethod() here is generally used by outside code to callback
		into the bsh interpreter. e.g. when we are acting as an interface
		for a scripted listener, etc.  In this case there is no real call stack
		so we make a default one starting with the special JAVACODE namespace
		and our namespace as the next.
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, 
		Interpreter interpreter, CallStack callstack, SimpleNode callerInfo,
		boolean declaredOnly  ) 
		throws EvalError
	{
		/*
			Wrap nulls.
			This is a bit of a cludge to address a deficiency in the class
			generator whereby it does not wrap nulls on method delegate.  See
			Class Generator.java.  If we fix that then we can remove this.
			(just have to generate the code there.)
		*/
		if ( args == null ) {
			args = new Object[0];
		} else {
			Object [] oa = new Object [args.length];
			for(int i=0; i<args.length; i++)
				oa[i] = ( args[i] == null ? Primitive.NULL : args[i] );
			args = oa;
		}
		if ( interpreter == null )
			interpreter = declaringInterpreter;
		if ( callstack == null )
			callstack = new CallStack( namespace );
		if ( callerInfo == null )
			callerInfo = SimpleNode.JAVACODE;
		// Find the bsh method
		Class [] types = Types.getTypes( args );
		BshMethod bshMethod = null;
		try {
			bshMethod = namespace.getMethod( methodName, types, declaredOnly );
		} catch ( UtilEvalError e ) {
			// leave null
		}
		if ( bshMethod != null )
			return bshMethod.invoke( args, new BshEvaluatingVisitor(callstack,  interpreter), callerInfo );
		/*
			No scripted method of that name.
			Implement the required part of the Object protocol:
				public int hashCode();
				public boolean equals(java.lang.Object);
				public java.lang.String toString();
			if these were not handled by scripted methods we must provide
			a default impl.
		*/
		// a default toString() that shows the interfaces we implement
		if ( methodName.equals("toString") && args.length==0 )
			return toString();
		// a default hashCode()
		if ( methodName.equals("hashCode") && args.length==0 )
			return new Integer(this.hashCode());
		// a default equals() testing for equality with the This reference
		if ( methodName.equals("equals") && args.length==1 ) {
			Object obj = args[0];
			return new Boolean( this == obj );
		}
		// a default clone()
		if ( methodName.equals("clone") && args.length==0 ) {
			NameSpace ns = new NameSpace(namespace,namespace.getName()+" clone");
			try {
				for( String varName : namespace.getVariableNames() ) {
					ns.setLocalVariable(varName,namespace.getVariable(varName,false),false);
				}
				for( BshMethod method : namespace.getMethods() ) {
					ns.setMethod(method);
				}
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
			}
			return ns.getThis(declaringInterpreter);
		}
		// Look for a default invoke() handler method in the namespace
		// Note: this code duplicates that in NameSpace getCommand()
		// is that ok?
		try {
			bshMethod = namespace.getMethod( 
				"invoke", new Class [] { null, null } );
		} catch ( UtilEvalError e ) { /*leave null*/ }
		// Call script "invoke( String methodName, Object [] args );
		if ( bshMethod != null )
			return bshMethod.invoke( new Object [] { methodName, args }, 
				new BshEvaluatingVisitor(callstack,  interpreter), callerInfo );
		throw new EvalError("Method " + 
			StringUtil.methodString( methodName, types ) +
			" not found in bsh scripted object: "+ namespace.getName(), 
			callerInfo, callstack );
	}
	/**
		Bind a This reference to a parent's namespace with the specified
		declaring interpreter.  Also re-init the callstack.  It's necessary 
		to bind a This reference before it can be used after deserialization.
		This is used by the bsh load() command.
		<p>
		This is a static utility method because it's used by a bsh command
		bind() and the interpreter doesn't currently allow access to direct 
		methods of This objects (small hack)
	*/
	public static void bind( 
		This ths, NameSpace namespace, Interpreter declaringInterpreter ) 
	{ 
		ths.namespace.setParent( namespace ); 
		ths.declaringInterpreter = declaringInterpreter;
	}
	/**
		Allow invocations of these method names on This type objects.
		Don't give bsh.This a chance to override their behavior.
		<p>
		If the method is passed here the invocation will actually happen on
		the bsh.This object via the regular reflective method invocation 
		mechanism.  If not, then the method is evaluated by bsh.This itself
		as a scripted method call.
	*/
	static boolean isExposedThisMethod( String name ) 
	{
		return 
			name.equals("getClass") 
			|| name.equals("invokeMethod")
			|| name.equals("getInterface")
			// These are necessary to let us test synchronization from scripts
			|| name.equals("wait") 
			|| name.equals("notify")
			|| name.equals("notifyAll");
	}
}
package bsh;
import bsh.ast.*;
import bsh.interpreter.BshEvaluatingVisitor;
import bsh.interpreter.BshInterpreterUtil;
import org.objectweb.asm.*;
import org.objectweb.asm.Type;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;
/**
 * ClassGeneratorUtil utilizes the ASM (www.objectweb.org) bytecode generator
 * by Eric Bruneton in order to generate class "stubs" for BeanShell at
 * runtime.
 * <p/>
 * <p/>
 * Stub classes contain all of the fields of a BeanShell scripted class
 * as well as two "callback" references to BeanShell namespaces: one for
 * static methods and one for instance methods.  Methods of the class are
 * delegators which invoke corresponding methods on either the static or
 * instance bsh object and then unpack and return the results.  The static
 * namespace utilizes a static import to delegate variable access to the
 * class' static fields.  The instance namespace utilizes a dynamic import
 * (i.e. mixin) to delegate variable access to the class' instance variables.
 * <p/>
 * <p/>
 * Constructors for the class delegate to the static initInstance() method of
 * ClassGeneratorUtil to initialize new instances of the object.  initInstance()
 * invokes the instance intializer code (init vars and instance blocks) and
 * then delegates to the corresponding scripted constructor method in the
 * instance namespace.  Constructors contain special switch logic which allows
 * the BeanShell to control the calling of alternate constructors (this() or
 * super() references) at runtime.
 * <p/>
 * <p/>
 * Specially named superclass delegator methods are also generated in order to
 * allow BeanShell to access overridden methods of the superclass (which
 * reflection does not normally allow).
 * <p/>
 *
 * @author Pat Niemeyer
 */
/*
	Notes:
	It would not be hard to eliminate the use of org.objectweb.asm.Type from
	this class, making the distribution a tiny bit smaller.
*/
public class ClassGeneratorUtil implements Opcodes {
	/**
	 * The name of the static field holding the reference to the bsh
	 * static This (the callback namespace for static methods)
	 */
	static final String BSHSTATIC = "_bshStatic";
	/**
	 * The name of the instance field holding the reference to the bsh
	 * instance This (the callback namespace for instance methods)
	 */
	private static final String BSHTHIS = "_bshThis";
	/**
	 * The prefix for the name of the super delegate methods. e.g.
	 * _bshSuperfoo() is equivalent to super.foo()
	 */
	static final String BSHSUPER = "_bshSuper";
	/**
	 * The bsh static namespace variable name of the instance initializer
	 */
	static final String BSHINIT = "_bshInstanceInitializer";
	/**
	 * The bsh static namespace variable that holds the constructor methods
	 */
	private static final String BSHCONSTRUCTORS = "_bshConstructors";
	/**
	 * The switch branch number for the default constructor.
	 * The value -1 will cause the default branch to be taken.
	 */
	private static final int DEFAULTCONSTRUCTOR = -1;
	private static final String OBJECT = "Ljava/lang/Object;";
	private final String className;
	/**
	 * fully qualified class name (with package) e.g. foo/bar/Blah
	 */
	private final String fqClassName;
	private final Class superClass;
	private final String superClassName;
	private final Class[] interfaces;
	private final Variable[] vars;
	private final Constructor[] superConstructors;
	private final DelayedEvalBshMethod[] constructors;
	private final DelayedEvalBshMethod[] methods;
	private final NameSpace classStaticNameSpace;
	private final Modifiers classModifiers;
	private boolean isInterface;
	/**
	 * @param packageName e.g. "com.foo.bar"
	 */
	public ClassGeneratorUtil(Modifiers classModifiers, String className, String packageName, Class superClass, Class[] interfaces, Variable[] vars, DelayedEvalBshMethod[] bshmethods, NameSpace classStaticNameSpace, boolean isInterface) {
		this.classModifiers = classModifiers;
		this.className = className;
		if (packageName != null) {
			this.fqClassName = packageName.replace('.', '/') + "/" + className;
		} else {
			this.fqClassName = className;
		}
		if (superClass == null) {
			superClass = Object.class;
		}
		this.superClass = superClass;
		this.superClassName = Type.getInternalName(superClass);
		if (interfaces == null) {
			interfaces = new Class[0];
		}
		this.interfaces = interfaces;
		this.vars = vars;
		this.classStaticNameSpace = classStaticNameSpace;
		this.superConstructors = superClass.getDeclaredConstructors();
		// Split the methods into constructors and regular method lists
		List consl = new ArrayList();
		List methodsl = new ArrayList();
		String classBaseName = getBaseName(className); // for inner classes
		for (DelayedEvalBshMethod bshmethod : bshmethods) {
			if (bshmethod.getName().equals(classBaseName)) {
				consl.add(bshmethod);
			} else {
				methodsl.add(bshmethod);
			}
		}
		this.constructors = (DelayedEvalBshMethod[]) consl.toArray(new DelayedEvalBshMethod[consl.size()]);
		this.methods = (DelayedEvalBshMethod[]) methodsl.toArray(new DelayedEvalBshMethod[methodsl.size()]);
		try {
			classStaticNameSpace.setLocalVariable(BSHCONSTRUCTORS, constructors, false/*strict*/);
		} catch (UtilEvalError e) {
			throw new InterpreterError("can't set cons var");
		}
		this.isInterface = isInterface;
	}
	/**
	 * Generate the class bytecode for this class.
	 */
	public byte[] generateClass() {
		// Force the class public for now...
		int classMods = getASMModifiers(classModifiers) | ACC_PUBLIC;
		if (isInterface) {
			classMods |= (ACC_INTERFACE|ACC_ABSTRACT);
		}
		String[] interfaceNames = new String[interfaces.length + (isInterface ? 0 : 1)]; // one more interface for instance init callback
		for (int i = 0; i < interfaces.length; i++) {
			interfaceNames[i] = Type.getInternalName(interfaces[i]);
		}
		if ( ! isInterface) {
			interfaceNames[interfaces.length] = Type.getInternalName(GeneratedClass.class);
		}
		String sourceFile = "BeanShell Generated via ASM (www.objectweb.org)";
		ClassWriter cw = new ClassWriter(0);
		cw.visit(Opcodes.V1_6, classMods, fqClassName, null, superClassName, interfaceNames);
		if ( ! isInterface) {
			// Generate the bsh instance 'This' reference holder field
			generateField(BSHTHIS + className, "Lbsh/This;", ACC_PUBLIC, cw);
			// Generate the static bsh static reference holder field
			generateField(BSHSTATIC + className, "Lbsh/This;", ACC_PUBLIC + ACC_STATIC, cw);
		}
		// Generate the fields
		for (Variable var : vars) {
			String type = var.getTypeDescriptor();
			// Don't generate private or loosely typed fields
			// Note: loose types aren't currently parsed anyway...
			if (var.hasModifier("private") || type == null) {
				continue;
			}
			int modifiers;
			if (isInterface) {
				modifiers = ACC_PUBLIC | ACC_STATIC | ACC_FINAL;
			} else {
				modifiers = getASMModifiers(var.getModifiers());
			}
			generateField(var.getName(), type, modifiers, cw);
		}
		// Generate the constructors
		boolean hasConstructor = false;
		for (int i = 0; i < constructors.length; i++) {
			// Don't generate private constructors
			if (constructors[i].hasModifier("private")) {
				continue;
			}
			int modifiers = getASMModifiers(constructors[i].getModifiers());
			generateConstructor(i, constructors[i].getParamTypeDescriptors(), modifiers, cw);
			hasConstructor = true;
		}
		// If no other constructors, generate a default constructor
		if ( ! isInterface &&  ! hasConstructor) {
			generateConstructor(DEFAULTCONSTRUCTOR/*index*/, new String[0], ACC_PUBLIC, cw);
		}
		// Generate the delegate methods
		for (DelayedEvalBshMethod method : methods) {
			String returnType = method.getReturnTypeDescriptor();
			// Don't generate private /*or loosely return typed */ methods
			if (method.hasModifier("private") /*|| returnType == null*/) {
				continue;
			}
			int modifiers = getASMModifiers(method.getModifiers());
			if (isInterface) {
				modifiers |= (ACC_PUBLIC | ACC_ABSTRACT);
			}
			generateMethod(className, fqClassName, method.getName(), returnType, method.getParamTypeDescriptors(), modifiers, cw);
			boolean isStatic = (modifiers & ACC_STATIC) > 0;
			boolean overridden = classContainsMethod(superClass, method.getName(), method.getParamTypeDescriptors());
			if (!isStatic && overridden) {
				generateSuperDelegateMethod(superClassName, method.getName(), returnType, method.getParamTypeDescriptors(), modifiers, cw);
			}
		}
		return cw.toByteArray();
	}
	/**
	 * Translate bsh.Modifiers into ASM modifier bitflags.
	 */
	private static int getASMModifiers(Modifiers modifiers) {
		int mods = 0;
		if (modifiers == null) {
			return mods;
		}
		if (modifiers.hasModifier("public")) {
			mods += ACC_PUBLIC;
		}
		if (modifiers.hasModifier("protected")) {
			mods += ACC_PROTECTED;
		}
		if (modifiers.hasModifier("static")) {
			mods += ACC_STATIC;
		}
		if (modifiers.hasModifier("synchronized")) {
			mods += ACC_SYNCHRONIZED;
		}
		if (modifiers.hasModifier("abstract")) {
			mods += ACC_ABSTRACT;
		}
		return mods;
	}
	/**
	 * Generate a field - static or instance.
	 */
	private static void generateField(String fieldName, String type, int modifiers, ClassWriter cw) {
		cw.visitField(modifiers, fieldName, type, null, null);
	}
	/**
	 * Generate a delegate method - static or instance.
	 * The generated code packs the method arguments into an object array
	 * (wrapping primitive types in bsh.Primitive), invokes the static or
	 * instance namespace invokeMethod() method, and then unwraps / returns
	 * the result.
	 */
	private static void generateMethod(String className, String fqClassName, String methodName, String returnType, String[] paramTypes, int modifiers, ClassWriter cw) {
		String[] exceptions = null;
		boolean isStatic = (modifiers & ACC_STATIC) != 0;
		if (returnType == null) // map loose return type to Object
		{
			returnType = OBJECT;
		}
		String methodDescriptor = getMethodDescriptor(returnType, paramTypes);
		// Generate method body
		MethodVisitor cv = cw.visitMethod(modifiers, methodName, methodDescriptor, null, exceptions);
		if ((modifiers & ACC_ABSTRACT) != 0) {
			return;
		}
		// Generate code to push the BSHTHIS or BSHSTATIC field
		if (isStatic) {
			cv.visitFieldInsn(GETSTATIC, fqClassName, BSHSTATIC + className, "Lbsh/This;");
		} else {
			// Push 'this'
			cv.visitVarInsn(ALOAD, 0);
			// Get the instance field
			cv.visitFieldInsn(GETFIELD, fqClassName, BSHTHIS + className, "Lbsh/This;");
		}
		// Push the name of the method as a constant
		cv.visitLdcInsn(methodName);
		// Generate code to push arguments as an object array
		generateParameterReifierCode(paramTypes, isStatic, cv);
		// Push nulls for various args of invokeMethod
		cv.visitInsn(ACONST_NULL); // interpreter
		cv.visitInsn(ACONST_NULL); // callstack
		cv.visitInsn(ACONST_NULL); // callerinfo
		// Push the boolean constant 'true' (for declaredOnly)
		cv.visitInsn(ICONST_1);
		// Invoke the method This.invokeMethod( name, Class [] sig, boolean )
		cv.visitMethodInsn(INVOKEVIRTUAL, "bsh/This", "invokeMethod", Type.getMethodDescriptor(Type.getType(Object.class),
                new Type[]{Type.getType(String.class), Type.getType(Object[].class), Type.getType(Interpreter.class),
                        Type.getType(CallStack.class), Type.getType(SimpleNode.class), Type.getType(Boolean.TYPE)}));
		// Generate code to unwrap bsh Primitive types
		cv.visitMethodInsn(INVOKESTATIC, "bsh/Primitive", "unwrap", "(Ljava/lang/Object;)Ljava/lang/Object;");
		// Generate code to return the value
		generateReturnCode(returnType, cv);
		// Need to calculate this... just fudging here for now.
	    cv.visitMaxs(20, 20);
	}
	/**
	 * Generate a constructor.
	 */
	public void generateConstructor(int index, String[] paramTypes, int modifiers, ClassWriter cw) {
		/** offset after params of the args object [] var */
		final int argsVar = paramTypes.length + 1;
		/** offset after params of the ConstructorArgs var */
		final int consArgsVar = paramTypes.length + 2;
		String[] exceptions = null;
		String methodDescriptor = getMethodDescriptor("V", paramTypes);
		// Create this constructor method
		MethodVisitor cv = cw.visitMethod(modifiers, "<init>", methodDescriptor, null, exceptions);
		// Generate code to push arguments as an object array
		generateParameterReifierCode(paramTypes, false/*isStatic*/, cv);
		cv.visitVarInsn(ASTORE, argsVar);
		// Generate the code implementing the alternate constructor switch
		generateConstructorSwitch(index, argsVar, consArgsVar, cv);
		// Generate code to invoke the ClassGeneratorUtil initInstance() method
		// push 'this'
		cv.visitVarInsn(ALOAD, 0);
		// Push the class/constructor name as a constant
		cv.visitLdcInsn(className);
		// Push arguments as an object array
		cv.visitVarInsn(ALOAD, argsVar);
		// invoke the initInstance() method
		cv.visitMethodInsn(INVOKESTATIC, "bsh/ClassGeneratorUtil", "initInstance", "(L" + GeneratedClass.class.getName().replace('.', '/') + ";Ljava/lang/String;[Ljava/lang/Object;)V");
		cv.visitInsn(RETURN);
		// Need to calculate this... just fudging here for now.
		cv.visitMaxs(20, 20);
	}
	/**
	 * Generate a switch with a branch for each possible alternate
	 * constructor.  This includes all superclass constructors and all
	 * constructors of this class.  The default branch of this switch is the
	 * default superclass constructor.
	 * <p/>
	 * This method also generates the code to call the static
	 * ClassGeneratorUtil
	 * getConstructorArgs() method which inspects the scripted constructor to
	 * find the alternate constructor signature (if any) and evalute the
	 * arguments at runtime.  The getConstructorArgs() method returns the
	 * actual arguments as well as the index of the constructor to call.
	 */
	void generateConstructorSwitch(int consIndex, int argsVar, int consArgsVar, MethodVisitor cv) {
		Label defaultLabel = new Label();
		Label endLabel = new Label();
		int cases = superConstructors.length + constructors.length;
		Label[] labels = new Label[cases];
		for (int i = 0; i < cases; i++) {
			labels[i] = new Label();
		}
		// Generate code to call ClassGeneratorUtil to get our switch index
		// and give us args...
		// push super class name
		cv.visitLdcInsn(superClass.getName()); // use superClassName var?
		// push class static This object
		cv.visitFieldInsn(GETSTATIC, fqClassName, BSHSTATIC + className, "Lbsh/This;");
		// push args
		cv.visitVarInsn(ALOAD, argsVar);
		// push this constructor index number onto stack
		cv.visitIntInsn(BIPUSH, consIndex);
		// invoke the ClassGeneratorUtil getConstructorsArgs() method
		cv.visitMethodInsn(INVOKESTATIC, "bsh/ClassGeneratorUtil", "getConstructorArgs", "(Ljava/lang/String;Lbsh/This;[Ljava/lang/Object;I)" + "Lbsh/ClassGeneratorUtil$ConstructorArgs;");
		// store ConstructorArgs in consArgsVar
		cv.visitVarInsn(ASTORE, consArgsVar);
		// Get the ConstructorArgs selector field from ConstructorArgs
		// push ConstructorArgs
		cv.visitVarInsn(ALOAD, consArgsVar);
		cv.visitFieldInsn(GETFIELD, "bsh/ClassGeneratorUtil$ConstructorArgs", "selector", "I");
		// start switch
		cv.visitTableSwitchInsn(0/*min*/, cases - 1/*max*/, defaultLabel, labels);
		// generate switch body
		int index = 0;
		for (int i = 0; i < superConstructors.length; i++, index++) {
			doSwitchBranch(index, superClassName, getTypeDescriptors(superConstructors[i].getParameterTypes()), endLabel, labels, consArgsVar, cv);
		}
		for (int i = 0; i < constructors.length; i++, index++) {
			doSwitchBranch(index, fqClassName, constructors[i].getParamTypeDescriptors(), endLabel, labels, consArgsVar, cv);
		}
		// generate the default branch of switch
		cv.visitLabel(defaultLabel);
		// default branch always invokes no args super
		cv.visitVarInsn(ALOAD, 0); // push 'this'
		cv.visitMethodInsn(INVOKESPECIAL, superClassName, "<init>", "()V");
		// done with switch
		cv.visitLabel(endLabel);
	}
	/*
			 Generate a branch of the constructor switch.  This method is called by
			 generateConstructorSwitch.
			 The code generated by this method assumes that the argument array is
			 on the stack.
		 */
	private static void doSwitchBranch(int index, String targetClassName, String[] paramTypes, Label endLabel, Label[] labels, int consArgsVar, MethodVisitor cv) {
		cv.visitLabel(labels[index]);
		//cv.visitLineNumber( index, labels[index] );
		cv.visitVarInsn(ALOAD, 0); // push this before args
		// Unload the arguments from the ConstructorArgs object
		for (String type : paramTypes) {
			final String method;
			if (type.equals("Z")) {
				method = "getBoolean";
			} else if (type.equals("B")) {
				method = "getByte";
			} else if (type.equals("C")) {
				method = "getChar";
			} else if (type.equals("S")) {
				method = "getShort";
			} else if (type.equals("I")) {
				method = "getInt";
			} else if (type.equals("J")) {
				method = "getLong";
			} else if (type.equals("D")) {
				method = "getDouble";
			} else if (type.equals("F")) {
				method = "getFloat";
			} else {
				method = "getObject";
			}
			// invoke the iterator method on the ConstructorArgs
			cv.visitVarInsn(ALOAD, consArgsVar); // push the ConstructorArgs
			String className = "bsh/ClassGeneratorUtil$ConstructorArgs";
			String retType;
			if (method.equals("getObject")) {
				retType = OBJECT;
			} else {
				retType = type;
			}
			cv.visitMethodInsn(INVOKEVIRTUAL, className, method, "()" + retType);
			// if it's an object type we must do a check cast
			if (method.equals("getObject")) {
				cv.visitTypeInsn(CHECKCAST, descriptorToClassName(type));
			}
		}
		// invoke the constructor for this branch
		String descriptor = getMethodDescriptor("V", paramTypes);
		cv.visitMethodInsn(INVOKESPECIAL, targetClassName, "<init>", descriptor);
		cv.visitJumpInsn(GOTO, endLabel);
	}
	private static String getMethodDescriptor(String returnType, String[] paramTypes) {
		StringBuilder sb = new StringBuilder("(");
		for (String paramType : paramTypes) {
			sb.append(paramType);
		}
		sb.append(')').append(returnType);
		return sb.toString();
	}
	/**
	 * Generate a superclass method delegate accessor method.
	 * These methods are specially named methods which allow access to
	 * overridden methods of the superclass (which the Java reflection API
	 * normally does not allow).
	 */
	// Maybe combine this with generateMethod()
	private static void generateSuperDelegateMethod(String superClassName, String methodName, String returnType, String[] paramTypes, int modifiers, ClassWriter cw) {
		String[] exceptions = null;
		if (returnType == null) // map loose return to Object
		{
			returnType = OBJECT;
		}
		String methodDescriptor = getMethodDescriptor(returnType, paramTypes);
		// Add method body
		MethodVisitor cv = cw.visitMethod(modifiers, "_bshSuper" + methodName, methodDescriptor, null, exceptions);
		cv.visitVarInsn(ALOAD, 0);
		// Push vars
		int localVarIndex = 1;
		for (String paramType : paramTypes) {
			if (isPrimitive(paramType)) {
				cv.visitVarInsn(ILOAD, localVarIndex);
			} else {
				cv.visitVarInsn(ALOAD, localVarIndex);
			}
			localVarIndex += ((paramType.equals("D") || paramType.equals("J")) ? 2 : 1);
		}
		cv.visitMethodInsn(INVOKESPECIAL, superClassName, methodName, methodDescriptor);
		generatePlainReturnCode(returnType, cv);
		// Need to calculate this... just fudging here for now.
		cv.visitMaxs(20, 20);
	}
	boolean classContainsMethod(Class clas, String methodName, String[] paramTypes) {
		while (clas != null) {
			Method[] methods = clas.getDeclaredMethods();
			for (Method method : methods) {
				if (method.getName().equals(methodName)) {
					String[] methodParamTypes = getTypeDescriptors(method.getParameterTypes());
					boolean found = true;
					for (int j = 0; j < methodParamTypes.length; j++) {
						if (!paramTypes[j].equals(methodParamTypes[j])) {
							found = false;
							break;
						}
					}
					if (found) {
						return true;
					}
				}
			}
			clas = clas.getSuperclass();
		}
		return false;
	}
	/**
	 * Generate return code for a normal bytecode
	 */
	private static void generatePlainReturnCode(String returnType, MethodVisitor cv) {
		if (returnType.equals("V")) {
			cv.visitInsn(RETURN);
		} else if (isPrimitive(returnType)) {
			int opcode = IRETURN;
			if (returnType.equals("D")) {
				opcode = DRETURN;
			} else if (returnType.equals("F")) {
				opcode = FRETURN;
			} else if (returnType.equals("J"))  //long
			{
				opcode = LRETURN;
			}
			cv.visitInsn(opcode);
		} else {
			cv.visitTypeInsn(CHECKCAST, descriptorToClassName(returnType));
			cv.visitInsn(ARETURN);
		}
	}
	/**
	 * Generates the code to reify the arguments of the given method.
	 * For a method "int m (int i, String s)", this code is the bytecode
	 * corresponding to the "new Object[] { new bsh.Primitive(i), s }"
	 * expression.
	 *
	 * @param cv	   the code visitor to be used to generate the bytecode.
	 * @param isStatic the enclosing methods is static
	 * @author Eric Bruneton
	 * @author Pat Niemeyer
	 */
	private static void generateParameterReifierCode(String[] paramTypes, boolean isStatic, final MethodVisitor cv) {
		cv.visitIntInsn(SIPUSH, paramTypes.length);
		cv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
		int localVarIndex = isStatic ? 0 : 1;
		for (int i = 0; i < paramTypes.length; ++i) {
			String param = paramTypes[i];
			cv.visitInsn(DUP);
			cv.visitIntInsn(SIPUSH, i);
			if (isPrimitive(param)) {
				int opcode;
				if (param.equals("F")) {
					opcode = FLOAD;
				} else if (param.equals("D")) {
					opcode = DLOAD;
				} else if (param.equals("J")) {
					opcode = LLOAD;
				} else {
					opcode = ILOAD;
				}
				String type = "bsh/Primitive";
				cv.visitTypeInsn(NEW, type);
				cv.visitInsn(DUP);
				cv.visitVarInsn(opcode, localVarIndex);
				String desc = param; // ok?
				cv.visitMethodInsn(INVOKESPECIAL, type, "<init>", "(" + desc + ")V");
			} else {
				// Technically incorrect here - we need to wrap null values
				// as bsh.Primitive.NULL.  However the This.invokeMethod()
				// will do that much for us.
				// We need to generate a conditional here to test for null
				// and return Primitive.NULL
				cv.visitVarInsn(ALOAD, localVarIndex);
			}
			cv.visitInsn(AASTORE);
			localVarIndex += ((param.equals("D") || param.equals("J")) ? 2 : 1);
		}
	}
	/**
	 * Generates the code to unreify the result of the given method.  For a
	 * method "int m (int i, String s)", this code is the bytecode
	 * corresponding to the "((Integer)...).intValue()" expression.
	 *
	 * @param cv the code visitor to be used to generate the bytecode.
	 * @author Eric Bruneton
	 * @author Pat Niemeyer
	 */
	private static void generateReturnCode(String returnType, MethodVisitor cv) {
		if (returnType.equals("V")) {
			cv.visitInsn(POP);
			cv.visitInsn(RETURN);
		} else if (isPrimitive(returnType)) {
			int opcode = IRETURN;
			String type;
			String meth;
			if (returnType.equals("B")) {
				type = "java/lang/Byte";
				meth = "byteValue";
			} else if (returnType.equals("I")) {
				type = "java/lang/Integer";
				meth = "intValue";
			} else if (returnType.equals("Z")) {
				type = "java/lang/Boolean";
				meth = "booleanValue";
			} else if (returnType.equals("D")) {
				opcode = DRETURN;
				type = "java/lang/Double";
				meth = "doubleValue";
			} else if (returnType.equals("F")) {
				opcode = FRETURN;
				type = "java/lang/Float";
				meth = "floatValue";
			} else if (returnType.equals("J")) {
				opcode = LRETURN;
				type = "java/lang/Long";
				meth = "longValue";
			} else if (returnType.equals("C")) {
				type = "java/lang/Character";
				meth = "charValue";
			} else /*if (returnType.equals("S") )*/ {
				type = "java/lang/Short";
				meth = "shortValue";
			}
			String desc = returnType;
			cv.visitTypeInsn(CHECKCAST, type); // type is correct here
			cv.visitMethodInsn(INVOKEVIRTUAL, type, meth, "()" + desc);
			cv.visitInsn(opcode);
		} else {
			cv.visitTypeInsn(CHECKCAST, descriptorToClassName(returnType));
			cv.visitInsn(ARETURN);
		}
	}
	/**
	 * Evaluate the arguments (if any) for the constructor specified by
	 * the constructor index.  Return the ConstructorArgs object which
	 * contains the actual arguments to the alternate constructor and also the
	 * index of that constructor for the constructor switch.
	 *
	 * @param consArgs the arguments to the constructor.  These are necessary in
	 *                 the evaluation of the alt constructor args.  e.g. Foo(a) { super(a); }
	 * @return the ConstructorArgs object containing a constructor selector
	 *         and evaluated arguments for the alternate constructor
	 */
	public static ConstructorArgs getConstructorArgs(String superClassName, This classStaticThis, Object[] consArgs, int index) {
		DelayedEvalBshMethod[] constructors;
		try {
			constructors = (DelayedEvalBshMethod[]) classStaticThis.getNameSpace().getVariable(BSHCONSTRUCTORS);
		} catch (Exception e) {
			throw new InterpreterError("unable to get instance initializer: " + e);
		}
		if (index == DEFAULTCONSTRUCTOR) // auto-gen default constructor
		{
			return ConstructorArgs.DEFAULT;
		} // use default super constructor
		DelayedEvalBshMethod constructor = constructors[index];
		if (constructor.methodBody.jjtGetNumChildren() == 0) {
			return ConstructorArgs.DEFAULT;
		} // use default super constructor
		// Determine if the constructor calls this() or super()
		String altConstructor = null;
		BSHArguments argsNode = null;
		SimpleNode firstStatement = (SimpleNode) constructor.methodBody.jjtGetChild(0);
		if (firstStatement instanceof BSHPrimaryExpression) {
			firstStatement = (SimpleNode) firstStatement.jjtGetChild(0);
		}
		if (firstStatement instanceof BSHMethodInvocation) {
			BSHMethodInvocation methodNode = (BSHMethodInvocation) firstStatement;
			BSHAmbiguousName methodName = methodNode.getNameNode();
			if (methodName.text.equals("super") || methodName.text.equals("this")) {
				altConstructor = methodName.text;
				argsNode = methodNode.getArgsNode();
			}
		}
		if (altConstructor == null) {
			return ConstructorArgs.DEFAULT;
		} // use default super constructor
		// Make a tmp namespace to hold the original constructor args for
		// use in eval of the parameters node
		NameSpace consArgsNameSpace = new NameSpace(classStaticThis.getNameSpace(), "consArgs");
		String[] consArgNames = constructor.getParameterNames();
		Class[] consArgTypes = constructor.getParameterTypes();
		for (int i = 0; i < consArgs.length; i++) {
			try {
				consArgsNameSpace.setTypedVariable(consArgNames[i], consArgTypes[i], consArgs[i], null/*modifiers*/);
			} catch (UtilEvalError e) {
				throw new InterpreterError("err setting local cons arg:" + e);
			}
		}
		// evaluate the args
		CallStack callstack = new CallStack();
		callstack.push(consArgsNameSpace);
		Object[] args;
		Interpreter interpreter = classStaticThis.declaringInterpreter;
		try {
			args = new BshEvaluatingVisitor(callstack, interpreter).getArguments(argsNode);
		} catch (EvalError e) {
			throw new InterpreterError("Error evaluating constructor args: " + e);
		}
		Class[] argTypes = Types.getTypes(args);
		args = Primitive.unwrap(args);
		Class superClass = interpreter.getClassManager().classForName(superClassName);
		if (superClass == null) {
			throw new InterpreterError("can't find superclass: " + superClassName);
		}
		Constructor[] superCons = superClass.getDeclaredConstructors();
		// find the matching super() constructor for the args
		if (altConstructor.equals("super")) {
			int i = Reflect.findMostSpecificConstructorIndex(argTypes, superCons);
			if (i == -1) {
				throw new InterpreterError("can't find constructor for args!");
			}
			return new ConstructorArgs(i, args);
		}
		// find the matching this() constructor for the args
		Class[][] candidates = new Class[constructors.length][];
		for (int i = 0; i < candidates.length; i++) {
			candidates[i] = constructors[i].getParameterTypes();
		}
		int i = Reflect.findMostSpecificSignature(argTypes, candidates);
		if (i == -1) {
			throw new InterpreterError("can't find constructor for args 2!");
		}
		// this() constructors come after super constructors in the table
		int selector = i + superCons.length;
		int ourSelector = index + superCons.length;
		// Are we choosing ourselves recursively through a this() reference?
		if (selector == ourSelector) {
			throw new InterpreterError("Recusive constructor call.");
		}
		return new ConstructorArgs(selector, args);
	}
	private static final ThreadLocal<NameSpace> CONTEXT_NAMESPACE = new ThreadLocal<NameSpace>();
	private static final ThreadLocal<Interpreter> CONTEXT_INTERPRETER = new ThreadLocal<Interpreter>();
	/**
	 * Register actual context, used by generated class constructor, which calls
	 * {@link  #initInstance(GeneratedClass, String, Object[])}.
	 */
	public static void registerConstructorContext(CallStack callstack, Interpreter interpreter) {
		if (callstack != null) {
			CONTEXT_NAMESPACE.set(callstack.top());
		} else {
			CONTEXT_NAMESPACE.remove();
		}
		if (interpreter != null) {
			CONTEXT_INTERPRETER.set(interpreter);
		} else {
			CONTEXT_INTERPRETER.remove();
		}
	}
	/**
	 * Initialize an instance of the class.
	 * This method is called from the generated class constructor to evaluate
	 * the instance initializer and scripted constructor in the instance
	 * namespace.
	 */
	public static void initInstance(GeneratedClass instance, String className, Object[] args) {
		Class[] sig = Types.getTypes(args);
		CallStack callstack = new CallStack();
		Interpreter interpreter;
		NameSpace instanceNameSpace;
		// check to see if the instance has already been initialized
		// (the case if using a this() alternate constuctor)
		// todo PeJoBo70 write test for this
		This instanceThis = getClassInstanceThis(instance, className);
		// XXX clean up this conditional
		if (instanceThis == null) {
			// Create the instance 'This' namespace, set it on the object
			// instance and invoke the instance initializer
			// Get the static This reference from the proto-instance
			This classStaticThis = getClassStaticThis(instance.getClass(), className);
			interpreter = CONTEXT_INTERPRETER.get();
			if (interpreter == null) {
				interpreter = classStaticThis.declaringInterpreter;
			}
			// Get the instance initializer block from the static This
			BSHBlock instanceInitBlock;
			try {
				instanceInitBlock = (BSHBlock) classStaticThis.getNameSpace().getVariable(BSHINIT);
			} catch (Exception e) {
				throw new InterpreterError("unable to get instance initializer: " + e);
			}
			// Create the instance namespace
			if (CONTEXT_NAMESPACE.get() != null) {
				instanceNameSpace = classStaticThis.getNameSpace().copy();
				instanceNameSpace.setParent(CONTEXT_NAMESPACE.get());
			} else {
				instanceNameSpace = new NameSpace(classStaticThis.getNameSpace(), className); // todo: old code
			}
			instanceNameSpace.isClass = true;
			// Set the instance This reference on the instance
			instanceThis = instanceNameSpace.getThis(interpreter);
			try {
				LHS lhs = Reflect.getLHSObjectField(instance, BSHTHIS + className);
				lhs.assign(instanceThis, false/*strict*/);
			} catch (Exception e) {
				throw new InterpreterError("Error in class gen setup: " + e);
			}
			// Give the instance space its object import
			instanceNameSpace.setClassInstance(instance);
			// should use try/finally here to pop ns
			callstack.push(instanceNameSpace);
			// evaluate the instance portion of the block in it
			try { // Evaluate the initializer block
				new BshEvaluatingVisitor(callstack, interpreter).evalBlock(instanceInitBlock, true/*override*/, ClassGenerator.ClassNodeFilter.CLASSINSTANCE);
			} catch (Exception e) {
				throw new InterpreterError("Error in class initialization: " + e, e);
			}
			callstack.pop();
		} else {
			// The object instance has already been initialzed by another
			// constructor.  Fall through to invoke the constructor body below.
			interpreter = instanceThis.declaringInterpreter;
			instanceNameSpace = instanceThis.getNameSpace();
		}
		// invoke the constructor method from the instanceThis
		String constructorName = getBaseName(className);
		try {
			// Find the constructor (now in the instance namespace)
			BshMethod constructor = instanceNameSpace.getMethod(constructorName, sig, true/*declaredOnly*/);
			// if args, we must have constructor
			if (args.length > 0 && constructor == null) {
				throw new InterpreterError("Can't find constructor: " + className);
			}
			// Evaluate the constructor
			if (constructor != null) {
				constructor.invoke(args, new BshEvaluatingVisitor(callstack,  interpreter),
                        null/*callerInfo*/, false/*overrideNameSpace*/);
			}
		} catch (Throwable e) {
			if (e instanceof TargetError) {
				e = (Exception) ((TargetError) e).getTarget();
			}
			if (e instanceof InvocationTargetException) {
				e = (Exception) ((InvocationTargetException) e).getTargetException();
			}
			throw new InterpreterError("Error in class initialization: " + e);
		}
	}
	/**
	 * Get the static bsh namespace field from the class.
	 *
	 * @param className may be the name of clas itself or a superclass of clas.
	 */
	private static This getClassStaticThis(Class clas, String className) {
		try {
			return (This) Reflect.getStaticFieldValue(clas, BSHSTATIC + className);
		} catch (Exception e) {
			throw new InterpreterError("Unable to get class static space: " + e);
		}
	}
	/**
	 * Get the instance bsh namespace field from the object instance.
	 *
	 * @return the class instance This object or null if the object has not
	 *         been initialized.
	 */
	static This getClassInstanceThis(Object instance, String className) {
		try {
			Object o = Reflect.getObjectFieldValue(instance, BSHTHIS + className);
			return (This) Primitive.unwrap(o); // unwrap Primitive.Null to null
		} catch (Exception e) {
			throw new InterpreterError("Generated class: Error getting This" + e);
		}
	}
	/**
	 * Does the type descriptor string describe a primitive type?
	 */
	private static boolean isPrimitive(String typeDescriptor) {
		return typeDescriptor.length() == 1; // right?
	}
	private static String[] getTypeDescriptors(Class[] cparams) {
		String[] sa = new String[cparams.length];
		for (int i = 0; i < sa.length; i++) {
			sa[i] = BshInterpreterUtil.getTypeDescriptor(cparams[i]);
		}
		return sa;
	}
	/**
	 * If a non-array object type, remove the prefix "L" and suffix ";".
	 */
	// Can this be factored out...?
	// Should be be adding the L...; here instead?
	private static String descriptorToClassName(String s) {
		if (s.startsWith("[") || !s.startsWith("L")) {
			return s;
		}
		return s.substring(1, s.length() - 1);
	}
	private static String getBaseName(String className) {
		int i = className.indexOf("$");
		if (i == -1) {
			return className;
		}
		return className.substring(i + 1);
	}
	/**
	 * A ConstructorArgs object holds evaluated arguments for a constructor
	 * call as well as the index of a possible alternate selector to invoke.
	 * This object is used by the constructor switch.
	 *
	 * @see bsh.ClassGeneratorUtil# generateConstructor(int, String[], int, bsh.org.objectweb.asm.ClassWriter)
	 */
	public static class ConstructorArgs {
		/**
		 * A ConstructorArgs which calls the default constructor
		 */
		public static final ConstructorArgs DEFAULT = new ConstructorArgs();
		public int selector = DEFAULTCONSTRUCTOR;
		Object[] args;
		int arg;
		/**
		 * The index of the constructor to call.
		 */
		ConstructorArgs() {
		}
		ConstructorArgs(int selector, Object[] args) {
			this.selector = selector;
			this.args = args;
		}
		Object next() {
			return args[arg++];
		}
		public boolean getBoolean() {
			return (Boolean) next();
		}
		public byte getByte() {
			return (Byte) next();
		}
		public char getChar() {
			return (Character) next();
		}
		public short getShort() {
			return (Short) next();
		}
		public int getInt() {
			return (Integer) next();
		}
		public long getLong() {
			return (Long) next();
		}
		public double getDouble() {
			return (Double) next();
		}
		public float getFloat() {
			return (Float) next();
		}
		public Object getObject() {
			return next();
		}
	}
}
package bsh;
import java.io.ObjectStreamException;
import java.util.HashMap;
import java.util.Map;
/**
    Wrapper for primitive types in Bsh.  This is package public because it 
	is used in the implementation of some bsh commands.
    See the note in LHS.java about wrapping objects.
*/
/*
	Note: this class is final because we may test == Primitive.class in places.
	If we need to change that search for those tests.
*/
public final class Primitive implements ParserConstants, java.io.Serializable
{
	/*
	static Hashtable primitiveToWrapper = new Hashtable();
	static Hashtable wrapperToPrimitive = new Hashtable();
	static {
		primitiveToWrapper.put( Boolean.TYPE, Boolean.class );
		primitiveToWrapper.put( Byte.TYPE, Byte.class );
		primitiveToWrapper.put( Short.TYPE, Short.class );
		primitiveToWrapper.put( Character.TYPE, Character.class );
		primitiveToWrapper.put( Integer.TYPE, Integer.class );
		primitiveToWrapper.put( Long.TYPE, Long.class );
		primitiveToWrapper.put( Float.TYPE, Float.class );
		primitiveToWrapper.put( Double.TYPE, Double.class );
		wrapperToPrimitive.put( Boolean.class, Boolean.TYPE );
		wrapperToPrimitive.put( Byte.class, Byte.TYPE );
		wrapperToPrimitive.put( Short.class, Short.TYPE );
		wrapperToPrimitive.put( Character.class, Character.TYPE );
		wrapperToPrimitive.put( Integer.class, Integer.TYPE );
		wrapperToPrimitive.put( Long.class, Long.TYPE );
		wrapperToPrimitive.put( Float.class, Float.TYPE );
		wrapperToPrimitive.put( Double.class, Double.TYPE );
	}
	*/
	static final Map<Class,Class> wrapperMap = new HashMap<Class,Class>();
	static {
		wrapperMap.put( Boolean.TYPE, Boolean.class );
		wrapperMap.put( Byte.TYPE, Byte.class );
		wrapperMap.put( Short.TYPE, Short.class );
		wrapperMap.put( Character.TYPE, Character.class );
		wrapperMap.put( Integer.TYPE, Integer.class );
		wrapperMap.put( Long.TYPE, Long.class );
		wrapperMap.put( Float.TYPE, Float.class );
		wrapperMap.put( Double.TYPE, Double.class );
		wrapperMap.put( Boolean.class, Boolean.TYPE );
		wrapperMap.put( Byte.class, Byte.TYPE );
		wrapperMap.put( Short.class, Short.TYPE );
		wrapperMap.put( Character.class, Character.TYPE );
		wrapperMap.put( Integer.class, Integer.TYPE );
		wrapperMap.put( Long.class, Long.TYPE );
		wrapperMap.put( Float.class, Float.TYPE );
		wrapperMap.put( Double.class, Double.TYPE );
	}
    /** The primitive value stored in its java.lang wrapper class */
    private Object value;
    private static class Special implements java.io.Serializable
    {
        private Special() { }
        public static final Special NULL_VALUE = new Special()
        {
            private Object readResolve() throws ObjectStreamException
            {
                return Special.NULL_VALUE;
            }
        };
        public static final Special VOID_TYPE = new Special()
        {
            private Object readResolve() throws ObjectStreamException
            {
                return Special.VOID_TYPE;
            }
        };
    }
    /*
        NULL means "no value".
        This ia a placeholder for primitive null value.
    */
    public static final Primitive NULL = new Primitive(Special.NULL_VALUE);
    /**
        VOID means "no type".
        Strictly speaking, this makes no sense here.  But for practical
        reasons we'll consider the lack of a type to be a special value.
    */
    public static final Primitive VOID = new Primitive(Special.VOID_TYPE);
    
    private Object readResolve() throws ObjectStreamException
    {
        if (value == Special.NULL_VALUE)
        {
            return Primitive.NULL;
        }
        else if (value == Special.VOID_TYPE)
        {
            return Primitive.VOID;
        }
        else
        {
            return this;
        }
    }
    // private to prevent invocation with param that isn't a primitive-wrapper
    public Primitive( Object value )
    {
        if ( value == null )
            throw new InterpreterError(
				"Use Primitve.NULL instead of Primitive(null)");
		if ( value != Special.NULL_VALUE 
			&& value != Special.VOID_TYPE &&
			!isWrapperType( value.getClass() ) 
		)
            throw new InterpreterError( "Not a wrapper type: "+value);
        this.value = value;
    }
    public Primitive(boolean value) { this(new Boolean(value)); }
    public Primitive(byte value) { this(new Byte(value)); }
    public Primitive(short value) { this(new Short(value)); }
    public Primitive(char value) { this(new Character(value)); }
    public Primitive(int value) { this(new Integer(value)); }
    public Primitive(long value) { this(new Long(value)); }
    public Primitive(float value) { this(new Float(value)); }
    public Primitive(double value) { this(new Double(value)); }
	/**
    	Return the primitive value stored in its java.lang wrapper class
	*/
    public Object getValue()
    {
        if ( value == Special.NULL_VALUE )
            return null;
        else 
		if ( value == Special.VOID_TYPE )
                throw new InterpreterError("attempt to unwrap void type");
        else
            return value;
    }
    public String toString()
    {
        if(value == Special.NULL_VALUE)
            return "null";
        else if(value == Special.VOID_TYPE)
            return "void";
        else
            return value.toString();
    }
	/**
		Get the corresponding Java primitive TYPE class for this Primitive.
		@return the primitive TYPE class type of the value or Void.TYPE for
		Primitive.VOID or null value for type of Primitive.NULL
	*/
    public Class getType()
    {
		if ( this == Primitive.VOID )
			return Void.TYPE;
		// NULL return null as type... we currently use null type to indicate 
		// loose typing throughout bsh.
		if ( this == Primitive.NULL )
			return null;
		return unboxType( value.getClass() );
    }
	/**
		Perform a binary operation on two Primitives or wrapper types.
		If both original args were Primitives return a Primitive result
		else it was mixed (wrapper/primitive) return the wrapper type.
		The exception is for boolean operations where we will return the 
		primitive type either way.
	*/
    public static Object binaryOperation(
		Object obj1, Object obj2, int kind)
        throws UtilEvalError
    {
		// special primitive types
        if ( obj1 == NULL || obj2 == NULL )
            throw new UtilEvalError(
				"Null value or 'null' literal in binary operation");
        if ( obj1 == VOID || obj2 == VOID )
            throw new UtilEvalError(
			"Undefined variable, class, or 'void' literal in binary operation");
		// keep track of the original types
		Class lhsOrgType = obj1.getClass();
		Class rhsOrgType = obj2.getClass();
		// Unwrap primitives
        if ( obj1 instanceof Primitive )
            obj1 = ((Primitive)obj1).getValue();
        if ( obj2 instanceof Primitive )
            obj2 = ((Primitive)obj2).getValue();
        Object[] operands = promotePrimitives(obj1, obj2);
        Object lhs = operands[0];
        Object rhs = operands[1];
        if(lhs.getClass() != rhs.getClass())
            throw new UtilEvalError("Type mismatch in operator.  " 
			+ lhs.getClass() + " cannot be used with " + rhs.getClass() );
		Object result;
		try {
			result = binaryOperationImpl( lhs, rhs, kind );
		} catch ( ArithmeticException e ) {
			throw new UtilTargetError( "Arithemetic Exception in binary op", e);
		}
		// If both original args were Primitives return a Primitive result
		// else it was mixed (wrapper/primitive) return the wrapper type
		// Exception is for boolean result, return the primitive
		if ( (lhsOrgType == Primitive.class && rhsOrgType == Primitive.class)
			|| result instanceof Boolean
		)
			return new Primitive( result );
		else
			return result;
    }
    public static Object binaryOperationImpl( Object lhs, Object rhs, int kind )
        throws UtilEvalError
	{
        if(lhs instanceof Boolean)
            return booleanBinaryOperation((Boolean)lhs, (Boolean)rhs, kind);
        else if(lhs instanceof Integer)
            return intBinaryOperation( (Integer)lhs, (Integer)rhs, kind );
        else if(lhs instanceof Long)
            return longBinaryOperation((Long)lhs, (Long)rhs, kind);
        else if(lhs instanceof Float)
            return floatBinaryOperation((Float)lhs, (Float)rhs, kind);
        else if(lhs instanceof Double)
            return doubleBinaryOperation( (Double)lhs, (Double)rhs, kind);
        else
            throw new UtilEvalError("Invalid types in binary operator" );
	}
    public static Boolean booleanBinaryOperation(Boolean B1, Boolean B2, int kind)
    {
        boolean lhs = B1.booleanValue();
        boolean rhs = B2.booleanValue();
        switch(kind)
        {
            case EQ:
                return new Boolean(lhs == rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case BOOL_OR:
            case BOOL_ORX:
            case BIT_OR:
                return new Boolean( lhs || rhs );
            case BOOL_AND:
            case BOOL_ANDX:
            case BIT_AND:
                return new Boolean( lhs && rhs );
	    
            case XOR:
                return new Boolean( lhs ^ rhs );
            default:
                throw new InterpreterError("unimplemented binary operator");
        }
    }
    // returns Object covering both Long and Boolean return types
    public static Object longBinaryOperation(Long L1, Long L2, int kind)
    {
        long lhs = L1.longValue();
        long rhs = L2.longValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Long(lhs + rhs);
            case MINUS:
                return new Long(lhs - rhs);
            case STAR:
                return new Long(lhs * rhs);
            case SLASH:
                return new Long(lhs / rhs);
            case MOD:
                return new Long(lhs % rhs);
            // bitwise
            case LSHIFT:
            case LSHIFTX:
                return new Long(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Long(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Long(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Long(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Long(lhs | rhs);
            case XOR:
                return new Long(lhs ^ rhs);
            default:
                throw new InterpreterError(
					"Unimplemented binary long operator");
        }
    }
    // returns Object covering both Integer and Boolean return types
    public static Object intBinaryOperation(Integer I1, Integer I2, int kind)
    {
        int lhs = I1.intValue();
        int rhs = I2.intValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Integer(lhs + rhs);
            case MINUS:
                return new Integer(lhs - rhs);
            case STAR:
                return new Integer(lhs * rhs);
            case SLASH:
                return new Integer(lhs / rhs);
            case MOD:
                return new Integer(lhs % rhs);
            // bitwise
            case LSHIFT:
            case LSHIFTX:
                return new Integer(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Integer(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Integer(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Integer(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Integer(lhs | rhs);
            case XOR:
                return new Integer(lhs ^ rhs);
            default:
                throw new InterpreterError(
					"Unimplemented binary integer operator");
        }
    }
    // returns Object covering both Double and Boolean return types
    public static Object doubleBinaryOperation(Double D1, Double D2, int kind)
        throws UtilEvalError
    {
        double lhs = D1.doubleValue();
        double rhs = D2.doubleValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Double(lhs + rhs);
            case MINUS:
                return new Double(lhs - rhs);
            case STAR:
                return new Double(lhs * rhs);
            case SLASH:
                return new Double(lhs / rhs);
            case MOD:
                return new Double(lhs % rhs);
            // can't shift floating-point values
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError("Can't shift doubles");
            default:
                throw new InterpreterError(
					"Unimplemented binary double operator");
        }
    }
    // returns Object covering both Long and Boolean return types
    public static Object floatBinaryOperation(Float F1, Float F2, int kind)
        throws UtilEvalError
    {
        float lhs = F1.floatValue();
        float rhs = F2.floatValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Float(lhs + rhs);
            case MINUS:
                return new Float(lhs - rhs);
            case STAR:
                return new Float(lhs * rhs);
            case SLASH:
                return new Float(lhs / rhs);
            case MOD:
                return new Float(lhs % rhs);
            // can't shift floats
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError("Can't shift floats ");
            default:
                throw new InterpreterError(
					"Unimplemented binary float operator");
        }
    }
	/**
		Promote primitive wrapper type to to Integer wrapper type
	*/
    public static Object promoteToInteger(Object wrapper )
    {
        if(wrapper instanceof Character)
            return new Integer(((Character)wrapper).charValue());
        else if((wrapper instanceof Byte) || (wrapper instanceof Short))
            return new Integer(((Number)wrapper).intValue());
        return wrapper;
    }
	/**
		Promote the pair of primitives to the maximum type of the two.
		e.g. [int,long]->[long,long]
	*/
    public static Object[] promotePrimitives(Object lhs, Object rhs)
    {
        lhs = promoteToInteger(lhs);
        rhs = promoteToInteger(rhs);
        if((lhs instanceof Number) && (rhs instanceof Number))
        {
            Number lnum = (Number)lhs;
            Number rnum = (Number)rhs;
            boolean b;
            if((b = (lnum instanceof Double)) || (rnum instanceof Double))
            {
                if(b)
                    rhs = new Double(rnum.doubleValue());
                else
                    lhs = new Double(lnum.doubleValue());
            }
            else if((b = (lnum instanceof Float)) || (rnum instanceof Float))
            {
                if(b)
                    rhs = new Float(rnum.floatValue());
                else
                    lhs = new Float(lnum.floatValue());
            }
            else if((b = (lnum instanceof Long)) || (rnum instanceof Long))
            {
                if(b)
                    rhs = new Long(rnum.longValue());
                else
                    lhs = new Long(lnum.longValue());
            }
        }
        return new Object[] { lhs, rhs };
    }
    public static Primitive unaryOperation(Primitive val, int kind)
        throws UtilEvalError
    {
        if (val == NULL)
            throw new UtilEvalError(
				"illegal use of null object or 'null' literal");
        if (val == VOID)
            throw new UtilEvalError(
				"illegal use of undefined object or 'void' literal");
        Class operandType = val.getType();
        Object operand = promoteToInteger(val.getValue());
        if ( operand instanceof Boolean )
            return new Primitive(booleanUnaryOperation((Boolean)operand, kind));
        else if(operand instanceof Integer)
        {
            int result = intUnaryOperation((Integer)operand, kind);
            // ++ and -- must be cast back the original type
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Primitive((byte)result);
                if(operandType == Short.TYPE)
                    return new Primitive((short)result);
                if(operandType == Character.TYPE)
                    return new Primitive((char)result);
            }
            return new Primitive(result);
        }
        else if(operand instanceof Long)
            return new Primitive(longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Primitive(floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Primitive(doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(
				"An error occurred.  Please call technical support.");
    }
    public static boolean booleanUnaryOperation(Boolean B, int kind)
		throws UtilEvalError
    {
        boolean operand = B.booleanValue();
        switch(kind)
        {
            case BANG:
                return !operand;
            default:
                throw new UtilEvalError("Operator inappropriate for boolean");
        }
    }
    public static int intUnaryOperation(Integer I, int kind)
    {
        int operand = I.intValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError("bad integer unaryOperation");
        }
    }
    public static long longUnaryOperation(Long L, int kind)
    {
        long operand = L.longValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError("bad long unaryOperation");
        }
    }
    public static float floatUnaryOperation(Float F, int kind)
    {
        float operand = F.floatValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError("bad float unaryOperation");
        }
    }
    public static double doubleUnaryOperation(Double D, int kind)
    {
        double operand = D.doubleValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError("bad double unaryOperation");
        }
    }
    public int intValue() throws UtilEvalError
    {
        if(value instanceof Number)
            return((Number)value).intValue();
        else
            throw new UtilEvalError("Primitive not a number");
    }
    public boolean booleanValue() throws UtilEvalError
    {
        if(value instanceof Boolean)
            return((Boolean)value).booleanValue();
        else
            throw new UtilEvalError("Primitive not a boolean");
    }
	/**
		Determine if this primitive is a numeric type.
		i.e. not boolean, null, or void (but including char)
	*/
	public boolean isNumber() {
		return ( !(value instanceof Boolean) 
			&& !(this == NULL) && !(this == VOID) );
	}
    public Number numberValue() throws UtilEvalError
    {
		Object value = this.value;
		// Promote character to Number type for these purposes
		if (value instanceof Character)
			value = new Integer(((Character)value).charValue());
        if (value instanceof Number)
            return (Number)value;
        else
            throw new UtilEvalError("Primitive not a number");
    }
	/**
		Primitives compare equal with other Primitives containing an equal
		wrapped value.
	*/
	public boolean equals( Object obj ) 
	{
		if ( obj instanceof Primitive )
			return ((Primitive)obj).value.equals( this.value );
		else
			return false;
	}
	/**
		The hash of the Primitive is tied to the hash of the wrapped value but
		shifted so that they are not the same.
	*/
	public int hashCode() 
	{
		return this.value.hashCode() * 21; // arbitrary
	}
	/**
		Unwrap primitive values and map voids to nulls.
		Non Primitive types remain unchanged.
		@param obj object type which may be bsh.Primitive
		@return corresponding "normal" Java type, "unwrapping" 
			any bsh.Primitive types to their wrapper types.
	*/
	public static Object unwrap( Object obj ) 
	{
        // map voids to nulls for the outside world
        if (obj == Primitive.VOID)
            return null;
        // unwrap primitives
        if (obj instanceof Primitive)
            return((Primitive)obj).getValue();
        else
            return obj;
	}
    /*
        Unwrap Primitive wrappers to their java.lang wrapper values.
		e.g. Primitive(42) becomes Integer(42)
		@see #unwrap( Object )
    */
    public static Object [] unwrap( Object[] args )
    {
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = unwrap( args[i] );
		return oa;
    }
    /*
    */
    public static Object [] wrap( Object[] args, Class [] paramTypes )
    {
		if ( args == null )
			return null;
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = wrap( args[i], paramTypes[i] );
		return oa;
    }
	/**
		Wrap primitive values (as indicated by type param) and nulls in the 
		Primitive class.  Values not primitive or null are left unchanged.
		Primitive values are represented by their wrapped values in param value.
		<p/>
		The value null is mapped to Primitive.NULL.
		Any value specified with type Void.TYPE is mapped to Primitive.VOID.
	*/
    public static Object wrap(
		Object value, Class type )
    {
        if ( type == Void.TYPE )
            return Primitive.VOID;
        if ( value == null )
            return Primitive.NULL;
		if ( type.isPrimitive() )
			return new Primitive( value );
		return value;
    }
	/**
		Get the appropriate default value per JLS 4.5.4
	*/
	public static Primitive getDefaultValue( Class type )
	{
		if ( type == null || !type.isPrimitive() )
			return Primitive.NULL;
		if ( type == Boolean.TYPE )
			return new Primitive( false );
		// non boolean primitive, get appropriate flavor of zero
		try {
			return new Primitive((int)0).castToType( type, Types.CAST );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError( "bad cast" );
		}
	}
	/**
		Get the corresponding java.lang wrapper class for the primitive TYPE
		class.
		e.g.  Integer.TYPE -> Integer.class
	*/
	public static Class boxType( Class primitiveType )
	{
		Class c = wrapperMap.get( primitiveType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			"Not a primitive type: "+ primitiveType );
	}
	/**
		Get the corresponding primitive TYPE class for the java.lang wrapper
		class type.
		e.g.  Integer.class -> Integer.TYPE
	*/
	public static Class unboxType( Class wrapperType )
	{
		Class c = wrapperMap.get( wrapperType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			"Not a primitive wrapper type: "+wrapperType );
	}
	/**
		Cast this bsh.Primitive value to a new bsh.Primitive value
		This is usually a numeric type cast.  Other cases include:
			A boolean can be cast to boolen
			null can be cast to any object type and remains null
			Attempting to cast a void causes an exception
		@param toType is the java object or primitive TYPE class
	*/
	public Primitive castToType( Class toType, int operation ) 
		throws UtilEvalError
	{
		return castPrimitive( 
			toType, getType()/*fromType*/, this/*fromValue*/, 
			false/*checkOnly*/, operation );
	}
	/*
		Cast or check a cast of a primitive type to another type.
		Normally both types are primitive (e.g. numeric), but a null value
		(no type) may be cast to any type.
		<p/>
		@param toType is the target type of the cast.  It is normally a
		java primitive TYPE, but in the case of a null cast can be any object
		type.
		@param fromType is the java primitive TYPE type of the primitive to be
		cast or null, to indicate that the fromValue was null or void.
		@param fromValue is, optionally, the value to be converted.  If
		checkOnly is true fromValue must be null.  If checkOnly is false,
		fromValue must be non-null (Primitive.NULL is of course valid).
	*/
	static Primitive castPrimitive( 
		Class toType, Class fromType, Primitive fromValue, 
		boolean checkOnly, int operation ) 
		throws UtilEvalError
	{
		/*
			Lots of preconditions checked here...
			Once things are running smoothly we might comment these out
			(That's what assertions are for).
		*/
		if ( checkOnly && fromValue != null )
			throw new InterpreterError("bad cast param 1");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError("bad cast param 2");
		if ( fromType != null && !fromType.isPrimitive() )
			throw new InterpreterError("bad fromType:" +fromType);
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError("inconsistent args 1");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError("inconsistent args 2");
		// can't cast void to anything
		if ( fromType == Void.TYPE )
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( Reflect.normalizeClassName(toType), 
					"void value", operation );
		// unwrap Primitive fromValue to its wrapper value, etc.
		Object value = null; 
		if ( fromValue != null )
			value = fromValue.getValue();
		if ( toType.isPrimitive() )
		{
			// Trying to cast null to primitive type?
			if ( fromType == null )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError(
						"primitive type:" + toType, "Null value", operation );
			// fall through
		} else
		{
			// Trying to cast primitive to an object type
			// Primitive.NULL can be cast to any object type
			if ( fromType == null )
				return checkOnly ? Types.VALID_CAST : 
					Primitive.NULL;
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError(
						"object type:" + toType, "primitive value", operation);
		}
		// can only cast boolean to boolean
		if ( fromType == Boolean.TYPE )
		{
			if ( toType != Boolean.TYPE )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError( toType, fromType, operation );
			return checkOnly ? Types.VALID_CAST :
				fromValue;
		}
		// Do numeric cast
		// Only allow legal Java assignment unless we're a CAST operation
		if ( operation == Types.ASSIGNMENT 
			&& !Types.isJavaAssignable( toType, fromType ) 
		) {
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( toType, fromType, operation );
		}
		return checkOnly ? Types.VALID_CAST :
			new Primitive( castWrapper(toType, value) );
	}
	public static boolean isWrapperType( Class type )
	{
		return wrapperMap.get( type ) != null && !type.isPrimitive();
	}
	/**
		Cast a primitive value represented by its java.lang wrapper type to the
		specified java.lang wrapper type.  e.g.  Byte(5) to Integer(5) or
		Integer(5) to Byte(5) 
		@param toType is the java TYPE type
		@param value is the value in java.lang wrapper.
		value may not be null.
	*/
	static Object castWrapper( 
		Class toType, Object value ) 
	{
		if ( !toType.isPrimitive() )
			throw new InterpreterError("invalid type in castWrapper: "+toType);
		if ( value == null )
			throw new InterpreterError("null value in castWrapper, guard");
		if ( value instanceof Boolean )
		{
			if ( toType != Boolean.TYPE )
				throw new InterpreterError("bad wrapper cast of boolean");
			else
				return value;
		}
		// first promote char to Number type to avoid duplicating code
		if ( value instanceof Character )
			value = new Integer(((Character)value).charValue());
		if ( !(value instanceof Number) )
			throw new InterpreterError("bad type in cast");
		Number number = (Number)value;
		if (toType == Byte.TYPE)
			return new Byte(number.byteValue());
		if (toType == Short.TYPE)
			return new Short(number.shortValue());
		if (toType == Character.TYPE)
			return new Character((char)number.intValue());
		if (toType == Integer.TYPE)
			return new Integer(number.intValue());
		if (toType == Long.TYPE)
			return new Long(number.longValue());
		if (toType == Float.TYPE)
			return new Float(number.floatValue());
		if (toType == Double.TYPE)
			return new Double(number.doubleValue());
		throw new InterpreterError("error in wrapper cast");
	}
}
package bsh;
import bsh.ast.*;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.*;
import java.util.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public final class ClassGenerator {
    private static ClassGenerator cg;
	private static final String DEBUG_DIR = System.getProperty("bsh.debugClasses");
	public static ClassGenerator getClassGenerator() {
        if (cg == null) {
            cg = new ClassGenerator();
        }
        return cg;
    }
    /**
     * Parse the BSHBlock for the class definition and generate the class.
     */
    public Class generateClass(String name, Modifiers modifiers, Class[] interfaces,
                               Class superClass, BSHBlock block, boolean isInterface,
                               CallStack callstack, Interpreter interpreter) throws EvalError {
        // Delegate to the static method
        return generateClassImpl(name, modifiers, interfaces, superClass, block, isInterface,
                new BshEvaluatingVisitor(callstack, interpreter));
    }
    /**
     * Invoke a super.method() style superclass method on an object instance.
     * This is not a normal function of the Java reflection API and is
     * provided by generated class accessor methods.
     */
    public Object invokeSuperclassMethod(BshClassManager bcm, Object instance,
                                         String methodName, Object[] args) throws UtilEvalError,
            ReflectError, InvocationTargetException {
        // Delegate to the static method
        return invokeSuperclassMethodImpl(bcm, instance, methodName, args);
    }
    /**
     * Change the parent of the class instance namespace.
     * This is currently used for inner class support.
     * Note: This method will likely be removed in the future.
     */
    // This could be static
    public void setInstanceNameSpaceParent(Object instance, String className, NameSpace parent) {
        This ithis = ClassGeneratorUtil.getClassInstanceThis(instance, className);
        ithis.getNameSpace().setParent(parent);
    }
    /**
     * Parse the BSHBlock for for the class definition and generate the class
     * using ClassGenerator.
     */
    public static Class generateClassImpl(String name, Modifiers modifiers, Class[] interfaces,
            Class superClass, BSHBlock block, boolean isInterface,
            BshEvaluatingVisitor visitor) throws EvalError {
        // Scripting classes currently requires accessibility
        // This can be eliminated with a bit more work.
        try {
            Capabilities.setAccessibility(true);
        } catch (Capabilities.Unavailable e) {
            throw new EvalError("Defining classes currently requires reflective Accessibility.",
                    block, visitor.getCallstack());
        }
        NameSpace enclosingNameSpace = visitor.getCallstack().top();
        String packageName = enclosingNameSpace.getPackage();
        String className = enclosingNameSpace.isClass ? (enclosingNameSpace.getName() + "$" + name) : name;
        String fqClassName = packageName == null ? className : packageName + "." + className;
        BshClassManager bcm = visitor.getInterpreter().getClassManager();
        // Race condition here...
        bcm.definingClass(fqClassName);
        // Create the class static namespace
        NameSpace classStaticNameSpace = new NameSpace(enclosingNameSpace, className);
        classStaticNameSpace.isClass = true;
        visitor.getCallstack().push(classStaticNameSpace);
        // Evaluate any inner class class definitions in the block
        // effectively recursively call this method for contained classes first
        visitor.evalBlock(block, true/*override*/, ClassNodeFilter.CLASSCLASSES);
        // Generate the type for our class
        Variable[] variables = getDeclaredVariables(block, visitor, packageName);
        DelayedEvalBshMethod[] methods = getDeclaredMethods(block, visitor, packageName);
        ClassGeneratorUtil classGenerator = new ClassGeneratorUtil(modifiers, className, packageName, superClass, interfaces, variables, methods, classStaticNameSpace, isInterface);
        byte[] code = classGenerator.generateClass();
        // if debug, write out the class file to debugClasses directory
		if (DEBUG_DIR != null) try {
            FileOutputStream out = new FileOutputStream(DEBUG_DIR + '/' + className + ".class");
            out.write(code);
            out.close();
        } catch (IOException e) {
            throw new IllegalStateException("cannot create file " + DEBUG_DIR + '/' + className + ".class", e);
        }
        // Define the new class in the classloader
        Class genClass = bcm.defineClass(fqClassName, code);
        // import the unq name into parent
        enclosingNameSpace.importClass(fqClassName.replace('$', '.'));
        try {
            classStaticNameSpace.setLocalVariable(ClassGeneratorUtil.BSHINIT, block, false/*strictJava*/);
        } catch (UtilEvalError e) {
            throw new InterpreterError("unable to init static: " + e);
        }
        // Give the static space its class static import
        // important to do this after all classes are defined
        classStaticNameSpace.setClassStatic(genClass);
        // evaluate the static portion of the block in the static space
        visitor.evalBlock(block, true/*override*/, ClassNodeFilter.CLASSSTATIC);
        visitor.getCallstack().pop();
        if ( ! genClass.isInterface()) {
            // Set the static bsh This callback
            String bshStaticFieldName = ClassGeneratorUtil.BSHSTATIC + className;
            try {
                LHS lhs = Reflect.getLHSStaticField(genClass, bshStaticFieldName);
                lhs.assign(classStaticNameSpace.getThis(visitor.getInterpreter()), false/*strict*/);
            } catch (Exception e) {
                throw new InterpreterError("Error in class gen setup: " + e);
            }
        }
        bcm.doneDefiningClass(fqClassName);
        return genClass;
    }
    static Variable[] getDeclaredVariables(BSHBlock body, BshEvaluatingVisitor visitor, String defaultPackage) {
        List<Variable> vars = new ArrayList<Variable>();
        for (int child = 0; child < body.jjtGetNumChildren(); child++) {
            SimpleNode node = (SimpleNode) body.jjtGetChild(child);
            if (node instanceof BSHTypedVariableDeclaration) {
                BSHTypedVariableDeclaration tvd = (BSHTypedVariableDeclaration) node;
                Modifiers modifiers = tvd.modifiers;
                String type = visitor.getTypeDescriptor(tvd.getTypeNode(), defaultPackage);
                BSHVariableDeclarator[] vardec = tvd.getDeclarators();
                for (BSHVariableDeclarator aVardec : vardec) {
                    String name = aVardec.name;
                    try {
                        Variable var = new Variable(name, type, null/*value*/, modifiers);
                        vars.add(var);
                    } catch (UtilEvalError e) {
                        // value error shouldn't happen
                    }
                }
            }
        }
        return vars.toArray(new Variable[vars.size()]);
    }
    static DelayedEvalBshMethod[] getDeclaredMethods(BSHBlock body,
           BshEvaluatingVisitor visitor, String defaultPackage) throws EvalError {
        List<DelayedEvalBshMethod> methods = new ArrayList<DelayedEvalBshMethod>();
        for (int child = 0; child < body.jjtGetNumChildren(); child++) {
            SimpleNode node = (SimpleNode) body.jjtGetChild(child);
            if (node instanceof BSHMethodDeclaration) {
                BSHMethodDeclaration md = (BSHMethodDeclaration) node;
                md.insureNodesParsed();
                Modifiers modifiers = md.modifiers;
                String name = md.name;
                String returnType = visitor.getReturnTypeDescriptor(md, defaultPackage);
                BSHReturnType returnTypeNode = visitor.getReturnTypeNode(md);
                BSHFormalParameters paramTypesNode = md.paramsNode;
                String[] paramTypes = visitor.getTypeDescriptors(paramTypesNode, defaultPackage);
                DelayedEvalBshMethod bm = new DelayedEvalBshMethod(name, returnType, returnTypeNode,
                        md.paramsNode.getParamNames(), paramTypes, paramTypesNode, md.blockNode,
                        null/*declaringNameSpace*/, modifiers,
                        visitor);
                methods.add(bm);
            }
        }
        return methods.toArray(new DelayedEvalBshMethod[methods.size()]);
    }
    /**
     * A node filter that filters nodes for either a class body static
     * initializer or instance initializer.  In the static case only static
     * members are passed, etc.
     */
    static class ClassNodeFilter implements BSHBlock.NodeFilter {
        public static final int STATIC = 0, INSTANCE = 1, CLASSES = 2;
        public static ClassNodeFilter CLASSSTATIC = new ClassNodeFilter(STATIC);
        public static ClassNodeFilter CLASSINSTANCE = new ClassNodeFilter(INSTANCE);
        public static ClassNodeFilter CLASSCLASSES = new ClassNodeFilter(CLASSES);
        int context;
        private ClassNodeFilter(int context) {
            this.context = context;
        }
        public boolean isVisible(SimpleNode node) {
            if (context == CLASSES) return node instanceof BSHClassDeclaration;
            // Only show class decs in CLASSES
            if (node instanceof BSHClassDeclaration) return false;
            if (context == STATIC) return isStatic(node);
            if (context == INSTANCE) return !isStatic(node);
            // ALL
            return true;
        }
        boolean isStatic(SimpleNode node) {
            if (node instanceof BSHTypedVariableDeclaration)
                return ((BSHTypedVariableDeclaration) node).modifiers != null
                        && ((BSHTypedVariableDeclaration) node).modifiers.hasModifier("static");
            if (node instanceof BSHMethodDeclaration)
                return ((BSHMethodDeclaration) node).modifiers != null
                        && ((BSHMethodDeclaration) node).modifiers.hasModifier("static");
            // need to add static block here
            if (node instanceof BSHBlock) return false;
            return false;
        }
    }
    public static Object invokeSuperclassMethodImpl(BshClassManager bcm, Object instance,
                                                    String methodName, Object[] args)
            throws UtilEvalError, ReflectError, InvocationTargetException {
        String superName = ClassGeneratorUtil.BSHSUPER + methodName;
        // look for the specially named super delegate method
        Class clas = instance.getClass();
        Method superMethod = Reflect.resolveJavaMethod(bcm, clas, superName, Types.getTypes(args), false/*onlyStatic*/);
        if (superMethod != null) return Reflect.invokeMethod(superMethod, instance, args);
        // No super method, try to invoke regular method
        // could be a superfluous "super." which is legal.
        Class superClass = clas.getSuperclass();
        superMethod = Reflect.resolveExpectedJavaMethod(bcm, superClass, instance, methodName, args, false/*onlyStatic*/);
        return Reflect.invokeMethod(superMethod, instance, args);
    }
}
package bsh;
import bsh.ast.SimpleNode;
public class UtilEvalError extends Exception 
{
	protected UtilEvalError() {
	}
	public UtilEvalError( String s ) {
		super(s);
	}
	public UtilEvalError( String s, Throwable cause ) {
		super(s,cause);
	}
	/**
		Re-throw as an eval error, prefixing msg to the message and specifying
		the node.  If a node already exists the addNode is ignored.
		@see #setNode(bsh.ast.SimpleNode)
		<p>
		@param msg may be null for no additional message.
	*/
	public EvalError toEvalError( 
		String msg, SimpleNode node, CallStack callstack  )
	{
		if ( Interpreter.DEBUG )
			printStackTrace();
		if ( msg == null )
			msg = "";
		else
			msg = msg + ": ";
		return new EvalError( msg+getMessage(), node, callstack, this );
	}
	public EvalError toEvalError ( SimpleNode node, CallStack callstack ) 
	{
		return toEvalError( null, node, callstack );
	}
}
package bsh;
import java.util.*;
public class StringUtil {
	public static String [] split( String s, String delim) {
		List<String> v = new ArrayList<String>();
		StringTokenizer st = new StringTokenizer(s, delim);
		while ( st.hasMoreTokens() )
			v.add( st.nextToken() );
		return v.toArray(new String[0]);
	}
	public static String maxCommonPrefix( String one, String two ) {
		int i=0;
		while( one.regionMatches( 0, two, 0, i ) )
			i++;
		return one.substring(0, i-1);
	}
    public static String methodString(String name, Class[] types)
    {
        StringBuilder sb = new StringBuilder(name + "(");
        if ( types.length > 0 )
			sb.append(" ");
        for( int i=0; i<types.length; i++ )
        {
            Class c = types[i];
            sb.append( ( (c == null) ? "null" : c.getName() ) 
				+ ( i < (types.length-1) ? ", " : " " ) );
        }
        sb.append(")");
        return sb.toString();
    }
	/**
		Split a filename into dirName, baseName
		@return String [] { dirName, baseName }
    public String [] splitFileName( String fileName ) 
	{ 
		String dirName, baseName;
		int i = fileName.lastIndexOf( File.separator );
		if ( i != -1 ) {
			dirName = fileName.substring(0, i);
			baseName = fileName.substring(i+1);
		} else
			baseName = fileName;
		return new String[] { dirName, baseName };
	}
	*/
	/**
		Hack - The real method is in Reflect.java which is not public.
	*/
    public static String normalizeClassName( Class type )
	{
		return Reflect.normalizeClassName( type );
	}
}
package	bsh;
public class BlockNameSpace extends NameSpace
{
    public BlockNameSpace( NameSpace parent ) 
		throws EvalError
	{
		super( parent, parent.getName()+ "/BlockNameSpace" );
    }
	/**
		Override the standard namespace behavior to make assignments
		happen in our parent (enclosing) namespace, unless the variable has
		already been assigned here via a typed declaration or through
		the special setBlockVariable() (used for untyped args in try/catch).
		<p>
		i.e. only allow typed var declaration to happen in this namespace.
		Typed vars are handled in the ordinary way local scope.  All untyped
		assignments are delegated to the enclosing context.
	*/
	/*
		Note: it may see like with the new 1.3 scoping this test could be
		removed, but it cannot.  When recurse is false we still need to set the
		variable in our parent, not here.
	*/
    public void	setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		if ( weHaveVar( name ) ) 
			// set the var here in the block namespace
			super.setVariable( name, value, strictJava, false );
		else
			// set the var in the enclosing (parent) namespace
			getParent().setVariable( name, value, strictJava, recurse );
    }
	/**
		Set an untyped variable in the block namespace.
		The BlockNameSpace would normally delegate this set to the parent.
		Typed variables are naturally set locally.
		This is used in try/catch block argument. 
	*/
    public void	setBlockVariable( String name, Object value ) 
		throws UtilEvalError 
	{
		super.setVariable( name, value, false/*strict?*/, false );
	}
	/**
		We have the variable: either it was declared here with a type, giving
		it block local scope or an untyped var was explicitly set here via
		setBlockVariable().
	*/
	private boolean weHaveVar( String name ) 
	{
		// super.variables.containsKey( name ) not any faster, I checked
		try {
			return super.getVariableImpl( name, false ) != null;
		} catch ( UtilEvalError e ) { return false; }
	}
/**
		Get the actual BlockNameSpace 'this' reference.
		<p/>
		Normally a 'this' reference to a BlockNameSpace (e.g. if () { } )
		resolves to the parent namespace (e.g. the namespace containing the
		"if" statement).  However when code inside the BlockNameSpace needs to
		resolve things relative to 'this' we must use the actual block's 'this'
		reference.  Name.java is smart enough to handle this using
		getBlockThis().
		@see #getThis( Interpreter )
    This getBlockThis( Interpreter declaringInterpreter ) 
	{
		return super.getThis( declaringInterpreter );
	}
*/
	//
	// Begin methods which simply delegate to our parent (enclosing scope) 
	//
	/**
		This method recurses to find the nearest non-BlockNameSpace parent.
	public NameSpace getParent() 
	{
		NameSpace parent = super.getParent();
		if ( parent instanceof BlockNameSpace )
			return parent.getParent();
		else
			return parent;
	}
*/
	/** do we need this? */
	private NameSpace getNonBlockParent() 
	{
		NameSpace parent = super.getParent();
		if ( parent instanceof BlockNameSpace )
			return ((BlockNameSpace)parent).getNonBlockParent();
		else
			return parent;
	}
	/**
		Get a 'this' reference is our parent's 'this' for the object closure.
		e.g. Normally a 'this' reference to a BlockNameSpace (e.g. if () { } )
		resolves to the parent namespace (e.g. the namespace containing the
		"if" statement). 
		@see #getBlockThis( Interpreter )
	*/
    public This getThis( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getThis( declaringInterpreter );
	}
	/**
		super is our parent's super
	*/
    public This getSuper( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getSuper( declaringInterpreter );
	}
	/**
		delegate import to our parent
	*/
    public void	importClass(String name) {
		getParent().importClass( name );
	}
	/**
		delegate import to our parent
	*/
    public void	importPackage(String name) {
		getParent().importPackage( name );
	}
    public void	setMethod(BshMethod method) 
		throws UtilEvalError
	{
		getParent().setMethod( method );
	}
}
package bsh;
import bsh.ast.SimpleNode;
public class EvalError extends Error
{
	private SimpleNode node;
	// Note: no way to mutate the Throwable message, must maintain our own
	private String message;
	private final CallStack callstack;
	public EvalError( String s, SimpleNode node, CallStack callstack, Throwable cause ) {
		this(s,node,callstack);
		initCause(cause);
	}
	public EvalError( String s, SimpleNode node, CallStack callstack ) {
		this.message = s;
		this.node = node;
		// freeze the callstack for the stack trace.
		this.callstack = callstack==null ? null : callstack.copy();
	}
	/**
		Print the error with line number and stack trace.
	*/
	public String getMessage() 
	{
		String trace;
		if ( node != null )
			trace = " : at Line: "+ node.getLineNumber() 
				+ " : in file: "+ node.getSourceFile()
				+ " : "+node.getText();
		else
			// Users should not normally see this.
			trace = ": <at unknown location>";
		if ( callstack != null )
			trace = trace +"\n" + getScriptStackTrace();
		return getRawMessage() + trace;
	}
	/**
		Re-throw the error, prepending the specified message.
	*/
	public void reThrow( String msg ) 
		throws EvalError 
	{
		prependMessage( msg );
		throw this;
	}
	/**
		The error has trace info associated with it. 
		i.e. It has an AST node that can print its location and source text.
	*/
	SimpleNode getNode() {
		return node;
	}
	void setNode( SimpleNode node ) {
		this.node = node;
	}
	public String getErrorText() { 
		if ( node != null )
			return node.getText() ;
		else
			return "<unknown error>";
	}
	public int getErrorLineNumber() { 
		if ( node != null )
			return node.getLineNumber() ;
		else
			return -1;
	}
	public String getErrorSourceFile() {
		if ( node != null )
			return node.getSourceFile() ;
		else
			return "<unknown file>";
	}
	public String getScriptStackTrace() 
	{
		if ( callstack == null )
			return "<Unknown>";
		String trace = "";
		CallStack stack = callstack.copy();
		while ( stack.depth() > 0 ) 
		{
			NameSpace ns = stack.pop();
			SimpleNode node = ns.getNode();
			if ( ns.isMethod )
			{
				trace = trace + "\nCalled from method: " + ns.getName();
				if ( node != null )
					trace += " : at Line: "+ node.getLineNumber() 
						+ " : in file: "+ node.getSourceFile()
						+ " : "+node.getText();
			}
		}
		return trace;
	}
	public String getRawMessage() { return message; }
	/**
		Prepend the message if it is non-null.
	*/
	private void prependMessage( String s ) 
	{ 
		if ( s == null )
			return;
		if ( message == null )
			message = s;
		else
			message = s + " : "+ message;
	}
}
package bsh.ast;
import bsh.*;

public class SimpleNode implements Node
{
	public static SimpleNode JAVACODE =
		new SimpleNode( -1 ) {
			public String getSourceFile() {
				return "<Called from Java Code>";
			}
			public int getLineNumber() {
				return -1;
			}
			public String getText()  {
				return "<Compiled Java Code>";
			}
		};
	protected Node parent;
	protected Node[] children;
	protected int id;
	public Token firstToken, lastToken;
	/** the source of the text from which this was parsed */
	String sourceFile;
	public SimpleNode(int i) {
		id = i;
	}
	public void jjtOpen() { }
	public void jjtClose() { }
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	//public SimpleNode getParent() { return (SimpleNode)parent; }
	public void jjtAddChild(Node n, int i)
	{
		if (children == null)
			children = new Node[i + 1];
		else
			if (i >= children.length)
			{
				Node c[] = new Node[i + 1];
				System.arraycopy(children, 0, c, 0, children.length);
				children = c;
			}
		children[i] = n;
	}
	public Node jjtGetChild(int i) { 
		return children[i]; 
	}
	public SimpleNode getChild( int i ) {
		return (SimpleNode)jjtGetChild(i);
	}
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
    /*
         You can override these two methods in subclasses of SimpleNode to
         customize the way the node appears when the tree is dumped.  If
         your output uses more than one line you should override
         toString(String), otherwise overriding toString() is probably all
         you need to do.
     */
	public String toString() { return ParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }
	/*
		Override this method if you want to customize how the node dumps
		out its children.
	*/
	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if(children != null)
		{
			for(int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null)
				{
					n.dump(prefix + " ");
				}
			}
		}
	}
	//  ---- BeanShell specific stuff hereafter ----  //
	/**
		Detach this node from its parent.
		This is primarily useful in node serialization.
		(see BSHMethodDeclaration)
	*/
	public void prune() {
		jjtSetParent( null );
	}
	/**
		Set the name of the source file (or more generally source) of
		the text from which this node was parsed.
	*/
	public void setSourceFile( String sourceFile ) {
		this.sourceFile = sourceFile;
	}
	/**
		Get the name of the source file (or more generally source) of
		the text from which this node was parsed.
		This will recursively search up the chain of parent nodes until
		a source is found or return a string indicating that the source
		is unknown.
	*/
	public String getSourceFile() {
		if ( sourceFile == null )
			if ( parent != null )
				return ((SimpleNode)parent).getSourceFile();
			else
				return "<unknown file>";
		else
			return sourceFile;
	}
	/**
		Get the line number of the starting token
	*/
	public int getLineNumber() {
		return firstToken.beginLine;
	}
	/**
		Get the ending line number of the starting token
	public int getEndLineNumber() {
		return lastToken.endLine;
	}
	*/
	/**
		Get the text of the tokens comprising this node.
	*/
	public String getText() 
	{
		StringBuilder text = new StringBuilder();
		Token t = firstToken;
		while ( t!=null ) {
			text.append(t.image);
			if ( !t.image.equals(".") )
				text.append(" ");
			if ( t==lastToken ||
				t.image.equals("{") || t.image.equals(";") )
				break;
			t=t.next;
		}
			
		return text.toString();
	}
    public <T> T accept(BshNodeVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
/**
	The BeanShell script interpreter.
	An instance of Interpreter can be used to source scripts and evaluate 
	statements or expressions.  
	<p>
	Here are some examples:
	<p><blockquote><pre>
		Interpeter bsh = new Interpreter();
		// Evaluate statements and expressions
		bsh.eval("foo=Math.sin(0.5)");
		bsh.eval("bar=foo*5; bar=Math.cos(bar);");
		bsh.eval("for(i=0; i<10; i++) { print(\"hello\"); }");
		// same as above using java syntax and apis only
		bsh.eval("for(int i=0; i<10; i++) { System.out.println(\"hello\"); }");
		// Source from files or streams
		bsh.source("myscript.bsh");  // or bsh.eval("source(\"myscript.bsh\")");
		// Use set() and get() to pass objects in and out of variables
		bsh.set( "date", new Date() );
		Date date = (Date)bsh.get( "date" );
		// This would also work:
		Date date = (Date)bsh.eval( "date" );
		bsh.eval("year = date.getYear()");
		Integer year = (Integer)bsh.get("year");  // primitives use wrappers
		// With Java1.3+ scripts can implement arbitrary interfaces...
		// Script an awt event handler (or source it from a file, more likely)
		bsh.eval( "actionPerformed( e ) { print( e ); }");
		// Get a reference to the script object (implementing the interface)
		ActionListener scriptedHandler = 
			(ActionListener)bsh.eval("return (ActionListener)this");
		// Use the scripted event handler normally...
		new JButton.addActionListener( script );
	</pre></blockquote>
	<p>
	In the above examples we showed a single interpreter instance, however 
	you may wish to use many instances, depending on the application and how
	you structure your scripts.  Interpreter instances are very light weight
	to create, however if you are going to execute the same script repeatedly
	and require maximum performance you should consider scripting the code as 
	a method and invoking the scripted method each time on the same interpreter
	instance (using eval()). 
	<p>
	See the BeanShell User's Manual for more information.
*/
public class Interpreter 
	implements Runnable, ConsoleInterface,Serializable
{
	/* --- Begin static members --- */
	public static final String VERSION = "2.2b0";
	/*
		Debug utils are static so that they are reachable by code that doesn't
		necessarily have an interpreter reference (e.g. tracing in utils).
		In the future we may want to allow debug/trace to be turned on on
		a per interpreter basis, in which case we'll need to use the parent 
		reference in some way to determine the scope of the command that 
		turns it on or off.
	*/
	public static boolean DEBUG, TRACE, LOCALSCOPING;
	// This should be per instance
	transient static PrintStream debug;
	static String systemLineSeparator = "\n"; // default
	private static final This SYSTEM_OBJECT = This.getThis(new NameSpace(null, null, "bsh.system"), null);
	static {
		staticInit();
	}
	/** 
		Strict Java mode 
		@see #setStrictJava( boolean )
	*/
	private boolean strictJava = false;
	/* --- End static members --- */
	/* --- Instance data --- */
	transient Parser parser;
	NameSpace globalNameSpace;
	transient Reader in;
	transient PrintStream out;
	transient PrintStream err;
	ConsoleInterface console; 
	/** If this interpeter is a child of another, the parent */
	Interpreter parent;
	/** The name of the file or other source that this interpreter is reading */
	String sourceFileInfo;
	/** by default in interactive mode System.exit() on EOF */
	private boolean exitOnEOF = true;
	protected boolean 
		evalOnly, 		// Interpreter has no input stream, use eval() only
		interactive;	// Interpreter has a user, print prompts, etc.
	/** Control the verbose printing of results for the show() command. */
	private boolean showResults;
	/* --- End instance data --- */
	/**
		The main constructor.
		All constructors should now pass through here.
		@param namespace If namespace is non-null then this interpreter's 
		root namespace will be set to the one provided.  If it is null a new 
		one will be created for it.
		@param parent The parent interpreter if this interpreter is a child 
			of another.  May be null.  Children share a BshClassManager with
			their parent instance.
		@param sourceFileInfo An informative string holding the filename 
		or other description of the source from which this interpreter is
		reading... used for debugging.  May be null.
	*/
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace,
		Interpreter parent, String sourceFileInfo )
	{
		//System.out.println("New Interpreter: "+this +", sourcefile = "+sourceFileInfo );
		parser = new Parser( in );
		long t1 = 0;
		if (Interpreter.DEBUG) {
			t1=System.currentTimeMillis();
		}
		this.in = in;
		this.out = out;
		this.err = err;
		this.interactive = interactive;
		debug = err;
		this.parent = parent;
		if ( parent != null )
			setStrictJava( parent.getStrictJava() );
		this.sourceFileInfo = sourceFileInfo;
		BshClassManager bcm = BshClassManager.createClassManager( this );
		if ( namespace == null ) {
			globalNameSpace = new NameSpace( bcm, "global");
			initRootSystemObject();
		} else {
			globalNameSpace = namespace;
			try {
				if ( ! (globalNameSpace.getVariable("bsh") instanceof This)) {
					initRootSystemObject();
				}
			} catch (final UtilEvalError e) {
				throw new IllegalStateException(e);
			}
		}
		// now done in NameSpace automatically when root
		// The classes which are imported by default
		//globalNameSpace.loadDefaultImports();
		if ( interactive ) {
			loadRCFiles();
		}
		if ( Interpreter.DEBUG ) {
			long t2=System.currentTimeMillis();
			Interpreter.debug("Time to initialize interpreter: "+(t2-t1));
		}
	}
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace)
	{
		this( in, out, err, interactive, namespace, null, null );
	}
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, boolean interactive)
	{
		this(in, out, err, interactive, null);
	}
	/**
		Construct a new interactive interpreter attached to the specified 
		console using the specified parent namespace.
	*/
	public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {
		this( console.getIn(), console.getOut(), console.getErr(), 
			true, globalNameSpace );
		setConsole( console );
	}
	/**
		Construct a new interactive interpreter attached to the specified 
		console.
	*/
	public Interpreter(ConsoleInterface console) {
		this(console, null);
	}
	/**
		Create an interpreter for evaluation only.
	*/
	public Interpreter()
	{
		this( new StringReader(""), 
			System.out, System.err, false, null );
		evalOnly = true;
		setu( "bsh.evalOnly", new Primitive(true) );
	}
	// End constructors
	/**
		Attach a console
		Note: this method is incomplete.
	*/
	public void setConsole( ConsoleInterface console ) {
		this.console = console;
		setu( "bsh.console", console );
		// redundant with constructor
		setOut( console.getOut() );
		setErr( console.getErr() );
		// need to set the input stream - reinit the parser?
	}
	private void initRootSystemObject() 
	{
		BshClassManager bcm = getClassManager();
		// bsh
		setu("bsh", new NameSpace( bcm, "Bsh Object" ).getThis( this ) );
		setu( "bsh.system", SYSTEM_OBJECT);
		setu( "bsh.shared", SYSTEM_OBJECT); // alias
		// bsh.help
		This helpText = new NameSpace(bcm, "Bsh Command Help Text" ).getThis( this );
		setu( "bsh.help", helpText );
		// bsh.cwd
		try {
			setu( "bsh.cwd", System.getProperty("user.dir") );
		} catch ( SecurityException e ) { 
			// applets can't see sys props
			setu( "bsh.cwd", "." );
		}
		// bsh.interactive
		setu( "bsh.interactive", new Primitive(interactive) );
		// bsh.evalOnly
		setu( "bsh.evalOnly", new Primitive(evalOnly) );
	}
	/**
		Set the global namespace for this interpreter.
		<p>
		Note: This is here for completeness.  If you're using this a lot 
		it may be an indication that you are doing more work than you have 
		to.  For example, caching the interpreter instance rather than the 
		namespace should not add a significant overhead.  No state other 
		than the debug status is stored in the interpreter.
		<p>
		All features of the namespace can also be accessed using the 
		interpreter via eval() and the script variable 'this.namespace'
		(or global.namespace as necessary).
	*/
	public void setNameSpace( NameSpace globalNameSpace ) {
		this.globalNameSpace = globalNameSpace;
	}
	/**
		Get the global namespace of this interpreter.
		<p>
		Note: This is here for completeness.  If you're using this a lot 
		it may be an indication that you are doing more work than you have 
		to.  For example, caching the interpreter instance rather than the 
		namespace should not add a significant overhead.  No state other than 
		the debug status is stored in the interpreter.  
		<p>
		All features of the namespace can also be accessed using the 
		interpreter via eval() and the script variable 'this.namespace'
		(or global.namespace as necessary).
	*/
	public NameSpace getNameSpace() {
		return globalNameSpace;
	}
	/**
		Run the text only interpreter on the command line or specify a file.
	*/
	public static void main( String [] args ) 
	{
		if ( args.length > 0 ) {
			String filename = args[0];
			String [] bshArgs;
			if ( args.length > 1 ) {
				bshArgs = new String [ args.length -1 ];
				System.arraycopy( args, 1, bshArgs, 0, args.length-1 );
			} else
				bshArgs = new String [0];
			Interpreter interpreter = new Interpreter();
			//System.out.println("run i = "+interpreter);
			interpreter.setu( "bsh.args", bshArgs );
			try {
				Object result = 
					interpreter.source( filename, interpreter.globalNameSpace );
				if ( result instanceof Class )
					try {
						invokeMain( (Class)result, bshArgs );
					} catch ( Exception e ) 
					{
						Object o = e;
						if ( e instanceof InvocationTargetException )
							o = ((InvocationTargetException)e)
								.getTargetException();
						System.err.println(
							"Class: "+result+" main method threw exception:"+o);
					}
			} catch ( FileNotFoundException e ) {
				System.err.println("File not found: "+e);
			} catch ( TargetError e ) {
				System.err.println("Script threw exception: "+e);
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, System.err );
			} catch ( EvalError e ) {
				System.err.println("Evaluation Error: "+e);
			} catch ( IOException e ) {
				System.err.println("I/O Error: "+e);
			}
		} else 
		{
			// Workaround for JDK bug 4071281, where system.in.available() 
			// returns too large a value. This bug has been fixed in JDK 1.2.
			InputStream src;
			if ( System.getProperty("os.name").startsWith("Windows") 
				&& System.getProperty("java.version").startsWith("1.1."))
			{
				src = new FilterInputStream(System.in) {
					public int available() throws IOException {
						return 0;
					}
				};
			}
			else
				src = System.in;
			Reader in = new CommandLineReader( new InputStreamReader(src));
			Interpreter interpreter = 
				new Interpreter( in, System.out, System.err, true );
			interpreter.run();
		}
	}
	public static void invokeMain( Class clas, String [] args ) 
		throws Exception
	{
		Method main = Reflect.resolveJavaMethod(
			null/*BshClassManager*/, clas, "main", 
			new Class [] { String [].class }, true/*onlyStatic*/ );
		if ( main != null )
			main.invoke( null, new Object [] { args } );
	}
	/**
		Run interactively.  (printing prompts, etc.)
	*/
	public void run() 
	{
		if(evalOnly)
			throw new RuntimeException("bsh Interpreter: No stream");
		/*
		  We'll print our banner using eval(String) in order to
		  exercise the parser and get the basic expression classes loaded...
		  This ameliorates the delay after typing the first statement.
		*/
		if ( interactive )
			try { 
				eval("printBanner();"); 
			} catch ( EvalError e ) {
				println(
					"BeanShell2 " + VERSION + " - http://code.google.com/p/beanshell2");
			}
		// init the callstack.  
		CallStack callstack = new CallStack( globalNameSpace );
        BshEvaluatingVisitor evaluator = new BshEvaluatingVisitor(callstack, this);
		SimpleNode node = null;
		boolean eof = false;
		while( !eof )
		{
			try
			{
				// try to sync up the console
				System.out.flush();
				System.err.flush();
				Thread.yield();  // this helps a little
				if ( interactive )
					print( getBshPrompt() );
				eof = Line();
				if( get_jjtree().nodeArity() > 0 )  // number of child nodes 
				{
					if( node != null )
						node.lastToken.next = null;  // prevent OutOfMemoryError
					node = (SimpleNode)(get_jjtree().rootNode());
					if(DEBUG)
						node.dump(">");
                    Object ret = node.accept(evaluator);
					node.lastToken.next = null;  // prevent OutOfMemoryError
				
					// sanity check during development
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							"Callstack growing: "+callstack);
					if(ret instanceof ReturnControl)
						ret = ((ReturnControl)ret).value;
					if( ret != Primitive.VOID )
					{
						setu("$_", ret);
						if ( showResults )
							println("<" + ret + ">");
					}
				}
			}
			catch(ParseException e)
			{
				error("Parser Error: " + e.getMessage());
				if ( DEBUG )
					e.printStackTrace();
				if(!interactive)
					eof = true;
				parser.reInitInput(in);
			}
			catch(InterpreterError e)
			{
				error("Internal Error: " + e.getMessage());
				e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(TargetError e)
			{
				error("// Uncaught Exception: " + e );
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, err );
				if(!interactive)
					eof = true;
				setu("$_e", e.getTarget());
			}
			catch (EvalError e)
			{
				if ( interactive )
					error( "EvalError: "+e.getMessage() );
				else
					error( "EvalError: "+e.getRawMessage() );
				if(DEBUG)
					e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(Exception e)
			{
				error("Unknown error: " + e);
				if ( DEBUG )
					e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(TokenMgrError e)
			{
				error("Error parsing input: " + e);
				/*
					We get stuck in infinite loops here when unicode escapes
					fail.  Must re-init the char stream reader 
					(ASCII_UCodeESC_CharStream.java)
				*/
				parser.reInitTokenInput( in );
				if(!interactive)
					eof = true;
			}
			finally
			{
				get_jjtree().reset();
				// reinit the callstack
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( globalNameSpace );
				}
			}
		}
		if ( interactive && exitOnEOF )
			System.exit(0);
	}
	// begin source and eval
	/**
		Read text from fileName and eval it.
	*/
	public Object source( String filename, NameSpace nameSpace ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		File file = pathToFile( filename );
		if ( Interpreter.DEBUG ) debug("Sourcing file: "+file);
		Reader sourceIn = new BufferedReader( new FileReader(file) );
		try {
			return eval( sourceIn, nameSpace, filename );
		} finally {
			sourceIn.close();
		}
	}
	/**
		Read text from fileName and eval it.
		Convenience method.  Use the global namespace.
	*/
	public Object source( String filename ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		return source( filename, globalNameSpace );
	}
	/**
		Spawn a non-interactive local interpreter to evaluate text in the 
		specified namespace.  
		Return value is the evaluated object (or corresponding primitive 
		wrapper).
		@param sourceFileInfo is for information purposes only.  It is used to
		display error messages (and in the future may be made available to
		the script).
		@throws EvalError on script problems
		@throws TargetError on unhandled exceptions from the script
	*/
	/*
		Note: we need a form of eval that passes the callstack through...
	*/
	/*
	Can't this be combined with run() ?
	run seems to have stuff in it for interactive vs. non-interactive...
	compare them side by side and see what they do differently, aside from the
	exception handling.
	*/
	public Object eval( 
		Reader in, NameSpace nameSpace, String sourceFileInfo
			/*, CallStack callstack */ ) 
		throws EvalError 
	{
		Object retVal = null;
		if ( Interpreter.DEBUG ) debug("eval: nameSpace = "+nameSpace);
		/* 
			Create non-interactive local interpreter for this namespace
			with source from the input stream and out/err same as 
			this interpreter.
		*/
		Interpreter localInterpreter = 
			new Interpreter( 
				in, out, err, false, nameSpace, this, sourceFileInfo  );
		CallStack callstack = new CallStack( nameSpace );
        BshEvaluatingVisitor evaluator = new BshEvaluatingVisitor(callstack, localInterpreter);
        SimpleNode node = null;
		boolean eof = false;
		while(!eof)
		{
			try
			{
				eof = localInterpreter.Line();
				if (localInterpreter.get_jjtree().nodeArity() > 0)
				{
					if( node != null )
						node.lastToken.next = null;  // prevent OutOfMemoryError
					node = (SimpleNode)localInterpreter.get_jjtree().rootNode();
					// nodes remember from where they were sourced
					node.setSourceFile( sourceFileInfo );
					if ( TRACE )
						println( "// " +node.getText() );
                    retVal = node.accept(evaluator);
					// sanity check during development
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							"Callstack growing: "+callstack);
					if ( retVal instanceof ReturnControl ) {
						retVal = ((ReturnControl)retVal).value;
						break; // non-interactive, return control now
					}
					if ( localInterpreter.showResults 
						&& retVal != Primitive.VOID )
						println("<" + retVal + ">");
				}
			} catch(ParseException e) {
				/*
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" parser Error: " 
					+ e.getMessage( DEBUG ), node, callstack );
				*/
				if ( DEBUG )
					// show extra "expecting..." info
					error( e.getMessage() );
				// add the source file info and throw again
				//e.setErrorSourceFile( sourceFileInfo );
				throw new EvalError("Error:", node, callstack, e);
			} catch ( InterpreterError e ) {
				e.printStackTrace();
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" internal Error: " 
					+ e.getMessage(), node, callstack);
			} catch ( TargetError e ) {
				// failsafe, set the Line as the origin of the error.
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow("Sourced file: "+sourceFileInfo);
			} catch ( EvalError e) {
				if ( DEBUG)
					e.printStackTrace();
				// failsafe, set the Line as the origin of the error.
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow( "Sourced file: "+sourceFileInfo );
			} catch ( Exception e) {
				if ( DEBUG)
					e.printStackTrace();
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" unknown error: " 
					+ e.getMessage(), node, callstack, e);
			} catch(TokenMgrError e) {
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" Token Parsing Error: " 
					+ e.getMessage(), node, callstack, e );
			} finally {
				localInterpreter.get_jjtree().reset();
				// reinit the callstack
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( nameSpace );
				}
			}
		}
		return Primitive.unwrap( retVal );
	}
	/**
		Evaluate the inputstream in this interpreter's global namespace.
	*/
	public Object eval( Reader in ) throws EvalError 
	{
		return eval( in, globalNameSpace, "eval stream" );
	}
	/**
		Evaluate the string in this interpreter's global namespace.
	*/
	public Object eval( String statements ) throws EvalError {
		if ( Interpreter.DEBUG ) debug("eval(String): "+statements);
		return eval(statements, globalNameSpace);
	}
	/**
		Evaluate the string in the specified namespace.
	*/
	public Object eval( String statements, NameSpace nameSpace ) 
		throws EvalError 
	{
		String s = ( statements.endsWith(";") ? statements : statements+";" );
		return eval( 
			new StringReader(s), nameSpace, 
			"inline evaluation of: ``"+ showEvalString(s)+"''" );
	}
	private String showEvalString( String s ) {
		s = s.replace('\n', ' ');
		s = s.replace('\r', ' ');
		if ( s.length() > 80 )
			s = s.substring( 0, 80 ) + " . . . ";
		return s;
	}
	// end source and eval
	/**
		Print an error message in a standard format on the output stream
		associated with this interpreter. On the GUI console this will appear 
		in red, etc.
	*/
	public final void error( Object o ) {
		if ( console != null )
				console.error( "// Error: " + o +"\n" );
		else {
			err.println("// Error: " + o );
			err.flush();
		}
	}
	// ConsoleInterface
	// The interpreter reflexively implements the console interface that it 
	// uses.  Should clean this up by using an inner class to implement the
	// console for us.
	/** 
		Get the input stream associated with this interpreter.
		This may be be stdin or the GUI console.
	*/
	public Reader getIn() { return in; }
	/** 
		Get the outptut stream associated with this interpreter.
		This may be be stdout or the GUI console.
	*/
	public PrintStream getOut() { return out; }
	/** 
		Get the error output stream associated with this interpreter.
		This may be be stderr or the GUI console.
	*/
	public PrintStream getErr() { return err; }
	public final void println( Object o )
	{
		print( String.valueOf(o) + systemLineSeparator );
	}
	public final void print( Object o )
	{
		if (console != null) {
			console.print(o);
		} else {
			out.print(o);
			out.flush();
		}
	}
	// End ConsoleInterface
	/**
		Print a debug message on debug stream associated with this interpreter
		only if debugging is turned on.
	*/
	public final static void debug(String s)
	{
		if ( DEBUG )
			debug.println("// Debug: " + s);
	}
	/* 
		Primary interpreter set and get variable methods
		Note: These are squeltching errors... should they?
	*/
	/**
		Get the value of the name.
		name may be any value. e.g. a variable or field
	*/
	public Object get( String name ) throws EvalError {
		try {
			Object ret = globalNameSpace.get( name, this );
			return Primitive.unwrap( ret );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() ); 
		}
	}
	/**
		Unchecked get for internal use
	*/
	Object getu( String name ) {
		try { 
			return get( name );
		} catch ( EvalError e ) { 
			throw new InterpreterError("set: "+e);
		}
	}
	/**
		Assign the value to the name.	
		name may evaluate to anything assignable. e.g. a variable or field.
	*/
	public void set( String name, Object value )
		throws EvalError 
	{
		// map null to Primtive.NULL coming in...
		if ( value == null )
			value = Primitive.NULL;
		CallStack callstack = new CallStack();
		try {
			if ( Name.isCompound( name ) ) 
			{
				LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( new BshEvaluatingVisitor(callstack,  this)	);
				lhs.assign( value, false );
			} else // optimization for common case
				globalNameSpace.setVariable( name, value, false );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
		}
	}
	/**
		Unchecked set for internal use
	*/
	void setu(String name, Object value) {
		try { 
			set(name, value);
		} catch ( EvalError e ) { 
			throw new InterpreterError("set: "+e);
		}
	}
	public void set(String name, long value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, int value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, double value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, float value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, boolean value) throws EvalError {
		set(name, new Primitive(value));
	}
	/**
		Unassign the variable name.	
		Name should evaluate to a variable.
	*/
	public void unset( String name ) 
		throws EvalError 
	{
		/*
			We jump through some hoops here to handle arbitrary cases like
			unset("bsh.foo");
		*/
		CallStack callstack = new CallStack();
		try {
			LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( 
				new BshEvaluatingVisitor(callstack, this) );
			if ( lhs.type != LHS.VARIABLE )
				throw new EvalError("Can't unset, not a variable: "+name, 
					SimpleNode.JAVACODE, new CallStack() );
			//lhs.assign( null, false );
			lhs.nameSpace.unsetVariable( name );
		} catch ( UtilEvalError e ) {
			throw new EvalError( e.getMessage(), 
				SimpleNode.JAVACODE, new CallStack() );
		}
	}
	// end primary set and get methods
	/**
		Get a reference to the interpreter (global namespace), cast 
		to the specified interface type.  Assuming the appropriate 
		methods of the interface are defined in the interpreter, then you may 
		use this interface from Java, just like any other Java object.
		<p>
		For example:
		<pre>
			Interpreter interpreter = new Interpreter();
			// define a method called run()
			interpreter.eval("run() { ... }");
		
			// Fetch a reference to the interpreter as a Runnable
			Runnable runnable = 
				(Runnable)interpreter.getInterface( Runnable.class );
		</pre>
		<p>
		Note that the interpreter does *not* require that any or all of the
		methods of the interface be defined at the time the interface is
		generated.  However if you attempt to invoke one that is not defined
		you will get a runtime exception.
		<p>
		Note also that this convenience method has exactly the same effect as 
		evaluating the script:
		<pre>
			(Type)this;
		</pre>
		<p>
		For example, the following is identical to the previous example:
		<p>
		<pre>
			// Fetch a reference to the interpreter as a Runnable
			Runnable runnable = 
				(Runnable)interpreter.eval( "(Runnable)this" );
		</pre>
		<p>
		<em>Version requirement</em> Although standard Java interface types 
		are always available, to be used with arbitrary interfaces this 
		feature requires that you are using Java 1.3 or greater.
		<p>
		@throws EvalError if the interface cannot be generated because the
		version of Java does not support the proxy mechanism. 
	*/
	public Object getInterface( Class interf ) throws EvalError
	{
		return globalNameSpace.getThis( this ).getInterface( interf );
	}
	/*	Methods for interacting with Parser */
	private JJTParserState get_jjtree() {
		return parser.jjtree;
	}
	private JavaCharStream get_jj_input_stream() {
		return parser.jj_input_stream;
	}
	private boolean Line() throws ParseException {
		return parser.Line();
	}
	/*	End methods for interacting with Parser */
	void loadRCFiles() {
		try {
			String rcfile = 
				// Default is c:\windows under win98, $HOME under Unix
				System.getProperty("user.home") + File.separator + ".bshrc";
			source( rcfile, globalNameSpace );
		} catch ( Exception e ) { 
			// squeltch security exception, filenotfoundexception
			if ( Interpreter.DEBUG ) debug("Could not find rc file: "+e);
		}
	}
	/**
		Localize a path to the file name based on the bsh.cwd interpreter 
		working directory.
	*/
	public File pathToFile( String fileName ) 
		throws IOException
	{
		File file = new File( fileName );
		// if relative, fix up to bsh.cwd
		if ( !file.isAbsolute() ) {
			String cwd = (String)getu("bsh.cwd");
			file = new File( cwd + File.separator + fileName );
		}
		// The canonical file name is also absolute.
		// No need for getAbsolutePath() here...
		return new File( file.getCanonicalPath() );
	}
	public static void redirectOutputToFile( String filename ) 
	{
		try {
			PrintStream pout = new PrintStream( 
				new FileOutputStream( filename ) );
			System.setOut( pout );
			System.setErr( pout );
		} catch ( IOException e ) {
			System.err.println("Can't redirect output to file: "+filename );
		}
	}
	/**
		Set an external class loader to be used as the base classloader
		for BeanShell.  The base classloader is used for all classloading 
		unless/until the addClasspath()/setClasspath()/reloadClasses()  
		commands are called to modify the interpreter's classpath.  At that 
		time the new paths /updated paths are added on top of the base 
		classloader.
		<p>
		BeanShell will use this at the same point it would otherwise use the 
		plain Class.forName().
		i.e. if no explicit classpath management is done from the script
		(addClassPath(), setClassPath(), reloadClasses()) then BeanShell will
		only use the supplied classloader.  If additional classpath management
		is done then BeanShell will perform that in addition to the supplied
		external classloader.  
		However BeanShell is not currently able to reload
		classes supplied through the external classloader.
		<p>
		@see BshClassManager#setClassLoader( ClassLoader )
	*/
	public void setClassLoader( ClassLoader externalCL ) {
		getClassManager().setClassLoader( externalCL );
	}
	/**
		Get the class manager associated with this interpreter
		(the BshClassManager of this interpreter's global namespace).
		This is primarily a convenience method.
	*/
	public BshClassManager getClassManager() 
	{
		return getNameSpace().getClassManager();
	}
	
	/**
		Set strict Java mode on or off.  
		This mode attempts to make BeanShell syntax behave as Java
		syntax, eliminating conveniences like loose variables, etc.
		When enabled, variables are required to be declared or initialized 
		before use and method arguments are reqired to have types. 
		<p>
		This mode will become more strict in a future release when 
		classes are interpreted and there is an alternative to scripting
		objects as method closures.
	*/
	public void setStrictJava( boolean b ) { 
		this.strictJava = b; 
	}
	/**
		@see #setStrictJava( boolean )
	*/
	public boolean getStrictJava() { 
		return this.strictJava;
	}
	static void staticInit() 
	{
	/* 
		Apparently in some environments you can't catch the security exception
		at all...  e.g. as an applet in IE  ... will probably have to work 
		around 
	*/
		try {
			systemLineSeparator = System.getProperty("line.separator");
			debug = System.err;
			DEBUG = Boolean.getBoolean("debug");
			TRACE = Boolean.getBoolean("trace");
			LOCALSCOPING = Boolean.getBoolean("localscoping");
			String outfilename = System.getProperty("outfile");
			if ( outfilename != null )
				redirectOutputToFile( outfilename );
		} catch ( SecurityException e ) { 
			System.err.println("Could not init static:"+e);
		} catch ( Exception e ) {
			System.err.println("Could not init static(2):"+e);
		} catch ( Throwable e ) { 
			System.err.println("Could not init static(3):"+e);
		}
	}
	/**
		Specify the source of the text from which this interpreter is reading.
		Note: there is a difference between what file the interrpeter is 
		sourcing and from what file a method was originally parsed.  One
		file may call a method sourced from another file.  See SimpleNode
		for origination file info.
		@see bsh.ast.SimpleNode#getSourceFile()
	*/
	public String getSourceFileInfo() { 
		if ( sourceFileInfo != null )
			return sourceFileInfo;
		else
			return "<unknown source>";
	}
	/**
		Get the parent Interpreter of this interpreter, if any.
		Currently this relationship implies the following:
			1) Parent and child share a BshClassManager
			2) Children indicate the parent's source file information in error
			reporting.
		When created as part of a source() / eval() the child also shares
		the parent's namespace.  But that is not necessary in general.
	*/
	public Interpreter getParent() {
		return parent;
	}
	public void setOut( PrintStream out ) {
		this.out = out;
	}
	public void setErr( PrintStream err ) {
		this.err = err;
	}
	/**
		De-serialization setup.
		Default out and err streams to stdout, stderr if they are null.
	*/
	private void readObject(ObjectInputStream stream) 
		throws java.io.IOException, ClassNotFoundException
	{
		stream.defaultReadObject();
		// set transient fields
		if ( console != null ) {
			setOut( console.getOut() );
			setErr( console.getErr() );
		} else {
			setOut( System.out );
			setErr( System.err );
		}
	}
	/**
		Get the prompt string defined by the getBshPrompt() method in the
		global namespace.  This may be from the getBshPrompt() command or may
		be defined by the user as with any other method.
		Defaults to "bsh % " if the method is not defined or there is an error.
	*/
	private String getBshPrompt() 
	{
		try {
			return (String)eval("getBshPrompt()");
		} catch ( Exception e ) {
			return "bsh % ";
		}
	}
	/**
		Specify whether, in interactive mode, the interpreter exits Java upon
		end of input.  If true, when in interactive mode the interpreter will
		issue a System.exit(0) upon eof.  If false the interpreter no
		System.exit() will be done.
		<p/>
		Note: if you wish to cause an EOF externally you can try closing the
		input stream.  This is not guaranteed to work in older versions of Java
		due to Java limitations, but should work in newer JDK/JREs.  (That was
		the motivation for the Java NIO package).
	*/
	public void setExitOnEOF( boolean value ) {
		exitOnEOF = value; // ug
	}
	/**
		Turn on/off the verbose printing of results as for the show()
		 command.
		If this interpreter has a parent the call is delegated.
		See the BeanShell show() command.
	*/
	public void setShowResults( boolean showResults ) {
		this.showResults = showResults;
	}
	/**
	 Show on/off verbose printing status for the show() command.
	 See the BeanShell show() command.
	 If this interpreter has a parent the call is delegated.
	 */
	public boolean getShowResults()  {
		return showResults;
	}
	public static void setShutdownOnExit(final boolean value) {
		try {
			SYSTEM_OBJECT.getNameSpace().setVariable("shutdownOnExit", Boolean.valueOf(value), false);
		} catch (final UtilEvalError utilEvalError) {
			throw new IllegalStateException(utilEvalError);
		}
	}
}
package bsh;
import bsh.ast.BSHBlock;
import bsh.ast.BSHMethodDeclaration;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
public class BshMethod 
	implements java.io.Serializable 
{
	/* 
		This is the namespace in which the method is set.
		It is a back-reference for the node, which needs to execute under this 
		namespace.  It is not necessary to declare this transient, because 
		we can only be saved as part of our namespace anyway... (currently).
	*/
	NameSpace declaringNameSpace;
	// Begin Method components
	Modifiers modifiers;
	private String name;
	private Class creturnType;
	// Arguments
	private String [] paramNames;
	private int numArgs;
	private Class [] cparamTypes;
	// Scripted method body
	BSHBlock methodBody;
	// Java Method, for a BshObject that delegates to a real Java method
	private Method javaMethod;
	private Object javaObject;
	// End method components
	public BshMethod(
		BSHMethodDeclaration method,
		NameSpace declaringNameSpace, Modifiers modifiers ) 
	{
		this( method.name, method.returnType, method.paramsNode.getParamNames(),
			method.paramsNode.paramTypes, method.blockNode, declaringNameSpace,
			modifiers );
	}
	public BshMethod(
		String name, Class returnType, String [] paramNames,
		Class [] paramTypes, BSHBlock methodBody, 
		NameSpace declaringNameSpace, Modifiers modifiers
	) {
		this.name = name;
		this.creturnType = returnType;
		this.paramNames = paramNames;
		if ( paramNames != null )
			this.numArgs = paramNames.length;
		this.cparamTypes = paramTypes;
		this.methodBody = methodBody;
		this.declaringNameSpace = declaringNameSpace;
		this.modifiers = modifiers;
	}
	/*
		Create a BshMethod that delegates to a real Java method upon invocation.
		This is used to represent imported object methods.
	*/
	public BshMethod( Method method, Object object )
	{
		this( method.getName(), method.getReturnType(), null/*paramNames*/,
			method.getParameterTypes(), null/*method.block*/, 
			null/*declaringNameSpace*/, null/*modifiers*/ );
		this.javaMethod = method;
		this.javaObject = object;
	}
	/**
		Get the argument types of this method.
		loosely typed (untyped) arguments will be represented by null argument
		types.
	*/
	/*
		Note: bshmethod needs to re-evaluate arg types here
		This is broken.
	*/
	public Class [] getParameterTypes() { return cparamTypes; }
	public String [] getParameterNames() { return paramNames; }
	/**
		Get the return type of the method.
		@return Returns null for a loosely typed return value, 
			Void.TYPE for a void return type, or the Class of the type.
	*/
	/*
		Note: bshmethod needs to re-evaluate the method return type here.
		This is broken.
	*/
	public Class getReturnType() { return creturnType; }
	public Modifiers getModifiers() { return modifiers; }
	public String getName() { return name; }
	/**
		Invoke the declared method with the specified arguments and interpreter
		reference.  This is the simplest form of invoke() for BshMethod 
		intended to be used in reflective style access to bsh scripts.
	*/
	public Object invoke( 
		Object[] argValues, BshEvaluatingVisitor visitor )
		throws EvalError 
	{
		return invoke( argValues, visitor, null, false );
	}
	/**
		Invoke the bsh method with the specified args, interpreter ref,
		and callstack.
		callerInfo is the node representing the method invocation
		It is used primarily for debugging in order to provide access to the 
		text of the construct that invoked the method through the namespace.
		@param callerInfo is the BeanShell AST node representing the method 
			invocation.  It is used to print the line number and text of 
			errors in EvalError exceptions.  If the node is null here error
			messages may not be able to point to the precise location and text
			of the error.
		@param visitor is the callstack.  If callstack is null a new one
			will be created with the declaring namespace of the method on top
			of the stack (i.e. it will look for purposes of the method 
			invocation like the method call occurred in the declaring 
			(enclosing) namespace in which the method is defined).
	*/
	public Object invoke( 
		Object[] argValues, BshEvaluatingVisitor visitor,
			SimpleNode callerInfo )
		throws EvalError 
	{
		return invoke( argValues, visitor, callerInfo, false );
	}
	/**
		Invoke the bsh method with the specified args, interpreter ref,
		and callstack.
		callerInfo is the node representing the method invocation
		It is used primarily for debugging in order to provide access to the 
		text of the construct that invoked the method through the namespace.
		@param callerInfo is the BeanShell AST node representing the method 
			invocation.  It is used to print the line number and text of 
			errors in EvalError exceptions.  If the node is null here error
			messages may not be able to point to the precise location and text
			of the error.
		@param visitor is the callstack.  If callstack is null a new one
			will be created with the declaring namespace of the method on top
			of the stack (i.e. it will look for purposes of the method 
			invocation like the method call occurred in the declaring 
			(enclosing) namespace in which the method is defined).
		@param overrideNameSpace 
			When true the method is executed in the namespace on the top of the
			stack instead of creating its own local namespace.  This allows it
			to be used in constructors.
	*/
	public Object invoke(
		Object[] argValues, BshEvaluatingVisitor visitor,
			SimpleNode callerInfo, boolean overrideNameSpace ) 
		throws EvalError 
	{
		if ( argValues != null )
			for (int i=0; i<argValues.length; i++)
				if ( argValues[i] == null )
					throw new Error("HERE!");
		if ( javaMethod != null )
			try {
				return Reflect.invokeMethod(
					javaMethod, javaObject, argValues ); 
			} catch ( ReflectError e ) {
				throw new EvalError(
					"Error invoking Java method: "+e, callerInfo, visitor.getCallstack() );
			} catch ( InvocationTargetException e2 ) {
				throw new TargetError( 
					"Exception invoking imported object method.", 
					e2, callerInfo, visitor.getCallstack(), true/*isNative*/ );
			}
		// is this a syncrhonized method?
		if ( modifiers != null && modifiers.hasModifier("synchronized") )
		{
			// The lock is our declaring namespace's This reference
			// (the method's 'super').  Or in the case of a class it's the
			// class instance.
			Object lock;
			if ( declaringNameSpace.isClass )
			{
				try {
					lock = declaringNameSpace.getClassInstance();
				} catch ( UtilEvalError e ) {
					throw new InterpreterError(
						"Can't get class instance for synchronized method.");
				}
			} else
				lock = declaringNameSpace.getThis(visitor.getInterpreter()); // ???
			synchronized( lock ) 
			{
				return invokeImpl( 
					argValues, visitor,
					callerInfo, overrideNameSpace );
			}
		} else
			return invokeImpl( argValues, visitor, callerInfo,
				overrideNameSpace );
	}
	private Object invokeImpl(
		Object[] argValues, BshEvaluatingVisitor visitor,
			SimpleNode callerInfo, boolean overrideNameSpace ) 
		throws EvalError 
	{
		Class returnType = getReturnType();
		Class [] paramTypes = getParameterTypes();
		// If null callstack
		if ( visitor.getCallstack() == null )
            visitor = new BshEvaluatingVisitor(new CallStack(declaringNameSpace), visitor.getInterpreter());
			//callstack = new CallStack( declaringNameSpace );
		if ( argValues == null )
			argValues = new Object [] { };
		// Cardinality (number of args) mismatch
		if ( argValues.length != numArgs ) 
		{
		/*
			// look for help string
			try {
				// should check for null namespace here
				String help = 
					(String)declaringNameSpace.get(
					"bsh.help."+name, interpreter );
				interpreter.println(help);
				return Primitive.VOID;
			} catch ( Exception e ) {
				throw eval error
			}
		*/
			throw new EvalError( 
				"Wrong number of arguments for local method: " 
				+ name, callerInfo, visitor.getCallstack() );
		}
		// Make the local namespace for the method invocation
		NameSpace localNameSpace;
		if ( overrideNameSpace )
			localNameSpace = visitor.getCallstack().top();
		else
		{
			localNameSpace = new NameSpace( declaringNameSpace, name );
			localNameSpace.isMethod = true;
		}
		// should we do this for both cases above?
		localNameSpace.setNode( callerInfo );
		// set the method parameters in the local namespace
		for(int i=0; i<numArgs; i++)
		{
			// Set typed variable
			if ( paramTypes[i] != null ) 
			{
				try {
					argValues[i] =
						//Types.getAssignableForm( argValues[i], paramTypes[i] );
						Types.castObject( argValues[i], paramTypes[i], Types.ASSIGNMENT );
				}
				catch( UtilEvalError e) {
					throw new EvalError(
						"Invalid argument: " 
						+ "`"+paramNames[i]+"'" + " for method: " 
						+ name + " : " + 
						e.getMessage(), callerInfo, visitor.getCallstack() );
				}
				try {
					localNameSpace.setTypedVariable( paramNames[i], 
						paramTypes[i], argValues[i], null/*modifiers*/);
				} catch ( UtilEvalError e2 ) {
					throw e2.toEvalError( "Typed method parameter assignment", 
						callerInfo, visitor.getCallstack()  );
				}
			} 
			// Set untyped variable
			else  // untyped param
			{
				// getAssignable would catch this for typed param
				if ( argValues[i] == Primitive.VOID)
					throw new EvalError(
						"Undefined variable or class name, parameter: " +
						paramNames[i] + " to method: " 
						+ name, callerInfo, visitor.getCallstack() );
				else
					try {
						localNameSpace.setLocalVariable(
							paramNames[i], argValues[i],
							visitor.getInterpreter().getStrictJava() );
					} catch ( UtilEvalError e3 ) {
						throw e3.toEvalError( callerInfo, visitor.getCallstack() );
					}
			}
		}
		// Push the new namespace on the call stack
		if ( !overrideNameSpace )
			visitor.getCallstack().push( localNameSpace );
		// Invoke the block, overriding namespace with localNameSpace
        Object ret = visitor.evalBlock(methodBody, true);
		// save the callstack including the called method, just for error mess
		CallStack returnStack = visitor.getCallstack().copy();
		// Get back to caller namespace
		if ( !overrideNameSpace )
			visitor.getCallstack().pop();
		ReturnControl retControl = null;
		if ( ret instanceof ReturnControl )
		{
			retControl = (ReturnControl)ret;
			// Method body can only use 'return' statment type return control.
			if ( retControl.kind == retControl.RETURN )
				ret = ((ReturnControl)ret).value;
			else 
				// retControl.returnPoint is the Node of the return statement
				throw new EvalError("'continue' or 'break' in method body", 
					retControl.returnPoint, returnStack );
			// Check for explicit return of value from void method type.
			// retControl.returnPoint is the Node of the return statement
			if ( returnType == Void.TYPE && ret != Primitive.VOID )
				throw new EvalError( "Cannot return value from void method", 
				retControl.returnPoint, returnStack);
		}
		if ( returnType != null )
		{
			// If return type void, return void as the value.
			if ( returnType == Void.TYPE )
				return Primitive.VOID;
			// return type is a class
			try {
				ret =
					// Types.getAssignableForm( ret, (Class)returnType );
					Types.castObject( ret, returnType, Types.ASSIGNMENT );
			} catch( UtilEvalError e )
			{
				// Point to return statement point if we had one.
				// (else it was implicit return? What's the case here?)
				SimpleNode node = callerInfo;
				if ( retControl != null )
					node = retControl.returnPoint;
				throw e.toEvalError(
					"Incorrect type returned from method: " 
					+ name + e.getMessage(), node, visitor.getCallstack() );
			}
		}
		return ret;
	}
	public boolean hasModifier( String name ) {
		return modifiers != null && modifiers.hasModifier(name);
	}
	public String toString() {
		return "Scripted Method: "
			+ StringUtil.methodString( name, getParameterTypes() ); 
	}
	// equal signature
	public boolean equals(Object o) {
		if (o == null) {
			return false;
		}
		if (o == this) {
			return true;
		}
		if (o.getClass() == this.getClass()) {
			BshMethod m = (BshMethod)o;
			if( !name.equals(m.name) || numArgs!=m.numArgs )
				return false;
			for( int i=0; i<numArgs; i++ ) {
				if( !equal(cparamTypes[i],m.cparamTypes[i]) )
					return false;
			}
			return true;
		}
		return false;
	}
	private static boolean equal(Object obj1,Object obj2) {
		return obj1==null ? obj2==null : obj1.equals(obj2);
	}
	@Override
	public int hashCode() {
		int h = name.hashCode();
		for (Class<?> cparamType : cparamTypes) {
			h = h * 31 + cparamType.hashCode();
		}
		return h;
	}
}
package	bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.Serializable;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Field;
/**
    A namespace	in which methods, variables, and imports (class names) live.  
	This is package public because it is used in the implementation of some 
	bsh commands.  However for normal use you should be using methods on 
	bsh.Interpreter to interact with your scripts.
	<p>
	A bsh.This object is a thin layer over a NameSpace that associates it with
	an Interpreter instance.  Together they comprise a Bsh scripted object 
	context.
	<p>
*/
/*
	Thanks to Slava Pestov (of jEdit fame) for import caching enhancements.
	Note: This class has gotten too big.  It should be broken down a bit.
*/
// not at all thread-safe - fschmidt
public class NameSpace implements Serializable, BshClassManager.Listener, NameSource, Cloneable {
	
	private static final long serialVersionUID = 5004976946651004751L;
	public static final NameSpace JAVACODE = 
		new NameSpace((BshClassManager)null, "Called from compiled Java code.");
	static {
		JAVACODE.isMethod = true;
	}
	// Begin instance data
	// Note: if we add something here we should reset it in the clear() method.
	/**
		The name of this namespace.  If the namespace is a method body
		namespace then this is the name of the method.  If it's a class or
		class instance then it's the name of the class.
	*/
	private String nsName; 
    private NameSpace parent;
    private Map<String,Variable> variables;
    private Map<String,List<BshMethod>> methods;
    protected Map<String,String> importedClasses;
    private List<String> importedPackages;
    private List<String> importedCommands;
	private List<Object> importedObjects;
	private List<Class> importedStatic;
	private String packageName;
	transient private BshClassManager classManager;
	// See notes in getThis()
    private This thisReference;
	/** Name resolver objects */
    private Map<String,Name> names;
	/** The node associated with the creation of this namespace.
		This is used support getInvocationLine() and getInvocationText(). */
	SimpleNode callerInfoNode;
	/** 
		Note that the namespace is a method body namespace.  This is used for
		printing stack traces in exceptions.  
	*/
	public boolean isMethod;
	/**
		Note that the namespace is a class body or class instance namespace.  
		This is used for controlling static/object import precedence, etc.
	*/
	/*
		Note: We will ll move this behavior out to a subclass of 
		NameSpace, but we'll start here.
	*/
	public boolean isClass;
	Class classStatic;	
	Object classInstance;
	
	void setClassStatic( Class clas ) {
		this.classStatic = clas;
		importStatic( clas );
	}
	void setClassInstance( Object instance ) {
		this.classInstance = instance;
		importObject( instance );
	}
	Object getClassInstance()
		throws UtilEvalError
	{
		if ( classInstance != null )
			return classInstance;
		if ( classStatic != null 
			//|| ( getParent()!=null && getParent().classStatic != null ) 
		)
			throw new UtilEvalError(
				"Can't refer to class instance from static context.");
		else
			throw new InterpreterError( 
				"Can't resolve class instance 'this' in: "+this);
	}
	/**
		Local class cache for classes resolved through this namespace using 
		getClass() (taking into account imports).  Only unqualified class names
		are cached here (those which might be imported).  Qualified names are 
		always absolute and are cached by BshClassManager.
	*/
    transient private Map<String,Class> classCache;
	// End instance data
	// Begin constructors
	/**
		@parent the parent namespace of this namespace.  Child namespaces
		inherit all variables and methods of their parent and can (of course)
		override / shadow them.
	*/
    public NameSpace( NameSpace parent, String name ) 
	{
		// Note: in this case parent must have a class manager.
		this( parent, null, name );
	}
    public NameSpace( BshClassManager classManager, String name ) 
	{
		this( null, classManager, name );
	}
    public NameSpace( 
		NameSpace parent, BshClassManager classManager, String name ) 
	{
		// We might want to do this here rather than explicitly in Interpreter
		// for global (see also prune())
		//if ( classManager == null && (parent == null ) )
			// create our own class manager?
		setName(name);
		setParent(parent);
		setClassManager( classManager );
		// Register for notification of classloader change
		if ( classManager != null )
			classManager.addListener(this);
    }
	// End constructors
	public void setName( String name ) {
		this.nsName = name;
	}
	/**
		The name of this namespace.  If the namespace is a method body
		namespace then this is the name of the method.  If it's a class or
		class instance then it's the name of the class.
	*/
	public String getName() {
		return this.nsName;
	}
	/**
		Set the node associated with the creation of this namespace.
		This is used in debugging and to support the getInvocationLine()
		and getInvocationText() methods.
	*/
	void setNode( SimpleNode node ) {
		callerInfoNode = node;
	}
	/**
	*/
	SimpleNode getNode() 
	{
		if ( callerInfoNode != null )
			return callerInfoNode;
		if ( parent != null )
			return parent.getNode();
		else
			return null;
	}
	/**
		Resolve name to an object through this namespace.
	*/
	public Object get( String name, Interpreter interpreter ) 
		throws UtilEvalError 
	{
		CallStack callstack = new CallStack( this );
		return getNameResolver( name ).toObject( new BshEvaluatingVisitor(callstack, interpreter) );
	}
	/**
		Set the variable through this namespace.
		This method obeys the LOCALSCOPING property to determine how variables
		are set.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		<p>
		Setting a new variable (which didn't exist before) or removing
		a variable causes a namespace change.
		@param strictJava specifies whether strict java rules are applied.
	*/
    public void	setVariable( String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		// if localscoping switch follow strictJava, else recurse
		boolean recurse = Interpreter.LOCALSCOPING ? strictJava : true;
		setVariable( name, value, strictJava, recurse );
	}
	/**
		Set a variable explicitly in the local scope.
	*/
    void setLocalVariable( 
		String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		setVariable( name, value, strictJava, false/*recurse*/ );
	}
	/**
		Set the value of a the variable 'name' through this namespace.
		The variable may be an existing or non-existing variable.
		It may live in this namespace or in a parent namespace if recurse is 
		true.
		<p>
		Note: This method is not public and does *not* know about LOCALSCOPING.
		Its caller methods must set recurse intelligently in all situations 
		(perhaps based on LOCALSCOPING).
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		<p>
		Setting a new variable (which didn't exist before) or removing
		a variable causes a namespace change.
		@param strictJava specifies whether strict java rules are applied.
		@param recurse determines whether we will search for the variable in
		  our parent's scope before assigning locally.
	*/
    void setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		ensureVariables();
		// primitives should have been wrapped
		if ( value == null )
			throw new InterpreterError("null variable value");
		// Locate the variable definition if it exists.
		Variable existing = getVariableImpl( name, recurse );
		// Found an existing variable here (or above if recurse allowed)
		if ( existing != null )
		{
			try {
				existing.setValue( value, Variable.ASSIGNMENT );
			} catch ( UtilEvalError e ) {
				throw new UtilEvalError(
					"Variable assignment: " + name + ": " + e.getMessage());
			}
		} else 
		// No previous variable definition found here (or above if recurse)
		{
			if ( strictJava )
				throw new UtilEvalError(
					"(Strict Java mode) Assignment to undeclared variable: "
					+name );
			// If recurse, set global untyped var, else set it here.	
			//NameSpace varScope = recurse ? getGlobal() : this;
			// This modification makes default allocation local
			NameSpace varScope = this;
			varScope.variables.put( 
				name, new Variable( name, value, null/*modifiers*/ ) );
			// nameSpaceChanged() on new variable addition
			nameSpaceChanged();
    	}
	}
	private void ensureVariables() {
		if ( variables == null )
			variables =	new HashMap<String,Variable>();
	}
	/**
		Remove the variable from the namespace.
	*/
	public void unsetVariable( String name )
	{
		if ( variables != null )
		{
			variables.remove( name );
			nameSpaceChanged();
		}
	}
	/**
		Get the names of variables defined in this namespace.
		(This does not show variables in parent namespaces).
	*/
	public String [] getVariableNames() {
		if ( variables == null )
			return new String [0];
		else
			return variables.keySet().toArray(new String[0]);
	}
	/**
		Get the names of methods declared in this namespace.
		(This does not include methods in parent namespaces).
	*/
	public String [] getMethodNames() 
	{
		if ( methods == null )
			return new String [0];
		else
			return methods.keySet().toArray(new String[0]);
	}
	/**
		Get the methods defined in this namespace.
		(This does not show methods in parent namespaces).
		Note: This will probably be renamed getDeclaredMethods()
	*/
	public BshMethod [] getMethods() 
	{
		if ( methods == null ) {
			return new BshMethod [0];
		} else {
			List<BshMethod> ret = new ArrayList<BshMethod>();
			for( List<BshMethod> list : methods.values() ) {
				ret.addAll(list);
			}
			return ret.toArray(new BshMethod[0]);
		}
	}
	/**
		Get the parent namespace.
		Note: this isn't quite the same as getSuper().
		getSuper() returns 'this' if we are at the root namespace.
	*/
	public NameSpace getParent() {
		return parent;
	}
	/**
		Get the parent namespace' This reference or this namespace' This
		reference if we are the top.
	*/
    public This getSuper( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getThis( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }
	/**
		Get the top level namespace or this namespace if we are the top.
		Note: this method should probably return type bsh.This to be consistent
		with getThis();
	*/
    public This getGlobal( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getGlobal( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }
	
	/**
		A This object is a thin layer over a namespace, comprising a bsh object
		context.  It handles things like the interface types the bsh object
		supports and aspects of method invocation on it.  
		<p>
		The declaringInterpreter is here to support callbacks from Java through
		generated proxies.  The scripted object "remembers" who created it for
		things like printing messages and other per-interpreter phenomenon
		when called externally from Java.
	*/
	/*
		Note: we need a singleton here so that things like 'this == this' work
		(and probably a good idea for speed).
		Caching a single instance here seems technically incorrect,
		considering the declaringInterpreter could be different under some
		circumstances.  (Case: a child interpreter running a source() / eval() 
		command ).  However the effect is just that the main interpreter that
		executes your script should be the one involved in call-backs from Java.
		I do not know if there are corner cases where a child interpreter would
		be the first to use a This reference in a namespace or if that would
		even cause any problems if it did...  We could do some experiments
		to find out... and if necessary we could cache on a per interpreter
		basis if we had weak references...  We might also look at skipping 
		over child interpreters and going to the parent for the declaring 
		interpreter, so we'd be sure to get the top interpreter.
	*/
    public This getThis( Interpreter declaringInterpreter ) 
	{
		if ( thisReference == null )
			thisReference = This.getThis( this, declaringInterpreter );
		return thisReference;
    }
	public BshClassManager getClassManager() 
	{
		if ( classManager != null )
			return classManager;
		if ( parent != null && parent != JAVACODE )
			return parent.getClassManager();
		classManager = BshClassManager.createClassManager( null/*interp*/ );
		
		//Interpreter.debug("No class manager namespace:" +this);
		return classManager;
	}
	void setClassManager( BshClassManager classManager ) {
		this.classManager = classManager;
	}
	/**
		Used for serialization
	*/
	public void prune() 
	{
		// Cut off from parent, we must have our own class manager.
		// Can't do this in the run() command (needs to resolve stuff)
		// Should we do it by default when we create a namespace will no
		// parent of class manager?
		if ( this.classManager == null )
// XXX if we keep the createClassManager in getClassManager then we can axe
// this?
			setClassManager( 
				BshClassManager.createClassManager( null/*interp*/ ) );
		setParent( null );
	}
	public void setParent( NameSpace parent ) 
	{
		this.parent = parent;
		// If we are disconnected from root we need to handle the def imports
		if ( parent == null )
			loadDefaultImports();
	}
	/**
		Get the specified variable in this namespace or a parent namespace.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to use 
		Primitive.unwrap() to get primitive values.
		@see Primitive#unwrap( Object )
		@return The variable value or Primitive.VOID if it is not defined.
	*/
    public Object getVariable( String name ) 
		throws UtilEvalError
	{
		return getVariable( name, true );
	}
	/**
		Get the specified variable in this namespace.
		@param recurse If recurse is true then we recursively search through 
		parent namespaces for the variable.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to use 
		Primitive.unwrap() to get primitive values.
		@see Primitive#unwrap( Object )
		@return The variable value or Primitive.VOID if it is not defined.
	*/
    public Object getVariable( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = getVariableImpl( name, recurse );
		return unwrapVariable( var );
    }
	/**
		Locate a variable and return the Variable object with optional 
		recursion through parent name spaces.
		<p/>
		If this namespace is static, return only static variables.
		@return the Variable value or null if it is not defined
	*/
    protected Variable getVariableImpl( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = null;
		// Change import precedence if we are a class body/instance
		// Get imported first.
		if ( var == null && isClass )
			var = getImportedVar( name );
		if ( var == null && variables != null )
			var	= (Variable)variables.get(name);
		// Change import precedence if we are a class body/instance
		if ( var == null && !isClass )
			var = getImportedVar( name );
		// try parent
		if ( recurse && (var == null) && (parent != null) )
			var	= parent.getVariableImpl( name, recurse );
		return var;
    }
	
	/*
		Get variables declared in this namespace.
	*/
	public Variable [] getDeclaredVariables() 
	{
		if ( variables == null )
			return new Variable[0];
		return variables.values().toArray(new Variable[0]);
	}
	/**
		Unwrap a variable to its value.
		@return return the variable value.  A null var is mapped to 
			Primitive.VOID
	*/
	protected Object unwrapVariable( Variable var ) 
		throws UtilEvalError
	{
		return (var == null) ? Primitive.VOID :	var.getValue();
	}
	/**
		@deprecated See #setTypedVariable( String, Class, Object, Modifiers )
	*/
    public void	setTypedVariable(
		String	name, Class type, Object value,	boolean	isFinal )
		throws UtilEvalError 
	{
		Modifiers modifiers = new Modifiers();
		if ( isFinal )
			modifiers.addModifier( Modifiers.FIELD, "final" );
		setTypedVariable( name, type, value, modifiers );
	}
    /**
		Declare a variable in the local scope and set its initial value.
		Value may be null to indicate that we would like the default value 
		for the variable type. (e.g.  0 for integer types, null for object 
		types).  An existing typed variable may only be set to the same type.
		If an untyped variable of the same name exists it will be overridden 
		with the new typed var.
		The set will perform a Types.getAssignableForm() on the value if 
		necessary.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		@param value If value is null, you'll get the default value for the type
		@param modifiers may be null
    */
    public void	setTypedVariable(
		String	name, Class type, Object value,	Modifiers modifiers )
		throws UtilEvalError 
	{
		//checkVariableModifiers( name, modifiers );
		ensureVariables();
		// Setting a typed variable is always a local operation.
		Variable existing = getVariableImpl( name, false/*recurse*/ );
		// Null value is just a declaration
		// Note: we might want to keep any existing value here instead of reset
	/*
	// Moved to Variable
		if ( value == null )
			value = Primitive.getDefaultValue( type );
	*/
		// does the variable already exist?
		if ( existing != null ) 
		{
			// Is it typed?
			if ( existing.getType() != null ) 
			{
				// If it had a different type throw error.
				// This allows declaring the same var again, but not with
				// a different (even if assignable) type.
				if ( existing.getType() != type )
				{
					throw new UtilEvalError( "Typed variable: "+name
						+" was previously declared with type: " 
						+ existing.getType() );
				} else 
				{
					// else set it and return
					existing.setValue( value, Variable.DECLARATION );
					return;
				}
			}
			// Careful here:
			// else fall through to override and install the new typed version
		} 
		// Add the new typed var
		variables.put( name, new Variable( name, type, value, modifiers ) );
    }
	/**
		Dissallow static vars outside of a class
		@param name is here just to allow the error message to use it
	protected void checkVariableModifiers( String name, Modifiers modifiers )
		throws UtilEvalError
	{
		if ( modifiers!=null && modifiers.hasModifier("static") )
			throw new UtilEvalError(
				"Can't declare static variable outside of class: "+name );
	}
	*/
	/**
		Note: this is primarily for internal use.
		@see Interpreter#source( String )
		@see Interpreter#eval( String )
	*/
    public void	setMethod( BshMethod method )
		throws UtilEvalError
	{
		//checkMethodModifiers( method );
		if ( methods == null )
			methods = new HashMap<String,List<BshMethod>>();
		String name = method.getName();
		List<BshMethod> list = methods.get(name);
		if ( list == null ) {
			methods.put(name, Collections.singletonList(method));
		} else {
			if( !(list instanceof ArrayList) ) {
				list = new ArrayList<BshMethod>(list);
				methods.put( name, list );
			}
			list.remove(method);
			list.add( method );
		}
    }
	/**
		see #getMethod( String, Class [], boolean )
		see #getMethod( String, Class [] )
	*/
    public BshMethod getMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		return getMethod( name, sig, false/*declaredOnly*/ );
	}
	/**
		Get the bsh method matching the specified signature declared in 
		this name space or a parent.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to be familiar
		with BeanShell's use of the Primitive wrapper class.
		@see bsh.Primitive
		@return the BshMethod or null if not found
		@param declaredOnly if true then only methods declared directly in this
			namespace will be found and no inherited or imported methods will
			be visible.
	*/
    public BshMethod getMethod( 
		String name, Class [] sig, boolean declaredOnly ) 
		throws UtilEvalError
	{
		BshMethod method = null;
		// Change import precedence if we are a class body/instance
		// Get import first.
		if ( method == null && isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		if ( method == null && methods != null )
		{
			List<BshMethod> list = methods.get(name);
			if ( list != null ) 
			{
				// Apply most specific signature matching
				Class [][] candidates = new Class[ list.size() ][];
				for( int i=0; i< candidates.length; i++ )
					candidates[i] = list.get(i).getParameterTypes();
				int match = 
					Reflect.findMostSpecificSignature( sig, candidates );
				if ( match != -1 )
					method = list.get(match);
			}
		}
		if ( method == null && !isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		
		// try parent
		if ( !declaredOnly && (method == null) && (parent != null) )
			return parent.getMethod( name, sig );
		return method;
    }
	/**
		Import a class name.
		Subsequent imports override earlier ones
	*/
    public void	importClass(String name)
    {
		if ( importedClasses == null )
			importedClasses = new HashMap<String,String>();
		importedClasses.put( Name.suffix(name, 1), name );
		nameSpaceChanged();
    }
	/**
		subsequent imports override earlier ones
	*/
    public void	importPackage(String name)
    {
		if(importedPackages == null)
			importedPackages = new ArrayList<String>();
		// If it exists, remove it and add it at the end (avoid memory leak)
		importedPackages.remove( name );
		importedPackages.add(name);
		nameSpaceChanged();
    }
	/**
		Import scripted or compiled BeanShell commands in the following package
		in the classpath.  You may use either "/" path or "." package notation.
		e.g. importCommands("/bsh/commands") or importCommands("bsh.commands")
		are equivalent.  If a relative path style specifier is used then it is
		made into an absolute path by prepending "/".
	*/
    public void	importCommands( String name )
    {
		if ( importedCommands == null )
			importedCommands = new ArrayList<String>();
		// dots to slashes
		name = name.replace('.','/');
		// absolute
		if ( !name.startsWith("/") )
			name = "/"+name;
		// remove trailing (but preserve case of simple "/")
		if ( name.length() > 1 && name.endsWith("/") )
			name = name.substring( 0, name.length()-1 );
		// If it exists, remove it and add it at the end (avoid memory leak)
		importedCommands.remove( name );
		importedCommands.add(name);
		nameSpaceChanged();
    }
	/**
		A command is a scripted method or compiled command class implementing a 
		specified method signature.  Commands are loaded from the classpath
		and may be imported using the importCommands() method.
		<p/>
		This method searches the imported commands packages for a script or
		command object corresponding to the name of the method.  If it is a
		script the script is sourced into this namespace and the BshMethod for
		the requested signature is returned.  If it is a compiled class the
		class is returned.  (Compiled command classes implement static invoke()
		methods).
		<p/>
		The imported packages are searched in reverse order, so that later
		imports take priority.
		Currently only the first object (script or class) with the appropriate
		name is checked.  If another, overloaded form, is located in another
		package it will not currently be found.  This could be fixed.
		<p/>
		@return a BshMethod, Class, or null if no such command is found.
		@param name is the name of the desired command method
		@param argTypes is the signature of the desired command method.
		@throws UtilEvalError if loadScriptedCommand throws UtilEvalError
			i.e. on errors loading a script that was found
	*/
	public Object getCommand( 	
		String name, Class [] argTypes, Interpreter interpreter ) 
		throws UtilEvalError
	{
		if (Interpreter.DEBUG) Interpreter.debug("getCommand: "+name);
		BshClassManager bcm = interpreter.getClassManager();
		if ( importedCommands != null )
		{
			// loop backwards for precedence
			for(int i=importedCommands.size()-1; i>=0; i--)
			{
				String path = importedCommands.get(i);
				String scriptPath; 
				if ( path.equals("/") )
					scriptPath = path + name +".bsh";
				else
					scriptPath = path +"/"+ name +".bsh";
				Interpreter.debug("searching for script: "+scriptPath );
        		InputStream in = bcm.getResourceAsStream( scriptPath );
				if ( in != null )
					return loadScriptedCommand( 
						in, name, argTypes, scriptPath, interpreter );
				// Chop leading "/" and change "/" to "."
				String className;
				if ( path.equals("/") )
					className = name;
				else
					className = path.substring(1).replace('/','.') +"."+name;
				Interpreter.debug("searching for class: "+className);
        		Class clas = bcm.classForName( className );
				if ( clas != null )
					return clas;
			}
		}
		if ( parent != null )
			return parent.getCommand( name, argTypes, interpreter );
		else
			return null;
	}
	protected BshMethod getImportedMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		// Try object imports
		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.get(i);
			Class clas = object.getClass();
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, false/*onlyStatic*/ );
			if ( method != null )
				return new BshMethod( method, object );
		}
		// Try static imports
		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = importedStatic.get(i);
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, true/*onlyStatic*/ );
			if ( method != null )
				return new BshMethod( method, null/*object*/ );
		}
		return null;
	}
	protected Variable getImportedVar( String name ) 
		throws UtilEvalError
	{
		// Try object imports
		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.get(i);
			Class clas = object.getClass();
			Field field = Reflect.resolveJavaField( 
				clas, name, false/*onlyStatic*/ );
			if ( field != null )
				return new Variable( 
					name, field.getType(), new LHS( object, field ) );
		}
		// Try static imports
		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = importedStatic.get(i);
			Field field = Reflect.resolveJavaField( 
				clas, name, true/*onlyStatic*/ );
			if ( field != null )
				return new Variable( name, field.getType(), new LHS( field ) );
		}
		return null;
	}
	/**
		Load a command script from the input stream and find the BshMethod in
		the target namespace.
		@throws UtilEvalError on error in parsing the script or if the the
			method is not found after parsing the script.
	*/
	/*
		If we want to support multiple commands in the command path we need to
		change this to not throw the exception.
	*/
	private BshMethod loadScriptedCommand( 
		InputStream in, String name, Class [] argTypes, String resourcePath, 
		Interpreter interpreter )
		throws UtilEvalError
	{
		try {
			interpreter.eval( 
				new InputStreamReader(in), this, resourcePath );
		} catch ( EvalError e ) {
		/* 
			Here we catch any EvalError from the interpreter because we are
			using it as a tool to load the command, not as part of the
			execution path.
		*/
			Interpreter.debug( e.toString() );
			throw new UtilEvalError( 
				"Error loading script: "+ e.getMessage(), e);
		}
		// Look for the loaded command 
		BshMethod meth = getMethod( name, argTypes );
		/*
		if ( meth == null )
			throw new UtilEvalError("Loaded resource: " + resourcePath +
				"had an error or did not contain the correct method" );
		*/
		return meth;
	}
	/**
		Helper that caches class.
	*/
	void cacheClass( String name, Class c ) {
		if ( classCache == null ) {
			classCache = new HashMap<String,Class>();
			//cacheCount++; // debug
		}
		classCache.put(name, c);
	}
	/**
		Load a class through this namespace taking into account imports.
		The class search will proceed through the parent namespaces if
		necessary.
		@return null if not found.
	*/
    public Class getClass( String name )
		throws UtilEvalError
    {
		Class c = getClassImpl(name);
		if ( c != null )
			return c;
		else
			// implement the recursion for getClassImpl()
			if ( parent != null )
				return parent.getClass( name );
			else
				return null;
	}
	/**
		Implementation of getClass() 
		Load a class through this namespace taking into account imports.
		<p>
		Check the cache first.  If an unqualified name look for imported 
		class or package.  Else try to load absolute name.
		<p>
		This method implements caching of unqualified names (normally imports).
		Qualified names are cached by the BshClassManager.
		Unqualified absolute class names (e.g. unpackaged Foo) are cached too
		so that we don't go searching through the imports for them each time.
		@return null if not found.
	*/
    private Class getClassImpl( String name )
		throws UtilEvalError
    {
		Class c = null;
		// Check the cache
		if (classCache != null) {
			c =	classCache.get(name);
			if ( c != null )
				return c;
		}
		// Unqualified (simple, non-compound) name
		boolean unqualifiedName = !Name.isCompound(name);
		// Unqualified name check imported
		if ( unqualifiedName ) 
		{
			// Try imported class
			if ( c == null )
				c = getImportedClassImpl( name );
			// if found as imported also cache it
			if ( c != null ) {
				cacheClass( name, c );
				return c;
			}
		}
		// Try absolute
		c = classForName( name );
		if ( c != null ) {
			// Cache unqualified names to prevent import check again
			if ( unqualifiedName )
				cacheClass( name, c );
			return c;
		}
		// Not found
		if ( Interpreter.DEBUG ) 
			Interpreter.debug("getClass(): " + name	+ " not	found in "+this);
		return null;
    }
	/**
		Try to make the name into an imported class.
		This method takes into account only imports (class or package)
		found directly in this NameSpace (no parent chain).
	*/
    private Class getImportedClassImpl( String name )
		throws UtilEvalError
    {
		// Try explicitly imported class, e.g. import foo.Bar;
		String fullname = null;
		if ( importedClasses != null )
			fullname = importedClasses.get(name);
		
		// not sure if we should really recurse here for explicitly imported
		// class in parent...  
		if ( fullname != null ) 
		{
			/*
				Found the full name in imported classes.
			*/
			// Try to make the full imported name
			Class clas = classForName(fullname);
			
			if ( clas != null )
				return clas;
			// Handle imported inner class case
			// Imported full name wasn't found as an absolute class
			// If it is compound, try to resolve to an inner class.  
			// (maybe this should happen in the BshClassManager?)
			if ( Name.isCompound( fullname ) )
				try {
					clas = getNameResolver( fullname ).toClass();
				} catch ( ClassNotFoundException e ) { /* not a class */ }
			else 
				if ( Interpreter.DEBUG ) Interpreter.debug(
					"imported unpackaged name not found:" +fullname);
			// If found cache the full name in the BshClassManager
			if ( clas != null ) {
				// (should we cache info in not a class case too?)
				getClassManager().cacheClassInfo( fullname, clas );
				return clas;
			}
			// It was explicitly imported, but we don't know what it is.
			// should we throw an error here??
			return null;  
		}
		/*
			Try imported packages, e.g. "import foo.bar.*;"
			in reverse order of import...
			(give later imports precedence...)
		*/
		if ( importedPackages != null )
			for(int i=importedPackages.size()-1; i>=0; i--)
			{
				String s = importedPackages.get(i) + "." + name;
				Class c=classForName(s);
				if ( c != null )
					return c;
			}
		BshClassManager bcm = getClassManager();
		/*
			Try super import if available
			Note: we do this last to allow explicitly imported classes
			and packages to take priority.  This method will also throw an
			error indicating ambiguity if it exists...
		*/
		if ( bcm.hasSuperImport() ) 
		{
			String s = bcm.getClassNameByUnqName( name );
			if ( s != null )
				return classForName( s );
		}
		return null;
    }
	private Class classForName( String name ) 
	{
		return getClassManager().classForName( name );
	}
	/**
		Implements NameSource
		@return all variable and method names in this and all parent
		namespaces
	*/
	public String [] getAllNames() 
	{
		List<String> list = new ArrayList<String>();
		getAllNamesAux( list );
		return list.toArray(new String[0]);
	}
	/**
		Helper for implementing NameSource
	*/
	protected void getAllNamesAux( List<String> list ) 
	{
		list.addAll( variables.keySet() );
		list.addAll( methods.keySet() );
		if ( parent != null )
			parent.getAllNamesAux( list );
	}
	List<NameSource.Listener> nameSourceListeners;
	/**
		Implements NameSource
		Add a listener who is notified upon changes to names in this space.
	*/
	public void addNameSourceListener( NameSource.Listener listener ) {
		if ( nameSourceListeners == null )
			nameSourceListeners = new ArrayList<NameSource.Listener>();
		nameSourceListeners.add( listener );
	}
	
	/**
		Perform "import *;" causing the entire classpath to be mapped.
		This can take a while.
	*/
	public void doSuperImport() 
		throws UtilEvalError
	{
		getClassManager().doSuperImport();
	}
	public String toString() {
		return "NameSpace: " 
			+ ( nsName==null
				? super.toString()
				: nsName + " (" + super.toString() +")" )
			+ ( isClass ? " (isClass) " : "" )
			+ ( isMethod ? " (method) " : "" )
			+ ( classStatic != null ? " (class static) " : "" )
			+ ( classInstance != null ? " (class instance) " : "" );
	}
	/*
		For serialization.
		Don't serialize non-serializable objects.
	*/
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException 
	{
		// clear name resolvers... don't know if this is necessary.
		names = null;
	
		s.defaultWriteObject();
	}
	/**
		Invoke a method in this namespace with the specified args and
		interpreter reference.  No caller information or call stack is
		required.  The method will appear as if called externally from Java.
		<p>
		see bsh.This.invokeMethod(
			String methodName, Object [] args, Interpreter interpreter, 
			CallStack callstack, SimpleNode callerInfo, boolean )
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter ) 
		throws EvalError
	{
		return invokeMethod( 
			methodName, args, interpreter, null, null );
	}
	/**
		This method simply delegates to This.invokeMethod();
		<p>
		see bsh.This.invokeMethod(
			String methodName, Object [] args, Interpreter interpreter, 
			CallStack callstack, SimpleNode callerInfo )
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter, 
		CallStack callstack, SimpleNode callerInfo ) 
		throws EvalError
	{
		return getThis( interpreter ).invokeMethod( 
			methodName, args, interpreter, callstack, callerInfo,
			false/*declaredOnly*/ );
	}
	/**
		Clear all cached classes and names
	*/
	public void classLoaderChanged() {
		nameSpaceChanged();
	}
	/**
		Clear all cached classes and names
	*/
	public void nameSpaceChanged() {
		classCache = null;
		names = null;
	}
	/**
		Import standard packages.  Currently:
		<pre>
			importClass("bsh.EvalError");
			importClass("bsh.Interpreter");
			importPackage("javax.swing.event");
			importPackage("javax.swing");
			importPackage("java.awt.event");
			importPackage("java.awt");
			importPackage("java.net");
			importPackage("java.util");
			importPackage("java.io");
			importPackage("java.lang");
			importCommands("/bsh/commands");
		</pre>
	*/
    public void loadDefaultImports()
    {
		/**
			Note: the resolver looks through these in reverse order, per
			precedence rules...  so for max efficiency put the most common
			ones later.
		*/
		importClass("bsh.EvalError");
		importClass("bsh.Interpreter");
		importPackage("javax.swing.event");
		importPackage("javax.swing");
		importPackage("java.awt.event");
		importPackage("java.awt");
		importPackage("java.net");
		importPackage("java.util");
		importPackage("java.io");
		importPackage("java.lang");
		importCommands("/bsh/commands");
    }
	/**
		This is the factory for Name objects which resolve names within
		this namespace (e.g. toObject(), toClass(), toLHS()).
		<p>
		This was intended to support name resolver caching, allowing 
		Name objects to cache info about the resolution of names for 
		performance reasons.  However this not proven useful yet.  
		<p>
		We'll leave the caching as it will at least minimize Name object
		creation.
		<p>
		(This method would be called getName() if it weren't already used for 
		the simple name of the NameSpace)
		<p>
		This method was public for a time, which was a mistake.  
		Use get() instead.
	*/
	public Name getNameResolver( String ambigname )
	{
		if ( names == null )
			names = new HashMap<String,Name>();
		Name name = names.get( ambigname );
		if ( name == null ) {
			name = new Name( this, ambigname );
			names.put( ambigname, name );
		} 
		return name;
	}
	public int getInvocationLine() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getLineNumber();
		else
			return -1;
	}
	public String getInvocationText() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getText();
		else
			return "<invoked from Java code>";
	}
	/**
		This is a helper method for working inside of bsh scripts and commands.
		In that context it is impossible to see a ClassIdentifier object
		for what it is.  Attempting to access a method on a ClassIdentifier
		will look like a static method invocation.  
		
		This method is in NameSpace for convenience (you don't have to import
		bsh.ClassIdentifier to use it );
	*/
	public static Class identifierToClass( ClassIdentifier ci ) 
	{
		return ci.getTargetClass();
	}
	/**
		Clear all variables, methods, and imports from this namespace.
		If this namespace is the root, it will be reset to the default 
		imports.
		@see #loadDefaultImports()
	*/
	public void clear() 
	{
		variables = null;
		methods = null;
		importedClasses = null;
		importedPackages = null;
		importedCommands = null;
		importedObjects = null;
		if ( parent == null )
			loadDefaultImports();	
    	classCache = null;
		names = null;
	}
	/**
		Import a compiled Java object's methods and variables into this 
		namespace.  When no scripted method / command or variable is found
		locally in this namespace method / fields of the object will be
		checked.  Objects are checked in the order of import with later imports
		taking precedence.
		<p/>
	*/
	/*
		Note: this impor pattern is becoming common... could factor it out into
		an importedObject Vector class.
	*/
	public void importObject( Object obj ) 
	{
		if ( importedObjects == null )
			importedObjects = new ArrayList<Object>();
		// If it exists, remove it and add it at the end (avoid memory leak)
		importedObjects.remove( obj );
		importedObjects.add( obj );
		nameSpaceChanged();
	}
	/**
	*/
	public void importStatic( Class clas ) 
	{
		if ( importedStatic == null )
			importedStatic = new ArrayList<Class>();
		// If it exists, remove it and add it at the end (avoid memory leak)
		importedStatic.remove( clas );
		importedStatic.add( clas );
		nameSpaceChanged();
	}
	/**
		Set the package name for classes defined in this namespace.
		Subsequent sets override the package.
	*/
	public void setPackage( String packageName )
	{
		this.packageName = packageName;
	}
	String getPackage() 
	{
		if ( packageName != null )
			return packageName;
		if ( parent != null )
			return parent.getPackage();
		
		return null;
	}
	NameSpace copy() {
		try {
			final NameSpace clone = (NameSpace) clone();
			clone.thisReference = null;
			clone.variables = clone(variables);
			clone.methods = clone(methods);
			clone.importedClasses = clone(importedClasses);
			clone.importedPackages = clone(importedPackages);
			clone.importedCommands = clone(importedCommands);
			clone.importedObjects = clone(importedObjects);
			clone.importedStatic = clone(importedStatic);
			clone.names = clone(names);
			return clone;
		} catch (CloneNotSupportedException e) {
			throw new IllegalStateException(e);
		}
	}
	private <K,V> Map<K,V> clone(final Map<K,V> map) {
		if (map == null) {
			return null;
		}
		return new HashMap<K,V>(map);
	}
	private <T> List<T> clone(final List<T> list) {
		if (list == null) {
			return null;
		}
		return new ArrayList<T>(list);
	}
}
package bsh.interpreter;
import bsh.*;
import bsh.ast.*;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
public class BshEvaluatingVisitor extends BshNodeVisitor<Object> {
    private CallStack callstack;
    private Interpreter interpreter;
    public BshEvaluatingVisitor(CallStack callstack, Interpreter interpreter) {
        this.callstack = callstack;
        this.interpreter = interpreter;
    }
    public CallStack getCallstack() {
        return callstack;
    }
    public Interpreter getInterpreter() {
        return interpreter;
    }
    @Override
    public Object visit(BSHAllocationExpression node) {
        // type is either a class name or a primitive type
        SimpleNode type = (SimpleNode)node.jjtGetChild(0);
        // args is either constructor arguments or array dimensions
        SimpleNode args = (SimpleNode)node.jjtGetChild(1);
        if ( type instanceof BSHAmbiguousName)
        {
            BSHAmbiguousName name = (BSHAmbiguousName)type;
            if (args instanceof BSHArguments)
                return objectAllocation(node, name, (BSHArguments) args);
            else
                return objectArrayAllocation(node, name, (BSHArrayDimensions) args
                );
        }
        else
            return primitiveArrayAllocation(node, (BSHPrimitiveType) type,
                    (BSHArrayDimensions) args);
    }
    public Object objectAllocation(BSHAllocationExpression node,
            BSHAmbiguousName nameNode, BSHArguments argumentsNode)
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        Object[] args = getArguments(argumentsNode);
        if ( args == null)
            throw new EvalError( "Null args in new.", node, callstack );
        // Look for scripted class object
        Object obj = ambiguousNameToObject(nameNode, false/* force class*/ );
        // Try regular class
        obj = ambiguousNameToObject( nameNode, true/*force class*/ );
        Class type = null;
        if ( obj instanceof ClassIdentifier )
            type = ((ClassIdentifier)obj).getTargetClass();
        else
            throw new EvalError(
                    "Unknown class: "+nameNode.text, node, callstack );
        // Is an inner class style object allocation
        boolean hasBody = node.jjtGetNumChildren() > 2;
        if ( hasBody )
        {
            BSHBlock body = (BSHBlock)node.jjtGetChild(2);
            if ( type.isInterface() )
                return constructWithInterfaceBody(node,
                        type, args, body);
            else
                return constructWithClassBody( node,
                        type, args, body );
        } else
            return constructObject(node, type, args );
    }
    public Object constructObject(BSHAllocationExpression node, Class<?> type, Object[] args ) throws EvalError {
        final boolean isGeneratedClass = GeneratedClass.class.isAssignableFrom(type);
        if (isGeneratedClass) {
            ClassGeneratorUtil.registerConstructorContext(callstack, interpreter);
        }
        Object obj;
        try {
            obj = Reflect.constructObject( type, args );
        } catch ( ReflectError e) {
            throw new EvalError(
                    "Constructor error: " + e.getMessage(), node, callstack );
        } catch (InvocationTargetException e) {
            // No need to wrap this debug
            Interpreter.debug("The constructor threw an exception:\n\t" + e.getTargetException());
            throw new TargetError("Object constructor", e.getTargetException(), node, callstack, true);
        } finally {
            if (isGeneratedClass) {
                ClassGeneratorUtil.registerConstructorContext(null, null); // clean up, prevent memory leak
            }
        }
        String className = type.getName();
        // Is it an inner class?
        if ( className.indexOf("$") == -1 )
            return obj;
        // Temporary hack to support inner classes
        // If the obj is a non-static inner class then import the context...
        // This is not a sufficient emulation of inner classes.
        // Replace this later...
        // work through to class 'this'
        This ths = callstack.top().getThis( null );
        NameSpace instanceNameSpace =
                Name.getClassNameSpace( ths.getNameSpace() );
        // Change the parent (which was the class static) to the class instance
        // We really need to check if we're a static inner class here first...
        // but for some reason Java won't show the static modifier on our
        // fake inner classes...  could generate a flag field.
        if ( instanceNameSpace != null
                && className.startsWith( instanceNameSpace.getName() +"$")
                )
        {
            ClassGenerator.getClassGenerator().setInstanceNameSpaceParent(
                    obj, className, instanceNameSpace );
        }
        return obj;
    }
    public Object constructWithClassBody( BSHAllocationExpression node,
            Class type, Object[] args, BSHBlock block )
            throws EvalError
    {
        String name = callstack.top().getName() + "$" + (++node.innerClassCount);
        Modifiers modifiers = new Modifiers();
        modifiers.addModifier( Modifiers.CLASS, "public" );
        Class clas = ClassGenerator.getClassGenerator() .generateClass(
                name, modifiers, null/*interfaces*/, type/*superClass*/,
                block, false/*isInterface*/, callstack, interpreter );
        try {
            return Reflect.constructObject( clas, args );
        } catch ( Exception e ) {
            Throwable cause = e;
            if ( e instanceof InvocationTargetException ) {
                cause = ((InvocationTargetException) e).getTargetException();
            }
            throw new EvalError("Error constructing inner class instance: "+e, node, callstack, cause);
        }
    }
    public Object constructWithInterfaceBody( BSHAllocationExpression node,
            Class type, Object[] args, BSHBlock body )
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        NameSpace local = new NameSpace(namespace, "AnonymousBlock");
        callstack.push(local);
        evalBlock(body, true);
        callstack.pop();
        // statical import fields from the interface so that code inside
        // can refer to the fields directly (e.g. HEIGHT)
        local.importStatic( type );
        return local.getThis(interpreter).getInterface( type );
    }
    public Object objectArrayAllocation( BSHAllocationExpression node,
            BSHAmbiguousName nameNode, BSHArrayDimensions dimensionsNode )
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        Class type = ambiguousNameToClass( nameNode );
        if ( type == null )
            throw new EvalError( "Class " + nameNode.getName(namespace)
                    + " not found.", node, callstack );
        return arrayAllocation( node, dimensionsNode, type );
    }
    public Object primitiveArrayAllocation( BSHAllocationExpression node,
            BSHPrimitiveType typeNode, BSHArrayDimensions dimensionsNode
    )
            throws EvalError
    {
        Class type = typeNode.getType();
        return arrayAllocation(node, dimensionsNode, type );
    }
    public Object arrayAllocation( BSHAllocationExpression node,
            BSHArrayDimensions dimensionsNode, Class type)
            throws EvalError
    {
        /*
              dimensionsNode can return either a fully intialized array or VOID.
              when VOID the prescribed array dimensions (defined and undefined)
              are contained in the node.
          */
        Object result = evalArrayDimensions(dimensionsNode, type);
        if ( result != Primitive.VOID )
            return result;
        else
            return arrayNewInstance( node, type, dimensionsNode );
    }
    /**
     Create an array of the dimensions specified in dimensionsNode.
     dimensionsNode may contain a number of "undefined" as well as "defined"
     dimensions.
     <p>
     Background: in Java arrays are implemented in arrays-of-arrays style
     where, for example, a two dimensional array is a an array of arrays of
     some base type.  Each dimension-type has a Java class type associated
     with it... so if foo = new int[5][5] then the type of foo is
     int [][] and the type of foo[0] is int[], etc.  Arrays may also be
     specified with undefined trailing dimensions - meaning that the lower
     order arrays are not allocated as objects. e.g.
     if foo = new int [5][]; then foo[0] == null //true; and can later be
     assigned with the appropriate type, e.g. foo[0] = new int[5];
     (See Learning Java, O'Reilly & Associates more background).
     <p>
     To create an array with undefined trailing dimensions using the
     reflection API we must use an array type to represent the lower order
     (undefined) dimensions as the "base" type for the array creation...
     Java will then create the correct type by adding the dimensions of the
     base type to specified allocated dimensions yielding an array of
     dimensionality base + specified with the base dimensons unallocated.
     To create the "base" array type we simply create a prototype, zero
     length in each dimension, array and use it to get its class
     (Actually, I think there is a way we could do it with Class.forName()
     but I don't trust this).   The code is simpler than the explanation...
     see below.
     */
    public Object arrayNewInstance( BSHAllocationExpression node,
            Class type, BSHArrayDimensions dimensionsNode )
            throws EvalError
    {
        if ( dimensionsNode.numUndefinedDims > 0 )
        {
            Object proto = Array.newInstance(
                    type, new int [dimensionsNode.numUndefinedDims] ); // zeros
            type = proto.getClass();
        }
        try {
            return Array.newInstance(
                    type, dimensionsNode.definedDimensions);
        } catch( NegativeArraySizeException e1 ) {
            throw new TargetError( e1, node, callstack );
        } catch( Exception e ) {
            throw new EvalError("Can't construct primitive array: " +
                    e.getMessage(), node, callstack);
        }
    }
    @Override
    public Object visit(BSHAmbiguousName node) {
        throw new InterpreterError(
                "Don't know how to eval an ambiguous name!"
                        +"  Use toObject() if you want an object." );
    }
    public Object ambiguousNameToObject( BSHAmbiguousName node )
            throws EvalError
    {
        return ambiguousNameToObject( node, false );
    }
    public Object ambiguousNameToObject( BSHAmbiguousName node,
            boolean forceClass )
            throws EvalError
    {
        try {
            return
                    node.getName( callstack.top() ).toObject(
                            this, forceClass );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    public Class ambiguousNameToClass( BSHAmbiguousName node )
            throws EvalError
    {
        try {
            return node.getName( callstack.top() ).toClass();
        } catch ( ClassNotFoundException e ) {
            throw new EvalError( e.getMessage(), node, callstack, e );
        } catch ( UtilEvalError e2 ) {
            // ClassPathException is a type of UtilEvalError
            throw e2.toEvalError( node, callstack );
        }
    }
    public LHS ambiguousNameToLHS( BSHAmbiguousName node )
            throws EvalError
    {
        try {
            return node.getName( callstack.top() ).toLHS( this );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHArguments node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHArguments class.");
    }
    /*
         Disallowing VOIDs here was an easy way to support the throwing of a
         more descriptive error message on use of an undefined argument to a
         method call (very common).  If it ever turns out that we need to
         support that for some reason we'll have to re-evaluate how we get
         "meta-information" about the arguments in the various invoke() methods
         that take Object [].  We could either pass BSHArguments down to
         overloaded forms of the methods or throw an exception subtype
         including the argument position back up, where the error message would
         be compounded.
     */
    public Object[] getArguments( BSHArguments node )
            throws EvalError
    {
        // evaluate each child
        Object[] args = new Object[node.jjtGetNumChildren()];
        for(int i = 0; i < args.length; i++)
        {
            args[i] = ((SimpleNode)node.jjtGetChild(i)).accept(this);
            if ( args[i] == Primitive.VOID )
                throw new EvalError( "Undefined argument: " +
                        ((SimpleNode)node.jjtGetChild(i)).getText(), node, callstack );
        }
        return args;
    }
    /**
     Evaluate the structure of the array in one of two ways:
     a) an initializer exists, evaluate it and return
     the fully constructed array object, also record the dimensions
     of that array
     b) evaluate and record the lengths in each dimension and
     return void.
     The structure of the array dims is maintained in dimensions.
     */
    @Override
    public Object visit(BSHArrayDimensions node) {
        SimpleNode child = (SimpleNode)node.jjtGetChild(0);
        /*
              Child is array initializer.  Evaluate it and fill in the
              dimensions it returns.  Initialized arrays are always fully defined
              (no undefined dimensions to worry about).
              The syntax uses the undefinedDimension count.
              e.g. int [][] { 1, 2 };
          */
        if (child instanceof BSHArrayInitializer)
        {
            if ( node.baseType == null )
                throw new EvalError(
                        "Internal Array Eval err:  unknown base type",
                        node, callstack );
            Object initValue = evalArrayInitializer(((BSHArrayInitializer) child),
                    node.baseType, node.numUndefinedDims, callstack, interpreter);
            Class arrayClass = initValue.getClass();
            int actualDimensions = Reflect.getArrayDimensions(arrayClass);
            node.definedDimensions = new int[ actualDimensions ];
            // Compare with number of dimensions actually created with the
            // number specified (syntax uses the undefined ones here)
            if ( node.definedDimensions.length != node.numUndefinedDims )
                throw new EvalError(
                        "Incompatible initializer. Allocation calls for a " +
                                node.numUndefinedDims+ " dimensional array, but initializer is a " +
                                actualDimensions + " dimensional array", node, callstack );
            // fill in definedDimensions [] lengths
            Object arraySlice = initValue;
            for ( int i = 0; i < node.definedDimensions.length; i++ ) {
                node.definedDimensions[i] = Array.getLength(arraySlice);
                if ( node.definedDimensions[i] > 0 )
                    arraySlice = Array.get(arraySlice, 0);
            }
            return initValue;
        }
        else
        // Evaluate the defined dimensions of the array
        {
            node.definedDimensions = new int[ node.numDefinedDims ];
            for(int i = 0; i < node.numDefinedDims; i++)
            {
                try {
                    Object length = ((SimpleNode)node.jjtGetChild(i)).accept(this);
                    node.definedDimensions[i] = ((Primitive)length).intValue();
                }
                catch(Exception e)
                {
                    throw new EvalError(
                            "Array index: " + i +
                                    " does not evaluate to an integer", node, callstack );
                }
            }
        }
        return Primitive.VOID;
    }
    public Object evalArrayDimensions( BSHArrayDimensions node,
            Class type )
            throws EvalError
    {
        if ( Interpreter.DEBUG ) Interpreter.debug("array base type = "+type);
        node.baseType = type;
        return node.accept(this);
    }
    /**
     Construct the array from the initializer syntax.
     @param baseType the base class type of the array (no dimensionality)
     @param dimensions the top number of dimensions of the array
     e.g. 2 for a String [][];
     */
    public Object evalArrayInitializer(BSHArrayInitializer nodeA, Class baseType, int dimensions,
                        CallStack callstack, Interpreter interpreter )
            throws EvalError
    {
        int numInitializers = nodeA.jjtGetNumChildren();
        // allocate the array to store the initializers
        int [] dima = new int [dimensions]; // description of the array
        // The other dimensions default to zero and are assigned when
        // the values are set.
        dima[0] = numInitializers;
        Object initializers =  Array.newInstance( baseType, dima );
        // Evaluate the initializers
        for (int i = 0; i < numInitializers; i++)
        {
            SimpleNode childNode = (SimpleNode)nodeA.jjtGetChild(i);
            Object currentInitializer;
            if ( childNode instanceof BSHArrayInitializer ) {
                if ( dimensions < 2 )
                    throw new EvalError(
                            "Invalid Location for Intializer, position: "+i,
                            nodeA, callstack );
                currentInitializer =
                        evalArrayInitializer(((BSHArrayInitializer)childNode),
                                baseType, dimensions-1, callstack, interpreter);
            } else
                currentInitializer = childNode.accept(this);
            if ( currentInitializer == Primitive.VOID )
                throw new EvalError(
                        "Void in array initializer, position"+i, nodeA, callstack );
            // Determine if any conversion is necessary on the initializers.
            //
            // Quick test to see if conversions apply:
            // If the dimensionality of the array is 1 then the elements of
            // the initializer can be primitives or boxable types.  If it is
            // greater then the values must be array (object) types and there
            // are currently no conversions that we do on those.
            // If we have conversions on those in the future then we need to
            // get the real base type here instead of the dimensionless one.
            Object value = currentInitializer;
            if ( dimensions == 1 )
            {
                // We do a bsh cast here.  strictJava should be able to affect
                // the cast there when we tighten control
                try {
                    value = Types.castObject(
                            currentInitializer, baseType, Types.CAST );
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError(
                            "Error in array initializer", nodeA, callstack );
                }
                // unwrap any primitive, map voids to null, etc.
                value = Primitive.unwrap( value );
            }
            // store the value in the array
            try {
                Array.set(initializers, i, value);
            } catch( IllegalArgumentException e ) {
                Interpreter.debug("illegal arg"+e);
                throwTypeError( nodeA, baseType, currentInitializer, i, callstack );
            } catch( ArrayStoreException e ) { // I think this can happen
                Interpreter.debug("arraystore"+e);
                throwTypeError(nodeA, baseType, currentInitializer, i, callstack );
            }
        }
        return initializers;
    }
    private void throwTypeError( BSHArrayInitializer node,
            Class baseType, Object initializer, int argNum, CallStack callstack )
            throws EvalError
    {
        String rhsType;
        if (initializer instanceof Primitive)
            rhsType =
                    ((Primitive)initializer).getType().getName();
        else
            rhsType = Reflect.normalizeClassName(
                    initializer.getClass());
        throw new EvalError ( "Incompatible type: " + rhsType
                +" in initializer of array type: "+ baseType
                +" at position: "+argNum, node, callstack );
    }
    @Override
    public Object visit(BSHArrayInitializer node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHArrayInitializer class.");
    }
    @Override
    public Object visit(BSHAssignment node) {
        BSHPrimaryExpression lhsNode =
                (BSHPrimaryExpression)node.jjtGetChild(0);
        if ( lhsNode == null )
            throw new InterpreterError( "Error, null LHSnode" );
        boolean strictJava = interpreter.getStrictJava();
        LHS lhs = primaryExprToLHS(lhsNode);
        if ( lhs == null )
            throw new InterpreterError( "Error, null LHS" );
        // For operator-assign operations save the lhs value before evaluating
        // the rhs.  This is correct Java behavior for postfix operations
        // e.g. i=1; i+=i++; // should be 2 not 3
        Object lhsValue = null;
        if ( node.operator != ParserConstants.ASSIGN ) // assign doesn't need the pre-value
            try {
                lhsValue = lhs.getValue();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
        SimpleNode rhsNode = (SimpleNode)node.jjtGetChild(1);
        Object rhs;
        // implement "blocks" foo = { };
        // if ( rhsNode instanceof BSHBlock )
        //    rsh =
        // else
        rhs = rhsNode.accept(this);
        if ( rhs == Primitive.VOID )
            throw new EvalError("Void assignment.", node, callstack );
        try {
            switch(node.operator)
            {
                case ParserConstants.ASSIGN:
                    return lhs.assign( rhs, strictJava );
                case ParserConstants.PLUSASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.PLUS), strictJava );
                case ParserConstants.MINUSASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.MINUS), strictJava );
                case ParserConstants.STARASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.STAR), strictJava );
                case ParserConstants.SLASHASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.SLASH), strictJava );
                case ParserConstants.ANDASSIGN:
                case ParserConstants.ANDASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.BIT_AND), strictJava );
                case ParserConstants.ORASSIGN:
                case ParserConstants.ORASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.BIT_OR), strictJava );
                case ParserConstants.XORASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.XOR), strictJava );
                case ParserConstants.MODASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.MOD), strictJava );
                case ParserConstants.LSHIFTASSIGN:
                case ParserConstants.LSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.LSHIFT), strictJava );
                case ParserConstants.RSIGNEDSHIFTASSIGN:
                case ParserConstants.RSIGNEDSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.RSIGNEDSHIFT ), strictJava );
                case ParserConstants.RUNSIGNEDSHIFTASSIGN:
                case ParserConstants.RUNSIGNEDSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.RUNSIGNEDSHIFT),
                            strictJava );
                default:
                    throw new InterpreterError(
                            "unimplemented operator in assignment BSH");
            }
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHBinaryExpression node) {
        Object lhs = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        /*
              Doing instanceof?  Next node is a type.
          */
        if (node.kind == ParserConstants.INSTANCEOF)
        {
            // null object ref is not instance of any type
            if ( lhs == Primitive.NULL )
                return new Primitive(false);
            Class rhs = getType(((BSHType)node.jjtGetChild(1)));
            /*
               // primitive (number or void) cannot be tested for instanceof
               if (lhs instanceof Primitive)
                   throw new EvalError("Cannot be instance of primitive type." );
           */
            /*
                   Primitive (number or void) is not normally an instanceof
                   anything.  But for internal use we'll test true for the
                   bsh.Primitive class.
                   i.e. (5 instanceof bsh.Primitive) will be true
               */
            if ( lhs instanceof Primitive )
                if ( rhs == bsh.Primitive.class )
                    return new Primitive(true);
                else
                    return new Primitive(false);
            // General case - performe the instanceof based on assignability
            boolean ret = Types.isJavaBaseAssignable( rhs, lhs.getClass() );
            return new Primitive(ret);
        }
        // The following two boolean checks were tacked on.
        // This could probably be smoothed out.
        /*
              Look ahead and short circuit evaluation of the rhs if:
                  we're a boolean AND and the lhs is false.
          */
        if ( node.kind == ParserConstants.BOOL_AND || node.kind == ParserConstants.BOOL_ANDX ) {
            Object obj = lhs;
            if ( node.isPrimitiveValue(lhs) )
                obj = ((Primitive)lhs).getValue();
            if ( obj instanceof Boolean &&
                    ( ((Boolean)obj).booleanValue() == false ) )
                return new Primitive(false);
        }
        /*
              Look ahead and short circuit evaluation of the rhs if:
                  we're a boolean AND and the lhs is false.
          */
        if ( node.kind == ParserConstants.BOOL_OR || node.kind == ParserConstants.BOOL_ORX ) {
            Object obj = lhs;
            if ( node.isPrimitiveValue(lhs) )
                obj = ((Primitive)lhs).getValue();
            if ( obj instanceof Boolean &&
                    ( ((Boolean)obj).booleanValue() == true ) )
                return new Primitive(true);
        }
        // end stuff that was tacked on for boolean short-circuiting.
        /*
              Are both the lhs and rhs either wrappers or primitive values?
              do binary op
          */
        boolean isLhsWrapper = node.isWrapper(lhs);
        Object rhs = ((SimpleNode)node.jjtGetChild(1)).accept(this); //eval(callstack, interpreter);
        boolean isRhsWrapper = node.isWrapper(rhs);
        if (
                ( isLhsWrapper || node.isPrimitiveValue(lhs) )
                        && ( isRhsWrapper || node.isPrimitiveValue(rhs) )
                )
        {
            // Special case for EQ on two wrapper objects
            if ( (isLhsWrapper && isRhsWrapper && node.kind == ParserConstants.EQ))
            {
                /*
                        Don't auto-unwrap wrappers (preserve identity semantics)
                        FALL THROUGH TO OBJECT OPERATIONS BELOW.
                    */
            } else
                try {
                    return Primitive.binaryOperation(lhs, rhs, node.kind);
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack  );
                }
        }
        /*
      Doing the following makes it hard to use untyped vars...
      e.g. if ( arg == null ) ...what if arg is a primitive?
      The answer is that we should test only if the var is typed...?
      need to get that info here...
          else
          {
          // Do we have a mixture of primitive values and non-primitives ?
          // (primitiveValue = not null, not void)
          int primCount = 0;
          if ( isPrimitiveValue( lhs ) )
              ++primCount;
          if ( isPrimitiveValue( rhs ) )
              ++primCount;
          if ( primCount > 1 )
              // both primitive types, should have been handled above
              throw new InterpreterError("should not be here");
          else
          if ( primCount == 1 )
              // mixture of one and the other
              throw new EvalError("Operator: '" + tokenImage[kind]
                  +"' inappropriate for object / primitive combination.",
                  this, callstack );
          // else fall through to handle both non-primitive types
          // end check for primitive and non-primitive mix
          }
      */
        /*
              Treat lhs and rhs as arbitrary objects and do the operation.
              (including NULL and VOID represented by their Primitive types)
          */
        //System.out.println("binary op arbitrary obj: {"+lhs+"}, {"+rhs+"}");
        switch(node.kind)
        {
            case ParserConstants.EQ:
                return new Primitive((lhs == rhs));
            case ParserConstants.NE:
                return new Primitive((lhs != rhs));
            case ParserConstants.PLUS:
                if(lhs instanceof String || rhs instanceof String)
                    return lhs.toString() + rhs.toString();
                // FALL THROUGH TO DEFAULT CASE!!!
            default:
                if(lhs instanceof Primitive || rhs instanceof Primitive)
                    if ( lhs == Primitive.VOID || rhs == Primitive.VOID )
                        throw new EvalError(
                                "illegal use of undefined variable, class, or 'void' literal",
                                node, callstack );
                    else
                    if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                        throw new EvalError(
                                "illegal use of null value or 'null' literal", node, callstack);
                throw new EvalError("Operator: '" + ParserConstants.tokenImage[node.kind] +
                        "' inappropriate for objects", node, callstack );
        }
    }
    /**
     @param overrideNamespace if set to true the block will be executed
     in the current namespace (not a subordinate one).
     <p>
     If true *no* new BlockNamespace will be swapped onto the stack and
     the eval will happen in the current
     top namespace.  This is used by BshMethod, TryStatement, etc.
     which must intialize the block first and also for those that perform
     multiple passes in the same block.
     */
    public Object evalBlock( BSHBlock node,
            boolean overrideNamespace )
            throws EvalError
    {
        Object syncValue = null;
        if ( node.isSynchronized )
        {
            // First node is the expression on which to sync
            SimpleNode exp = ((SimpleNode)node.jjtGetChild(0));
            syncValue = exp.accept(this);
        }
        Object ret;
        if ( node.isSynchronized ) // Do the actual synchronization
            synchronized( syncValue )
            {
                ret = evalBlock(node, overrideNamespace, null/*filter*/);
            }
        else
            ret = evalBlock(node, overrideNamespace, null/*filter*/ );
        return ret;
    }
    public Object evalBlock( BSHBlock block,
            boolean overrideNamespace, BSHBlock.NodeFilter nodeFilter )
            throws EvalError
    {
        Object ret = Primitive.VOID;
        NameSpace enclosingNameSpace = null;
        if ( !overrideNamespace )
        {
            enclosingNameSpace= callstack.top();
            BlockNameSpace bodyNameSpace =
                    new BlockNameSpace( enclosingNameSpace );
            callstack.swap( bodyNameSpace );
        }
        int startChild = block.isSynchronized ? 1 : 0;
        int numChildren = block.jjtGetNumChildren();
        try {
            /*
                   Evaluate block in two passes:
                   First do class declarations then do everything else.
               */
            for(int i=startChild; i<numChildren; i++)
            {
                SimpleNode node = ((SimpleNode)block.jjtGetChild(i));
                if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
                    continue;
                if ( node instanceof BSHClassDeclaration )
                    node.accept(this);
            }
            for(int i=startChild; i<numChildren; i++)
            {
                SimpleNode node = ((SimpleNode)block.jjtGetChild(i));
                if ( node instanceof BSHClassDeclaration )
                    continue;
                // filter nodes
                if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
                    continue;
                ret = node.accept(this);
                // statement or embedded block evaluated a return statement
                if ( ret instanceof ReturnControl )
                    break;
            }
        } finally {
            // make sure we put the namespace back when we leave.
            if ( !overrideNamespace )
                callstack.swap( enclosingNameSpace );
        }
        return ret;
    }
    @Override
    public Object visit(BSHBlock node) {
        return evalBlock(node, false);
    }
    @Override
    public Object visit(BSHCastExpression node) {
        NameSpace namespace = callstack.top();
        Class toType = getType(((BSHType)node.jjtGetChild(0)));
        SimpleNode expression = (SimpleNode)node.jjtGetChild(1);
        // evaluate the expression
        Object fromValue = expression.accept(this);
        Class fromType = fromValue.getClass();
        // TODO: need to add isJavaCastable() test for strictJava
        // (as opposed to isJavaAssignable())
        try {
            return Types.castObject( fromValue, toType, Types.CAST );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack  );
        }
    }
    @Override
    public Object visit(BSHClassDeclaration node) {
        synchronized (node) {
            if (node.generatedClass == null) {
                node.generatedClass = generateClass(node);
            }
            return node.generatedClass;
        }
    }
    public Class<?> generateClass(BSHClassDeclaration node) throws EvalError {
        int child = 0;
        // resolve superclass if any
        Class superClass = null;
        if ( node.extend ) {
            BSHAmbiguousName superNode = (BSHAmbiguousName)node.jjtGetChild(child++);
            superClass = ambiguousNameToClass( superNode );
        }
        // Get interfaces
        Class [] interfaces = new Class[node.numInterfaces];
        for( int i=0; i<node.numInterfaces; i++) {
            BSHAmbiguousName node1 = (BSHAmbiguousName)node.jjtGetChild(child++);
            interfaces[i] = ambiguousNameToClass(node1);
            if ( !interfaces[i].isInterface() )
                throw new EvalError(
                        "Type: "+node1.text+" is not an interface!",
                        node, callstack );
        }
        BSHBlock block;
        // Get the class body BSHBlock
        if ( child < node.jjtGetNumChildren() )
            block = (BSHBlock) node.jjtGetChild(child);
        else
            block = new BSHBlock( ParserTreeConstants.JJTBLOCK );
        return ClassGenerator.getClassGenerator().generateClass(
                node.name, node.modifiers, interfaces, superClass, block, node.isInterface,
                callstack, interpreter );
    }
    @Override
    public Object visit(BSHEnhancedForStatement node) {
        Class elementType = null;
        SimpleNode expression, statement=null;
        NameSpace enclosingNameSpace = callstack.top();
        SimpleNode firstNode =((SimpleNode)node.jjtGetChild(0));
        int nodeCount = node.jjtGetNumChildren();
        if ( firstNode instanceof BSHType )
        {
            elementType=getType(((BSHType)firstNode));
            expression=((SimpleNode)node.jjtGetChild(1));
            if ( nodeCount>2 )
                statement=((SimpleNode)node.jjtGetChild(2));
        } else
        {
            expression=firstNode;
            if ( nodeCount>1 )
                statement=((SimpleNode)node.jjtGetChild(1));
        }
        BlockNameSpace eachNameSpace = new BlockNameSpace( enclosingNameSpace );
        callstack.swap( eachNameSpace );
        final Object iteratee = expression.accept(this);
        if ( iteratee == Primitive.NULL )
            throw new EvalError("The collection, array, map, iterator, or " +
                    "enumeration portion of a for statement cannot be null.",
                    node, callstack );
        CollectionManager cm = CollectionManager.getCollectionManager();
        if ( !cm.isBshIterable( iteratee ) )
            throw new EvalError("Can't iterate over type: "
                    +iteratee.getClass(), node, callstack );
        Iterator iterator = cm.getBshIterator( iteratee );
        Object returnControl = Primitive.VOID;
        while( iterator.hasNext() )
        {
            try {
                Object value = iterator.next();
                if ( value == null )
                    value = Primitive.NULL;
                if ( elementType != null )
                    eachNameSpace.setTypedVariable(
                            node.varName/*name*/, elementType/*type*/,
                            value, new Modifiers()/*none*/ );
                else
                    eachNameSpace.setVariable( node.varName, value, false );
            } catch ( UtilEvalError e ) {
                throw e.toEvalError(
                        "for loop iterator variable:"+ node.varName, node, callstack );
            }
            boolean breakout = false; // switch eats a multi-level break here?
            if ( statement != null ) // not empty statement
            {
                Object ret = statement.accept(this); //eval( callstack, interpreter );
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case ParserConstants.RETURN:
                            returnControl = ret;
                            breakout = true;
                            break;
                        case ParserConstants.CONTINUE:
                            break;
                        case ParserConstants.BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if (breakout)
                break;
        }
        callstack.swap(enclosingNameSpace);
        return returnControl;
    }
    @Override
    public Object visit(BSHFormalComment node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHFormalComment class.");
    }
    @Override
    public Object visit(BSHFormalParameter node) {
        if ( node.jjtGetNumChildren() > 0 )
            node.type = getType(((BSHType)node.jjtGetChild(0)));
        else
            node.type = node.UNTYPED;
        return node.type;
    }
    public String getFormalParameterTypeDescriptor( BSHFormalParameter node,
             String defaultPackage )
    {
        if ( node.jjtGetNumChildren() > 0 )
            return getTypeDescriptor(((BSHType) node.jjtGetChild(0)), defaultPackage);
        else
            // this will probably not get used
            return "Ljava/lang/Object;";  // Object type
    }
    @Override
    public Object visit(BSHFormalParameters node) {
        if ( node.paramTypes != null )
            return node.paramTypes;
        node.insureParsed();
        Class [] paramTypes = new Class[node.numArgs];
        for(int i=0; i<node.numArgs; i++)
        {
            BSHFormalParameter param = (BSHFormalParameter)node.jjtGetChild(i);
            paramTypes[i] = (Class)param.accept(this); //eval( callstack, interpreter );
        }
        node.paramTypes = paramTypes;
        return paramTypes;
    }
    public String [] getTypeDescriptors( BSHFormalParameters node, String defaultPackage )
    {
        if ( node.typeDescriptors != null )
            return node.typeDescriptors;
        node.insureParsed();
        String [] typeDesc = new String[node.numArgs];
        for(int i=0; i<node.numArgs; i++)
        {
            BSHFormalParameter param = (BSHFormalParameter)node.jjtGetChild(i);
            typeDesc[i] = getFormalParameterTypeDescriptor(param, defaultPackage );
        }
        node.typeDescriptors = typeDesc;
        return typeDesc;
    }
    @Override
    public Object visit(BSHForStatement node) {
        int i = 0;
        if(node.hasForInit)
            node.forInit = ((SimpleNode)node.jjtGetChild(i++));
        if(node.hasExpression)
            node.expression = ((SimpleNode)node.jjtGetChild(i++));
        if(node.hasForUpdate)
            node.forUpdate = ((SimpleNode)node.jjtGetChild(i++));
        if(i < node.jjtGetNumChildren()) // should normally be
            node.statement = ((SimpleNode)node.jjtGetChild(i));
        NameSpace enclosingNameSpace= callstack.top();
        BlockNameSpace forNameSpace = new BlockNameSpace( enclosingNameSpace );
        /*
              Note: some interesting things are going on here.
              1) We swap instead of push...  The primary mode of operation
              acts like we are in the enclosing namespace...  (super must be
              preserved, etc.)
              2) We do *not* call the body block eval with the namespace
              override.  Instead we allow it to create a second subordinate
              BlockNameSpace child of the forNameSpace.  Variable propogation
              still works through the chain, but the block's child cleans the
              state between iteration.
              (which is correct Java behavior... see forscope4.bsh)
          */
        // put forNameSpace it on the top of the stack
        // Note: it's important that there is only one exit point from this
        // method so that we can swap back the namespace.
        callstack.swap( forNameSpace );
        // Do the for init
        if ( node.hasForInit )
            node.forInit.accept(this);
        Object returnControl = Primitive.VOID;
        while(true)
        {
            if ( node.hasExpression )
            {
                boolean cond = BshInterpreterUtil.evaluateCondition(
                        node.expression, this);
                if ( !cond )
                    break;
            }
            boolean breakout = false; // switch eats a multi-level break here?
            if ( node.statement != null ) // not empty statement
            {
                // do *not* invoke special override for block... (see above)
                Object ret = node.statement.accept(this);
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case ParserConstants.RETURN:
                            returnControl = ret;
                            breakout = true;
                            break;
                        case ParserConstants.CONTINUE:
                            break;
                        case ParserConstants.BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if ( breakout )
                break;
            if ( node.hasForUpdate )
                node.forUpdate.accept(this);
        }
        callstack.swap( enclosingNameSpace );  // put it back
        return returnControl;
    }
    @Override
    public Object visit(BSHIfStatement node) {
        Object ret = null;
        if( BshInterpreterUtil.evaluateCondition(
                (SimpleNode) node.jjtGetChild(0), this) )
            ret = ((SimpleNode)node.jjtGetChild(1)).accept(this);
        else
        if(node.jjtGetNumChildren() > 2)
            ret = ((SimpleNode)node.jjtGetChild(2)).accept(this);
        if(ret instanceof ReturnControl)
            return ret;
        else
            return Primitive.VOID;
    }
    @Override
    public Object visit(BSHImportDeclaration node) {
        NameSpace namespace = callstack.top();
        if ( node.superImport )
            try {
                namespace.doSuperImport();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack  );
            }
        else
        {
            if ( node.staticImport )
            {
                if ( node.importPackage )
                {
                    Class clas = ambiguousNameToClass(((BSHAmbiguousName)node.jjtGetChild(0)));
                    namespace.importStatic( clas );
                } else
                    throw new EvalError(
                            "static field imports not supported yet",
                            node, callstack );
            } else
            {
                String name = ((BSHAmbiguousName)node.jjtGetChild(0)).text;
                if ( node.importPackage )
                    namespace.importPackage(name);
                else
                    namespace.importClass(name);
            }
        }
        return Primitive.VOID;
    }
    @Override
    public Object visit(BSHLiteral node) {
        if (node.value == null)
            throw new InterpreterError("Null in bsh literal: "+node.value);
        return node.value;
    }
    @Override
    public Object visit(BSHMethodDeclaration node) {
        node.returnType = evalMethodReturnType(node);
        evalNodes(node);
        // Install an *instance* of this method in the namespace.
        // See notes in BshMethod
        // This is not good...
        // need a way to update eval without re-installing...
        // so that we can re-eval params, etc. when classloader changes
        // look into this
        NameSpace namespace = callstack.top();
        BshMethod bshMethod = new BshMethod( node, namespace, node.modifiers );
        try {
            namespace.setMethod( bshMethod );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError(node,callstack);
        }
        return Primitive.VOID;
    }
    public Class evalReturnType( BSHReturnType node ) throws EvalError
    {
        if ( node.isVoid )
            return Void.TYPE;
        else
            return getType(getTypeNode(node));
    }
    public BSHType getTypeNode(BSHReturnType node) {
        return (BSHType)node.jjtGetChild(0);
    }
    public String getTypeDescriptor( BSHReturnType node,
            String defaultPackage )
    {
        if ( node.isVoid )
            return "V";
        else
            return getTypeDescriptor(getTypeNode(node),
                    defaultPackage);
    }
    public String getReturnTypeDescriptor(BSHMethodDeclaration node,
            String defaultPackage )
    {
        node.insureNodesParsed();
        if ( node.returnTypeNode == null )
            return null;
        else
            return getTypeDescriptor(node.returnTypeNode, defaultPackage );
    }
    public BSHReturnType getReturnTypeNode(BSHMethodDeclaration node) {
        node.insureNodesParsed();
        return node.returnTypeNode;
    }
    /**
     Evaluate the return type node.
     @return the type or null indicating loosely typed return
     */
    public Class evalMethodReturnType( BSHMethodDeclaration node )
            throws EvalError
    {
        node.insureNodesParsed();
        if ( node.returnTypeNode != null )
            return evalReturnType(node.returnTypeNode);
        else
            return null;
    }
    public void evalNodes(BSHMethodDeclaration node)
            throws EvalError
    {
        node.insureNodesParsed();
        // validate that the throws names are class names
        for(int i=node.firstThrowsClause; i<node.numThrows+node.firstThrowsClause; i++)
            ambiguousNameToClass(((BSHAmbiguousName)node.jjtGetChild(i)) );
        node.paramsNode.accept(this);
        // if strictJava mode, check for loose parameters and return type
        if ( interpreter.getStrictJava() )
        {
            for(int i=0; i<node.paramsNode.paramTypes.length; i++)
                if ( node.paramsNode.paramTypes[i] == null )
                    // Warning: Null callstack here.  Don't think we need
                    // a stack trace to indicate how we sourced the method.
                    throw new EvalError(
                            "(Strict Java Mode) Undeclared argument type, parameter: " +
                                    node.paramsNode.getParamNames()[i] + " in method: "
                                    + node.name, node, null );
            if ( node.returnType == null )
                // Warning: Null callstack here.  Don't think we need
                // a stack trace to indicate how we sourced the method.
                throw new EvalError(
                        "(Strict Java Mode) Undeclared return type for method: "
                                + node.name, node, null );
        }
    }
    @Override
    public Object visit(BSHMethodInvocation node) {
        NameSpace namespace = callstack.top();
        BSHAmbiguousName nameNode = node.getNameNode();
        // Do not evaluate methods this() or super() in class instance space
        // (i.e. inside a constructor)
        if ( namespace.getParent() != null && namespace.getParent().isClass
                && ( nameNode.text.equals("super") || nameNode.text.equals("this") )
                )
            return Primitive.VOID;
        Name name = nameNode.getName(namespace);
        Object[] args = getArguments(node.getArgsNode());
        // This try/catch block is replicated is BSHPrimarySuffix... need to
        // factor out common functionality...
        // Move to Reflect?
        try {
            return name.invokeMethod( this, args, node);
        } catch ( ReflectError e ) {
            throw new EvalError(
                    "Error in method invocation: " + e.getMessage(),
                    node, callstack, e );
        } catch ( InvocationTargetException e )
        {
            String msg = "Method Invocation "+name;
            Throwable te = e.getTargetException();
            /*
                   Try to squeltch the native code stack trace if the exception
                   was caused by a reflective call back into the bsh interpreter
                   (e.g. eval() or source()
               */
            boolean isNative = true;
            if ( te instanceof EvalError )
                if ( te instanceof TargetError )
                    isNative = ((TargetError)te).inNativeCode();
                else
                    isNative = false;
            throw new TargetError( msg, te, node, callstack, isNative );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHPackageDeclaration node) {
        BSHAmbiguousName name = (BSHAmbiguousName)node.jjtGetChild(0);
        NameSpace namespace = callstack.top();
        namespace.setPackage( name.text );
        // import the package we're in by default...
        namespace.importPackage( name.text );
        return Primitive.VOID;
    }
    /**
     Evaluate to a value object.
     */
    private LHS primaryExprToLHS(BSHPrimaryExpression node)
            throws EvalError
    {
        Object obj = evalPrimaryExpr(node, true);
        if ( ! (obj instanceof LHS) )
            throw new EvalError("Can't assign to:", node, callstack );
        else
            return (LHS)obj;
    }
    /*
         Our children are a prefix expression and any number of suffixes.
         <p>
         We don't eval() any nodes until the suffixes have had an
         opportunity to work through them.  This lets the suffixes decide
         how to interpret an ambiguous name (e.g. for the .class operation).
     */
    private Object evalPrimaryExpr( BSHPrimaryExpression node, boolean toLHS )
            throws EvalError
    {
        //CallStack callstack = visitor.getCallstack();
        //Interpreter interpreter = visitor.getInterpreter();
        Object obj = node.jjtGetChild(0);
        int numChildren = node.jjtGetNumChildren();
        for(int i=1; i<numChildren; i++)
            obj = doSuffix(((BSHPrimarySuffix)node.jjtGetChild(i)), obj, toLHS);
        /*
              If the result is a Node eval() it to an object or LHS
              (as determined by toLHS)
          */
        if ( obj instanceof SimpleNode )
            if ( obj instanceof BSHAmbiguousName)
                if ( toLHS )
                    obj = ambiguousNameToLHS(((BSHAmbiguousName)obj));
                else
                    obj = ambiguousNameToObject(((BSHAmbiguousName)obj));
            else
                // Some arbitrary kind of node
                if ( toLHS )
                    // is this right?
                    throw new EvalError("Can't assign to prefix.",
                            node, callstack );
                else
                    obj = ((SimpleNode)obj).accept(this);
        // return LHS or value object as determined by toLHS
        if ( obj instanceof LHS )
            if ( toLHS )
                return obj;
            else
                try {
                    return ((LHS)obj).getValue();
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack );
                }
        else
            return obj;
    }
    @Override
    public Object visit(BSHPrimaryExpression node) {
        return evalPrimaryExpr(node, false);
    }
    private Object doSuffix( BSHPrimarySuffix node,
            Object obj, boolean toLHS)
            throws EvalError
    {
        // Handle ".class" suffix operation
        // Prefix must be a BSHType
        if ( node.operation == BSHPrimarySuffix.CLASS )
            if ( obj instanceof BSHType) {
                if ( toLHS )
                    throw new EvalError("Can't assign .class",
                            node, callstack );
                NameSpace namespace = callstack.top();
                return getType(((BSHType)obj));
            } else
                throw new EvalError(
                        "Attempt to use .class suffix on non class.",
                        node, callstack );
        /*
              Evaluate our prefix if it needs evaluating first.
              If this is the first evaluation our prefix mayb be a Node
              (directly from the PrimaryPrefix) - eval() it to an object.
              If it's an LHS, resolve to a value.
              Note: The ambiguous name construct is now necessary where the node
              may be an ambiguous name.  If this becomes common we might want to
              make a static method nodeToObject() or something.  The point is
              that we can't just eval() - we need to direct the evaluation to
              the context sensitive type of result; namely object, class, etc.
          */
        if ( obj instanceof SimpleNode )
            if ( obj instanceof BSHAmbiguousName)
                obj = ambiguousNameToObject(((BSHAmbiguousName)obj));
            else
                obj = ((SimpleNode)obj).accept(this);
        else
        if ( obj instanceof LHS )
            try {
                obj = ((LHS)obj).getValue();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
        try
        {
            switch(node.operation)
            {
                case BSHPrimarySuffix.INDEX:
                    return doIndex(node, obj, toLHS );
                case BSHPrimarySuffix.NAME:
                    return doName(node, obj, toLHS );
                case BSHPrimarySuffix.PROPERTY:
                    return doProperty( node, toLHS, obj);
                default:
                    throw new InterpreterError( "Unknown suffix type" );
            }
        }
        catch(ReflectError e)
        {
            throw new EvalError("reflection error: " + e, node, callstack, e );
        }
        catch(InvocationTargetException e)
        {
            throw new TargetError( "target exception", e.getTargetException(),
                    node, callstack, true);
        }
    }
    /*
         Field access, .length on array, or a method invocation
         Must handle toLHS case for each.
     */
    private Object doName( BSHPrimarySuffix node, Object obj, boolean toLHS)
            throws EvalError, ReflectError, InvocationTargetException
    {
        try {
            // .length on array
            if ( node.field.equals("length") && obj.getClass().isArray() )
                if ( toLHS )
                    throw new EvalError(
                            "Can't assign array length", node, callstack );
                else
                    return new Primitive(Array.getLength(obj));
            // field access
            if ( node.jjtGetNumChildren() == 0 )
                if ( toLHS )
                    return Reflect.getLHSObjectField(obj, node.field);
                else
                    return Reflect.getObjectFieldValue( obj, node.field );
            // Method invocation
            // (LHS or non LHS evaluation can both encounter method calls)
            Object[] oa = getArguments(((BSHArguments)node.jjtGetChild(0)));
            // TODO:
            // Note: this try/catch block is copied from BSHMethodInvocation
            // we need to factor out this common functionality and make sure
            // we handle all cases ... (e.g. property style access, etc.)
            // maybe move this to Reflect ?
            try {
                return Reflect.invokeObjectMethod(
                        obj, node.field, oa, this, node );
            } catch ( ReflectError e ) {
                throw new EvalError(
                        "Error in method invocation: " + e.getMessage(),
                        node, callstack, e );
            } catch ( InvocationTargetException e )
            {
                String msg = "Method Invocation "+node.field;
                Throwable te = e.getTargetException();
                /*
                        Try to squeltch the native code stack trace if the exception
                        was caused by a reflective call back into the bsh interpreter
                        (e.g. eval() or source()
                    */
                boolean isNative = true;
                if ( te instanceof EvalError )
                    if ( te instanceof TargetError )
                        isNative = ((TargetError)te).inNativeCode();
                    else
                        isNative = false;
                throw new TargetError( msg, te, node, callstack, isNative );
            }
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    /**
     array index.
     Must handle toLHS case.
     */
    private Object doIndex( BSHPrimarySuffix node,
            Object obj, boolean toLHS )
            throws EvalError, ReflectError
    {
        int index = BshInterpreterUtil.getIndexAux( obj, this, node );
        if ( toLHS )
            return new LHS(obj, index);
        else
            try {
                return Reflect.getIndex(obj, index);
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
    }
    /**
     Property access.
     Must handle toLHS case.
     */
    private Object doProperty( BSHPrimarySuffix node, boolean toLHS, Object obj )
            throws EvalError
    {
        if(obj == Primitive.VOID)
            throw new EvalError(
                    "Attempt to access property on undefined variable or class name",
                    node, callstack );
        if ( obj instanceof Primitive )
            throw new EvalError("Attempt to access property on a primitive",
                    node, callstack );
        Object value = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        if ( !( value instanceof String ) )
            throw new EvalError(
                    "Property expression must be a String or identifier.",
                    node, callstack );
        if ( toLHS )
            return new LHS(obj, (String)value);
        // Property style access to Hashtable or Map
        CollectionManager cm = CollectionManager.getCollectionManager();
        if ( cm.isMap( obj ) )
        {
            Object val = cm.getFromMap( obj, value/*key*/ );
            return ( val == null ?  val = Primitive.NULL : val );
        }
        try {
            return Reflect.getObjectProperty( obj, (String)value );
        }
        catch ( UtilEvalError e)
        {
            throw e.toEvalError( "Property: "+value, node, callstack );
        }
        catch (ReflectError e)
        {
            throw new EvalError("No such property: " + value, node, callstack );
        }
    }
    @Override
    public Object visit(BSHPrimarySuffix node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimarySuffix class.", node);
    }
    @Override
    public Object visit(BSHPrimitiveType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimitiveType class.", node);
    }
    @Override
    public Object visit(BSHReturnStatement node) {
        Object value;
        if(node.jjtGetNumChildren() > 0)
            value = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        else
            value = Primitive.VOID;
        return new ReturnControl( node.kind, value, node );
    }
    @Override
    public Object visit(BSHReturnType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimarySuffix class.");
    }
    @Override
    public Object visit(BSHStatementExpressionList node) {
        int n = node.jjtGetNumChildren();
        for(int i=0; i<n; i++)
        {
            SimpleNode nn = ((SimpleNode)node.jjtGetChild(i));
            nn.accept(this);
        }
        return Primitive.VOID;
    }
    @Override
    public Object visit(BSHSwitchLabel node) {
        if ( node.isDefault )
            return null; // should probably error
        SimpleNode label = ((SimpleNode)node.jjtGetChild(0));
        return label.accept(this);
    }
    @Override
    public Object visit(BSHSwitchStatement node) {
        int numchild = node.jjtGetNumChildren();
        int child = 0;
        SimpleNode switchExp = ((SimpleNode)node.jjtGetChild(child++));
        Object switchVal = switchExp.accept(this);
        /*
              Note: this could be made clearer by adding an inner class for the
              cases and an object context for the child traversal.
          */
        // first label
        BSHSwitchLabel label;
        Object obj;
        ReturnControl returnControl=null;
        // get the first label
        if ( child >= numchild )
            throw new EvalError("Empty switch statement.", node, callstack );
        label = ((BSHSwitchLabel)node.jjtGetChild(child++));
        // while more labels or blocks and haven't hit return control
        while ( child < numchild && returnControl == null )
        {
            // if label is default or equals switchVal
            if ( label.isDefault
                    || primitiveEquals(node, switchVal, label.accept(this), switchExp) )  {
                // execute nodes, skipping labels, until a break or return
                while ( child < numchild )
                {
                    obj = node.jjtGetChild(child++);
                    if ( obj instanceof BSHSwitchLabel )
                        continue;
                    // eval it
                    Object value =
                            ((SimpleNode)obj).accept(this);
                    // should check to disallow continue here?
                    if ( value instanceof ReturnControl ) {
                        returnControl = (ReturnControl)value;
                        break;
                    }
                }
            } else
            {
                // skip nodes until next label
                while ( child < numchild )
                {
                    obj = node.jjtGetChild(child++);
                    if ( obj instanceof BSHSwitchLabel ) {
                        label = (BSHSwitchLabel)obj;
                        break;
                    }
                }
            }
        }
        if ( returnControl != null && returnControl.kind == ParserConstants.RETURN )
            return returnControl;
        else
            return Primitive.VOID;
    }
    /**
     Helper method for testing equals on two primitive or boxable objects.
     yuck: factor this out into Primitive.java
     */
    public boolean primitiveEquals( BSHSwitchStatement node,
            Object switchVal, Object targetVal,
            SimpleNode switchExp  )
            throws EvalError
    {
        if ( switchVal instanceof Primitive || targetVal instanceof Primitive )
            try {
                // binaryOperation can return Primitive or wrapper type
                Object result = Primitive.binaryOperation(
                        switchVal, targetVal, ParserConstants.EQ );
                result = Primitive.unwrap( result );
                return result.equals( Boolean.TRUE );
            } catch ( UtilEvalError e ) {
                throw e.toEvalError(
                        "Switch value: "+switchExp.getText()+": ",
                        node, callstack );
            }
        else
            return switchVal.equals( targetVal );
    }
    @Override
    public Object visit(BSHTernaryExpression node) {
        SimpleNode
                cond = (SimpleNode)node.jjtGetChild(0),
                evalTrue = (SimpleNode)node.jjtGetChild(1),
                evalFalse = (SimpleNode)node.jjtGetChild(2);
        if ( BshInterpreterUtil.evaluateCondition(cond, this) )
            return evalTrue.accept(this);
        else
            return evalFalse.accept(this);
    }
    @Override
    public Object visit(BSHThrowStatement node) {
        Object obj = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        // need to loosen this to any throwable... do we need to handle
        // that in interpreter somewhere?  check first...
        if(!(obj instanceof Exception))
            throw new EvalError("Expression in 'throw' must be Exception type",
                    node, callstack );
        // wrap the exception in a TargetException to propogate it up
        throw new TargetError( (Exception)obj, node, callstack );
    }
    @Override
    public Object visit(BSHTryStatement node) {
        BSHBlock tryBlock = ((BSHBlock)node.jjtGetChild(0));
        List<BSHFormalParameter> catchParams = new ArrayList<BSHFormalParameter>();
        List<BSHBlock> catchBlocks = new ArrayList<BSHBlock>();
        int nchild = node.jjtGetNumChildren();
        Node nodeObj = null;
        int i=1;
        while((i < nchild) && ((nodeObj = node.jjtGetChild(i++)) instanceof BSHFormalParameter))
        {
            catchParams.add((BSHFormalParameter)nodeObj);
            catchBlocks.add((BSHBlock)node.jjtGetChild(i++));
            nodeObj = null;
        }
        // finaly block
        BSHBlock finallyBlock = null;
        if(nodeObj != null)
            finallyBlock = (BSHBlock)nodeObj;
        // Why both of these?
        TargetError target = null;
        Throwable thrown = null;
        Object ret = null;
        /*
              Evaluate the contents of the try { } block and catch any resulting
              TargetErrors generated by the script.
              We save the callstack depth and if an exception is thrown we pop
              back to that depth before contiuing.  The exception short circuited
              any intervening method context pops.
              Note: we the stack info... what do we do with it?  append
              to exception message?
          */
        int callstackDepth = callstack.depth();
        try {
            ret = tryBlock.accept(this);
        }
        catch( TargetError e ) {
            target = e;
            String stackInfo = "Bsh Stack: ";
            while ( callstack.depth() > callstackDepth )
                stackInfo += "\t" + callstack.pop() +"\n";
        }
        // unwrap the target error
        if ( target != null )
            thrown = target.getTarget();
        // If we have an exception, find a catch
        if (thrown != null)
        {
            int n = catchParams.size();
            for(i=0; i<n; i++)
            {
                // Get catch block
                BSHFormalParameter fp = catchParams.get(i);
                // Should cache this subject to classloader change message
                // Evaluation of the formal parameter simply resolves its
                // type via the specified namespace.. it doesn't modify the
                // namespace.
                fp.accept(this);
                if ( fp.type == null && interpreter.getStrictJava() )
                    throw new EvalError(
                            "(Strict Java) Untyped catch block", node, callstack );
                // If the param is typed check assignability
                if ( fp.type != null )
                    try {
                        thrown = (Throwable)Types.castObject(
                                thrown/*rsh*/, fp.type/*lhsType*/, Types.ASSIGNMENT );
                    } catch( UtilEvalError e ) {
                        /*
                                  Catch the mismatch and continue to try the next
                                  Note: this is innefficient, should have an
                                  isAssignableFrom() that doesn't throw
                                  // TODO: we do now have a way to test assignment
                                  // 	in castObject(), use it?
                              */
                        continue;
                    }
                // Found match, execute catch block
                BSHBlock cb = catchBlocks.get(i);
                // Prepare to execute the block.
                // We must create a new BlockNameSpace to hold the catch
                // parameter and swap it on the stack after initializing it.
                NameSpace enclosingNameSpace = callstack.top();
                BlockNameSpace cbNameSpace =
                        new BlockNameSpace( enclosingNameSpace );
                try {
                    if ( fp.type == BSHFormalParameter.UNTYPED )
                        // set an untyped variable directly in the block
                        cbNameSpace.setBlockVariable( fp.name, thrown );
                    else
                    {
                        // set a typed variable (directly in the block)
                        Modifiers modifiers = new Modifiers();
                        cbNameSpace.setTypedVariable(
                                fp.name, fp.type, thrown, new Modifiers()/*none*/ );
                    }
                } catch ( UtilEvalError e ) {
                    throw new InterpreterError(
                            "Unable to set var in catch block namespace." );
                }
                // put cbNameSpace on the top of the stack
                callstack.swap( cbNameSpace );
                try {
                    ret = cb.accept(this);
                } finally {
                    // put it back
                    callstack.swap( enclosingNameSpace );
                }
                target = null;  // handled target
                break;
            }
        }
        // evaluate finally block
        if( finallyBlock != null ) {
            Object result = finallyBlock.accept(this);
            if( result instanceof ReturnControl )
                return result;
        }
        // exception fell through, throw it upward...
        if(target != null)
            throw target;
        if(ret instanceof ReturnControl)
            return ret;
        else
            return Primitive.VOID;
    }
    @Override
    public Object visit(BSHType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHType class.", node);
    }
    /**
     Returns a class descriptor for this type.
     If the type is an ambiguous name (object type) evaluation is
     attempted through the namespace in order to resolve imports.
     If it is not found and the name is non-compound we assume the default
     package for the name.
     */
    public String getTypeDescriptor( BSHType node, String defaultPackage )
    {
        // return cached type if available
        if ( node.descriptor != null )
            return node.descriptor;
        String descriptor;
        //  first typeNode will either be PrimitiveType or AmbiguousName
        SimpleNode typeNode = node.getTypeNode();
        if ( typeNode instanceof BSHPrimitiveType)
            descriptor = BshInterpreterUtil.getTypeDescriptor( ((BSHPrimitiveType)typeNode).type );
        else
        {
            String clasName = ((BSHAmbiguousName)typeNode).text;
            BshClassManager bcm = interpreter.getClassManager();
            // Note: incorrect here - we are using the hack in bsh class
            // manager that allows lookup by base name.  We need to eliminate
            // this limitation by working through imports.  See notes in class
            // manager.
            String definingClass = bcm.getClassBeingDefined( clasName );
            Class clas = null;
            if ( definingClass == null )
            {
                try {
                    clas = ambiguousNameToClass(((BSHAmbiguousName)typeNode) );
                } catch ( EvalError e ) {
                    //throw new InterpreterError("unable to resolve type: "+e);
                    // ignore and try default package
                    //System.out.println("BSHType: "+typeNode+" class not found");
                }
            } else
                clasName = definingClass;
            if ( clas != null )
            {
                //System.out.println("found clas: "+clas);
                descriptor = BshInterpreterUtil.getTypeDescriptor( clas );
            }else
            {
                if ( defaultPackage == null || Name.isCompound( clasName ) )
                    descriptor = "L" + clasName.replace('.','/') + ";";
                else
                    descriptor =
                            "L"+defaultPackage.replace('.','/')+"/"+clasName + ";";
            }
        }
        for(int i=0; i<node.arrayDims; i++)
            descriptor = "["+descriptor;
        node.descriptor = descriptor;
        //System.out.println("BSHType: returning descriptor: "+descriptor);
        return descriptor;
    }
    public Class getType(BSHType tnode)
            throws EvalError
    {
        // return cached type if available
        if ( tnode.type != null )
            return tnode.type;
        //  first node will either be PrimitiveType or AmbiguousName
        SimpleNode node = tnode.getTypeNode();
        if ( node instanceof BSHPrimitiveType )
            tnode.baseType = ((BSHPrimitiveType)node).getType();
        else
            tnode.baseType = ambiguousNameToClass(((BSHAmbiguousName)node));
        if ( tnode.arrayDims > 0 ) {
            try {
                // Get the type by constructing a prototype array with
                // arbitrary (zero) length in each dimension.
                int[] dims = new int[tnode.arrayDims]; // int array default zeros
                Object obj = Array.newInstance(tnode.baseType, dims);
                tnode.type = obj.getClass();
            } catch(Exception e) {
                throw new EvalError("Couldn't construct array type",
                        tnode, callstack );
            }
        } else
            tnode.type = tnode.baseType;
        // hack... sticking to first interpreter that resolves this
        // see comments on type instance variable
        interpreter.getClassManager().addListener(tnode);
        return tnode.type;
    }
    @Override
    public Object visit(BSHTypedVariableDeclaration node) {
        try {
            NameSpace namespace = callstack.top();
            BSHType typeNode = node.getTypeNode();
            Class type = getType(typeNode);
            BSHVariableDeclarator [] bvda = node.getDeclarators();
            for (int i = 0; i < bvda.length; i++)
            {
                BSHVariableDeclarator dec = bvda[i];
                // Type node is passed down the chain for array initializers
                // which need it under some circumstances
                Object value = evalVariableDeclarator(dec, typeNode);
                try {
                    namespace.setTypedVariable(
                            dec.name, type, value, node.modifiers );
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack );
                }
            }
        } catch ( EvalError e ) {
            e.reThrow( "Typed variable declaration" );
        }
        return Primitive.VOID;
    }
    public Class evalType( BSHTypedVariableDeclaration node )
            throws EvalError
    {
        BSHType typeNode = node.getTypeNode();
        return getType( typeNode );
    }
    @Override
    public Object visit(BSHUnaryExpression node) {
        SimpleNode simpleNode = (SimpleNode)node.jjtGetChild(0);
        // If this is a unary increment of decrement (either pre or postfix)
        // then we need an LHS to which to assign the result.  Otherwise
        // just do the unary operation for the value.
        try {
            if ( node.kind == ParserConstants.INCR || node.kind == ParserConstants.DECR ) {
                LHS lhs = primaryExprToLHS((BSHPrimaryExpression) simpleNode);
                return node.lhsUnaryOperation(lhs, interpreter.getStrictJava());
            } else
                return
                        node.unaryOperation(simpleNode.accept(this), node.kind);
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    /**
     Evaluate the optional initializer value.
     (The name was set at parse time.)
     A variable declarator can be evaluated with or without preceding
     type information. Currently the type info is only used by array
     initializers in the case where there is no explicitly declared type.
     @param typeNode is the BSHType node.  Its info is passed through to any
     variable intializer children for the case where the array initializer
     does not declare the type explicitly. e.g.
     int [] a = { 1, 2 };
     typeNode may be null to indicate no type information available.
     */
    private Object evalVariableDeclarator(BSHVariableDeclarator node, BSHType typeNode)
            throws EvalError
    {
        // null value means no value
        Object value = null;
        if ( node.jjtGetNumChildren() > 0 )
        {
            SimpleNode initializer = (SimpleNode)node.jjtGetChild(0);
            /*
                   If we have type info and the child is an array initializer
                   pass it along...  Else use the default eval style.
                   (This allows array initializer to handle the problem...
                   allowing for future enhancements in loosening types there).
               */
            if ( (typeNode != null)
                    && initializer instanceof BSHArrayInitializer
                    )
                value = evalArrayInitializer(((BSHArrayInitializer) initializer),
                        typeNode.getBaseType(), typeNode.getArrayDims(),
                        callstack, interpreter);
            else
                value = initializer.accept(this);
        }
        if ( value == Primitive.VOID )
            throw new EvalError("Void initializer.", node, callstack );
        return value;
    }
    @Override
    public Object visit(BSHVariableDeclarator node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHVariableDeclarator class.");
    }
    @Override
    public Object visit(BSHWhileStatement node) {
        int numChild = node.jjtGetNumChildren();
        // Order of body and condition is swapped for do / while
        final SimpleNode condExp;
        final SimpleNode body;
        if ( node.isDoStatement ) {
            condExp = (SimpleNode) node.jjtGetChild(1);
            body = (SimpleNode) node.jjtGetChild(0);
        } else {
            condExp = (SimpleNode) node.jjtGetChild(0);
            if ( numChild > 1 )	{
                body = (SimpleNode) node.jjtGetChild(1);
            } else {
                body = null;
            }
        }
        boolean doOnceFlag = node.isDoStatement;
        while (doOnceFlag || BshInterpreterUtil.evaluateCondition(condExp, this)) {
            doOnceFlag = false;
            // no body?
            if ( body == null ) {
                continue;
            }
            Object ret = body.accept(this);
            if (ret instanceof ReturnControl) {
                switch(( (ReturnControl)ret).kind ) {
                    case ParserConstants.RETURN:
                        return ret;
                    case ParserConstants.CONTINUE:
                        break;
                    case ParserConstants.BREAK:
                        return Primitive.VOID;
                }
            }
        }
        return Primitive.VOID;
    }
}
package bsh;
import bsh.ast.SimpleNode;
import java.lang.reflect.InvocationTargetException;
import java.io.PrintStream;
public final class TargetError extends EvalError 
{
	private final boolean inNativeCode;
	public TargetError(
		String msg, Throwable t, SimpleNode node, CallStack callstack,
		boolean inNativeCode )
	{
		super( msg, node, callstack, t );
		this.inNativeCode = inNativeCode;
	}
	public TargetError( Throwable t, SimpleNode node, CallStack callstack )
	{
		this("TargetError", t, node, callstack, false);
	}
	public Throwable getTarget()
	{
		// check for easy mistake
		Throwable target = getCause();
		if(target instanceof InvocationTargetException)
			return((InvocationTargetException)target).getTargetException();
		else
			return target;
	}
	public String getMessage() 
	{
		return super.getMessage() 
			+ "\nTarget exception: " + 
			printTargetError( getCause() );
	}
    public void printStackTrace( boolean debug, PrintStream out ) {
		if ( debug ) {
			super.printStackTrace( out );
			out.println("--- Target Stack Trace ---");
		}
		getCause().printStackTrace( out );
	}
	/**
		Generate a printable string showing the wrapped target exception.
		If the proxy mechanism is available, allow the extended print to
		check for UndeclaredThrowableException and print that embedded error.
	*/
	private String printTargetError( Throwable t ) 
	{
		return getCause().toString() + "\n" + xPrintTargetError( t );
	}
	/**
		Extended form of print target error.
		This indirection is used to print UndeclaredThrowableExceptions 
		which are possible when the proxy mechanism is available.
		We are shielded from compile problems by using a bsh script.
		This is acceptable here because we're not in a critical path...
		Otherwise we'd need yet another dynamically loaded module just for this.
	*/
	private String xPrintTargetError( Throwable t ) 
	{
		String getTarget =
			"import java.lang.reflect.UndeclaredThrowableException;"+
			"String result=\"\";"+
			"while ( target instanceof UndeclaredThrowableException ) {"+
			"	target=target.getUndeclaredThrowable(); " +
			"	result+=\"Nested: \"+target.toString();" +
			"}"+
			"return result;";
		Interpreter i = new Interpreter();
		try {
			i.set("target", t);
			return (String)i.eval( getTarget );
		} catch ( EvalError e ) {
			throw new InterpreterError("xprintarget: "+e.toString() );
		}
	}
	/**
		Return true if the TargetError was generated from native code.
		e.g. if the script called into a compiled java class which threw
		the excpetion.  We distinguish so that we can print the stack trace
		for the native code case... the stack trace would not be useful if
		the exception was generated by the script.  e.g. if the script
		explicitly threw an exception... (the stack trace would simply point
		to the bsh internals which generated the exception).
	*/
	public boolean inNativeCode() { 
		return inNativeCode; 
	}
}
package bsh;
import java.io.Serializable;
import java.util.Stack;
import java.util.EmptyStackException;
public final class CallStack implements Serializable {
	private static final long serialVersionUID = 0L;
	private final Stack<NameSpace> stack = new Stack<NameSpace>();
	public CallStack() { }
	public CallStack( NameSpace namespace ) { 
		push( namespace );
	}
	public void clear() {
		stack.removeAllElements();
	}
	public void push( NameSpace ns ) {
		stack.push( ns );
	}
	public NameSpace top() {
		return stack.peek();
	}
	/**
		zero based.
	*/
	public NameSpace get(int depth) {
		int size = stack.size();
		if ( depth >= size )
			return NameSpace.JAVACODE;
		else
			return stack.get(size-1-depth);
	}
	
	/**
		This is kind of crazy, but used by the setNameSpace command.
		zero based.
	*/
	public void set(int depth, NameSpace ns) {
		stack.set( stack.size()-1-depth, ns );
	}
	public NameSpace pop() {
		try {
			return stack.pop();
		} catch(EmptyStackException e) {
			throw new InterpreterError("pop on empty CallStack");
		}
	}
	/**
		Swap in the value as the new top of the stack and return the old
		value.
	*/
	public NameSpace swap( NameSpace newTop ) {
		int last = stack.size() - 1;
		NameSpace oldTop = stack.get(last);
		stack.set( last, newTop );
		return oldTop;
	}
	public int depth() {
		return stack.size();
	}
/*
	public NameSpace [] toArray() {
		NameSpace [] nsa = new NameSpace [ depth() ];
		stack.copyInto( nsa );
		return nsa;
	}
*/
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("CallStack:\n");
		for( int i=stack.size()-1; i>=0; i-- )
			sb.append("\t"+stack.get(i)+"\n");
		return sb.toString();
	}
	/**
		Occasionally we need to freeze the callstack for error reporting
		purposes, etc.
	*/
	public CallStack copy() {
		CallStack cs = new CallStack();
		cs.stack.addAll(this.stack);
		return cs;
	}
}
package bsh;
import bsh.classpath.ClassManagerImpl;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.*;
import java.util.Map;
public class PreparsedScript {
	private final BshMethod _method;
	private final Interpreter _interpreter;
	public PreparsedScript(final String source) throws EvalError {
		this(source, getDefaultClassLoader());
	}
	private static ClassLoader getDefaultClassLoader() {
		ClassLoader cl = null;
		try {
			cl = Thread.currentThread().getContextClassLoader();
		} catch (final SecurityException e) {
			// ignore
		}
		if (cl == null) {
			cl = PreparsedScript.class.getClassLoader();
		}
		if (cl != null) {
			return cl;
		}
		return ClassLoader.getSystemClassLoader();
	}
	public PreparsedScript(final String source, final ClassLoader classLoader) throws EvalError {
		final ClassManagerImpl classManager = new ClassManagerImpl();
		classManager.setClassLoader(classLoader);
		final NameSpace nameSpace = new NameSpace(classManager, "global");
		_interpreter = new Interpreter(new StringReader(""), System.out, System.err, false, nameSpace, null, null);
		try {
			final This callable = (This) _interpreter.eval("__execute() { " + source + "\n" + "}\n" + "return this;");
			_method = callable.getNameSpace().getMethod("__execute", new Class[0], false);
		} catch (final UtilEvalError e) {
			throw new IllegalStateException(e);
		}
	}
	public Object invoke(final Map<String, ?> context) throws EvalError {
		final NameSpace nameSpace = new NameSpace(_interpreter.getClassManager(), "BeanshellExecutable");
		nameSpace.setParent(_interpreter.getNameSpace());
		final BshMethod method = new BshMethod(_method.getName(), _method.getReturnType(), _method.getParameterNames(), _method.getParameterTypes(), _method.methodBody, nameSpace, _method.getModifiers());
		for (final Map.Entry<String, ?> entry : context.entrySet()) {
			try {
				nameSpace.setVariable(entry.getKey(), entry.getValue(), false);
			} catch (final UtilEvalError e) {
				throw new EvalError("cannot set variable '" + entry.getKey() + '\'', null, null, e);
			}
		}
		final Object result = method.invoke(new Object[0], new BshEvaluatingVisitor(null, _interpreter));
		if (result instanceof Primitive) {
			if (( (Primitive) result).getType() == Void.TYPE) {
				return null;
			}
			return ( (Primitive) result).getValue();
		}
		return result;
	}
	public void setOut(final PrintStream value) {
		_interpreter.setOut(value);
	}
	public void setErr(final PrintStream value) {
		_interpreter.setErr(value);
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
public class Name implements java.io.Serializable
{
	// These do not change during evaluation
	public NameSpace namespace;
	String value = null;
	
	// ---------------------------------------------------------
	// The following instance variables mutate during evaluation and should
	// be reset by the reset() method where necessary
	// For evaluation
	/** Remaining text to evaluate */
	private String evalName;
	/** 
		The last part of the name evaluated.  This is really only used for
	 	this, caller, and super resolution.
	*/
	private String lastEvalName;
	private static String FINISHED = null; // null evalname and we're finished
	private Object evalBaseObject;	// base object for current eval
	private int callstackDepth;		// number of times eval hit 'this.caller'
	//  
	//  End mutable instance variables.
	// ---------------------------------------------------------
	// Begin Cached result structures
	// These are optimizations 
	// Note: it's ok to cache class resolution here because when the class
	// space changes the namespace will discard cached names.
	/** 
		The result is a class 
	*/
	Class asClass;
	/** 
		The result is a static method call on the following class 
	*/
	Class classOfStaticMethod;
	// End Cached result structures
	private void reset() {
		evalName = value;
		evalBaseObject = null;
		callstackDepth = 0;
	}
	/**
		This constructor should *not* be used in general. 
		Use NameSpace getNameResolver() which supports caching.
		@see NameSpace getNameResolver().
	*/
	// I wish I could make this "friendly" to only NameSpace
	Name( NameSpace namespace, String s )
	{
		this.namespace = namespace;
		value = s;
	}
	/**
		Resolve possibly complex name to an object value.
		Throws EvalError on various failures.
		A null object value is indicated by a Primitive.NULL.
		A return type of Primitive.VOID comes from attempting to access
		an undefined variable.
		Some cases:
			myVariable
			myVariable.foo
			myVariable.foo.bar
			java.awt.GridBagConstraints.BOTH
			my.package.stuff.MyClass.someField.someField...
		Interpreter reference is necessary to allow resolution of 
		"this.interpreter" magic field.
		CallStack reference is necessary to allow resolution of 
		"this.caller" magic field.
		"this.callstack" magic field.
	*/
	public Object toObject( BshEvaluatingVisitor visitor )
		throws UtilEvalError
	{
		return toObject( visitor, false );
	}
	/**
		see #toObject(CallStack, Interpreter)
		@param forceClass if true then resolution will only produce a class.
		This is necessary to disambiguate in cases where the grammar knows
		that we want a class; where in general the var path may be taken.
	*/
	synchronized public Object toObject( 
		BshEvaluatingVisitor visitor, boolean forceClass )
		throws UtilEvalError
	{
		reset();
		Object obj = null;
		while( evalName != null )
			obj = consumeNextObjectField(visitor, forceClass, false/*autoalloc*/  );
		if ( obj == null )
			throw new InterpreterError("null value in toObject()");
		return obj;
	}
	private Object completeRound( 
		String lastEvalName, String nextEvalName, Object returnObject )
	{
		if ( returnObject == null )
			throw new InterpreterError("lastEvalName = "+lastEvalName);
		this.lastEvalName = lastEvalName;
		this.evalName = nextEvalName;
		this.evalBaseObject = returnObject;
		return returnObject;
	}
	/**
		Get the next object by consuming one or more components of evalName.  
		Often this consumes just one component, but if the name is a classname 
		it will consume all of the components necessary to make the class 
		identifier.
	*/
	private Object consumeNextObjectField( 	
		BshEvaluatingVisitor visitor,
		boolean forceClass, boolean autoAllocateThis ) 
		throws UtilEvalError
	{
		/*
			Is it a simple variable name?
			Doing this first gives the correct Java precedence for vars 
			vs. imported class names (at least in the simple case - see
			tests/precedence1.bsh).  It should also speed things up a bit.
		*/
		if ( (evalBaseObject == null && !isCompound(evalName) )
			&& !forceClass ) 
		{
			Object obj = resolveThisFieldReference( visitor,
				namespace, evalName, false );
			if ( obj != Primitive.VOID )
				return completeRound( evalName, FINISHED, obj );
		}
		/*
			Is it a bsh script variable reference?
			If we're just starting the eval of name (no base object)
			or we're evaluating relative to a This type reference check.
		*/
		String varName = prefix(evalName, 1);
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug("trying to resolve variable: " + varName);
			Object obj;
			// switch namespace and special var visibility
			if ( evalBaseObject == null ) {
				obj = resolveThisFieldReference(visitor, namespace, varName, false );
			} else {
				obj = resolveThisFieldReference(visitor,
					((This)evalBaseObject).namespace,
					varName, true );
			}
			if ( obj != Primitive.VOID ) 
			{
				// Resolved the variable
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( "resolved variable: " + varName + 
					" in namespace: "+namespace);
				return completeRound( varName, suffix(evalName), obj );
			}
		}
		/*
			Is it a class name?
			If we're just starting eval of name try to make it, else fail.
		*/
		if ( evalBaseObject == null ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( "trying class: " + evalName);
			
			/*
				Keep adding parts until we have a class 
			*/
			Class clas = null;
			int i = 1;
			String className = null;
			for(; i <= countParts(evalName); i++)
			{
				className = prefix(evalName, i);
				if ( (clas = namespace.getClass(className)) != null )
					break;
			}
		
			if ( clas != null )  {
				return completeRound(
					className,
					suffix( evalName, countParts(evalName)-i ),
					new ClassIdentifier(clas) 
				);
			}
			// not a class (or variable per above)
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( "not a class, trying var prefix "+evalName );
		}
		// No variable or class found in 'this' type ref.
		// if autoAllocateThis then create one; a child 'this'.
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass && autoAllocateThis )
		{
			NameSpace targetNameSpace = 
				( evalBaseObject == null ) ?  
					namespace : ((This)evalBaseObject).namespace;
			Object obj = new NameSpace( 
				targetNameSpace, "auto: "+varName ).getThis( visitor.getInterpreter() );
			targetNameSpace.setVariable( varName, obj, false );
			return completeRound( varName, suffix(evalName), obj );
		}
		/*
			If we didn't find a class or variable name (or prefix) above
			there are two possibilities:
			- If we are a simple name then we can pass as a void variable 
			reference.
			- If we are compound then we must fail at this point.
		*/
		if ( evalBaseObject == null ) {
			if ( !isCompound(evalName) ) {
				return completeRound( evalName, FINISHED, Primitive.VOID );
			} else
				throw new UtilEvalError(
					"Class or variable not found: " + evalName);
		}
		/*
			--------------------------------------------------------
			After this point we're definitely evaluating relative to
			a base object.
			--------------------------------------------------------
		*/
		/*
			Do some basic validity checks.
		*/
		if ( evalBaseObject == Primitive.NULL) // previous round produced null
			throw new UtilTargetError( new NullPointerException( 
				"Null Pointer while evaluating: " +value ) );
		if ( evalBaseObject == Primitive.VOID) // previous round produced void
			throw new UtilEvalError(
				"Undefined variable or class name while evaluating: "+value);
		if ( evalBaseObject instanceof Primitive)
			throw new UtilEvalError("Can't treat primitive like an object. "+
			"Error while evaluating: "+value);
		/* 
			Resolve relative to a class type
			static field, inner class, ?
		*/
		if ( evalBaseObject instanceof ClassIdentifier ) 
		{
			Class clas = ((ClassIdentifier)evalBaseObject).getTargetClass();
			String field = prefix(evalName, 1);
			// Class qualified 'this' reference from inner class.
			// e.g. 'MyOuterClass.this'
			if ( field.equals("this") )
			{
				// find the enclosing class instance space of the class name
				NameSpace ns = namespace;
				while ( ns != null )
				{
					// getClassInstance() throws exception if not there
					if ( ns.classInstance != null 
						&& ns.classInstance.getClass() == clas 
					)
						return completeRound( 
							field, suffix(evalName), ns.classInstance );
					ns=ns.getParent();
				}
				throw new UtilEvalError(
					"Can't find enclosing 'this' instance of class: "+clas);
			}
			Object obj = null;
			// static field?
			try {
				if ( Interpreter.DEBUG ) 
					Interpreter.debug("Name call to getStaticFieldValue, class: "
						+clas+", field:"+field);
				obj = Reflect.getStaticFieldValue(clas, field);
			} catch( ReflectError e ) { 
				if ( Interpreter.DEBUG ) 
					Interpreter.debug("field reflect error: "+e);
			}
			// inner class?
			if ( obj == null ) {
				String iclass = clas.getName()+"$"+field;
				Class c = namespace.getClass( iclass );
				if ( c != null )
					obj = new ClassIdentifier(c);
			}
			if ( obj == null )
				throw new UtilEvalError(
					"No static field or inner class: " 
					+ field + " of " + clas );
			return completeRound( field, suffix(evalName), obj );
		}
		/*
			If we've fallen through here we are no longer resolving to
			a class type.
		*/
		if ( forceClass )
			throw new UtilEvalError( 
				value +" does not resolve to a class name." );
		/* 
			Some kind of field access?
		*/
		String field = prefix(evalName, 1);
		// length access on array? 
		if ( field.equals("length") && evalBaseObject.getClass().isArray() )
		{
			Object obj = new Primitive(Array.getLength(evalBaseObject));
			return completeRound( field, suffix(evalName), obj );
		}
		// Check for field on object 
		// Note: could eliminate throwing the exception somehow
		try {
			Object obj = Reflect.getObjectFieldValue(evalBaseObject, field);
			return completeRound( field, suffix(evalName), obj );
		} catch(ReflectError e) { /* not a field */ }
	
		// if we get here we have failed
		throw new UtilEvalError(
			"Cannot access field: " + field + ", on object: " + evalBaseObject);
	}
	/**
		Resolve a variable relative to a This reference.
		This is the general variable resolution method, accomodating special
		fields from the This context.  Together the namespace and interpreter
		comprise the This context.  The callstack, if available allows for the
		this.caller construct.  
		Optionally interpret special "magic" field names: e.g. interpreter.
		<p/>
		@param visitor may be null, but this is only legitimate in special
		cases where we are sure resolution will not involve this.caller.
		@param thisNameSpace the namespace of the this reference (should be the
		same as the top of the stack?
	*/
	Object resolveThisFieldReference( BshEvaluatingVisitor visitor,
		NameSpace thisNameSpace,
		String varName, boolean specialFieldsVisible ) 
		throws UtilEvalError
	{
		if ( varName.equals("this") ) 
		{
			/*
				Somewhat of a hack.  If the special fields are visible (we're
				operating relative to a 'this' type already) dissallow further
				.this references to prevent user from skipping to things like
				super.this.caller
			*/
			if ( specialFieldsVisible )
				throw new UtilEvalError("Redundant to call .this on This type");
			// Allow getThis() to work through BlockNameSpace to the method
			// namespace
	// XXX re-eval this... do we need it?
			This ths = thisNameSpace.getThis( visitor.getInterpreter() );
			thisNameSpace= ths.getNameSpace();
			Object result = ths;
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				if ( isCompound( evalName ) )
					result = classNameSpace.getThis( visitor.getInterpreter() );
				else
					result = classNameSpace.getClassInstance();
			}
			return result;
		}
		/*
			Some duplication for "super".  See notes for "this" above
			If we're in an enclsing class instance and have a superclass
			instance our super is the superclass instance.
		*/
		if ( varName.equals("super") ) 
		{
			//if ( specialFieldsVisible )
			//throw new UtilEvalError("Redundant to call .this on This type");
			// Allow getSuper() to through BlockNameSpace to the method's super
			This ths = thisNameSpace.getSuper( visitor.getInterpreter() );
			thisNameSpace = ths.getNameSpace();
			// super is now the closure's super or class instance
	// XXXX re-evaluate this
	// can getSuper work by itself now?
			// If we're a class instance and the parent is also a class instance
			// then super means our parent.
			if ( 
				thisNameSpace.getParent() != null 
				&& thisNameSpace.getParent().isClass
			)
				ths = thisNameSpace.getParent().getThis( visitor.getInterpreter() );
			return ths;
		}
		Object obj = null;
		if ( varName.equals("global") )
			obj = thisNameSpace.getGlobal( visitor.getInterpreter() );
		if ( obj == null && specialFieldsVisible ) 
		{
			if (varName.equals("namespace"))
				obj = thisNameSpace;
			else if (varName.equals("variables"))
				obj = thisNameSpace.getVariableNames();
			else if (varName.equals("methods"))
				obj = thisNameSpace.getMethodNames();
			else if ( varName.equals("interpreter") )
				if ( lastEvalName.equals("this") )
					obj = visitor.getInterpreter();
				else
					throw new UtilEvalError(
						"Can only call .interpreter on literal 'this'");
		}
		if ( obj == null && specialFieldsVisible && varName.equals("caller") )
		{
			if ( lastEvalName.equals("this") || lastEvalName.equals("caller") ) 
			{
				// get the previous context (see notes for this class)
				if ( visitor.getInterpreter() == null )
					throw new InterpreterError("no callstack");
				obj = visitor.getCallstack().get( ++callstackDepth ).getThis(
					visitor.getInterpreter() );
			}
			else
				throw new UtilEvalError(
				"Can only call .caller on literal 'this' or literal '.caller'");
			// early return
			return obj;
		}
		if ( obj == null && specialFieldsVisible 
			&& varName.equals("callstack") )
		{
			if ( lastEvalName.equals("this") ) 
			{
				// get the previous context (see notes for this class)
				if ( visitor.getCallstack() == null )
					throw new InterpreterError("no callstack");
				obj = visitor.getCallstack();
			}
			else
				throw new UtilEvalError(
				"Can only call .callstack on literal 'this'");
		}
		if ( obj == null )
			obj = thisNameSpace.getVariable(varName);
		if ( obj == null )
			throw new InterpreterError("null this field ref:"+varName);
		return obj;
	}
	/**
		@return the enclosing class body namespace or null if not in a class.
	*/
	public static NameSpace getClassNameSpace( NameSpace thisNameSpace )
	{
		// is a class instance
		//if ( thisNameSpace.classInstance != null )
		if ( thisNameSpace.isClass )
			return thisNameSpace;
		if ( thisNameSpace.isMethod 
			&& thisNameSpace.getParent() != null 
			//&& thisNameSpace.getParent().classInstance != null
			&& thisNameSpace.getParent().isClass
		)
			return thisNameSpace.getParent();
		return null;
	}
	/**
		Check the cache, else use toObject() to try to resolve to a class
		identifier.  
		@throws ClassNotFoundException on class not found.
		@throws ClassPathException (type of EvalError) on special case of 
		ambiguous unqualified name after super import. 
	*/
	synchronized public Class toClass() 
		throws ClassNotFoundException, UtilEvalError
	{
		if ( asClass != null )
			return asClass;
		reset();
		// "var" means untyped, return null class
		if ( evalName.equals("var") )
			return asClass = null;
		/* Try straightforward class name first */
		Class clas = namespace.getClass( evalName );
		if ( clas == null ) 
		{
			/* 
				Try toObject() which knows how to work through inner classes
				and see what we end up with 
			*/
			Object obj = null;
			try {
				// Null interpreter and callstack references.
				// class only resolution should not require them.
				obj = toObject( new BshEvaluatingVisitor(null, null), true );
			} catch ( UtilEvalError  e ) { }; // couldn't resolve it
		
			if ( obj instanceof ClassIdentifier )
				clas = ((ClassIdentifier)obj).getTargetClass();
		}
		if ( clas == null )
			throw new ClassNotFoundException(
				"Class: " + value+ " not found in namespace");
		asClass = clas;
		return asClass;
	}
	/*
	*/
	synchronized public LHS toLHS( 
		BshEvaluatingVisitor visitor )
		throws UtilEvalError
	{
		// Should clean this up to a single return statement
		reset();
		LHS lhs;
		// Simple (non-compound) variable assignment e.g. x=5;
		if ( !isCompound(evalName) ) 
		{
			if ( evalName.equals("this") )
				throw new UtilEvalError("Can't assign to 'this'." );
			// Interpreter.debug("Simple var LHS...");
			lhs = new LHS( namespace, evalName, false/*bubble up if allowed*/);
			return lhs;
		}
		// Field e.g. foo.bar=5;
		Object obj = null;
		try {
			while( evalName != null && isCompound( evalName ) )
			{
				obj = consumeNextObjectField( visitor,
					false/*forcclass*/, true/*autoallocthis*/ );
			}
		} 
		catch( UtilEvalError e ) {
			throw new UtilEvalError( "LHS evaluation: " + e.getMessage() );
		}
		// Finished eval and its a class.
		if ( evalName == null && obj instanceof ClassIdentifier )
			throw new UtilEvalError("Can't assign to class: " + value );
		if ( obj == null )
			throw new UtilEvalError("Error in LHS: " + value );
		// e.g. this.x=5;  or someThisType.x=5;
		if ( obj instanceof This )
		{
			// dissallow assignment to magic fields
			if ( 
				evalName.equals("namespace")
				|| evalName.equals("variables")
				|| evalName.equals("methods")
				|| evalName.equals("caller")
			)
				throw new UtilEvalError(
					"Can't assign to special variable: "+evalName );
			Interpreter.debug("found This reference evaluating LHS");
			/*
				If this was a literal "super" reference then we allow recursion
				in setting the variable to get the normal effect of finding the
				nearest definition starting at the super scope.  On any other
				resolution qualified by a 'this' type reference we want to set
				the variable directly in that scope. e.g. this.x=5;  or 
				someThisType.x=5;
				
				In the old scoping rules super didn't do this.
			*/
			boolean localVar = !lastEvalName.equals("super");
			return new LHS( ((This)obj).namespace, evalName, localVar );
		}
		if ( evalName != null )
		{
			try {
				if ( obj instanceof ClassIdentifier ) 
				{
					Class clas = ((ClassIdentifier)obj).getTargetClass();
					lhs = Reflect.getLHSStaticField(clas, evalName);
					return lhs;
				} else {
					lhs = Reflect.getLHSObjectField(obj, evalName);
					return lhs;
				}
			} catch(ReflectError e) {
				throw new UtilEvalError("Field access: "+e);
			}
		}
		throw new InterpreterError("Internal error in lhs...");
	}
	
    /**
		Invoke the method identified by this name.
		Performs caching of method resolution using SignatureKey.
		<p>
        Name contains a wholely unqualfied messy name; resolve it to 
		( object | static prefix ) + method name and invoke.
		<p>
        The interpreter is necessary to support 'this.interpreter' references
		in the called code. (e.g. debug());
		<p>
		<pre>
        Some cases:
            // dynamic
            local();
            myVariable.foo();
            myVariable.bar.blah.foo();
            // static
            java.lang.Integer.getInteger("foo");
		</pre>
    */
    public Object invokeMethod( BshEvaluatingVisitor visitor,
		Object[] args,
		SimpleNode callerInfo
	)
        throws UtilEvalError, EvalError, ReflectError, InvocationTargetException
    {
        String methodName = Name.suffix(value, 1);
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		NameSpace namespace = visitor.getCallstack().top();
		// Optimization - If classOfStaticMethod is set then we have already 
		// been here and determined that this is a static method invocation.
		// Note: maybe factor this out with path below... clean up.
        if ( classOfStaticMethod != null )
		{
			return Reflect.invokeStaticMethod( 
				bcm, classOfStaticMethod, methodName, args );
		}
		if ( !Name.isCompound(value) )
			return invokeLocalMethod( visitor,
				args, callerInfo );
		// Note: if we want methods declared inside blocks to be accessible via
		// this.methodname() inside the block we could handle it here as a
		// special case.  See also resolveThisFieldReference() special handling
		// for BlockNameSpace case.  They currently work via the direct name
		// e.g. methodName().
        String prefix = Name.prefix(value);
		// Superclass method invocation? (e.g. super.foo())
		if ( prefix.equals("super") && Name.countParts(value) == 2 )
		{
			// Allow getThis() to work through block namespaces first
			This ths = namespace.getThis( visitor.getInterpreter() );
			NameSpace thisNameSpace = ths.getNameSpace();
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				Object instance = classNameSpace.getClassInstance();
				return ClassGenerator.getClassGenerator()
					.invokeSuperclassMethod( bcm, instance, methodName, args );
			}
		}
        // Find target object or class identifier
        Name targetName = namespace.getNameResolver( prefix );
        Object obj = targetName.toObject( visitor );
		if ( obj == Primitive.VOID ) 
			throw new UtilEvalError( "Attempt to resolve method: "+methodName
					+"() on undefined variable or class name: "+targetName);
        // if we've got an object, resolve the method
        if ( !(obj instanceof ClassIdentifier) ) {
            if (obj instanceof Primitive) {
                if (obj == Primitive.NULL)
                    throw new UtilTargetError( new NullPointerException( 
						"Null Pointer in Method Invocation of " +methodName
							+"() on variable: "+targetName) );
                // some other primitive
                // should avoid calling methods on primitive, as we do
                // in Name (can't treat primitive like an object message)
                // but the hole is useful right now.
				if ( Interpreter.DEBUG )
                	visitor.getInterpreter().debug(
					"Attempt to access method on primitive..." 
					+ " allowing bsh.Primitive to peek through for debugging");
            }
            // found an object and it's not an undefined variable
            return Reflect.invokeObjectMethod(obj, methodName, args, visitor, callerInfo );
        }
		// It's a class
        // try static method
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug("invokeMethod: trying static - " + targetName);
        Class clas = ((ClassIdentifier)obj).getTargetClass();
		// cache the fact that this is a static method invocation on this class
		classOfStaticMethod = clas;
		
        if ( clas != null )
			return Reflect.invokeStaticMethod( bcm, clas, methodName, args );
        // return null; ???
		throw new UtilEvalError("invokeMethod: unknown target: " + targetName);
    }
	/**
		Invoke a locally declared method or a bsh command.
		If the method is not already declared in the namespace then try
		to load it as a resource from the imported command path (e.g.
		/bsh/commands)
	*/
	/*
		Note: the bsh command code should probably not be here...  we need to
		scope it by the namespace that imported the command... so it probably
		needs to be integrated into NameSpace.
	*/
    private Object invokeLocalMethod( BshEvaluatingVisitor visitor,
		Object[] args,
		SimpleNode callerInfo
	)
        throws EvalError/*, ReflectError, InvocationTargetException*/
    {
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug( "invokeLocalMethod: " + value );
		if ( visitor.getInterpreter() == null )
			throw new InterpreterError(
				"invokeLocalMethod: interpreter = null");
		String commandName = value;
		Class [] argTypes = Types.getTypes( args );
        // Check for existing method
        BshMethod meth = null;
		try {
			meth = namespace.getMethod( commandName, argTypes );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(
				"Local method invocation", callerInfo, visitor.getCallstack() );
		}
		// If defined, invoke it
        if ( meth != null )
			return meth.invoke( args, visitor, callerInfo );
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		// Look for a BeanShell command
		Object commandObject;
		try {
			commandObject = namespace.getCommand( 
				commandName, argTypes, visitor.getInterpreter() );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError("Error loading command: ", 
				callerInfo, visitor.getCallstack() );
		}
		// should try to print usage here if nothing found
		if ( commandObject == null )
		{
			// Look for a default invoke() handler method in the namespace
			// Note: this code duplicates that in This.java... should it?
			// Call on 'This' can never be a command
			BshMethod invokeMethod = null;
			try {
				invokeMethod = namespace.getMethod( 
					"invoke", new Class [] { null, null } );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					"Local method invocation", callerInfo, visitor.getCallstack() );
			}
			if ( invokeMethod != null )
				return invokeMethod.invoke( 
					new Object [] { commandName, args },
                        visitor,
					callerInfo );
            throw new EvalError( "Command not found: " 
				+StringUtil.methodString( commandName, argTypes ), 
				callerInfo, visitor.getCallstack() );
		}
		if ( commandObject instanceof BshMethod )
			return ((BshMethod)commandObject).invoke( 
				args, visitor, callerInfo );
		if ( commandObject instanceof Class )
			try {
				return Reflect.invokeCompiledCommand( 
					((Class)commandObject), args, visitor );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError("Error invoking compiled command: ",
				callerInfo, visitor.getCallstack() );
			}
		throw new InterpreterError("invalid command type");
    }
/*
	private String getHelp( String name )
		throws UtilEvalError
	{
		try {
			// should check for null namespace here
			return get( "bsh.help."+name, null/interpreter/ );
		} catch ( Exception e ) {
			return "usage: "+name;
		}
	}
	private String getHelp( Class commandClass )
		throws UtilEvalError
	{
        try {
            return (String)Reflect.invokeStaticMethod(
				null/bcm/, commandClass, "usage", null );
        } catch( Exception e )
			return "usage: "+name;
		}
	}
*/
	// Static methods that operate on compound ('.' separated) names
	// I guess we could move these to StringUtil someday
	public static boolean isCompound(String value)
	{
		return value.indexOf('.') != -1 ;
		//return countParts(value) > 1;
	}
	static int countParts(String value)
	{
		if(value == null)
			return 0;
		int count = 0;
		int index = -1;
		while((index = value.indexOf('.', index + 1)) != -1)
			count++;
		return count + 1;
	}
	static String prefix(String value)
	{
		if(!isCompound(value))
			return null;
		return prefix(value, countParts(value) - 1);
	}
	static String prefix(String value, int parts)
	{
		if (parts < 1 )
			return null;
		int count = 0;
		int index = -1;
		while( ((index = value.indexOf('.', index + 1)) != -1) 
			&& (++count < parts) )
		{ ; }
		return (index == -1) ? value : value.substring(0, index);
	}
	static String suffix(String name)
	{
		if(!isCompound(name))
			return null;
		return suffix(name, countParts(name) - 1);
	}
	public static String suffix(String value, int parts)
	{
		if (parts < 1)
			return null;
		int count = 0;
		int index = value.length() + 1;
		while ( ((index = value.lastIndexOf('.', index - 1)) != -1) 
			&& (++count < parts) );
		return (index == -1) ? value : value.substring(index + 1);
	}
	// end compound name routines
	public String toString() { return value; }
}
package bsh;
import javax.script.AbstractScriptEngine;
import javax.script.Bindings;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.Invocable;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineFactory;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/*
	Adopted from http://ikayzo.org/svn/beanshell/BeanShell/engine/src/bsh/engine/BshScriptEngine.java
	Notes
	This engine supports open-ended pluggable scriptcontexts
*/
public class BshScriptEngine extends AbstractScriptEngine implements Compilable, Invocable {
	// The BeanShell global namespace for the interpreter is stored in the
	// engine scope map under this key.
	static final String engineNameSpaceKey = "org_beanshell_engine_namespace";
	private BshScriptEngineFactory factory;
	private bsh.Interpreter interpreter;
	public BshScriptEngine() {
		this(null);
	}
	public BshScriptEngine(BshScriptEngineFactory factory) {
		this.factory = factory;
		getInterpreter(); // go ahead and prime the interpreter now
	}
	protected Interpreter getInterpreter() {
		if (interpreter == null) {
			this.interpreter = new bsh.Interpreter();
			interpreter.setNameSpace(null); // should always be set by context
		}
		return interpreter;
	}
	public Object eval(String script, ScriptContext scriptContext) throws ScriptException {
		return evalSource(script, scriptContext);
	}
	public Object eval(Reader reader, ScriptContext scriptContext) throws ScriptException {
		return evalSource(reader, scriptContext);
	}
	/*
		This is the primary implementation method.
		We respect the String/Reader difference here in BeanShell because
		BeanShell will do a few extra things in the string case... e.g.
		tack on a trailing ";" semicolon if necessary.
	*/
	private Object evalSource(Object source, ScriptContext scriptContext) throws ScriptException {
		bsh.NameSpace contextNameSpace = getEngineNameSpace(scriptContext);
		Interpreter bsh = getInterpreter();
		bsh.setNameSpace(contextNameSpace);
		bsh.setOut(toPrintStream(scriptContext.getWriter()));
		bsh.setErr(toPrintStream(scriptContext.getErrorWriter()));
		try {
			if (source instanceof Reader) {
				return bsh.eval((Reader) source);
			} else {
				return bsh.eval((String) source);
			}
		//} catch (ParseException e) {
			// explicit parsing error  TODO how to handle parse exception ?
			//throw new ScriptException(e.toString());
                    //e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (TargetError e) {
			// The script threw an application level exception
			// set it as the cause ?
			ScriptException se = new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
			se.initCause(e.getTarget());
			throw se;
		} catch (EvalError e) {
			// The script couldn't be evaluated properly
			throw new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (InterpreterError e) {
			// The interpreter had a fatal problem
			throw new ScriptException(e.toString());
		}
	}
	private PrintStream toPrintStream(final Writer writer) {
		// This is a big hack, convert writer to PrintStream
		return new PrintStream(new WriterOutputStream(writer));
	}
	/*
		Check the context for an existing global namespace embedded
		in the script context engine scope.  If none exists, ininitialize the
		context with one.
	*/
	private static NameSpace getEngineNameSpace(ScriptContext scriptContext) {
		NameSpace ns = (NameSpace) scriptContext.getAttribute(engineNameSpaceKey, ScriptContext.ENGINE_SCOPE);
		if (ns == null) {
			// Create a global namespace for the interpreter
			Map<String, Object> engineView = new ScriptContextEngineView(scriptContext);
			ns = new ExternalNameSpace(null/*parent*/, "javax_script_context", engineView);
			scriptContext.setAttribute(engineNameSpaceKey, ns, ScriptContext.ENGINE_SCOPE);
		}
		return ns;
	}
	public Bindings createBindings() {
		return new SimpleBindings();
	}
	public ScriptEngineFactory getFactory() {
		if (factory == null) {
			factory = new BshScriptEngineFactory();
		}
		return factory;
	}
	/**
	 * Compiles the script (source represented as a {@code String}) for later
	 * execution.
	 *
	 * @param script The source of the script, represented as a {@code String}.
	 * @return An subclass of {@code CompiledScript} to be executed later
	 *         using one of the {@code eval} methods of {@code CompiledScript}.
	 * @throws ScriptException	  if compilation fails.
	 * @throws NullPointerException if the argument is null.
	 */
	public CompiledScript compile(String script) throws ScriptException {
		try {
			final PreparsedScript preparsed = new PreparsedScript(script);
			return new CompiledScript() {
				@Override
				public Object eval(ScriptContext context) throws ScriptException {
					final HashMap<String, Object> map = new HashMap<String, Object>();
					final List<Integer> scopes = new ArrayList<Integer>(context.getScopes());
					Collections.sort(scopes); // lowest scope at first pos
					Collections.reverse(scopes); // highest scope at first pos
					for (final Integer scope : scopes) {
						map.putAll(context.getBindings(scope));
					}
					preparsed.setOut(toPrintStream(context.getWriter()));
					preparsed.setErr(toPrintStream(context.getErrorWriter()));
					try {
						return preparsed.invoke(map);
					} catch (final EvalError e) {
						throw constructScriptException(e);
					}
				}
				@Override
				public ScriptEngine getEngine() {
					return BshScriptEngine.this;
				}
			};
		} catch (final EvalError e) {
			throw constructScriptException(e);
		}
	}
	private ScriptException constructScriptException(final EvalError e) {
		return new ScriptException(e.getMessage(), e.getErrorSourceFile(), e.getErrorLineNumber());
	}
	private static String convertToString(Reader reader) throws IOException {
		final StringBuffer buffer = new StringBuffer(64);
		char[] cb = new char[64];
		int len;
		while ((len = reader.read(cb)) != -1) {
			buffer.append(cb, 0, len);
		}
		return buffer.toString();
	}
	
	/**
	 * Compiles the script (source read from {@code Reader}) for later
	 * execution.  Functionality is identical to {@code compile(String)} other
	 * than the way in which the source is passed.
	 *
	 * @param script The reader from which the script source is obtained.
	 * @return An implementation of {@code CompiledScript} to be executed
	 *         later using one of its {@code eval} methods of
	 *         {@code CompiledScript}.
	 * @throws ScriptException	  if compilation fails.
	 * @throws NullPointerException if argument is null.
	 */
	public CompiledScript compile(Reader script) throws ScriptException {
		try {
			return compile(convertToString(script));
		} catch (IOException e) {
			throw new ScriptException(e);
		}
	}
	/**
	 * Calls a procedure compiled during a previous script execution, which is
	 * retained in the state of the {@code ScriptEngine{@code .
	 *
	 * @param name The name of the procedure to be called.
	 * @param thiz If the procedure is a member  of a class defined in the script
	 *             and thiz is an instance of that class returned by a previous execution or
	 *             invocation, the named method is called through that instance. If classes are
	 *             not supported in the scripting language or if the procedure is not a member
	 *             function of any class, the argument must be {@code null}.
	 * @param args Arguments to pass to the procedure.  The rules for converting
	 *             the arguments to scripting variables are implementation-specific.
	 * @return The value returned by the procedure.  The rules for converting the
	 *         scripting variable returned by the procedure to a Java Object are
	 *         implementation-specific.
	 * @throws javax.script.ScriptException if an error occurrs during invocation
	 *                                      of the method.
	 * @throws NoSuchMethodException		if method with given name or matching argument
	 *                                      types cannot be found.
	 * @throws NullPointerException		 if method name is null.
	 */
	public Object invokeMethod(Object thiz, String name, Object... args) throws ScriptException, NoSuchMethodException {
		if (!(thiz instanceof bsh.This)) {
			throw new ScriptException("Illegal objec type: " + thiz.getClass());
		}
		bsh.This bshObject = (bsh.This) thiz;
		try {
			return bshObject.invokeMethod(name, args);
		//} catch (ParseException e) {
			// explicit parsing error
		//	throw new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (TargetError e) {
			// The script threw an application level exception
			// set it as the cause ?
			ScriptException se = new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
			se.initCause(e.getTarget());
			throw se;
		} catch (EvalError e) {
			// The script couldn't be evaluated properly
			throw new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (InterpreterError e) {
			// The interpreter had a fatal problem
			throw new ScriptException(e.toString());
		}
	}
	/**
	 * Same as invoke(Object, String, Object...) with {@code null} as the
	 * first argument.  Used to call top-level procedures defined in scripts.
	 *
	 * @param args Arguments to pass to the procedure
	 * @return The value returned by the procedure
	 * @throws javax.script.ScriptException if an error occurrs during invocation
	 *                                      of the method.
	 * @throws NoSuchMethodException		if method with given name or matching
	 *                                      argument types cannot be found.
	 * @throws NullPointerException		 if method name is null.
	 */
	public Object invokeFunction(String name, Object... args) throws ScriptException, NoSuchMethodException {
		return invokeMethod(getGlobal(), name, args);
	}
	/**
	 * Returns an implementation of an interface using procedures compiled in the
	 * interpreter. The methods of the interface may be implemented using the
	 * {@code invoke} method.
	 *
	 * @param clasz The {@code Class} object of the interface to return.
	 * @return An instance of requested interface - null if the requested interface
	 *         is unavailable, i. e. if compiled methods in the
	 *         {@code ScriptEngine} cannot be found matching the ones in the
	 *         requested interface.
	 * @throws IllegalArgumentException if the specified {@code Class} object
	 *                                  does not exist or is not an interface.
	 */
	public <T> T getInterface(Class<T> clasz) {
		return clasz.cast(getGlobal().getInterface(clasz));
	}
	/**
	 * Returns an implementation of an interface using member functions of a
	 * scripting object compiled in the interpreter. The methods of the interface
	 * may be implemented using invoke(Object, String, Object...) method.
	 *
	 * @param thiz  The scripting object whose member functions are used to
	 *              implement the methods of the interface.
	 * @param clasz The {@code Class} object of the interface to return.
	 * @return An instance of requested interface - null if the requested
	 *         interface is unavailable, i. e. if compiled methods in the
	 *         {@code ScriptEngine} cannot be found matching the ones in the
	 *         requested interface.
	 * @throws IllegalArgumentException if the specified {@code Class} object
	 *                                  does not exist or is not an interface, or if the specified Object is null
	 *                                  or does not represent a scripting object.
	 */
	public <T> T getInterface(Object thiz, Class<T> clasz) {
		if (!(thiz instanceof bsh.This)) {
			throw new IllegalArgumentException("invalid object type: " + thiz.getClass());
		}
		bsh.This bshThis = (bsh.This) thiz;
		return clasz.cast(bshThis.getInterface(clasz));
	}
	private bsh.This getGlobal() {
		// requires 2.0b5 to make getThis() public
		return getEngineNameSpace(getContext()).getThis(getInterpreter());
	}
	/*
		This is a total hack.  We need to introduce a writer to the
		Interpreter.
	*/
	class WriterOutputStream extends OutputStream {
		Writer writer;
		WriterOutputStream(Writer writer) {
			this.writer = writer;
		}
		public void write(int b) throws IOException {
			writer.write(b);
		}
		public void flush() throws IOException {
			writer.flush();
		}
		public void close() throws IOException {
			writer.close();
		}
	}
}