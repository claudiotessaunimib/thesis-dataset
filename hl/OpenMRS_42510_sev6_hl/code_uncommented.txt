package org.openmrs.module;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.SortedMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.aopalliance.aop.Advice;
import org.openmrs.GlobalProperty;
import org.openmrs.Privilege;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.Daemon;
import org.openmrs.module.Extension.MEDIA_TYPE;
import org.openmrs.util.CycleException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.Graph;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.context.support.AbstractRefreshableApplicationContext;
import org.springframework.util.StringUtils;
import liquibase.Contexts;
public class ModuleFactory {
	private ModuleFactory() {
	}
	private static final Logger log = LoggerFactory.getLogger(ModuleFactory.class);
	protected static final Cache<String, Module> loadedModules = CacheBuilder.newBuilder()
		.softValues().build();
	protected static final Cache<String, Module> startedModules = CacheBuilder.newBuilder()
		.softValues().build();
	protected static final Map<String, List<Extension>> extensionMap = new HashMap<>();
	protected static final Cache<Module, ModuleClassLoader> moduleClassLoaders = CacheBuilder.newBuilder().weakKeys()
		.softValues().build();
	private static final Map<String, Set<ModuleClassLoader>> providedPackages = new ConcurrentHashMap<>();
	private static final String MODULE_CHANGELOG_FILENAME = "liquibase.xml";
	private static final Cache<String, DaemonToken> daemonTokens = CacheBuilder.newBuilder().softValues().build();
	private static final Set<String> actualStartupOrder = new LinkedHashSet<>();
	public static Module loadModule(File moduleFile) throws ModuleException {
		return loadModule(moduleFile, true);
	}
	public static Module loadModule(File moduleFile, Boolean replaceIfExists) throws ModuleException {
		Module module = new ModuleFileParser(Context.getMessageSourceService()).parse(moduleFile);
		if (module != null) {
			loadModule(module, replaceIfExists);
		}
		return module;
	}
	public static Module loadModule(Module module, Boolean replaceIfExists) throws ModuleException {
		log.debug("Adding module {} to the module queue", module.getName());
		Module oldModule = getLoadedModulesMap().get(module.getModuleId());
		if (oldModule != null) {
			int versionComparison = ModuleUtil.compareVersion(oldModule.getVersion(), module.getVersion());
			if (versionComparison < 0) {
				unloadModule(oldModule);
			} else if (versionComparison == 0) {
				if (replaceIfExists) {
					unloadModule(oldModule);
				} else {
					throw new ModuleException("A module with the same id and version already exists", module.getModuleId());
				}
			} else {
				return oldModule;
			}
		}
		getLoadedModulesMap().put(module.getModuleId(), module);
		return module;
	}
	public static void loadModules() {
		File modulesFolder = ModuleUtil.getModuleRepository();
		log.debug("Loading modules from: {}", modulesFolder.getAbsolutePath());
		File[] files = modulesFolder.listFiles();
		if (modulesFolder.isDirectory() && files != null) {
			loadModules(Arrays.asList(files));
		} else {
			log.error("modules folder: '" + modulesFolder.getAbsolutePath() + "' is not a directory or IO error occurred");
		}
	}
	public static void loadModules(List<File> modulesToLoad) {
		for (File f : modulesToLoad) {
			if (f.exists()) {
				if (!f.getName().startsWith(".")) {
					try {
						Module mod = loadModule(f, true);
						log.debug("Loaded module: " + mod + " successfully");
					}
					catch (Exception e) {
						log.error("Unable to load file in module directory: " + f + ". Skipping file.", e);
					}
				}
			} else {
				log.error("Could not find file in module directory: " + f);
			}
		}
		Map<String, Module> loadedModulesMap = getLoadedModulesMapPackage();
		for (Module m : loadedModulesMap.values()) {
			Map<String, String> startBeforeModules = m.getStartBeforeModulesMap();
			if (startBeforeModules.size() > 0) {
				for (String s : startBeforeModules.keySet()) {
					Module mod = loadedModulesMap.get(s);
					if (mod != null) {
						mod.addRequiredModule(m.getPackageName(), m.getVersion());
					}
				}
			}
		}
	}
	public static void startModules() {
		if (!getLoadedModules().isEmpty()) {
			List<Module> modules = getModulesThatShouldStart();
			try {
				modules = getModulesInStartupOrder(modules);
			}
			catch (CycleException ex) {
				String message = getCyclicDependenciesMessage(ex.getMessage());
				log.error(message, ex);
				notifySuperUsersAboutCyclicDependencies(ex);
				modules = (List<Module>) ex.getExtraData();
			}
			for (Module mod : modules) {
				if (mod.isStarted()) {
					continue;
				}
				if (!requiredModulesStarted(mod)) {
					String message = getFailedToStartModuleMessage(mod);
					log.error(message);
					mod.setStartupErrorMessage(message);
					notifySuperUsersAboutModuleFailure(mod);
					continue;
				}
				try {
					log.debug("starting module: {}", mod.getModuleId());
					startModule(mod);
				}
				catch (Exception e) {
					log.error("Error while starting module: " + mod.getName(), e);
					mod.setStartupErrorMessage("Error while starting module", e);
					notifySuperUsersAboutModuleFailure(mod);
				}
			}
		}
	}
	private static List<Module> getModulesThatShouldStart() {
		List<Module> modules = new ArrayList<>();
		AdministrationService adminService = Context.getAdministrationService();
		for (Module mod : getLoadedModulesCoreFirst()) {
			String key = mod.getModuleId() + ".started";
			String startedProp = adminService.getGlobalProperty(key, null);
			String mandatoryProp = adminService.getGlobalProperty(mod.getModuleId() + ".mandatory", null);
			boolean isCoreToOpenmrs = mod.isCore() && !ModuleUtil.ignoreCoreModules();
			if (startedProp == null || "true".equals(startedProp) || "true".equalsIgnoreCase(mandatoryProp)
				|| mod.isMandatory() || isCoreToOpenmrs) {
				modules.add(mod);
			}
		}
		return modules;
	}
	public static List<Module> getModulesInStartupOrder(Collection<Module> modules) throws CycleException {
		Graph<Module> graph = new Graph<>();
		for (Module mod : modules) {
			graph.addNode(mod);
			for (String key : mod.getRequiredModules()) {
				Module module = getModuleByPackage(key);
				Module fromNode = graph.getNode(module);
				if (fromNode == null) {
					fromNode = module;
				}
				if (fromNode != null) {
					graph.addEdge(graph.new Edge(
						fromNode,
						mod));
				}
			}
			for (String key : mod.getAwareOfModules()) {
				Module module = getModuleByPackage(key);
				Module fromNode = graph.getNode(module);
				if (fromNode == null) {
					fromNode = module;
				}
				if (fromNode != null) {
					graph.addEdge(graph.new Edge(
						fromNode,
						mod));
				}
			}
		}
		return graph.topologicalSort();
	}
	private static void notifySuperUsersAboutModuleFailure(Module mod) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.getAlertService().notifySuperUsers("Module.startupError.notification.message", null, mod.getName());
		}
		catch (Exception e) {
			log.error("Unable to send an alert to the super users", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	private static void notifySuperUsersAboutCyclicDependencies(Exception ex) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
			Context.getAlertService().notifySuperUsers("Module.error.cyclicDependencies", ex, ex.getMessage());
		}
		catch (Exception e) {
			log.error("Unable to send an alert to the super users", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ALERTS);
		}
	}
	public static List<Module> getLoadedModulesCoreFirst() {
		List<Module> list = new ArrayList<>(getLoadedModules());
		final Collection<String> coreModuleIds = ModuleConstants.CORE_MODULES.keySet();
		list.sort((left, right) -> {
			Integer leftVal = coreModuleIds.contains(left.getModuleId()) ? 0 : 1;
			Integer rightVal = coreModuleIds.contains(right.getModuleId()) ? 0 : 1;
			return leftVal.compareTo(rightVal);
		});
		return list;
	}
	private static List<String> getMissingRequiredModules(Module module) {
		List<String> ret = new ArrayList<>();
		for (String moduleName : module.getRequiredModules()) {
			boolean started = false;
			for (Module mod : getStartedModules()) {
				if (mod.getPackageName().equals(moduleName)) {
					String reqVersion = module.getRequiredModuleVersion(moduleName);
					if (reqVersion == null || ModuleUtil.compareVersion(mod.getVersion(), reqVersion) >= 0) {
						started = true;
					}
					break;
				}
			}
			if (!started) {
				String moduleVersion = module.getRequiredModuleVersion(moduleName);
				moduleName = moduleName.replace("org.openmrs.module.", "").replace("org.openmrs.", "");
				ret.add(moduleName + (moduleVersion != null ? " " + moduleVersion : ""));
			}
		}
		return ret;
	}
	public static Collection<Module> getLoadedModules() {
		if (getLoadedModulesMap().size() > 0) {
			return getLoadedModulesMap().values();
		}
		return Collections.emptyList();
	}
	public static Map<String, Module> getLoadedModulesMap() {
		return loadedModules.asMap();
	}
	public static Map<String, Module> getLoadedModulesMapPackage() {
		Map<String, Module> map = new HashMap<>();
		for (Module loadedModule : getLoadedModulesMap().values()) {
			map.put(loadedModule.getPackageName(), loadedModule);
		}
		return map;
	}
	public static Collection<Module> getStartedModules() {
		if (getStartedModulesMap().size() > 0) {
			return getStartedModulesMap().values();
		}
		return Collections.emptyList();
	}
	public static List<Module> getStartedModulesInOrder() {
		List<Module> modules = new ArrayList<>();
		if (actualStartupOrder != null) {
			for (String moduleId : actualStartupOrder) {
				modules.add(getStartedModulesMap().get(moduleId));
			}
		} else {
			modules.addAll(getStartedModules());
		}
		return modules;
	}
	public static Map<String, Module> getStartedModulesMap() {
		return startedModules.asMap();
	}
	public static Module getModuleById(String moduleId) {
		return getLoadedModulesMap().get(moduleId);
	}
	public static Module getStartedModuleById(String moduleId) {
		return getStartedModulesMap().get(moduleId);
	}
	public static Module getModuleByPackage(String modulePackage) {
		for (Module mod : getLoadedModulesMap().values()) {
			if (mod.getPackageName().equals(modulePackage)) {
				return mod;
			}
		}
		return null;
	}
	public static Module startModule(Module module) throws ModuleException {
		return startModule(module, false, null);
	}
	public static Module startModule(Module module, boolean isOpenmrsStartup,
		AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		if (!requiredModulesStarted(module)) {
			int missingModules = 0;
			for (String packageName : module.getRequiredModulesMap().keySet()) {
				Module mod = getModuleByPackage(packageName);
				if (mod == null) {
					missingModules++;
					continue;
				}
				if (!mod.isStarted()) {
					startModule(mod);
				}
			}
			if (missingModules > 0) {
				String message = getFailedToStartModuleMessage(module);
				log.error(message);
				module.setStartupErrorMessage(message);
				notifySuperUsersAboutModuleFailure(module);
				return module;
			}
		}
		return Daemon.startModule(module, isOpenmrsStartup, applicationContext);
	}
	public static Module startModuleInternal(Module module) throws ModuleException {
		return startModuleInternal(module, false, null);
	}
	public static Module startModuleInternal(Module module, boolean isOpenmrsStartup,
		AbstractRefreshableApplicationContext applicationContext) throws ModuleException {
		if (module != null) {
			String moduleId = module.getModuleId();
			try {
				String requireVersion = module.getRequireOpenmrsVersion();
				ModuleUtil.checkRequiredVersion(OpenmrsConstants.OPENMRS_VERSION_SHORT, requireVersion);
				if (!requiredModulesStarted(module)) {
					throw new ModuleException(getFailedToStartModuleMessage(module));
				}
				ModuleClassLoader moduleClassLoader = new ModuleClassLoader(module, ModuleFactory.class.getClassLoader());
				getModuleClassLoaderMap().put(module, moduleClassLoader);
				registerProvidedPackages(moduleClassLoader);
				Map<String, List<Extension>> moduleExtensionMap = new HashMap<>();
				for (Extension ext : module.getExtensions()) {
					String extId = ext.getExtensionId();
					List<Extension> tmpExtensions = moduleExtensionMap.computeIfAbsent(extId, k -> new ArrayList<>());
					tmpExtensions.add(ext);
				}
				Comparator<Extension> sortOrder = (e1, e2) -> Integer.valueOf(e1.getOrder()).compareTo(e2.getOrder());
				for (Map.Entry<String, List<Extension>> moduleExtensionEntry : moduleExtensionMap.entrySet()) {
					List<Extension> sortedModuleExtensions = moduleExtensionEntry.getValue();
					sortedModuleExtensions.sort(sortOrder);
					List<Extension> extensions = getExtensionMap().computeIfAbsent(moduleExtensionEntry.getKey(),
						k -> new ArrayList<>());
					for (Extension ext : sortedModuleExtensions) {
						log.debug("Adding to mapping ext: " + ext.getExtensionId() + " ext.class: " + ext.getClass());
						extensions.add(ext);
					}
				}
				SortedMap<String, String> diffs = SqlDiffFileParser.getSqlDiffs(module);
				try {
					Context.addProxyPrivilege("");
					for (Map.Entry<String, String> entry : diffs.entrySet()) {
						String version = entry.getKey();
						String sql = entry.getValue();
						if (StringUtils.hasText(sql)) {
							runDiff(module, version, sql);
						}
					}
				}
				finally {
					Context.removeProxyPrivilege("");
				}
				runLiquibase(module);
				getStartedModulesMap().put(moduleId, module);
				actualStartupOrder.add(moduleId);
				try {
					saveGlobalProperty(moduleId + ".started", "true", getGlobalPropertyStartedDescription(moduleId));
					saveGlobalProperty(moduleId + ".mandatory", String.valueOf(module.isMandatory()),
						getGlobalPropertyMandatoryModuleDescription(moduleId));
				}
				catch (Exception e) {
					log.debug("Got an error when trying to set the global property on module startup", e);
				}
				if (!module.getPrivileges().isEmpty() || !module.getGlobalProperties().isEmpty()) {
					log.debug("Updating core dataset");
					Context.checkCoreDataset();
				}
				try {
					if (module.getModuleActivator() != null) {
						module.getModuleActivator().willStart();
					}
				}
				catch (ModuleException e) {
					throw e;
				}
				catch (Exception e) {
					throw new ModuleException("Error while calling module's Activator.startup()/willStart() method", e);
				}
				module.clearStartupError();
			}
			catch (Exception e) {
				log.warn("Error while trying to start module: " + moduleId, e);
				module.setStartupErrorMessage("Error while trying to start module", e);
				notifySuperUsersAboutModuleFailure(module);
				try {
					boolean skipOverStartedProperty = false;
					if (e instanceof ModuleMustStartException) {
						skipOverStartedProperty = true;
					}
					stopModule(module, skipOverStartedProperty, true);
				}
				catch (Exception e2) {
					log.debug("Error while stopping module: " + moduleId, e2);
				}
			}
		}
		if (applicationContext != null) {
			ModuleUtil.refreshApplicationContext(applicationContext, isOpenmrsStartup, module);
		}
		return module;
	}
	private static void registerProvidedPackages(ModuleClassLoader moduleClassLoader) {
		for (String providedPackage : moduleClassLoader.getProvidedPackages()) {
			Set<ModuleClassLoader> newSet = new HashSet<>();
			Set<ModuleClassLoader> set = providedPackages.get(providedPackage);
			if (set != null) {
				newSet.addAll(set);
			}
			newSet.add(moduleClassLoader);
			providedPackages.put(providedPackage, newSet);
		}
	}
	private static void unregisterProvidedPackages(ModuleClassLoader moduleClassLoader) {
		for (String providedPackage : moduleClassLoader.getProvidedPackages()) {
			Set<ModuleClassLoader> newSet = new HashSet<>();
			Set<ModuleClassLoader> set = providedPackages.get(providedPackage);
			if (set != null) {
				newSet.addAll(set);
			}
			newSet.remove(moduleClassLoader);
			providedPackages.put(providedPackage, newSet);
		}
	}
	public static Set<ModuleClassLoader> getModuleClassLoadersForPackage(String packageName) {
		Set<ModuleClassLoader> set = providedPackages.get(packageName);
		if (set == null) {
			return Collections.emptySet();
		} else {
			return new HashSet<>(set);
		}
	}
	private static String getFailedToStartModuleMessage(Module module) {
		String[] params = { module.getName(), String.join(",", getMissingRequiredModules(module)) };
		return Context.getMessageSourceService().getMessage("Module.error.moduleCannotBeStarted", params,
			Context.getLocale());
	}
	private static String getCyclicDependenciesMessage(String message) {
		return Context.getMessageSourceService().getMessage("Module.error.cyclicDependencies", new Object[] { message },
			Context.getLocale());
	}
	public static void loadAdvice(Module module) {
		for (AdvicePoint advice : module.getAdvicePoints()) {
			Class<?> cls;
			try {
				cls = Context.loadClass(advice.getPoint());
				Object aopObject = advice.getClassInstance();
				if (aopObject instanceof Advisor) {
					log.debug("adding advisor [{}]", aopObject.getClass());
					Context.addAdvisor(cls, (Advisor) aopObject);
				} else if (aopObject != null) {
					log.debug("adding advice [{}]", aopObject.getClass());
					Context.addAdvice(cls, (Advice) aopObject);
				} else {
					log.debug("Could not load advice class for {} [{}]", advice.getPoint(), advice.getClassName());
				}
			}
			catch (ClassNotFoundException | NoClassDefFoundError e) {
				log.warn("Could not load advice point [{}]", advice.getPoint(), e);
			}
		}
	}
	private static void runDiff(Module module, String version, String sql) {
		AdministrationService as = Context.getAdministrationService();
		String key = module.getModuleId() + ".database_version";
		GlobalProperty gp = as.getGlobalPropertyObject(key);
		boolean executeSQL = false;
		if (gp != null && StringUtils.hasLength(gp.getPropertyValue())) {
			String currentDbVersion = gp.getPropertyValue();
			if (log.isDebugEnabled()) {
				log.debug("version:column {}:{}", version, currentDbVersion);
				log.debug("compare: {}", ModuleUtil.compareVersion(version, currentDbVersion));
			}
			if (ModuleUtil.compareVersion(version, currentDbVersion) > 0) {
				executeSQL = true;
			}
		} else {
			executeSQL = true;
		}
		if (executeSQL) {
			try {
				Context.addProxyPrivilege(PrivilegeConstants.SQL_LEVEL_ACCESS);
				log.debug("Executing sql: " + sql);
				String[] sqlStatements = sql.split(";");
				for (String sqlStatement : sqlStatements) {
					if (sqlStatement.trim().length() > 0) {
						as.executeSQL(sqlStatement, false);
					}
				}
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.SQL_LEVEL_ACCESS);
			}
			try {
				Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
				String description = "DO NOT MODIFY.  Current database version number for the " + module.getModuleId()
					+ " module.";
				if (gp == null) {
					log.info("Global property " + key + " was not found. Creating one now.");
					gp = new GlobalProperty(key, version, description);
					as.saveGlobalProperty(gp);
				} else if (!gp.getPropertyValue().equals(version)) {
					log.info("Updating global property " + key + " to version: " + version);
					gp.setDescription(description);
					gp.setPropertyValue(version);
					as.saveGlobalProperty(gp);
				} else {
					log.error("Should not be here. GP property value and sqldiff version should not be equal");
				}
			}
			finally {
				Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			}
		}
	}
	private static void runLiquibase(Module module) {
		ModuleClassLoader moduleClassLoader = getModuleClassLoader(module);
		boolean liquibaseFileExists = false;
		if (moduleClassLoader != null) {
			try (InputStream inStream = moduleClassLoader.getResourceAsStream(MODULE_CHANGELOG_FILENAME)) {
				liquibaseFileExists = (inStream != null);
			}
			catch (IOException ignored) {
			}
		}
		if (liquibaseFileExists) {
			try {
				DatabaseUpdater.executeChangelog(MODULE_CHANGELOG_FILENAME, new Contexts(), null, moduleClassLoader);
			}
			catch (InputRequiredException e) {
				throw new ModuleException("Input during database updates is not yet implemented.", module.getName(), e);
			}
			catch (Exception e) {
				throw new ModuleException("Unable to update data model using " + MODULE_CHANGELOG_FILENAME + ".",
					module.getName(), e);
			}
		}
	}
	public static void stopModule(Module mod) {
		stopModule(mod, false, false);
	}
	public static void stopModule(Module mod, boolean isShuttingDown) {
		stopModule(mod, isShuttingDown, false);
	}
	public static List<Module> stopModule(Module mod, boolean skipOverStartedProperty, boolean isFailedStartup)
		throws ModuleMustStartException {
		List<Module> dependentModulesStopped = new ArrayList<>();
		if (mod != null) {
			if (!ModuleFactory.isModuleStarted(mod)) {
				return dependentModulesStopped;
			}
			try {
				if (mod.getModuleActivator() != null) {
					mod.getModuleActivator().willStop();
				}
			}
			catch (Exception t) {
				log.warn("Unable to call module's Activator.willStop() method", t);
			}
			String moduleId = mod.getModuleId();
			if (!isFailedStartup && mod.isMandatory()) {
				throw new MandatoryModuleException(moduleId);
			}
			if (!isFailedStartup && ModuleConstants.CORE_MODULES.containsKey(moduleId)) {
				throw new OpenmrsCoreModuleException(moduleId);
			}
			String modulePackage = mod.getPackageName();
			List<Module> startedModulesCopy = new ArrayList<>(getStartedModules());
			for (Module dependentModule : startedModulesCopy) {
				if (dependentModule != null && !dependentModule.equals(mod)
					&& isModuleRequiredByAnother(dependentModule, modulePackage)) {
					dependentModulesStopped.add(dependentModule);
					dependentModulesStopped.addAll(stopModule(dependentModule, skipOverStartedProperty, isFailedStartup));
				}
			}
			getStartedModulesMap().remove(moduleId);
			if (actualStartupOrder != null) {
				actualStartupOrder.remove(moduleId);
				for (Module depModule : dependentModulesStopped) {
					actualStartupOrder.remove(depModule.getModuleId());
				}
			}
			if (!skipOverStartedProperty && !Context.isRefreshingContext()) {
				saveGlobalProperty(moduleId + ".started", "false", getGlobalPropertyStartedDescription(moduleId));
			}
			ModuleClassLoader moduleClassLoader = getModuleClassLoaderMap().get(mod);
			if (moduleClassLoader != null) {
				unregisterProvidedPackages(moduleClassLoader);
				log.debug("Mod was in classloader map.  Removing advice and extensions.");
				try {
					for (AdvicePoint advice : mod.getAdvicePoints()) {
						Class cls;
						try {
							cls = Context.loadClass(advice.getPoint());
							Object aopObject = advice.getClassInstance();
							if (aopObject instanceof Advisor) {
								log.debug("adding advisor: " + aopObject.getClass());
								Context.removeAdvisor(cls, (Advisor) aopObject);
							} else {
								log.debug("Adding advice: " + aopObject.getClass());
								Context.removeAdvice(cls, (Advice) aopObject);
							}
						}
						catch (Exception t) {
							log.warn("Could not remove advice point: " + advice.getPoint(), t);
						}
					}
				}
				catch (Exception t) {
					log.warn("Error while getting advicePoints from module: " + moduleId, t);
				}
				try {
					for (Extension ext : mod.getExtensions()) {
						String extId = ext.getExtensionId();
						try {
							List<Extension> tmpExtensions = getExtensions(extId);
							tmpExtensions.remove(ext);
							getExtensionMap().put(extId, tmpExtensions);
						}
						catch (Exception exterror) {
							log.warn("Error while getting extension: " + ext, exterror);
						}
					}
				}
				catch (Exception t) {
					log.warn("Error while getting extensions from module: " + moduleId, t);
				}
			}
			List<OpenmrsService> services = Context.getModuleOpenmrsServices(modulePackage);
			if (services != null) {
				for (OpenmrsService service : services) {
					service.onShutdown();
				}
			}
			try {
				if (mod.getModuleActivator() != null) {
					mod.getModuleActivator().stopped();
				}
			}
			catch (Exception t) {
				log.warn("Unable to call module's Activator.shutdown() method", t);
			}
			mod.getExtensions().clear();
			mod.setModuleActivator(null);
			mod.disposeAdvicePointsClassInstance();
			ModuleClassLoader cl = removeClassLoader(mod);
			if (cl != null) {
				cl.dispose();
				File folder = OpenmrsClassLoader.getLibCacheFolder();
				File tmpModuleDir = new File(folder, moduleId);
				try {
					OpenmrsUtil.deleteDirectory(tmpModuleDir);
				}
				catch (IOException e) {
					log.warn("Unable to delete libcachefolder for " + moduleId);
				}
			}
		}
		return dependentModulesStopped;
	}
	private static boolean isModuleRequiredByAnother(Module dependentModule, String modulePackage) {
		return dependentModule.getRequiredModules() != null && dependentModule.getRequiredModules().contains(modulePackage);
	}
	private static ModuleClassLoader removeClassLoader(Module mod) {
		ModuleClassLoader cl = moduleClassLoaders.getIfPresent(mod);
		if (cl == null) {
			log.warn("Module: " + mod.getModuleId() + " does not exist");
		}
		moduleClassLoaders.invalidate(mod);
		return cl;
	}
	public static void unloadModule(Module mod) {
		if (isModuleStarted(mod)) {
			stopModule(mod, true);
		}
		getLoadedModules().remove(mod);
		if (mod != null) {
			File file = mod.getFile();
			boolean deleted = file.delete();
			if (!deleted) {
				file.deleteOnExit();
				log.warn("Could not delete " + file.getAbsolutePath());
			}
		}
	}
	public static List<Extension> getExtensions(String pointId) {
		List<Extension> extensions;
		Map<String, List<Extension>> extensionMap = getExtensionMap();
		extensions = extensionMap.get(pointId);
		if (extensions == null) {
			extensions = new ArrayList<>();
		}
		if (!pointId.contains(Extension.EXTENSION_ID_SEPARATOR)) {
			for (MEDIA_TYPE mediaType : Extension.MEDIA_TYPE.values()) {
				List<Extension> tmpExtensions = extensionMap.get(Extension.toExtensionId(pointId, mediaType));
				if (tmpExtensions != null) {
					for (Extension ext : tmpExtensions) {
						if (!extensions.contains(ext)) {
							extensions.add(ext);
						}
					}
				}
			}
		}
		log.debug("Getting extensions defined by : " + pointId);
		return extensions;
	}
	public static List<Extension> getExtensions(String pointId, Extension.MEDIA_TYPE type) {
		String key = Extension.toExtensionId(pointId, type);
		List<Extension> extensions = getExtensionMap().get(key);
		if (extensions != null) {
			log.debug("Getting extensions defined by : " + key);
			return extensions;
		} else {
			return getExtensions(pointId);
		}
	}
	public static List<Privilege> getPrivileges() {
		List<Privilege> privileges = new ArrayList<>();
		for (Module mod : getStartedModules()) {
			privileges.addAll(mod.getPrivileges());
		}
		log.debug(privileges.size() + " new privileges");
		return privileges;
	}
	public static List<GlobalProperty> getGlobalProperties() {
		List<GlobalProperty> globalProperties = new ArrayList<>();
		for (Module mod : getStartedModules()) {
			globalProperties.addAll(mod.getGlobalProperties());
		}
		log.debug(globalProperties.size() + " new global properties");
		return globalProperties;
	}
	public static boolean isModuleStarted(Module mod) {
		return getStartedModulesMap().containsValue(mod);
	}
	public static boolean isModuleStarted(String moduleId) {
		return getStartedModulesMap().containsKey(moduleId);
	}
	public static ModuleClassLoader getModuleClassLoader(Module mod) throws ModuleException {
		ModuleClassLoader mcl = getModuleClassLoaderMap().get(mod);
		if (mcl == null) {
			log.debug("Module classloader not found for module with id: " + mod.getModuleId());
		}
		return mcl;
	}
	public static ModuleClassLoader getModuleClassLoader(String moduleId) throws ModuleException {
		Module mod = getStartedModulesMap().get(moduleId);
		if (mod == null) {
			log.debug("Module id not found in list of started modules: " + moduleId);
		}
		return getModuleClassLoader(mod);
	}
	public static Collection<ModuleClassLoader> getModuleClassLoaders() {
		Map<Module, ModuleClassLoader> classLoaders = getModuleClassLoaderMap();
		if (classLoaders.size() > 0) {
			return classLoaders.values();
		}
		return Collections.emptyList();
	}
	public static Map<Module, ModuleClassLoader> getModuleClassLoaderMap() {
		if (moduleClassLoaders == null) {
			return Collections.emptyMap();
		}
		return moduleClassLoaders.asMap();
	}
	public static Map<String, List<Extension>> getExtensionMap() {
		return extensionMap;
	}
	private static boolean requiredModulesStarted(Module module) {
		for (String reqModPackage : module.getRequiredModules()) {
			boolean started = false;
			for (Module mod : getStartedModules()) {
				if (mod.getPackageName().equals(reqModPackage)) {
					String reqVersion = module.getRequiredModuleVersion(reqModPackage);
					if (reqVersion == null || ModuleUtil.compareVersion(mod.getVersion(), reqVersion) >= 0) {
						started = true;
					}
					break;
				}
			}
			if (!started) {
				return false;
			}
		}
		return true;
	}
	public static Module updateModule(Module mod) throws ModuleException {
		if (mod.getDownloadURL() == null) {
			return mod;
		}
		URL url;
		try {
			url = new URL(mod.getDownloadURL());
		}
		catch (MalformedURLException e) {
			throw new ModuleException("Unable to download module update", e);
		}
		unloadModule(mod);
		InputStream inputStream = ModuleUtil.getURLStream(url);
		log.warn("url pathname: " + url.getPath());
		String filename = url.getPath().substring(url.getPath().lastIndexOf("/"));
		File moduleFile = ModuleUtil.insertModuleFile(inputStream, filename);
		try {
			Module newModule = loadModule(moduleFile);
			startModule(newModule);
			return newModule;
		}
		catch (Exception e) {
			log.warn("Error while unloading old module and loading in new module");
			moduleFile.delete();
			return mod;
		}
	}
	public static boolean isTokenValid(DaemonToken token) {
		if (token == null) {
			return false;
		} else {
			synchronized (daemonTokens) {
				DaemonToken validToken = daemonTokens.getIfPresent(token.getId());
				return validToken != null && validToken == token;
			}
		}
	}
	static void passDaemonToken(Module module) {
		ModuleActivator moduleActivator = module.getModuleActivator();
		if (moduleActivator instanceof DaemonTokenAware) {
			DaemonToken daemonToken = getDaemonToken(module);
			((DaemonTokenAware) module.getModuleActivator()).setDaemonToken(daemonToken);
		}
	}
	private static DaemonToken getDaemonToken(Module module) {
		DaemonToken token;
		try {
			token = daemonTokens.get(module.getModuleId(), () -> new DaemonToken(module.getModuleId()));
		}
		catch (ExecutionException e) {
			throw new APIException(e);
		}
		return token;
	}
	private static String getGlobalPropertyStartedDescription(String moduleId) {
		String ret = "DO NOT MODIFY. true/false whether or not the " + moduleId;
		ret += " module has been started.  This is used to make sure modules that were running ";
		ret += " prior to a restart are started again";
		return ret;
	}
	private static String getGlobalPropertyMandatoryModuleDescription(String moduleId) {
		String ret = "true/false whether or not the " + moduleId;
		ret += " module MUST start when openmrs starts.  This is used to make sure that mission critical";
		ret += " modules are always running if openmrs is running.";
		return ret;
	}
	private static void saveGlobalProperty(String key, String value, String desc) {
		try {
			AdministrationService as = Context.getAdministrationService();
			GlobalProperty gp = as.getGlobalPropertyObject(key);
			if (gp == null) {
				gp = new GlobalProperty(key, value, desc);
			} else {
				gp.setPropertyValue(value);
			}
			as.saveGlobalProperty(gp);
		}
		catch (Exception e) {
			log.warn("Unable to save the global property", e);
		}
	}
	public static List<String> getDependencies(String moduleId) {
		List<String> dependentModules = null;
		Module module = getModuleById(moduleId);
		Map<String, Module> startedModules = getStartedModulesMap();
		String modulePackage = module.getPackageName();
		for (Entry<String, Module> entry : startedModules.entrySet()) {
			if (!moduleId.equals(entry.getKey()) && entry.getValue().getRequiredModules().contains(modulePackage)) {
				if (dependentModules == null) {
					dependentModules = new ArrayList<>();
				}
				dependentModules.add(entry.getKey() + " " + entry.getValue().getVersion());
			}
		}
		return dependentModules;
	}
}
package org.openmrs.util;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.ref.WeakReference;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import org.openmrs.module.ModuleClassLoader;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleUtil;
import org.openmrs.scheduler.SchedulerException;
import org.openmrs.scheduler.SchedulerService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import net.sf.ehcache.CacheManager;
public class OpenmrsClassLoader extends URLClassLoader {
	private static Logger log = LoggerFactory.getLogger(OpenmrsClassLoader.class);
	private static File libCacheFolder;
	private static boolean libCacheFolderInitialized = false;
	private static Map<String, OpenmrsMemento> mementos = new WeakHashMap<>();
	private Map<String, WeakReference<Class<?>>> cachedClasses = new ConcurrentHashMap<>();
	private static final String LIBCACHESUFFIX = ".openmrs-lib-cache";
	public OpenmrsClassLoader(ClassLoader parent) {
		super(new URL[0], parent);
		if (parent instanceof OpenmrsClassLoader) {
			throw new IllegalArgumentException("Parent must not be OpenmrsClassLoader nor null");
		} else if (parent instanceof ModuleClassLoader) {
			throw new IllegalArgumentException("Parent must not be ModuleClassLoader");
		}
		OpenmrsClassLoaderHolder.INSTANCE = this;
		log.debug("Creating new OpenmrsClassLoader instance with parent: {}", parent);
		URLConnection urlConnection = new OpenmrsURLConnection();
		urlConnection.setDefaultUseCaches(false);
	}
	public OpenmrsClassLoader() {
		this(OpenmrsClassLoader.class.getClassLoader());
	}
	private static class OpenmrsClassLoaderHolder {
		private OpenmrsClassLoaderHolder() {
		}
		private static OpenmrsClassLoader INSTANCE = null;
	}
	public static OpenmrsClassLoader getInstance() {
		if (OpenmrsClassLoaderHolder.INSTANCE == null) {
			OpenmrsClassLoaderHolder.INSTANCE = new OpenmrsClassLoader();
		}
		return OpenmrsClassLoaderHolder.INSTANCE;
	}
	@Override
	public synchronized Class<?> loadClass(String name, final boolean resolve) throws ClassNotFoundException {
		Class<?> c = getCachedClass(name);
		if (c == null) {
			String packageName = StringUtils.substringBeforeLast(name, ".");
			Set<ModuleClassLoader> moduleClassLoaders = ModuleFactory.getModuleClassLoadersForPackage(packageName);
			for (ModuleClassLoader moduleClassLoader : moduleClassLoaders) {
				try {
					c = moduleClassLoader.loadClass(name);
					break;
				}
				catch (ClassNotFoundException e) {
				}
			}
			if (c == null) {
				c = getParent().loadClass(name);
			}
			cacheClass(name, c);
		}
		if (resolve) {
			resolveClass(c);
		}
		return c;
	}
	private Class<?> getCachedClass(String name) {
		WeakReference<Class<?>> ref = cachedClasses.get(name);
		if (ref != null) {
			Class<?> loadedClass = ref.get();
			if (loadedClass == null || loadedClass.getClassLoader() == null) {
				cachedClasses.remove(name);
				loadedClass = null;
			} else if (loadedClass.getClassLoader() instanceof ModuleClassLoader) {
				ModuleClassLoader moduleClassLoader = (ModuleClassLoader) loadedClass.getClassLoader();
				if (moduleClassLoader.isDisposed()) {
					cachedClasses.remove(name);
					loadedClass = null;
				}
			}
			return loadedClass;
		}
		return null;
	}
	private void cacheClass(String name, Class<?> clazz) {
		cachedClasses.put(name, new WeakReference<>(clazz));
	}
	@Override
	public URL findResource(final String name) {
		log.trace("finding resource: {}", name);
		URL result;
		for (ModuleClassLoader classLoader : ModuleFactory.getModuleClassLoaders()) {
			result = classLoader.findResource(name);
			if (result != null) {
				return result;
			}
		}
		result = super.findResource(name);
		if (result != null && "jar".equals(result.getProtocol()) && name.contains("openmrs")) {
			result = expandURL(result, getLibCacheFolder());
		}
		return result;
	}
	@Override
	public Enumeration<URL> findResources(final String name) throws IOException {
		Set<URI> results = new HashSet<>();
		for (ModuleClassLoader classLoader : ModuleFactory.getModuleClassLoaders()) {
			Enumeration<URL> urls = classLoader.findResources(name);
			while (urls.hasMoreElements()) {
				URL result = urls.nextElement();
				if (result != null) {
					try {
						results.add(result.toURI());
					}
					catch (URISyntaxException e) {
						throwInvalidURI(result, e);
					}
				}
			}
		}
		for (Enumeration<URL> en = super.findResources(name); en.hasMoreElements();) {
			URL url = en.nextElement();
			try {
				results.add(url.toURI());
			}
			catch (URISyntaxException e) {
				throwInvalidURI(url, e);
			}
		}
		List<URL> resources = new ArrayList<>(results.size());
		for (URI result : results) {
			resources.add(result.toURL());
		}
		return Collections.enumeration(resources);
	}
	private void throwInvalidURI(URL url, Exception e) throws IOException {
		throw new IOException(url.getPath() + " is not a valid URI", e);
	}
	@Override
	public InputStream getResourceAsStream(String file) {
		for (ModuleClassLoader classLoader : ModuleFactory.getModuleClassLoaders()) {
			InputStream result = classLoader.getResourceAsStream(file);
			if (result != null) {
				return result;
			}
		}
		return super.getResourceAsStream(file);
	}
	@Override
	public Enumeration<URL> getResources(String packageName) throws IOException {
		Set<URI> results = new HashSet<>();
		for (ModuleClassLoader classLoader : ModuleFactory.getModuleClassLoaders()) {
			Enumeration<URL> urls = classLoader.getResources(packageName);
			while (urls.hasMoreElements()) {
				URL result = urls.nextElement();
				if (result != null) {
					try {
						results.add(result.toURI());
					}
					catch (URISyntaxException e) {
						throwInvalidURI(result, e);
					}
				}
			}
		}
		for (Enumeration<URL> en = super.getResources(packageName); en.hasMoreElements();) {
			URL url = en.nextElement();
			try {
				results.add(url.toURI());
			}
			catch (URISyntaxException e) {
				throwInvalidURI(url, e);
			}
		}
		List<URL> resources = new ArrayList<>(results.size());
		for (URI result : results) {
			resources.add(result.toURL());
		}
		return Collections.enumeration(resources);
	}
	@Override
	public String toString() {
		return "Openmrs" + super.toString();
	}
	public static void destroyInstance() {
		ThreadGroup rootGroup = Thread.currentThread().getThreadGroup();
		ThreadGroup parent;
		while ((parent = rootGroup.getParent()) != null) {
			rootGroup = parent;
		}
		log.info("this classloader hashcode: {}", OpenmrsClassLoaderHolder.INSTANCE.hashCode());
		List<CacheManager> knownCacheManagers = CacheManager.ALL_CACHE_MANAGERS;
		while (!knownCacheManagers.isEmpty()) {
			CacheManager cacheManager = CacheManager.ALL_CACHE_MANAGERS.get(0);
			try {
				cacheManager.shutdown();
				Field field = cacheManager.getClass().getDeclaredField("cacheManagerTimer");
				field.setAccessible(true);
				field.set(cacheManager, null);
			}
			catch (Exception ex) {
				log.error(ex.getMessage(), ex);
			}
		}
		OpenmrsClassScanner.destroyInstance();
		OpenmrsClassLoaderHolder.INSTANCE = null;
	}
	public static void setThreadsToNewClassLoader() {
		Set<Thread> threadSet = Thread.getAllStackTraces().keySet();
		Thread[] threadArray = threadSet.toArray(new Thread[threadSet.size()]);
		for (Thread thread : threadArray) {
			ClassLoader classLoader = thread.getContextClassLoader();
			if (classLoader == null) {
				continue;
			}
			if (classLoader == getInstance()) {
				continue;
			}
			if (classLoader instanceof OpenmrsClassLoader) {
				thread.setContextClassLoader(getInstance());
			}
		}
	}
	private static List<Thread> listThreads(ThreadGroup group, String indent) {
		List<Thread> threadToReturn = new ArrayList<>();
		log.error(indent + "Group[" + group.getName() + ":" + group.getClass() + "]");
		int nt = group.activeCount();
		Thread[] threads = new Thread[nt * 2 + 10]; 
		nt = group.enumerate(threads, false);
		for (int i = 0; i < nt; i++) {
			Thread t = threads[i];
			log.error(indent
			        + "  Thread["
			        + t.getName()
			        + ":"
			        + t.getClass()
			        + ":"
			        + (t.getContextClassLoader() == null ? "null cl" : t.getContextClassLoader().getClass().getName() + " "
			                + t.getContextClassLoader().hashCode()) + "]");
			threadToReturn.add(t);
		}
		int ng = group.activeGroupCount();
		ThreadGroup[] groups = new ThreadGroup[ng * 2 + 10];
		ng = group.enumerate(groups, false);
		for (int i = 0; i < ng; i++) {
			threadToReturn.addAll(listThreads(groups[i], indent + "  "));
		}
		return threadToReturn;
	}
	public static void onShutdown() {
		Set<Thread> threadSet = Thread.getAllStackTraces().keySet();
		Thread[] threadArray = threadSet.toArray(new Thread[threadSet.size()]);
		for (Thread thread : threadArray) {
			ClassLoader classLoader = thread.getContextClassLoader();
			if (classLoader == null) {
				continue;
			}
			if (classLoader instanceof OpenmrsClassLoader) {
				try {
					thread.setContextClassLoader(classLoader.getParent());
					if (thread == Thread.currentThread()) {
						continue;
					}
					log.info("onShutdown Stopping thread: {}", thread.getName());
					thread.stop();
				}
				catch (Exception ex) {
					log.error(ex.getMessage(), ex);
				}
			}
		}
		clearReferences();
	}
	protected static void clearReferences() {
		Enumeration<Driver> drivers = DriverManager.getDrivers();
		while (drivers.hasMoreElements()) {
			Driver driver = drivers.nextElement();
			if (driver.getClass().getClassLoader() == getInstance()) {
				try {
					DriverManager.deregisterDriver(driver);
				}
				catch (SQLException e) {
					log.warn("SQL driver deregistration failed", e);
				}
			}
		}
		for (WeakReference<Class<?>> refClazz : getInstance().cachedClasses.values()) {
			if (refClazz == null) {
				continue;
			}
			Class<?> clazz = refClazz.get();
			if (clazz != null && clazz.getName().contains("openmrs")) { 
				try {
					Field[] fields = clazz.getDeclaredFields();
					for (Field field : fields) {
						int mods = field.getModifiers();
						if (field.getType().isPrimitive() || (field.getName().contains("$"))) {
							continue;
						}
						if (Modifier.isStatic(mods)) {
							try {
								if (clazz.equals(OpenmrsClassLoader.class) && "log".equals(field.getName())) {
									continue;
								}
								field.setAccessible(true);
								if (Modifier.isFinal(mods)) {
									if (!(field.getType().getName().startsWith("javax."))) {
										nullInstance(field.get(null));
									}
								} else {
									field.set(null, null);
									log.debug("Set field {} to null in class {}", field.getName(), clazz.getName());
								}
							}
							catch (Exception t) {
								log.debug("Could not set field {} to null in class {}", field.getName(), clazz.getName(), t);
							}
						}
					}
				}
				catch (Exception t) {
					log.debug("Could not clean fields for class {}", clazz.getName(), t);
				}
			}
		}
		OpenmrsClassLoader.log = null;
		getInstance().cachedClasses.clear();
	}
	protected static void nullInstance(Object instance) {
		if (instance == null) {
			return;
		}
		Field[] fields = instance.getClass().getDeclaredFields();
		for (Field field : fields) {
			int mods = field.getModifiers();
			if (field.getType().isPrimitive() || (field.getName().contains("$"))) {
				continue;
			}
			try {
				field.setAccessible(true);
				if (!(Modifier.isStatic(mods) && Modifier.isFinal(mods))) {
					Object value = field.get(instance);
					if (null != value) {
						Class<?> valueClass = value.getClass();
						if (!loadedByThisOrChild(valueClass)) {
							log.debug(
							    "Not setting field {} to null in object of class {} because the referenced object was of type {} which was not loaded by this WebappClassLoader.",
							    field.getName(), instance.getClass().getName(), valueClass.getName());
						} else {
							field.set(instance, null);
							log.debug("Set field {} to null in class {}", field.getName(), instance.getClass().getName());
						}
					}
				} 
			}
			catch (Exception e) {
				log.debug("Could not set field {} to null in object instance of class {}", field.getName(),
				    instance.getClass().getName(), e);
			}
		}
	}
	protected static boolean loadedByThisOrChild(Class<?> clazz) {
		boolean result = false;
		for (ClassLoader classLoader = clazz.getClassLoader(); null != classLoader; classLoader = classLoader.getParent()) {
			if (classLoader.equals(getInstance())) {
				result = true;
				break;
			}
		}
		return result;
	}
	public static void saveState() {
		try {
			String key = SchedulerService.class.getName();
			if (!Context.isRefreshingContext()) {
				mementos.put(key, Context.getSchedulerService().saveToMemento());
			}
		}
		catch (Exception t) {
		}
	}
	public static void restoreState() {
		try {
			String key = SchedulerService.class.getName();
			Context.getSchedulerService().restoreFromMemento(mementos.get(key));
		}
		catch (APIException e) {
		}
		mementos.clear();
	}
	public static void flushInstance() {
		try {
			SchedulerService service = null;
			try {
				service = Context.getSchedulerService();
			}
			catch (APIException e2) {
				log.warn("Unable to get scheduler service", e2);
			}
			if (service != null) {
				service.rescheduleAllTasks();
			}
		}
		catch (SchedulerException e) {
			log.error("Failed to restart scheduler tasks", e);
		}
	}
	public static File getLibCacheFolder() {
		if (libCacheFolder != null) {
			return libCacheFolderInitialized ? libCacheFolder : null;
		}
		synchronized (ModuleClassLoader.class) {
			libCacheFolder = new File(OpenmrsUtil.getApplicationDataDirectory(), LIBCACHESUFFIX);
			log.debug("libraries cache folder is {}", libCacheFolder);
			if (libCacheFolder.exists()) {
				try {
					OpenmrsUtil.deleteDirectory(libCacheFolder);
					libCacheFolder.mkdirs();
				}
				catch (IOException io) {
					log.warn("Unable to delete: {}", libCacheFolder.getName());
				}
			} else {
				libCacheFolder.mkdirs();
			}
			libCacheFolder.deleteOnExit();
			libCacheFolderInitialized = true;
		}
		return libCacheFolder;
	}
	public static URL expandURL(URL result, File folder) {
		String extForm = result.toExternalForm();
		if (OpenmrsConstants.UNIX_BASED_OPERATING_SYSTEM) {
			extForm = extForm.replaceFirst("jar:file:", "").replaceAll("%20", " ");
		} else {
			extForm = extForm.replaceFirst("jar:file:/", "").replaceAll("%20", " ");
		}
		log.debug("url external form: {}", extForm);
		int i = extForm.indexOf("!");
		String jarPath = extForm.substring(0, i);
		String filePath = extForm.substring(i + 2); 
		log.debug("jarPath: {}", jarPath);
		log.debug("filePath: {}", filePath);
		File file = new File(folder, filePath);
		log.debug("absolute path: {}", file.getAbsolutePath());
		try {
			if (file.exists()) {
				return file.toURI().toURL();
			} else {
				File jarFile = new File(jarPath);
				if (!jarFile.exists()) {
					log.warn("Cannot find jar at: {} for url: {}", jarFile, result);
					return null;
				}
				ModuleUtil.expandJar(jarFile, folder, filePath, true);
				return file.toURI().toURL();
			}
		}
		catch (IOException io) {
			log.warn("Unable to expand url: {}", result, io);
			return null;
		}
	}
	private class OpenmrsURLConnection extends URLConnection {
		public OpenmrsURLConnection() {
			super(null);
		}
		@Override
		public void connect() throws IOException {
		}
	}
}
package org.openmrs.api.context;
import org.aopalliance.aop.Advice;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.SessionFactory;
import org.openmrs.Allergen;
import org.openmrs.GlobalProperty;
import org.openmrs.OpenmrsObject;
import org.openmrs.PersonName;
import org.openmrs.Privilege;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.CohortService;
import org.openmrs.api.ConceptService;
import org.openmrs.api.ConditionService;
import org.openmrs.api.DatatypeService;
import org.openmrs.api.DiagnosisService;
import org.openmrs.api.EncounterService;
import org.openmrs.api.FormService;
import org.openmrs.api.LocationService;
import org.openmrs.api.MedicationDispenseService;
import org.openmrs.api.ObsService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.OrderService;
import org.openmrs.api.OrderSetService;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.ProviderService;
import org.openmrs.api.SerializationService;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.api.db.ContextDAO;
import org.openmrs.hl7.HL7Service;
import org.openmrs.logic.LogicService;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.module.ModuleMustStartException;
import org.openmrs.module.ModuleUtil;
import org.openmrs.notification.AlertService;
import org.openmrs.notification.MessageException;
import org.openmrs.notification.MessagePreparator;
import org.openmrs.notification.MessageSender;
import org.openmrs.notification.MessageService;
import org.openmrs.notification.mail.MailMessageSender;
import org.openmrs.notification.mail.velocity.VelocityMessagePreparator;
import org.openmrs.scheduler.SchedulerService;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.ConfigUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.validator.ValidateUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;
import javax.mail.Authenticator;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.Future;
public class Context {
	private static final Logger log = LoggerFactory.getLogger(Context.class);
	private static ContextDAO contextDAO;
	private static Session mailSession;
	private static final ThreadLocal<Object[] > userContextHolder = new ThreadLocal<>();
	private static volatile ServiceContext serviceContext;
	private static Properties runtimeProperties = new Properties();
	private static Properties configProperties = new Properties();
	private static AuthenticationScheme authenticationScheme;
	public Context() {
	}
	static ContextDAO getContextDAO() {
		if (contextDAO == null) {
			throw new APIException("error.context.null", (Object[]) null);
		}
		return contextDAO;
	}
	public void setContextDAO(ContextDAO dao) {
		setDAO(dao);
	}
	public static void setDAO(ContextDAO dao) {
		contextDAO = dao;
	}
	private static void setAuthenticationScheme() {
		authenticationScheme = new UsernamePasswordAuthenticationScheme();
		try {
			authenticationScheme = Context.getServiceContext().getApplicationContext().getBean(AuthenticationScheme.class); 
			log.info("An authentication scheme override was provided. Using this one in place of the OpenMRS default authentication scheme.");
		}
		catch(NoUniqueBeanDefinitionException e) {
			log.error("Multiple authentication schemes overrides are being provided, this is currently not supported. Sticking to OpenMRS default authentication scheme.");
		}
		catch(NoSuchBeanDefinitionException e) {
			log.debug("No authentication scheme override was provided. Sticking to OpenMRS default authentication scheme.");
		}
		catch(BeansException e){
			log.error("Fatal error encountered when injecting the authentication scheme override. Sticking to OpenMRS default authentication scheme.");
		}
	}
	public static Class<?> loadClass(String className) throws ClassNotFoundException {
		return OpenmrsClassLoader.getInstance().loadClass(className);
	}
	public static void setUserContext(UserContext ctx) {
		log.trace("Setting user context {}", ctx);
		Object[] arr = new Object[] { ctx };
		userContextHolder.set(arr);
	}
	public static void clearUserContext() {
		log.trace("Clearing user context {}", Arrays.toString(userContextHolder.get()));
		userContextHolder.remove();
	}
	public static UserContext getUserContext() {
		Object[] arr = userContextHolder.get();
		log.trace("Getting user context {} from userContextHolder {}", Arrays.toString(arr), userContextHolder);
		if (arr == null) {
			log.trace("userContext is null.");
			throw new APIException(
					"A user context must first be passed to setUserContext()...use Context.openSession() (and closeSession() to prevent memory leaks!) before using the API");
		}
		return (UserContext) userContextHolder.get()[0];
	}
	static ServiceContext getServiceContext() {
		if (serviceContext == null) {
			synchronized (Context.class) {
				if (serviceContext == null) {
					log.info("Creating new service context");
					serviceContext = ServiceContext.getInstance();
				}
			}
		}
		log.trace("serviceContext: {}", serviceContext);
		return ServiceContext.getInstance();
	}
	public void setServiceContext(ServiceContext ctx) {
		setContext(ctx);
	}
	public static void setContext(ServiceContext ctx) {
		serviceContext = ctx;
	}
	public static AuthenticationScheme getAuthenticationScheme() {
		return authenticationScheme;
	}
	@Deprecated
	public static void authenticate(String username, String password) throws ContextAuthenticationException {
		authenticate(new UsernamePasswordCredentials(username, password));
	}
	public static Authenticated authenticate(Credentials credentials) throws ContextAuthenticationException {
		if (Daemon.isDaemonThread()) {
			log.error("Authentication attempted while operating on a "
					+ "daemon thread, authenticating is not necessary or allowed");
			return new BasicAuthenticated(Daemon.getDaemonThreadUser(), "No auth scheme used by Context - Daemon user is always authenticated.");
		}
		if (credentials == null) {
			throw new ContextAuthenticationException("Context cannot authenticate with null credentials.");
		}
		return getUserContext().authenticate(credentials);
	}
	public static void refreshAuthenticatedUser() {
		if (Daemon.isDaemonThread()) {
			return;
		}
		log.debug("Refreshing authenticated user");
		getUserContext().refreshAuthenticatedUser();
	}
	public static void becomeUser(String systemId) throws ContextAuthenticationException {
		log.info("systemId: {}", systemId);
		getUserContext().becomeUser(systemId);
	}
	public static Properties getRuntimeProperties() {
		log.trace("getting runtime properties. size: {}", runtimeProperties.size());
		Properties props = new Properties();
		props.putAll(runtimeProperties);
		return props;
	}
	public static void setRuntimeProperties(Properties props) {
		runtimeProperties = props;
	}
	public static ConceptService getConceptService() {
		return getServiceContext().getConceptService();
	}
	public static EncounterService getEncounterService() {
		return getServiceContext().getEncounterService();
	}
	public static LocationService getLocationService() {
		return getServiceContext().getLocationService();
	}
	public static ObsService getObsService() {
		return getServiceContext().getObsService();
	}
	public static PatientService getPatientService() {
		return getServiceContext().getPatientService();
	}
	public static CohortService getCohortService() {
		return getServiceContext().getCohortService();
	}
	public static PersonService getPersonService() {
		return getServiceContext().getPersonService();
	}
	public static ConditionService getConditionService(){
		return getServiceContext().getConditionService();
	}
	public static DiagnosisService getDiagnosisService(){
		return getServiceContext().getDiagnosisService();
	}
	public static MedicationDispenseService getMedicationDispenseService(){
		return getServiceContext().getMedicationDispenseService();
	}
	public static HL7Service getHL7Service() {
		return getServiceContext().getHL7Service();
	}
	public static UserService getUserService() {
		return getServiceContext().getUserService();
	}
	public static OrderService getOrderService() {
		return getServiceContext().getOrderService();
	}
	public static OrderSetService getOrderSetService() {
		return getServiceContext().getOrderSetService();
	}
	public static FormService getFormService() {
		return getServiceContext().getFormService();
	}
	public static SerializationService getSerializationService() {
		return getServiceContext().getSerializationService();
	}
	public static LogicService getLogicService() {
		return getServiceContext().getLogicService();
	}
	public static AdministrationService getAdministrationService() {
		return getServiceContext().getAdministrationService();
	}
	public static MessageSourceService getMessageSourceService() {
		return getServiceContext().getMessageSourceService();
	}
	public static SchedulerService getSchedulerService() {
		return getServiceContext().getSchedulerService();
	}
	public static AlertService getAlertService() {
		return getServiceContext().getAlertService();
	}
	public static ProgramWorkflowService getProgramWorkflowService() {
		return getServiceContext().getProgramWorkflowService();
	}
	public static MessageService getMessageService() {
		MessageService ms = getServiceContext().getMessageService();
		try {
			if (ms.getMessagePreparator() == null) {
				ms.setMessagePreparator(getMessagePreparator());
			}
			if (ms.getMessageSender() == null) {
				ms.setMessageSender(getMessageSender());
			}
		}
		catch (Exception e) {
			log.error("Unable to create message service due", e);
		}
		return ms;
	}
	public static Properties getMailProperties() {
		Properties p = new Properties();
		String prefix = "mail.";
		for (GlobalProperty gp : getAdministrationService().getGlobalPropertiesByPrefix(prefix)) {
			if (gp.getProperty().equals("mail.transport_protocol")) {
				p.setProperty("mail.transport.protocol", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_host")) {
				p.setProperty("mail.smtp.host", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_port")) {
				p.setProperty("mail.smtp.port", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_auth")) {
				p.setProperty("mail.smtp.auth", gp.getPropertyValue());
			}
			else {
				p.setProperty(gp.getProperty(), gp.getPropertyValue());
			}
		}
		for (String runtimeProperty : runtimeProperties.stringPropertyNames()) {
			if (runtimeProperty.startsWith(prefix)) {
				p.setProperty(runtimeProperty, runtimeProperties.getProperty(runtimeProperty));
			}
		}
		for (String systemProperty : System.getProperties().stringPropertyNames()) {
			if (systemProperty.startsWith(prefix)) {
				p.setProperty(systemProperty, System.getProperty(systemProperty));
			}
		}
		return p;
	}
	private static Session getMailSession() {
		if (mailSession == null) {
			synchronized (Context.class) {
				if (mailSession == null) {
					Authenticator auth = new Authenticator() {
						@Override
						public PasswordAuthentication getPasswordAuthentication() {
							return new PasswordAuthentication(
								ConfigUtil.getProperty("mail.user"),
								ConfigUtil.getProperty("mail.password")
							);
						}
					};
					mailSession = Session.getInstance(getMailProperties(), auth);
				}
			}
		}
		return mailSession;
	}
	private static MessageSender getMessageSender() {
		return new MailMessageSender(getMailSession());
	}
	private static MessagePreparator getMessagePreparator() throws MessageException {
		return new VelocityMessagePreparator();
	}
	public static User getAuthenticatedUser() {
		if (Daemon.isDaemonThread()) {
			return Daemon.getDaemonThreadUser();
		}
		return getUserContext().getAuthenticatedUser();
	}
	public static boolean isAuthenticated() {
		if (Daemon.isDaemonThread()) {
			return true;
		} else {
			try {
				return getAuthenticatedUser() != null;
			} catch (APIException e) {
				log.info("Could not get authenticated user inside called to isAuthenticated(), assuming no user context has been defined", e);
				return false;
			}
		}
	}
	public static void logout() {
		if (!isSessionOpen()) {
			return; 
		}
		log.debug("Logging out : {}", getAuthenticatedUser());
		getUserContext().logout();
		setUserContext(new UserContext(getAuthenticationScheme()));
	}
	public static Set<Role> getAllRoles(User user) throws Exception {
		return getUserContext().getAllRoles();
	}
	public static boolean hasPrivilege(String privilege) {
		if (Daemon.isDaemonThread()) {
			return true;
		}
		return getUserContext().hasPrivilege(privilege);
	}
	public static void requirePrivilege(String privilege) throws ContextAuthenticationException {
		if (!hasPrivilege(privilege)) {
			String errorMessage;
			if (StringUtils.isNotBlank(privilege)) {
				errorMessage = Context.getMessageSourceService().getMessage("error.privilegesRequired",
						new Object[] { privilege }, null);
			} else {
				errorMessage = Context.getMessageSourceService().getMessage("error.privilegesRequiredNoArgs");
			}
			throw new ContextAuthenticationException(errorMessage);
		}
	}
	public static void addProxyPrivilege(String privilege) {
		getUserContext().addProxyPrivilege(privilege);
	}
	public static void removeProxyPrivilege(String privilege) {
		getUserContext().removeProxyPrivilege(privilege);
	}
	public static void setLocale(Locale locale) {
		getUserContext().setLocale(locale);
	}
	public static Locale getLocale() {
		if (!isSessionOpen()) {
			return LocaleUtility.getDefaultLocale();
		}
		return getUserContext().getLocale();
	}
	public static void openSession() {
		log.trace("opening session");
		setUserContext(new UserContext(getAuthenticationScheme())); 
		getContextDAO().openSession();
	}
	public static void closeSession() {
		log.trace("closing session");
		clearUserContext(); 
		getContextDAO().closeSession();
	}
	public static void openSessionWithCurrentUser() {
		getContextDAO().openSession();
	}
	public static void closeSessionWithCurrentUser() {
		getContextDAO().closeSession();
	}
	public static void clearSession() {
		log.trace("clearing session");
		getContextDAO().clearSession();
	}
	public static void flushSession() {
		log.trace("flushing session");
		getContextDAO().flushSession();
	}
	public static boolean isSessionOpen() {
		return userContextHolder.get() != null;
	}
	public static void refreshEntity(Object obj) {
		log.trace("refreshing object: {}", obj);
		getContextDAO().refreshEntity(obj);
	}
	public static void evictFromSession(Object obj) {
		log.trace("clearing session");
		getContextDAO().evictFromSession(obj);
	}
	public static void evictEntity(OpenmrsObject object) {
		log.debug("Clearing DB cache for entity: {} with id: {}", object.getClass(), object.getId());
		getContextDAO().evictEntity(object);
	}
	public static void evictAllEntities(Class<?> entityClass) {
		log.debug("Clearing DB cache for entities of type: {}", entityClass);
		getContextDAO().evictAllEntities(entityClass);
	}
	public static void clearEntireCache() {
		log.debug("Clearing DB cache from all regions");
		getContextDAO().clearEntireCache();
	}
	public static synchronized void startup(Properties props) throws DatabaseUpdateException, InputRequiredException,
	ModuleMustStartException {
		getContextDAO().startup(props);
		checkForDatabaseUpdates(props);
		OpenmrsUtil.startup(props);
		openSession();
		clearSession();
		checkCoreDataset();
		getContextDAO().setupSearchIndex();
		ModuleUtil.startup(props);
	}
	public static synchronized void startup(String url, String username, String password, Properties properties)
			throws DatabaseUpdateException, InputRequiredException, ModuleMustStartException {
		if (properties == null) {
			properties = new Properties();
		}
		properties.put("connection.url", url);
		properties.put("connection.username", username);
		properties.put("connection.password", password);
		setRuntimeProperties(properties);
		openSession(); 
		startup(properties);
		SchedulerUtil.startup(properties);
		closeSession();
	}
	public static void shutdown() {
		log.debug("Shutting down the scheduler");
		try {
			SchedulerUtil.shutdown();
		}
		catch (Exception e) {
			log.warn("Error while shutting down scheduler service", e);
		}
		log.debug("Shutting down the modules");
		try {
			ModuleUtil.shutdown();
		}
		catch (Exception e) {
			log.warn("Error while shutting down module system", e);
		}
		log.debug("Shutting down the context");
		try {
			ContextDAO dao = null;
			try {
				dao = getContextDAO();
			}
			catch (APIException e) {
			}
			if (dao != null) {
				dao.shutdown();
			}
		}
		catch (Exception e) {
			log.warn("Error while shutting down context dao", e);
		}
	}
	public static <T> T getService(Class<? extends T> cls) {
		return getServiceContext().getService(cls);
	}
	public static void addAdvisor(Class cls, Advisor advisor) {
		getServiceContext().addAdvisor(cls, advisor);
	}
	public static void addAdvice(Class cls, Advice advice) {
		getServiceContext().addAdvice(cls, advice);
	}
	public static void removeAdvisor(Class cls, Advisor advisor) {
		getServiceContext().removeAdvisor(cls, advisor);
	}
	public static void removeAdvice(Class cls, Advice advice) {
		getServiceContext().removeAdvice(cls, advice);
	}
	public static void checkCoreDataset() {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ROLES);
			Set<String> currentRoleNames = new HashSet<>();
			for (Role role : Context.getUserService().getAllRoles()) {
				currentRoleNames.add(role.getRole().toUpperCase());
			}
			Map<String, String> map = OpenmrsUtil.getCoreRoles();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				String roleName = entry.getKey();
				if (!currentRoleNames.contains(roleName.toUpperCase())) {
					Role role = new Role();
					role.setRole(roleName);
					role.setDescription(entry.getValue());
					Context.getUserService().saveRole(role);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core roles for openmrs system", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ROLES);
		}
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_PRIVILEGES);
			Set<String> currentPrivilegeNames = new HashSet<>();
			for (Privilege privilege : Context.getUserService().getAllPrivileges()) {
				currentPrivilegeNames.add(privilege.getPrivilege().toUpperCase());
			}
			Map<String, String> map = OpenmrsUtil.getCorePrivileges();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				String privilegeName = entry.getKey();
				if (!currentPrivilegeNames.contains(privilegeName.toUpperCase())) {
					Privilege p = new Privilege();
					p.setPrivilege(privilegeName);
					p.setDescription(entry.getValue());
					Context.getUserService().savePrivilege(p);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core privileges", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_PRIVILEGES);
		}
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			Context.addProxyPrivilege(PrivilegeConstants.GET_GLOBAL_PROPERTIES);
			Set<String> currentPropNames = new HashSet<>();
			Map<String, GlobalProperty> propsMissingDescription = new HashMap<>();
			Map<String, GlobalProperty> propsMissingDatatype = new HashMap<>();
			for (GlobalProperty prop : Context.getAdministrationService().getAllGlobalProperties()) {
				currentPropNames.add(prop.getProperty().toUpperCase());
				if (prop.getDescription() == null) {
					propsMissingDescription.put(prop.getProperty().toUpperCase(), prop);
				}
				if (prop.getDatatypeClassname() == null) {
					propsMissingDatatype.put(prop.getProperty().toUpperCase(), prop);
				}
			}
			for (GlobalProperty coreProp : OpenmrsConstants.CORE_GLOBAL_PROPERTIES()) {
				String corePropName = coreProp.getProperty().toUpperCase();
				if (!currentPropNames.contains(corePropName)) {
					Context.getAdministrationService().saveGlobalProperty(coreProp);
					currentPropNames.add(corePropName); 
				} else {
					GlobalProperty propToUpdate = propsMissingDescription.get(corePropName);
					if (propToUpdate != null) {
						propToUpdate.setDescription(coreProp.getDescription());
						Context.getAdministrationService().saveGlobalProperty(propToUpdate);
					}
					propToUpdate = propsMissingDatatype.get(corePropName);
					if (propToUpdate != null && coreProp.getDatatypeClassname() != null) {
						propToUpdate.setDatatypeClassname(coreProp.getDatatypeClassname());
						propToUpdate.setDatatypeConfig(coreProp.getDatatypeConfig());
						propToUpdate.setPreferredHandlerClassname(coreProp.getPreferredHandlerClassname());
						propToUpdate.setHandlerConfig(coreProp.getHandlerConfig());
						Context.getAdministrationService().saveGlobalProperty(propToUpdate);
					}
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core global properties", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			Context.removeProxyPrivilege(PrivilegeConstants.GET_GLOBAL_PROPERTIES);
		}
		AdministrationService as = Context.getAdministrationService();
		Boolean disableValidation = Boolean.valueOf(as.getGlobalProperty(OpenmrsConstants.GP_DISABLE_VALIDATION, "false"));
		ValidateUtil.setDisableValidation(disableValidation);
		PersonName.setFormat(Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GLOBAL_PROPERTY_LAYOUT_NAME_FORMAT));
		Allergen.setOtherNonCodedConceptUuid(Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GP_ALLERGEN_OTHER_NON_CODED_UUID));
	}
	private static void checkForDatabaseUpdates(Properties props) throws DatabaseUpdateException, InputRequiredException {
		boolean updatesRequired;
		try {
			updatesRequired = DatabaseUpdater.updatesRequired();
		}
		catch (Exception e) {
			throw new DatabaseUpdateException("Unable to check if database updates are required", e);
		}
		if (updatesRequired) {
			if (DatabaseUpdater.allowAutoUpdate()) {
				DatabaseUpdater.executeChangelog();
			} else {
				throw new DatabaseUpdateException(
						"Database updates are required.  Call Context.updateDatabase() before .startup() to continue.");
			}
		}
	}
	@Deprecated
	public static void updateDatabase(Map<String, Object> userInput) throws DatabaseUpdateException {
		throw new UnsupportedOperationException("As of 2.4, this method is not longer implemented");
	}
	public static SimpleDateFormat getDateFormat() {
		return OpenmrsUtil.getDateFormat(getLocale());
	}
	public static SimpleDateFormat getTimeFormat() {
		return OpenmrsUtil.getTimeFormat(getLocale());
	}
	public static SimpleDateFormat getDateTimeFormat() {
		return OpenmrsUtil.getDateTimeFormat(getLocale());
	}
	public static boolean isRefreshingContext() {
		return getServiceContext().isRefreshingContext();
	}
	public static <T> List<T> getRegisteredComponents(Class<T> type) {
		return getServiceContext().getRegisteredComponents(type);
	}
	public static <T> T getRegisteredComponent(String beanName, Class<T> type) throws APIException {
		return getServiceContext().getRegisteredComponent(beanName, type);
	}
	public static List<OpenmrsService> getModuleOpenmrsServices(String modulePackage) {
		return getServiceContext().getModuleOpenmrsServices(modulePackage);
	}
	public static VisitService getVisitService() {
		return getServiceContext().getVisitService();
	}
	public static ProviderService getProviderService() {
		return getServiceContext().getProviderService();
	}
	public static DatatypeService getDatatypeService() {
		return getServiceContext().getDatatypeService();
	}
	public static void addConfigProperty(Object key, Object value) {
		configProperties.put(key, value);
	}
	public static void removeConfigProperty(Object key) {
		configProperties.remove(key);
	}
	public static Properties getConfigProperties() {
		Properties props = new Properties();
		props.putAll(configProperties);
		return props;
	}
	public static void updateSearchIndex() {
		getContextDAO().updateSearchIndex();
	}
	public static Future<?> updateSearchIndexAsync() {
		return getContextDAO().updateSearchIndexAsync();
	}
	public static void updateSearchIndexForType(Class<?> type) {
		getContextDAO().updateSearchIndexForType(type);
	}
	public static void updateSearchIndexForObject(Object object) {
		getContextDAO().updateSearchIndexForObject(object);
	}
	public static void setUseSystemClassLoader(boolean useSystemClassLoader) {
		getServiceContext().setUseSystemClassLoader(useSystemClassLoader);
	}
	public static boolean isUseSystemClassLoader() {
		return getServiceContext().isUseSystemClassLoader();
	}
	public static Connection getDatabaseConnection() {
		return getContextDAO().getDatabaseConnection();
	}
}
package org.openmrs.web.filter.update;
import java.util.List;
import org.openmrs.liquibase.LiquibaseProvider;
import org.openmrs.util.DatabaseUpdater;
public class DatabaseUpdaterWrapper {
	public List<DatabaseUpdater.OpenMRSChangeSet> getUnrunDatabaseChanges( LiquibaseProvider liquibaseProvider) throws Exception {
		return DatabaseUpdater.getUnrunDatabaseChanges( liquibaseProvider );
	}
	public boolean isLocked() {
		return DatabaseUpdater.isLocked();
	}
	public boolean updatesRequired() throws Exception {
		return DatabaseUpdater.updatesRequired();
	}
}
package org.openmrs.util;
import liquibase.Contexts;
import liquibase.GlobalConfiguration;
import liquibase.LabelExpression;
import liquibase.Liquibase;
import liquibase.RuntimeEnvironment;
import liquibase.Scope;
import liquibase.changelog.ChangeLogHistoryServiceFactory;
import liquibase.changelog.ChangeLogIterator;
import liquibase.changelog.ChangeSet;
import liquibase.changelog.DatabaseChangeLog;
import liquibase.changelog.filter.ChangeSetFilterResult;
import liquibase.changelog.filter.ContextChangeSetFilter;
import liquibase.changelog.filter.DbmsChangeSetFilter;
import liquibase.changelog.filter.ShouldRunChangeSetFilter;
import liquibase.changelog.visitor.UpdateVisitor;
import liquibase.command.core.StatusCommandStep;
import liquibase.database.Database;
import liquibase.database.DatabaseFactory;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.LiquibaseException;
import liquibase.exception.LockException;
import liquibase.lockservice.LockService;
import liquibase.lockservice.LockServiceFactory;
import liquibase.resource.CompositeResourceAccessor;
import liquibase.resource.FileSystemResourceAccessor;
import liquibase.resource.ResourceAccessor;
import liquibase.ui.LoggerUIService;
import org.apache.commons.io.IOUtils;
import org.openmrs.api.context.Context;
import org.openmrs.liquibase.ChangeLogDetective;
import org.openmrs.liquibase.ChangeLogVersionFinder;
import org.openmrs.liquibase.ChangeSetExecutorCallback;
import org.openmrs.liquibase.LiquibaseProvider;
import org.openmrs.liquibase.LiquibaseScopeHandling;
import org.openmrs.liquibase.OpenmrsClassLoaderResourceAccessor;
import org.openmrs.module.ModuleClassLoader;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.logging.Level;
public class DatabaseUpdater {
	private static final Logger log = LoggerFactory.getLogger(DatabaseUpdater.class);
	private static final String EMPTY_CHANGE_LOG_FILE = "liquibase-empty-changelog.xml";
	public static final String CONTEXT = "core";
	public static final String DATABASE_UPDATES_LOG_FILE = "liquibaseUpdateLogs.txt";
	private static Integer authenticatedUserId;
	private static final ChangeLogDetective changeLogDetective;
	private static final ChangeLogVersionFinder changeLogVersionFinder;
	private static LiquibaseProvider liquibaseProvider;
	static {
		changeLogDetective = new ChangeLogDetective();
		changeLogVersionFinder = new ChangeLogVersionFinder();
	}
	static void setLiquibaseProvider(LiquibaseProvider liquibaseProvider) {
		DatabaseUpdater.liquibaseProvider = liquibaseProvider;
	}
	static void unsetLiquibaseProvider() {
		DatabaseUpdater.liquibaseProvider = null;
	}
	private static volatile List<String> updateWarnings = null;
	public static void executeChangelog() throws DatabaseUpdateException {
		final LiquibaseProvider liquibaseProvider = new DatabaseUpdaterLiquibaseProvider();
		final List<String> changeLogs;
		try {
			final String version = changeLogDetective.getInitialLiquibaseSnapshotVersion(CONTEXT, liquibaseProvider);
			log.debug(
				"updating the database with versions of liquibase-update-to-latest files greater than '{}'",
				version);
			changeLogs = changeLogDetective.getUnrunLiquibaseUpdateFileNames(version, CONTEXT, liquibaseProvider);
			log.debug("found applicable Liquibase update change logs: {}", changeLogs);
		}
		catch (Exception e) {
			log.error("Error while trying to find database changes to run", e);
			throw new DatabaseUpdateException("Error while trying to find database changes to run", e);
		}
		if (changeLogs.isEmpty()) {
			return;
		}
		for (String changeLog : changeLogs) {
			log.debug("applying Liquibase changelog '{}'", changeLog);
			executeChangelog(changeLog, (ChangeSetExecutorCallback) null);
		}
	}
	@Deprecated
	public static void executeChangelog(String changelog, Map<String, Object> userInput)
	        throws DatabaseUpdateException {
		log.debug("Executing changelog: {}" , changelog);
		executeChangelog(changelog, (ChangeSetExecutorCallback) null);
	}
	public static List<String> executeChangelog(String changelog, ChangeSetExecutorCallback callback)
	        throws DatabaseUpdateException {
		log.debug("installing the tables into the database");
		if (changelog == null) {
			throw new IllegalArgumentException("changelog must not be null");
		}
		try {
			log.debug("executing liquibase changelog {}", changelog);
			return executeChangelog(changelog, new Contexts(CONTEXT), callback, null);
		}
		catch (Exception e) {
			throw new DatabaseUpdateException("There was an error while updating the database to the latest. file: "
			        + changelog + ". Error: " + e.getMessage(), e);
		}
	}
	public static List<String> executeChangelog(String changeLogFile, Contexts contexts, ChangeSetExecutorCallback callback,
	        ClassLoader cl) throws Exception {
		if (cl == null) {
			cl = OpenmrsClassLoader.getInstance();
		}
		Thread.currentThread().setContextClassLoader(cl);
		log.debug("Setting up liquibase object to run changelog: {}", changeLogFile);
		Liquibase liquibase = getLiquibase(changeLogFile, cl);
		String scopeId = LiquibaseScopeHandling.enterLiquibaseUILoggingService();
		int numChangeSetsToRun = new StatusCommandStep()
			.listUnrunChangeSets(contexts,
				new LabelExpression(), liquibase.getDatabaseChangeLog(), liquibase.getDatabase()).size();
		LiquibaseScopeHandling.exitLiquibaseScope(scopeId);
		Database database = null;
		LockService lockHandler = null;
		try {
			database = liquibase.getDatabase();
			lockHandler = LockServiceFactory.getInstance().getLockService(database);
			lockHandler.waitForLock();
			DatabaseChangeLog changeLog = liquibase.getDatabaseChangeLog();
			changeLog.setChangeLogParameters(liquibase.getChangeLogParameters());
			changeLog.validate(database);
			ChangeLogIterator logIterator = new ChangeLogIterator(changeLog, new ShouldRunChangeSetFilter(database),
			        new ContextChangeSetFilter(contexts), new DbmsChangeSetFilter(database));
			Scope.getCurrentScope().getSingleton(ChangeLogHistoryServiceFactory.class).getChangeLogService(database).init();
			logIterator.run(new OpenmrsUpdateVisitor(database, callback, numChangeSetsToRun),
			    new RuntimeEnvironment(database, contexts, new LabelExpression()));
		}
		finally {
			try {
				if (lockHandler != null) {
					lockHandler.releaseLock();
				}
			}
			catch (Exception e) {
				log.error("Could not release lock", e);
			}
			try {
				if (database != null && database.getConnection() != null) {
					database.getConnection().close();
				}
			}
			catch (Exception e) {
			}
		}
		return updateWarnings;
	}
	public static boolean updatesRequired() throws Exception {
		log.debug("checking for updates");
		List<OpenMRSChangeSet> changesets = getUnrunDatabaseChanges(new DatabaseUpdaterLiquibaseProvider());
		if (isLocked() && changesets.isEmpty()) {
			DatabaseUpdater.releaseDatabaseLock();
			log.debug("db lock found and released automatically");
			return false;
		}
		return !changesets.isEmpty();
	}
	public static boolean updatesRequired(String... changeLogFilenames) throws Exception {
		log.debug("checking for updates");
		List<OpenMRSChangeSet> changesets = getUnrunDatabaseChanges(changeLogFilenames);
		return !changesets.isEmpty();
	}
	public static Boolean allowAutoUpdate() {
		String allowAutoUpdate = Context.getRuntimeProperties()
		        .getProperty(OpenmrsConstants.AUTO_UPDATE_DATABASE_RUNTIME_PROPERTY, "false");
		return "true".equals(allowAutoUpdate);
	}
	private static void mergeDefaultRuntimeProperties(Properties runtimeProperties) {
		Set<Object> runtimePropertyKeys = new HashSet<>(runtimeProperties.keySet());
		for (Object key : runtimePropertyKeys) {
			String prop = (String) key;
			String value = (String) runtimeProperties.get(key);
			log.trace("Setting property: " + prop + ":" + value);
			if (!prop.startsWith("hibernate") && !runtimeProperties.containsKey("hibernate." + prop)) {
				runtimeProperties.setProperty("hibernate." + prop, value);
			}
		}
		InputStream propertyStream = null;
		try {
			Properties props = new Properties();
			propertyStream = DatabaseUpdater.class.getClassLoader().getResourceAsStream("hibernate.default.properties");
			OpenmrsUtil.loadProperties(props, propertyStream);
			for (Map.Entry<Object, Object> entry : props.entrySet()) {
				if (!runtimeProperties.containsKey(entry.getKey())) {
					runtimeProperties.put(entry.getKey(), entry.getValue());
				}
			}
		}
		finally {
			try {
				propertyStream.close();
			}
			catch (Exception e) {
			}
		}
	}
	static Liquibase getLiquibase(String changeLogFile) throws Exception {
		if (liquibaseProvider != null) {
			return liquibaseProvider.getLiquibase(changeLogFile);
		}
		return getLiquibase(changeLogFile, OpenmrsClassLoader.getInstance());
	}
	private static Liquibase getLiquibase(String changeLogFile, ClassLoader cl) throws Exception {
		Connection connection;
		try {
			connection = getConnection();
		}
		catch (SQLException e) {
			throw new Exception(
			        "Unable to get a connection to the database.  Please check your openmrs runtime properties file and make sure you have the correct connection.username and connection.password set",
			        e);
		}
		if (cl == null) {
			cl = OpenmrsClassLoader.getInstance();
		}
		try {
			Database database = DatabaseFactory.getInstance()
			        .findCorrectDatabaseImplementation(new JdbcConnection(connection));
			database.setDatabaseChangeLogTableName("liquibasechangelog");
			database.setDatabaseChangeLogLockTableName("liquibasechangeloglock");
			if (connection.getMetaData().getDatabaseProductName().contains("HSQL Database Engine")
			        || connection.getMetaData().getDatabaseProductName().contains("H2")) {
				database.setDatabaseChangeLogTableName(database.getDatabaseChangeLogTableName().toUpperCase());
				database.setDatabaseChangeLogLockTableName(database.getDatabaseChangeLogLockTableName().toUpperCase());
			}
			if (changeLogFile == null) {
				changeLogFile = EMPTY_CHANGE_LOG_FILE;
			}
			configureLiquibaseDuplicateFileMode();
			Scope.getCurrentScope()
				.getSingleton(ChangeLogHistoryServiceFactory.class)
				.getChangeLogService(database)
				.init();
			return new Liquibase(changeLogFile, getCompositeResourceAccessor(cl), database);
		}
		catch (Exception e) {
			if (connection != null) {
				connection.close();
			}
			throw e;
		}
	}
	public static Connection getConnection() throws Exception {
		Properties props = Context.getRuntimeProperties();
		mergeDefaultRuntimeProperties(props);
		String driver = props.getProperty("hibernate.connection.driver_class");
		String username = props.getProperty("hibernate.connection.username");
		String password = props.getProperty("hibernate.connection.password");
		String url = props.getProperty("hibernate.connection.url");
		if (url.contains("mysql") && !url.contains("InnoDB")) {
			url = url + "&sessionVariables=default_storage_engine=InnoDB";
		}
		Class.forName(driver);
		return DriverManager.getConnection(url, username, password);
	}
	public static class OpenMRSChangeSet {
		private String id;
		private String author;
		private String comments;
		private String description;
		private ChangeSet.RunStatus runStatus;
		private Date ranDate;
		public OpenMRSChangeSet(ChangeSet changeSet, Database database) throws Exception {
			setId(changeSet.getId());
			setAuthor(changeSet.getAuthor());
			setComments(changeSet.getComments());
			setDescription(changeSet.getDescription());
			setRunStatus(database.getRunStatus(changeSet));
			setRanDate(database.getRanDate(changeSet));
		}
		public String getAuthor() {
			return author;
		}
		public void setAuthor(String author) {
			this.author = author;
		}
		public String getComments() {
			return comments;
		}
		public void setComments(String comments) {
			this.comments = comments;
		}
		public String getDescription() {
			return description;
		}
		public void setDescription(String description) {
			this.description = description;
		}
		public ChangeSet.RunStatus getRunStatus() {
			return runStatus;
		}
		public void setRunStatus(ChangeSet.RunStatus runStatus) {
			this.runStatus = runStatus;
		}
		public Date getRanDate() {
			return ranDate;
		}
		public void setRanDate(Date ranDate) {
			this.ranDate = ranDate;
		}
		public String getId() {
			return id;
		}
		public void setId(String id) {
			this.id = id;
		}
	}
	public static List<OpenMRSChangeSet> getDatabaseChanges() throws Exception {
		if (Context.isSessionOpen()) { 
			Context.requirePrivilege(PrivilegeConstants.GET_DATABASE_CHANGES);
		}
		List<OpenMRSChangeSet> result = new ArrayList<>();
		String initialSnapshotVersion = changeLogDetective.getInitialLiquibaseSnapshotVersion(CONTEXT,
		    new DatabaseUpdaterLiquibaseProvider());
		List<String> updateVersions = changeLogVersionFinder.getUpdateVersionsGreaterThan(initialSnapshotVersion);
		Map<String, List<String>> snapshotCombinations = changeLogVersionFinder.getSnapshotCombinations();
		List<String> changeLogFileNames = new ArrayList<>();
		changeLogFileNames.addAll(snapshotCombinations.get(initialSnapshotVersion));
		changeLogFileNames.addAll(changeLogVersionFinder.getUpdateFileNames(updateVersions));
		Liquibase liquibase = null;
		try {
			for (String filename : changeLogFileNames) {
				String scopeId = LiquibaseScopeHandling.enterLiquibaseUILoggingService();
				liquibase = getLiquibase(filename);
				List<ChangeSet> changeSets = liquibase.getDatabaseChangeLog().getChangeSets();
				for (ChangeSet changeSet : changeSets) {
					OpenMRSChangeSet openMRSChangeSet = new OpenMRSChangeSet(changeSet, liquibase.getDatabase());
					result.add(openMRSChangeSet);
				}
				LiquibaseScopeHandling.exitLiquibaseScope(scopeId);
				liquibase.close();
			}
		}
		finally {
			if (liquibase != null) {
				try {
					liquibase.close();
				}
				catch (Exception e) {
				}
			}
		}
		return result;
	}
	public static List<OpenMRSChangeSet> getUnrunDatabaseChanges(LiquibaseProvider liquibaseProvider) throws Exception {
		if (Context.isSessionOpen()) { 
			Context.requirePrivilege(PrivilegeConstants.GET_DATABASE_CHANGES);
		}
		String initialSnapshotVersion = changeLogDetective.getInitialLiquibaseSnapshotVersion(CONTEXT, liquibaseProvider);
		log.debug("initial snapshot version is '{}'", initialSnapshotVersion);
		List<String> liquibaseUpdateFilenames = changeLogDetective.getUnrunLiquibaseUpdateFileNames(initialSnapshotVersion,
		    CONTEXT, liquibaseProvider);
		if (!liquibaseUpdateFilenames.isEmpty()) {
			return getUnrunDatabaseChanges(liquibaseUpdateFilenames.toArray(new String[0]));
		}
		return new ArrayList<OpenMRSChangeSet>();
	}
	public static List<OpenMRSChangeSet> getUnrunDatabaseChanges(String... changeLogFilenames) {
		if (Context.isSessionOpen()) { 
			Context.requirePrivilege(PrivilegeConstants.GET_DATABASE_CHANGES);
		}
		log.debug("looking for un-run change sets in '{}'", Arrays.toString(changeLogFilenames));
		Database database = null;
		try {
			if (changeLogFilenames == null || changeLogFilenames.length == 0) {
				throw new IllegalArgumentException("changeLogFilenames can neither null nor an empty array");
			}
			List<OpenMRSChangeSet> results = new ArrayList<>();
			String scopeId = LiquibaseScopeHandling.enterLiquibaseUILoggingService();
			for (String changelogFile : changeLogFilenames) {
				Liquibase liquibase = getLiquibase(changelogFile, null);
				database = liquibase.getDatabase();
				List<ChangeSet> changeSets = new StatusCommandStep()
					.listUnrunChangeSets(new Contexts(CONTEXT),
						new LabelExpression(), liquibase.getDatabaseChangeLog(), liquibase.getDatabase());
				for (ChangeSet changeSet : changeSets) {
					OpenMRSChangeSet omrschangeset = new OpenMRSChangeSet(changeSet, database);
					results.add(omrschangeset);
				}
			}
			LiquibaseScopeHandling.exitLiquibaseScope(scopeId);
			return results;
		}
		catch (Exception e) {
			throw new RuntimeException(
			        "Error occurred while trying to get the updates needed for the database. " + e.getMessage(), e);
		}
		finally {
			try {
				database.getConnection().close();
			}
			catch (Exception e) {
			}
		}
	}
	public static Integer getAuthenticatedUserId() {
		return authenticatedUserId;
	}
	public static void setAuthenticatedUserId(Integer userId) {
		authenticatedUserId = userId;
	}
	public static void reportUpdateWarnings(List<String> warnings) {
		if (updateWarnings == null) {
			updateWarnings = new LinkedList<>();
		}
		updateWarnings.addAll(warnings);
	}
	public static void writeUpdateMessagesToFile(String text) {
		OutputStreamWriter streamWriter = null;
		PrintWriter writer = null;
		File destFile = new File(OpenmrsUtil.getApplicationDataDirectory(), DatabaseUpdater.DATABASE_UPDATES_LOG_FILE);
		try {
			String lineSeparator = System.getProperty("line.separator");
			Date date = Calendar.getInstance().getTime();
			streamWriter = new OutputStreamWriter(new FileOutputStream(destFile, true), StandardCharsets.UTF_8);
			writer = new PrintWriter(new BufferedWriter(streamWriter));
			writer.write("********** START OF DATABASE UPDATE LOGS AS AT " + date + " **********");
			writer.write(lineSeparator);
			writer.write(lineSeparator);
			writer.write(text);
			writer.write(lineSeparator);
			writer.write(lineSeparator);
			writer.write("*********** END OF DATABASE UPDATE LOGS AS AT " + date + " ***********");
			writer.write(lineSeparator);
			writer.write(lineSeparator);
			if (writer.checkError()) {
				log.warn("An Error occured while writing warnings to the database update log file'");
			}
			writer.close();
		}
		catch (FileNotFoundException e) {
			log.warn("Failed to find the database update log file", e);
		}
		finally {
			IOUtils.closeQuietly(streamWriter);
			IOUtils.closeQuietly(writer);
		}
	}
	public static synchronized void releaseDatabaseLock() throws LockException {
		Database database = null;
		try {
			Liquibase liquibase = getLiquibase(null, null);
			database = liquibase.getDatabase();
			LockService lockService = LockServiceFactory.getInstance().getLockService(database);
			if (lockService.hasChangeLogLock() && isLocked()) {
				lockService.forceReleaseLock();
			}
		}
		catch (Exception e) {
			throw new LockException(e);
		}
		finally {
			try {
				database.getConnection().close();
			}
			catch (Exception e) {
			}
		}
	}
	public static boolean isLocked() {
		Database database = null;
		try {
			Liquibase liquibase = getLiquibase(null, null);
			database = liquibase.getDatabase();
			return LockServiceFactory.getInstance().getLockService(database).listLocks().length > 0;
		}
		catch (Exception e) {
			return false;
		}
		finally {
			try {
				database.getConnection().close();
			}
			catch (Exception e) {
			}
		}
	}
	private final static class OpenmrsUpdateVisitor extends UpdateVisitor {
		private final ChangeSetExecutorCallback callback;
		private final int numChangeSetsToRun;
		public OpenmrsUpdateVisitor(Database database, ChangeSetExecutorCallback callback, int numChangeSetsToRun) {
			super(database, null);
			this.callback = callback;
			this.numChangeSetsToRun = numChangeSetsToRun;
		}
		@Override
		public void visit(ChangeSet changeSet, DatabaseChangeLog databaseChangeLog, Database database,
			Set<ChangeSetFilterResult> filterResults) throws LiquibaseException {
			if (callback != null) {
				callback.executing(changeSet, numChangeSetsToRun);
			}
			Map<String, Object> scopeValues = new HashMap<>();
			scopeValues.put(Scope.Attr.resourceAccessor.name(), getCompositeResourceAccessor(null));
			String scopeId = null;
			try {
				scopeId = Scope.enter(scopeValues);
				super.visit(changeSet, databaseChangeLog, database, filterResults);
			}
			catch (Exception e) {
				throw new LiquibaseException("Unable to execute change set: " + changeSet, e);
			}
			finally {
				try {
					Scope.exit(scopeId);
				}
				catch (Exception e) {
					log.warn("An error occurred trying to exit the liquibase scope", e);
				}
			}
		}
	}
	private static CompositeResourceAccessor getCompositeResourceAccessor(ClassLoader classLoader) {
		if (classLoader == null) {
			classLoader = Thread.currentThread().getContextClassLoader();
			if (!(classLoader instanceof OpenmrsClassLoader) && !(classLoader instanceof ModuleClassLoader)) {
				classLoader = OpenmrsClassLoader.getInstance();
			}
		}
		ResourceAccessor openmrsFO = new OpenmrsClassLoaderResourceAccessor(classLoader);
		ResourceAccessor fsFO = new FileSystemResourceAccessor(OpenmrsUtil.getApplicationDataDirectoryAsFile());
		return new CompositeResourceAccessor(openmrsFO, fsFO);
	}
	private static void configureLiquibaseDuplicateFileMode() {
		final String dupFlagModeKey = GlobalConfiguration.DUPLICATE_FILE_MODE.getKey();
		final String dupFlagMode = Context.getRuntimeProperties().getProperty(dupFlagModeKey);
		if (dupFlagMode != null) {
			System.setProperty(dupFlagModeKey, dupFlagMode);
		} else if (System.getProperty(dupFlagModeKey) == null) {
			System.setProperty(dupFlagModeKey, OpenmrsConstants.LIQUIBASE_DUPLICATE_FILE_MODE_DEFAULT);
		}
	}
}
package org.openmrs.web.filter.update;
import liquibase.changelog.ChangeSet;
import liquibase.exception.LockException;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.liquibase.ChangeLogDetective;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.liquibase.ChangeSetExecutorCallback;
import org.openmrs.util.DatabaseUpdaterLiquibaseProvider;
import org.openmrs.util.InputRequiredException;
import org.openmrs.liquibase.ChangeLogVersionFinder;
import org.openmrs.util.OpenmrsThreadPoolHolder;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.RoleConstants;
import org.openmrs.util.Security;
import org.openmrs.web.Listener;
import org.openmrs.web.WebDaemon;
import org.openmrs.web.filter.StartupFilter;
import org.openmrs.web.filter.initialization.InitializationFilter;
import org.openmrs.web.filter.util.CustomResourceLoader;
import org.openmrs.web.filter.util.ErrorMessageConstants;
import org.openmrs.web.filter.util.FilterUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.context.ContextLoader;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Future;
public class UpdateFilter extends StartupFilter {
	protected final Logger log = LoggerFactory.getLogger(UpdateFilter.class);
	private static final String DEFAULT_PAGE = "maintenance.vm";
	private static final String REVIEW_CHANGES = "reviewchanges.vm";
	private static final String PROGRESS_VM_AJAXREQUEST = "updateProgress.vm.ajaxRequest";
	private UpdateFilterModel updateFilterModel = null;
	private static boolean updatesRequired = true;
	private boolean authenticatedSuccessfully = false;
	private UpdateFilterCompletion updateJob;
	private static boolean isDatabaseUpdateInProgress = false;
	private static Boolean lockReleased = false;
	@Override
	protected void doGet(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
	        throws IOException, ServletException {
		Map<String, Object> referenceMap = new HashMap<>();
		checkLocaleAttributesForFirstTime(httpRequest);
		if (httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE) != null) {
			referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE,
			    httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
		}
		renderTemplate(DEFAULT_PAGE, referenceMap, httpResponse);
	}
	@Override
	protected synchronized void doPost(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
	        throws IOException, ServletException {
		final String updJobStatus = "updateJobStarted";
		String page = httpRequest.getParameter("page");
		Map<String, Object> referenceMap = new HashMap<>();
		if (httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE) != null) {
			referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE,
			    httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
		}
		if (DEFAULT_PAGE.equals(page)) {
			String username = httpRequest.getParameter("username");
			String password = httpRequest.getParameter("password");
			log.debug("Attempting to authenticate user: " + username);
			if (authenticateAsSuperUser(username, password)) {
				log.debug("Authentication successful.  Redirecting to 'reviewupdates' page.");
				authenticatedSuccessfully = true;
				referenceMap.put("isDatabaseUpdateInProgress", isDatabaseUpdateInProgress);
				if (isDatabaseUpdateInProgress) {
					referenceMap.put(updJobStatus, true);
					httpResponse.setContentType("text/html");
					renderTemplate(REVIEW_CHANGES, referenceMap, httpResponse);
					return;
				}
				if (!isLockReleased() && DatabaseUpdater.isLocked()) {
					try {
						DatabaseUpdater.releaseDatabaseLock();
						setLockReleased(true);
					}
					catch (LockException e) {
					}
					updateFilterModel.updateChanges();
				}
				String localeParameter = FilterUtil.restoreLocale(username);
				httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, localeParameter);
				referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE, localeParameter);
				renderTemplate(REVIEW_CHANGES, referenceMap, httpResponse);
			} else {
				try {
					log.debug("Sleeping for 3 seconds because of a bad username/password");
					Thread.sleep(3000);
				}
				catch (InterruptedException e) {
					log.error("Unable to sleep", e);
					throw new ServletException("Got interrupted while trying to sleep thread", e);
				}
				errors.put(ErrorMessageConstants.UPDATE_ERROR_UNABLE_AUTHENTICATE, null);
				renderTemplate(DEFAULT_PAGE, referenceMap, httpResponse);
			}
		}
		else if (REVIEW_CHANGES.equals(page)) {
			if (!authenticatedSuccessfully) {
				renderTemplate(DEFAULT_PAGE, referenceMap, httpResponse);
				return;
			}
			if (!isDatabaseUpdateInProgress) {
				isDatabaseUpdateInProgress = true;
				updateJob = new UpdateFilterCompletion();
				updateJob.start();
				referenceMap.put(updJobStatus, true);
			} else {
				referenceMap.put("isDatabaseUpdateInProgress", true);
				referenceMap.put(updJobStatus, true);
			}
			renderTemplate(REVIEW_CHANGES, referenceMap, httpResponse);
		} else if (PROGRESS_VM_AJAXREQUEST.equals(page)) {
			httpResponse.setContentType("text/json");
			httpResponse.setHeader("Cache-Control", "no-cache");
			Map<String, Object> result = new HashMap<>();
			if (updateJob != null) {
				result.put("hasErrors", updateJob.hasErrors());
				if (updateJob.hasErrors()) {
					errors.putAll(updateJob.getErrors());
				}
				if (updateJob.hasWarnings() && updateJob.getExecutingChangesetId() == null) {
					result.put("hasWarnings", updateJob.hasWarnings());
					StringBuilder sb = new StringBuilder("<ul>");
					for (String warning : updateJob.getUpdateWarnings()) {
						sb.append("<li>").append(warning).append("</li>");
					}
					sb.append("</ul>");
					result.put("updateWarnings", sb.toString());
					result.put("updateLogFile",
					    StringUtils.replace(
					        OpenmrsUtil.getApplicationDataDirectory() + DatabaseUpdater.DATABASE_UPDATES_LOG_FILE, "\\",
					        "\\\\"));
					updateJob.hasUpdateWarnings = false;
					updateJob.getUpdateWarnings().clear();
				}
				result.put("updatesRequired", updatesRequired());
				result.put("message", updateJob.getMessage());
				result.put("changesetIds", updateJob.getChangesetIds());
				result.put("executingChangesetId", updateJob.getExecutingChangesetId());
				addLogLinesToResponse(result);
			}
			String jsonText = toJSONString(result);
			httpResponse.getWriter().write(jsonText);
		}
	}
	public void checkLocaleAttributesForFirstTime(HttpServletRequest httpRequest) {
		Locale locale = httpRequest.getLocale();
		String systemDefaultLocale = FilterUtil.readSystemDefaultLocale(null);
		if (CustomResourceLoader.getInstance(httpRequest).getAvailablelocales().contains(locale)) {
			httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, locale.toString());
			log.info("Used client's locale " + locale.toString());
		} else if (StringUtils.isNotBlank(systemDefaultLocale)) {
			httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, systemDefaultLocale);
			log.info("Used system default locale " + systemDefaultLocale);
		} else {
			httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, Locale.ENGLISH.toString());
			log.info("Used default locale " + Locale.ENGLISH.toString());
		}
	}
	protected boolean authenticateAsSuperUser(String usernameOrSystemId, String password) throws ServletException {
		Connection connection = null;
		try {
			connection = DatabaseUpdater.getConnection();
			String select = "select user_id, password, salt from users where (username = ? or system_id = ?) and retired = '0'";
			PreparedStatement statement = null;
			try {
				statement = connection.prepareStatement(select);
				statement.setString(1, usernameOrSystemId);
				statement.setString(2, usernameOrSystemId);
				if (statement.execute()) {
					ResultSet results = null;
					try {
						results = statement.getResultSet();
						if (results.next()) {
							Integer userId = results.getInt(1);
							DatabaseUpdater.setAuthenticatedUserId(userId);
							String storedPassword = results.getString(2);
							String salt = results.getString(3);
							String passwordToHash = password + salt;
							return Security.hashMatches(storedPassword, passwordToHash) && isSuperUser(connection, userId);
						}
					}
					finally {
						if (results != null) {
							try {
								results.close();
							}
							catch (Exception resultsCloseEx) {
								log.error("Failed to quietly close ResultSet", resultsCloseEx);
							}
						}
					}
				}
			}
			finally {
				if (statement != null) {
					try {
						statement.close();
					}
					catch (Exception statementCloseEx) {
						log.error("Failed to quietly close Statement", statementCloseEx);
					}
				}
			}
		}
		catch (Exception connectionEx) {
			log.error(
			    "Error while trying to authenticate as super user. Ignore this if you are upgrading from OpenMRS 1.5 to 1.6",
			    connectionEx);
			if (connection != null) {
				String select = "select user_id, password, salt from users where (username = ? or system_id = ?) and voided = '0'";
				PreparedStatement statement = null;
				try {
					statement = connection.prepareStatement(select);
					statement.setString(1, usernameOrSystemId);
					statement.setString(2, usernameOrSystemId);
					if (statement.execute()) {
						ResultSet results = null;
						try {
							results = statement.getResultSet();
							if (results.next()) {
								Integer userId = results.getInt(1);
								DatabaseUpdater.setAuthenticatedUserId(userId);
								String storedPassword = results.getString(2);
								String salt = results.getString(3);
								String passwordToHash = password + salt;
								return Security.hashMatches(storedPassword, passwordToHash)
								        && isSuperUser(connection, userId);
							}
						}
						finally {
							if (results != null) {
								try {
									results.close();
								}
								catch (Exception resultsCloseEx) {
									log.error("Failed to quietly close ResultSet", resultsCloseEx);
								}
							}
						}
					}
				}
				catch (Exception unhandeledEx) {
					log.error("Error while trying to authenticate as super user (voided version)", unhandeledEx);
				}
				finally {
					if (statement != null) {
						try {
							statement.close();
						}
						catch (Exception statementCloseEx) {
							log.error("Failed to quietly close Statement", statementCloseEx);
						}
					}
				}
			}
		}
		finally {
			if (connection != null) {
				try {
					connection.close();
				}
				catch (SQLException e) {
					log.debug("Error while closing the database", e);
				}
			}
		}
		return false;
	}
	protected boolean isSuperUser(Connection connection, Integer userId) throws SQLException {
		String select = "select 1 from user_role where user_id = ? and (role = ? or role = 'Administrator')";
		PreparedStatement statement = connection.prepareStatement(select);
		statement.setInt(1, userId);
		statement.setString(2, RoleConstants.SUPERUSER);
		if (statement.execute()) {
			ResultSet results = statement.getResultSet();
			if (results.next()) {
				return results.getInt(1) == 1;
			}
		}
		return false;
	}
	private void startOpenmrs(ServletContext servletContext) throws Exception {
		ContextLoader contextLoader = new ContextLoader();
		contextLoader.initWebApplicationContext(servletContext);
		try {
			WebDaemon.startOpenmrs(servletContext);
		}
		catch (Exception exception) {
			contextLoader.closeWebApplicationContext(servletContext);
			throw exception;
		}
	}
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		super.init(filterConfig);
		log.debug("Initializing the UpdateFilter");
		if (!InitializationFilter.initializationRequired()
		        || (Listener.isSetupNeeded() && Listener.runtimePropertiesFound())) {
			updateFilterModel = new UpdateFilterModel();
			try {
				if (updateFilterModel.updateRequired) {
					setUpdatesRequired(true);
				} else if (updateFilterModel.changes == null) {
					setUpdatesRequired(false);
				} else {
					log.debug("Setting updates required to {} because of the size of unrun changes", (!updateFilterModel.changes.isEmpty()));
					setUpdatesRequired(!updateFilterModel.changes.isEmpty());
				}
			}
			catch (Exception e) {
				throw new ServletException("Unable to determine if updates are required", e);
			}
		} else {
			log.debug(
			    "Setting updates required to false because the user doesn't have any runtime properties yet or database is empty");
			setUpdatesRequired(false);
		}
	}
	@Override
	protected Object getUpdateFilterModel() {
		return updateFilterModel;
	}
	@Override
	public boolean skipFilter(HttpServletRequest httpRequest) {
		return !PROGRESS_VM_AJAXREQUEST.equals(httpRequest.getParameter("page")) && !updatesRequired();
	}
	public static synchronized boolean updatesRequired() {
		return updatesRequired;
	}
	public static synchronized void setUpdatesRequired(boolean updatesRequired) {
		UpdateFilter.updatesRequired = updatesRequired;
	}
	public static Boolean isLockReleased() {
		return lockReleased;
	}
	public static synchronized void setLockReleased(Boolean lockReleased) {
		UpdateFilter.lockReleased = lockReleased;
	}
	@Override
	protected String getTemplatePrefix() {
		return "org/openmrs/web/filter/update/";
	}
	private class UpdateFilterCompletion {
		private Runnable r;
		private String executingChangesetId = null;
		private List<String> changesetIds = new ArrayList<>();
		private Map<String, Object[]> errors = new HashMap<>();
		private String message = null;
		private boolean erroneous = false;
		private boolean hasUpdateWarnings = false;
		private List<String> updateWarnings = new LinkedList<>();
		public synchronized void reportError(String error, Object... params) {
			Map<String, Object[]> reportedErrors = new HashMap<>();
			reportedErrors.put(error, params);
			reportErrors(reportedErrors);
		}
		public synchronized void reportErrors(Map<String, Object[]> errs) {
			errors.putAll(errs);
			erroneous = true;
		}
		public synchronized boolean hasErrors() {
			return erroneous;
		}
		public synchronized Map<String, Object[]> getErrors() {
			return errors;
		}
		public void start() {
			setUpdatesRequired(true);
			OpenmrsThreadPoolHolder.threadExecutor.submit(r);
		}
		public synchronized void setMessage(String message) {
			this.message = message;
		}
		public synchronized String getMessage() {
			return message;
		}
		public synchronized void addChangesetId(String changesetid) {
			this.changesetIds.add(changesetid);
			this.executingChangesetId = changesetid;
		}
		public synchronized List<String> getChangesetIds() {
			return changesetIds;
		}
		public synchronized String getExecutingChangesetId() {
			return executingChangesetId;
		}
		public synchronized List<String> getUpdateWarnings() {
			return updateWarnings;
		}
		public synchronized boolean hasWarnings() {
			return hasUpdateWarnings;
		}
		public synchronized void reportWarnings(List<String> warnings) {
			updateWarnings.addAll(warnings);
			hasUpdateWarnings = true;
		}
		public UpdateFilterCompletion() {
			 r = new Runnable() {
				@Override
				public void run() {
					try {
						class PrintingChangeSetExecutorCallback implements ChangeSetExecutorCallback {
							private String message;
							public PrintingChangeSetExecutorCallback(String message) {
								this.message = message;
							}
							@Override
							public void executing(ChangeSet changeSet, int numChangeSetsToRun) {
								addChangesetId(changeSet.getId());
								setMessage(message);
							}
						}
						try {
							setMessage("Updating the database to the latest version");
							ChangeLogDetective changeLogDetective = new ChangeLogDetective();
							ChangeLogVersionFinder changeLogVersionFinder = new ChangeLogVersionFinder();
							List<String> changelogs = new ArrayList<>();
							List<String> warnings = new ArrayList<>();
							String version = changeLogDetective.getInitialLiquibaseSnapshotVersion(DatabaseUpdater.CONTEXT,
							    new DatabaseUpdaterLiquibaseProvider());
							log.debug(
							    "updating the database with versions of liquibase-update-to-latest files greater than '{}'",
							    version);
							changelogs.addAll(changeLogVersionFinder
							        .getUpdateFileNames(changeLogVersionFinder.getUpdateVersionsGreaterThan(version)));
							log.debug("found applicable Liquibase update change logs: {}", changelogs);
							for (String changelog : changelogs) {
								log.debug("applying Liquibase changelog '{}'", changelog);
								List<String> currentWarnings = DatabaseUpdater.executeChangelog(changelog,
								    new PrintingChangeSetExecutorCallback("executing Liquibase changelog :" + changelog));
								if (currentWarnings != null) {
									warnings.addAll(currentWarnings);
								}
							}
							executingChangesetId = null; 
							if (CollectionUtils.isNotEmpty(warnings)) {
								reportWarnings(warnings);
							}
						}
						catch (InputRequiredException inputRequired) {
							log.error("Not implemented", inputRequired);
							updateFilterModel.updateChanges();
							reportError(ErrorMessageConstants.UPDATE_ERROR_INPUT_NOT_IMPLEMENTED,
							    inputRequired.getMessage());
							return;
						}
						catch (DatabaseUpdateException e) {
							log.error("Unable to update the database", e);
							Map<String, Object[]> databaseUpdateErrors = new HashMap<>();
							databaseUpdateErrors.put(ErrorMessageConstants.UPDATE_ERROR_UNABLE, null);
							for (String errorMessage : Arrays.asList(e.getMessage().split("\n"))) {
								databaseUpdateErrors.put(errorMessage, null);
							}
							updateFilterModel.updateChanges();
							reportErrors(databaseUpdateErrors);
							return;
						}
						catch (Exception e) {
							log.error("Unable to update the database", e);
							return;
						}
						setMessage("Starting OpenMRS");
						try {
							startOpenmrs(filterConfig.getServletContext());
						}
						catch (Exception e) {
							log.error("Unable to complete the startup.", e);
							reportError(ErrorMessageConstants.UPDATE_ERROR_COMPLETE_STARTUP, e.getMessage());
							return;
						}
						setUpdatesRequired(false);
					}
					finally {
						if (!hasErrors()) {
							setUpdatesRequired(false);
						}
						isDatabaseUpdateInProgress = false;
					}
				}
			};
		}
	}
}
package org.openmrs.web;
import org.apache.logging.log4j.LogManager;
import org.openmrs.api.context.Context;
import org.openmrs.logging.OpenmrsLoggingUtil;
import org.openmrs.module.MandatoryModuleException;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.ModuleMustStartException;
import org.openmrs.module.OpenmrsCoreModuleException;
import org.openmrs.module.web.OpenmrsJspServlet;
import org.openmrs.module.web.WebModuleUtil;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.MemoryLeakUtil;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.web.filter.initialization.DatabaseDetective;
import org.openmrs.web.filter.initialization.InitializationFilter;
import org.openmrs.web.filter.update.UpdateFilter;
import org.owasp.csrfguard.CsrfGuard;
import org.owasp.csrfguard.CsrfGuardServletContextListener;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.factory.BeanCreationException;
import org.springframework.util.StringUtils;
import org.springframework.web.context.ContextLoader;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.XmlWebApplicationContext;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;
import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.ServletException;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.StringReader;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.sql.Driver;
import java.sql.DriverManager;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
public final class Listener extends ContextLoader implements ServletContextListener, HttpSessionListener {
	private static final org.slf4j.Logger log = LoggerFactory.getLogger(Listener.class);
	private static boolean runtimePropertiesFound = false;
	private static Throwable errorAtStartup = null;
	private static boolean setupNeeded = false;
	private static boolean openmrsStarted = false;
	public static boolean runtimePropertiesFound() {
		return runtimePropertiesFound;
	}
	public static boolean errorOccurredAtStartup() {
		return errorAtStartup != null;
	}
	public static boolean isSetupNeeded() {
		return setupNeeded;
	}
	public static boolean isOpenmrsStarted() {
		return openmrsStarted;
	}
	public static Throwable getErrorAtStartup() {
		return errorAtStartup;
	}
	public static void setRuntimePropertiesFound(boolean runtimePropertiesFound) {
		Listener.runtimePropertiesFound = runtimePropertiesFound;
	}
	public static void setErrorAtStartup(Throwable errorAtStartup) {
		Listener.errorAtStartup = errorAtStartup;
	}
	@Override
	public void sessionCreated(HttpSessionEvent se) {
		for (HttpSessionListener listener : getHttpSessionListeners()) {
			listener.sessionCreated(se);
		}
	}
	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		for (HttpSessionListener listener : getHttpSessionListeners()) {
			listener.sessionDestroyed(se);
		}
	}
	private List<HttpSessionListener> getHttpSessionListeners() {
		List<HttpSessionListener> httpSessionListeners = Collections.emptyList();
		if (openmrsStarted) {
			try {
				httpSessionListeners = Context.getRegisteredComponents(HttpSessionListener.class);
			}
			catch (Exception e) {
				log.warn("An error occurred trying to retrieve HttpSessionListener beans from the context", e);
			}
		}
		return httpSessionListeners;
	}
	@Override
	public void contextInitialized(ServletContextEvent event) {
		log.debug("Starting the OpenMRS webapp");
		try {
			OpenmrsUtil.validateJavaVersion();
			ServletContext servletContext = event.getServletContext();
			loadConstants(servletContext);
			clearDWRFile(servletContext);
			setApplicationDataDirectory(servletContext);
			Properties props = getRuntimeProperties();
			if (props != null) {
				setRuntimePropertiesFound(true);
				Context.setRuntimeProperties(props);
				String appDataRuntimeProperty = props
				        .getProperty(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY, null);
				if (StringUtils.hasLength(appDataRuntimeProperty)) {
					OpenmrsUtil.setApplicationDataDirectory(null);
				}
				OpenmrsLoggingUtil.applyLogLevel(getClass().toString(), "INFO");
				log.info("Using runtime properties file: {}",
				         OpenmrsUtil.getRuntimePropertiesFilePathName(WebConstants.WEBAPP_NAME));
			}
			loadCsrfGuardProperties(servletContext);
			Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
			if (!setupNeeded()) {
				copyCustomizationIntoWebapp(servletContext, props);
				XmlWebApplicationContext context = (XmlWebApplicationContext) createWebApplicationContext(servletContext);
				configureAndRefreshWebApplicationContext(context, servletContext);
				servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);
				WebDaemon.startOpenmrs(event.getServletContext());
			} else {
				setupNeeded = true;
			}
		}
		catch (Exception e) {
			setErrorAtStartup(e);
			log.error(MarkerFactory.getMarker("FATAL"), "Failed to obtain JDBC connection", e);
		}
	}
	private void loadCsrfGuardProperties(ServletContext servletContext) throws IOException {
		File csrfGuardFile = new File(OpenmrsUtil.getApplicationDataDirectory(), "csrfguard.properties");
		Properties csrfGuardProperties = new Properties();
		if (csrfGuardFile.exists()) {
			try (InputStream csrfGuardInputStream = Files.newInputStream(csrfGuardFile.toPath())) {
				csrfGuardProperties.load(csrfGuardInputStream);
			}
			catch (Exception e) {
				log.error("Error loading csrfguard.properties file at " + csrfGuardFile.getAbsolutePath(), e);
				throw e;
			}
		}
		else {
			String fileName = servletContext.getRealPath("/WEB-INF/csrfguard.properties");
			try (InputStream csrfGuardInputStream = Files.newInputStream(Paths.get(fileName))) {
				csrfGuardProperties.load(csrfGuardInputStream);
			}
			catch (Exception e) {
				log.error("Error loading csrfguard.properties file at " +  fileName, e);
				throw e;
			}
		}
		Properties runtimeProperties = getRuntimeProperties();
		if (runtimeProperties != null) {
			runtimeProperties.stringPropertyNames().forEach(property -> {
				if (property.startsWith("org.owasp.csrfguard")) {
					csrfGuardProperties.setProperty(property, runtimeProperties.getProperty(property));
				}
			});	
		}
		CsrfGuard.load(csrfGuardProperties);
		try {
			Field field = CsrfGuardServletContextListener.class.getDeclaredField("servletContext");
			field.setAccessible(true);
			field.set(null, servletContext.getContextPath());
		}
		catch (Exception ex) {
			log.error("Failed to set the CSRFGuard servlet context", ex);
		}
	}
	private boolean setupNeeded() throws Exception {
		if (!runtimePropertiesFound) {
			return true;
		}
		DatabaseDetective databaseDetective = new DatabaseDetective();
		if (databaseDetective.isDatabaseEmpty(OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME))) {
			return true;
		}
		return DatabaseUpdater.updatesRequired() && !DatabaseUpdater.allowAutoUpdate();
	}
	public static void startOpenmrs(ServletContext servletContext) throws ServletException {
		openmrsStarted = false;
		try {
			Listener.loadBundledModules(servletContext);
			Context.startup(getRuntimeProperties());
		}
		catch (DatabaseUpdateException | InputRequiredException updateEx) {
			throw new ServletException("Should not be here because updates were run previously", updateEx);
		}
		catch (MandatoryModuleException mandatoryModEx) {
			throw new ServletException(mandatoryModEx);
		}
		catch (OpenmrsCoreModuleException coreModEx) {
			throw coreModEx;
		}
		try {
			Listener.performWebStartOfModules(servletContext);
			SchedulerUtil.startup(getRuntimeProperties());
		}
		catch (Exception t) {
			Context.shutdown();
			WebModuleUtil.shutdownModules(servletContext);
			throw new ServletException(t);
		}
		finally {
			Context.closeSession();
		}
		openmrsStarted = true;
	}
	private void loadConstants(ServletContext servletContext) {
		WebConstants.BUILD_TIMESTAMP = servletContext.getInitParameter("build.timestamp");
		WebConstants.WEBAPP_NAME = getContextPath(servletContext);
		WebConstants.MODULE_REPOSITORY_URL = servletContext.getInitParameter("module.repository.url");
		if (!"openmrs".equalsIgnoreCase(WebConstants.WEBAPP_NAME)) {
			OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY = WebConstants.WEBAPP_NAME
			        + "_APPLICATION_DATA_DIRECTORY";
		}
	}
	private void setApplicationDataDirectory(ServletContext servletContext) {
		String appDataDir = servletContext.getInitParameter("application.data.directory");
		if (StringUtils.hasLength(appDataDir)) {
			OpenmrsUtil.setApplicationDataDirectory(appDataDir);
		} else if (!"openmrs".equalsIgnoreCase(WebConstants.WEBAPP_NAME)) {
			OpenmrsUtil.setApplicationDataDirectory(
			    Paths.get(OpenmrsUtil.getApplicationDataDirectory(), WebConstants.WEBAPP_NAME).toString());
		}
	}
	private String getContextPath(ServletContext servletContext) {
		String contextPath = servletContext.getContextPath();
		if (contextPath.startsWith("/")) {
			contextPath = contextPath.substring(1);
		}
		return contextPath;
	}
	private void clearDWRFile(ServletContext servletContext) {
		File dwrFile = Paths.get(servletContext.getRealPath(""), "WEB-INF", "dwr-modules.xml").toFile();
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder db = dbf.newDocumentBuilder();
			db.setEntityResolver((publicId, systemId) -> new InputSource(new StringReader("")));
			Document doc = db.parse(dwrFile);
			Element elem = doc.getDocumentElement();
			elem.setTextContent("");
			OpenmrsUtil.saveDocument(doc, dwrFile);
		}
		catch (Exception e) {
			log.debug("Error clearing dwr-modules.xml", e);
			dwrFile.delete();
			OutputStreamWriter writer = null;
			try {
				writer = new OutputStreamWriter(new FileOutputStream(dwrFile), StandardCharsets.UTF_8);
				writer.write(
				    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE dwr PUBLIC \"-
			}
			catch (IOException io) {
				log.error(
				    "Unable to clear out the " + dwrFile.getAbsolutePath() + " file.  Please redeploy the openmrs war file",
				    io);
			}
			finally {
				if (writer != null) {
					try {
						writer.close();
					}
					catch (IOException io) {
						log.warn("Couldn't close Writer: " + io);
					}
				}
			}
		}
	}
	private void copyCustomizationIntoWebapp(ServletContext servletContext, Properties props) {
		String realPath = servletContext.getRealPath("");
		Map<String, String> custom = new HashMap<>();
		custom.put("custom.template.dir", "/WEB-INF/template");
		custom.put("custom.index.jsp.file", "/WEB-INF/view/index.jsp");
		custom.put("custom.login.jsp.file", "/WEB-INF/view/login.jsp");
		custom.put("custom.patientDashboardForm.jsp.file", "/WEB-INF/view/patientDashboardForm.jsp");
		custom.put("custom.images.dir", "/images");
		custom.put("custom.style.css.file", "/style.css");
		custom.put("custom.messages", "/WEB-INF/custom_messages.properties");
		custom.put("custom.messages_fr", "/WEB-INF/custom_messages_fr.properties");
		custom.put("custom.messages_es", "/WEB-INF/custom_messages_es.properties");
		custom.put("custom.messages_de", "/WEB-INF/custom_messages_de.properties");
		for (Map.Entry<String, String> entry : custom.entrySet()) {
			String prop = entry.getKey();
			String webappPath = entry.getValue();
			String userOverridePath = props.getProperty(prop);
			if (userOverridePath != null) {
				String absolutePath = realPath + webappPath;
				File file = new File(userOverridePath);
				if (file.exists() && !userOverridePath.startsWith(".")) {
					log.debug("Overriding file: " + absolutePath);
					log.debug("Overriding file with: " + userOverridePath);
					if (file.isDirectory()) {
						File[] files = file.listFiles();
						if (files != null) {
							for (File f : files) {
								userOverridePath = f.getAbsolutePath();
								if (!f.getName().startsWith(".")) {
									String tmpAbsolutePath = absolutePath + "/" + f.getName();
									if (!copyFile(userOverridePath, tmpAbsolutePath)) {
										log.warn("Unable to copy file in folder defined by runtime property: " + prop);
										log.warn("Your source directory (or a file in it) '" + userOverridePath
													+ " cannot be loaded or destination '" + tmpAbsolutePath + "' cannot be found");
									}
								}
							}
						}
					} else {
						if (!copyFile(userOverridePath, absolutePath)) {
							log.warn("Unable to copy file defined by runtime property: " + prop);
							log.warn("Your source file '" + userOverridePath + " cannot be loaded or destination '"
							        + absolutePath + "' cannot be found");
						}
					}
				}
			}
		}
	}
	private boolean copyFile(String fromPath, String toPath) {
		FileInputStream inputStream = null;
		FileOutputStream outputStream = null;
		try {
			inputStream = new FileInputStream(fromPath);
			outputStream = new FileOutputStream(toPath);
			OpenmrsUtil.copyFile(inputStream, outputStream);
		}
		catch (IOException io) {
			return false;
		}
		finally {
			try {
				if (inputStream != null) {
					inputStream.close();
				}
			}
			catch (IOException io) {
				log.warn("Unable to close input stream", io);
			}
			try {
				if (outputStream != null) {
					outputStream.close();
				}
			}
			catch (IOException io) {
				log.warn("Unable to close input stream", io);
			}
		}
		return true;
	}
	public static void loadBundledModules(ServletContext servletContext) {
		File folder = Paths.get(servletContext.getRealPath(""), "WEB-INF", "bundledModules").toFile();
		if (!folder.exists()) {
			log.warn("Bundled module folder doesn't exist: " + folder.getAbsolutePath());
			return;
		}
		if (!folder.isDirectory()) {
			log.warn("Bundled module folder isn't really a directory: " + folder.getAbsolutePath());
			return;
		}
		File[] files = folder.listFiles();
		if (files != null) {
			for (File f : files) {
				if (!f.getName().startsWith(".")) { 
					try {
						Module mod = ModuleFactory.loadModule(f);
						log.debug("Loaded bundled module: " + mod + " successfully");
					}
					catch (Exception e) {
						log.warn("Error while trying to load bundled module " + f.getName() + "", e);
					}
				}
			}
		}
	}
	@SuppressWarnings("squid:S1215")
	@Override
	public void contextDestroyed(ServletContextEvent event) {
		try {
			openmrsStarted = false;
			Context.openSession();
			Context.shutdown();
			WebModuleUtil.shutdownModules(event.getServletContext());
		}
		catch (Exception e) {
			if (!"contextDAO is null".equals(e.getMessage())) {
				System.out.println("Listener.contextDestroyed: Error while shutting down openmrs: ");
				log.error("Listener.contextDestroyed: Error while shutting down openmrs: ", e);
			}
		}
		finally {
			if ("true".equalsIgnoreCase(System.getProperty("FUNCTIONAL_TEST_MODE"))) {
				String filename = WebConstants.WEBAPP_NAME + "-test-runtime.properties";
				File file = new File(OpenmrsUtil.getApplicationDataDirectory(), filename);
				System.out.println(filename + " delete=" + file.delete());
			}
			Context.closeSession();
		}
		try {
			for (Enumeration<Driver> e = DriverManager.getDrivers(); e.hasMoreElements();) {
				Driver driver = e.nextElement();
				ClassLoader classLoader = driver.getClass().getClassLoader();
				if (classLoader == null || classLoader == getClass().getClassLoader()) {
					DriverManager.deregisterDriver(driver);
				} else {
					System.err.println("Didn't remove driver class: " + driver.getClass() + " with classloader of: "
					        + driver.getClass().getClassLoader());
				}
			}
		}
		catch (Exception e) {
			System.err.println("Listener.contextDestroyed: Failed to cleanup drivers in webapp");
			log.error("Listener.contextDestroyed: Failed to cleanup drivers in webapp", e);
		}
		MemoryLeakUtil.shutdownMysqlCancellationTimer();
		OpenmrsClassLoader.onShutdown();
		LogManager.shutdown();
		System.gc();
		System.gc();
	}
	public static Properties getRuntimeProperties() {
		return OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
	}
	public static void performWebStartOfModules(ServletContext servletContext) throws ModuleMustStartException, Exception {
		List<Module> startedModules = new ArrayList<>(ModuleFactory.getStartedModules());
		performWebStartOfModules(startedModules, servletContext);
	}
	public static void performWebStartOfModules(Collection<Module> startedModules, ServletContext servletContext)
	        throws ModuleMustStartException, Exception {
		boolean someModuleNeedsARefresh = false;
		for (Module mod : startedModules) {
			try {
				boolean thisModuleCausesRefresh = WebModuleUtil.startModule(mod, servletContext,
				    true);
				someModuleNeedsARefresh = someModuleNeedsARefresh || thisModuleCausesRefresh;
			}
			catch (Exception e) {
				mod.setStartupErrorMessage("Unable to start module", e);
			}
		}
		if (someModuleNeedsARefresh) {
			try {
				WebModuleUtil.refreshWAC(servletContext, true, null);
			}
			catch (ModuleMustStartException | BeanCreationException ex) {
				throw ex;
			}
			catch (Exception e) {
				Throwable rootCause = getActualRootCause(e, true);
				if (rootCause != null) {
					log.error(MarkerFactory.getMarker("FATAL"),
					    "Unable to refresh the spring application context.  Root Cause was:", rootCause);
				} else {
					log.error(MarkerFactory.getMarker("FATAL"),
					    "nable to refresh the spring application context. Unloading all modules,  Error was:", e);
				}
				try {
					WebModuleUtil.shutdownModules(servletContext);
					for (Module mod : ModuleFactory.getLoadedModules()) {
						if (!mod.isCoreModule() && !mod.isMandatory()) {
							try {
								ModuleFactory.stopModule(mod, true, true);
							}
							catch (Exception t3) {
								log.trace("Unable to shutdown module:" + mod, t3);
							}
						}
					}
					WebModuleUtil.refreshWAC(servletContext, true, null);
				}
				catch (MandatoryModuleException ex) {
					throw new MandatoryModuleException(ex.getModuleId(), "Got an error while starting a mandatory module: "
					        + e.getMessage() + ". Check the server logs for more information");
				}
				catch (Exception t2) {
					log.warn("caught another error: ", t2);
					throw t2;
				}
			}
		}
		for (Module mod : ModuleFactory.getStartedModulesInOrder()) {
			WebModuleUtil.loadServlets(mod, servletContext);
			WebModuleUtil.loadFilters(mod, servletContext);
		}
		servletContext.setAttribute(OpenmrsJspServlet.OPENMRS_TLD_SCAN_NEEDED, true);
	}
	private static Throwable getActualRootCause(Throwable t, boolean isOriginalError) {
		if (t.getCause() != null) {
			return getActualRootCause(t.getCause(), false);
		}
		if (!isOriginalError) {
			return t;
		}
		return null;
	}
}
package org.openmrs.util;
import liquibase.Liquibase;
import org.openmrs.liquibase.LiquibaseProvider;
public class DatabaseUpdaterLiquibaseProvider implements LiquibaseProvider {
	@Override
	public Liquibase getLiquibase(String changeLogFile) throws Exception {
		return DatabaseUpdater.getLiquibase(changeLogFile);
	}
}
package org.openmrs.liquibase;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import liquibase.Contexts;
import liquibase.LabelExpression;
import liquibase.Liquibase;
import liquibase.changelog.ChangeSet;
import liquibase.command.core.StatusCommandStep;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ChangeLogDetective {
	private static final Logger log = LoggerFactory.getLogger("org.openmrs.api.ChangeLogDetective");
	private static final String BEN = "ben";
	private static final String DEFAULT_SNAPSHOT_VERSION = "1.9.x";
	private static final String DISABLE_FOREIGN_KEY_CHECKS = "disable-foreign-key-checks";
	private static final String ENABLE_FOREIGN_KEY_CHECKS = "enable-foreign-key-checks";
	private static final int MAX_NUMBER_OF_CHANGE_SETS_TO_LOG = 10;
	private static final String LIQUIBASE_CORE_DATA_1_9_X_FILENAME = "liquibase-core-data-1.9.x.xml";
	private static final String LIQUIBASE_SCHEMA_ONLY_1_9_X_FILENAME = "liquibase-schema-only-1.9.x.xml";
	private ChangeLogVersionFinder changeLogVersionFinder;
	public ChangeLogDetective() {
		changeLogVersionFinder = new ChangeLogVersionFinder();
	}
	public String getInitialLiquibaseSnapshotVersion(String context, LiquibaseProvider liquibaseProvider) throws Exception {
		log.info("identifying the Liquibase snapshot version that had been used to initialize the OpenMRS database...");
		Map<String, List<String>> snapshotCombinations = changeLogVersionFinder.getSnapshotCombinations();
		if (snapshotCombinations.isEmpty()) {
			throw new IllegalStateException(
			        "identifying the Liqubase snapshot version that had been used to initialize the OpenMRS database failed as no candidate change sets were found");
		}
		List<String> snapshotVersions = getSnapshotVersionsInDescendingOrder(snapshotCombinations);
		for (String version : snapshotVersions) {
			int unrunChangeSetsCount = 0;
			log.info("looking for un-run change sets in snapshot version '{}'", version);
			List<String> changeSets = snapshotCombinations.get(version);
			Contexts contexts = new Contexts(context);
			for (String filename : changeSets) {
				List<ChangeSet> rawUnrunChangeSets = getUnrunChangeSets(filename, contexts, liquibaseProvider);
				List<ChangeSet> refinedUnrunChangeSets = excludeVintageChangeSets(filename, rawUnrunChangeSets);
				log.info("file '{}' contains {} un-run change sets", filename, refinedUnrunChangeSets.size());
				logUnRunChangeSetDetails(filename, refinedUnrunChangeSets);
				unrunChangeSetsCount += refinedUnrunChangeSets.size();
			}
			if (unrunChangeSetsCount == 0) {
				log.info("the Liquibase snapshot version that had been used to initialize the OpenMRS database is '{}'",
				    version);
				return version;
			}
		}
		log.info(
		    "the snapshot version that had been used to initialize the OpenMRS database could not be identified, falling back to the default version '{}'",
		    DEFAULT_SNAPSHOT_VERSION);
		return DEFAULT_SNAPSHOT_VERSION;
	}
	public List<String> getUnrunLiquibaseUpdateFileNames(String snapshotVersion, String context,
	        LiquibaseProvider liquibaseProvider) throws Exception {
		List<String> unrunLiquibaseUpdates = new ArrayList<>();
		List<String> updateVersions = changeLogVersionFinder.getUpdateVersionsGreaterThan(snapshotVersion);
		List<String> updateFileNames = changeLogVersionFinder.getUpdateFileNames(updateVersions);
		Contexts contexts = new Contexts(context);
		for (String filename : updateFileNames) {
			List<ChangeSet> unrunChangeSets = getUnrunChangeSets(filename, contexts, liquibaseProvider);
			log.info("file '{}' contains {} un-run change sets", filename, unrunChangeSets.size());
			logUnRunChangeSetDetails(filename, unrunChangeSets);
			if (!unrunChangeSets.isEmpty()) {
				unrunLiquibaseUpdates.add(filename);
			}
		}
		return unrunLiquibaseUpdates;
	}
	List<String> getSnapshotVersionsInDescendingOrder(Map<String, List<String>> snapshotCombinations) {
		List<String> versions = new ArrayList<>(snapshotCombinations.keySet());
		versions.sort(Collections.reverseOrder());
		return versions;
	}
	List<ChangeSet> excludeVintageChangeSets(String filename, List<ChangeSet> changeSets) {
		List<ChangeSet> result = new ArrayList<>();
		for (ChangeSet changeSet : changeSets) {
			if (!isVintageChangeSet(filename, changeSet)) {
				result.add(changeSet);
			}
		}
		return result;
	}
	List<ChangeSet> getUnrunChangeSets(String filename, Contexts context, LiquibaseProvider liquibaseProvider) throws Exception {
		String scopeId = LiquibaseScopeHandling.enterLiquibaseUILoggingService();
		Liquibase liquibase = liquibaseProvider.getLiquibase(filename);
		List<ChangeSet> unrunChangeSets;
		try {
			unrunChangeSets = new StatusCommandStep()
				.listUnrunChangeSets(context,
					new LabelExpression(), liquibase.getDatabaseChangeLog(), liquibase.getDatabase());
		} finally {
			LiquibaseScopeHandling.exitLiquibaseScope(scopeId);
			liquibase.close();
		}
		return unrunChangeSets;
	}
	boolean isVintageChangeSet(String filename, ChangeSet changeSet) {
		if (filename != null && filename.contains(LIQUIBASE_CORE_DATA_1_9_X_FILENAME) && changeSet.getAuthor().equals(BEN)) {
			return changeSet.getId().equals(DISABLE_FOREIGN_KEY_CHECKS) || changeSet.getId().equals(ENABLE_FOREIGN_KEY_CHECKS);
		}
		return false;
	}
	boolean logUnRunChangeSetDetails(String filename, List<ChangeSet> changeSets) {
		if (changeSets.size() < MAX_NUMBER_OF_CHANGE_SETS_TO_LOG && (filename.contains(LIQUIBASE_CORE_DATA_1_9_X_FILENAME)
		        || filename.contains(LIQUIBASE_SCHEMA_ONLY_1_9_X_FILENAME))) {
			if (log.isInfoEnabled()) {
				for (ChangeSet changeSet : changeSets) {
					log.info("file '{}' contains un-run change set with id '{}' by author '{}'", filename, changeSet.getId(),
						changeSet.getAuthor());
				}
			}
			return true;
		}
		return false;
	}
}
package org.openmrs.web.filter.util;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.DatabaseUtil;
import org.openmrs.util.OpenmrsConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class FilterUtil {
	private FilterUtil() {
	}
	private static final Logger log = LoggerFactory.getLogger(FilterUtil.class);
	private static final String DATABASE_CLOSING_ERROR = "Error while closing the database";
	public static final String LOCALE_ATTRIBUTE = "locale";
	public static final String REMEMBER_ATTRIBUTE = "remember";
	public static final String ADMIN_USERNAME = "admin";
	public static String restoreLocale(String username) {
		String currentLocale = null;
		if (StringUtils.isNotBlank(username)) {
			PreparedStatement statement = null;
			Connection connection = null;
			ResultSet results = null;
			try {
				connection = DatabaseUpdater.getConnection();
				Integer userId = getUserIdByName(username, connection);
				if (userId != null) {
					String select = "select property_value from user_property where user_id = ? and property = ?";
					statement = connection.prepareStatement(select);
					statement.setInt(1, userId);
					statement.setString(2, OpenmrsConstants.USER_PROPERTY_DEFAULT_LOCALE);
					if (statement.execute()) {
						results = statement.getResultSet();
						if (results.next()) {
							currentLocale = results.getString(1);
						}
					}
				}
				if (currentLocale == null) {
					currentLocale = readSystemDefaultLocale(connection);
				}
			}
			catch (Exception e) {
				log.error("Error while retriving locale property", e);
			}
			finally {
				try {
					if (statement != null) {
						statement.close();
					}
				}
				catch (SQLException e) {
					log.warn("Error while closing statement");
				}
				if (connection != null) {
					try {
						connection.close();
					}
					catch (SQLException e) {
						log.debug(DATABASE_CLOSING_ERROR, e);
					}
				}
				if (results != null) {
					try {
						results.close();
					}
					catch (SQLException e) {
						log.warn("Error while closing ResultSet", e);
					}
				}
			}
		}
		if (currentLocale == null) {
			currentLocale = OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE_DEFAULT_VALUE;
		}
		return currentLocale;
	}
	public static String readSystemDefaultLocale(Connection connection) {
		String systemDefaultLocale = null;
		boolean needToCloseConection = false;
		try {
			if (connection == null) {
				connection = DatabaseUpdater.getConnection();
				needToCloseConection = true;
			}
			String select = "select property_value from global_property where property = ?";
			PreparedStatement statement = connection.prepareStatement(select);
			statement.setString(1, OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE);
			if (statement.execute()) {
				ResultSet results = statement.getResultSet();
				if (results.next()) {
					systemDefaultLocale = results.getString(1);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while retrieving system default locale", e);
		}
		finally {
			if (needToCloseConection && connection != null) {
				try {
					connection.close();
				}
				catch (SQLException e) {
					log.debug(DATABASE_CLOSING_ERROR, e);
				}
			}
		}
		return systemDefaultLocale;
	}
	public static boolean storeLocale(String locale) {
		if (StringUtils.isNotBlank(locale)) {
			Connection connection = null;
			Integer userId = null;
			try {
				connection = DatabaseUpdater.getConnection();
				userId = getUserIdByName(ADMIN_USERNAME, connection);
				if (userId != null) {
					String insert = "insert into user_property (user_id, property, property_value) values (?, 'defaultLocale', ?)";
					PreparedStatement statement = null;
					try {
						statement = connection.prepareStatement(insert);
						statement.setInt(1, userId);
						statement.setString(2, locale);
						if (statement.executeUpdate() != 1) {
							log.warn("Unable to save user locale as admin property.");
						}
					}
					finally {
						if (statement != null) {
							try {
								statement.close();
							}
							catch (Exception statementCloseEx) {
								log.error("Failed to quietly close Statement", statementCloseEx);
							}
						}
					}
				}
				String update = "update global_property set property_value = ? where property = ? ";
				PreparedStatement statement = null;
				try {
					statement = connection.prepareStatement(update);
					statement.setString(1, locale);
					statement.setString(2, OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE);
					if (statement.executeUpdate() != 1) {
						log.warn("Unable to set system default locale property.");
					}
				}
				finally {
					if (statement != null) {
						try {
							statement.close();
						}
						catch (Exception statementCloseEx) {
							log.error("Failed to quietly close Statement", statementCloseEx);
						}
					}
				}
			}
			catch (Exception e) {
				log.warn("Locale " + locale + " could not be set for user with id " + userId + " .", e);
				return false;
			}
			finally {
				if (connection != null) {
					try {
						connection.close();
					}
					catch (SQLException e) {
						log.debug(DATABASE_CLOSING_ERROR, e);
					}
				}
			}
			return true;
		}
		return false;
	}
	public static Integer getUserIdByName(String userNameOrSystemId, Connection connection) throws SQLException {
		String select = "select user_id from users where system_id = ? or username = ?";
		PreparedStatement statement = connection.prepareStatement(select);
		statement.setString(1, userNameOrSystemId);
		statement.setString(2, userNameOrSystemId);
		Integer userId = null;
		if (statement.execute()) {
			ResultSet results = statement.getResultSet();
			if (results.next()) {
				userId = results.getInt(1);
			}
		}
		return userId;
	}
	public static String getGlobalPropertyValue(String globalPropertyName) {
		String propertyValue = null;
		Connection connection = null;
		try {
			connection = DatabaseUpdater.getConnection();
			List<List<Object>> results = DatabaseUtil.executeSQL(connection,
			    "select property_value from global_property where property = '" + globalPropertyName + "'", true);
			if (results.size() == 1 && results.get(0).size() == 1) {
				propertyValue = results.get(0).get(0).toString();
			}
		}
		catch (Exception e) {
			log.error("Error while retrieving value for global property:" + globalPropertyName, e);
		}
		finally {
			if (connection != null) {
				try {
					connection.close();
				}
				catch (SQLException e) {
					log.debug("Error while closing the database connection", e);
				}
			}
		}
		return propertyValue;
	}
}
package org.openmrs.liquibase;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.openmrs.module.VersionComparator;
public class ChangeLogVersionFinder {
	static final String BASE_FOLDER_NAME = "org" + File.separator + "openmrs" + File.separator + "liquibase";
	static final String CORE_DATA_FOLDER_NAME = BASE_FOLDER_NAME + File.separator + "snapshots" + File.separator
	        + "core-data";
	static final String SCHEMA_ONLY_FOLDER_NAME = BASE_FOLDER_NAME + File.separator + "snapshots" + File.separator
	        + "schema-only";
	static final String UPDATES_FOLDER_NAME = BASE_FOLDER_NAME + File.separator + "updates";
	static final String CORE_DATA_BASE_NAME = "liquibase-core-data-";
	static final String SCHEMA_ONLY_BASE_NAME = "liquibase-schema-only-";
	static final String UPDATE_TO_LATEST_BASE_NAME = "liquibase-update-to-latest-";
	private static final String DOT_XML = ".xml";
	private static final String LOWER_CASE_X = "x";
	private static final Pattern MAJOR_MINOR_PATTERN = Pattern.compile("(\\d+\\.\\d+\\.)");
	private ChangeLogVersions changeLogVersions;
	public ChangeLogVersionFinder() {
		this.changeLogVersions = new ChangeLogVersions();
	}
	public ChangeLogVersionFinder(ChangeLogVersions changeLogVersions) {
		this.changeLogVersions = changeLogVersions;
	}
	public SortedMap<String, List<String>> getChangeLogCombinations() {
		SortedMap<String, List<String>> changeLogCombinations = new TreeMap<>();
		for (String snapshotVersion : getSnapshotVersions()) {
			List<String> changeLogFilenames = new ArrayList<>();
			changeLogFilenames.addAll(getSnapshotFilenames(snapshotVersion));
			changeLogFilenames.addAll(getUpdateFileNames(getUpdateVersionsGreaterThan(snapshotVersion)));
			changeLogCombinations.put(snapshotVersion, changeLogFilenames);
		}
		return changeLogCombinations;
	}
	public SortedMap<String, List<String>> getSnapshotCombinations() {
		SortedMap<String, List<String>> changeLogCombinations = new TreeMap<>();
		for (String snapshotVersion : getSnapshotVersions()) {
			List<String> changeLogFilenames = new ArrayList<>(getSnapshotFilenames(snapshotVersion));
			changeLogCombinations.put(snapshotVersion, changeLogFilenames);
		}
		return changeLogCombinations;
	}
	public List<String> getSnapshotFilenames(String version) {
		String versionAsDotX = getVersionAsDotX(version);
		return Arrays.asList(SCHEMA_ONLY_FOLDER_NAME + File.separator + SCHEMA_ONLY_BASE_NAME + versionAsDotX + DOT_XML,
		    CORE_DATA_FOLDER_NAME + File.separator + CORE_DATA_BASE_NAME + versionAsDotX + DOT_XML);
	}
	public Optional<String> getLatestSnapshotVersion() {
		return getSnapshotVersions().stream().max(new VersionComparator());
	}
	public Optional<String> getLatestSchemaSnapshotFilename() {
		return getLatestSnapshotVersion().map(
			snapshotVersion -> SCHEMA_ONLY_FOLDER_NAME + File.separator + SCHEMA_ONLY_BASE_NAME + snapshotVersion + DOT_XML);
	}
	public Optional<String> getLatestCoreDataSnapshotFilename() {
		return getLatestSnapshotVersion().map(
			snapshotVersion -> CORE_DATA_FOLDER_NAME + File.separator + CORE_DATA_BASE_NAME + snapshotVersion + DOT_XML);
	}
	public List<String> getUpdateVersionsGreaterThan(String otherVersion) {
		String versionAsDotX = getVersionAsDotX(otherVersion);
		VersionComparator versionComparator = new VersionComparator();
		return getUpdateVersions().stream()
		        .filter(updateVersion -> versionComparator.compare(updateVersion, versionAsDotX) > 0)
		        .sorted(versionComparator).collect(Collectors.toList());
	}
	public List<String> getUpdateFileNames(List<String> versions) {
		return versions.stream()
		        .map(version -> UPDATES_FOLDER_NAME + File.separator + UPDATE_TO_LATEST_BASE_NAME + version + DOT_XML)
		        .collect(Collectors.toList());
	}
	List<String> getSnapshotVersions() {
		return changeLogVersions.getSnapshotVersions();
	}
	List<String> getUpdateVersions() {
		return changeLogVersions.getUpdateVersions();
	}
	String getVersionAsDotX(String version) {
		Matcher matcher = MAJOR_MINOR_PATTERN.matcher(version);
		if (matcher.find()) {
			return matcher.group(1) + LOWER_CASE_X;
		}
		throw new IllegalArgumentException(
		        String.format("version string '%s' does not match 'major.minor.' pattern", version));
	}
}
package org.openmrs.web.filter.initialization;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Base64.Encoder;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Random;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.zip.ZipInputStream;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import liquibase.changelog.ChangeSet;
import org.apache.commons.io.IOUtils;
import org.openmrs.ImplementationId;
import org.openmrs.api.APIAuthenticationException;
import org.openmrs.api.PasswordException;
import org.openmrs.api.UserService;
import org.openmrs.api.context.Context;
import org.openmrs.api.context.ContextAuthenticationException;
import org.openmrs.api.context.UsernamePasswordCredentials;
import org.openmrs.api.impl.UserServiceImpl;
import org.openmrs.liquibase.ChangeLogDetective;
import org.openmrs.liquibase.ChangeLogVersionFinder;
import org.openmrs.module.MandatoryModuleException;
import org.openmrs.module.OpenmrsCoreModuleException;
import org.openmrs.module.web.WebModuleUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.liquibase.ChangeSetExecutorCallback;
import org.openmrs.util.DatabaseUpdaterLiquibaseProvider;
import org.openmrs.util.DatabaseUtil;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsThreadPoolHolder;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.util.Security;
import org.openmrs.web.Listener;
import org.openmrs.web.WebConstants;
import org.openmrs.web.WebDaemon;
import org.openmrs.web.filter.StartupFilter;
import org.openmrs.web.filter.update.UpdateFilter;
import org.openmrs.web.filter.util.CustomResourceLoader;
import org.openmrs.web.filter.util.ErrorMessageConstants;
import org.openmrs.web.filter.util.FilterUtil;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;
import org.springframework.web.context.ContextLoader;
public class InitializationFilter extends StartupFilter {
	private static final org.slf4j.Logger log = LoggerFactory.getLogger(InitializationFilter.class);
	private static final String DATABASE_POSTGRESQL = "postgresql";
	private static final String DATABASE_MYSQL = "mysql";
	private static final String DATABASE_SQLSERVER = "sqlserver";
	private static final String DATABASE_H2 = "h2";
	private static final String LIQUIBASE_DEMO_DATA = "liquibase-demo-data.xml";
	private static final String CHOOSE_LANG = "chooselang.vm";
	private static final String INSTALL_METHOD = "installmethod.vm";
	private static final String SIMPLE_SETUP = "simplesetup.vm";
	private static final String DATABASE_SETUP = "databasesetup.vm";
	private static final String TESTING_REMOTE_DETAILS_SETUP = "remotedetails.vm";
	private static final String DEFAULT_PAGE = CHOOSE_LANG;
	private static final String DATABASE_TABLES_AND_USER = "databasetablesanduser.vm";
	private static final String ADMIN_USER_SETUP = "adminusersetup.vm";
	private static final String IMPLEMENTATION_ID_SETUP = "implementationidsetup.vm";
	private static final String OTHER_RUNTIME_PROPS = "otherruntimeproperties.vm";
	private static final String WIZARD_COMPLETE = "wizardcomplete.vm";
	private static final String PROGRESS_VM = "progress.vm";
	private static final String PROGRESS_VM_AJAXREQUEST = "progress.vm.ajaxRequest";
	public static final String RELEASE_TESTING_MODULE_PATH = "/module/releasetestinghelper/";
	private InitializationWizardModel wizardModel = null;
	private InitializationCompletion initJob;
	private static boolean isInstallationStarted = false;
	private String loadedDriverString;
	private static boolean initializationComplete = false;
	protected synchronized void setInitializationComplete(boolean initializationComplete) {
		InitializationFilter.initializationComplete = initializationComplete;
	}
	@Override
	protected void doGet(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
		throws IOException, ServletException {
		loadInstallationScriptIfPresent();
		if (httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE) == null) {
			checkLocaleAttributesForFirstTime(httpRequest);
		}
		Map<String, Object> referenceMap = new HashMap<>();
		String page = httpRequest.getParameter("page");
		referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE, httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
		httpResponse.setHeader("Cache-Control", "no-cache");
		if (isInstallationStarted() && !PROGRESS_VM_AJAXREQUEST.equals(page)) {
			referenceMap.put("isInstallationStarted", true);
			httpResponse.setContentType("text/html");
			renderTemplate(PROGRESS_VM, referenceMap, httpResponse);
		} else if (PROGRESS_VM_AJAXREQUEST.equals(page)) {
			httpResponse.setContentType("text/json");
			Map<String, Object> result = new HashMap<>();
			if (initJob != null) {
				result.put("hasErrors", initJob.hasErrors());
				if (initJob.hasErrors()) {
					result.put("errorPage", initJob.getErrorPage());
					errors.putAll(initJob.getErrors());
				}
				result.put("initializationComplete", isInitializationComplete());
				result.put("message", initJob.getMessage());
				result.put("actionCounter", initJob.getStepsComplete());
				if (!isInitializationComplete()) {
					result.put("executingTask", initJob.getExecutingTask());
					result.put("executedTasks", initJob.getExecutedTasks());
					result.put("completedPercentage", initJob.getCompletedPercentage());
				}
				addLogLinesToResponse(result);
			}
			PrintWriter writer = httpResponse.getWriter();
			writer.write(toJSONString(result));
			writer.close();
		} else if (InitializationWizardModel.INSTALL_METHOD_AUTO.equals(wizardModel.installMethod)
			|| httpRequest.getServletPath().equals("/" + AUTO_RUN_OPENMRS)) {
			autoRunOpenMRS(httpRequest);
			referenceMap.put("isInstallationStarted", true);
			httpResponse.setContentType("text/html");
			renderTemplate(PROGRESS_VM, referenceMap, httpResponse);
		} else if (page == null) {
			httpResponse.setContentType("text/html");
			clearPasswords();
			renderTemplate(DEFAULT_PAGE, referenceMap, httpResponse);
		} else if (INSTALL_METHOD.equals(page)) {
			File runtimeProperties = getRuntimePropertiesFile();
			if (!runtimeProperties.exists()) {
				try {
					runtimeProperties.createNewFile();
					wizardModel.canCreate = true;
					wizardModel.cannotCreateErrorMessage = "";
				}
				catch (IOException io) {
					wizardModel.canCreate = false;
					wizardModel.cannotCreateErrorMessage = io.getMessage();
				}
				wizardModel.canWrite = runtimeProperties.canWrite();
				runtimeProperties.delete();
			} else {
				wizardModel.canWrite = runtimeProperties.canWrite();
				wizardModel.databaseConnection = Context.getRuntimeProperties().getProperty("connection.url",
					wizardModel.databaseConnection);
				wizardModel.currentDatabaseUsername = Context.getRuntimeProperties().getProperty("connection.username",
					wizardModel.currentDatabaseUsername);
				wizardModel.currentDatabasePassword = Context.getRuntimeProperties().getProperty("connection.password",
					wizardModel.currentDatabasePassword);
			}
			wizardModel.runtimePropertiesPath = runtimeProperties.getAbsolutePath();
			httpResponse.setContentType("text/html");
			renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
		}
	}
	private void loadInstallationScriptIfPresent() {
		Properties script = getInstallationScript();
		if (!script.isEmpty()) {
			wizardModel.installMethod = script.getProperty("install_method", wizardModel.installMethod);
			wizardModel.databaseConnection = script.getProperty("connection.url", wizardModel.databaseConnection);
			wizardModel.databaseDriver = script.getProperty("connection.driver_class", wizardModel.databaseDriver);
			wizardModel.currentDatabaseUsername = script.getProperty("connection.username",
				wizardModel.currentDatabaseUsername);
			wizardModel.currentDatabasePassword = script.getProperty("connection.password",
				wizardModel.currentDatabasePassword);
			String hasCurrentOpenmrsDatabase = script.getProperty("has_current_openmrs_database");
			if (hasCurrentOpenmrsDatabase != null) {
				wizardModel.hasCurrentOpenmrsDatabase = Boolean.valueOf(hasCurrentOpenmrsDatabase);
			}
			wizardModel.createDatabaseUsername = script.getProperty("create_database_username",
				wizardModel.createDatabaseUsername);
			wizardModel.createDatabasePassword = script.getProperty("create_database_password",
				wizardModel.createDatabasePassword);
			String createTables = script.getProperty("create_tables");
			if (createTables != null) {
				wizardModel.createTables = Boolean.valueOf(createTables);
			}
			String createDatabaseUser = script.getProperty("create_database_user");
			if (createDatabaseUser != null) {
				wizardModel.createDatabaseUser = Boolean.valueOf(createDatabaseUser);
			}
			wizardModel.createUserUsername = script.getProperty("create_user_username", wizardModel.createUserUsername);
			wizardModel.createUserPassword = script.getProperty("create_user_password", wizardModel.createUserPassword);
			String addDemoData = script.getProperty("add_demo_data");
			if (addDemoData != null) {
				wizardModel.addDemoData = Boolean.valueOf(addDemoData);
			}
			String moduleWebAdmin = script.getProperty("module_web_admin");
			if (moduleWebAdmin != null) {
				wizardModel.moduleWebAdmin = Boolean.valueOf(moduleWebAdmin);
			}
			String autoUpdateDatabase = script.getProperty("auto_update_database");
			if (autoUpdateDatabase != null) {
				wizardModel.autoUpdateDatabase = Boolean.valueOf(autoUpdateDatabase);
			}
			wizardModel.adminUserPassword = script.getProperty("admin_user_password", wizardModel.adminUserPassword);
		}
	}
	private void clearPasswords() {
		wizardModel.databaseRootPassword = "";
		wizardModel.createDatabasePassword = "";
		wizardModel.createUserPassword = "";
		wizardModel.currentDatabasePassword = "";
		wizardModel.remotePassword = "";
	}
	@Override
	protected void doPost(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
		throws IOException, ServletException {
		String page = httpRequest.getParameter("page");
		Map<String, Object> referenceMap = new HashMap<>();
		if (httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE) != null) {
			referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE,
				httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
		}
		if (isInstallationStarted()) {
			referenceMap.put("isInstallationStarted", true);
			httpResponse.setContentType("text/html");
			renderTemplate(PROGRESS_VM, referenceMap, httpResponse);
			return;
		}
		if (DEFAULT_PAGE.equals(page)) {
			File runtimeProperties = getRuntimePropertiesFile();
			if (!runtimeProperties.exists()) {
				try {
					runtimeProperties.createNewFile();
					wizardModel.canCreate = true;
					wizardModel.cannotCreateErrorMessage = "";
				}
				catch (IOException io) {
					wizardModel.canCreate = false;
					wizardModel.cannotCreateErrorMessage = io.getMessage();
				}
				wizardModel.canWrite = runtimeProperties.canWrite();
				runtimeProperties.delete();
			} else {
				wizardModel.canWrite = runtimeProperties.canWrite();
				wizardModel.databaseConnection = Context.getRuntimeProperties().getProperty("connection.url",
					wizardModel.databaseConnection);
				wizardModel.currentDatabaseUsername = Context.getRuntimeProperties().getProperty("connection.username",
					wizardModel.currentDatabaseUsername);
				wizardModel.currentDatabasePassword = Context.getRuntimeProperties().getProperty("connection.password",
					wizardModel.currentDatabasePassword);
			}
			wizardModel.runtimePropertiesPath = runtimeProperties.getAbsolutePath();
			checkLocaleAttributes(httpRequest);
			referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE,
				httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
			log.info("Locale stored in session is " + httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
			httpResponse.setContentType("text/html");
			renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
		} else if (INSTALL_METHOD.equals(page)) {
			if (goBack(httpRequest)) {
				referenceMap.put(FilterUtil.REMEMBER_ATTRIBUTE,
					httpRequest.getSession().getAttribute(FilterUtil.REMEMBER_ATTRIBUTE) != null);
				referenceMap.put(FilterUtil.LOCALE_ATTRIBUTE,
					httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE));
				renderTemplate(CHOOSE_LANG, referenceMap, httpResponse);
				return;
			}
			wizardModel.installMethod = httpRequest.getParameter("install_method");
			if (InitializationWizardModel.INSTALL_METHOD_SIMPLE.equals(wizardModel.installMethod)) {
				page = SIMPLE_SETUP;
			} else if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
				page = TESTING_REMOTE_DETAILS_SETUP;
				wizardModel.currentStepNumber = 1;
				wizardModel.numberOfSteps = skipDatabaseSetupPage() ? 1 : 3;
			} else {
				page = DATABASE_SETUP;
				wizardModel.currentStepNumber = 1;
				wizardModel.numberOfSteps = 5;
			}
			renderTemplate(page, referenceMap, httpResponse);
		} 
		else if (SIMPLE_SETUP.equals(page)) {
			if (goBack(httpRequest)) {
				renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
				return;
			}
			wizardModel.databaseConnection = httpRequest.getParameter("database_connection");
			;
			wizardModel.createDatabaseUsername = Context.getRuntimeProperties().getProperty("connection.username",
				wizardModel.createDatabaseUsername);
			wizardModel.createUserUsername = wizardModel.createDatabaseUsername;
			wizardModel.databaseRootPassword = httpRequest.getParameter("database_root_password");
			checkForEmptyValue(wizardModel.databaseRootPassword, errors, ErrorMessageConstants.ERROR_DB_PSDW_REQ);
			wizardModel.hasCurrentOpenmrsDatabase = false;
			wizardModel.createTables = true;
			wizardModel.createDatabasePassword = wizardModel.databaseRootPassword;
			wizardModel.addDemoData = "yes".equals(httpRequest.getParameter("add_demo_data"));
			wizardModel.hasCurrentDatabaseUser = false;
			wizardModel.createDatabaseUser = true;
			wizardModel.createUserPassword = wizardModel.databaseRootPassword;
			wizardModel.moduleWebAdmin = true;
			wizardModel.autoUpdateDatabase = false;
			wizardModel.adminUserPassword = InitializationWizardModel.ADMIN_DEFAULT_PASSWORD;
			createSimpleSetup(httpRequest.getParameter("database_root_password"), httpRequest.getParameter("add_demo_data"));
			try {
				loadedDriverString = DatabaseUtil.loadDatabaseDriver(wizardModel.databaseConnection,
					wizardModel.databaseDriver);
			}
			catch (ClassNotFoundException e) {
				errors.put(ErrorMessageConstants.ERROR_DB_DRIVER_CLASS_REQ, null);
				renderTemplate(page, referenceMap, httpResponse);
				return;
			}
			if (errors.isEmpty()) {
				page = WIZARD_COMPLETE;
			}
			renderTemplate(page, referenceMap, httpResponse);
		} 
		else if (DATABASE_SETUP.equals(page)) {
			if (goBack(httpRequest)) {
				wizardModel.currentStepNumber -= 1;
				if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
					renderTemplate(TESTING_REMOTE_DETAILS_SETUP, referenceMap, httpResponse);
				} else {
					renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
				}
				return;
			}
			wizardModel.databaseConnection = httpRequest.getParameter("database_connection");
			checkForEmptyValue(wizardModel.databaseConnection, errors, ErrorMessageConstants.ERROR_DB_CONN_REQ);
			wizardModel.databaseDriver = httpRequest.getParameter("database_driver");
			checkForEmptyValue(wizardModel.databaseConnection, errors, ErrorMessageConstants.ERROR_DB_DRIVER_REQ);
			loadedDriverString = loadDriver(wizardModel.databaseConnection, wizardModel.databaseDriver);
			if (!StringUtils.hasText(loadedDriverString)) {
				errors.put(ErrorMessageConstants.ERROR_DB_DRIVER_CLASS_REQ, null);
				renderTemplate(page, referenceMap, httpResponse);
				return;
			}
			if ("yes".equals(httpRequest.getParameter("current_openmrs_database"))) {
				wizardModel.databaseName = httpRequest.getParameter("openmrs_current_database_name");
				checkForEmptyValue(wizardModel.databaseName, errors, ErrorMessageConstants.ERROR_DB_CURR_NAME_REQ);
				wizardModel.hasCurrentOpenmrsDatabase = true;
			} else {
				wizardModel.hasCurrentOpenmrsDatabase = false;
				wizardModel.createTables = true;
				wizardModel.databaseName = httpRequest.getParameter("openmrs_new_database_name");
				checkForEmptyValue(wizardModel.databaseName, errors, ErrorMessageConstants.ERROR_DB_NEW_NAME_REQ);
				wizardModel.createDatabaseUsername = httpRequest.getParameter("create_database_username");
				checkForEmptyValue(wizardModel.createDatabaseUsername, errors, ErrorMessageConstants.ERROR_DB_USER_NAME_REQ);
				wizardModel.createDatabasePassword = httpRequest.getParameter("create_database_password");
				checkForEmptyValue(wizardModel.createDatabasePassword, errors, ErrorMessageConstants.ERROR_DB_USER_PSWD_REQ);
			}
			if (errors.isEmpty()) {
				page = DATABASE_TABLES_AND_USER;
				if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
					wizardModel.currentStepNumber = 3;
				} else {
					wizardModel.currentStepNumber = 2;
				}
			}
			renderTemplate(page, referenceMap, httpResponse);
		} 
		else if (DATABASE_TABLES_AND_USER.equals(page)) {
			if (goBack(httpRequest)) {
				wizardModel.currentStepNumber -= 1;
				renderTemplate(DATABASE_SETUP, referenceMap, httpResponse);
				return;
			}
			if (wizardModel.hasCurrentOpenmrsDatabase) {
				wizardModel.createTables = "yes".equals(httpRequest.getParameter("create_tables"));
			}
			wizardModel.addDemoData = "yes".equals(httpRequest.getParameter("add_demo_data"));
			if ("yes".equals(httpRequest.getParameter("current_database_user"))) {
				wizardModel.currentDatabaseUsername = httpRequest.getParameter("current_database_username");
				checkForEmptyValue(wizardModel.currentDatabaseUsername, errors,
					ErrorMessageConstants.ERROR_DB_CUR_USER_NAME_REQ);
				wizardModel.currentDatabasePassword = httpRequest.getParameter("current_database_password");
				checkForEmptyValue(wizardModel.currentDatabasePassword, errors,
					ErrorMessageConstants.ERROR_DB_CUR_USER_PSWD_REQ);
				wizardModel.hasCurrentDatabaseUser = true;
				wizardModel.createDatabaseUser = false;
			} else {
				wizardModel.hasCurrentDatabaseUser = false;
				wizardModel.createDatabaseUser = true;
				wizardModel.createUserUsername = httpRequest.getParameter("create_user_username");
				checkForEmptyValue(wizardModel.createUserUsername, errors, ErrorMessageConstants.ERROR_DB_USER_NAME_REQ);
				wizardModel.createUserPassword = httpRequest.getParameter("create_user_password");
				checkForEmptyValue(wizardModel.createUserPassword, errors, ErrorMessageConstants.ERROR_DB_USER_PSWD_REQ);
			}
			if (errors.isEmpty()) { 
				page = InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod) ? WIZARD_COMPLETE
					: OTHER_RUNTIME_PROPS;
			}
			renderTemplate(page, referenceMap, httpResponse);
		} 
		else if (OTHER_RUNTIME_PROPS.equals(page)) {
			if (goBack(httpRequest)) {
				renderTemplate(DATABASE_TABLES_AND_USER, referenceMap, httpResponse);
				return;
			}
			wizardModel.moduleWebAdmin = "yes".equals(httpRequest.getParameter("module_web_admin"));
			wizardModel.autoUpdateDatabase = "yes".equals(httpRequest.getParameter("auto_update_database"));
			if (wizardModel.createTables) { 
				page = ADMIN_USER_SETUP;
			} else { 
				page = IMPLEMENTATION_ID_SETUP;
			}
			renderTemplate(page, referenceMap, httpResponse);
		} 
		else if (ADMIN_USER_SETUP.equals(page)) {
			if (goBack(httpRequest)) {
				renderTemplate(OTHER_RUNTIME_PROPS, referenceMap, httpResponse);
				return;
			}
			wizardModel.adminUserPassword = httpRequest.getParameter("new_admin_password");
			String adminUserConfirm = httpRequest.getParameter("new_admin_password_confirm");
			if (!wizardModel.adminUserPassword.equals(adminUserConfirm)) {
				errors.put(ErrorMessageConstants.ERROR_DB_ADM_PSWDS_MATCH, null);
				renderTemplate(ADMIN_USER_SETUP, referenceMap, httpResponse);
				return;
			}
			if ("".equals(wizardModel.adminUserPassword)) {
				errors.put(ErrorMessageConstants.ERROR_DB_ADM_PSDW_EMPTY, null);
				renderTemplate(ADMIN_USER_SETUP, referenceMap, httpResponse);
				return;
			}
			try {
				OpenmrsUtil.validatePassword("admin", wizardModel.adminUserPassword, "admin");
			}
			catch (PasswordException p) {
				errors.put(ErrorMessageConstants.ERROR_DB_ADM_PSDW_WEAK, null);
				renderTemplate(ADMIN_USER_SETUP, referenceMap, httpResponse);
				return;
			}
			if (errors.isEmpty()) { 
				page = IMPLEMENTATION_ID_SETUP;
			}
			renderTemplate(page, referenceMap, httpResponse);
		} 
		else if (IMPLEMENTATION_ID_SETUP.equals(page)) {
			if (goBack(httpRequest)) {
				if (wizardModel.createTables) {
					renderTemplate(ADMIN_USER_SETUP, referenceMap, httpResponse);
				} else {
					renderTemplate(OTHER_RUNTIME_PROPS, referenceMap, httpResponse);
				}
				return;
			}
			wizardModel.implementationIdName = httpRequest.getParameter("implementation_name");
			wizardModel.implementationId = httpRequest.getParameter("implementation_id");
			wizardModel.implementationIdPassPhrase = httpRequest.getParameter("pass_phrase");
			wizardModel.implementationIdDescription = httpRequest.getParameter("description");
			if (wizardModel.implementationId.indexOf('^') != -1 || wizardModel.implementationId.indexOf('|') != -1) {
				errors.put(ErrorMessageConstants.ERROR_DB_IMPL_ID_REQ, null);
				renderTemplate(IMPLEMENTATION_ID_SETUP, referenceMap, httpResponse);
				return;
			}
			if (errors.isEmpty()) { 
				page = WIZARD_COMPLETE;
			}
			renderTemplate(page, referenceMap, httpResponse);
		} else if (WIZARD_COMPLETE.equals(page)) {
			if (goBack(httpRequest)) {
				if (InitializationWizardModel.INSTALL_METHOD_SIMPLE.equals(wizardModel.installMethod)) {
					page = SIMPLE_SETUP;
				} else if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
					if (skipDatabaseSetupPage()) {
						page = TESTING_REMOTE_DETAILS_SETUP;
					} else {
						page = DATABASE_TABLES_AND_USER;
					}
				} else {
					page = IMPLEMENTATION_ID_SETUP;
				}
				renderTemplate(page, referenceMap, httpResponse);
				return;
			}
			wizardModel.tasksToExecute = new ArrayList<>();
			createDatabaseTask();
			if (InitializationWizardModel.INSTALL_METHOD_TESTING.equals(wizardModel.installMethod)) {
				wizardModel.importTestData = true;
				wizardModel.createTables = false;
				wizardModel.addDemoData = false;
				if (skipDatabaseSetupPage()) {
					wizardModel.hasCurrentOpenmrsDatabase = false;
					wizardModel.hasCurrentDatabaseUser = true;
					wizardModel.createDatabaseUser = false;
					Properties props = OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
					wizardModel.currentDatabaseUsername = props.getProperty("connection.username");
					wizardModel.currentDatabasePassword = props.getProperty("connection.password");
					wizardModel.createDatabaseUsername = wizardModel.currentDatabaseUsername;
					wizardModel.createDatabasePassword = wizardModel.currentDatabasePassword;
				}
				wizardModel.tasksToExecute.add(WizardTask.IMPORT_TEST_DATA);
				wizardModel.tasksToExecute.add(WizardTask.ADD_MODULES);
			} else {
				createTablesTask();
				createDemoDataTask();
			}
			wizardModel.tasksToExecute.add(WizardTask.UPDATE_TO_LATEST);
			referenceMap.put("tasksToExecute", wizardModel.tasksToExecute);
			startInstallation();
			renderTemplate(PROGRESS_VM, referenceMap, httpResponse);
		} else if (TESTING_REMOTE_DETAILS_SETUP.equals(page)) {
			if (goBack(httpRequest)) {
				wizardModel.currentStepNumber -= 1;
				renderTemplate(INSTALL_METHOD, referenceMap, httpResponse);
				return;
			}
			wizardModel.remoteUrl = httpRequest.getParameter("remoteUrl");
			checkForEmptyValue(wizardModel.remoteUrl, errors, "install.testing.remote.url.required");
			if (errors.isEmpty()) {
				if (TestInstallUtil.testConnection(wizardModel.remoteUrl)) {
					if (TestInstallUtil
						.testConnection(wizardModel.remoteUrl.concat(RELEASE_TESTING_MODULE_PATH + "settings.htm"))) {
						wizardModel.remoteUsername = httpRequest.getParameter("username");
						wizardModel.remotePassword = httpRequest.getParameter("password");
						checkForEmptyValue(wizardModel.remoteUsername, errors, "install.testing.username.required");
						checkForEmptyValue(wizardModel.remotePassword, errors, "install.testing.password.required");
						if (errors.isEmpty()) {
							try {
								TestInstallUtil.getResourceInputStream(
									wizardModel.remoteUrl + RELEASE_TESTING_MODULE_PATH + "verifycredentials.htm",
									wizardModel.remoteUsername, wizardModel.remotePassword);
							}
							catch (APIAuthenticationException e) {
								log.debug("Error generated: ", e);
								page = TESTING_REMOTE_DETAILS_SETUP;
								errors.put(ErrorMessageConstants.UPDATE_ERROR_UNABLE_AUTHENTICATE, null);
								renderTemplate(page, referenceMap, httpResponse);
								return;
							}
							if (skipDatabaseSetupPage()) {
								Properties props = OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
								wizardModel.databaseConnection = props.getProperty("connection.url");
								loadedDriverString = loadDriver(wizardModel.databaseConnection, wizardModel.databaseDriver);
								if (!StringUtils.hasText(loadedDriverString)) {
									page = TESTING_REMOTE_DETAILS_SETUP;
									errors.put(ErrorMessageConstants.ERROR_DB_DRIVER_CLASS_REQ, null);
									renderTemplate(page, referenceMap, httpResponse);
									return;
								}
								wizardModel.databaseName = InitializationWizardModel.DEFAULT_DATABASE_NAME;
								page = WIZARD_COMPLETE;
							} else {
								page = DATABASE_SETUP;
								wizardModel.currentStepNumber = 2;
							}
							msgs.put("install.testing.testingModuleFound", null);
						} else {
							renderTemplate(page, referenceMap, httpResponse);
							return;
						}
					} else {
						errors.put("install.testing.noTestingModule", null);
					}
				} else {
					errors.put("install.testing.invalidProductionUrl", new Object[] { wizardModel.remoteUrl });
				}
			}
			renderTemplate(page, referenceMap, httpResponse);
		}
	}
	private void startInstallation() {
		if (!isInstallationStarted()) {
			initJob = new InitializationCompletion();
			setInstallationStarted(true);
			initJob.start();
		}
	}
	private void createDemoDataTask() {
		if (wizardModel.addDemoData) {
			wizardModel.tasksToExecute.add(WizardTask.ADD_DEMO_DATA);
		}
	}
	private void createTablesTask() {
		if (wizardModel.createTables) {
			wizardModel.tasksToExecute.add(WizardTask.CREATE_TABLES);
			wizardModel.tasksToExecute.add(WizardTask.ADD_CORE_DATA);
		}
	}
	private void createDatabaseTask() {
		if (!wizardModel.hasCurrentOpenmrsDatabase) {
			wizardModel.tasksToExecute.add(WizardTask.CREATE_SCHEMA);
		}
		if (wizardModel.createDatabaseUser) {
			wizardModel.tasksToExecute.add(WizardTask.CREATE_DB_USER);
		}
	}
	private void createSimpleSetup(String databaseRootPassword, String addDemoData) {
		setDatabaseNameIfInTestMode();
		wizardModel.databaseConnection = Context.getRuntimeProperties().getProperty("connection.url",
			wizardModel.databaseConnection);
		wizardModel.createDatabaseUsername = Context.getRuntimeProperties().getProperty("connection.username",
			wizardModel.createDatabaseUsername);
		wizardModel.createUserUsername = wizardModel.createDatabaseUsername;
		wizardModel.databaseRootPassword = databaseRootPassword;
		checkForEmptyValue(wizardModel.databaseRootPassword, errors, ErrorMessageConstants.ERROR_DB_PSDW_REQ);
		wizardModel.hasCurrentOpenmrsDatabase = false;
		wizardModel.createTables = true;
		wizardModel.createDatabasePassword = wizardModel.databaseRootPassword;
		wizardModel.addDemoData = "yes".equals(addDemoData);
		wizardModel.hasCurrentDatabaseUser = false;
		wizardModel.createDatabaseUser = true;
		wizardModel.createUserPassword = wizardModel.databaseRootPassword;
		wizardModel.moduleWebAdmin = true;
		wizardModel.autoUpdateDatabase = false;
		wizardModel.adminUserPassword = InitializationWizardModel.ADMIN_DEFAULT_PASSWORD;
	}
	private void setDatabaseNameIfInTestMode() {
		if (OpenmrsUtil.isTestMode()) {
			wizardModel.databaseName = OpenmrsUtil.getOpenMRSVersionInTestMode();
		}
	}
	private void autoRunOpenMRS(HttpServletRequest httpRequest) {
		File runtimeProperties = getRuntimePropertiesFile();
		wizardModel.runtimePropertiesPath = runtimeProperties.getAbsolutePath();
		if (!InitializationWizardModel.INSTALL_METHOD_AUTO.equals(wizardModel.installMethod)) {
			if (httpRequest.getParameter("database_user_name") != null) {
				wizardModel.createDatabaseUsername = httpRequest.getParameter("database_user_name");
			}
			createSimpleSetup(httpRequest.getParameter("database_root_password"), "yes");
		}
		checkLocaleAttributes(httpRequest);
		try {
			loadedDriverString = DatabaseUtil.loadDatabaseDriver(wizardModel.databaseConnection, wizardModel.databaseDriver);
		}
		catch (ClassNotFoundException e) {
			errors.put(ErrorMessageConstants.ERROR_DB_DRIVER_CLASS_REQ, null);
			return;
		}
		wizardModel.tasksToExecute = new ArrayList<>();
		createDatabaseTask();
		createTablesTask();
		createDemoDataTask();
		wizardModel.tasksToExecute.add(WizardTask.UPDATE_TO_LATEST);
		startInstallation();
	}
	private void checkLocaleAttributes(HttpServletRequest httpRequest) {
		String localeParameter = httpRequest.getParameter(FilterUtil.LOCALE_ATTRIBUTE);
		Boolean rememberLocale = false;
		if (httpRequest.getParameter(FilterUtil.REMEMBER_ATTRIBUTE) != null) {
			rememberLocale = true;
		}
		if (localeParameter != null) {
			String storedLocale = null;
			if (httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE) != null) {
				storedLocale = httpRequest.getSession().getAttribute(FilterUtil.LOCALE_ATTRIBUTE).toString();
			}
			if (storedLocale == null || !storedLocale.equals(localeParameter)) {
				log.info("Stored locale parameter to session " + localeParameter);
				httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, localeParameter);
			}
			if (rememberLocale) {
				httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, localeParameter);
				httpRequest.getSession().setAttribute(FilterUtil.REMEMBER_ATTRIBUTE, true);
				wizardModel.localeToSave = localeParameter;
			} else {
				httpRequest.getSession().setAttribute(FilterUtil.REMEMBER_ATTRIBUTE, null);
				wizardModel.localeToSave = null;
			}
		}
	}
	public void checkLocaleAttributesForFirstTime(HttpServletRequest httpRequest) {
		Locale locale = httpRequest.getLocale();
		if (CustomResourceLoader.getInstance(httpRequest).getAvailablelocales().contains(locale)) {
			httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, locale.toString());
		} else {
			httpRequest.getSession().setAttribute(FilterUtil.LOCALE_ATTRIBUTE, Locale.ENGLISH.toString());
		}
	}
	private boolean verifyConnection(String connectionUsername, String connectionPassword,
		String databaseConnectionFinalUrl) {
		try {
			Class.forName(loadedDriverString).newInstance();
			Connection tempConnection = DriverManager.getConnection(databaseConnectionFinalUrl, connectionUsername,
				connectionPassword);
			tempConnection.close();
			return true;
		}
		catch (Exception e) {
			errors.put("User account " + connectionUsername + " does not work. " + e.getMessage()
					+ " See the error log for more details",
				null); 
			log.warn("Error while checking the connection user account", e);
			return false;
		}
	}
	private File getRuntimePropertiesFile() {
		File file;
		String pathName = OpenmrsUtil.getRuntimePropertiesFilePathName(WebConstants.WEBAPP_NAME);
		if (pathName != null) {
			file = new File(pathName);
		} else {
			file = new File(OpenmrsUtil.getApplicationDataDirectory(), getRuntimePropertiesFileName());
		}
		log.debug("Using file: " + file.getAbsolutePath());
		return file;
	}
	private String getRuntimePropertiesFileName() {
		String fileName = OpenmrsUtil.getRuntimePropertiesFileNameInTestMode();
		if (fileName == null) {
			fileName = WebConstants.WEBAPP_NAME + "-runtime.properties";
		}
		return fileName;
	}
	@Override
	protected String getTemplatePrefix() {
		return "org/openmrs/web/filter/initialization/";
	}
	@Override
	protected Object getUpdateFilterModel() {
		return wizardModel;
	}
	@Override
	public boolean skipFilter(HttpServletRequest httpRequest) {
		return !PROGRESS_VM_AJAXREQUEST.equals(httpRequest.getParameter("page")) && !initializationRequired();
	}
	public static boolean initializationRequired() {
		return !isInitializationComplete();
	}
	protected static synchronized void setInstallationStarted(boolean isInstallationStarted) {
		InitializationFilter.isInstallationStarted = isInstallationStarted;
	}
	protected static boolean isInstallationStarted() {
		return isInstallationStarted;
	}
	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		super.init(filterConfig);
		wizardModel = new InitializationWizardModel();
		DatabaseDetective databaseDetective = new DatabaseDetective();
		if (databaseDetective.isDatabaseEmpty(OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME))) {
			setInitializationComplete(false);
		} else {
			setInitializationComplete(true);
		}
	}
	private void importTestDataSet(InputStream in, String connectionUrl, String connectionUsername,
		String connectionPassword) throws IOException {
		File tempFile = null;
		FileOutputStream fileOut = null;
		try {
			ZipInputStream zipIn = new ZipInputStream(in);
			zipIn.getNextEntry();
			tempFile = File.createTempFile("testDataSet", "dump");
			fileOut = new FileOutputStream(tempFile);
			IOUtils.copy(zipIn, fileOut);
			fileOut.close();
			zipIn.close();
			if (connectionUrl.contains(":mxj:")) {
				connectionUrl = connectionUrl.replace(":mxj:", ":");
			}
			URI uri = URI.create(connectionUrl.substring(5)); 
			String host = uri.getHost();
			int port = uri.getPort();
			TestInstallUtil.addTestData(host, port, wizardModel.databaseName, connectionUsername, connectionPassword,
				tempFile.getAbsolutePath());
		}
		finally {
			IOUtils.closeQuietly(in);
			IOUtils.closeQuietly(fileOut);
			if (tempFile != null) {
				tempFile.delete();
			}
		}
	}
	private boolean isCurrentDatabase(String database) {
		return wizardModel.databaseConnection.contains(database);
	}
	private int executeStatement(boolean silent, String user, String pw, String sql, String... args) {
		Connection connection = null;
		Statement statement = null;
		try {
			String replacedSql = sql;
			if (isCurrentDatabase(DATABASE_MYSQL)) {
				Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
			} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
				Class.forName("org.postgresql.Driver").newInstance();
				replacedSql = replacedSql.replaceAll("`", "\"");
			} else {
				replacedSql = replacedSql.replaceAll("`", "\"");
			}
			String tempDatabaseConnection;
			if (sql.contains("create database")) {
				tempDatabaseConnection = wizardModel.databaseConnection.replace("@DBNAME@",
					""); 
			} else {
				tempDatabaseConnection = wizardModel.databaseConnection.replace("@DBNAME@", wizardModel.databaseName);
			}
			connection = DriverManager.getConnection(tempDatabaseConnection, user, pw);
			for (String arg : args) {
				arg = arg.replace(";", "&#094"); 
				replacedSql = replacedSql.replaceFirst("\\?", arg);
			}
			statement = connection.createStatement();
			return statement.executeUpdate(replacedSql);
		}
		catch (SQLException sqlex) {
			if (!silent) {
				log.warn("error executing sql: " + sql, sqlex);
				errors.put("Error executing sql: " + sql + " - " + sqlex.getMessage(), null);
			}
		}
		catch (InstantiationException | ClassNotFoundException | IllegalAccessException e) {
			log.error("Error generated", e);
		}
		finally {
			try {
				if (statement != null) {
					statement.close();
				}
			}
			catch (SQLException e) {
				log.warn("Error while closing statement");
			}
			try {
				if (connection != null) {
					connection.close();
				}
			}
			catch (Exception e) {
				log.warn("Error while closing connection", e);
			}
		}
		return -1;
	}
	private static synchronized boolean isInitializationComplete() {
		return initializationComplete;
	}
	private boolean checkForEmptyValue(String value, Map<String, Object[]> errors, String errorMessageCode) {
		if (!StringUtils.isEmpty(value)) {
			return true;
		}
		errors.put(errorMessageCode, null);
		return false;
	}
	private class InitializationCompletion {
		private final Future<Void> future;
		private int steps = 0;
		private String message = "";
		private Map<String, Object[]> errors = new HashMap<>();
		private String errorPage = null;
		private boolean erroneous = false;
		private int completedPercentage = 0;
		private WizardTask executingTask;
		private List<WizardTask> executedTasks = new ArrayList<>();
		public synchronized void reportError(String error, String errorPage, Object... params) {
			errors.put(error, params);
			this.errorPage = errorPage;
			erroneous = true;
		}
		public synchronized boolean hasErrors() {
			return erroneous;
		}
		public synchronized String getErrorPage() {
			return errorPage;
		}
		public synchronized Map<String, Object[]> getErrors() {
			return errors;
		}
		public void start() {
			setStepsComplete(0);
			setInitializationComplete(false);
		}
		public void waitForCompletion() {
			try {
				future.get();
			} catch (InterruptedException | ExecutionException e) {
				throw new RuntimeException(e);
			}
		}
		protected synchronized void setStepsComplete(int steps) {
			this.steps = steps;
		}
		protected synchronized int getStepsComplete() {
			return steps;
		}
		public synchronized String getMessage() {
			return message;
		}
		public synchronized void setMessage(String message) {
			this.message = message;
			setStepsComplete(getStepsComplete() + 1);
		}
		protected synchronized WizardTask getExecutingTask() {
			return executingTask;
		}
		protected synchronized int getCompletedPercentage() {
			return completedPercentage;
		}
		protected synchronized void setCompletedPercentage(int completedPercentage) {
			this.completedPercentage = completedPercentage;
		}
		protected synchronized void addExecutedTask(WizardTask task) {
			this.executedTasks.add(task);
		}
		protected synchronized void setExecutingTask(WizardTask executingTask) {
			this.executingTask = executingTask;
		}
		protected synchronized List<WizardTask> getExecutedTasks() {
			return this.executedTasks;
		}
		public InitializationCompletion() {
			Runnable r = new Runnable() {
				@Override
				public void run() {
					try {
						String connectionUsername;
						StringBuilder connectionPassword = new StringBuilder();
						ChangeLogDetective changeLogDetective = new ChangeLogDetective();
						ChangeLogVersionFinder changeLogVersionFinder = new ChangeLogVersionFinder();
						if (!wizardModel.hasCurrentOpenmrsDatabase) {
							setMessage("Create database");
							setExecutingTask(WizardTask.CREATE_SCHEMA);
							String sql;
							if (isCurrentDatabase(DATABASE_MYSQL)) {
								sql = "create database if not exists `?` default character set utf8";
							} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
								sql = "create database `?` encoding 'utf8'";
							} else if (isCurrentDatabase(DATABASE_H2)) {
								sql = null;
							} else {
								sql = "create database `?`";
							}
							int result;
							if (sql != null) {
								result = executeStatement(false, wizardModel.createDatabaseUsername,
									wizardModel.createDatabasePassword, sql, wizardModel.databaseName);
							} else {
								result = 1;
							}
							if (result < 0) {
								reportError(ErrorMessageConstants.ERROR_DB_CREATE_NEW, DEFAULT_PAGE);
								return;
							} else {
								wizardModel.workLog.add("Created database " + wizardModel.databaseName);
							}
							addExecutedTask(WizardTask.CREATE_SCHEMA);
						}
						if (wizardModel.createDatabaseUser) {
							setMessage("Create database user");
							setExecutingTask(WizardTask.CREATE_DB_USER);
							connectionUsername = wizardModel.databaseName + "_user";
							if (connectionUsername.length() > 16) {
								connectionUsername = wizardModel.databaseName.substring(0, 11)
									+ "_user"; 
							}
							connectionPassword.append("");
							String chars = "acdeghijklmnopqrtvwxyzACDEGHIJKLMNOPQRTVWXYZ0123456789.|~@#^&";
							Random r = new Random();
							StringBuilder randomStr = new StringBuilder("");
							for (int x = 0; x < 12; x++) {
								randomStr.append(chars.charAt(r.nextInt(chars.length())));
							}
							connectionPassword.append(randomStr);
							String host = "'%'";
							if (wizardModel.databaseConnection.contains("localhost")
								|| wizardModel.databaseConnection.contains("127.0.0.1")) {
								host = "'localhost'";
							}
							String sql = "";
							if (isCurrentDatabase(DATABASE_MYSQL)) {
								sql = "drop user '?'@" + host;
							} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
								sql = "drop user `?`";
							}
							executeStatement(true, wizardModel.createUserUsername, wizardModel.createUserPassword, sql,
								connectionUsername);
							if (isCurrentDatabase(DATABASE_MYSQL)) {
								sql = "create user '?'@" + host + " identified by '?'";
							} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
								sql = "create user `?` with password '?'";
							}
							if (-1 != executeStatement(false, wizardModel.createUserUsername, wizardModel.createUserPassword,
								sql, connectionUsername, connectionPassword.toString())) {
								wizardModel.workLog.add("Created user " + connectionUsername);
							} else {
								reportError(ErrorMessageConstants.ERROR_DB_CREATE_DB_USER, DEFAULT_PAGE);
								return;
							}
							int result = 1;
							if (isCurrentDatabase(DATABASE_MYSQL)) {
								sql = "GRANT ALL ON `?`.* TO '?'@" + host;
								result = executeStatement(false, wizardModel.createUserUsername,
									wizardModel.createUserPassword, sql, wizardModel.databaseName, connectionUsername);
							} else if (isCurrentDatabase(DATABASE_POSTGRESQL)) {
								sql = "ALTER USER `?` WITH SUPERUSER";
								result = executeStatement(false, wizardModel.createUserUsername,
									wizardModel.createUserPassword, sql, connectionUsername);
							}
							if (result < 0) {
								reportError(ErrorMessageConstants.ERROR_DB_GRANT_PRIV, DEFAULT_PAGE);
								return;
							} else {
								wizardModel.workLog.add("Granted user " + connectionUsername + " all privileges to database "
									+ wizardModel.databaseName);
							}
							addExecutedTask(WizardTask.CREATE_DB_USER);
						} else {
							connectionUsername = wizardModel.currentDatabaseUsername;
							connectionPassword.setLength(0);
							connectionPassword.append(wizardModel.currentDatabasePassword);
						}
						String finalDatabaseConnectionString = wizardModel.databaseConnection.replace("@DBNAME@",
							wizardModel.databaseName);
						finalDatabaseConnectionString = finalDatabaseConnectionString.replace("@APPLICATIONDATADIR@",
							OpenmrsUtil.getApplicationDataDirectory().replace("\\", "/"));
						if (!verifyConnection(connectionUsername, connectionPassword.toString(),
							finalDatabaseConnectionString)) {
							setMessage("Verify that the database connection works");
							reportError("Unable to connect to database", DEFAULT_PAGE);
							return;
						}
						Properties runtimeProperties = new Properties();
						runtimeProperties.put("connection.url", finalDatabaseConnectionString);
						runtimeProperties.put("connection.username", connectionUsername);
						runtimeProperties.put("connection.password", connectionPassword.toString());
						if (StringUtils.hasText(wizardModel.databaseDriver)) {
							runtimeProperties.put("connection.driver_class", wizardModel.databaseDriver);
						}
						if (finalDatabaseConnectionString.contains(DATABASE_POSTGRESQL)) {
							runtimeProperties.put("hibernate.dialect", "org.hibernate.dialect.PostgreSQL82Dialect");
						}
						if (finalDatabaseConnectionString.contains(DATABASE_SQLSERVER)) {
							runtimeProperties.put("hibernate.dialect", "org.hibernate.dialect.SQLServerDialect");
						}
						if (finalDatabaseConnectionString.contains(DATABASE_H2)) {
							runtimeProperties.put("hibernate.dialect", "org.hibernate.dialect.H2Dialect");
						}
						runtimeProperties.put("module.allow_web_admin", wizardModel.moduleWebAdmin.toString());
						runtimeProperties.put("auto_update_database", wizardModel.autoUpdateDatabase.toString());
						final Encoder base64 = Base64.getEncoder();
						runtimeProperties.put(OpenmrsConstants.ENCRYPTION_VECTOR_RUNTIME_PROPERTY,
							new String(base64.encode(Security.generateNewInitVector()), StandardCharsets.UTF_8));
						runtimeProperties.put(OpenmrsConstants.ENCRYPTION_KEY_RUNTIME_PROPERTY,
							new String(base64.encode(Security.generateNewSecretKey()), StandardCharsets.UTF_8));
						Properties properties = Context.getRuntimeProperties();
						properties.putAll(runtimeProperties);
						runtimeProperties = properties;
						Context.setRuntimeProperties(runtimeProperties);
						class PrintingChangeSetExecutorCallback implements ChangeSetExecutorCallback {
							private int i = 1;
							private String message;
							public PrintingChangeSetExecutorCallback(String message) {
								this.message = message;
							}
							@Override
							public void executing(ChangeSet changeSet, int numChangeSetsToRun) {
								setMessage(message + " (" + i++ + "/" + numChangeSetsToRun + "): Author: "
									+ changeSet.getAuthor() + " Comments: " + changeSet.getComments() + " Description: "
									+ changeSet.getDescription());
								float numChangeSetsToRunFloat = (float) numChangeSetsToRun;
								float j = (float) i;
								setCompletedPercentage(Math.round(j * 100 / numChangeSetsToRunFloat));
							}
						}
						if (wizardModel.createTables) {
							try {
								String liquibaseSchemaFileName = changeLogVersionFinder.getLatestSchemaSnapshotFilename()
									.get();
								String liquibaseCoreDataFileName = changeLogVersionFinder.getLatestCoreDataSnapshotFilename()
									.get();
								setMessage("Executing " + liquibaseSchemaFileName);
								setExecutingTask(WizardTask.CREATE_TABLES);
								log.debug("executing Liquibase file '{}' ", liquibaseSchemaFileName);
								DatabaseUpdater.executeChangelog(liquibaseSchemaFileName,
									new PrintingChangeSetExecutorCallback("OpenMRS schema file"));
								addExecutedTask(WizardTask.CREATE_TABLES);
								setCompletedPercentage(0);
								setExecutingTask(WizardTask.ADD_CORE_DATA);
								log.debug("executing Liquibase file '{}' ", liquibaseCoreDataFileName);
								DatabaseUpdater.executeChangelog(liquibaseCoreDataFileName,
									new PrintingChangeSetExecutorCallback("OpenMRS core data file"));
								wizardModel.workLog.add("Created database tables and added core data");
								addExecutedTask(WizardTask.ADD_CORE_DATA);
							}
							catch (Exception e) {
								reportError(ErrorMessageConstants.ERROR_DB_CREATE_TABLES_OR_ADD_DEMO_DATA, DEFAULT_PAGE,
									e.getMessage());
								log.warn("Error while trying to create tables and demo data", e);
							}
						}
						if (wizardModel.importTestData) {
							try {
								setMessage("Importing test data");
								setExecutingTask(WizardTask.IMPORT_TEST_DATA);
								setCompletedPercentage(0);
								try {
									InputStream inData = TestInstallUtil.getResourceInputStream(
										wizardModel.remoteUrl + RELEASE_TESTING_MODULE_PATH + "generateTestDataSet.form",
										wizardModel.remoteUsername, wizardModel.remotePassword);
									setCompletedPercentage(40);
									setMessage("Loading imported test data...");
									importTestDataSet(inData, finalDatabaseConnectionString, connectionUsername,
										connectionPassword.toString());
									wizardModel.workLog.add("Imported test data");
									addExecutedTask(WizardTask.IMPORT_TEST_DATA);
									setCompletedPercentage(0);
									setMessage("Importing modules from remote server...");
									setExecutingTask(WizardTask.ADD_MODULES);
									InputStream inModules = TestInstallUtil.getResourceInputStream(
										wizardModel.remoteUrl + RELEASE_TESTING_MODULE_PATH + "getModules.htm",
										wizardModel.remoteUsername, wizardModel.remotePassword);
									setCompletedPercentage(90);
									setMessage("Adding imported modules...");
									if (!TestInstallUtil.addZippedTestModules(inModules)) {
										reportError(ErrorMessageConstants.ERROR_DB_UNABLE_TO_ADD_MODULES, DEFAULT_PAGE, "");
										return;
									} else {
										wizardModel.workLog.add("Added Modules");
										addExecutedTask(WizardTask.ADD_MODULES);
									}
								}
								catch (APIAuthenticationException e) {
									log.warn("Unable to authenticate as a User with the System Developer role");
									reportError(ErrorMessageConstants.UPDATE_ERROR_UNABLE_AUTHENTICATE,
										TESTING_REMOTE_DETAILS_SETUP, "");
									return;
								}
							}
							catch (Exception e) {
								reportError(ErrorMessageConstants.ERROR_DB_IMPORT_TEST_DATA, DEFAULT_PAGE, e.getMessage());
								log.warn("Error while trying to import test data", e);
								return;
							}
						}
						if (wizardModel.createTables && wizardModel.addDemoData) {
							try {
								setMessage("Adding demo data");
								setCompletedPercentage(0);
								setExecutingTask(WizardTask.ADD_DEMO_DATA);
								log.debug("executing Liquibase file '{}' ", LIQUIBASE_DEMO_DATA);
								DatabaseUpdater.executeChangelog(LIQUIBASE_DEMO_DATA,
									new PrintingChangeSetExecutorCallback("OpenMRS demo patients, users, and forms"));
								wizardModel.workLog.add("Added demo data");
								addExecutedTask(WizardTask.ADD_DEMO_DATA);
							}
							catch (Exception e) {
								reportError(ErrorMessageConstants.ERROR_DB_CREATE_TABLES_OR_ADD_DEMO_DATA, DEFAULT_PAGE,
									e.getMessage());
								log.warn("Error while trying to add demo data", e);
							}
						}
						try {
							setMessage("Updating the database to the latest version");
							setCompletedPercentage(0);
							setExecutingTask(WizardTask.UPDATE_TO_LATEST);
							String version = null;
							if (wizardModel.createTables) {
								version = changeLogVersionFinder.getLatestSnapshotVersion().get();
							} else {
								version = changeLogDetective.getInitialLiquibaseSnapshotVersion(DatabaseUpdater.CONTEXT,
									new DatabaseUpdaterLiquibaseProvider());
							}
							log.debug(
								"updating the database with versions of liquibase-update-to-latest files greater than '{}'",
								version);
							List<String> changelogs = changeLogVersionFinder
								.getUpdateFileNames(changeLogVersionFinder.getUpdateVersionsGreaterThan(version));
							for (String changelog : changelogs) {
								log.debug("applying Liquibase changelog '{}'", changelog);
								DatabaseUpdater.executeChangelog(changelog,
									new PrintingChangeSetExecutorCallback("executing Liquibase changelog " + changelog));
							}
							addExecutedTask(WizardTask.UPDATE_TO_LATEST);
						}
						catch (Exception e) {
							reportError(ErrorMessageConstants.ERROR_DB_UPDATE_TO_LATEST, DEFAULT_PAGE, e.getMessage());
							log.warn("Error while trying to update to the latest database version", e);
							return;
						}
						setExecutingTask(null);
						setMessage("Starting OpenMRS");
						ContextLoader contextLoader = new ContextLoader();
						contextLoader.initWebApplicationContext(filterConfig.getServletContext());
						FileOutputStream fos = null;
						try {
							fos = new FileOutputStream(getRuntimePropertiesFile());
							OpenmrsUtil.storeProperties(runtimeProperties, fos,
								"Auto generated by OpenMRS initialization wizard");
							wizardModel.workLog.add("Saved runtime properties file " + getRuntimePropertiesFile());
							wizardModel.workLog.add("Adjusting file posix properties to user readonly");
							if (getRuntimePropertiesFile().setReadable(false, false)
								&& getRuntimePropertiesFile().setReadable(true)) {
								wizardModel.workLog
									.add("Successfully adjusted RuntimePropertiesFile to disallow world to read it");
							} else {
								wizardModel.workLog
									.add("Unable to adjust RuntimePropertiesFile to disallow world to read it");
							}
						}
						finally {
							if (fos != null) {
								fos.close();
							}
						}
						Context.openSession();
						if (!"".equals(wizardModel.implementationId)) {
							try {
								Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
								Context.addProxyPrivilege(PrivilegeConstants.MANAGE_CONCEPT_SOURCES);
								Context.addProxyPrivilege(PrivilegeConstants.GET_CONCEPT_SOURCES);
								Context.addProxyPrivilege(PrivilegeConstants.MANAGE_IMPLEMENTATION_ID);
								ImplementationId implId = new ImplementationId();
								implId.setName(wizardModel.implementationIdName);
								implId.setImplementationId(wizardModel.implementationId);
								implId.setPassphrase(wizardModel.implementationIdPassPhrase);
								implId.setDescription(wizardModel.implementationIdDescription);
								Context.getAdministrationService().setImplementationId(implId);
							}
							catch (Exception e) {
								reportError(ErrorMessageConstants.ERROR_SET_INPL_ID, DEFAULT_PAGE, e.getMessage());
								log.warn("Implementation ID could not be set.", e);
								Context.shutdown();
								WebModuleUtil.shutdownModules(filterConfig.getServletContext());
								contextLoader.closeWebApplicationContext(filterConfig.getServletContext());
								return;
							}
							finally {
								Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
								Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_CONCEPT_SOURCES);
								Context.removeProxyPrivilege(PrivilegeConstants.GET_CONCEPT_SOURCES);
								Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_IMPLEMENTATION_ID);
							}
						}
						try {
							if (wizardModel.createTables) {
								try {
									Context.authenticate(new UsernamePasswordCredentials("admin", "test"));
									Properties props = Context.getRuntimeProperties();
									String initValue = props.getProperty(UserService.ADMIN_PASSWORD_LOCKED_PROPERTY);
									props.setProperty(UserService.ADMIN_PASSWORD_LOCKED_PROPERTY, "false");
									Context.setRuntimeProperties(props);
									Context.getUserService().changePassword("test", wizardModel.adminUserPassword);
									if (initValue == null) {
										props.remove(UserService.ADMIN_PASSWORD_LOCKED_PROPERTY);
									} else {
										props.setProperty(UserService.ADMIN_PASSWORD_LOCKED_PROPERTY, initValue);
									}
									Context.setRuntimeProperties(props);
									Context.logout();
								}
								catch (ContextAuthenticationException ex) {
									log.info("No need to change admin password.", ex);
								}
							}
						}
						catch (Exception e) {
							Context.shutdown();
							WebModuleUtil.shutdownModules(filterConfig.getServletContext());
							contextLoader.closeWebApplicationContext(filterConfig.getServletContext());
							reportError(ErrorMessageConstants.ERROR_COMPLETE_STARTUP, DEFAULT_PAGE, e.getMessage());
							log.warn("Unable to complete the startup.", e);
							return;
						}
						try {
							Context.getAdministrationService().updatePostgresSequence();
						}
						catch (Exception e) {
							log.warn("Not able to update PostgreSQL sequence. Startup failed for PostgreSQL", e);
							reportError(ErrorMessageConstants.ERROR_COMPLETE_STARTUP, DEFAULT_PAGE, e.getMessage());
							return;
						}
						Context.closeSession();
						try {
							UpdateFilter.setUpdatesRequired(false);
							WebDaemon.startOpenmrs(filterConfig.getServletContext());
						}
						catch (DatabaseUpdateException updateEx) {
							log.warn("Error while running the database update file", updateEx);
							reportError(ErrorMessageConstants.ERROR_DB_UPDATE, DEFAULT_PAGE, updateEx.getMessage());
							return;
						}
						catch (InputRequiredException inputRequiredEx) {
							log.warn(
								"Unable to continue because user input is required for the db updates and we cannot do anything about that right now");
							reportError(ErrorMessageConstants.ERROR_INPUT_REQ, DEFAULT_PAGE);
							return;
						}
						catch (MandatoryModuleException mandatoryModEx) {
							log.warn(
								"A mandatory module failed to start. Fix the error or unmark it as mandatory to continue.",
								mandatoryModEx);
							reportError(ErrorMessageConstants.ERROR_MANDATORY_MOD_REQ, DEFAULT_PAGE,
								mandatoryModEx.getMessage());
							return;
						}
						catch (OpenmrsCoreModuleException coreModEx) {
							log.warn(
								"A core module failed to start. Make sure that all core modules (with the required minimum versions) are installed and starting properly.",
								coreModEx);
							reportError(ErrorMessageConstants.ERROR_CORE_MOD_REQ, DEFAULT_PAGE, coreModEx.getMessage());
							return;
						}
					}
					catch (IOException e) {
						reportError(ErrorMessageConstants.ERROR_COMPLETE_STARTUP, DEFAULT_PAGE, e.getMessage());
					}
					finally {
						if (!hasErrors()) {
							setInitializationComplete(true);
							FilterUtil.storeLocale(wizardModel.localeToSave);
						}
						setInstallationStarted(false);
					}
				}
			};
			future = OpenmrsThreadPoolHolder.threadExecutor.submit(() -> { r.run(); return null; });
		}
	}
	public static String loadDriver(String connection, String databaseDriver) {
		String loadedDriverString = null;
		try {
			loadedDriverString = DatabaseUtil.loadDatabaseDriver(connection, databaseDriver);
			log.info("using database driver :" + loadedDriverString);
		}
		catch (ClassNotFoundException e) {
			log.error("The given database driver class was not found. "
				+ "Please ensure that the database driver jar file is on the class path "
				+ "(like in the webapp's lib folder)");
		}
		return loadedDriverString;
	}
	private static boolean skipDatabaseSetupPage() {
		Properties props = OpenmrsUtil.getRuntimeProperties(WebConstants.WEBAPP_NAME);
		return (props != null && StringUtils.hasText(props.getProperty("connection.url"))
			&& StringUtils.hasText(props.getProperty("connection.username"))
			&& StringUtils.hasText(props.getProperty("connection.password")));
	}
	private static boolean goBack(HttpServletRequest httpRequest) {
		return "Back".equals(httpRequest.getParameter("back"))
			|| (httpRequest.getParameter("back.x") != null && httpRequest.getParameter("back.y") != null);
	}
	private Properties getInstallationScript() {
		Properties prop = new Properties();
		String fileName = System.getProperty("OPENMRS_INSTALLATION_SCRIPT");
		if (fileName == null) {
			return prop;
		}
		if (fileName.startsWith("classpath:")) {
			fileName = fileName.substring(10);
			InputStream input = null;
			try {
				input = getClass().getClassLoader().getResourceAsStream(fileName);
				prop.load(input);
				log.info("Using installation script from classpath: " + fileName);
				input.close();
			}
			catch (IOException ex) {
				log.error("Failed to load installation script from classpath: " + fileName, ex);
				throw new RuntimeException(ex);
			}
			finally {
				IOUtils.closeQuietly(input);
			}
		} else {
			File file = new File(fileName);
			if (file.exists()) {
				InputStream input = null;
				try {
					input = new FileInputStream(fileName);
					prop.load(input);
					log.info("Using installation script from absolute path: " + file.getAbsolutePath());
					input.close();
				}
				catch (IOException ex) {
					log.error("Failed to load installation script from absolute path: " + file.getAbsolutePath(), ex);
					throw new RuntimeException(ex);
				}
				finally {
					IOUtils.closeQuietly(input);
				}
			}
		}
		return prop;
	}
}
package org.openmrs.liquibase;
import liquibase.resource.ClassLoaderResourceAccessor;
import liquibase.resource.InputStreamList;
import liquibase.resource.Resource;
import org.openmrs.util.OpenmrsClassLoader;
import java.io.IOException;
import java.net.URI;
import java.util.List;
@Deprecated
public class OpenmrsClassLoaderResourceAccessor extends ClassLoaderResourceAccessor {
	public OpenmrsClassLoaderResourceAccessor() {
		super(OpenmrsClassLoader.getInstance());
	}
	public OpenmrsClassLoaderResourceAccessor(ClassLoader classLoader) {
		super(classLoader);
	}
	@Override
	public InputStreamList openStreams(String relativeTo, String streamPath) throws IOException {
		List<Resource> resources = super.getAll(streamPath);
		InputStreamList result = new InputStreamList();
		if (resources == null || resources.isEmpty()) {
			return result;
		}
		for (Resource resource : resources) {
			result.add(resource.getUri(), resource.openInputStream());
		}
		if (!result.isEmpty() && result.size() > 1) {
			try (InputStreamList oldResult = result) {
				URI uri = oldResult.getURIs().get(0);
				result = new InputStreamList(uri, uri.toURL().openStream());
			}
		}
		return result;
	}
}
package org.openmrs.util.databasechange;
import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.DatabaseUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import liquibase.change.custom.CustomTaskChange;
import liquibase.database.Database;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.CustomChangeException;
import liquibase.exception.DatabaseException;
import liquibase.exception.SetupException;
import liquibase.exception.ValidationErrors;
import liquibase.resource.ResourceAccessor;
public class DuplicateEncounterTypeNameChangeSet implements CustomTaskChange {
	private static final Logger log = LoggerFactory.getLogger(DuplicateEncounterTypeNameChangeSet.class);
	@Override
	public String getConfirmationMessage() {
		return "Completed updating duplicate EncounterType names";
	}
	@Override
	public void setFileOpener(ResourceAccessor arg0) {
	}
	@Override
	public void setUp() throws SetupException {
	}
	@Override
	public ValidationErrors validate(Database arg0) {
		return null;
	}
	@Override
	public void execute(Database database) throws CustomChangeException {
		JdbcConnection connection = (JdbcConnection) database.getConnection();
		Map<String, HashSet<Integer>> duplicates = new HashMap<>();
		Statement stmt = null;
		PreparedStatement pStmt = null;
		ResultSet rs = null;
		Boolean initialAutoCommit = null;
		try {
			initialAutoCommit = connection.getAutoCommit();
			connection.setAutoCommit(false);
			stmt = connection.createStatement();
			rs = stmt
			        .executeQuery("SELECT * FROM encounter_type INNER JOIN (SELECT name FROM encounter_type GROUP BY name HAVING count(name) > 1) dup ON encounter_type.name = dup.name");
			Integer id;
			String name;
			while (rs.next()) {
				id = rs.getInt("encounter_type_id");
				name = rs.getString("name");
				if (duplicates.get(name) == null) {
					HashSet<Integer> results = new HashSet<>();
					results.add(id);
					duplicates.put(name, results);
				} else {
					HashSet<Integer> results = duplicates.get(name);
					results.add(id);
				}
			}
			for (Object o : duplicates.entrySet()) {
				Map.Entry pairs = (Map.Entry) o;
				HashSet<Integer> values = (HashSet<Integer>) pairs.getValue();
				List<Integer> ids = new ArrayList<Integer>(values);
				int duplicateNameId = 1;
				for (int i = 1; i < ids.size(); i++) {
					String newName = pairs.getKey() + "_" + duplicateNameId;
					List<List<Object>> duplicateResult;
					boolean duplicateName;
					Connection con = DatabaseUpdater.getConnection();
					do {
						String sqlValidatorString = "select * from encounter_type where name = '" + newName + "'";
						duplicateResult = DatabaseUtil.executeSQL(con, sqlValidatorString, true);
						if (!duplicateResult.isEmpty()) {
							duplicateNameId += 1;
							newName = pairs.getKey() + "_" + duplicateNameId;
							duplicateName = true;
						} else {
							duplicateName = false;
						}
					} while (duplicateName);
					pStmt = connection.prepareStatement("update encounter_type set name = ? where encounter_type_id = ?");
					pStmt.setString(1, newName);
					pStmt.setInt(2, ids.get(i));
					duplicateNameId += 1;
					pStmt.executeUpdate();
				}
			}
		}
		catch (BatchUpdateException e) {
			log.warn("Error generated while processing batch insert", e);
			try {
				log.debug("Rolling back batch", e);
				connection.rollback();
			}
			catch (Exception rbe) {
				log.warn("Error generated while rolling back batch insert", e);
			}
			throw new CustomChangeException("Failed to update one or more duplicate EncounterType names", e);
		}
		catch (Exception e) {
			throw new CustomChangeException(e);
		}
		finally {
			try {
				if (initialAutoCommit != null) {
					connection.setAutoCommit(initialAutoCommit);
				}
			}
			catch (DatabaseException e) {
				log.warn("Failed to set auto commit to ids initial state", e);
			}
			if (rs != null) {
				try {
					rs.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the resultset object");
				}
			}
			if (stmt != null) {
				try {
					stmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the select statement used to identify duplicate EncounterType object names");
				}
			}
			if (pStmt != null) {
				try {
					pStmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the prepared statement used to update duplicate EncounterType object names");
				}
			}
		}
	}
}
package org.openmrs.util.databasechange;
import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.DatabaseUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import liquibase.change.custom.CustomTaskChange;
import liquibase.database.Database;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.CustomChangeException;
import liquibase.exception.DatabaseException;
import liquibase.exception.SetupException;
import liquibase.exception.ValidationErrors;
import liquibase.resource.ResourceAccessor;
public class DuplicateEncounterRoleNameChangeSet implements CustomTaskChange {
	private static final Logger log = LoggerFactory.getLogger(DuplicateEncounterRoleNameChangeSet.class);
	@Override
	public String getConfirmationMessage() {
		return "Completed updating duplicate EncounterRole names";
	}
	@Override
	public void setFileOpener(ResourceAccessor arg0) {
	}
	@Override
	public void setUp() throws SetupException {
	}
	@Override
	public ValidationErrors validate(Database arg0) {
		return null;
	}
	@Override
	public void execute(Database database) throws CustomChangeException {
		JdbcConnection connection = (JdbcConnection) database.getConnection();
		Map<String, HashSet<Integer>> duplicates = new HashMap<>();
		Statement stmt = null;
		PreparedStatement pStmt = null;
		ResultSet rs = null;
		Boolean initialAutoCommit = null;
		try {
			initialAutoCommit = connection.getAutoCommit();
			connection.setAutoCommit(false);
			stmt = connection.createStatement();
			rs = stmt
			        .executeQuery("SELECT * FROM encounter_role INNER JOIN (SELECT name FROM encounter_role GROUP BY name HAVING count(name) > 1) dup ON encounter_role.name = dup.name");
			Integer id;
			String name;
			while (rs.next()) {
				id = rs.getInt("encounter_role_id");
				name = rs.getString("name");
				if (duplicates.get(name) == null) {
					HashSet<Integer> results = new HashSet<>();
					results.add(id);
					duplicates.put(name, results);
				} else {
					HashSet<Integer> results = duplicates.get(name);
					results.add(id);
				}
			}
			for (Object o : duplicates.entrySet()) {
				Map.Entry pairs = (Map.Entry) o;
				HashSet<Integer> values = (HashSet<Integer>) pairs.getValue();
				List<Integer> ids = new ArrayList<Integer>(values);
				int duplicateNameId = 1;
				for (int i = 1; i < ids.size(); i++) {
					String newName = pairs.getKey() + "_" + duplicateNameId;
					List<List<Object>> duplicateResult;
					boolean duplicateName;
					Connection con = DatabaseUpdater.getConnection();
					do {
						String sqlValidatorString = "select * from encounter_role where name = '" + newName + "'";
						duplicateResult = DatabaseUtil.executeSQL(con, sqlValidatorString, true);
						if (!duplicateResult.isEmpty()) {
							duplicateNameId += 1;
							newName = pairs.getKey() + "_" + duplicateNameId;
							duplicateName = true;
						} else {
							duplicateName = false;
						}
					} while (duplicateName);
					pStmt = connection
							.prepareStatement(
									"update encounter_role set name = ?, changed_by = ?, date_changed = ? where encounter_role_id = ?");
					if (!duplicateResult.isEmpty()) {
						pStmt.setString(1, newName);
					}
					pStmt.setString(1, newName);
					pStmt.setInt(2, DatabaseUpdater.getAuthenticatedUserId());
					Calendar cal = Calendar.getInstance();
					Date date = new Date(cal.getTimeInMillis());
					pStmt.setDate(3, date);
					pStmt.setInt(4, ids.get(i));
					duplicateNameId += 1;
					pStmt.executeUpdate();
				}
			}
		}
		catch (BatchUpdateException e) {
			log.warn("Error generated while processsing batch insert", e);
			try {
				log.debug("Rolling back batch", e);
				connection.rollback();
			}
			catch (Exception rbe) {
				log.warn("Error generated while rolling back batch insert", e);
			}
			throw new CustomChangeException("Failed to update one or more duplicate EncounterRole names", e);
		}
		catch (Exception e) {
			throw new CustomChangeException(e);
		}
		finally {
			try {
				connection.commit();
				if (initialAutoCommit != null) {
					connection.setAutoCommit(initialAutoCommit);
				}
			}
			catch (DatabaseException e) {
				log.warn("Failed to set auto commit to ids initial state", e);
			}
			if (rs != null) {
				try {
					rs.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the resultset object");
				}
			}
			if (stmt != null) {
				try {
					stmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the select statement used to identify duplicate EncounterRole object names");
				}
			}
			if (pStmt != null) {
				try {
					pStmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the prepared statement used to update duplicate EncounterRole object names");
				}
			}
		}
	}
}
package org.openmrs.util;
import org.openmrs.annotation.AddOnStartup;
import org.openmrs.annotation.HasAddOnStartupPrivileges;
@HasAddOnStartupPrivileges
public class PrivilegeConstants {
	private PrivilegeConstants() {
	}
	@AddOnStartup(description = "Able to get concept entries")
	public static final String GET_CONCEPTS = "Get Concepts";
	@AddOnStartup(description = "Able to get concept proposals to the system")
	public static final String GET_CONCEPT_PROPOSALS = "Get Concept Proposals";
	@AddOnStartup(description = "Able to get users in OpenMRS")
	public static final String GET_USERS = "Get Users";
	@AddOnStartup(description = "Able to get patient encounters")
	public static final String GET_ENCOUNTERS = "Get Encounters";
	@AddOnStartup(description = "Able to get encounter types")
	public static final String GET_ENCOUNTER_TYPES = "Get Encounter Types";
	@AddOnStartup(description = "Able to get locations")
	public static final String GET_LOCATIONS = "Get Locations";
	@AddOnStartup(description = "Able to get patient observations")
	public static final String GET_OBS = "Get Observations";
	@AddOnStartup(description = "Able to get patient notes")
	public static final String GET_NOTE = "Get Notes";
	@AddOnStartup(description = "Able to get patients")
	public static final String GET_PATIENTS = "Get Patients";
	@AddOnStartup(description = "Able to get patient identifiers")
	public static final String GET_PATIENT_IDENTIFIERS = "Get Patient Identifiers";
	@AddOnStartup(description = "Able to get patient cohorts")
	public static final String GET_PATIENT_COHORTS = "Get Patient Cohorts";
	@AddOnStartup(description = "Able to get orders")
	public static final String GET_ORDERS = "Get Orders";
	@AddOnStartup(description = "Able to get forms")
	public static final String GET_FORMS = "Get Forms";
	@AddOnStartup(description = "Able to get patient identifier types")
	public static final String GET_IDENTIFIER_TYPES = "Get Identifier Types";
	@AddOnStartup(description = "Able to get concept classes")
	public static final String GET_CONCEPT_CLASSES = "Get Concept Classes";
	@AddOnStartup(description = "Able to get concept datatypes")
	public static final String GET_CONCEPT_DATATYPES = "Get Concept Datatypes";
	@AddOnStartup(description = "Able to get user privileges")
	public static final String GET_PRIVILEGES = "Get Privileges";
	@AddOnStartup(description = "Able to get user roles")
	public static final String GET_ROLES = "Get Roles";
	@AddOnStartup(description = "Able to get field types")
	public static final String GET_FIELD_TYPES = "Get Field Types";
	@AddOnStartup(description = "Able to get order types")
	public static final String GET_ORDER_TYPES = "Get Order Types";
	@AddOnStartup(description = "Able to get relationship types")
	public static final String GET_RELATIONSHIP_TYPES = "Get Relationship Types";
	@AddOnStartup(description = "Able to get concept sources")
	public static final String GET_CONCEPT_SOURCES = "Get Concept Sources";
	@AddOnStartup(description = "Able to get concept map types")
	public static final String GET_CONCEPT_MAP_TYPES = "Get Concept Map Types";
	@AddOnStartup(description = "Able to get concept reference terms")
	public static final String GET_CONCEPT_REFERENCE_TERMS = "Get Concept Reference Terms";
	@AddOnStartup(description = "Able to get patient programs")
	public static final String GET_PROGRAMS = "Get Programs";
	@AddOnStartup(description = "Able to get which programs that patients are in")
	public static final String GET_PATIENT_PROGRAMS = "Get Patient Programs";
	@AddOnStartup(description = "Able to get global properties on the administration screen")
	public static final String GET_GLOBAL_PROPERTIES = "Get Global Properties";
	@AddOnStartup(description = "Able to get person attribute types")
	public static final String GET_PERSON_ATTRIBUTE_TYPES = "Get Person Attribute Types";
	@AddOnStartup(description = "Able to get provider attribute types")
	public static final String GET_PROVIDER_ATTRIBUTE_TYPES = "Get Provider Attribute Types";
	@AddOnStartup(description = "Able to get person objects")
	public static final String GET_PERSONS = "Get People";
	@AddOnStartup(description = "Able to get relationships")
	public static final String GET_RELATIONSHIPS = "Get Relationships";
	@AddOnStartup(description = "Able to get database changes from the admin screen")
	public static final String GET_DATABASE_CHANGES = "Get Database Changes";
	@AddOnStartup(description = "Able to get problems")
	public static final String GET_PROBLEMS = "Get Problems";
	@AddOnStartup(description = "Able to get allergies")
	public static final String GET_ALLERGIES = "Get Allergies";
	@AddOnStartup(description = "Able to add/edit/delete HL7 messages")
	public static final String MANAGE_HL7_MESSAGES = "Manage HL7 Messages";
	public static final String PURGE_HL7_MESSAGES = "Purge HL7 Messages";
	@AddOnStartup(description = "Able to get an HL7 Source")
	public static final String GET_HL7_SOURCE = "Get HL7 Source";
	@AddOnStartup(description = "Able to get an HL7 Queue item")
	public static final String GET_HL7_IN_QUEUE = "Get HL7 Inbound Queue";
	@AddOnStartup(description = "Able to get an HL7 archive item")
	public static final String GET_HL7_IN_ARCHIVE = "Get HL7 Inbound Archive";
	@AddOnStartup(description = "Able to get an HL7 error item")
	public static final String GET_HL7_IN_EXCEPTION = "Get HL7 Inbound Exception";
	@AddOnStartup(description = "Able to get visit types")
	public static final String GET_VISIT_TYPES = "Get Visit Types";
	@AddOnStartup(description = "Able to get visits")
	public static final String GET_VISITS = "Get Visits";
	@AddOnStartup(description = "Able to get visit attribute types")
	public static final String GET_VISIT_ATTRIBUTE_TYPES = "Get Visit Attribute Types";
	@AddOnStartup(description = "Able to get location attribute types")
	public static final String GET_LOCATION_ATTRIBUTE_TYPES = "Get Location Attribute Types";
	@AddOnStartup(description = "Able to get Provider")
	public static final String GET_PROVIDERS = "Get Providers";
	@AddOnStartup(description = "Able to get encounter roles")
	public static final String GET_ENCOUNTER_ROLES = "Get Encounter Roles";
	@AddOnStartup(description = "Able to add/edit/delete concept entries")
	public static final String MANAGE_CONCEPTS = "Manage Concepts";
	public static final String PURGE_CONCEPTS = "Purge Concepts";
	@AddOnStartup(description = "Able to add/edit/delete concept name tags")
	public static final String MANAGE_CONCEPT_NAME_TAGS = "Manage Concept Name tags";
	@AddOnStartup(description = "Able to add concept proposals to the system")
	public static final String ADD_CONCEPT_PROPOSALS = "Add Concept Proposals";
	@AddOnStartup(description = "Able to edit concept proposals in the system")
	public static final String EDIT_CONCEPT_PROPOSALS = "Edit Concept Proposals";
	@AddOnStartup(description = "Able to delete concept proposals from the system")
	public static final String DELETE_CONCEPT_PROPOSALS = "Delete Concept Proposals";
	public static final String PURGE_CONCEPT_PROPOSALS = "Purge Concept Proposals";
	@AddOnStartup(description = "Able to add users to OpenMRS")
	public static final String ADD_USERS = "Add Users";
	@AddOnStartup(description = "Able to edit users in OpenMRS")
	public static final String EDIT_USERS = "Edit Users";
	@AddOnStartup(description = "Able to delete users in OpenMRS")
	public static final String DELETE_USERS = "Delete Users";
	public static final String PURGE_USERS = "Purge Users";
	@AddOnStartup(description = "Able to change the passwords of users in OpenMRS")
	public static final String EDIT_USER_PASSWORDS = "Edit User Passwords";
	@AddOnStartup(description = "Able to add patient encounters")
	public static final String ADD_ENCOUNTERS = "Add Encounters";
	@AddOnStartup(description = "Able to edit patient encounters")
	public static final String EDIT_ENCOUNTERS = "Edit Encounters";
	@AddOnStartup(description = "Able to delete patient encounters")
	public static final String DELETE_ENCOUNTERS = "Delete Encounters";
	public static final String PURGE_ENCOUNTERS = "Purge Encounters";
	@AddOnStartup(description = "Able to add/edit/retire encounter types")
	public static final String MANAGE_ENCOUNTER_TYPES = "Manage Encounter Types";
	public static final String PURGE_ENCOUNTER_TYPES = "Purge Encounter Types";
	@AddOnStartup(description = "Able to choose encounter visit handler and enable/disable encounter visits")
	public static final String CONFIGURE_VISITS = "Configure Visits";
	@AddOnStartup(description = "Able to add/edit/delete locations")
	public static final String MANAGE_LOCATIONS = "Manage Locations";
	public static final String PURGE_LOCATIONS = "Purge Locations";
	@AddOnStartup(description = "Able to add/edit/delete location tags")
	public static final String MANAGE_LOCATION_TAGS = "Manage Location Tags";
	@AddOnStartup(description = "Able to add/edit/delete address templates")
	public static final String MANAGE_ADDRESS_TEMPLATES = "Manage Address Templates";
	public static final String PURGE_LOCATION_TAGS = "Purge Location Tags";
	@AddOnStartup(description = "Able to add patient observations")
	public static final String ADD_OBS = "Add Observations";
	@AddOnStartup(description = "Able to edit patient observations")
	public static final String EDIT_OBS = "Edit Observations";
	@AddOnStartup(description = "Able to delete patient observations")
	public static final String DELETE_OBS = "Delete Observations";
	public static final String PURGE_OBS = "Purge Observations";
	@AddOnStartup(description = "Able to edit patient notes")
	public static final String EDIT_NOTE = "Edit Notes";
	@AddOnStartup(description = "Able to delete patient notes")
	public static final String DELETE_NOTE = "Delete Notes";
	@AddOnStartup(description = "Able to add patients")
	public static final String ADD_PATIENTS = "Add Patients";
	@AddOnStartup(description = "Able to edit patients")
	public static final String EDIT_PATIENTS = "Edit Patients";
	@AddOnStartup(description = "Able to delete patients")
	public static final String DELETE_PATIENTS = "Delete Patients";
	public static final String PURGE_PATIENTS = "Purge Patients";
	@AddOnStartup(description = "Able to add patient identifiers")
	public static final String ADD_PATIENT_IDENTIFIERS = "Add Patient Identifiers";
	@AddOnStartup(description = "Able to edit patient identifiers")
	public static final String EDIT_PATIENT_IDENTIFIERS = "Edit Patient Identifiers";
	@AddOnStartup(description = "Able to delete patient identifiers")
	public static final String DELETE_PATIENT_IDENTIFIERS = "Delete Patient Identifiers";
	public static final String PURGE_PATIENT_IDENTIFIERS = "Purge Patient Identifiers";
	@AddOnStartup(description = "Able to add a cohort to the system")
	public static final String ADD_COHORTS = "Add Cohorts";
	@AddOnStartup(description = "Able to add a cohort to the system")
	public static final String EDIT_COHORTS = "Edit Cohorts";
	@AddOnStartup(description = "Able to add a cohort to the system")
	public static final String DELETE_COHORTS = "Delete Cohorts";
	public static final String PURGE_COHORTS = "Purge Cohorts";
	@AddOnStartup(description = "Able to add orders")
	public static final String ADD_ORDERS = "Add Orders";
	@AddOnStartup(description = "Able to edit orders")
	public static final String EDIT_ORDERS = "Edit Orders";
	@AddOnStartup(description = "Able to delete orders")
	public static final String DELETE_ORDERS = "Delete Orders";
	public static final String PURGE_ORDERS = "Purge Orders";
	@AddOnStartup(description = "Able to add/edit/delete forms")
	public static final String MANAGE_FORMS = "Manage Forms";
	public static final String PURGE_FORMS = "Purge Forms";
	@AddOnStartup(description = "Able to fill out forms")
	public static final String FORM_ENTRY = "Form Entry";
	@AddOnStartup(description = "Able to add/edit/retire patient identifier types")
	public static final String MANAGE_IDENTIFIER_TYPES = "Manage Identifier Types";
	public static final String PURGE_IDENTIFIER_TYPES = "Purge Identifier Types";
	@AddOnStartup(description = "Able to add/edit/retire concept classes")
	public static final String MANAGE_CONCEPT_CLASSES = "Manage Concept Classes";
	public static final String PURGE_CONCEPT_CLASSES = "Purge Concept Classes";
	@AddOnStartup(description = "Able to add/edit/retire concept datatypes")
	public static final String MANAGE_CONCEPT_DATATYPES = "Manage Concept Datatypes";
	public static final String PURGE_CONCEPT_DATATYPES = "Purge Concept Datatypes";
	@AddOnStartup(description = "Able to add/edit/delete privileges")
	public static final String MANAGE_PRIVILEGES = "Manage Privileges";
	public static final String PURGE_PRIVILEGES = "Purge Privileges";
	@AddOnStartup(description = "Able to add/edit/delete user roles")
	public static final String MANAGE_ROLES = "Manage Roles";
	public static final String PURGE_ROLES = "Purge Roles";
	@AddOnStartup(description = "Able to add/edit/retire field types")
	public static final String MANAGE_FIELD_TYPES = "Manage Field Types";
	public static final String PURGE_FIELD_TYPES = "Purge Field Types";
	@AddOnStartup(description = "Able to add/edit/retire order types")
	public static final String MANAGE_ORDER_TYPES = "Manage Order Types";
	public static final String PURGE_ORDER_TYPES = "Purge Order Types";
	@AddOnStartup(description = "Able to add/edit/retire relationship types")
	public static final String MANAGE_RELATIONSHIP_TYPES = "Manage Relationship Types";
	public static final String PURGE_RELATIONSHIP_TYPES = "Purge Relationship Types";
	@AddOnStartup(description = "Able to add/edit/delete user alerts")
	public static final String MANAGE_ALERTS = "Manage Alerts";
	@AddOnStartup(description = "Able to add/edit/delete concept sources")
	public static final String MANAGE_CONCEPT_SOURCES = "Manage Concept Sources";
	@AddOnStartup(description = "Able to add/edit/retire concept map types")
	public static final String MANAGE_CONCEPT_MAP_TYPES = "Manage Concept Map Types";
	public static final String PURGE_CONCEPT_MAP_TYPES = "Purge Concept Map Types";
	@AddOnStartup(description = "Able to add/edit/retire reference terms")
	public static final String MANAGE_CONCEPT_REFERENCE_TERMS = "Manage Concept Reference Terms";
	public static final String CREATE_REFERENCE_TERMS_WHILE_EDITING_CONCEPTS = "Create Reference Terms While Editing Concepts";
	public static final String PURGE_CONCEPT_REFERENCE_TERMS = "Purge Concept Reference Terms";
	public static final String PURGE_CONCEPT_SOURCES = "Purge Concept Sources";
	@AddOnStartup(description = "Able to view the navigation menu (Home, View Patients, Dictionary, Administration, My Profile")
	public static final String VIEW_NAVIGATION_MENU = "View Navigation Menu";
	@AddOnStartup(description = "Able to view the 'Administration' link in the navigation bar")
	public static final String VIEW_ADMIN_FUNCTIONS = "View Administration Functions";
	@AddOnStartup(description = "Able to view and fill out unpublished forms")
	public static final String VIEW_UNPUBLISHED_FORMS = "View Unpublished Forms";
	@AddOnStartup(description = "Able to add/view/delete patient programs")
	public static final String MANAGE_PROGRAMS = "Manage Programs";
	@AddOnStartup(description = "Able to add patients to programs")
	public static final String ADD_PATIENT_PROGRAMS = "Add Patient Programs";
	@AddOnStartup(description = "Able to edit patients in programs")
	public static final String EDIT_PATIENT_PROGRAMS = "Edit Patient Programs";
	@AddOnStartup(description = "Able to delete patients from programs")
	public static final String DELETE_PATIENT_PROGRAMS = "Delete Patient Programs";
	public static final String PURGE_PATIENT_PROGRAMS = "Purge Patient Programs";
	@AddOnStartup(description = "Able to add/edit global properties")
	public static final String MANAGE_GLOBAL_PROPERTIES = "Manage Global Properties";
	public static final String PURGE_GLOBAL_PROPERTIES = "Purge Global Properties";
	@AddOnStartup(description = "Able to add/remove modules to the system")
	public static final String MANAGE_MODULES = "Manage Modules";
	@AddOnStartup(description = "Able to add/edit/remove scheduled tasks")
	public static final String MANAGE_SCHEDULER = "Manage Scheduler";
	@AddOnStartup(description = "Able to add/edit/retire person attribute types")
	public static final String MANAGE_PERSON_ATTRIBUTE_TYPES = "Manage Person Attribute Types";
	public static final String PURGE_PERSON_ATTRIBUTE_TYPES = "Purge Person Attribute Types";
	@AddOnStartup(description = "Able to add person objects")
	public static final String ADD_PERSONS = "Add People";
	@AddOnStartup(description = "Able to add person objects")
	public static final String EDIT_PERSONS = "Edit People";
	@AddOnStartup(description = "Able to delete objects")
	public static final String DELETE_PERSONS = "Delete People";
	public static final String PURGE_PERSONS = "Purge People";
	@AddOnStartup(description = "Able to add relationships")
	public static final String ADD_RELATIONSHIPS = "Add Relationships";
	@AddOnStartup(description = "Able to edit relationships")
	public static final String EDIT_RELATIONSHIPS = "Edit Relationships";
	@AddOnStartup(description = "Able to delete relationships")
	public static final String DELETE_RELATIONSHIPS = "Delete Relationships";
	public static final String PURGE_RELATIONSHIPS = "Purge Relationships";
	@AddOnStartup(description = "Able to view/add/edit the implementation id for the system")
	public static final String MANAGE_IMPLEMENTATION_ID = "Manage Implementation Id";
	public static final String SQL_LEVEL_ACCESS = "SQL Level Access";
	@AddOnStartup(description = "Add problems")
	public static final String ADD_PROBLEMS = "Add Problems";
	@AddOnStartup(description = "Able to edit problems")
	public static final String EDIT_PROBLEMS = "Edit Problems";
	@AddOnStartup(description = "Remove problems")
	public static final String DELETE_PROBLEMS = "Remove Problems";
	@AddOnStartup(description = "Add allergies")
	public static final String ADD_ALLERGIES = "Add Allergies";
	@AddOnStartup(description = "Able to edit allergies")
	public static final String EDIT_ALLERGIES = "Edit Allergies";
	@AddOnStartup(description = "Remove allergies")
	public static final String DELETE_ALLERGIES = "Remove Allergies";
	@AddOnStartup(description = "Able to view/add/remove the concept stop words")
	public static final String MANAGE_CONCEPT_STOP_WORDS = "Manage Concept Stop Words";
	@AddOnStartup(description = "Able to add an HL7 Source")
	public static final String PRIV_ADD_HL7_SOURCE = "Add HL7 Source";
	@AddOnStartup(description = "Able to update an HL7 Source")
	public static final String PRIV_UPDATE_HL7_SOURCE = "Update HL7 Source";
	public static final String PRIV_PURGE_HL7_SOURCE = "Purge HL7 Source";
	@AddOnStartup(description = "Able to add an HL7 Queue item")
	public static final String PRIV_ADD_HL7_IN_QUEUE = "Add HL7 Inbound Queue";
	@AddOnStartup(description = "Able to update an HL7 Queue item")
	public static final String PRIV_UPDATE_HL7_IN_QUEUE = "Update HL7 Inbound Queue";
	@AddOnStartup(description = "Able to delete an HL7 Queue item")
	public static final String PRIV_DELETE_HL7_IN_QUEUE = "Delete HL7 Inbound Queue";
	public static final String PRIV_PURGE_HL7_IN_QUEUE = "Purge HL7 Inbound Queue";
	@AddOnStartup(description = "Able to add an HL7 archive item")
	public static final String PRIV_ADD_HL7_IN_ARCHIVE = "Add HL7 Inbound Archive";
	@AddOnStartup(description = "Able to update an HL7 archive item")
	public static final String PRIV_UPDATE_HL7_IN_ARCHIVE = "Update HL7 Inbound Archive";
	@AddOnStartup(description = "Able to delete/retire an HL7 archive item")
	public static final String PRIV_DELETE_HL7_IN_ARCHIVE = "Delete HL7 Inbound Archive";
	public static final String PRIV_PURGE_HL7_IN_ARCHIVE = "Purge HL7 Inbound Archive";
	@AddOnStartup(description = "Able to add an HL7 error item")
	public static final String PRIV_ADD_HL7_IN_EXCEPTION = "Add HL7 Inbound Exception";
	@AddOnStartup(description = "Able to update an HL7 archive item")
	public static final String PRIV_UPDATE_HL7_IN_EXCEPTION = "Update HL7 Inbound Exception";
	@AddOnStartup(description = "Able to delete an HL7 archive item")
	public static final String PRIV_DELETE_HL7_IN_EXCEPTION = "Delete HL7 Inbound Exception";
	public static final String PRIV_PURGE_HL7_IN_EXCEPTION = "Purge HL7 Inbound Exception";
	@AddOnStartup(description = "Able to add/edit/delete visit types")
	public static final String MANAGE_VISIT_TYPES = "Manage Visit Types";
	@AddOnStartup(description = "Able to add visits")
	public static final String ADD_VISITS = "Add Visits";
	@AddOnStartup(description = "Able to edit visits")
	public static final String EDIT_VISITS = "Edit Visits";
	@AddOnStartup(description = "Able to delete visits")
	public static final String DELETE_VISITS = "Delete Visits";
	public static final String PURGE_VISITS = "Purge Visits";
	@AddOnStartup(description = "Able to add/edit/retire visit attribute types")
	public static final String MANAGE_VISIT_ATTRIBUTE_TYPES = "Manage Visit Attribute Types";
	public static final String PURGE_VISIT_ATTRIBUTE_TYPES = "Purge Visit Attribute Types";
	@AddOnStartup(description = "Able to add/edit/retire location attribute types")
	public static final String MANAGE_LOCATION_ATTRIBUTE_TYPES = "Manage Location Attribute Types";
	public static final String PURGE_LOCATION_ATTRIBUTE_TYPES = "Purge Location Attribute Types";
	@AddOnStartup(description = "Able to edit Provider")
	public static final String MANAGE_PROVIDERS = "Manage Providers";
	public static final String PURGE_PROVIDERS = "Purge Providers";
	public static final String PURGE_ENCOUNTER_ROLES = "Purge Encounter Roles";
	@AddOnStartup(description = "Able to add/edit/retire encounter roles")
	public static final String MANAGE_ENCOUNTER_ROLES = "Manage Encounter Roles";
	@AddOnStartup(description = "Able to assign System Developer role")
	public static final String ASSIGN_SYSTEM_DEVELOPER_ROLE = "Assign System Developer Role";
	@AddOnStartup(description = "Able to get Order Frequencies")
	public static final String GET_ORDER_FREQUENCIES = "Get Order Frequencies";
	@AddOnStartup(description = "Able to add/edit/retire Order Frequencies")
	public static final String MANAGE_ORDER_FREQUENCIES = "Manage Order Frequencies";
	public static final String PURGE_ORDER_FREQUENCIES = "Purge Order Frequencies";
	@AddOnStartup(description = "Able to get Care Settings")
	public static final String GET_CARE_SETTINGS = "Get Care Settings";
	@AddOnStartup(description = "Able to manage the search index")
	public static final String MANAGE_SEARCH_INDEX = "Manage Search Index";
	@AddOnStartup(description = "Able to add, edit, delete allergies")
	public static final String MODIFY_ALLERGIES = "Task: Modify Allergies";
	@AddOnStartup(description = "Able to get order sets")
	public static final String GET_ORDER_SETS = "Get Order Sets";
	@AddOnStartup(description = "Able to manage order sets")
	public static final String MANAGE_ORDER_SETS = "Manage Order Sets";
	@AddOnStartup(description = "Able to get concept attribute types")
	public static final String GET_CONCEPT_ATTRIBUTE_TYPES = "Get Concept Attribute Types";
	@AddOnStartup(description = "Able to add/edit/retire concept attribute types")
	public static final String MANAGE_CONCEPT_ATTRIBUTE_TYPES = "Manage Concept Attribute Types";
	public static final String PURGE_CONCEPT_ATTRIBUTE_TYPES = "Purge Concept Attribute Types";
	@AddOnStartup(description = "Able to edit conditions")
	public static final String EDIT_CONDITIONS = "Edit Conditions";
	@AddOnStartup(description = "Able to get conditions")
	public static final String GET_CONDITIONS = "Get Conditions";
	@AddOnStartup(description = "Able to delete conditions")
	public static final String DELETE_CONDITIONS = "Delete Conditions";
	@AddOnStartup(description = "Able to edit diagnoses")
	public static final String EDIT_DIAGNOSES = "Edit Diagnoses";
	@AddOnStartup(description = "Able to get diagnoses")
	public static final String GET_DIAGNOSES = "Get Diagnoses";
	@AddOnStartup(description = "Able to delete diagnoses")
	public static final String DELETE_DIAGNOSES = "Delete Diagnoses";
	@AddOnStartup(description = "Able to get diagnoses attribute types")
	public static final String GET_DIAGNOSES_ATTRIBUTE_TYPES = "Get Diagnoses Attribute Types";
	@AddOnStartup(description = "Able to get order set attribute types")
	public static final String GET_ORDER_SET_ATTRIBUTE_TYPES = "Get Order Set Attribute Types";
	@AddOnStartup(description = "Able to add/edit/retire order set attribute types")
	public static final String MANAGE_ORDER_SET_ATTRIBUTE_TYPES = "Manage Order Set Attribute Types";
	public static final String PURGE_ORDER_SET_ATTRIBUTE_TYPES = "Purge Order Set Attribute Types";
	@AddOnStartup(description = "Able to get Medication Dispenses")
	public static final String GET_MEDICATION_DISPENSE = "Get Medication Dispense";
	@AddOnStartup(description = "Able to edit Medication Dispenses")
	public static final String EDIT_MEDICATION_DISPENSE = "Edit Medication Dispense";
	@AddOnStartup(description = "Able to delete Medication Dispenses")
	public static final String DELETE_MEDICATION_DISPENSE = "Delete Medication Dispense";
}
package org.openmrs.util.databasechange;
import java.sql.BatchUpdateException;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Calendar;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.util.DatabaseUpdater;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import liquibase.change.custom.CustomTaskChange;
import liquibase.database.Database;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.CustomChangeException;
import liquibase.exception.DatabaseException;
import liquibase.exception.SetupException;
import liquibase.exception.ValidationErrors;
import liquibase.resource.ResourceAccessor;
public class AddConceptMapTypesChangeset implements CustomTaskChange {
	private static final Logger log = LoggerFactory.getLogger(AddConceptMapTypesChangeset.class);
	private String visibleConceptMapTypes;
	private String hiddenConceptMapTypes;
	private String[] visibleConceptMapTypeArray;
	private String[] hiddenConceptMapTypeArray;
	@Override
	public void execute(Database database) throws CustomChangeException {
		runBatchInsert((JdbcConnection) database.getConnection());
	}
	private void runBatchInsert(JdbcConnection connection) throws CustomChangeException {
		PreparedStatement pStmt = null;
		try {
			connection.setAutoCommit(false);
			Integer userId = DatabaseUpdater.getAuthenticatedUserId();
			if (userId == null || userId < 1) {
				userId = getInt(connection, "SELECT min(user_id) FROM users");
				if (userId < 1) {
					userId = null;
				}
			}
			pStmt = connection.prepareStatement("INSERT INTO concept_map_type "
			        + "(concept_map_type_id, name, is_hidden, retired, creator, date_created, uuid) VALUES(?,?,?,?,"
			        + userId + ",?,?)");
			int mapTypeId = 1;
			for (String map : visibleConceptMapTypeArray) {
				String[] mapTypeAndUuid = map.trim().split("\\|");
				String mapType = mapTypeAndUuid[0];
				String mapUuid = mapTypeAndUuid[1];
				pStmt.setInt(1, mapTypeId);
				pStmt.setString(2, mapType);
				pStmt.setBoolean(3, false);
				pStmt.setBoolean(4, false);
				pStmt.setDate(5, new Date(Calendar.getInstance().getTimeInMillis()));
				pStmt.setString(6, mapUuid);
				pStmt.addBatch();
				mapTypeId++;
			}
			for (String map : hiddenConceptMapTypeArray) {
				String[] mapTypeAndUuid = map.trim().split("\\|");
				String mapType = mapTypeAndUuid[0];
				String mapUuid = mapTypeAndUuid[1];
				pStmt.setInt(1, mapTypeId);
				pStmt.setString(2, mapType);
				pStmt.setBoolean(3, true);
				pStmt.setBoolean(4, false);
				pStmt.setDate(5, new Date(Calendar.getInstance().getTimeInMillis()));
				pStmt.setString(6, mapUuid);
				pStmt.addBatch();
				mapTypeId++;
			}
			try {
				int[] updateCounts = pStmt.executeBatch();
				for (int updateCount : updateCounts) {
					if (updateCount > -1) {
						log.debug("Successfully executed: updateCount=" + updateCount);
					} else if (updateCount == Statement.SUCCESS_NO_INFO) {
						log.debug("Successfully executed; No Success info");
					} else if (updateCount == Statement.EXECUTE_FAILED) {
						log.warn("Failed to execute insert");
					}
				}
				log.debug("Committing inserts...");
				connection.commit();
			}
			catch (BatchUpdateException be) {
				log.warn("Error generated while processsing batch insert", be);
				int[] updateCounts = be.getUpdateCounts();
				for (int updateCount : updateCounts) {
					if (updateCount > -1) {
						log.warn("Executed with exception: insertCount=" + updateCount);
					} else if (updateCount == Statement.SUCCESS_NO_INFO) {
						log.warn("Executed with exception; No Success info");
					} else if (updateCount == Statement.EXECUTE_FAILED) {
						log.warn("Failed to execute insert with exception");
					}
				}
				try {
					log.debug("Rolling back batch", be);
					connection.rollback();
				}
				catch (Exception rbe) {
					log.warn("Error generated while rolling back batch insert", be);
				}
				throw new CustomChangeException("Failed to insert one or more concept map types", be);
			}
		}
		catch (DatabaseException | SQLException e) {
			throw new CustomChangeException("Failed to insert one or more concept map types:", e);
		}
		finally {
			try {
				connection.setAutoCommit(true);
			}
			catch (DatabaseException e) {
				log.warn("Failed to reset auto commit back to true", e);
			}
			if (pStmt != null) {
				try {
					pStmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the prepared statement object");
				}
			}
		}
	}
	private int getInt(JdbcConnection connection, String sql) {
		Statement stmt = null;
		int result = 0;
		try {
			stmt = connection.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			if (rs.next()) {
				result = rs.getInt(1);
			} else {
				log.warn("No row returned by getInt() method");
			}
			if (rs.next()) {
				log.warn("Multiple rows returned by getInt() method");
			}
			return result;
		}
		catch (DatabaseException | SQLException e) {
			log.warn("Error generated", e);
		}
		finally {
			if (stmt != null) {
				try {
					stmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the statement object");
				}
			}
		}
		return result;
	}
	@Override
	public void setUp() throws SetupException {
		if (StringUtils.isNotBlank(visibleConceptMapTypes)) {
			visibleConceptMapTypeArray = StringUtils.split(visibleConceptMapTypes, ",");
		}
		if (StringUtils.isNotBlank(hiddenConceptMapTypes)) {
			hiddenConceptMapTypeArray = StringUtils.split(hiddenConceptMapTypes, ",");
		}
	}
	public void setVisibleConceptMapTypes(String visibleConceptMapTypes) {
		this.visibleConceptMapTypes = visibleConceptMapTypes;
	}
	public void setHiddenConceptMapTypes(String hiddenConceptMapTypes) {
		this.hiddenConceptMapTypes = hiddenConceptMapTypes;
	}
	@Override
	public String getConfirmationMessage() {
		return "Finished inserting core concept map types";
	}
	@Override
	public void setFileOpener(ResourceAccessor resourceAccessor) {
	}
	@Override
	public ValidationErrors validate(Database database) {
		return null;
	}
}
package org.openmrs.util.databasechange;
import java.sql.BatchUpdateException;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.collections.set.ListOrderedSet;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.ConceptName;
import org.openmrs.api.ConceptNameType;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import liquibase.change.custom.CustomTaskChange;
import liquibase.database.Database;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.CustomChangeException;
import liquibase.exception.DatabaseException;
import liquibase.exception.SetupException;
import liquibase.exception.ValidationErrors;
import liquibase.resource.ResourceAccessor;
public class ConceptValidatorChangeSet implements CustomTaskChange {
	private static final Logger log = LoggerFactory.getLogger(ConceptValidatorChangeSet.class);
	private List<String> updateWarnings = new LinkedList<>();
	private List<String> logMessages = new LinkedList<>();
	private Set<ConceptName> updatedConceptNames = new HashSet<>();
	private Locale defaultLocale = new Locale("en");
	private List<Locale> allowedLocales = null;
	@Override
	public void execute(Database database) throws CustomChangeException {
		JdbcConnection connection = (JdbcConnection) database.getConnection();
		validateAndCleanUpConcepts(connection);
		if (!updatedConceptNames.isEmpty()) {
			runBatchUpdate(connection);
		} else {
			log.debug("No concept names to update");
		}
		if (!logMessages.isEmpty() || !updateWarnings.isEmpty()) {
			writeWarningsToFile();
		}
		if (!updateWarnings.isEmpty()) {
			DatabaseUpdater.reportUpdateWarnings(updateWarnings);
		}
		updateWarnings = null;
		updatedConceptNames = null;
		logMessages = null;
	}
	private void validateAndCleanUpConcepts(JdbcConnection connection) {
		List<Integer> conceptIds = getAllUnretiredConceptIds(connection);
		allowedLocales = getAllowedLocalesList(connection);
		defaultLocale = allowedLocales.get(allowedLocales.size() - 1);
		Map<Locale, Set<String>> localeDuplicateNamesMap = null;
		for (Integer conceptId : conceptIds) {
			Map<Locale, List<ConceptName>> localeConceptNamesMap = getLocaleConceptNamesMap(connection, conceptId);
			if (localeConceptNamesMap == null) {
				updateWarnings.add("No names added for concept with id: " + conceptId);
				continue;
			}
			boolean hasFullySpecifiedName = false;
			List<ConceptName> namesWithNoLocale = null;
			for (Map.Entry<Locale, List<ConceptName>> e : localeConceptNamesMap.entrySet()) {
				Locale conceptNameLocale = e.getKey();
				boolean fullySpecifiedNameForLocaleFound = false;
				boolean preferredNameForLocaleFound = false;
				boolean shortNameForLocaleFound = false;
				Map<String, List<ConceptName>> nameDuplicateConceptNamesMap = new HashMap<>();
				for (ConceptName nameInLocale : e.getValue()) {
					if (StringUtils.isBlank(nameInLocale.getName())) {
						updateWarnings.add("ConceptName with id " + nameInLocale.getConceptNameId() + " ("
						        + nameInLocale.getName() + ") is null, white space character or empty string");
					}
					if (conceptNameLocale == null) {
						if (namesWithNoLocale == null) {
							namesWithNoLocale = new LinkedList<>();
						}
						namesWithNoLocale.add(nameInLocale);
						continue;
					}
					if (!allowedLocales.contains(conceptNameLocale)) {
						updateWarnings.add("ConceptName with id: " + nameInLocale.getConceptNameId() + " ("
						        + nameInLocale.getName() + ") has a locale (" + conceptNameLocale
						        + ") that isn't listed among the allowed ones by the system admin");
					}
					if (nameInLocale.getLocalePreferred() != null) {
						if (nameInLocale.getLocalePreferred() && !preferredNameForLocaleFound) {
							if (nameInLocale.isIndexTerm()) {
								nameInLocale.setLocalePreferred(false);
								reportUpdatedName(nameInLocale, "Preferred name '" + nameInLocale.getName()
								        + "' in locale '" + conceptNameLocale.getDisplayName()
								        + "' has been dropped as the preferred name because it is a search term");
							} else if (nameInLocale.isShort()) {
								nameInLocale.setLocalePreferred(false);
								reportUpdatedName(nameInLocale, "Preferred name '" + nameInLocale.getName()
								        + "' in locale '" + conceptNameLocale.getDisplayName()
								        + "' has been dropped as the preferred name because it is a short name");
							} else {
								preferredNameForLocaleFound = true;
							}
						}
						else if (nameInLocale.getLocalePreferred() && preferredNameForLocaleFound) {
							nameInLocale.setLocalePreferred(false);
							reportUpdatedName(
							    nameInLocale,
							    "Preferred name '"
							            + nameInLocale.getName()
							            + "' in locale '"
							            + conceptNameLocale.getDisplayName()
							            + "' has been dropped as the preferred name because there is already another preferred name in the same locale");
						}
					} else {
						nameInLocale.setLocalePreferred(false);
						reportUpdatedName(nameInLocale, "The locale preferred property of name '" + nameInLocale.getName()
						        + "' in locale '" + conceptNameLocale.getDisplayName()
						        + "' has been updated to false from null");
					}
					if (nameInLocale.isFullySpecifiedName()) {
						if (!hasFullySpecifiedName) {
							hasFullySpecifiedName = true;
						}
						if (!fullySpecifiedNameForLocaleFound) {
							fullySpecifiedNameForLocaleFound = true;
						} else {
							nameInLocale.setConceptNameType(null);
							reportUpdatedName(nameInLocale, "The name '" + nameInLocale.getName() + "' in locale '"
							        + conceptNameLocale.getDisplayName()
							        + "' has been converted from fully specified to a synonym");
						}
					}
					if (nameInLocale.isShort()) {
						if (!shortNameForLocaleFound) {
							shortNameForLocaleFound = true;
						}
						else {
							nameInLocale.setConceptNameType(null);
							reportUpdatedName(nameInLocale, "The name '" + nameInLocale.getName() + "' in locale '"
							        + conceptNameLocale.getDisplayName()
							        + "' has been converted from a short name to a synonym");
						}
					}
					if ((nameInLocale.isFullySpecifiedName() || nameInLocale.isPreferred())
					        && !isNameUniqueInLocale(connection, nameInLocale, conceptId)) {
						if (localeDuplicateNamesMap == null) {
							localeDuplicateNamesMap = new HashMap<>();
						}
						if (!localeDuplicateNamesMap.containsKey(conceptNameLocale)) {
							localeDuplicateNamesMap.put(conceptNameLocale, new HashSet<>());
						}
						localeDuplicateNamesMap.get(conceptNameLocale).add(nameInLocale.getName());
					}
					String name = nameInLocale.getName().toLowerCase();
					if (!nameDuplicateConceptNamesMap.containsKey(name)) {
						nameDuplicateConceptNamesMap.put(name, new ArrayList<>());
					}
					nameDuplicateConceptNamesMap.get(name).add(nameInLocale);
				}
				for (Map.Entry<String, List<ConceptName>> entry : nameDuplicateConceptNamesMap.entrySet()) {
					if (entry.getValue().size() < 2) {
						continue;
					}
					logMessages.add("The name '" + entry.getKey() + "' was found multiple times for the concept with id '"
					        + conceptId + "' in locale '" + conceptNameLocale.getDisplayName() + "'");					
				}
				if (!preferredNameForLocaleFound) {
					for (ConceptName cn : localeConceptNamesMap.get(conceptNameLocale)) {
						if (cn.isFullySpecifiedName()) {
							cn.setLocalePreferred(true);
							preferredNameForLocaleFound = true;
							break;
						}
					}
					if (!preferredNameForLocaleFound) {
						for (ConceptName cn : localeConceptNamesMap.get(conceptNameLocale)) {
							if (cn.isSynonym()) {
								cn.setLocalePreferred(true);
								break;
							}
						}
					}
				}
			}
			if (!hasFullySpecifiedName) {
				hasFullySpecifiedName = setFullySpecifiedName(conceptId, localeConceptNamesMap);
			}
			if (!CollectionUtils.isEmpty(namesWithNoLocale)) {
				for (ConceptName conceptName : namesWithNoLocale) {
					conceptName.setLocale(defaultLocale);
					reportUpdatedName(conceptName, "The locale for ConceptName with id " + conceptName.getConceptNameId()
					        + " (" + conceptName.getName() + ") has been set to '" + defaultLocale.getDisplayName() + "'");
					if (!hasFullySpecifiedName) {
						conceptName.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
						hasFullySpecifiedName = true;
						reportUpdatedName(conceptName, "ConceptName with id " + conceptName.getConceptNameId() + " ("
						        + conceptName.getName() + ") in locale '" + defaultLocale.getDisplayName()
						        + "' has been set as the fully specified name for concept with id : " + conceptId);
					}
					else {
						conceptName.setLocalePreferred(false);
						reportUpdatedName(conceptName, "ConceptName with id " + conceptName.getConceptNameId() + " ("
						        + conceptName.getName() + ") is no longer marked as preferred because it had no locale");
						if (conceptName.isFullySpecifiedName() || conceptName.isShort()) {
							conceptName.setConceptNameType(null);
							reportUpdatedName(conceptName, "The name '" + conceptName.getName() + "' in locale '"
							        + conceptName.toString() + "' has been converted to a synonym because it had no locale");
						}
					}
				}
			}
			if (!hasFullySpecifiedName) {
				updateWarnings.add("Concept with id: " + conceptId + " has no fully specified name");
			}
		}
		if (!MapUtils.isEmpty(localeDuplicateNamesMap)) {
			for (Map.Entry<Locale, Set<String>> entry : localeDuplicateNamesMap.entrySet()) {
				if (CollectionUtils.isEmpty(entry.getValue())) {
					continue;
				}
				for (String duplicateName : entry.getValue()) {
					updateWarnings.add("Concept Name '" + duplicateName + "' was found multiple times in locale '"
					        + entry.getKey() + "'");
				}
			}
		}
		logMessages.add("Number of Updated ConceptNames: " + updatedConceptNames.size());
	}
	private void writeWarningsToFile() {
		String lineSeparator = System.getProperty("line.separator");
		StringBuilder sb = new StringBuilder("WARNINGS:").append(lineSeparator);
		for (String warning : updateWarnings) {
			sb.append(lineSeparator).append(warning);
		}
		sb.append(lineSeparator).append(lineSeparator).append("NOTIFICATIONS:").append(lineSeparator);
		for (String message : logMessages) {
			sb.append(lineSeparator).append(message);
		}
		DatabaseUpdater.writeUpdateMessagesToFile(sb.toString());
	}
	private boolean setFullySpecifiedName(int conceptId, Map<Locale, List<ConceptName>> localeConceptNamesMap) {
		for (Locale allowedLoc : allowedLocales) {
			List<ConceptName> possibleFullySpecNames = localeConceptNamesMap.get(allowedLoc);
			if (CollectionUtils.isEmpty(possibleFullySpecNames)) {
				continue;
			}
			for (ConceptName cn : possibleFullySpecNames) {
				if (cn.isSynonym()) {
					cn.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
					reportUpdatedName(cn, "ConceptName with id " + cn.getConceptNameId() + " (" + cn.getName()
					        + ") in locale '" + allowedLoc.getDisplayName()
					        + "' has been set as the fully specified name for concept with id : " + conceptId);
					return true;
				}
			}
			for (ConceptName cn : possibleFullySpecNames) {
				if (cn.isShort()) {
					cn.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
					reportUpdatedName(cn, "ConceptName with id " + cn.getConceptNameId() + " (" + cn.getName()
					        + ") in locale '" + allowedLoc.getDisplayName()
					        + "' has been changed from short to fully specified name for concept with id : " + conceptId);
					return true;
				}
			}
		}
		for (Map.Entry<Locale, List<ConceptName>> entry : localeConceptNamesMap.entrySet()) {
			Locale locale = entry.getKey();
			if (locale != null) {
				ConceptName fullySpecName = entry.getValue().get(0);
				fullySpecName.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
				reportUpdatedName(fullySpecName, "ConceptName with id " + fullySpecName.getConceptNameId() + " ("
				        + fullySpecName.getName() + ") in locale '" + locale.getDisplayName()
				        + "' has been set as the fully specified name for concept with id : " + conceptId);
				return true;
			}
		}
		return false;
	}
	private void reportUpdatedName(ConceptName updatedName, String updateMessage) {
		updatedConceptNames.add(updatedName);
		logMessages.add(updateMessage);
	}
	private List<Integer> getAllUnretiredConceptIds(JdbcConnection connection) {
		LinkedList<Integer> conceptIds = null;
		Statement stmt = null;
		try {
			stmt = connection.createStatement();
			ResultSet rs = stmt.executeQuery("SELECT concept_id FROM concept WHERE retired = '0'");
			while (rs.next()) {
				if (conceptIds == null) {
					conceptIds = new LinkedList<>();
				}
				conceptIds.add(rs.getInt("concept_id"));
			}
		}
		catch (DatabaseException | SQLException e) {
			log.warn("Error generated", e);
		}
		finally {
			if (stmt != null) {
				try {
					stmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the statement object");
				}
			}
		}
		return conceptIds;
	}
	private boolean isNameUniqueInLocale(JdbcConnection connection, ConceptName conceptName, int conceptId) {
		int duplicates = getInt(connection,
		    "SELECT count(*) FROM concept_name cn, concept c WHERE cn.concept_id = c.concept_id  AND (cn.concept_name_type = '"
		            + ConceptNameType.FULLY_SPECIFIED
		            + "' OR cn.locale_preferred = '1') AND cn.voided = '0' AND cn.name = '"
		            + HibernateUtil.escapeSqlWildcards(conceptName.getName(), connection.getUnderlyingConnection())
		            + "' AND cn.locale = '"
		            + HibernateUtil.escapeSqlWildcards(conceptName.getLocale().toString(), connection
		                    .getUnderlyingConnection()) + "' AND c.retired = '0' AND c.concept_id != " + conceptId);
		return duplicates == 0;
	}
	@SuppressWarnings("unchecked")
	private List<Locale> getAllowedLocalesList(JdbcConnection connection) {
		Statement stmt = null;
		ListOrderedSet allowedLocales = new ListOrderedSet();
		try {
			stmt = connection.createStatement();
			ResultSet rsDefaultLocale = stmt.executeQuery("SELECT property_value FROM global_property WHERE property = '"
			        + OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_LOCALE + "'");
			if (rsDefaultLocale.next()) {
				String defaultLocaleStr = rsDefaultLocale.getString("property_value");
				if (!StringUtils.isBlank(defaultLocaleStr) && defaultLocaleStr.length() > 1) {
					Locale defaultLocaleGP = LocaleUtility.fromSpecification(defaultLocaleStr);
					if (defaultLocaleGP != null) {
						defaultLocale = defaultLocaleGP;
					}
				} else {
					updateWarnings.add("'" + defaultLocaleStr
					        + "' is an invalid value for the global property default locale");
				}
			}
			allowedLocales.add(defaultLocale);
			ResultSet rsAllowedLocales = stmt.executeQuery("SELECT property_value FROM global_property WHERE property = '"
			        + OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST + "'");
			if (rsAllowedLocales.next()) {
				String allowedLocaleStr = rsAllowedLocales.getString("property_value");
				if (!StringUtils.isBlank(allowedLocaleStr)) {
					String[] localesArray = allowedLocaleStr.split(",");
					for (String localeStr : localesArray) {
						if (localeStr.trim().length() > 1) {
							allowedLocales.add(LocaleUtility.fromSpecification(localeStr.trim()));
						} else {
							updateWarnings.add("'" + localeStr
							        + "' is an invalid value for the global property locale.allowed.list");
						}
					}
				}
			} else {
				log.warn("The global property '" + OpenmrsConstants.GLOBAL_PROPERTY_LOCALE_ALLOWED_LIST + "' isn't set");
			}
		}
		catch (DatabaseException | SQLException e) {
			log.warn("Error generated", e);
		}
		finally {
			if (stmt != null) {
				try {
					stmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the statement object");
				}
			}
		}
		allowedLocales.add(new Locale("en"));
		return allowedLocales.asList();
	}
	private Map<Locale, List<ConceptName>> getLocaleConceptNamesMap(JdbcConnection connection, int conceptId) {
		PreparedStatement pStmt = null;
		Map<Locale, List<ConceptName>> localeConceptNamesMap = null;
		try {
			pStmt = connection
			        .prepareStatement("SELECT concept_name_id, name, concept_name_type, locale, locale_preferred FROM concept_name WHERE voided = '0' AND concept_id = ?");
			pStmt.setInt(1, conceptId);
			ResultSet rs = pStmt.executeQuery();
			while (rs.next()) {
				if (localeConceptNamesMap == null) {
					localeConceptNamesMap = new HashMap<>();
				}
				ConceptName conceptName = new ConceptName();
				conceptName.setConceptNameId(rs.getInt("concept_name_id"));
				conceptName.setName(rs.getString("name"));
				String cnType = rs.getString("concept_name_type");
				if (!StringUtils.isBlank(cnType)) {
					ConceptNameType conceptNameType = null;
					if (cnType.equals(ConceptNameType.FULLY_SPECIFIED.toString())) {
						conceptNameType = ConceptNameType.FULLY_SPECIFIED;
					} else if (cnType.equals(ConceptNameType.SHORT.toString())) {
						conceptNameType = ConceptNameType.SHORT;
					} else if (cnType.equals(ConceptNameType.INDEX_TERM.toString())) {
						conceptNameType = ConceptNameType.INDEX_TERM;
					}
					conceptName.setConceptNameType(conceptNameType);
				}
				String localeString = rs.getString("locale");
				conceptName.setLocale(!StringUtils.isBlank(localeString) ? LocaleUtility.fromSpecification(localeString)
				        : null);
				conceptName.setLocalePreferred(rs.getBoolean("locale_preferred"));
				conceptName.setVoided(false);
				if (!localeConceptNamesMap.containsKey(conceptName.getLocale())) {
					localeConceptNamesMap.put(conceptName.getLocale(), new LinkedList<>());
				}
				localeConceptNamesMap.get(conceptName.getLocale()).add(conceptName);
			}
		}
		catch (DatabaseException | SQLException e) {
			log.warn("Error generated", e);
		}
		finally {
			if (pStmt != null) {
				try {
					pStmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the prepared statement object");
				}
			}
		}
		return localeConceptNamesMap;
	}
	private void runBatchUpdate(JdbcConnection connection) {
		PreparedStatement pStmt = null;
		try {
			connection.setAutoCommit(false);
			pStmt = connection
			        .prepareStatement("UPDATE concept_name SET locale = ?, concept_name_type = ?, locale_preferred = ?, voided = ?, date_voided = ?, void_reason = ?, voided_by = ? WHERE concept_name_id = ?");
			Integer userId = DatabaseUpdater.getAuthenticatedUserId();
			if (userId == null || userId < 1) {
				userId = getInt(connection, "SELECT min(user_id) FROM users");
				if (userId < 1) {
					userId = null;
				}
			}
			for (ConceptName conceptName : updatedConceptNames) {
				pStmt.setString(1, conceptName.getLocale().toString());
				pStmt.setString(2, (conceptName.getConceptNameType() != null) ? conceptName.getConceptNameType().toString()
				        : null);
				pStmt.setBoolean(3, conceptName.getLocalePreferred());
				pStmt.setBoolean(4, conceptName.getVoided());
				pStmt.setDate(5, conceptName.getVoided() ? new Date(System.currentTimeMillis()) : null);
				pStmt.setString(6, conceptName.getVoidReason());
				pStmt.setObject(7, (conceptName.getVoided() && userId != null) ? userId : null, Types.INTEGER);
				pStmt.setInt(8, conceptName.getConceptNameId());
				pStmt.addBatch();
			}
			try {
				int[] updateCounts = pStmt.executeBatch();
				for (int updateCount : updateCounts) {
					if (updateCount > -1) {
						log.debug("Successfully executed: updateCount=" + updateCount);
					} else if (updateCount == Statement.SUCCESS_NO_INFO) {
						log.debug("Successfully executed; No Success info");
					} else if (updateCount == Statement.EXECUTE_FAILED) {
						log.warn("Failed to execute update");
					}
				}
				log.debug("Committing updates...");
				connection.commit();
			}
			catch (BatchUpdateException be) {
				log.warn("Error generated while processsing batch update", be);
				int[] updateCounts = be.getUpdateCounts();
				for (int updateCount : updateCounts) {
					if (updateCount > -1) {
						log.warn("Executed with exception: updateCount=" + updateCount);
					} else if (updateCount == Statement.SUCCESS_NO_INFO) {
						log.warn("Executed with exception; No Success info");
					} else if (updateCount == Statement.EXECUTE_FAILED) {
						log.warn("Failed to execute update with exception");
					}
				}
				try {
					log.warn("Rolling back batch", be);
					connection.rollback();
				}
				catch (Exception rbe) {
					log.warn("Error generated while rolling back batch update", be);
				}
			}
		}
		catch (SQLException | DatabaseException e) {
			log.warn("Error generated", e);
		}
		finally {
			try {
				connection.setAutoCommit(true);
			}
			catch (DatabaseException e) {
				log.warn("Failed to reset auto commit back to true", e);
			}
			if (pStmt != null) {
				try {
					pStmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the prepared statement object");
				}
			}
		}
	}
	private int getInt(JdbcConnection connection, String sql) {
		Statement stmt = null;
		int result = 0;
		try {
			stmt = connection.createStatement();
			ResultSet rs = stmt.executeQuery(sql);
			if (rs.next()) {
				result = rs.getInt(1);
			} else {
				log.warn("No row returned by getInt() method");
			}
			if (rs.next()) {
				log.warn("Multiple rows returned by getInt() method");
			}
			return result;
		}
		catch (DatabaseException | SQLException e) {
			log.warn("Error generated", e);
		}
		finally {
			if (stmt != null) {
				try {
					stmt.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the statement object");
				}
			}
		}
		return result;
	}
	@Override
	public String getConfirmationMessage() {
		return "Finished validating concepts";
	}
	@Override
	public void setFileOpener(ResourceAccessor fileOpener) {
	}
	@Override
	public void setUp() throws SetupException {
	}
	@Override
	public ValidationErrors validate(Database database) {
		return new ValidationErrors();
	}
}
package org.openmrs.web;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import org.openmrs.module.Module;
import org.openmrs.module.ModuleFactory;
import org.openmrs.module.web.WebModuleUtil;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.web.filter.initialization.InitializationFilter;
import org.openmrs.web.filter.update.UpdateFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.web.context.support.XmlWebApplicationContext;
public class DispatcherServlet extends org.springframework.web.servlet.DispatcherServlet {
	private static final long serialVersionUID = -6925172744402818729L;
	private static final Logger log = LoggerFactory.getLogger(DispatcherServlet.class);
	@Override
	protected void initFrameworkServlet() throws ServletException, BeansException {
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		log.debug("Framework being initialized");
		WebModuleUtil.setDispatcherServlet(this);
		super.initFrameworkServlet();
	}
	public void reInitFrameworkServlet() throws ServletException {
		log.debug("Framework being REinitialized");
		Thread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());
		((XmlWebApplicationContext) getWebApplicationContext()).setClassLoader(OpenmrsClassLoader.getInstance());
		init();
		for (Module module : ModuleFactory.getStartedModules()) {
			ModuleFactory.loadAdvice(module);
		}
	}
	@Override
	public void init(ServletConfig config) throws ServletException {
		super.init(config);
		if (UpdateFilter.updatesRequired() && !DatabaseUpdater.allowAutoUpdate()) {
			log.info("DB updates are required, the update wizard must be run");
		}
		if (InitializationFilter.initializationRequired()) {
			log.info("Runtime properties were not found or the database is empty, so initialization is required");
		}
	}
	public void stopAndCloseApplicationContext() {
		try {
			XmlWebApplicationContext ctx = (XmlWebApplicationContext) getWebApplicationContext();
			ctx.stop();
			ctx.close();
		}
		catch (Exception e) {
			log.error("Exception while stopping and closing dispatcherServlet context: ", e);
		}
	}
}
package org.openmrs.util.databasechange;
import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.DatabaseUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import liquibase.change.custom.CustomTaskChange;
import liquibase.database.Database;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.CustomChangeException;
import liquibase.exception.DatabaseException;
import liquibase.exception.SetupException;
import liquibase.exception.ValidationErrors;
import liquibase.resource.ResourceAccessor;
public class DuplicateLocationAttributeTypeNameChangeSet implements CustomTaskChange {
	private static final Logger log = LoggerFactory.getLogger(DuplicateLocationAttributeTypeNameChangeSet.class);
	@Override
	public String getConfirmationMessage() {
		return "Completed updating duplicate LocationAttributeType names";
	}
	@Override
	public void setFileOpener(ResourceAccessor arg0) {
	}
	@Override
	public void setUp() throws SetupException {
	}
	@Override
	public ValidationErrors validate(Database arg0) {
		return null;
	}
	@Override
	public void execute(Database database) throws CustomChangeException {
		JdbcConnection connection = (JdbcConnection) database.getConnection();
		Map<String, HashSet<Integer>> duplicates = new HashMap<>();
		Statement stmt = null;
		PreparedStatement pStmt = null;
		ResultSet rs = null;
		boolean autoCommit = true;
		try {
			autoCommit = connection.getAutoCommit();
			connection.setAutoCommit(false);
			stmt = connection.createStatement();
			rs = stmt.executeQuery("SELECT * FROM location_attribute_type "
			        + "INNER JOIN (SELECT name FROM location_attribute_type GROUP BY name HAVING count(name) > 1) "
			        + "dup ON location_attribute_type.name = dup.name");
			Integer id;
			String name;
			while (rs.next()) {
				id = rs.getInt("location_attribute_type_id");
				name = rs.getString("name");
				if (duplicates.get(name) == null) {
					HashSet<Integer> results = new HashSet<>();
					results.add(id);
					duplicates.put(name, results);
				} else {
					HashSet<Integer> results = duplicates.get(name);
					results.add(id);
				}
			}
			for (Object o : duplicates.entrySet()) {
				Map.Entry pairs = (Map.Entry) o;
				HashSet<Integer> values = (HashSet<Integer>) pairs.getValue();
				List<Integer> duplicateNames = new ArrayList<Integer>(values);
				int duplicateNameId = 1;
				for (int i = 1; i < duplicateNames.size(); i++) {
					String newName = pairs.getKey() + "_" + duplicateNameId;
					List<List<Object>> duplicateResult;
					boolean duplicateName;
					Connection con = DatabaseUpdater.getConnection();
					do {
						String sqlValidatorString = "select * from location_attribute_type where name = '" + newName + "'";
						duplicateResult = DatabaseUtil.executeSQL(con, sqlValidatorString, true);
						if (!duplicateResult.isEmpty()) {
							duplicateNameId += 1;
							newName = pairs.getKey() + "_" + duplicateNameId;
							duplicateName = true;
						} else {
							duplicateName = false;
						}
					} while (duplicateName);
					pStmt = connection
							.prepareStatement(
									"update location_attribute_type set name = ?, changed_by = ?, date_changed = ? where location_attribute_type_id = ?");
					if (!duplicateResult.isEmpty()) {
						pStmt.setString(1, newName);
					}
					pStmt.setString(1, newName);
					pStmt.setInt(2, DatabaseUpdater.getAuthenticatedUserId());
					Calendar cal = Calendar.getInstance();
					Date date = new Date(cal.getTimeInMillis());
					pStmt.setDate(3, date);
					pStmt.setInt(4, duplicateNames.get(i));
					duplicateNameId += 1;
					pStmt.executeUpdate();
				}
			}
		}
		catch (BatchUpdateException e) {
			log.warn("Error generated while processsing batch insert", e);
			try {
				log.debug("Rolling back batch", e);
				connection.rollback();
			}
			catch (Exception rbe) {
				log.warn("Error generated while rolling back batch insert", e);
			}
			throw new CustomChangeException("Failed to update one or more duplicate LocationAttributeType names", e);
		}
		catch (Exception e) {
			throw new CustomChangeException("Error while updating duplicate LocationAttributeType object names", e);
		}
		finally {
			try {
				connection.commit();
				connection.setAutoCommit(autoCommit);
			}
			catch (DatabaseException e) {
				log.warn("Failed to reset auto commit back to true", e);
			}
			if (rs != null) {
				try {
					rs.close();
				}
				catch (SQLException e) {
					log.warn("Failed to close the resultset object");
				}
			}
			if (stmt != null) {
				try {
					stmt.close();
				}
				catch (SQLException e) {
					log
					        .warn("Failed to close the select statement used to identify duplicate LocationAttributeType object names");
				}
			}
			if (pStmt != null) {
				try {
					pStmt.close();
				}
				catch (SQLException e) {
					log
					        .warn("Failed to close the prepared statement used to update duplicate LocationAttributeType object names");
				}
			}
		}
	}
}
package org.openmrs.util.databasechange;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.List;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.DatabaseUtil;
import liquibase.change.custom.CustomTaskChange;
import liquibase.database.Database;
import liquibase.database.jvm.JdbcConnection;
import liquibase.exception.CustomChangeException;
import liquibase.exception.SetupException;
import liquibase.exception.ValidationErrors;
import liquibase.resource.ResourceAccessor;
public class ProgramValidatorChangeSet implements CustomTaskChange {
	@Override
	public void execute(Database database) throws CustomChangeException {
		Connection conn = ((JdbcConnection) database.getConnection()).getUnderlyingConnection();
		List<String> messages = new ArrayList<>();
		StringBuilder message = new StringBuilder();
		message.append("Starting now, when you transition a patient into a state that is configured as terminal, ");
		message.append("then that whole program enrollment will be marked as completed.<br/>");
		message.append("Please check that programs, workflows, and states are configured.<br/>");
		message.append("This check will highlight two things: ");
		message.append("<ul><li>states that are marked as both initial and terminal ");
		message.append("(if you start someone in that state their program enrollment will be instantly closed)</li>");
		message.append("<li>workflows that have no initial states (because you don't have a state to start people in)</li>");
		message.append("</ul><br/>");
		message.append("The following states are configured as both initial and terminal:<br/>");
		StringBuilder query = new StringBuilder();
		query.append(" select 	s.concept_id, min(n.name) as name ");
		query.append(" from 	program_workflow_state s, concept_name n ");
		query.append(" where 	s.concept_id = n.concept_id and initial = '1' and terminal = '1' ");
		query.append(" group by s.concept_id ");
		List<List<Object>> results = DatabaseUtil.executeSQL(conn, query.toString(), true);
		if (results.isEmpty()) {
			message.append("None found.");
		} else {
			for (List<Object> row : results) {
				message.append(row.get(1).toString()).append("<br/>");
			}
		}
		message.append("<br/>The following workflows have no initial states...<br/>");
		query = new StringBuilder();
		query.append(" select 		w.concept_id, s.initial, count(*) as num ");
		query.append(" from			program_workflow w, program_workflow_state s ");
		query.append(" where		w.program_workflow_id = s.program_workflow_id ");
		query.append(" group by 	w.concept_id, s.initial ");
		results = DatabaseUtil.executeSQL(conn, query.toString(), true);
		List<Integer> missingInitial = new ArrayList<>();
		for (List<Object> row : results) {
			missingInitial.add(Integer.valueOf(row.get(0).toString()));
		}
		for (List<Object> row : results) {
			Integer conceptId = Integer.valueOf(row.get(0).toString());
			boolean isInitial = "1".equals(row.get(1).toString());
			int num = Integer.parseInt(row.get(2).toString());
			if (isInitial && num > 0) {
				missingInitial.remove(conceptId);
			}
		}
		if (missingInitial.isEmpty()) {
			message.append("None found.");
		} else {
			for (Integer conceptId : missingInitial) {
				String sql = "select min(name) from concept_name where concept_id = " + conceptId;
				String name = DatabaseUtil.executeSQL(conn, sql, true).get(0).get(0).toString();
				message.append(name).append("<br/>");
			}
		}
		messages.add(message.toString());
		DatabaseUpdater.reportUpdateWarnings(messages);
	}
	@Override
	public String getConfirmationMessage() {
		return "Finished validating programs";
	}
	@Override
	public void setFileOpener(ResourceAccessor fo) {
	}
	@Override
	public void setUp() throws SetupException {
	}
	@Override
	public ValidationErrors validate(Database db) {
		return new ValidationErrors();
	}
}