package brut.androlib;
import brut.androlib.exceptions.AndrolibException;
import brut.common.BrutException;
import brut.util.AaptManager;
import brut.util.OSDetection;
import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.logging.Logger;
public final class Config {
    private static final Logger LOGGER = Logger.getLogger(Config.class.getName());
    public static final short DECODE_SOURCES_NONE = 0x0000;
    public static final short DECODE_SOURCES_SMALI = 0x0001;
    public static final short DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES = 0x0010;
    public static final short DECODE_RESOURCES_NONE = 0x0100;
    public static final short DECODE_RESOURCES_FULL = 0x0101;
    public static final short FORCE_DECODE_MANIFEST_NONE = 0x0000;
    public static final short FORCE_DECODE_MANIFEST_FULL = 0x0001;
    public static final short DECODE_ASSETS_NONE = 0x0000;
    public static final short DECODE_ASSETS_FULL = 0x0001;
    public static final short DECODE_RES_RESOLVE_REMOVE = 0x0000;
    public static final short DECODE_RES_RESOLVE_DUMMY = 0x0001;
    public static final short DECODE_RES_RESOLVE_RETAIN = 0x0002;
    private static final String DEFAULT_FRAMEWORK_DIRECTORY;
    static {
        File parent = new File(System.getProperty("user.home"));
        Path path;
        if (OSDetection.isMacOSX()) {
            path = Paths.get(parent.getAbsolutePath(), "Library", "apktool", "framework");
        } else if (OSDetection.isWindows()) {
            path = Paths.get(parent.getAbsolutePath(), "AppData", "Local", "apktool", "framework");
        } else {
            String xdgDataFolder = System.getenv("XDG_DATA_HOME");
            if (xdgDataFolder != null) {
                path = Paths.get(xdgDataFolder, "apktool", "framework");
            } else {
                path = Paths.get(parent.getAbsolutePath(), ".local", "share", "apktool", "framework");
            }
        }
        DEFAULT_FRAMEWORK_DIRECTORY = path.toString();
    }
    private boolean mForceBuildAll;
    private boolean mForceDeleteFramework;
    private boolean mDebugMode;
    private boolean mNetSecConf;
    private boolean mVerbose;
    private boolean mCopyOriginalFiles;
    private boolean mUpdateFiles;
    private boolean mNoCrunch;
    private boolean mNoApk;
    private short mDecodeSources;
    private short mDecodeResources;
    private short mForceDecodeManifest;
    private short mDecodeAssets;
    private short mDecodeResolveMode;
    private int mApiLevel;
    private boolean mAnalysisMode;
    private boolean mForceDelete;
    private boolean mKeepBrokenResources;
    private boolean mBaksmaliDebugMode;
    private int mJobs;
    private String mFrameworkDirectory;
    private String mFrameworkTag;
    private File mAaptBinary;
    private int mAaptVersion;
    public Config() {
        mForceBuildAll = false;
        mForceDeleteFramework = false;
        mDebugMode = false;
        mNetSecConf = false;
        mVerbose = false;
        mCopyOriginalFiles = false;
        mUpdateFiles = false;
        mNoCrunch = false;
        mNoApk = false;
        mDecodeSources = DECODE_SOURCES_SMALI;
        mDecodeResources = DECODE_RESOURCES_FULL;
        mForceDecodeManifest = FORCE_DECODE_MANIFEST_NONE;
        mDecodeAssets = DECODE_ASSETS_FULL;
        mDecodeResolveMode = DECODE_RES_RESOLVE_REMOVE;
        mApiLevel = 0;
        mAnalysisMode = false;
        mForceDelete = false;
        mKeepBrokenResources = false;
        mBaksmaliDebugMode = true;
        mJobs = Math.min(Runtime.getRuntime().availableProcessors(), 8);
        mFrameworkDirectory = DEFAULT_FRAMEWORK_DIRECTORY;
        mFrameworkTag = null;
        mAaptBinary = null;
        mAaptVersion = 2;
    }
    public boolean isForceBuildAll() {
        return mForceBuildAll;
    }
    public void setForceBuildAll(boolean forceBuildAll) {
        mForceBuildAll = forceBuildAll;
    }
    public boolean isForceDeleteFramework() {
        return mForceDeleteFramework;
    }
    public void setForceDeleteFramework(boolean forceDeleteFramework) {
        mForceDeleteFramework = forceDeleteFramework;
    }
    public boolean isDebugMode() {
        return mDebugMode;
    }
    public void setDebugMode(boolean debugMode) {
        mDebugMode = debugMode;
    }
    public boolean isNetSecConf() {
        return mNetSecConf;
    }
    public void setNetSecConf(boolean netSecConf) {
        mNetSecConf = netSecConf;
    }
    public boolean isVerbose() {
        return mVerbose;
    }
    public void setVerbose(boolean verbose) {
        mVerbose = verbose;
    }
    public boolean isCopyOriginalFiles() {
        return mCopyOriginalFiles;
    }
    public void setCopyOriginalFiles(boolean copyOriginalFiles) {
        mCopyOriginalFiles = copyOriginalFiles;
    }
    public boolean isUpdateFiles() {
        return mUpdateFiles;
    }
    public void setUpdateFiles(boolean updateFiles) {
        mUpdateFiles = updateFiles;
    }
    public boolean isNoCrunch() {
        return mNoCrunch;
    }
    public void setNoCrunch(boolean noCrunch) {
        mNoCrunch = noCrunch;
    }
    public boolean isNoApk() {
        return mNoApk;
    }
    public void setNoApk(boolean noApk) {
        mNoApk = noApk;
    }
    public short getDecodeSources() {
        return mDecodeSources;
    }
    public void setDecodeSources(short decodeSources) throws AndrolibException {
        switch (decodeSources) {
            case DECODE_SOURCES_NONE:
            case DECODE_SOURCES_SMALI:
            case DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES:
                mDecodeSources = decodeSources;
                break;
            default:
                throw new AndrolibException("Invalid decode sources mode: " + decodeSources);
        }
    }
    public short getDecodeResources() {
        return mDecodeResources;
    }
    public void setDecodeResources(short decodeResources) throws AndrolibException {
        switch (decodeResources) {
            case DECODE_RESOURCES_NONE:
            case DECODE_RESOURCES_FULL:
                mDecodeResources = decodeResources;
                break;
            default:
                throw new AndrolibException("Invalid decode resources mode: " + decodeResources);
        }
    }
    public short getForceDecodeManifest() {
        return mForceDecodeManifest;
    }
    public void setForceDecodeManifest(short forceDecodeManifest) throws AndrolibException {
        switch (forceDecodeManifest) {
            case FORCE_DECODE_MANIFEST_NONE:
            case FORCE_DECODE_MANIFEST_FULL:
                mForceDecodeManifest = forceDecodeManifest;
                break;
            default:
                throw new AndrolibException("Invalid force decode manifest mode: " + forceDecodeManifest);
        }
    }
    public short getDecodeAssets() {
        return mDecodeAssets;
    }
    public void setDecodeAssets(short decodeAssets) throws AndrolibException {
        switch (decodeAssets) {
            case DECODE_ASSETS_NONE:
            case DECODE_ASSETS_FULL:
                mDecodeAssets = decodeAssets;
                break;
            default:
                throw new AndrolibException("Invalid decode asset mode: " + decodeAssets);
        }
    }
    public short getDecodeResolveMode() {
        return mDecodeResolveMode;
    }
    public void setDecodeResolveMode(short decodeResolveMode) throws AndrolibException {
        switch (decodeResolveMode) {
            case DECODE_RES_RESOLVE_REMOVE:
            case DECODE_RES_RESOLVE_DUMMY:
            case DECODE_RES_RESOLVE_RETAIN:
                mDecodeResolveMode = decodeResolveMode;
                break;
            default:
                throw new AndrolibException("Invalid decode resolve mode: " + decodeResolveMode);
        }
    }
    public int getApiLevel() {
        return mApiLevel;
    }
    public void setApiLevel(int apiLevel) {
        mApiLevel = apiLevel;
    }
    public boolean isAnalysisMode() {
        return mAnalysisMode;
    }
    public void setAnalysisMode(boolean analysisMode) {
        mAnalysisMode = analysisMode;
    }
    public boolean isForceDelete() {
        return mForceDelete;
    }
    public void setForceDelete(boolean forceDelete) {
        mForceDelete = forceDelete;
    }
    public boolean isKeepBrokenResources() {
        return mKeepBrokenResources;
    }
    public void setKeepBrokenResources(boolean keepBrokenResources) {
        mKeepBrokenResources = keepBrokenResources;
    }
    public boolean isBaksmaliDebugMode() {
        return mBaksmaliDebugMode;
    }
    public void setBaksmaliDebugMode(boolean baksmaliDebugMode) {
        mBaksmaliDebugMode = baksmaliDebugMode;
    }
    public int getJobs() {
        return mJobs;
    }
    public void setJobs(int jobs) {
        mJobs = jobs;
    }
    public String getFrameworkDirectory() {
        return mFrameworkDirectory;
    }
    public void setFrameworkDirectory(String frameworkDirectory) {
        mFrameworkDirectory = frameworkDirectory != null
            ? frameworkDirectory : DEFAULT_FRAMEWORK_DIRECTORY;
    }
    public String getFrameworkTag() {
        return mFrameworkTag;
    }
    public void setFrameworkTag(String frameworkTag) {
        mFrameworkTag = frameworkTag;
    }
    public File getAaptBinary() {
        return mAaptBinary;
    }
    public void setAaptBinary(File aaptBinary) throws AndrolibException {
        try {
            mAaptBinary = aaptBinary;
            mAaptVersion = AaptManager.getAaptVersion(aaptBinary);
        } catch (BrutException ex) {
            throw new AndrolibException(ex);
        }
    }
    public int getAaptVersion() {
        return mAaptVersion;
    }
    public void setAaptVersion(int aaptVersion) {
        mAaptVersion = aaptVersion;
    }
}
package brut.androlib.exceptions;
import brut.common.BrutException;
public class AndrolibException extends BrutException {
    public AndrolibException() {
        super();
    }
    public AndrolibException(String message) {
        super(message);
    }
    public AndrolibException(Throwable cause) {
        super(cause);
    }
    public AndrolibException(String message, Throwable cause) {
        super(message, cause);
    }
}
package brut.androlib.res.decoder;
import android.util.TypedValue;
import brut.androlib.Config;
import brut.androlib.apk.ApkInfo;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.*;
import brut.androlib.res.data.arsc.*;
import brut.androlib.res.data.value.*;
import brut.util.ExtDataInputStream;
import org.apache.commons.lang3.tuple.Pair;
import java.io.*;
import java.math.BigInteger;
import java.util.*;
import java.util.logging.Logger;
public class ARSCDecoder {
    private static final Logger LOGGER = Logger.getLogger(ARSCDecoder.class.getName());
    private static final short ENTRY_FLAG_COMPLEX = 0x0001;
    private static final short ENTRY_FLAG_PUBLIC = 0x0002;
    private static final short ENTRY_FLAG_WEAK = 0x0004;
    private static final short ENTRY_FLAG_COMPACT = 0x0008;
    private static final short TABLE_TYPE_FLAG_SPARSE = 0x01;
    private static final short TABLE_TYPE_FLAG_OFFSET16 = 0x02;
    private static final int KNOWN_CONFIG_BYTES = 64;
    private static final int NO_ENTRY = 0xFFFFFFFF;
    private static final int NO_ENTRY_OFFSET16 = 0xFFFF;
    private final ExtDataInputStream mIn;
    private final ResTable mResTable;
    private final List<FlagsOffset> mFlagsOffsets;
    private final boolean mKeepBroken;
    private final Config mConfig;
    private final HashMap<Integer, Integer> mMissingResSpecMap;
    private final HashMap<Integer, ResTypeSpec> mResTypeSpecs;
    private ARSCHeader mHeader;
    private StringBlock mTableStrings;
    private StringBlock mTypeNames;
    private StringBlock mSpecNames;
    private ResPackage mPkg;
    private ResTypeSpec mTypeSpec;
    private ResType mType;
    private int mResId;
    private int mTypeIdOffset;
    public ARSCDecoder(InputStream in, ResTable resTable, boolean storeFlagsOffsets, boolean keepBroken) {
        mIn = ExtDataInputStream.littleEndian(in);
        mResTable = resTable;
        mFlagsOffsets = storeFlagsOffsets ? new ArrayList<>() : null;
        mKeepBroken = keepBroken;
        mConfig = resTable.getConfig();
        mMissingResSpecMap = new LinkedHashMap<>();
        mResTypeSpecs = new HashMap<>();
    }
    public ARSCData decode() throws AndrolibException {
        try {
            ResPackage[] pkgs = readResourceTable();
            FlagsOffset[] flagsOffsets = mFlagsOffsets != null ? mFlagsOffsets.toArray(new FlagsOffset[0]) : null;
            return new ARSCData(pkgs, flagsOffsets);
        } catch (IOException ex) {
            throw new AndrolibException("Could not decode arsc file", ex);
        }
    }
    private ResPackage[] readResourceTable() throws AndrolibException, IOException {
        Set<ResPackage> pkgs = new LinkedHashSet<>();
        ResTypeSpec typeSpec;
        int chunkNumber = 1;
        chunkLoop:
        for (;;) {
            nextChunk();
            LOGGER.fine(String.format(
                "Chunk #%d start=0x%08x type=0x%04x chunkSize=0x%08x",
                chunkNumber++, mIn.position(), mHeader.type, mHeader.chunkSize
            ));
            switch (mHeader.type) {
                case ARSCHeader.RES_NULL_TYPE:
                    readUnknownChunk();
                    break;
                case ARSCHeader.RES_STRING_POOL_TYPE:
                    readStringPoolChunk();
                    break;
                case ARSCHeader.RES_TABLE_TYPE:
                    readTableChunk();
                    break;
                case ARSCHeader.XML_TYPE_PACKAGE:
                    mTypeIdOffset = 0;
                    pkgs.add(readTablePackage());
                    break;
                case ARSCHeader.XML_TYPE_TYPE:
                    readTableType();
                    break;
                case ARSCHeader.XML_TYPE_SPEC_TYPE:
                    typeSpec = readTableSpecType();
                    addTypeSpec(typeSpec);
                    break;
                case ARSCHeader.XML_TYPE_LIBRARY:
                    readLibraryType();
                    break;
                case ARSCHeader.XML_TYPE_OVERLAY:
                    readOverlaySpec();
                    break;
                case ARSCHeader.XML_TYPE_OVERLAY_POLICY:
                    readOverlayPolicySpec();
                    break;
                case ARSCHeader.XML_TYPE_STAGED_ALIAS:
                    readStagedAliasSpec();
                    break;
                default:
                    if (mHeader.type != ARSCHeader.RES_NONE_TYPE) {
                        LOGGER.severe(String.format("Unknown chunk type: %04x", mHeader.type));
                    }
                    break chunkLoop;
            }
        }
        if (mConfig.getDecodeResolveMode() == Config.DECODE_RES_RESOLVE_DUMMY
                && mPkg != null && mPkg.getResSpecCount() > 0) {
            addMissingResSpecs();
        }
        return pkgs.toArray(new ResPackage[0]);
    }
    private void readStringPoolChunk() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.RES_STRING_POOL_TYPE);
        mTableStrings = StringBlock.readWithoutChunk(mIn, mHeader.startPosition, mHeader.headerSize, mHeader.chunkSize);
    }
    private void readTableChunk() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.RES_TABLE_TYPE);
        mIn.skipInt(); 
        mHeader.checkForUnreadHeader(mIn);
    }
    private void readUnknownChunk() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.RES_NULL_TYPE);
        mHeader.checkForUnreadHeader(mIn);
        LOGGER.warning("Skipping unknown chunk data of size " + mHeader.chunkSize);
        mHeader.skipChunk(mIn);
    }
    private ResPackage readTablePackage() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.XML_TYPE_PACKAGE);
        int id = mIn.readInt();
        if (id == 0) {
            id = 2;
            if (mResTable.getPackageOriginal() == null && mResTable.getPackageRenamed() == null) {
                mResTable.setSharedLibrary(true);
            }
        }
        String name = mIn.readNullEndedString(128, true);
        mIn.skipInt(); 
        mIn.skipInt(); 
        mIn.skipInt(); 
        mIn.skipInt(); 
        int splitHeaderSize = 2 + 2 + 4 + 4 + (2 * 128) + (4 * 5); 
        if (mHeader.headerSize == splitHeaderSize) {
            mTypeIdOffset = mIn.readInt();
        }
        if (mTypeIdOffset > 0) {
            LOGGER.warning("Please report this application to Apktool for a fix: https:
        }
        mHeader.checkForUnreadHeader(mIn);
        mTypeNames = StringBlock.readWithChunk(mIn);
        mSpecNames = StringBlock.readWithChunk(mIn);
        mResId = id << 24;
        mPkg = new ResPackage(mResTable, id, name);
        return mPkg;
    }
    private void readLibraryType() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.XML_TYPE_LIBRARY);
        int libraryCount = mIn.readInt();
        int packageId;
        String packageName;
        mHeader.checkForUnreadHeader(mIn);
        for (int i = 0; i < libraryCount; i++) {
            packageId = mIn.readInt();
            packageName = mIn.readNullEndedString(128, true);
            LOGGER.info(String.format("Decoding Shared Library (%s), pkgId: %d", packageName, packageId));
        }
    }
    private void readStagedAliasSpec() throws IOException {
        int count = mIn.readInt();
        mHeader.checkForUnreadHeader(mIn);
        for (int i = 0; i < count; i++) {
            LOGGER.fine(String.format("Staged alias: 0x%08x -> 0x%08x", mIn.readInt(), mIn.readInt()));
        }
    }
    private void readOverlaySpec() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.XML_TYPE_OVERLAY);
        String name = mIn.readNullEndedString(256, true);
        String actor = mIn.readNullEndedString(256, true);
        mHeader.checkForUnreadHeader(mIn);
        LOGGER.fine(String.format("Overlay name: \"%s\", actor: \"%s\")", name, actor));
    }
    private void readOverlayPolicySpec() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.XML_TYPE_OVERLAY_POLICY);
        mIn.skipInt(); 
        int count = mIn.readInt();
        mHeader.checkForUnreadHeader(mIn);
        for (int i = 0; i < count; i++) {
            LOGGER.fine(String.format("Skipping overlay (%h)", mIn.readInt()));
        }
    }
    private ResTypeSpec readTableSpecType() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.XML_TYPE_SPEC_TYPE);
        int id = mIn.readUnsignedByte();
        mIn.skipBytes(1); 
        mIn.skipBytes(2); 
        int entryCount = mIn.readInt();
        if (mFlagsOffsets != null) {
            mFlagsOffsets.add(new FlagsOffset((int) mIn.position(), entryCount));
        }
        mHeader.checkForUnreadHeader(mIn);
        mIn.skipBytes(entryCount * 4); 
        mTypeSpec = new ResTypeSpec(mTypeNames.getString(id - 1), id);
        mPkg.addType(mTypeSpec);
        return mTypeSpec;
    }
    private ResType readTableType() throws AndrolibException, IOException {
        checkChunkType(ARSCHeader.XML_TYPE_TYPE);
        int typeId = mIn.readUnsignedByte() - mTypeIdOffset;
        if (mResTypeSpecs.containsKey(typeId)) {
            mTypeSpec = mResTypeSpecs.get(typeId);
        } else {
            mTypeSpec = new ResTypeSpec(mTypeNames.getString(typeId - 1), typeId);
            addTypeSpec(mTypeSpec);
            mPkg.addType(mTypeSpec);
        }
        mResId = (0xff000000 & mResId) | mTypeSpec.getId() << 16;
        int typeFlags = mIn.readByte();
        mIn.skipBytes(2); 
        int entryCount = mIn.readInt();
        int entriesStart = mIn.readInt();
        ResConfigFlags flags = readConfigFlags();
        mHeader.checkForUnreadHeader(mIn);
        boolean isOffset16 = (typeFlags & TABLE_TYPE_FLAG_OFFSET16) != 0;
        boolean isSparse = (typeFlags & TABLE_TYPE_FLAG_SPARSE) != 0;
        if (isSparse && !mResTable.isMainPkgLoaded()) {
            mResTable.setSparseResources(true);
        }
        HashMap<Integer, Integer> entryOffsetMap = new LinkedHashMap<>();
        for (int i = 0; i < entryCount; i++) {
            if (isSparse) {
                entryOffsetMap.put(mIn.readUnsignedShort(), mIn.readUnsignedShort());
            } else if (isOffset16) {
                entryOffsetMap.put(i, mIn.readUnsignedShort());
            } else {
                entryOffsetMap.put(i, mIn.readInt());
            }
        }
        if (flags.isInvalid()) {
            String resName = mTypeSpec.getName() + flags.getQualifiers();
            if (mKeepBroken) {
                LOGGER.warning("Invalid config flags detected: " + resName);
            } else {
                LOGGER.warning("Invalid config flags detected. Dropping resources: " + resName);
            }
        }
        mType = !flags.isInvalid() || mKeepBroken ? mPkg.getOrCreateConfig(flags) : null;
        int noEntry = isOffset16 ? NO_ENTRY_OFFSET16 : NO_ENTRY;
        long entriesStartAligned = mHeader.startPosition + entriesStart;
        if (mIn.position() < entriesStartAligned) {
            long bytesSkipped = mIn.skip(entriesStartAligned - mIn.position());
            LOGGER.fine(String.format("Skipping: %d byte(s) to align with ResTable_entry start.", bytesSkipped));
        }
        for (int i : entryOffsetMap.keySet()) {
            mResId = (mResId & 0xffff0000) | i;
            int offset = entryOffsetMap.get(i);
            if (offset == noEntry) {
                mMissingResSpecMap.put(mResId, typeId);
                continue;
            }
            if (mIn.position() == mHeader.endPosition) {
                int remainingEntries = entryCount - i;
                LOGGER.warning(String.format("End of chunk hit. Skipping remaining entries (%d) in type: %s",
                    remainingEntries, mTypeSpec.getName()
                ));
                break;
            }
            EntryData entryData = readEntryData();
            if (entryData != null) {
                readEntry(entryData);
            } else {
                mMissingResSpecMap.put(mResId, typeId);
            }
        }
        if (mIn.position() < mHeader.endPosition) {
            long bytesSkipped = mIn.skip(mHeader.endPosition - mIn.position());
            LOGGER.warning("Unknown data detected. Skipping: " + bytesSkipped + " byte(s)");
        }
        return mType;
    }
    private EntryData readEntryData() throws AndrolibException, IOException {
        int size = mIn.readUnsignedShort();
        short flags = mIn.readShort();
        boolean isComplex = (flags & ENTRY_FLAG_COMPLEX) != 0;
        boolean isCompact = (flags & ENTRY_FLAG_COMPACT) != 0;
        int specNamesId = mIn.readInt();
        if (specNamesId == NO_ENTRY && !isCompact) {
            return null;
        }
        if (isCompact && !mResTable.isMainPkgLoaded()) {
            mResTable.setCompactEntries(true);
        }
        ResValue value;
        if (isCompact) {
            byte type = (byte) ((flags >> 8) & 0xFF);
            value = readCompactValue(type, specNamesId);
            specNamesId = size;
        } else if (isComplex) {
            value = readComplexEntry();
        } else {
            value = readValue();
        }
        if (value == null) {
            return null;
        }
        EntryData entryData = new EntryData();
        entryData.flags = flags;
        entryData.specNamesId = specNamesId;
        entryData.value = value;
        return entryData;
    }
    private void readEntry(EntryData entryData) throws AndrolibException {
        int specNamesId = entryData.specNamesId;
        ResValue value = entryData.value;
        if (mTypeSpec.isString() && value instanceof ResFileValue) {
            value = new ResStringValue(value.toString(), ((ResFileValue) value).getRawIntValue());
        }
        if (mType == null) {
            return;
        }
        ResID resId = new ResID(mResId);
        ResResSpec spec;
        if (mPkg.hasResSpec(resId)) {
            spec = mPkg.getResSpec(resId);
        } else {
            spec = new ResResSpec(resId, mSpecNames.getString(specNamesId), mPkg, mTypeSpec);
            mPkg.addResSpec(spec);
            mTypeSpec.addResSpec(spec);
        }
        ResResource res = new ResResource(mType, spec, value);
        try {
            mType.addResource(res);
            spec.addResource(res);
        } catch (AndrolibException ex) {
            if (mKeepBroken) {
                mType.addResource(res, true);
                spec.addResource(res, true);
                LOGGER.warning(String.format("Duplicate Resource Detected. Ignoring duplicate: %s", res));
            } else {
                throw ex;
            }
        }
    }
    private ResBagValue readComplexEntry() throws AndrolibException, IOException {
        int parentId = mIn.readInt();
        int count = mIn.readInt();
        ResValueFactory factory = mPkg.getValueFactory();
        Pair<Integer, ResScalarValue>[] items = new Pair[count];
        ResIntBasedValue resValue;
        int resId;
        for (int i = 0; i < count; i++) {
            resId = mIn.readInt();
            resValue = readValue();
            if (resValue == null) {
                continue;
            }
            if (!(resValue instanceof ResScalarValue)) {
                resValue = new ResStringValue(resValue.toString(), resValue.getRawIntValue());
            }
            items[i] = Pair.of(resId, (ResScalarValue) resValue);
        }
        return factory.bagFactory(parentId, items, mTypeSpec);
    }
    private ResIntBasedValue readCompactValue(byte type, int data) throws AndrolibException {
        return type == TypedValue.TYPE_STRING
            ? mPkg.getValueFactory().factory(mTableStrings.getHTML(data), data)
            : mPkg.getValueFactory().factory(type, data, null);
    }
    private ResIntBasedValue readValue() throws AndrolibException, IOException {
        short size = mIn.readShort();
        if (size < 8) {
            return null;
        }
        mIn.skipCheckByte((byte) 0); 
        byte type = mIn.readByte();
        int data = mIn.readInt();
        return type == TypedValue.TYPE_STRING
            ? mPkg.getValueFactory().factory(mTableStrings.getHTML(data), data)
            : mPkg.getValueFactory().factory(type, data, null);
    }
    private ResConfigFlags readConfigFlags() throws AndrolibException, IOException {
        int size = mIn.readInt();
        int read = 8;
        if (size < 8) {
            throw new AndrolibException("Config size < 8");
        }
        boolean isInvalid = false;
        short mcc = mIn.readShort();
        short mnc = mIn.readShort();
        char[] language = new char[0];
        char[] country = new char[0];
        if (size >= 12) {
            language = unpackLanguageOrRegion(mIn.readByte(), mIn.readByte(), 'a');
            country = unpackLanguageOrRegion(mIn.readByte(), mIn.readByte(), '0');
            read = 12;
        }
        byte orientation = 0;
        byte touchscreen = 0;
        if (size >= 14) {
            orientation = mIn.readByte();
            touchscreen = mIn.readByte();
            read = 14;
        }
        int density = 0;
        if (size >= 16) {
            density = mIn.readUnsignedShort();
            read = 16;
        }
        byte keyboard = 0;
        byte navigation = 0;
        byte inputFlags = 0;
        byte grammaticalInflection = 0;
        if (size >= 20) {
            keyboard = mIn.readByte();
            navigation = mIn.readByte();
            inputFlags = mIn.readByte();
            grammaticalInflection = mIn.readByte();
            read = 20;
        }
        short screenWidth = 0;
        short screenHeight = 0;
        short sdkVersion = 0;
        if (size >= 28) {
            screenWidth = mIn.readShort();
            screenHeight = mIn.readShort();
            sdkVersion = mIn.readShort();
            mIn.skipBytes(2); 
            read = 28;
        }
        byte screenLayout = 0;
        byte uiMode = 0;
        short smallestScreenWidthDp = 0;
        if (size >= 32) {
            screenLayout = mIn.readByte();
            uiMode = mIn.readByte();
            smallestScreenWidthDp = mIn.readShort();
            read = 32;
        }
        short screenWidthDp = 0;
        short screenHeightDp = 0;
        if (size >= 36) {
            screenWidthDp = mIn.readShort();
            screenHeightDp = mIn.readShort();
            read = 36;
        }
        char[] localeScript = null;
        char[] localeVariant = null;
        if (size >= 48) {
            localeScript = readVariantLengthString(4).toCharArray();
            localeVariant = readVariantLengthString(8).toCharArray();
            read = 48;
        }
        byte screenLayout2 = 0;
        byte colorMode = 0;
        if (size >= 52) {
            screenLayout2 = mIn.readByte();
            colorMode = mIn.readByte();
            mIn.skipBytes(2); 
            read = 52;
        }
        char[] localeNumberingSystem = null;
        if (size >= 60) {
            localeNumberingSystem = readVariantLengthString(8).toCharArray();
            read = 60;
        }
        int exceedingKnownSize = size - KNOWN_CONFIG_BYTES;
        if (exceedingKnownSize > 0) {
            byte[] buf = new byte[exceedingKnownSize];
            read += exceedingKnownSize;
            mIn.readFully(buf);
            BigInteger exceedingBI = new BigInteger(1, buf);
            if (exceedingBI.equals(BigInteger.ZERO)) {
                LOGGER.fine(String
                        .format("Config flags size > %d, but exceeding bytes are all zero, so it should be ok.",
                                KNOWN_CONFIG_BYTES));
            } else {
                LOGGER.warning(String.format("Config flags size > %d. Size = %d. Exceeding bytes: 0x%X.",
                        KNOWN_CONFIG_BYTES, size, exceedingBI));
                isInvalid = true;
            }
        }
        int remainingSize = size - read;
        if (remainingSize > 0) {
            mIn.skipBytes(remainingSize);
        }
        return new ResConfigFlags(mcc, mnc, language, country,
                orientation, touchscreen, density, keyboard, navigation,
                inputFlags, grammaticalInflection, screenWidth, screenHeight, sdkVersion,
                screenLayout, uiMode, smallestScreenWidthDp, screenWidthDp,
                screenHeightDp, localeScript, localeVariant, screenLayout2,
                colorMode, localeNumberingSystem, size, isInvalid);
    }
    private char[] unpackLanguageOrRegion(byte in0, byte in1, char base) {
        if (((in0 >> 7) & 1) == 1) {
            int first = in1 & 0x1F;
            int second = ((in1 & 0xE0) >> 5) + ((in0 & 0x03) << 3);
            int third = (in0 & 0x7C) >> 2;
            return new char[] { (char) (first + base), (char) (second + base), (char) (third + base) };
        }
        return new char[] { (char) in0, (char) in1 };
    }
    private String readVariantLengthString(int maxLength) throws IOException {
        StringBuilder string = new StringBuilder(16);
        while (maxLength-- != 0) {
            short ch = mIn.readByte();
            if (ch == 0) {
                break;
            }
            string.append((char) ch);
        }
        mIn.skipBytes(maxLength);
        return string.toString();
    }
    private void addTypeSpec(ResTypeSpec resTypeSpec) {
        mResTypeSpecs.put(resTypeSpec.getId(), resTypeSpec);
    }
    private void addMissingResSpecs() throws AndrolibException {
        for (int resId : mMissingResSpecMap.keySet()) {
            int typeId = mMissingResSpecMap.get(resId);
            String resName = "APKTOOL_DUMMY_" + Integer.toHexString(resId);
            ResID id = new ResID(resId);
            ResResSpec spec = new ResResSpec(id, resName, mPkg, mResTypeSpecs.get(typeId));
            if (!mPkg.hasResSpec(id)) {
                mPkg.addResSpec(spec);
                spec.getType().addResSpec(spec);
                ResType resType = mPkg.getOrCreateConfig(new ResConfigFlags());
                ResValue value = new ResReferenceValue(mPkg, 0, "");
                ResResource res = new ResResource(resType, spec, value);
                resType.addResource(res);
                spec.addResource(res);
            }
        }
    }
    private ARSCHeader nextChunk() throws IOException {
        return mHeader = ARSCHeader.read(mIn);
    }
    private void checkChunkType(int expectedType) throws AndrolibException {
        if (mHeader.type != expectedType) {
            throw new AndrolibException(String.format("Invalid chunk type: expected=0x%08x, got=0x%08x",
                    expectedType, mHeader.type));
        }
    }
}
package brut.androlib.res.data;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.UndefinedResObjectException;
import com.google.common.collect.Sets;
import org.apache.commons.lang3.StringUtils;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;
public class ResResSpec {
    private static final Set<String> EMPTY_RESOURCE_NAMES = Sets.newHashSet(
        "0_resource_name_obfuscated", "(name removed)"
    );
    private final ResID mId;
    private final String mName;
    private final ResPackage mPackage;
    private final ResTypeSpec mType;
    private final Map<ResConfigFlags, ResResource> mResources;
    public ResResSpec(ResID id, String name, ResPackage pkg, ResTypeSpec type) {
        mId = id;
        if (name == null || name.isEmpty() || EMPTY_RESOURCE_NAMES.contains(name)) {
            name = "APKTOOL_DUMMYVAL_" + id;
        } else if (type.getResSpecUnsafe(name) != null) {
            name = String.format("APKTOOL_DUPLICATE_%s_%s", type, id);
        }
        mName = name;
        mPackage = pkg;
        mType = type;
        mResources = new LinkedHashMap<>();
    }
    public Set<ResResource> listResources() {
        return new LinkedHashSet<>(mResources.values());
    }
    public ResResource getResource(ResType config) throws AndrolibException {
        return getResource(config.getFlags());
    }
    public ResResource getResource(ResConfigFlags config) throws AndrolibException {
        ResResource res = mResources.get(config);
        if (res == null) {
            throw new UndefinedResObjectException(String.format("resource: spec=%s, config=%s", this, config));
        }
        return res;
    }
    public ResResource getDefaultResource() throws AndrolibException {
        return getResource(new ResConfigFlags());
    }
    public boolean hasDefaultResource() {
        return mResources.containsKey(new ResConfigFlags());
    }
    public String getFullName(ResPackage relativeToPackage, boolean excludeType) {
        return getFullName(getPackage().equals(relativeToPackage), excludeType);
    }
    public String getFullName(boolean excludePackage, boolean excludeType) {
        return (excludePackage ? "" : getPackage().getName() + ":")
                + (excludeType ? "" : getType().getName() + "/") + getName();
    }
    public ResID getId() {
        return mId;
    }
    public String getName() {
        return StringUtils.replace(mName, "\"", "q");
    }
    public ResPackage getPackage() {
        return mPackage;
    }
    public ResTypeSpec getType() {
        return mType;
    }
    public boolean isDummyResSpec() {
        return getName().startsWith("APKTOOL_DUMMY_");
    }
    public void addResource(ResResource res) throws AndrolibException {
        addResource(res, false);
    }
    public void addResource(ResResource res, boolean overwrite) throws AndrolibException {
        ResConfigFlags flags = res.getConfig().getFlags();
        if (mResources.put(flags, res) != null && !overwrite) {
            throw new AndrolibException(String.format("Multiple resources: spec=%s, config=%s", this, flags));
        }
    }
    @Override
    public String toString() {
        return mId + " " + mType + "/" + mName;
    }
}
package brut.androlib.res.data.value;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.exceptions.UndefinedResObjectException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResResSpec;
public class ResReferenceValue extends ResIntValue {
    private final ResPackage mPackage;
    private final boolean mTheme;
    public ResReferenceValue(ResPackage pkg, int value, String rawValue) {
        this(pkg, value, rawValue, false);
    }
    public ResReferenceValue(ResPackage pkg, int value, String rawValue, boolean theme) {
        super(value, rawValue, "reference");
        mPackage = pkg;
        mTheme = theme;
    }
    @Override
    protected String encodeAsResXml() throws AndrolibException {
        ResResSpec spec = !isNull() ? getReferent() : null;
        if (spec == null) {
            return "@null";
        }
        String prefix = mTheme ? "?" : "@";
        boolean excludeType = mTheme && spec.getType().getName().equals("attr");
        return prefix + spec.getFullName(mPackage, excludeType);
    }
    public ResPackage getPackage() {
        return mPackage;
    }
    public ResResSpec getReferent() throws AndrolibException {
        try {
            return mPackage.getResTable().getResSpec(getValue());
        } catch (UndefinedResObjectException ex) {
            return null;
        }
    }
    public boolean isNull() {
        return mValue == 0;
    }
    public boolean referentIsNull() throws AndrolibException {
        return getReferent() == null;
    }
}
package brut.androlib.res.data.value;
import brut.androlib.Config;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import org.apache.commons.lang3.tuple.Pair;
import org.xmlpull.v1.XmlSerializer;
import java.io.IOException;
public class ResBagValue extends ResValue implements ResValuesXmlSerializable {
    protected final ResReferenceValue mParent;
    protected final Config mConfig;
    public ResBagValue(ResReferenceValue parent) {
        mParent = parent;
        mConfig = parent.getPackage().getConfig();
    }
    @Override
    public void serializeToResValuesXml(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        String type = res.getResSpec().getType().getName();
        if ("style".equals(type)) {
            new ResStyleValue(mParent, Pair.emptyArray(), null).serializeToResValuesXml(serializer, res);
            return;
        }
        if ("array".equals(type)) {
            new ResArrayValue(mParent, Pair.emptyArray()).serializeToResValuesXml(serializer, res);
            return;
        }
        if ("plurals".equals(type)) {
            new ResPluralsValue(mParent, Pair.emptyArray()).serializeToResValuesXml(serializer, res);
            return;
        }
        serializer.startTag(null, "item");
        serializer.attribute(null, "type", type);
        serializer.attribute(null, "name", res.getResSpec().getName());
        serializer.endTag(null, "item");
    }
}
package brut.androlib.res.data.value;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import brut.androlib.res.xml.ResXmlEncoders;
import org.apache.commons.lang3.tuple.Pair;
import org.xmlpull.v1.XmlSerializer;
import java.io.IOException;
public class ResPluralsValue extends ResBagValue implements ResValuesXmlSerializable {
    private static final String[] QUANTITY_MAP = { "other", "zero", "one", "two", "few", "many" };
    private static final int BAG_KEY_PLURALS_START = 0x01000004;
    private final ResScalarValue[] mItems;
    ResPluralsValue(ResReferenceValue parent, Pair<Integer, ResScalarValue>[] items) {
        super(parent);
        mItems = new ResScalarValue[6];
        for (Pair<Integer, ResScalarValue> item : items) {
            mItems[item.getLeft() - BAG_KEY_PLURALS_START] = item.getRight();
        }
    }
    @Override
    public void serializeToResValuesXml(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        serializer.startTag(null, "plurals");
        serializer.attribute(null, "name", res.getResSpec().getName());
        for (int i = 0; i < mItems.length; i++) {
            ResScalarValue item = mItems[i];
            if (item == null) {
                continue;
            }
            serializer.startTag(null, "item");
            serializer.attribute(null, "quantity", QUANTITY_MAP[i]);
            serializer.text(ResXmlEncoders.enumerateNonPositionalSubstitutionsIfRequired(item.encodeAsResXmlNonEscapedItemValue()));
            serializer.endTag(null, "item");
        }
        serializer.endTag(null, "plurals");
    }
}
package brut.androlib.res.data;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.value.ResValue;
public class ResResource {
    private final ResType mConfig;
    private final ResResSpec mResSpec;
    private final ResValue mValue;
    public ResResource(ResType config, ResResSpec spec, ResValue value) {
        mConfig = config;
        mResSpec = spec;
        mValue = value;
    }
    public String getFilePath() {
        return mResSpec.getType().getName() + mConfig.getFlags().getQualifiers() + "/" + mResSpec.getName();
    }
    public ResType getConfig() {
        return mConfig;
    }
    public ResResSpec getResSpec() {
        return mResSpec;
    }
    public ResValue getValue() {
        return mValue;
    }
    public void replace(ResValue value) throws AndrolibException {
        ResResource res = new ResResource(mConfig, mResSpec, value);
        mConfig.addResource(res, true);
        mResSpec.addResource(res, true);
    }
    @Override
    public String toString() {
        return getFilePath();
    }
}
package brut.androlib.res.data.value;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import com.google.common.collect.Sets;
import org.apache.commons.lang3.tuple.Pair;
import org.xmlpull.v1.XmlSerializer;
import java.io.IOException;
import java.util.Set;
public class ResArrayValue extends ResBagValue implements ResValuesXmlSerializable {
    private static final Set<String> ALLOWED_ARRAY_TYPES = Sets.newHashSet("string", "integer");
    private final ResScalarValue[] mItems;
    ResArrayValue(ResReferenceValue parent, Pair<Integer, ResScalarValue>[] items) {
        super(parent);
        mItems = new ResScalarValue[items.length];
        for (int i = 0; i < items.length; i++) {
            mItems[i] = items[i].getRight();
        }
    }
    public ResArrayValue(ResReferenceValue parent, ResScalarValue[] items) {
        super(parent);
        mItems = items;
    }
    @Override
    public void serializeToResValuesXml(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        String type = getType();
        type = (type != null ? type + "-" : "") + "array";
        serializer.startTag(null, type);
        serializer.attribute(null, "name", res.getResSpec().getName());
        for (ResScalarValue item : mItems) {
            if (item.hasMultipleNonPositionalSubstitutions()) {
                serializer.attribute(null, "formatted", "false");
                break;
            }
        }
        for (ResScalarValue item : mItems) {
            serializer.startTag(null, "item");
            serializer.text(item.encodeAsResXmlNonEscapedItemValue());
            serializer.endTag(null, "item");
        }
        serializer.endTag(null, type);
    }
    public String getType() throws AndrolibException {
        if (mItems.length == 0) {
            return null;
        }
        String type = mItems[0].getType();
        for (ResScalarValue item : mItems) {
            if (item.encodeAsResXmlItemValue().startsWith("@string")) {
                return "string";
            } else if (item.encodeAsResXmlItemValue().startsWith("@drawable")) {
                return null;
            } else if (item.encodeAsResXmlItemValue().startsWith("@integer")) {
                return "integer";
            } else if (!"string".equals(type) && !"integer".equals(type)) {
                return null;
            } else if (!type.equals(item.getType())) {
                return null;
            }
        }
        if (!ALLOWED_ARRAY_TYPES.contains(type)) {
            return "string";
        }
        return type;
    }
}
package brut.androlib.res.xml;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResResource;
import org.xmlpull.v1.XmlSerializer;
import java.io.IOException;
public interface ResValuesXmlSerializable {
    void serializeToResValuesXml(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException;
}
package brut.androlib.res.data.value;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import org.apache.commons.lang3.tuple.Pair;
import org.xmlpull.v1.XmlSerializer;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;
public class ResStyleValue extends ResBagValue implements ResValuesXmlSerializable {
    private static final Logger LOGGER = Logger.getLogger(ResStyleValue.class.getName());
    private final Pair<ResReferenceValue, ResScalarValue>[] mItems;
    ResStyleValue(ResReferenceValue parent, Pair<Integer, ResScalarValue>[] items, ResValueFactory factory) {
        super(parent);
        mItems = new Pair[items.length];
        for (int i = 0; i < items.length; i++) {
            Pair<Integer, ResScalarValue> item = items[i];
            mItems[i] = Pair.of(factory.newReference(item.getLeft(), null), item.getRight());
        }
    }
    @Override
    public void serializeToResValuesXml(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        serializer.startTag(null, "style");
        serializer.attribute(null, "name", res.getResSpec().getName());
        if (!mParent.isNull() && !mParent.referentIsNull()) {
            serializer.attribute(null, "parent", mParent.encodeAsResXmlAttr());
        } else if (res.getResSpec().getName().indexOf('.') != -1) {
            serializer.attribute(null, "parent", "");
        }
        Set<String> processedNames = new HashSet<>();
        for (Pair<ResReferenceValue, ResScalarValue> item : mItems) {
            ResReferenceValue ref = item.getLeft();
            ResScalarValue val = item.getRight();
            ResResSpec spec = ref.getReferent();
            if (spec == null) {
                LOGGER.fine(String.format("null style reference: ref=0x%08x(%s), val=0x%08x(%s)",
                    ref.getRawIntValue(), ref.getType(), val.getRawIntValue(), val.getType()));
                continue;
            }
            String name;
            String value = null;
            ResValue resource = spec.getDefaultResource().getValue();
            if (resource instanceof ResReferenceValue) {
                continue;
            } else if (resource instanceof ResAttr) {
                ResAttr attr = (ResAttr) resource;
                value = attr.convertToResXmlFormat(val);
                name = spec.getFullName(res.getResSpec().getPackage(), true);
            } else {
                name = "@" + spec.getFullName(res.getResSpec().getPackage(), false);
            }
            if (!mConfig.isAnalysisMode() && processedNames.contains(name)) {
                continue;
            }
            if (value == null) {
                value = val.encodeAsResXmlValue();
            }
            if (value == null) {
                continue;
            }
            serializer.startTag(null, "item");
            serializer.attribute(null, "name", name);
            serializer.text(value);
            serializer.endTag(null, "item");
            processedNames.add(name);
        }
        serializer.endTag(null, "style");
        processedNames.clear();
    }
}
package brut.androlib.res.data.value;
import android.util.TypedValue;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResTypeSpec;
import org.apache.commons.lang3.tuple.Pair;
public class ResValueFactory {
    private final ResPackage mPackage;
    public ResValueFactory(ResPackage pkg) {
        mPackage = pkg;
    }
    public ResScalarValue factory(int type, int value, String rawValue) throws AndrolibException {
        switch (type) {
            case TypedValue.TYPE_NULL:
                if (value == TypedValue.DATA_NULL_EMPTY) {
                    return new ResEmptyValue(value, rawValue, type);
                }
                return new ResReferenceValue(mPackage, 0, null);
            case TypedValue.TYPE_REFERENCE:
                return newReference(value, null);
            case TypedValue.TYPE_ATTRIBUTE:
            case TypedValue.TYPE_DYNAMIC_ATTRIBUTE:
                return newReference(value, rawValue, true);
            case TypedValue.TYPE_STRING:
                return new ResStringValue(rawValue, value);
            case TypedValue.TYPE_FLOAT:
                return new ResFloatValue(Float.intBitsToFloat(value), value, rawValue);
            case TypedValue.TYPE_DIMENSION:
                return new ResDimenValue(value, rawValue);
            case TypedValue.TYPE_FRACTION:
                return new ResFractionValue(value, rawValue);
            case TypedValue.TYPE_INT_BOOLEAN:
                return new ResBoolValue(value != 0, value, rawValue);
            case TypedValue.TYPE_DYNAMIC_REFERENCE:
                return newReference(value, rawValue);
        }
        if (type >= TypedValue.TYPE_FIRST_COLOR_INT && type <= TypedValue.TYPE_LAST_COLOR_INT) {
            return new ResColorValue(value, rawValue);
        }
        if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
            return new ResIntValue(value, rawValue, type);
        }
        throw new AndrolibException("Invalid value type: " + type);
    }
    public ResIntBasedValue factory(String value, int rawValue) {
        if (value == null) {
            return new ResFileValue("", rawValue);
        }
        if (value.startsWith("res/")) {
            return new ResFileValue(value, rawValue);
        }
        if (value.startsWith("r/") || value.startsWith("R/")) { 
            return new ResFileValue(value, rawValue);
        }
        return new ResStringValue(value, rawValue);
    }
    public ResBagValue bagFactory(int parentId, Pair<Integer, ResScalarValue>[] items, ResTypeSpec resTypeSpec)
            throws AndrolibException {
        ResReferenceValue parent = newReference(parentId, null);
        if (items.length == 0) {
            return new ResBagValue(parent);
        }
        String resTypeName = resTypeSpec.getName();
        switch (resTypeName) {
            case ResTypeSpec.RES_TYPE_NAME_ATTR:
            case ResTypeSpec.RES_TYPE_NAME_ATTR_PRIVATE:
                return ResAttr.factory(parent, items, this);
            case ResTypeSpec.RES_TYPE_NAME_ARRAY:
                return new ResArrayValue(parent, items);
            case ResTypeSpec.RES_TYPE_NAME_PLURALS:
                return new ResPluralsValue(parent, items);
            default:
                if (resTypeName.startsWith(ResTypeSpec.RES_TYPE_NAME_STYLES)) {
                    return new ResStyleValue(parent, items, this);
                }
                throw new AndrolibException("unsupported res type name for bags. Found: " + resTypeName);
        }
    }
    public ResReferenceValue newReference(int resId, String rawValue) {
        return newReference(resId, rawValue, false);
    }
    public ResReferenceValue newReference(int resId, String rawValue, boolean theme) {
        return new ResReferenceValue(mPackage, resId, rawValue, theme);
    }
}
package brut.androlib.res.data.value;
import brut.androlib.Config;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.ResResource;
import org.apache.commons.lang3.tuple.Pair;
import org.xmlpull.v1.XmlSerializer;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;
public class ResEnumAttr extends ResAttr {
    private static final Logger LOGGER = Logger.getLogger(ResEnumAttr.class.getName());
    private final Pair<ResReferenceValue, ResScalarValue>[] mItems;
    private final Map<Integer, String> mItemsCache;
    ResEnumAttr(ResReferenceValue parent, int type, Integer min, Integer max, Boolean l10n,
                Pair<ResReferenceValue, ResScalarValue>[] items) {
        super(parent, type, min, max, l10n);
        mItems = items;
        mItemsCache = new HashMap<>();
    }
    @Override
    public String convertToResXmlFormat(ResScalarValue value)
            throws AndrolibException {
        if (value instanceof ResIntValue) {
            String decoded = decodeValue(((ResIntValue) value).getValue());
            if (decoded != null) {
                return decoded;
            }
        }
        return super.convertToResXmlFormat(value);
    }
    @Override
    protected void serializeBody(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        for (Pair<ResReferenceValue, ResScalarValue> item : mItems) {
            ResReferenceValue ref = item.getLeft();
            ResScalarValue val = item.getRight();
            ResResSpec referent = ref.getReferent();
            if (referent == null && mConfig.getDecodeResolveMode() == Config.DECODE_RES_RESOLVE_REMOVE) {
                LOGGER.fine(String.format("null enum reference: ref=0x%08x(%s), val=0x%08x(%s)",
                    ref.getRawIntValue(), ref.getType(), val.getRawIntValue(), val.getType()));
                continue;
            }
            serializer.startTag(null, "enum");
            serializer.attribute(null, "name", referent != null
                ? referent.getName() : String.format("APKTOOL_MISSING_0x%08x", ref.getRawIntValue()));
            serializer.attribute(null, "value", String.valueOf(val.getRawIntValue()));
            serializer.endTag(null, "enum");
        }
    }
    private String decodeValue(int value) throws AndrolibException {
        String decoded = mItemsCache.get(value);
        if (decoded == null) {
            ResReferenceValue ref = null;
            for (Pair<ResReferenceValue, ResScalarValue> item : mItems) {
                ResScalarValue val = item.getRight();
                if (val.getRawIntValue() == value) {
                    ref = item.getLeft();
                    break;
                }
            }
            if (ref != null && !ref.referentIsNull()) {
                decoded = ref.getReferent().getName();
                mItemsCache.put(value, decoded);
            }
        }
        return decoded;
    }
}
package brut.androlib.res.data.value;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResPackage;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.xml.ResValuesXmlSerializable;
import org.apache.commons.lang3.tuple.Pair;
import org.xmlpull.v1.XmlSerializer;
import java.io.IOException;
public class ResAttr extends ResBagValue implements ResValuesXmlSerializable {
    private static final int BAG_KEY_ATTR_MIN = 0x01000001;
    private static final int BAG_KEY_ATTR_MAX = 0x01000002;
    private static final int BAG_KEY_ATTR_L10N = 0x01000003;
    private static final int TYPE_REFERENCE = 0x01;
    private static final int TYPE_STRING = 0x02;
    private static final int TYPE_INT = 0x04;
    private static final int TYPE_BOOL = 0x08;
    private static final int TYPE_COLOR = 0x10;
    private static final int TYPE_FLOAT = 0x20;
    private static final int TYPE_DIMEN = 0x40;
    private static final int TYPE_FRACTION = 0x80;
    private static final int TYPE_ANY_STRING = 0xee;
    private static final int TYPE_ENUM = 0x00010000;
    private static final int TYPE_FLAGS = 0x00020000;
    private final int mType;
    private final Integer mMin;
    private final Integer mMax;
    private final Boolean mL10n;
    ResAttr(ResReferenceValue parent, int type, Integer min, Integer max, Boolean l10n) {
        super(parent);
        mType = type;
        mMin = min;
        mMax = max;
        mL10n = l10n;
    }
    public String convertToResXmlFormat(ResScalarValue value) throws AndrolibException {
        return null;
    }
    @Override
    public void serializeToResValuesXml(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        String type = getTypeAsString();
        serializer.startTag(null, "attr");
        serializer.attribute(null, "name", res.getResSpec().getName());
        if (type != null) {
            serializer.attribute(null, "format", type);
        }
        if (mMin != null) {
            serializer.attribute(null, "min", mMin.toString());
        }
        if (mMax != null) {
            serializer.attribute(null, "max", mMax.toString());
        }
        if (mL10n != null && mL10n) {
            serializer.attribute(null, "localization", "suggested");
        }
        serializeBody(serializer, res);
        serializer.endTag(null, "attr");
    }
    public static ResAttr factory(ResReferenceValue parent, Pair<Integer, ResScalarValue>[] items,
                                  ResValueFactory factory) throws AndrolibException {
        Integer min = null, max = null;
        Boolean l10n = null;
        int i = 1;
        for (; i < items.length; i++) {
            Pair<Integer, ResScalarValue> item = items[i];
            switch (item.getLeft()) {
                case BAG_KEY_ATTR_MIN:
                    min = item.getRight().getRawIntValue();
                    continue;
                case BAG_KEY_ATTR_MAX:
                    max = item.getRight().getRawIntValue();
                    continue;
                case BAG_KEY_ATTR_L10N:
                    l10n = item.getRight().getRawIntValue() != 0;
                    continue;
            }
            break;
        }
        int rawValue = items[0].getRight().getRawIntValue();
        int scalarType = rawValue & 0xffff;
        if (i == items.length) {
            return new ResAttr(parent, scalarType, min, max, l10n);
        }
        ResPackage pkg = parent.getPackage();
        Pair<ResReferenceValue, ResScalarValue>[] attrItems = new Pair[items.length - i];
        for (int j = 0; i < items.length; i++, j++) {
            Pair<Integer, ResScalarValue> item = items[i];
            int resId = item.getLeft();
            pkg.addSynthesizedRes(resId);
            attrItems[j] = Pair.of(factory.newReference(resId, null), item.getRight());
        }
        switch (rawValue & 0xff0000) {
            case TYPE_ENUM:
                return new ResEnumAttr(parent, scalarType, min, max, l10n, attrItems);
            case TYPE_FLAGS:
                return new ResFlagsAttr(parent, scalarType, min, max, l10n, attrItems);
        }
        throw new AndrolibException("Could not decode attr value");
    }
    protected void serializeBody(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
    }
    protected String getTypeAsString() {
        String s = "";
        if ((mType & TYPE_REFERENCE) != 0) {
            s += "|reference";
        }
        if ((mType & TYPE_STRING) != 0) {
            s += "|string";
        }
        if ((mType & TYPE_INT) != 0) {
            s += "|integer";
        }
        if ((mType & TYPE_BOOL) != 0) {
            s += "|boolean";
        }
        if ((mType & TYPE_COLOR) != 0) {
            s += "|color";
        }
        if ((mType & TYPE_FLOAT) != 0) {
            s += "|float";
        }
        if ((mType & TYPE_DIMEN) != 0) {
            s += "|dimension";
        }
        if ((mType & TYPE_FRACTION) != 0) {
            s += "|fraction";
        }
        if (s.isEmpty()) {
            return null;
        }
        return s.substring(1);
    }
}
package brut.androlib.res.data.value;
import brut.androlib.Config;
import brut.androlib.exceptions.AndrolibException;
import brut.androlib.res.data.ResResSpec;
import brut.androlib.res.data.ResResource;
import brut.androlib.res.data.arsc.FlagItem;
import org.apache.commons.lang3.tuple.Pair;
import org.xmlpull.v1.XmlSerializer;
import java.io.IOException;
import java.util.Arrays;
import java.util.Comparator;
import java.util.logging.Logger;
public class ResFlagsAttr extends ResAttr {
    private static final Logger LOGGER = Logger.getLogger(ResFlagsAttr.class.getName());
    private final FlagItem[] mItems;
    private FlagItem[] mZeroFlags;
    private FlagItem[] mFlags;
    ResFlagsAttr(ResReferenceValue parent, int type, Integer min, Integer max, Boolean l10n,
                 Pair<ResReferenceValue, ResScalarValue>[] items) {
        super(parent, type, min, max, l10n);
        mItems = new FlagItem[items.length];
        for (int i = 0; i < items.length; i++) {
            Pair<ResReferenceValue, ResScalarValue> item = items[i];
            mItems[i] = new FlagItem(item.getLeft(), item.getRight().getRawIntValue());
        }
    }
    @Override
    public String convertToResXmlFormat(ResScalarValue value) throws AndrolibException {
        if (value instanceof ResReferenceValue) {
            return value.encodeAsResXml();
        }
        if (!(value instanceof ResIntValue)) {
            return super.convertToResXmlFormat(value);
        }
        loadFlags();
        int intVal = ((ResIntValue) value).getValue();
        if (intVal == 0) {
            return renderFlags(mZeroFlags);
        }
        FlagItem[] flagItems = new FlagItem[mFlags.length];
        int[] flags = new int[mFlags.length];
        int flagsCount = 0;
        for (FlagItem flagItem : mFlags) {
            int flag = flagItem.flag;
            if ((intVal & flag) != flag) {
                continue;
            }
            if (!isSubpartOf(flag, flags)) {
                flags[flagsCount] = flag;
                flagItems[flagsCount++] = flagItem;
            }
        }
        return renderFlags(Arrays.copyOf(flagItems, flagsCount));
    }
    @Override
    protected void serializeBody(XmlSerializer serializer, ResResource res)
            throws AndrolibException, IOException {
        for (FlagItem item : mItems) {
            ResResSpec referent = item.ref.getReferent();
            if (referent == null && mConfig.getDecodeResolveMode() == Config.DECODE_RES_RESOLVE_REMOVE) {
                LOGGER.fine(String.format("null flag reference: 0x%08x(%s)", item.ref.getValue(), item.ref.getType()));
                continue;
            }
            serializer.startTag(null, "flag");
            serializer.attribute(null, "name", item.getValue());
            serializer.attribute(null, "value", String.format("0x%08x", item.flag));
            serializer.endTag(null, "flag");
        }
    }
    private boolean isSubpartOf(int flag, int[] flags) {
        for (int f : flags) {
            if ((f & flag) == flag) {
                return true;
            }
        }
        return false;
    }
    private String renderFlags(FlagItem[] flags) throws AndrolibException {
        StringBuilder sb = new StringBuilder();
        for (FlagItem flag : flags) {
            sb.append("|").append(flag.getValue());
        }
        if (sb.length() == 0) {
            return sb.toString();
        }
        return sb.substring(1);
    }
    private void loadFlags() {
        if (mFlags != null) {
            return;
        }
        FlagItem[] zeroFlags = new FlagItem[mItems.length];
        int zeroFlagsCount = 0;
        FlagItem[] flags = new FlagItem[mItems.length];
        int flagsCount = 0;
        for (FlagItem item : mItems) {
            if (item.flag == 0) {
                zeroFlags[zeroFlagsCount++] = item;
            } else {
                flags[flagsCount++] = item;
            }
        }
        mZeroFlags = Arrays.copyOf(zeroFlags, zeroFlagsCount);
        mFlags = Arrays.copyOf(flags, flagsCount);
        Arrays.sort(mFlags, Comparator.comparingInt((FlagItem item) -> Integer.bitCount(item.flag)).reversed());
    }
}