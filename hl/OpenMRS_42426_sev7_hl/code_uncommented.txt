package org.openmrs.api.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Cohort;
import org.openmrs.Encounter;
import org.openmrs.EncounterRole;
import org.openmrs.EncounterType;
import org.openmrs.Form;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.Order;
import org.openmrs.OrderGroup;
import org.openmrs.Patient;
import org.openmrs.Privilege;
import org.openmrs.Provider;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.VisitType;
import org.openmrs.api.APIException;
import org.openmrs.api.DiagnosisService;
import org.openmrs.api.EncounterService;
import org.openmrs.api.EncounterTypeLockedException;
import org.openmrs.api.ObsService;
import org.openmrs.api.OrderService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.EncounterDAO;
import org.openmrs.api.handler.EncounterVisitHandler;
import org.openmrs.parameter.EncounterSearchCriteria;
import org.openmrs.parameter.EncounterSearchCriteriaBuilder;
import org.openmrs.util.HandlerUtil;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.springframework.transaction.annotation.Transactional;
@Transactional
public class EncounterServiceImpl extends BaseOpenmrsService implements EncounterService {
	private EncounterDAO dao;
	@Override
	public void setEncounterDAO(EncounterDAO dao) {
		this.dao = dao;
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatient(String query, boolean includeVoided) throws APIException {
		if (query == null) {
			throw new IllegalArgumentException("The 'query' parameter is required and cannot be null");
		}
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncounters(query, null, null, null, includeVoided), null);
	}
	@Override
	public Encounter saveEncounter(Encounter encounter) throws APIException {
		failIfDeniedToEdit(encounter);
		createVisitForNewEncounter(encounter);
		boolean isNewEncounter = requirePrivilege(encounter);
		Patient p = encounter.getPatient();
		Date originalDate;
		Location originalLocation = null;
		if (!isNewEncounter) {
			originalDate = dao.getSavedEncounterDatetime(encounter);
			if (encounter.getLocation() != null) {
				originalLocation = dao.getSavedEncounterLocation(encounter);
			}
			Date newDate = encounter.getEncounterDatetime();
			Location newLocation = encounter.getLocation();
			for (Obs obs : encounter.getAllFlattenedObs(true)) {
				if (OpenmrsUtil.compare(originalDate, newDate) != 0
				        && OpenmrsUtil.compare(obs.getObsDatetime(), originalDate) == 0) {
					obs.setObsDatetime(newDate);
				}
				if (!OpenmrsUtil.nullSafeEquals(newLocation, originalLocation) && obs.getLocation().equals(originalLocation)) {
					obs.setLocation(newLocation);
				}
				if (!obs.getPerson().getPersonId().equals(p.getPatientId())) {
					obs.setPerson(p);
				}
			}
		}
		for (Order o : encounter.getOrders()) {
			if (!p.equals(o.getPatient())) {
				o.setPatient(p);
			}
		}
		dao.saveEncounter(encounter);
		for (OrderGroup orderGroup : encounter.getOrderGroups()) {
			Context.getOrderService().saveOrderGroup(orderGroup);
		}
		for (Order o : encounter.getOrdersWithoutOrderGroups()) {
			if (o.getOrderId() == null) {
				Context.getOrderService().saveOrder(o, null);
			}
		}
		String changeMessage = Context.getMessageSourceService().getMessage("Obs.void.reason.default");
		ObsService os = Context.getObsService();
		List<Obs> obsToRemove = new ArrayList<>();
		List<Obs> obsToAdd = new ArrayList<>();
		for (Obs o : encounter.getObsAtTopLevel(true)) {
			if (o.getId() == null) {
				os.saveObs(o, null);
			} else {
				Obs newObs = os.saveObs(o, changeMessage);
				obsToRemove.add(o);
				obsToAdd.add(os.getObs(o.getId()));
				obsToAdd.add(newObs);
			}
		}
		removeGivenObsAndTheirGroupMembersFromEncounter(obsToRemove, encounter);
		addGivenObsAndTheirGroupMembersToEncounter(obsToAdd, encounter);
		encounter.getConditions().forEach(Context.getConditionService()::saveCondition);
		encounter.getAllergies().forEach(Context.getPatientService()::saveAllergy);
		encounter.getDiagnoses().stream().forEach(diagnosis -> {
			diagnosis.setPatient(p);
			diagnosis.setEncounter(encounter);
		});
		encounter.getDiagnoses().forEach(Context.getDiagnosisService()::save);
		return encounter;
	}
	private void failIfDeniedToEdit(Encounter encounter) throws APIException {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.edit", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
	}
	private void createVisitForNewEncounter(Encounter encounter) {
		if (encounter.getEncounterId() == null) {
			EncounterVisitHandler encounterVisitHandler = Context.getEncounterService().getActiveEncounterVisitHandler();
			if (encounterVisitHandler != null) {
				encounterVisitHandler.beforeCreateEncounter(encounter);
				if (encounter.getVisit() != null && encounter.getVisit().getVisitId() == null) {
					Context.getVisitService().saveVisit(encounter.getVisit());
				}
			}
		}
	}
	private boolean requirePrivilege(Encounter encounter) {
		boolean isNewEncounter = false;
		if (encounter.getEncounterId() == null) {
			isNewEncounter = true;
			Context.requirePrivilege(PrivilegeConstants.ADD_ENCOUNTERS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_ENCOUNTERS);
		}
		return isNewEncounter;
	}
	private void removeGivenObsAndTheirGroupMembersFromEncounter(Collection<Obs> obsToRemove, Encounter encounter) {
		for (Obs o : obsToRemove) {
			encounter.removeObs(o);
			Set<Obs> groupMembers = o.getGroupMembers(true);
			if (CollectionUtils.isNotEmpty(groupMembers)) {
				removeGivenObsAndTheirGroupMembersFromEncounter(groupMembers, encounter);
			}
		}
	}
	private void addGivenObsAndTheirGroupMembersToEncounter(Collection<Obs> obsToAdd, Encounter encounter) {
		for (Obs o : obsToAdd) {
			encounter.addObs(o);
			Set<Obs> groupMembers = o.getGroupMembers(true);
			if (CollectionUtils.isNotEmpty(groupMembers)) {
				addGivenObsAndTheirGroupMembersToEncounter(groupMembers, encounter);
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Encounter getEncounter(Integer encounterId) throws APIException {
		Encounter encounter = dao.getEncounter(encounterId);
		if (encounter == null) {
			return null;
		} else if (canViewEncounter(encounter, null)) {
			return encounter;
		} else {
			throw new APIException("Encounter.error.privilege.required.view", new Object[] { encounter.getEncounterType()
			        .getViewPrivilege() });
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatient(Patient patient) throws APIException {
		if (patient == null) {
			throw new IllegalArgumentException("The 'patient' parameter is requred and cannot be null");
		}
		EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setPatient(patient)
		        .setIncludeVoided(false).createEncounterSearchCriteria();
		return Context.getEncounterService().getEncounters(encounterSearchCriteria);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatient(String query) throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(getEncountersByPatient(query, false), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatientId(Integer patientId) throws APIException {
		if (patientId == null) {
			throw new IllegalArgumentException("The 'patientId' parameter is requred and cannot be null");
		}
		return Context.getEncounterService()
		        .filterEncountersByViewPermissions(dao.getEncountersByPatientId(patientId), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByPatientIdentifier(String identifier) throws APIException {
		if (identifier == null) {
			throw new IllegalArgumentException("The 'identifier' parameter is required and cannot be null");
		}
		List<Encounter> encs = new ArrayList<>();
		for (Patient p : Context.getPatientService().getPatients(identifier, null, null, false)) {
			encs.addAll(Context.getEncounterService().getEncountersByPatientId(p.getPatientId()));
		}
		return Context.getEncounterService().filterEncountersByViewPermissions(encs, null);
	}
	@Deprecated
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncounters(Patient who, Location loc, Date fromDate, Date toDate,
	                                     Collection<Form> enteredViaForms, Collection<EncounterType> encounterTypes,
	                                     Collection<Provider> providers, Collection<VisitType> visitTypes,
	                                     Collection<Visit> visits, boolean includeVoided) {
		EncounterSearchCriteriaBuilder encounterSearchCriteriaBuilder = new EncounterSearchCriteriaBuilder().setPatient(who)
		        .setLocation(loc).setFromDate(fromDate).setToDate(toDate).setEnteredViaForms(enteredViaForms)
		        .setEncounterTypes(encounterTypes).setProviders(providers).setVisitTypes(visitTypes).setVisits(visits)
		        .setIncludeVoided(includeVoided);
		return getEncounters(encounterSearchCriteriaBuilder.createEncounterSearchCriteria());
	}
	@Override
	public List<Encounter> getEncounters(EncounterSearchCriteria encounterSearchCriteria) {
		return Context.getEncounterService().filterEncountersByViewPermissions(dao.getEncounters(encounterSearchCriteria),
		    null);
	}
	@Override
	public Encounter voidEncounter(Encounter encounter, String reason) {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.void", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
		if (reason == null) {
			throw new IllegalArgumentException("The argument 'reason' is required and so cannot be null");
		}
		ObsService os = Context.getObsService();
		for (Obs o : encounter.getObsAtTopLevel(false)) {
			if (!o.getVoided()) {
				os.voidObs(o, reason);
			}
		}
		OrderService orderService = Context.getOrderService();
		for (Order o : encounter.getOrders()) {
			orderService.voidOrder(o, reason);
		}
		encounter.setVoided(true);
		encounter.setVoidedBy(Context.getAuthenticatedUser());
		if (encounter.getDateVoided() == null) {
			encounter.setDateVoided(new Date());
		}
		encounter.setVoidReason(reason);
		Context.getEncounterService().saveEncounter(encounter);
		return encounter;
	}
	@Override
	public Encounter unvoidEncounter(Encounter encounter) throws APIException {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.unvoid", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
		String voidReason = encounter.getVoidReason();
		if (voidReason == null) {
			voidReason = "";
		}
		ObsService os = Context.getObsService();
		for (Obs o : encounter.getObsAtTopLevel(true)) {
			if (voidReason.equals(o.getVoidReason())) {
				os.unvoidObs(o);
			}
		}
		OrderService orderService = Context.getOrderService();
		for (Order o : encounter.getOrders()) {
			if (voidReason.equals(o.getVoidReason())) {
				orderService.unvoidOrder(o);
			}
		}
		encounter.setVoided(false);
		encounter.setVoidedBy(null);
		encounter.setDateVoided(null);
		encounter.setVoidReason(null);
		Context.getEncounterService().saveEncounter(encounter);
		return encounter;
	}
	@Override
	public void purgeEncounter(Encounter encounter) throws APIException {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.purge", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
		dao.deleteEncounter(encounter);
	}
	@Override
	public void purgeEncounter(Encounter encounter, boolean cascade) throws APIException {
		if (!canEditEncounter(encounter, null)) {
			throw new APIException("Encounter.error.privilege.required.purge", new Object[] { encounter.getEncounterType()
			        .getEditPrivilege() });
		}
		if (cascade) {
			ObsService obsService = Context.getObsService();
			List<Encounter> justThisEncounter = new ArrayList<>();
			justThisEncounter.add(encounter);
			List<Obs> observations = new ArrayList<>(
					obsService.getObservations(null, justThisEncounter, null, null, null, null, null, null,
							null, null, null, true));
			for (Obs o : observations) {
				obsService.purgeObs(o);
			}
			Set<Order> orders = encounter.getOrders();
			for (Order o : orders) {
				Context.getOrderService().purgeOrder(o);
			}
		}
		Context.getEncounterService().purgeEncounter(encounter);
	}
	@Override
	public EncounterType saveEncounterType(EncounterType encounterType) {
		Context.getEncounterService().checkIfEncounterTypesAreLocked();
		dao.saveEncounterType(encounterType);
		return encounterType;
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterType getEncounterType(Integer encounterTypeId) throws APIException {
		return dao.getEncounterType(encounterTypeId);
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterType getEncounterType(String name) throws APIException {
		return dao.getEncounterType(name);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterType> getAllEncounterTypes() throws APIException {
		return dao.getAllEncounterTypes(true);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterType> getAllEncounterTypes(boolean includeRetired) throws APIException {
		return dao.getAllEncounterTypes(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterType> findEncounterTypes(String name) throws APIException {
		return dao.findEncounterTypes(name);
	}
	@Override
	public EncounterType retireEncounterType(EncounterType encounterType, String reason) throws APIException {
		if (reason == null) {
			throw new IllegalArgumentException("The 'reason' for retiring is required");
		}
		Context.getEncounterService().checkIfEncounterTypesAreLocked();
		encounterType.setRetired(true);
		encounterType.setRetireReason(reason);
		return Context.getEncounterService().saveEncounterType(encounterType);
	}
	@Override
	public EncounterType unretireEncounterType(EncounterType encounterType) throws APIException {
		Context.getEncounterService().checkIfEncounterTypesAreLocked();
		encounterType.setRetired(false);
		return Context.getEncounterService().saveEncounterType(encounterType);
	}
	@Override
	public void purgeEncounterType(EncounterType encounterType) throws APIException {
		Context.getEncounterService().checkIfEncounterTypesAreLocked();
		dao.deleteEncounterType(encounterType);
	}
	@Override
	@Transactional(readOnly = true)
	public Encounter getEncounterByUuid(String uuid) throws APIException {
		return dao.getEncounterByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterType getEncounterTypeByUuid(String uuid) throws APIException {
		return dao.getEncounterTypeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public Map<Integer, List<Encounter>> getAllEncounters(Cohort patients) {
		return dao.getAllEncounters(patients);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncounters(String query, Integer start, Integer length, boolean includeVoided)
	    throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncounters(query, null, start, length, includeVoided), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncounters(String query, Integer patientId, Integer start, Integer length,
	                                     boolean includeVoided) throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncounters(query, patientId, start, length, includeVoided), null);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfEncounters(String query, boolean includeVoided) {
		return OpenmrsUtil.convertToInteger(dao.getCountOfEncounters(query, null, includeVoided));
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByVisit(Visit visit, boolean includeVoided) {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncountersByVisit(visit, includeVoided), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterVisitHandler> getEncounterVisitHandlers() {
		return HandlerUtil.getHandlersForType(EncounterVisitHandler.class, null);
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterVisitHandler getActiveEncounterVisitHandler() throws APIException {
		String handlerGlobalValue = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GP_VISIT_ASSIGNMENT_HANDLER, null);
		if (StringUtils.isBlank(handlerGlobalValue)) {
			return null;
		}
		EncounterVisitHandler handler;
		String namePrefix = OpenmrsConstants.REGISTERED_COMPONENT_NAME_PREFIX;
		if (handlerGlobalValue.startsWith(namePrefix)) {
			String beanName = handlerGlobalValue.substring(namePrefix.length());
			handler = Context.getRegisteredComponent(beanName, EncounterVisitHandler.class);
		} else {
			Object instance;
			try {
				instance = OpenmrsClassLoader.getInstance().loadClass(handlerGlobalValue).newInstance();
			}
			catch (Exception ex) {
				throw new APIException("failed.instantiate.assignment.handler", new Object[] { handlerGlobalValue }, ex);
			}
			if (instance instanceof EncounterVisitHandler) {
				handler = (EncounterVisitHandler) instance;
			} else {
				throw new APIException("assignment.handler.should.implement.EncounterVisitHandler", (Object[]) null);
			}
		}
		return handler;
	}
	@Override
	public EncounterRole saveEncounterRole(EncounterRole encounterRole) throws APIException {
		dao.saveEncounterRole(encounterRole);
		return encounterRole;
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterRole getEncounterRole(Integer encounterRoleId) throws APIException {
		return dao.getEncounterRole(encounterRoleId);
	}
	@Override
	public void purgeEncounterRole(EncounterRole encounterRole) throws APIException {
		dao.deleteEncounterRole(encounterRole);
	}
	@Override
	@Transactional(readOnly = true)
	public List<EncounterRole> getAllEncounterRoles(boolean includeRetired) {
		return dao.getAllEncounterRoles(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public EncounterRole getEncounterRoleByUuid(String uuid) throws APIException {
		return dao.getEncounterRoleByUuid(uuid);
	}
	@Override
	public EncounterRole getEncounterRoleByName(String name) {
		return dao.getEncounterRoleByName(name);
	}
	@Override
	public EncounterRole retireEncounterRole(EncounterRole encounterRole, String reason) throws APIException {
		if (reason == null) {
			throw new IllegalArgumentException("The 'reason' for retiring is required");
		}
		return Context.getEncounterService().saveEncounterRole(encounterRole);
	}
	@Override
	public EncounterRole unretireEncounterRole(EncounterRole encounterRole) throws APIException {
		return Context.getEncounterService().saveEncounterRole(encounterRole);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersNotAssignedToAnyVisit(Patient patient) throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncountersNotAssignedToAnyVisit(patient), null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> getEncountersByVisitsAndPatient(Patient patient, boolean includeVoided, String query,
	                                                       Integer start, Integer length) throws APIException {
		return Context.getEncounterService().filterEncountersByViewPermissions(
		    dao.getEncountersByVisitsAndPatient(patient, includeVoided, query, start, length), null);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getEncountersByVisitsAndPatientCount(Patient patient, boolean includeVoided, String query)
	    throws APIException {
		return dao.getEncountersByVisitsAndPatientCount(patient, includeVoided, query);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Encounter> filterEncountersByViewPermissions(List<Encounter> encounters, User user) {
		if (encounters != null) {
			if (user == null) {
				user = Context.getAuthenticatedUser();
			}
			for (Iterator<Encounter> iterator = encounters.iterator(); iterator.hasNext();) {
				Encounter encounter = iterator.next();
				EncounterType et = encounter.getEncounterType();
				if (et != null && !userHasEncounterPrivilege(et.getViewPrivilege(), user)) {
					iterator.remove();
				}
			}
		}
		return encounters;
	}
	@Override
	@Transactional(readOnly = true)
	public boolean canViewAllEncounterTypes(User subject) {
		boolean canView = Boolean.TRUE;
		for (EncounterType et : Context.getEncounterService().getAllEncounterTypes()) {
			if (!userHasEncounterPrivilege(et.getViewPrivilege(), subject)) {
				canView = Boolean.FALSE;
				break;
			}
		}
		return canView;
	}
	@Override
	@Transactional(readOnly = true)
	public boolean canEditAllEncounterTypes(User subject) {
		boolean canEdit = Boolean.TRUE;
		for (EncounterType et : Context.getEncounterService().getAllEncounterTypes()) {
			if (!userHasEncounterPrivilege(et.getEditPrivilege(), subject)) {
				canEdit = Boolean.FALSE;
				break;
			}
		}
		return canEdit;
	}
	@Override
	public boolean canEditEncounter(Encounter encounter, User user) {
		if (encounter == null) {
			throw new IllegalArgumentException("The encounter argument can not be null");
		}
		if (encounter.getEncounterType() == null) {
			return Boolean.TRUE;
		}
		if (user == null) {
			user = Context.getAuthenticatedUser();
		}
		return userHasEncounterPrivilege(encounter.getEncounterType().getEditPrivilege(), user);
	}
	@Override
	public boolean canViewEncounter(Encounter encounter, User user) {
		if (encounter == null) {
			throw new IllegalArgumentException("The encounter argument can not be null");
		}
		if (encounter.getEncounterType() == null) {
			return Boolean.TRUE;
		}
		if (user == null) {
			user = Context.getAuthenticatedUser();
		}
		return userHasEncounterPrivilege(encounter.getEncounterType().getViewPrivilege(), user);
	}
	private boolean userHasEncounterPrivilege(Privilege privilege, User user) {
		if (privilege == null) {
			return true;
		}
		return user.hasPrivilege(privilege.getPrivilege());
	}
	@Override
	@Transactional(readOnly = true)
	public void checkIfEncounterTypesAreLocked() {
		String locked = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_ENCOUNTER_TYPES_LOCKED, "false");
		if (Boolean.valueOf(locked)) {
			throw new EncounterTypeLockedException();
		}
	}
	@Override
	public List<EncounterRole> getEncounterRolesByName(String name) {
		return dao.getEncounterRolesByName(name);
	}
	@Override
	public Encounter transferEncounter(Encounter encounter, Patient patient) {
		Encounter encounterCopy = encounter.copyAndAssignToAnotherPatient(patient);
		voidEncounter(encounter, "transfer to patient: id = " + patient.getId());
		Visit visit = encounter.getVisit();
		if (visit != null && visit.getEncounters().size() == 1) {
			Context.getVisitService().voidVisit(visit, "Visit does not contain non-voided encounters");
		}
		return saveEncounter(encounterCopy);
	}
}
package org.openmrs;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import javax.persistence.Transient;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.hibernate.search.annotations.Analyze;
import org.hibernate.search.annotations.ContainedIn;
import org.hibernate.search.annotations.DateBridge;
import org.hibernate.search.annotations.DocumentId;
import org.hibernate.search.annotations.EncodingType;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.Resolution;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;
@Audited
public class Person extends BaseChangeableOpenmrsData {
	public static final long serialVersionUID = 2L;
	private static final Logger log = LoggerFactory.getLogger(Person.class);
	@DocumentId
	protected Integer personId;
	private Set<PersonAddress> addresses = null;
	@ContainedIn
	private Set<PersonName> names = null;
	@ContainedIn
	private Set<PersonAttribute> attributes = null;
	@Field
	private String gender;
	@Field(analyze = Analyze.YES)
	@DateBridge(encoding = EncodingType.STRING, resolution = Resolution.DAY)
	private Date birthdate;
	private Date birthtime;
	private Boolean birthdateEstimated = false;
	private Boolean deathdateEstimated = false;
	@Field
	private Boolean dead = false;
	private Date deathDate;
	private Concept causeOfDeath;
	private String causeOfDeathNonCoded;
	private User personCreator;
	private Date personDateCreated;
	private User personChangedBy;
	private Date personDateChanged;
	private Boolean personVoided = false;
	private User personVoidedBy;
	private Date personDateVoided;
	private String personVoidReason;
	@Field
	@NotAudited
	private boolean isPatient;
	@Transient
	Map<String, PersonAttribute> attributeMap = null;
	@Transient
	private Map<String, PersonAttribute> allAttributeMap = null;
	public Person() {
	}
	public Person(Person person) {
		if (person == null) {
			return;
		}
		personId = person.getPersonId();
		setUuid(person.getUuid());
		addresses = person.getAddresses();
		names = person.getNames();
		attributes = person.getAttributes();
		gender = person.getGender();
		birthdate = person.getBirthdate();
		birthtime = person.getBirthDateTime();
		birthdateEstimated = person.getBirthdateEstimated();
		deathdateEstimated = person.getDeathdateEstimated();
		dead = person.getDead();
		deathDate = person.getDeathDate();
		causeOfDeath = person.getCauseOfDeath();
		causeOfDeathNonCoded = person.getCauseOfDeathNonCoded();
		setPersonCreator(person.getPersonCreator());
		setPersonDateCreated(person.getPersonDateCreated());
		setPersonChangedBy(person.getPersonChangedBy());
		setPersonDateChanged(person.getPersonDateChanged());
		setPersonVoided(person.getPersonVoided());
		setPersonVoidedBy(person.getPersonVoidedBy());
		setPersonDateVoided(person.getPersonDateVoided());
		setPersonVoidReason(person.getPersonVoidReason());
		setPatient(person.getIsPatient());
	}
	public Person(Integer personId) {
		this.personId = personId;
	}
	public Integer getPersonId() {
		return personId;
	}
	public void setPersonId(Integer personId) {
		this.personId = personId;
	}
	public String getGender() {
		return this.gender;
	}
	public void setGender(String gender) {
		this.gender = gender;
	}
	public Date getBirthdate() {
		return this.birthdate;
	}
	public void setBirthdate(Date birthdate) {
		this.birthdate = birthdate;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isBirthdateEstimated() {
		return getBirthdateEstimated();
	}
	public Boolean getBirthdateEstimated() {
		return birthdateEstimated;
	}
	public void setBirthdateEstimated(Boolean birthdateEstimated) {
		this.birthdateEstimated = birthdateEstimated;
	}
	public Boolean getDeathdateEstimated() {
		return this.deathdateEstimated;
	}
	public void setDeathdateEstimated(Boolean deathdateEstimated) {
		this.deathdateEstimated = deathdateEstimated;
	}
	public void setBirthtime(Date birthtime) {
		this.birthtime = birthtime;
	}
	public Date getBirthDateTime() {
		if (birthdate != null && birthtime != null) {
			String birthDateString = new SimpleDateFormat("yyyy-MM-dd").format(birthdate);
			String birthTimeString = new SimpleDateFormat("HH:mm:ss").format(birthtime);
			try {
				return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(birthDateString + " " + birthTimeString);
			}
			catch (ParseException e) {
				log.error("Failed to parse birth date string", e);
			}
		}
		return null;
	}
	public Date getBirthtime() {
		return this.birthtime;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isDead() {
		return getDead();
	}
	public Boolean getDead() {
		return dead;
	}
	public void setDead(Boolean dead) {
		this.dead = dead;
	}
	public Date getDeathDate() {
		return this.deathDate;
	}
	public void setDeathDate(Date deathDate) {
		this.deathDate = deathDate;
		if (deathDate != null) {
			setDead(true);
		}
	}
	public Concept getCauseOfDeath() {
		return this.causeOfDeath;
	}
	public void setCauseOfDeath(Concept causeOfDeath) {
		this.causeOfDeath = causeOfDeath;
	}
	public String getCauseOfDeathNonCoded() {
		return this.causeOfDeathNonCoded;
	}
	public void setCauseOfDeathNonCoded(String causeOfDeathNonCoded) {
		this.causeOfDeathNonCoded = causeOfDeathNonCoded;
	}
	public Set<PersonAddress> getAddresses() {
		if (addresses == null) {
			addresses = new TreeSet<>();
		}
		return this.addresses;
	}
	public void setAddresses(Set<PersonAddress> addresses) {
		this.addresses = addresses;
	}
	public Set<PersonName> getNames() {
		if (names == null) {
			names = new TreeSet<>();
		}
		return this.names;
	}
	public void setNames(Set<PersonName> names) {
		this.names = names;
	}
	public Set<PersonAttribute> getAttributes() {
		if (attributes == null) {
			attributes = new TreeSet<>();
		}
		return this.attributes;
	}
	public List<PersonAttribute> getActiveAttributes() {
		List<PersonAttribute> attrs = new ArrayList<>();
		for (PersonAttribute attr : getAttributes()) {
			if (!attr.getVoided()) {
				attrs.add(attr);
			}
		}
		return attrs;
	}
	public void setAttributes(Set<PersonAttribute> attributes) {
		this.attributes = attributes;
		attributeMap = null;
		allAttributeMap = null;
	}
	public void addAttribute(PersonAttribute newAttribute) {
		newAttribute.setPerson(this);
		boolean newIsNull = !StringUtils.hasText(newAttribute.getValue());
		for (PersonAttribute currentAttribute : getActiveAttributes()) {
			if (currentAttribute.equals(newAttribute)) {
				return;
			} else if (currentAttribute.getAttributeType().equals(newAttribute.getAttributeType())) {
				if (currentAttribute.getValue() != null && currentAttribute.getValue().equals(newAttribute.getValue())) {
					return;
				}
				if (!newAttribute.getVoided() || newIsNull) {
					if (currentAttribute.getCreator() != null) {
						currentAttribute.voidAttribute("New value: " + newAttribute.getValue());
					} else {
						removeAttribute(currentAttribute);
					}
				}
			}
		}
		attributeMap = null;
		allAttributeMap = null;
		if (!OpenmrsUtil.collectionContains(attributes, newAttribute) && !newIsNull) {
			attributes.add(newAttribute);
		}
	}
	public void removeAttribute(PersonAttribute attribute) {
		if (attributes != null && attributes.remove(attribute)) {
			attributeMap = null;
			allAttributeMap = null;
		}
	}
	public PersonAttribute getAttribute(PersonAttributeType pat) {
		if (pat != null) {
			for (PersonAttribute attribute : getAttributes()) {
				if (pat.equals(attribute.getAttributeType()) && !attribute.getVoided()) {
					return attribute;
				}
			}
		}
		return null;
	}
	public PersonAttribute getAttribute(String attributeName) {
		if (attributeName != null) {
			for (PersonAttribute attribute : getAttributes()) {
				PersonAttributeType type = attribute.getAttributeType();
				if (type != null && attributeName.equals(type.getName()) && !attribute.getVoided()) {
					return attribute;
				}
			}
		}
		return null;
	}
	public PersonAttribute getAttribute(Integer attributeTypeId) {
		for (PersonAttribute attribute : getActiveAttributes()) {
			if (attributeTypeId.equals(attribute.getAttributeType().getPersonAttributeTypeId())) {
				return attribute;
			}
		}
		return null;
	}
	public List<PersonAttribute> getAttributes(String attributeName) {
		List<PersonAttribute> ret = new ArrayList<>();
		for (PersonAttribute attribute : getActiveAttributes()) {
			PersonAttributeType type = attribute.getAttributeType();
			if (type != null && attributeName.equals(type.getName())) {
				ret.add(attribute);
			}
		}
		return ret;
	}
	public List<PersonAttribute> getAttributes(Integer attributeTypeId) {
		List<PersonAttribute> ret = new ArrayList<>();
		for (PersonAttribute attribute : getActiveAttributes()) {
			if (attributeTypeId.equals(attribute.getAttributeType().getPersonAttributeTypeId())) {
				ret.add(attribute);
			}
		}
		return ret;
	}
	public List<PersonAttribute> getAttributes(PersonAttributeType personAttributeType) {
		List<PersonAttribute> ret = new ArrayList<>();
		for (PersonAttribute attribute : getAttributes()) {
			if (personAttributeType.equals(attribute.getAttributeType()) && !attribute.getVoided()) {
				ret.add(attribute);
			}
		}
		return ret;
	}
	public Map<String, PersonAttribute> getAttributeMap() {
		if (attributeMap != null) {
			return attributeMap;
		}
		log.debug("Current Person Attributes: \n{}", printAttributes());
		attributeMap = new HashMap<>();
		for (PersonAttribute attribute : getActiveAttributes()) {
			attributeMap.put(attribute.getAttributeType().getName(), attribute);
		}
		return attributeMap;
	}
	public Map<String, PersonAttribute> getAllAttributeMap() {
		if (allAttributeMap != null) {
			return allAttributeMap;
		}
		log.debug("Current Person Attributes: \n{}", printAttributes());
		allAttributeMap = new HashMap<>();
		for (PersonAttribute attribute : getAttributes()) {
			allAttributeMap.put(attribute.getAttributeType().getName(), attribute);
		}
		return allAttributeMap;
	}
	public String printAttributes() {
		StringBuilder s = new StringBuilder("");
		for (PersonAttribute attribute : getAttributes()) {
			s.append(attribute.getAttributeType()).append(" : ").append(attribute.getValue()).append(" : voided? ")
			        .append(attribute.getVoided()).append("\n");
		}
		return s.toString();
	}
	public void addName(PersonName name) {
		if (name != null) {
			name.setPerson(this);
			if (names == null) {
				names = new TreeSet<>();
			}
			if (!OpenmrsUtil.collectionContains(names, name)) {
				names.add(name);
			}
		}
	}
	public void removeName(PersonName name) {
		if (names != null) {
			names.remove(name);
		}
	}
	public void addAddress(PersonAddress address) {
		if (address != null) {
			address.setPerson(this);
			if (addresses == null) {
				addresses = new TreeSet<>();
			}
			if (!OpenmrsUtil.collectionContains(addresses, address) && !address.isBlank()) {
				addresses.add(address);
			}
		}
	}
	public void removeAddress(PersonAddress address) {
		if (addresses != null) {
			addresses.remove(address);
		}
	}
	public PersonName getPersonName() {
		if (getNames() != null && !getNames().isEmpty()) {
			for (PersonName name : getNames()) {
				if (name.getPreferred() && !name.getVoided()) {
					return name;
				}
			}
			for (PersonName name : getNames()) {
				if (!name.getVoided()) {
					return name;
				}
			}
			if (getVoided()) {
				return getNames().iterator().next();
			}
		}
		return null;
	}
	public String getGivenName() {
		PersonName personName = getPersonName();
		if (personName == null) {
			return "";
		} else {
			return personName.getGivenName();
		}
	}
	public String getMiddleName() {
		PersonName personName = getPersonName();
		if (personName == null) {
			return "";
		} else {
			return personName.getMiddleName();
		}
	}
	public String getFamilyName() {
		PersonName personName = getPersonName();
		if (personName == null) {
			return "";
		} else {
			return personName.getFamilyName();
		}
	}
	public PersonAddress getPersonAddress() {
		if (getAddresses() != null && !getAddresses().isEmpty()) {
			for (PersonAddress addr : getAddresses()) {
				if (addr.getPreferred() && !addr.getVoided()) {
					return addr;
				}
			}
			for (PersonAddress addr : getAddresses()) {
				if (!addr.getVoided()) {
					return addr;
				}
			}
			if (getVoided()) {
				return getAddresses().iterator().next();
			}
		}
		return null;
	}
	public Integer getAge() {
		return getAge(null);
	}
	public Integer getAge(Date onDate) {
		if (birthdate == null) {
			return null;
		}
		Calendar today = Calendar.getInstance();
		if (onDate != null) {
			today.setTime(onDate);
		}
		if (getDeathDate() != null && today.getTime().after(getDeathDate())) {
			today.setTime(getDeathDate());
		}
		Calendar bday = Calendar.getInstance();
		bday.setTime(birthdate);
		int age = today.get(Calendar.YEAR) - bday.get(Calendar.YEAR);
		int todaysMonth = today.get(Calendar.MONTH);
		int bdayMonth = bday.get(Calendar.MONTH);
		int todaysDay = today.get(Calendar.DAY_OF_MONTH);
		int bdayDay = bday.get(Calendar.DAY_OF_MONTH);
		if (todaysMonth < bdayMonth) {
			age--;
		} else if (todaysMonth == bdayMonth && todaysDay < bdayDay) {
			age--;
		}
		return age;
	}
	public Integer getAgeInMonths() {
		return getAgeInChronoUnit(ChronoUnit.MONTHS);
	}
	public Integer getAgeInWeeks() {
		return getAgeInChronoUnit(ChronoUnit.WEEKS);
	}
	public Integer getAgeInDays() {
		return getAgeInChronoUnit(ChronoUnit.DAYS);
	}
	private Integer getAgeInChronoUnit(ChronoUnit chronoUnit) {
		if (this.birthdate == null) {
			return null;
		}
		LocalDate birthDate = new java.sql.Date(this.birthdate.getTime()).toLocalDate();
		LocalDate endDate = LocalDate.now();
		if (this.deathDate != null) {
			LocalDate deathDate = new java.sql.Date(this.deathDate.getTime()).toLocalDate();
			if (endDate.isAfter(deathDate)) {
				endDate = deathDate;
			}
		}
		switch (chronoUnit) {
			case DAYS:
				return (int) ChronoUnit.DAYS.between(birthDate, endDate);
			case WEEKS:
				return (int) ChronoUnit.WEEKS.between(birthDate, endDate);
			case MONTHS:
				return (int) ChronoUnit.MONTHS.between(birthDate, endDate);
			default:
				throw new IllegalArgumentException("Unsupported ChronoUnit: " + chronoUnit);
		}
	}
	public void setBirthdateFromAge(int age, Date ageOnDate) {
		Calendar c = Calendar.getInstance();
		c.setTime(ageOnDate == null ? new Date() : ageOnDate);
		c.set(Calendar.DATE, 1);
		c.set(Calendar.MONTH, Calendar.JANUARY);
		c.add(Calendar.YEAR, -1 * age);
		setBirthdate(c.getTime());
		setBirthdateEstimated(true);
	}
	public User getPersonChangedBy() {
		return personChangedBy;
	}
	public void setPersonChangedBy(User changedBy) {
		this.personChangedBy = changedBy;
		this.setChangedBy(changedBy);
	}
	public Date getPersonDateChanged() {
		return personDateChanged;
	}
	public void setPersonDateChanged(Date dateChanged) {
		this.personDateChanged = dateChanged;
		this.setDateChanged(dateChanged);
	}
	public User getPersonCreator() {
		return personCreator;
	}
	public void setPersonCreator(User creator) {
		this.personCreator = creator;
		this.setCreator(creator);
	}
	public Date getPersonDateCreated() {
		return personDateCreated;
	}
	public void setPersonDateCreated(Date dateCreated) {
		this.personDateCreated = dateCreated;
		this.setDateCreated(dateCreated);
	}
	public Date getPersonDateVoided() {
		return personDateVoided;
	}
	public void setPersonDateVoided(Date dateVoided) {
		this.personDateVoided = dateVoided;
		this.setDateVoided(dateVoided);
	}
	public void setPersonVoided(Boolean voided) {
		this.personVoided = voided;
		this.setVoided(voided);
	}
	public Boolean getPersonVoided() {
		return personVoided;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isPersonVoided() {
		return getPersonVoided();
	}
	public User getPersonVoidedBy() {
		return personVoidedBy;
	}
	public void setPersonVoidedBy(User voidedBy) {
		this.personVoidedBy = voidedBy;
		this.setVoidedBy(voidedBy);
	}
	public String getPersonVoidReason() {
		return personVoidReason;
	}
	public void setPersonVoidReason(String voidReason) {
		this.personVoidReason = voidReason;
		this.setVoidReason(voidReason);
	}
	@Deprecated
	@JsonIgnore
	@NotAudited
	public boolean isPatient() {
		return getIsPatient();
	}
	@NotAudited
	public boolean getIsPatient() {
		return isPatient;
	}
	protected void setPatient(boolean isPatient) {
		this.isPatient = isPatient;
	}
	@Override
	public String toString() {
		return "Person(personId=" + personId + ")";
	}
	@Override
	public Integer getId() {
		return getPersonId();
	}
	@Override
	public void setId(Integer id) {
		setPersonId(id);
	}
}
package org.openmrs;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.envers.Audited;
import org.openmrs.annotation.AllowDirectAccess;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.obs.ComplexData;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.util.Format;
import org.openmrs.util.Format.FORMAT_TYPE;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@Audited
public class Obs extends BaseFormRecordableOpenmrsData {
	public enum Interpretation {
		NORMAL, ABNORMAL, CRITICALLY_ABNORMAL, NEGATIVE, POSITIVE, CRITICALLY_LOW, LOW, HIGH, CRITICALLY_HIGH, VERY_SUSCEPTIBLE, SUSCEPTIBLE, INTERMEDIATE, RESISTANT, SIGNIFICANT_CHANGE_DOWN, SIGNIFICANT_CHANGE_UP, OFF_SCALE_LOW, OFF_SCALE_HIGH
	}
	public enum Status {
		PRELIMINARY, FINAL, AMENDED
	}
	private static final String DATE_TIME_PATTERN = "yyyy-MM-dd HH:mm";
	private static final String TIME_PATTERN = "HH:mm";
	private static final String DATE_PATTERN = "yyyy-MM-dd";
	public static final long serialVersionUID = 112342333L;
	private static final Logger log = LoggerFactory.getLogger(Obs.class);
	protected Integer obsId;
	protected Concept concept;
	protected Date obsDatetime;
	protected String accessionNumber;
	protected Obs obsGroup;
	@AllowDirectAccess
	protected Set<Obs> groupMembers;
	protected Concept valueCoded;
	protected ConceptName valueCodedName;
	protected Drug valueDrug;
	protected Integer valueGroupId;
	protected Date valueDatetime;
	protected Double valueNumeric;
	protected String valueModifier;
	protected String valueText;
	protected String valueComplex;
	protected transient ComplexData complexData;
	protected String comment;
	protected transient Integer personId;
	protected Person person;
	protected Order order;
	protected Location location;
	protected Encounter encounter;
	private Obs previousVersion;
	private Boolean dirty = Boolean.FALSE;
	private Interpretation interpretation;
	private Status status = Status.FINAL;
	private ObsReferenceRange referenceRange;
	public Obs() {
	}
	public Obs(Person person, Concept question, Date obsDatetime, Location location) {
		this.person = person;
		if (person != null) {
			this.personId = person.getPersonId();
		}
		this.concept = question;
		this.obsDatetime = obsDatetime;
		this.location = location;
	}
	public Obs(Integer obsId) {
		this.obsId = obsId;
	}
	public static Obs newInstance(Obs obsToCopy) {
		Obs newObs = new Obs(obsToCopy.getPerson(), obsToCopy.getConcept(), obsToCopy.getObsDatetime(),
		        obsToCopy.getLocation());
		newObs.setObsGroup(obsToCopy.getObsGroup());
		newObs.setAccessionNumber(obsToCopy.getAccessionNumber());
		newObs.setValueCoded(obsToCopy.getValueCoded());
		newObs.setValueDrug(obsToCopy.getValueDrug());
		newObs.setValueGroupId(obsToCopy.getValueGroupId());
		newObs.setValueDatetime(obsToCopy.getValueDatetime());
		newObs.setValueNumeric(obsToCopy.getValueNumeric());
		newObs.setValueModifier(obsToCopy.getValueModifier());
		newObs.setValueText(obsToCopy.getValueText());
		newObs.setComment(obsToCopy.getComment());
		newObs.setEncounter(obsToCopy.getEncounter());
		newObs.setCreator(obsToCopy.getCreator());
		newObs.setDateCreated(obsToCopy.getDateCreated());
		newObs.setVoided(obsToCopy.getVoided());
		newObs.setVoidedBy(obsToCopy.getVoidedBy());
		newObs.setDateVoided(obsToCopy.getDateVoided());
		newObs.setVoidReason(obsToCopy.getVoidReason());
		newObs.setStatus(obsToCopy.getStatus());
		newObs.setInterpretation(obsToCopy.getInterpretation());
		newObs.setOrder(obsToCopy.getOrder());
		newObs.setValueComplex(obsToCopy.getValueComplex());
		newObs.setComplexData(obsToCopy.getComplexData());
		newObs.setFormField(obsToCopy.getFormFieldNamespace(), obsToCopy.getFormFieldPath());
		if (obsToCopy.hasGroupMembers(true)) {
			for (Obs member : obsToCopy.getGroupMembers(true)) {
				if (member.getObsId() == null) {
					newObs.addGroupMember(member);
				} else {
					Obs newMember = Obs.newInstance(member);
					newMember.setPreviousVersion(member);
					newObs.addGroupMember(newMember);
				}
			}
		}
		return newObs;
	}
	public String getComment() {
		return comment;
	}
	public void setComment(String comment) {
		markAsDirty(this.comment, comment);
		this.comment = comment;
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		markAsDirty(this.concept, concept);
		this.concept = concept;
	}
	public ConceptDescription getConceptDescription() {
		if (getConcept() == null) {
			return null;
		}
		return concept.getDescription();
	}
	public Encounter getEncounter() {
		return encounter;
	}
	public void setEncounter(Encounter encounter) {
		markAsDirty(this.encounter, encounter);
		this.encounter = encounter;
	}
	public Location getLocation() {
		return location;
	}
	public void setLocation(Location location) {
		markAsDirty(this.location, location);
		this.location = location;
	}
	public Date getObsDatetime() {
		return obsDatetime;
	}
	public void setObsDatetime(Date obsDatetime) {
		markAsDirty(this.obsDatetime, obsDatetime);
		this.obsDatetime = obsDatetime;
	}
	public Obs getObsGroup() {
		return obsGroup;
	}
	public void setObsGroup(Obs obsGroup) {
		markAsDirty(this.obsGroup, obsGroup);
		this.obsGroup = obsGroup;
	}
	public boolean isObsGrouping() {
		return hasGroupMembers(true);
	}
	public boolean hasGroupMembers() {
		return hasGroupMembers(false);
	}
	public boolean hasGroupMembers(boolean includeVoided) {
		return !org.springframework.util.CollectionUtils.isEmpty(getGroupMembers(includeVoided));
	}
	public Set<Obs> getGroupMembers() {
		return getGroupMembers(false);
	}
	public Set<Obs> getGroupMembers(boolean includeVoided) {
		if (includeVoided) {
			return groupMembers;
		}
		if (groupMembers == null) {
			return null;
		}
		Set<Obs> nonVoided = new LinkedHashSet<>(groupMembers);
		nonVoided.removeIf(BaseOpenmrsData::getVoided);
		return nonVoided;
	}
	public void setGroupMembers(Set<Obs> groupMembers) {
		this.groupMembers = groupMembers;
	}
	public void addGroupMember(Obs member) {
		if (member == null) {
			return;
		}
		if (getGroupMembers() == null) {
			groupMembers = new HashSet<>();
		}
		if (member.equals(this)) {
			throw new APIException("Obs.error.groupCannotHaveItselfAsAMentor", new Object[] { this, member });
		}
		member.setObsGroup(this);
		groupMembers.add(member);
	}
	public void removeGroupMember(Obs member) {
		if (member == null || getGroupMembers() == null) {
			return;
		}
		if (groupMembers.remove(member)) {
			member.setObsGroup(null);
		}
	}
	public Set<Obs> getRelatedObservations() {
		Set<Obs> ret = new HashSet<>();
		if (this.isObsGrouping()) {
			ret.addAll(this.getGroupMembers());
			Obs parentObs = this;
			while (parentObs.getObsGroup() != null) {
				for (Obs obsSibling : parentObs.getObsGroup().getGroupMembers()) {
					if (!obsSibling.isObsGrouping()) {
						ret.add(obsSibling);
					}
				}
				parentObs = parentObs.getObsGroup();
			}
		} else if (this.getObsGroup() != null) {
			for (Obs obsSibling : this.getObsGroup().getGroupMembers()) {
				if (!obsSibling.isObsGrouping()) {
					ret.add(obsSibling);
				}
			}
		}
		return ret;
	}
	public Integer getObsId() {
		return obsId;
	}
	public void setObsId(Integer obsId) {
		this.obsId = obsId;
	}
	public Order getOrder() {
		return order;
	}
	public void setOrder(Order order) {
		markAsDirty(this.order, order);
		this.order = order;
	}
	public Integer getPersonId() {
		return personId;
	}
	protected void setPersonId(Integer personId) {
		markAsDirty(this.personId, personId);
		this.personId = personId;
	}
	public Person getPerson() {
		return person;
	}
	public void setPerson(Person person) {
		markAsDirty(this.person, person);
		this.person = person;
		if (person != null) {
			setPersonId(person.getPersonId());
		}
	}
	public void setValueBoolean(Boolean valueBoolean) {
		if (getConcept() != null && getConcept().getDatatype() != null && getConcept().getDatatype().isBoolean()) {
			if (valueBoolean != null) {
				setValueCoded(valueBoolean ? Context.getConceptService().getTrueConcept() : Context.getConceptService()
				        .getFalseConcept());
			} else {
				setValueCoded(null);
			}
		}
	}
	public Boolean getValueAsBoolean() {
		if (getValueCoded() != null) {
			if (getValueCoded().equals(Context.getConceptService().getTrueConcept())) {
				return Boolean.TRUE;
			} else if (getValueCoded().equals(Context.getConceptService().getFalseConcept())) {
				return Boolean.FALSE;
			}
		} else if (getValueNumeric() != null) {
			if (getValueNumeric() == 1) {
				return Boolean.TRUE;
			} else if (getValueNumeric() == 0) {
				return Boolean.FALSE;
			}
		}
		return null;
	}
	public Boolean getValueBoolean() {
		if (getConcept() != null && valueCoded != null && getConcept().getDatatype().isBoolean()) {
			Concept trueConcept = Context.getConceptService().getTrueConcept();
			return trueConcept != null && valueCoded.getId().equals(trueConcept.getId());
		}
		return null;
	}
	public Concept getValueCoded() {
		return valueCoded;
	}
	public void setValueCoded(Concept valueCoded) {
		markAsDirty(this.valueCoded, valueCoded);
		this.valueCoded = valueCoded;
	}
	public ConceptName getValueCodedName() {
		return valueCodedName;
	}
	public void setValueCodedName(ConceptName valueCodedName) {
		markAsDirty(this.valueCodedName, valueCodedName);
		this.valueCodedName = valueCodedName;
	}
	public Drug getValueDrug() {
		return valueDrug;
	}
	public void setValueDrug(Drug valueDrug) {
		markAsDirty(this.valueDrug, valueDrug);
		this.valueDrug = valueDrug;
	}
	public Date getValueDatetime() {
		return valueDatetime;
	}
	public void setValueDatetime(Date valueDatetime) {
		markAsDirty(this.valueDatetime, valueDatetime);
		this.valueDatetime = valueDatetime;
	}
	public Date getValueDate() {
		return valueDatetime;
	}
	public void setValueDate(Date valueDate) {
		markAsDirty(this.valueDatetime, valueDate);
		this.valueDatetime = valueDate;
	}
	public Date getValueTime() {
		return valueDatetime;
	}
	public void setValueTime(Date valueTime) {
		markAsDirty(this.valueDatetime, valueTime);
		this.valueDatetime = valueTime;
	}
	public Integer getValueGroupId() {
		return valueGroupId;
	}
	public void setValueGroupId(Integer valueGroupId) {
		markAsDirty(this.valueGroupId, valueGroupId);
		this.valueGroupId = valueGroupId;
	}
	public String getValueModifier() {
		return valueModifier;
	}
	public void setValueModifier(String valueModifier) {
		markAsDirty(this.valueModifier, valueModifier);
		this.valueModifier = valueModifier;
	}
	public Double getValueNumeric() {
		return valueNumeric;
	}
	public void setValueNumeric(Double valueNumeric) {
		markAsDirty(this.valueNumeric, valueNumeric);
		this.valueNumeric = valueNumeric;
	}
	public String getValueText() {
		return valueText;
	}
	public void setValueText(String valueText) {
		markAsDirty(this.valueText, valueText);
		this.valueText = valueText;
	}
	public boolean isComplex() {
		if (getConcept() != null) {
			return getConcept().isComplex();
		}
		return false;
	}
	public String getValueComplex() {
		return this.valueComplex;
	}
	public void setValueComplex(String valueComplex) {
		markAsDirty(this.valueComplex, valueComplex);
		this.valueComplex = valueComplex;
	}
	public void setComplexData(ComplexData complexData) {
		markAsDirty(this.complexData, complexData);
		this.complexData = complexData;
	}
	public ComplexData getComplexData() {
		return this.complexData;
	}
	public String getAccessionNumber() {
		return accessionNumber;
	}
	public void setAccessionNumber(String accessionNumber) {
		markAsDirty(this.accessionNumber, accessionNumber);
		this.accessionNumber = accessionNumber;
	}
	public String getValueAsString(Locale locale) {
		NumberFormat nf = NumberFormat.getNumberInstance(locale);
		DecimalFormat df = (DecimalFormat) nf;
		df.applyPattern("#0.0#####");
		if (getConcept() != null) {
			String abbrev = getConcept().getDatatype().getHl7Abbreviation();
			if ("BIT".equals(abbrev)) {
				return getValueAsBoolean() == null ? "" : getValueAsBoolean().toString();
			} else if ("CWE".equals(abbrev)) {
				if (getValueCoded() == null) {
					return "";
				}
				if (getValueDrug() != null) {
					return getValueDrug().getFullName(locale);
				} else {
					ConceptName codedName = getValueCodedName();
					if (codedName != null) {
						return getValueCoded().getName(locale, false).getName();
					} else {
						ConceptName fallbackName = getValueCoded().getName();
						if (fallbackName != null) {
							return fallbackName.getName();
						} else {
							return "";
						}
					}
				}
			} else if ("NM".equals(abbrev) || "SN".equals(abbrev)) {
				if (getValueNumeric() == null) {
					return "";
				} else {
					Concept deproxiedConcept = HibernateUtil.getRealObjectFromProxy(getConcept());
					if (deproxiedConcept instanceof ConceptNumeric) {
						ConceptNumeric cn = (ConceptNumeric) deproxiedConcept;
						if (!cn.getAllowDecimal()) {
							double d = getValueNumeric();
							int i = (int) d;
							return Integer.toString(i);
						} else {
							df.format(getValueNumeric());
						}
					}
				}
			} else if ("DT".equals(abbrev)) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_PATTERN);
				return (getValueDatetime() == null ? "" : dateFormat.format(getValueDatetime()));
			} else if ("TM".equals(abbrev)) {
				return (getValueDatetime() == null ? "" : Format.format(getValueDatetime(), locale, FORMAT_TYPE.TIME));
			} else if ("TS".equals(abbrev)) {
				return (getValueDatetime() == null ? "" : Format.format(getValueDatetime(), locale, FORMAT_TYPE.TIMESTAMP));
			} else if ("ST".equals(abbrev)) {
				return getValueText();
			} else if ("ED".equals(abbrev) && getValueComplex() != null) {
				String[] valuesComplex = getValueComplex().split("\\|");
				for (String value : valuesComplex) {
					if (StringUtils.isNotEmpty(value)) {
						return value.trim();
					}
				}
			}
		}
		if (getValueNumeric() != null) {
			return df.format(getValueNumeric());
		} else if (getValueCoded() != null) {
			if (getValueDrug() != null) {
				return getValueDrug().getFullName(locale);
			} else {
				ConceptName valudeCodedName = getValueCodedName();
				if (valudeCodedName != null) {
					return valudeCodedName.getName();
				} else {
					return "";
				}
			}
		} else if (getValueDatetime() != null) {
			return Format.format(getValueDatetime(), locale, FORMAT_TYPE.DATE);
		} else if (getValueText() != null) {
			return getValueText();
		} else if (hasGroupMembers()) {
			StringBuilder sb = new StringBuilder();
			for (Obs groupMember : getGroupMembers()) {
				if (sb.length() > 0) {
					sb.append(", ");
				}
				sb.append(groupMember.getValueAsString(locale));
			}
			return sb.toString();
		}
		if (getValueComplex() != null) {
			String[] valuesComplex = getValueComplex().split("\\|");
			for (String value : valuesComplex) {
				if (StringUtils.isNotEmpty(value)) {
					return value.trim();
				}
			}
		}
		return "";
	}
	public void setValueAsString(String s) throws ParseException {
		log.debug("getConcept() == {}", getConcept());
		if (getConcept() != null && !StringUtils.isBlank(s)) {
			String abbrev = getConcept().getDatatype().getHl7Abbreviation();
			if ("BIT".equals(abbrev)) {
				setValueBoolean(Boolean.valueOf(s));
			} else if ("CWE".equals(abbrev)) {
				throw new RuntimeException("Not Yet Implemented");
			} else if ("NM".equals(abbrev) || "SN".equals(abbrev)) {
				setValueNumeric(Double.valueOf(s));
			} else if ("DT".equals(abbrev)) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_PATTERN);
				setValueDatetime(dateFormat.parse(s));
			} else if ("TM".equals(abbrev)) {
				DateFormat timeFormat = new SimpleDateFormat(TIME_PATTERN);
				setValueDatetime(timeFormat.parse(s));
			} else if ("TS".equals(abbrev)) {
				DateFormat datetimeFormat = new SimpleDateFormat(DATE_TIME_PATTERN);
				setValueDatetime(datetimeFormat.parse(s));
			} else if ("ST".equals(abbrev)) {
				setValueText(s);
			} else {
				throw new RuntimeException("Don't know how to handle " + abbrev + " for concept: " + getConcept().getName().getName());
			}
		} else {
			throw new RuntimeException("concept is null for " + this);
		}
	}
	@Override
	public String toString() {
		if (obsId == null) {
			return "obs id is null";
		}
		return "Obs #" + obsId.toString();
	}
	@Override
	public Integer getId() {
		return getObsId();
	}
	@Override
	public void setId(Integer id) {
		setObsId(id);
	}
	public Obs getPreviousVersion() {
		return previousVersion;
	}
	public void setPreviousVersion(Obs previousVersion) {
		markAsDirty(this.previousVersion, previousVersion);
		this.previousVersion = previousVersion;
	}
	public Boolean hasPreviousVersion() {
		return getPreviousVersion() != null;
	}
	@Override
	public void setCreator(User creator) {
		markAsDirty(getCreator(), creator);
		super.setCreator(creator);
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		markAsDirty(getDateCreated(), dateCreated);
		super.setDateCreated(dateCreated);
	}
	@Override
	public void setFormField(String namespace, String formFieldPath) {
		String oldValue = formNamespaceAndPath;
		super.setFormField(namespace, formFieldPath);
		markAsDirty(oldValue, formNamespaceAndPath);
	}
	public boolean isDirty() {
		return dirty;
	}
	protected void markAsDirty(Object oldValue, Object newValue) {
		if (!isDirty() && obsId != null && !OpenmrsUtil.nullSafeEquals(oldValue, newValue)) {
			dirty = true;
		}
	}
	public Interpretation getInterpretation() {
		return interpretation;
	}
	public void setInterpretation(Interpretation interpretation) {
		markAsDirty(this.interpretation, interpretation);
		this.interpretation = interpretation;
	}
	public Status getStatus() {
		return status;
	}
	public void setStatus(Status status) {
		markAsDirty(this.status, status);
		this.status = status;
	}
	public ObsReferenceRange getReferenceRange() {
		return referenceRange;
	}
	public void setReferenceRange(ObsReferenceRange referenceRange) {
		this.referenceRange = referenceRange;
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.DocumentId;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Table;
@Audited
@Entity
@Table(name = "obs_reference_range")
public class ObsReferenceRange extends BaseReferenceRange {
	private static final long serialVersionUID = 473299L;
	@DocumentId
	@Id
	@Column(name = "obs_reference_range_id")
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer obsReferenceRangeId;
	@OneToOne
	@JoinColumn(name = "obs_id", referencedColumnName = "obs_id", unique = true)
	private Obs obs;
	public ObsReferenceRange() {
	}
	public Integer getObsReferenceRangeId() {
		return obsReferenceRangeId;
	}
	public void setObsReferenceRangeId(Integer obsReferenceRangeId) {
		this.obsReferenceRangeId = obsReferenceRangeId;
	}
	public Integer getId() {
		return getObsReferenceRangeId();
	}
	public void setId(Integer id) {
		setObsReferenceRangeId(id);
	}
	public Obs getObs() {
		return obs;
	}
	public void setObs(Obs obs) {
		this.obs = obs;
	}
}
package org.openmrs;
import java.lang.reflect.Field;
import javax.annotation.PostConstruct;
import org.hibernate.SessionFactory;
import org.hibernate.event.service.spi.EventListenerRegistry;
import org.hibernate.event.spi.EventType;
import org.hibernate.event.spi.PostLoadEvent;
import org.hibernate.event.spi.PostLoadEventListener;
import org.hibernate.internal.SessionFactoryImpl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
@Component
public class ObsPostLoadEventListener implements PostLoadEventListener {
	private static final Logger log = LoggerFactory.getLogger(ObsPostLoadEventListener.class);
	@Autowired
	private SessionFactory sessionFactory;
	@PostConstruct
	public void registerListener() {
		EventListenerRegistry registry = ((SessionFactoryImpl) sessionFactory).getServiceRegistry().getService(
		    EventListenerRegistry.class);
		registry.getEventListenerGroup(EventType.POST_LOAD).appendListener(this);
	}
	@Override
	public void onPostLoad(PostLoadEvent event) {
		if (Obs.class.isAssignableFrom(event.getEntity().getClass())) {
			Field field = null;
			try {
				field = Obs.class.getDeclaredField("dirty");
				field.setAccessible(true);
				field.set(event.getEntity(), false);
			}
			catch (ReflectiveOperationException e) {
				log.error("Failed to unset an Obs as dirty after being loaded from the database", e);
			}
			finally {
				if (field != null) {
					field.setAccessible(false);
				}
			}
		}
	}
}
package org.openmrs;
import java.util.Date;
import javax.persistence.Column;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.MappedSuperclass;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.Field;
@MappedSuperclass
@Audited
public abstract class BaseOpenmrsData extends BaseOpenmrsObject implements OpenmrsData {
	@ManyToOne(optional = false)
	@JoinColumn(name = "creator", updatable = false)
	protected User creator;
	@Column(name = "date_created", nullable = false, updatable = false)
	private Date dateCreated;
	@ManyToOne
	@JoinColumn(name = "changed_by")
	private User changedBy;
	@Column(name = "date_changed")
	private Date dateChanged;
	@Column(name = "voided", nullable = false)
	@Field
	private Boolean voided = Boolean.FALSE;
	@Column(name = "date_voided")
	private Date dateVoided;
	@ManyToOne
	@JoinColumn(name = "voided_by")
	private User voidedBy;
	@Column(name = "void_reason", length = 255)
	private String voidReason;
	public BaseOpenmrsData() {
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	@Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	@Override
	@Deprecated
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	@Deprecated
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	@Override
	@Deprecated
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	@Deprecated
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	@Deprecated
	@JsonIgnore
	public Boolean isVoided() {
		return getVoided();
	}
	@Override
	public Boolean getVoided() {
		return voided;
	}
	@Override
	public void setVoided(Boolean voided) {
		this.voided = voided;
	}
	@Override
	public Date getDateVoided() {
		return dateVoided;
	}
	@Override
	public void setDateVoided(Date dateVoided) {
		this.dateVoided = dateVoided;
	}
	@Override
	public User getVoidedBy() {
		return voidedBy;
	}
	@Override
	public void setVoidedBy(User voidedBy) {
		this.voidedBy = voidedBy;
	}
	@Override
	public String getVoidReason() {
		return voidReason;
	}
	@Override
	public void setVoidReason(String voidReason) {
		this.voidReason = voidReason;
	}
}
package org.openmrs.util;
import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.sql.Timestamp;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Random;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.jar.JarFile;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;
import javax.activation.MimetypesFileTypeMap;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Cohort;
import org.openmrs.Concept;
import org.openmrs.ConceptNumeric;
import org.openmrs.ConceptReferenceRange;
import org.openmrs.Drug;
import org.openmrs.EncounterType;
import org.openmrs.Form;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.PersonAttributeType;
import org.openmrs.Program;
import org.openmrs.ProgramWorkflowState;
import org.openmrs.User;
import org.openmrs.annotation.AddOnStartup;
import org.openmrs.annotation.HasAddOnStartupPrivileges;
import org.openmrs.annotation.Logging;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.ConceptService;
import org.openmrs.api.InvalidCharactersPasswordException;
import org.openmrs.api.PasswordException;
import org.openmrs.api.ShortPasswordException;
import org.openmrs.api.WeakPasswordException;
import org.openmrs.api.context.Context;
import org.openmrs.logging.OpenmrsLoggingUtil;
import org.openmrs.module.ModuleException;
import org.openmrs.module.ModuleFactory;
import org.openmrs.propertyeditor.CohortEditor;
import org.openmrs.propertyeditor.ConceptEditor;
import org.openmrs.propertyeditor.DrugEditor;
import org.openmrs.propertyeditor.EncounterTypeEditor;
import org.openmrs.propertyeditor.FormEditor;
import org.openmrs.propertyeditor.LocationEditor;
import org.openmrs.propertyeditor.PersonAttributeTypeEditor;
import org.openmrs.propertyeditor.ProgramEditor;
import org.openmrs.propertyeditor.ProgramWorkflowStateEditor;
import org.openmrs.validator.ObsValidator;
import org.slf4j.LoggerFactory;
import org.slf4j.MarkerFactory;
import org.springframework.beans.propertyeditors.CustomDateEditor;
import org.springframework.context.NoSuchMessageException;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
public class OpenmrsUtil {
	private OpenmrsUtil() {
	}
	private static volatile MimetypesFileTypeMap mimetypesFileTypeMap = null;
	private static org.slf4j.Logger log = LoggerFactory.getLogger(OpenmrsUtil.class);
	private static Map<Locale, SimpleDateFormat> dateFormatCache = new HashMap<>();
	private static Map<Locale, SimpleDateFormat> timeFormatCache = new HashMap<>();
	public static <E> Collection<Collection<E>> compareLists(Collection<E> origList, Collection<E> newList) {	
		Collection<Collection<E>> returnList = new ArrayList<>();
		Collection<E> toAdd = new LinkedList<>();
		Collection<E> toDel = new LinkedList<>();
		for (E currentNewListObj : newList) {
			boolean foundInList = false;
			for (E currentOrigListObj : origList) {
				if (currentNewListObj.equals(currentOrigListObj)) {
					foundInList = true;
					origList.remove(currentOrigListObj);
					break;
				}
			}
			if (!foundInList) {
				toAdd.add(currentNewListObj);
			}
			toDel = origList;
		}
		returnList.add(toAdd);
		returnList.add(toDel);
		return returnList;
	}
	public static boolean isStringInArray(String str, String[] arr) {
		if (str != null && arr != null) {
			for (String anArr : arr) {
				if (str.equals(anArr)) {
					return true;
				}
			}
		}
		return false;
	}
	public static Boolean isInNormalNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiNormal() == null || concept.getLowNormal() == null) {
			return false;
		}
		return (value <= concept.getHiNormal() && value >= concept.getLowNormal());
	}
	public static Boolean isInCriticalNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiCritical() == null || concept.getLowCritical() == null) {
			return false;
		}
		return (value <= concept.getHiCritical() && value >= concept.getLowCritical());
	}
	public static Boolean isInAbsoluteNumericRange(Float value, ConceptNumeric concept) {
		if (concept.getHiAbsolute() == null || concept.getLowAbsolute() == null) {
			return false;
		}
		return (value <= concept.getHiAbsolute() && value >= concept.getLowAbsolute());
	}
	public static Boolean isValidNumericValue(Float value, ConceptNumeric concept) {
		if (concept.getHiAbsolute() == null || concept.getLowAbsolute() == null) {
			return true;
		}
		return (value <= concept.getHiAbsolute() && value >= concept.getLowAbsolute());
	}
	public static String getFileAsString(File file) throws IOException {
		StringBuilder fileData = new StringBuilder(1000);
		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8));
		char[] buf = new char[1024];
		int numRead;
		while ((numRead = reader.read(buf)) != -1) {
			String readData = String.valueOf(buf, 0, numRead);
			fileData.append(readData);
			buf = new char[1024];
		}
		reader.close();
		return fileData.toString();
	}
	public static byte[] getFileAsBytes(File file) throws IOException {
		FileInputStream fileInputStream = null;
		try {
			fileInputStream = new FileInputStream(file);
			byte[] b = new byte[fileInputStream.available()];
			fileInputStream.read(b);
			return b;
		}
		catch (Exception e) {
			log.error("Unable to get file as byte array", e);
		}
		finally {
			if (fileInputStream != null) {
				try {
					fileInputStream.close();
				}
				catch (IOException io) {
					log.warn("Couldn't close fileInputStream: " + io);
				}
			}
		}
		return null;
	}
	public static void copyFile(InputStream inputStream, OutputStream outputStream) throws IOException {
		if (inputStream == null || outputStream == null) {
			if (outputStream != null) {
				IOUtils.closeQuietly(outputStream);
			}
			return;
		}
		try {
			IOUtils.copy(inputStream, outputStream);
		}
		finally {
			IOUtils.closeQuietly(outputStream);
		}
	}
	public static String getFileMimeType(File file) {
		if (mimetypesFileTypeMap == null) {
			synchronized (OpenmrsUtil.class) {
				mimetypesFileTypeMap = new MimetypesFileTypeMap();
			}
		}
		return mimetypesFileTypeMap.getContentType(file);
	}
	public static boolean folderContains(File folder, String filename) {
		if (folder == null) {
			return false;
		}
		if (!folder.isDirectory()) {
			return false;
		}
		File[] files = folder.listFiles();
		if (files == null) {
			return false;
		}
		for (File f : files) {
			if (f.getName().equals(filename)) {
				return true;
			}
		}
		return false;
	}
	public static Map<String, String> getCorePrivileges() {
		Map<String, String> corePrivileges = new HashMap<>();
		Set<Class<?>> classes = OpenmrsClassScanner.getInstance().getClassesWithAnnotation(HasAddOnStartupPrivileges.class);
		for (Class cls : classes) {
			Field[] flds = cls.getDeclaredFields();
			for (Field fld : flds) {
				String fieldValue = null;
				AddOnStartup privilegeAnnotation = fld.getAnnotation(AddOnStartup.class);
				if (null == privilegeAnnotation) {
					continue;
				}
				if (!privilegeAnnotation.core()) {
					continue;
				}
				try {
					fieldValue = (String) fld.get(null);
				}
				catch (IllegalAccessException e) {
					log.error("Field is inaccessible.", e);
				}
				corePrivileges.put(fieldValue, privilegeAnnotation.description());
			}
		}
		for (org.openmrs.Privilege privilege : ModuleFactory.getPrivileges()) {
			corePrivileges.put(privilege.getPrivilege(), privilege.getDescription());
		}
		return corePrivileges;
	}
	public static Map<String, String> getCoreRoles() {
		Map<String, String> roles = new HashMap<>();
		Field[] flds = RoleConstants.class.getDeclaredFields();
		for (Field fld : flds) {
			String fieldValue = null;
			AddOnStartup roleAnnotation = fld.getAnnotation(AddOnStartup.class);
			if (null == roleAnnotation) {
				continue;
			}
			if (!roleAnnotation.core()) {
				continue;
			}
			try {
				fieldValue = (String) fld.get(null);
			}
			catch (IllegalAccessException e) {
				log.error("Field is inaccessible.", e);
			}
			roles.put(fieldValue, roleAnnotation.description());
		}
		return roles;
	}
	public static void startup(Properties p) {
		String val = p.getProperty("obscure_patients", null);
		if (val != null && "true".equalsIgnoreCase(val)) {
			OpenmrsConstants.OBSCURE_PATIENTS = true;
		}
		val = p.getProperty("obscure_patients.family_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_FAMILY_NAME = val;
		}
		val = p.getProperty("obscure_patients.given_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_GIVEN_NAME = val;
		}
		val = p.getProperty("obscure_patients.middle_name", null);
		if (val != null) {
			OpenmrsConstants.OBSCURE_PATIENTS_MIDDLE_NAME = val;
		}
		val = p.getProperty("connection.database_name", null);
		if (val == null) {
			val = p.getProperty("connection.url", null);
			if (val != null) {
				try {
					int endIndex = val.lastIndexOf("?");
					if (endIndex == -1) {
						endIndex = val.length();
					}
					int startIndex = val.lastIndexOf("/", endIndex);
					val = val.substring(startIndex + 1, endIndex);
					OpenmrsConstants.DATABASE_NAME = val;
				}
				catch (Exception e) {
					log.error(MarkerFactory.getMarker("FATAL"), "Database name cannot be configured from 'connection.url' ."
					        + "Either supply 'connection.database_name' or correct the url",
					    e);
				}
			}
		}
		val = p.getProperty("connection.database_business_name", null);
		if (val == null) {
			val = OpenmrsConstants.DATABASE_NAME;
		}
		OpenmrsConstants.DATABASE_BUSINESS_NAME = val;
	}
	@Deprecated
	public static MemoryAppender getMemoryAppender() {
		return new MemoryAppender(OpenmrsLoggingUtil.getMemoryAppender());
	}
	@Logging(ignore = true)
	@Deprecated
	public static void applyLogLevels() {
		OpenmrsLoggingUtil.applyLogLevels();
	}
	@Deprecated
	public static void setupLogAppenders() {
		OpenmrsLoggingUtil.reloadLoggingConfiguration();
	}
	@Deprecated
	public static void applyLogLevel(String logClass, String logLevel) {
		OpenmrsLoggingUtil.applyLogLevel(logClass, logLevel);
	}
	public static Map<String, String> parseParameterList(String paramList) {
		Map<String, String> ret = new HashMap<>();
		if (paramList != null && paramList.length() > 0) {
			String[] args = paramList.split("\\|");
			for (String s : args) {
				int ind = s.indexOf('=');
				if (ind <= 0) {
					throw new IllegalArgumentException(
					        "Misformed argument in dynamic page specification string: '" + s + "' is not 'key=value'.");
				}
				String name = s.substring(0, ind);
				String value = s.substring(ind + 1);
				ret.put(name, value);
			}
		}
		return ret;
	}
	public static <Arg1, Arg2 extends Arg1> boolean nullSafeEquals(Arg1 d1, Arg2 d2) {
		if (d1 == null) {
			return d2 == null;
		} else if (d2 == null) {
			return false;
		}
		return (d1 instanceof Date && d2 instanceof Date) ? compare((Date) d1, (Date) d2) == 0 : d1.equals(d2);
	}
	public static int compare(Date d1, Date d2) {
		if (d1 instanceof Timestamp && d2 instanceof Timestamp) {
			return d1.compareTo(d2);
		}
		if (d1 instanceof Timestamp) {
			d1 = new Date(d1.getTime());
		}
		if (d2 instanceof Timestamp) {
			d2 = new Date(d2.getTime());
		}
		return d1.compareTo(d2);
	}
	public static int compareWithNullAsEarliest(Date d1, Date d2) {
		if (d1 == null && d2 == null) {
			return 0;
		}
		if (d1 == null) {
			return -1;
		} else if (d2 == null) {
			return 1;
		} else {
			return compare(d1, d2);
		}
	}
	public static int compareWithNullAsLatest(Date d1, Date d2) {
		if (d1 == null && d2 == null) {
			return 0;
		}
		if (d1 == null) {
			return 1;
		} else if (d2 == null) {
			return -1;
		} else {
			return compare(d1, d2);
		}
	}
	public static <E extends Comparable<E>> int compareWithNullAsLowest(E c1, E c2) {
		if (c1 == null && c2 == null) {
			return 0;
		}
		if (c1 == null) {
			return -1;
		} else if (c2 == null) {
			return 1;
		} else {
			return c1.compareTo(c2);
		}
	}
	public static <E extends Comparable<E>> int compareWithNullAsGreatest(E c1, E c2) {
		if (c1 == null && c2 == null) {
			return 0;
		}
		if (c1 == null) {
			return 1;
		} else if (c2 == null) {
			return -1;
		} else {
			return c1.compareTo(c2);
		}
	}
	@Deprecated
	public static <E> String join(Collection<E> c, String separator) {
		if (c == null) {
			return "";
		}
		StringBuilder ret = new StringBuilder();
		for (Iterator<E> i = c.iterator(); i.hasNext();) {
			ret.append(i.next());
			if (i.hasNext()) {
				ret.append(separator);
			}
		}
		return ret.toString();
	}
	public static Set<Concept> conceptSetHelper(String descriptor) {
		Set<Concept> ret = new HashSet<>();
		if (descriptor == null || descriptor.length() == 0) {
			return ret;
		}
		ConceptService cs = Context.getConceptService();
		for (StringTokenizer st = new StringTokenizer(descriptor, "|"); st.hasMoreTokens();) {
			String s = st.nextToken().trim();
			boolean isSet = s.startsWith("set:");
			if (isSet) {
				s = s.substring(4).trim();
			}
			Concept c = null;
			if (s.startsWith("name:")) {
				String name = s.substring(5).trim();
				c = cs.getConceptByName(name);
			} else {
				try {
					c = cs.getConcept(Integer.valueOf(s.trim()));
				}
				catch (Exception ex) {}
			}
			if (c != null) {
				if (isSet) {
					List<Concept> inSet = cs.getConceptsByConceptSet(c);
					ret.addAll(inSet);
				} else {
					ret.add(c);
				}
			}
		}
		return ret;
	}
	public static List<Concept> delimitedStringToConceptList(String delimitedString, String delimiter) {
		List<Concept> ret = null;
		if (delimitedString != null) {
			String[] tokens = delimitedString.split(delimiter);
			for (String token : tokens) {
				Integer conceptId;
				try {
					conceptId = Integer.valueOf(token);
				}
				catch (NumberFormatException nfe) {
					conceptId = null;
				}
				Concept c;
				if (conceptId != null) {
					c = Context.getConceptService().getConcept(conceptId);
				} else {
					c = Context.getConceptService().getConceptByName(token);
				}
				if (c != null) {
					if (ret == null) {
						ret = new ArrayList<>();
					}
					ret.add(c);
				}
			}
		}
		return ret;
	}
	public static Map<String, Concept> delimitedStringToConceptMap(String delimitedString, String delimiter) {
		Map<String, Concept> ret = null;
		if (delimitedString != null) {
			String[] tokens = delimitedString.split(delimiter);
			for (String token : tokens) {
				Concept c = Context.getConceptService().getConcept(token);
				if (c != null) {
					if (ret == null) {
						ret = new HashMap<>();
					}
					ret.put(token, c);
				}
			}
		}
		return ret;
	}
	public static List<Concept> conceptListHelper(String descriptor) {
		Set<Concept> ret = new LinkedHashSet<>();
		if (descriptor == null || descriptor.length() == 0) {
			return Collections.emptyList();
		}
		ConceptService cs = Context.getConceptService();
		for (StringTokenizer st = new StringTokenizer(descriptor, "|"); st.hasMoreTokens();) {
			String s = st.nextToken().trim();
			boolean isSet = s.startsWith("set:");
			if (isSet) {
				s = s.substring(4).trim();
			}
			Concept c = null;
			if (s.startsWith("name:")) {
				String name = s.substring(5).trim();
				c = cs.getConceptByName(name);
			} else {
				try {
					c = cs.getConcept(Integer.valueOf(s.trim()));
				}
				catch (Exception ex) {}
			}
			if (c != null) {
				if (isSet) {
					List<Concept> inSet = cs.getConceptsByConceptSet(c);
					ret.addAll(inSet);
				} else {
					ret.add(c);
				}
			}
		}
		return new ArrayList<>(ret);
	}
	public static Date getLastMomentOfDay(Date day) {
		Calendar calender = Calendar.getInstance();
		calender.setTime(day);
		calender.set(Calendar.HOUR_OF_DAY, 23);
		calender.set(Calendar.MINUTE, 59);
		calender.set(Calendar.SECOND, 59);
		calender.set(Calendar.MILLISECOND, 999);
		return calender.getTime();
	}
	public static Date firstSecondOfDay(Date date) {
		if (date == null) {
			return null;
		}
		Calendar c = Calendar.getInstance();
		c.setTime(date);
		c.set(Calendar.HOUR_OF_DAY, 0);
		c.set(Calendar.MINUTE, 0);
		c.set(Calendar.SECOND, 0);
		c.set(Calendar.MILLISECOND, 0);
		return c.getTime();
	}
	public static Date safeDate(Date d1) {
		return new Date(d1.getTime());
	}
	public static boolean deleteDirectory(File dir) throws IOException {
		if (!dir.exists() || !dir.isDirectory()) {
			throw new IOException("Could not delete directory '" + dir.getAbsolutePath() + "' (not a directory)");
		}
		log.debug("Deleting directory {}", dir.getAbsolutePath());
		File[] fileList = dir.listFiles();
		if (fileList == null) {
			return false;
		}
		for (File f : fileList) {
			if (f.isDirectory()) {
				deleteDirectory(f);
			}
			boolean success = f.delete();
			if (log.isDebugEnabled()) {
				log.debug("   deleting " + f.getName() + " : " + (success ? "ok" : "failed"));
			}
			if (!success) {
				f.deleteOnExit();
			}
		}
		boolean success = dir.delete();
		if (!success) {
			log.warn("   ...could not remove directory: " + dir.getAbsolutePath());
			dir.deleteOnExit();
		}
		if (success && log.isDebugEnabled()) {
			log.debug("   ...and directory itself");
		}
		return success;
	}
	public static File url2file(final URL url) {
		if (url == null || !"file".equalsIgnoreCase(url.getProtocol())) {
			return null;
		}
		return new File(url.getFile().replaceAll("%20", " "));
	}
	public static InputStream getResourceInputStream(final URL url) throws IOException {
		File file = url2file(url);
		if (file != null) {
			return new BufferedInputStream(new FileInputStream(file));
		}
		if (!"jar".equalsIgnoreCase(url.getProtocol())) {
			return url.openStream();
		}
		String urlStr = url.toExternalForm();
		if (urlStr.endsWith("!/")) {
			throw new FileNotFoundException(url.toExternalForm());
		}
		int p = urlStr.indexOf("!/");
		if (p == -1) {
			throw new MalformedURLException(url.toExternalForm());
		}
		String path = urlStr.substring(p + 2);
		file = url2file(new URL(urlStr.substring(4, p)));
		if (file == null) {
			return url.openStream();
		}
		try (JarFile jarFile = new JarFile(file)) {
			ZipEntry entry = jarFile.getEntry(path);
			if (entry == null) {
				throw new FileNotFoundException(url.toExternalForm());
			}
			try (InputStream in = jarFile.getInputStream(entry)) {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				copyFile(in, out);
				return new ByteArrayInputStream(out.toByteArray());
			}
		}
	}
	public static String getApplicationDataDirectory() {
		return getApplicationDataDirectoryAsFile().toString();
	}
	public static File getApplicationDataDirectoryAsFile() {
		String filepath = null;
		final String openmrsDir = "OpenMRS";
		String systemProperty = System.getProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY);
		if (StringUtils.isNotBlank(systemProperty)) {
			filepath = systemProperty;
		} else {
			String runtimeProperty = Context.getRuntimeProperties()
				.getProperty(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY, null);
			if (StringUtils.isNotBlank(runtimeProperty)) {
				filepath = runtimeProperty;
			}
		}
		if (filepath == null) {
			if (OpenmrsConstants.UNIX_BASED_OPERATING_SYSTEM) {
				filepath = Paths.get(System.getProperty("user.home"), "." + openmrsDir).toString();
				if (!canWrite(new File(filepath))) {
					log.warn("Unable to write to users home dir, fallback to: "
						+ OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_UNIX);
					filepath = Paths.get(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_UNIX, openmrsDir).toString();
				}
			} else {
				filepath = Paths.get(System.getProperty("user.home"), "Application Data", "OpenMRS").toString();
				if (!new File(filepath).exists()) {
					filepath = Paths.get(System.getenv("appdata"), "OpenMRS").toString();
				}
				if (!canWrite(new File(filepath))) {
					log.warn("Unable to write to users home dir, fallback to: "
						+ OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_WIN);
					filepath = OpenmrsConstants.APPLICATION_DATA_DIRECTORY_FALLBACK_WIN + File.separator + openmrsDir;
				}
			}
			filepath = filepath + File.separator;
		}
		File folder = new File(filepath);
		if (!folder.exists()) {
			folder.mkdirs();
		}
		return folder;
	}
	public static void setApplicationDataDirectory(String path) {
		if (StringUtils.isBlank(path)) {
			System.clearProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY);
		} else {
			System.setProperty(OpenmrsConstants.KEY_OPENMRS_APPLICATION_DATA_DIRECTORY, path);
		}
	}
	private static boolean canWrite(File folder) {
		try {
			if (!folder.exists()) {
				folder.mkdirs();
			}
			return folder.canWrite();
		}
		catch (SecurityException ex) {
		}
		return false;
	}
	@Deprecated
	public static String getOpenmrsLogLocation() {
		return OpenmrsLoggingUtil.getOpenmrsLogLocation();
	}
	public static void validateJavaVersion() {
		if (System.getProperty("java.version").matches("1\\.[0-7]\\.(.*)")) {
			throw new APIException(
				"OpenMRS " + OpenmrsConstants.OPENMRS_VERSION_SHORT + " requires Java 8 and above, but is running under " + 
					System.getProperty("java.version"));
		}
	}
	public static File getDirectoryInApplicationDataDirectory(String folderName) throws APIException {
		File folder = new File(folderName);
		if (!folder.isAbsolute()) {
			folder = new File(getApplicationDataDirectoryAsFile(), folderName);
		}
		if (!folder.exists()) {
			log.warn("'" + folder.getAbsolutePath() + "' doesn't exist.  Creating directories now.");
			folder.mkdirs();
		}
		if (!folder.isDirectory()) {
			throw new APIException("should.be.directory", new Object[] { folder.getAbsolutePath() });
		}
		return folder;
	}
	public static void saveDocument(Document doc, File outFile) {
		OutputStream outStream = null;
		try {
			outStream = new FileOutputStream(outFile);
			TransformerFactory tFactory = TransformerFactory.newInstance();
			Transformer transformer = tFactory.newTransformer();
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			DocumentType doctype = doc.getDoctype();
			if (doctype != null) {
				transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctype.getPublicId());
				transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctype.getSystemId());
			}
			DOMSource source = new DOMSource(doc);
			StreamResult result = new StreamResult(outStream);
			transformer.transform(source, result);
		}
		catch (TransformerException e) {
			throw new ModuleException("Error while saving dwrmodulexml back to dwr-modules.xml", e);
		}
		catch (FileNotFoundException e) {
			throw new ModuleException(outFile.getAbsolutePath() + " file doesn't exist.", e);
		}
		finally {
			try {
				if (outStream != null) {
					outStream.close();
				}
			}
			catch (Exception e) {
				log.warn("Unable to close outstream", e);
			}
		}
	}
	public static List<Integer> delimitedStringToIntegerList(String delimitedString, String delimiter) {
		List<Integer> ret = new ArrayList<>();
		String[] tokens = delimitedString.split(delimiter);
		for (String token : tokens) {
			token = token.trim();
			if (token.length() != 0) {
				ret.add(Integer.valueOf(token));
			}
		}
		return ret;
	}
	public static boolean stringStartsWith(String str, String[] prefixes) {
		for (String prefix : prefixes) {
			if (StringUtils.startsWith(str, prefix)) {
				return true;
			}
		}
		return false;
	}
	public static boolean isConceptInList(Concept concept, List<Concept> list) {
		boolean ret = false;
		if (concept != null && list != null) {
			for (Concept c : list) {
				if (c.equals(concept)) {
					ret = true;
					break;
				}
			}
		}
		return ret;
	}
	public static Date fromDateHelper(Date comparisonDate, Integer withinLastDays, Integer withinLastMonths,
	        Integer untilDaysAgo, Integer untilMonthsAgo, Date sinceDate, Date untilDate) {
		Date ret = null;
		if (withinLastDays != null || withinLastMonths != null) {
			Calendar gc = Calendar.getInstance();
			gc.setTime(comparisonDate != null ? comparisonDate : new Date());
			if (withinLastDays != null) {
				gc.add(Calendar.DAY_OF_MONTH, -withinLastDays);
			}
			if (withinLastMonths != null) {
				gc.add(Calendar.MONTH, -withinLastMonths);
			}
			ret = gc.getTime();
		}
		if (sinceDate != null && (ret == null || sinceDate.after(ret))) {
			ret = sinceDate;
		}
		return ret;
	}
	public static Date toDateHelper(Date comparisonDate, Integer withinLastDays, Integer withinLastMonths,
	        Integer untilDaysAgo, Integer untilMonthsAgo, Date sinceDate, Date untilDate) {
		Date ret = null;
		if (untilDaysAgo != null || untilMonthsAgo != null) {
			Calendar gc = Calendar.getInstance();
			gc.setTime(comparisonDate != null ? comparisonDate : new Date());
			if (untilDaysAgo != null) {
				gc.add(Calendar.DAY_OF_MONTH, -untilDaysAgo);
			}
			if (untilMonthsAgo != null) {
				gc.add(Calendar.MONTH, -untilMonthsAgo);
			}
			ret = gc.getTime();
		}
		if (untilDate != null && (ret == null || untilDate.before(ret))) {
			ret = untilDate;
		}
		return ret;
	}
	public static <T> boolean containsAny(Collection<T> collection, Collection<T> elements) {
		for (T obj : elements) {
			if (collection.contains(obj)) {
				return true;
			}
		}
		return false;
	}
	public static <K, V> void addToSetMap(Map<K, Set<V>> map, K key, V obj) {
		Set<V> set = map.computeIfAbsent(key, k -> new HashSet<>());
		set.add(obj);
	}
	public static <K, V> void addToListMap(Map<K, List<V>> map, K key, V obj) {
		List<V> list = map.computeIfAbsent(key, k -> new ArrayList<>());
		list.add(obj);
	}
	public static SimpleDateFormat getDateFormat(Locale locale) {
		if (dateFormatCache.containsKey(locale)) {
			return (SimpleDateFormat) dateFormatCache.get(locale).clone();
		}
		SimpleDateFormat sdf = new OpenmrsDateFormat((SimpleDateFormat) DateFormat.getDateInstance(DateFormat.SHORT, locale),
		        locale);
		String pattern = sdf.toPattern();
		if (!pattern.contains("yyyy")) {
			String regex = "yy";
			if (!pattern.contains("yy")) {
				regex = "y";
			}
			pattern = pattern.replaceFirst(regex, "yyyy");
			sdf.applyPattern(pattern);
		}
		if (!pattern.contains("MM")) {
			pattern = pattern.replaceFirst("M", "MM");
			sdf.applyPattern(pattern);
		}
		if (!pattern.contains("dd")) {
			pattern = pattern.replaceFirst("d", "dd");
			sdf.applyPattern(pattern);
		}
		dateFormatCache.put(locale, sdf);
		return (SimpleDateFormat) sdf.clone();
	}
	public static SimpleDateFormat getTimeFormat(Locale locale) {
		if (timeFormatCache.containsKey(locale)) {
			return (SimpleDateFormat) timeFormatCache.get(locale).clone();
		}
		SimpleDateFormat sdf = (SimpleDateFormat) DateFormat.getTimeInstance(DateFormat.SHORT, locale);
		String pattern = sdf.toPattern();
		if (!(pattern.contains("hh") || pattern.contains("HH"))) {
			pattern = pattern.replaceFirst("h", "hh").replaceFirst("H", "HH");
			sdf.applyPattern(pattern);
		}
		timeFormatCache.put(locale, sdf);
		return (SimpleDateFormat) sdf.clone();
	}
	public static SimpleDateFormat getDateTimeFormat(Locale locale) {
		SimpleDateFormat dateFormat;
		SimpleDateFormat timeFormat;
		dateFormat = getDateFormat(locale);
		timeFormat = getTimeFormat(locale);
		String pattern = dateFormat.toPattern() + " " + timeFormat.toPattern();
		SimpleDateFormat sdf = new SimpleDateFormat();
		sdf.applyPattern(pattern);
		return sdf;
	}
	@SuppressWarnings("unchecked")
	public static Object parse(String string, Class clazz) {
		try {
			Method valueOfMethod = null;
			try {
				valueOfMethod = clazz.getMethod("valueOf", String.class);
			}
			catch (NoSuchMethodException ex) {}
			if (valueOfMethod != null) {
				return valueOfMethod.invoke(null, string);
			} else if (clazz.isEnum()) {
				List<Enum> constants = Arrays.asList((Enum[]) clazz.getEnumConstants());
				for (Enum e : constants) {
					if (e.toString().equals(string)) {
						return e;
					}
				}
				throw new IllegalArgumentException(string + " is not a legal value of enum class " + clazz);
			} else if (String.class.equals(clazz)) {
				return string;
			} else if (Location.class.equals(clazz)) {
				try {
					Integer.parseInt(string);
					LocationEditor ed = new LocationEditor();
					ed.setAsText(string);
					return ed.getValue();
				}
				catch (NumberFormatException ex) {
					return Context.getLocationService().getLocation(string);
				}
			} else if (Concept.class.equals(clazz)) {
				ConceptEditor ed = new ConceptEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Program.class.equals(clazz)) {
				ProgramEditor ed = new ProgramEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (ProgramWorkflowState.class.equals(clazz)) {
				ProgramWorkflowStateEditor ed = new ProgramWorkflowStateEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (EncounterType.class.equals(clazz)) {
				EncounterTypeEditor ed = new EncounterTypeEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Form.class.equals(clazz)) {
				FormEditor ed = new FormEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Drug.class.equals(clazz)) {
				DrugEditor ed = new DrugEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (PersonAttributeType.class.equals(clazz)) {
				PersonAttributeTypeEditor ed = new PersonAttributeTypeEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Cohort.class.equals(clazz)) {
				CohortEditor ed = new CohortEditor();
				ed.setAsText(string);
				return ed.getValue();
			} else if (Date.class.equals(clazz)) {
				CustomDateEditor ed = new CustomDateEditor(Context.getDateFormat(), true, 10);
				ed.setAsText(string);
				return ed.getValue();
			} else if (Object.class.equals(clazz)) {
				return string;
			} else {
				throw new IllegalArgumentException("Don't know how to handle class: " + clazz);
			}
		}
		catch (Exception ex) {
			log.error("error converting \"" + string + "\" to " + clazz, ex);
			throw new IllegalArgumentException(ex);
		}
	}
	public static boolean collectionContains(Collection<?> objects, Object obj) {
		if (obj == null || objects == null) {
			return false;
		}
		for (Object o : objects) {
			if (o != null && o.equals(obj)) {
				return true;
			}
		}
		return false;
	}
	public static File getOutFile(File dir, Date date, User user) {
		Random gen = new Random();
		File outFile;
		do {
			DateFormat dateFormat = new SimpleDateFormat("yyyy.MM.dd-HHmm-ssSSS");
			if (date == null) {
				date = new Date();
			}
			StringBuilder filename = new StringBuilder();
			filename.append(dateFormat.format(date));
			if (user != null) {
				filename.append("-");
				filename.append(user.getUserId());
				filename.append("-");
			}
			filename.append(gen.nextInt() * 10000);
			filename.append(".xml");
			outFile = new File(dir, filename.toString());
			date = null;
		} while (outFile.exists());
		return outFile;
	}
	public static String generateUid(Integer size) {
		Random gen = new Random();
		StringBuilder sb = new StringBuilder(size);
		for (int i = 0; i < size; i++) {
			int ch = gen.nextInt() * 62;
			if (ch < 10) {
				sb.append(ch);
			} else if (ch < 36) {
				sb.append((char) (ch - 10 + 'a'));
			} else {
				sb.append((char) (ch - 36 + 'A'));
			}
		}
		return sb.toString();
	}
	public static String generateUid() {
		return generateUid(20);
	}
	public static void storeProperties(Properties properties, File file, String comment) {
		OutputStream outStream = null;
		try {
			outStream = new FileOutputStream(file, true);
			storeProperties(properties, outStream, comment);
		}
		catch (IOException ex) {
			log.error("Unable to create file " + file.getAbsolutePath() + " in storeProperties routine.");
		}
		finally {
			try {
				if (outStream != null) {
					outStream.close();
				}
			}
			catch (IOException ioe) {
			}
		}
	}
	public static void storeProperties(Properties properties, OutputStream outStream, String comment) {
		try {
			Charset utf8 = StandardCharsets.UTF_8;
			properties.store(new OutputStreamWriter(outStream, utf8), comment);
		}
		catch (FileNotFoundException fnfe) {
			log.error("target file not found" + fnfe);
		}
		catch (UnsupportedEncodingException ex) { 
			log.error("unsupported encoding error hit" + ex);
		}
		catch (IOException ioex) {
			log.error("IO exception encountered trying to append to properties file" + ioex);
		}
	}
	public static void loadProperties(Properties props, InputStream inputStream) {
		InputStreamReader reader = null;
		try {
			reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);
			props.load(reader);
		}
		catch (FileNotFoundException fnfe) {
			log.error("Unable to find properties file" + fnfe);
		}
		catch (UnsupportedEncodingException uee) {
			log.error("Unsupported encoding used in properties file" + uee);
		}
		catch (IOException ioe) {
			log.error("Unable to read properties from properties file" + ioe);
		}
		finally {
			try {
				if (reader != null) {
					reader.close();
				}
			}
			catch (IOException ioe) {
				log.error("Unable to close properties file " + ioe);
			}
		}
	}
	public static void loadProperties(Properties props, File propertyFile) {
		try {
			loadProperties(props, new FileInputStream(propertyFile));
		}
		catch (FileNotFoundException fnfe) {
			log.error("Unable to find properties file" + fnfe);
		}
	}
	public static String getMessage(String code, Object... args) {
		Locale l = Context.getLocale();
		try {
			String translation = Context.getMessageSourceService().getMessage(code, args, l);
			if (translation != null) {
				return translation;
			}
		}
		catch (NoSuchMessageException e) {
			log.warn("Message code <" + code + "> not found for locale " + l);
		}
		catch (APIException apiEx) {
			log.debug("Unable to get code: " + code, apiEx);
			return code;
		}
		return code;
	}
	public static void validatePassword(String username, String password, String systemId) throws PasswordException {
		String userGp = "true";
		String lengthGp = "8";
		String caseGp = "true";
		String digitGp = "true";
		String nonDigitGp = "true";
		String regexGp = null;
		AdministrationService svc = null;
		try {
			svc = Context.getAdministrationService();
		}
		catch (APIException apiEx) {
			log.debug("Unable to get global properties", apiEx);
		}
		if (svc != null && Context.isSessionOpen()) {
			userGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_CANNOT_MATCH_USERNAME_OR_SYSTEMID, userGp);
			lengthGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_MINIMUM_LENGTH, lengthGp);
			caseGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_UPPER_AND_LOWER_CASE, caseGp);
			digitGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_DIGIT, digitGp);
			nonDigitGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_REQUIRES_NON_DIGIT, nonDigitGp);
			regexGp = svc.getGlobalProperty(OpenmrsConstants.GP_PASSWORD_CUSTOM_REGEX, regexGp);
		}
		if (password == null) {
			throw new WeakPasswordException();
		}
		if ("true".equals(userGp) && (password.equals(username) || password.equals(systemId))) {
			throw new WeakPasswordException();
		}
		if (StringUtils.isNotEmpty(lengthGp)) {
			try {
				int minLength = Integer.parseInt(lengthGp);
				if (password.length() < minLength) {
					throw new ShortPasswordException(getMessage("error.password.length", lengthGp));
				}
			}
			catch (NumberFormatException nfe) {
				log.warn(
				    "Error in global property <" + OpenmrsConstants.GP_PASSWORD_MINIMUM_LENGTH + "> must be an Integer");
			}
		}
		if ("true".equals(caseGp) && !containsUpperAndLowerCase(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireMixedCase"));
		}
		if ("true".equals(digitGp) && !containsDigit(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireNumber"));
		}
		if ("true".equals(nonDigitGp) && containsOnlyDigits(password)) {
			throw new InvalidCharactersPasswordException(getMessage("error.password.requireLetter"));
		}
		if (StringUtils.isNotEmpty(regexGp)) {
			try {
				Pattern pattern = Pattern.compile(regexGp);
				Matcher matcher = pattern.matcher(password);
				if (!matcher.matches()) {
					throw new InvalidCharactersPasswordException(getMessage("error.password.different"));
				}
			}
			catch (PatternSyntaxException pse) {
				log.warn("Invalid regex of " + regexGp + " defined in global property <"
				        + OpenmrsConstants.GP_PASSWORD_CUSTOM_REGEX + ">.");
			}
		}
	}
	public static boolean containsUpperAndLowerCase(String test) {
		if (test != null) {
			Pattern pattern = Pattern.compile("^(?=.*?[A-Z])(?=.*?[a-z])[\\w|\\W]*$");
			Matcher matcher = pattern.matcher(test);
			return matcher.matches();
		}
		return false;
	}
	public static boolean containsOnlyDigits(String test) {
		if (test != null) {
			for (char c : test.toCharArray()) {
				if (!Character.isDigit(c)) {
					return false;
				}
			}
		}
		return StringUtils.isNotEmpty(test);
	}
	public static boolean containsDigit(String test) {
		if (test != null) {
			for (char c : test.toCharArray()) {
				if (Character.isDigit(c)) {
					return true;
				}
			}
		}
		return false;
	}
	public static void closeStream(Closeable closableStream) {
		if (closableStream != null) {
			try {
				closableStream.close();
			}
			catch (IOException io) {
				log.trace("Error occurred while closing stream", io);
			}
		}
	}
	public static String shortenedStackTrace(String stackTrace) {
		if (stackTrace == null) {
			return null;
		}
		List<String> results = new ArrayList<>();
		final Pattern exclude = Pattern.compile("(org.springframework.|java.lang.reflect.Method.invoke|sun.reflect.)");
		boolean found = false;
		for (String line : stackTrace.split("\n")) {
			Matcher m = exclude.matcher(line);
			if (m.find()) {
				found = true;
			} else {
				if (found) {
					found = false;
					results.add("\tat [ignored] ...");
				}
				results.add(line);
			}
		}
		return StringUtils.join(results, "\n");
	}
	public static Properties getRuntimeProperties(String applicationName) {
		if (applicationName == null) {
			applicationName = "openmrs";
		}
		String pathName;
		pathName = getRuntimePropertiesFilePathName(applicationName);
		FileInputStream propertyStream = null;
		try {
			if (pathName != null) {
				propertyStream = new FileInputStream(pathName);
			}
		}
		catch (FileNotFoundException e) {
			log.warn("Unable to find a runtime properties file at " + new File(pathName).getAbsolutePath());
		}
		try {
			if (propertyStream == null) {
				throw new IOException("Could not find a runtime properties file named " + pathName
				        + " in the OpenMRS application data directory, or the current directory");
			}
			Properties props = new Properties();
			OpenmrsUtil.loadProperties(props, propertyStream);
			propertyStream.close();
			log.info("Using runtime properties file: " + pathName);
			return props;
		}
		catch (Exception ex) {
			log.info("Got an error while attempting to load the runtime properties", ex);
			log.warn(
			    "Unable to find a runtime properties file. Initial setup is needed. View the webapp to run the setup wizard.");
			return null;
		}
	}
	public static boolean isTestMode() {
		return "true".equalsIgnoreCase(System.getProperty("FUNCTIONAL_TEST_MODE"));
	}
	public static String getRuntimePropertiesFilePathName(String applicationName) {
		if (applicationName == null) {
			applicationName = "openmrs";
		}
		String defaultFileName = applicationName + "-runtime.properties";
		String fileNameInTestMode = getRuntimePropertiesFileNameInTestMode();
		String pathName = fileNameInTestMode != null ? fileNameInTestMode : defaultFileName;
		log.debug("Attempting to look for properties file in current directory: " + pathName);
		if (new File(pathName).exists()) {
			return pathName;
		} else {
			log.warn("Unable to find a runtime properties file at " + new File(pathName).getAbsolutePath());
		}
		String envVarName = applicationName.toUpperCase() + "_RUNTIME_PROPERTIES_FILE";
		String envFileName = System.getenv(envVarName);
		if (envFileName != null) {
			log.debug("Atempting to look for runtime properties from: " + pathName);
			if (new File(envFileName).exists()) {
				return envFileName;
			} else {
				log.warn("Unable to find properties file with path: " + pathName + ". (derived from environment variable "
				        + envVarName + ")");
			}
		} else {
			log.info("Couldn't find an environment variable named " + envVarName);
			if (log.isDebugEnabled()) {
				log.debug("Available environment variables are named: " + System.getenv().keySet());
			}
		}
		File file = new File(getApplicationDataDirectory(), pathName);
		pathName = file.getAbsolutePath();
		log.debug("Attempting to look for property file from: " + pathName);
		if (file.exists()) {
			return pathName;
		} else {
			log.warn("Unable to find properties file: " + pathName);
		}
		return null;
	}
	public static String getRuntimePropertiesFileNameInTestMode() {
		String filename = null;
		if (isTestMode()) {
			log.info("In functional testing mode. Ignoring the existing runtime properties file");
			filename = getOpenMRSVersionInTestMode() + "-test-runtime.properties";
		}
		return filename;
	}
	public static String getOpenMRSVersionInTestMode() {
		return System.getProperty("OPENMRS_VERSION", "openmrs");
	}
	public static boolean nullSafeEqualsIgnoreCase(String s1, String s2) {
		if (s1 == null) {
			return s2 == null;
		} else if (s2 == null) {
			return false;
		}
		return s1.equalsIgnoreCase(s2);
	}
	public static Integer convertToInteger(Long longValue) {
		if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {
			throw new IllegalArgumentException(longValue + " cannot be cast to Integer without changing its value.");
		}
		return longValue.intValue();
	}
	public static boolean isYesterday(Date date) {
		if (date == null) {
			return false;
		}
		Calendar c1 = Calendar.getInstance();
		c1.add(Calendar.DAY_OF_YEAR, -1); 
		Calendar c2 = Calendar.getInstance();
		c2.setTime(date);
		return (c1.get(Calendar.ERA) == c2.get(Calendar.ERA) && c1.get(Calendar.YEAR) == c2.get(Calendar.YEAR)
		        && c1.get(Calendar.DAY_OF_YEAR) == c2.get(Calendar.DAY_OF_YEAR));
	}
	public static Set<String> getDeclaredFields(Class<?> clazz) {
		return Arrays.stream(clazz.getDeclaredFields()).map(Field::getName).collect(Collectors.toSet());
	}
	public static String isValidNumericValue(Float value, Concept concept, Obs obs) {
		ConceptReferenceRange conceptReferenceRange = new ObsValidator().getReferenceRange(concept, obs);
		if (conceptReferenceRange == null) {
			return "";
		}
		if ((conceptReferenceRange.getHiAbsolute() != null && conceptReferenceRange.getHiAbsolute() < value) ||
			(conceptReferenceRange.getLowAbsolute() != null && conceptReferenceRange.getLowAbsolute() > value)) {
			return String.format("Expected value between %s and %s", conceptReferenceRange.getLowAbsolute(), conceptReferenceRange.getHiAbsolute());
		} else {
			return "";
		}
	}
}
package org.openmrs;
import javax.persistence.CollectionTable;
import javax.persistence.Column;
import javax.persistence.ElementCollection;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.MapKeyColumn;
import javax.persistence.Table;
import javax.persistence.Transient;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
import org.hibernate.annotations.Cascade;
import org.hibernate.annotations.CascadeType;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.LazyCollection;
import org.hibernate.annotations.LazyCollectionOption;
import org.hibernate.annotations.Parameter;
import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.openmrs.api.context.Context;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.RoleConstants;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@Entity
@Table(name = "users")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@Audited
public class User extends BaseOpenmrsObject implements java.io.Serializable, Attributable<User>, Auditable, Retireable {
	public static final long serialVersionUID = 2L ;
	private static final Logger log = LoggerFactory.getLogger(User.class);
	@Id
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "users_user_id_seq")
	@GenericGenerator(
		name = "users_user_id_seq",
		strategy = "native",
		parameters = @Parameter(name = "sequence", value = "users_user_id_seq")
	)
	@Column(name = "user_id")
	private Integer userId;
	@ManyToOne
	@JoinColumn(name = "person_id", nullable = false)
	@LazyCollection(LazyCollectionOption.FALSE)
	@Cascade(CascadeType.SAVE_UPDATE)
	private Person person;
	@Column(name = "system_id", nullable = false, length = 50)
	private String systemId;
	@Column(name = "username", length = 50)
	private String username;
	@Column(name = "email", length = 255, unique = true)
	private String email;
	@ManyToMany
	@JoinTable(name = "user_role", joinColumns = @JoinColumn(name = "user_id"), inverseJoinColumns = @JoinColumn(name = "role"))
	@LazyCollection(LazyCollectionOption.FALSE)
	@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
	@Cascade({ CascadeType.SAVE_UPDATE, CascadeType.MERGE, CascadeType.EVICT })
	private Set<Role> roles;
	@ElementCollection
	@CollectionTable(name = "user_property", joinColumns = @JoinColumn(name = "user_id", nullable = false))
	@MapKeyColumn(name = "property", length = 255)
	@Column(name = "property_value", length = Integer.MAX_VALUE)
	@Cascade({ CascadeType.SAVE_UPDATE, CascadeType.MERGE, CascadeType.EVICT })
	@NotAudited
	private Map<String, String> userProperties;
	@Transient
	private List<Locale> proficientLocales = null;
	@Transient
	private String parsedProficientLocalesProperty = "";
	@ManyToOne
	@JoinColumn(name = "creator", nullable = false)
	private User creator;
	@Column(name = "date_created", nullable = false, length = 19)
	private Date dateCreated;
	@ManyToOne
	@JoinColumn(name = "changed_by")
	private User changedBy;
	@Column(name = "date_changed", length = 19)
	private Date dateChanged;
	@Column(name = "retired", nullable = false, length = 1)
	private boolean retired;
	@ManyToOne
	@JoinColumn(name = "retired_by")
	private User retiredBy;
	@Column(name = "date_retired", length = 19)
	private Date dateRetired;
	@Column(name = "retire_reason", length = 255)
	private String retireReason;
	public User() {
	}
	public User(Integer userId) {
		this.userId = userId;
	}
	public User(Person person) {
		this.person = person;
	}
	public boolean isSuperUser() {
		return containsRole(RoleConstants.SUPERUSER);
	}
	public boolean hasPrivilege(String privilege) {
		if (StringUtils.isEmpty(privilege)) {
			return true;
		}
		if (isSuperUser()) {
			return true;
		}
		Set<Role> tmproles = getAllRoles();
		for (Role tmprole : tmproles) {
			if (tmprole.hasPrivilege(privilege)) {
				return true;
			}
		}
		return false;
	}
	public boolean hasRole(String r) {
		return hasRole(r, false);
	}
	public boolean hasRole(String r, boolean ignoreSuperUser) {
		if (!ignoreSuperUser && isSuperUser()) {
			return true;
		}
		if (roles == null) {
			return false;
		}
		Set<Role> tmproles = getAllRoles();
		log.debug("User # {} has roles: {}", userId, tmproles);
		return containsRole(r);
	}
	public boolean containsRole(String roleName) {
		for (Role role : getAllRoles()) {
			if (role.getRole().equalsIgnoreCase(roleName)) {
				return true;
			}
		}
		return false;
	}
	public Collection<Privilege> getPrivileges() {
		Set<Privilege> privileges = new HashSet<>();
		Set<Role> tmproles = getAllRoles();
		Role role;
		for (Role tmprole : tmproles) {
			role = tmprole;
			Collection<Privilege> privs = role.getPrivileges();
			if (privs != null) {
				privileges.addAll(privs);
			}
		}
		return privileges;
	}
	public Set<Role> getAllRoles() {
		Set<Role> baseRoles = new HashSet<>();
		Set<Role> totalRoles = new HashSet<>();
		if (getRoles() != null) {
			baseRoles.addAll(getRoles());
			totalRoles.addAll(getRoles());
		}
		log.debug("User's base roles: {}", baseRoles);
		try {
			for (Role r : baseRoles) {
				totalRoles.addAll(r.getAllParentRoles());
			}
		}
		catch (ClassCastException e) {
			log.error("Error converting roles for user: " + this);
			log.error("baseRoles.class: " + baseRoles.getClass().getName());
			log.error("baseRoles: " + baseRoles.toString());
			for (Role baseRole : baseRoles) {
				log.error("baseRole: '" + baseRole + "'");
			}
		}
		return totalRoles;
	}
	public Set<Role> getRoles() {
		return roles;
	}
	public void setRoles(Set<Role> roles) {
		this.roles = roles;
	}
	public User addRole(Role role) {
		if (roles == null) {
			roles = new HashSet<>();
		}
		if (!roles.contains(role) && role != null) {
			roles.add(role);
		}
		return this;
	}
	public User removeRole(Role role) {
		if (roles != null) {
			roles.remove(role);
		}
		return this;
	}
	@Override
	@Deprecated
	public List<User> findPossibleValues(String searchText) {
		try {
			return Context.getUserService().getUsersByName(searchText, "", false);
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	@Override
	@Deprecated
	public List<User> getPossibleValues() {
		try {
			return Context.getUserService().getAllUsers();
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	@Override
	public User hydrate(String userId) {
		try {
			return Context.getUserService().getUser(Integer.valueOf(userId));
		}
		catch (Exception e) {
			return new User();
		}
	}
	@Override
	public String serialize() {
		if (getUserId() != null) {
			return "" + getUserId();
		} else {
			return "";
		}
	}
	@Override
	public String getDisplayString() {
		String returnString = "";
		if (getPersonName() != null) {
			returnString += getPersonName().getFullName() + " ";
		}
		returnString += "(" + getUsername() + ")";
		return returnString;
	}
	public String getSystemId() {
		return systemId;
	}
	public void setSystemId(String systemId) {
		this.systemId = systemId;
	}
	public Integer getUserId() {
		return userId;
	}
	public void setUserId(Integer userId) {
		this.userId = userId;
	}
	public Person getPerson() {
		return person;
	}
	private Person getPersonMaybeCreate() {
		if (person == null) {
			person = new Person();
		}
		return person;
	}
	public void setPerson(Person person) {
		this.person = person;
	}
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	@Override
	public String toString() {
		return StringUtils.isNotBlank(username) ? username : systemId;
	}
	public Map<String, String> getUserProperties() {
		if (userProperties == null) {
			userProperties = new HashMap<>();
		}
		return userProperties;
	}
	public void setUserProperties(Map<String, String> userProperties) {
		this.userProperties = userProperties;
	}
	public void setUserProperty(String prop, String value) {
		getUserProperties().put(prop, value);
	}
	public void removeUserProperty(String prop) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			userProperties.remove(prop);
		}
	}
	public String getUserProperty(String prop) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			return userProperties.get(prop);
		}
		return "";
	}
	public String getUserProperty(String prop, String defaultValue) {
		if (getUserProperties() != null && userProperties.containsKey(prop)) {
			return userProperties.get(prop);
		}
		return defaultValue;
	}
	public void addName(PersonName name) {
		getPersonMaybeCreate().addName(name);
	}
	public PersonName getPersonName() {
		return getPerson() == null ? null : getPerson().getPersonName();
	}
	public String getGivenName() {
		return getPerson() == null ? null : getPerson().getGivenName();
	}
	public String getFamilyName() {
		return getPerson() == null ? null : getPerson().getFamilyName();
	}
	public Set<PersonName> getNames() {
		return person.getNames();
	}
	public List<Locale> getProficientLocales() {
		String proficientLocalesProperty = getUserProperty(OpenmrsConstants.USER_PROPERTY_PROFICIENT_LOCALES);
		if ((proficientLocales == null)
		        || (!OpenmrsUtil.nullSafeEquals(parsedProficientLocalesProperty, proficientLocalesProperty))) {
			parsedProficientLocalesProperty = proficientLocalesProperty;
			proficientLocales = new ArrayList<>();
			if (proficientLocalesProperty != null) {
				String[] proficientLocalesArray = proficientLocalesProperty.split(",");
				for (String proficientLocaleSpec : proficientLocalesArray) {
					if (proficientLocaleSpec.length() > 0) {
						Locale proficientLocale = LocaleUtility.fromSpecification(proficientLocaleSpec);
						if (!proficientLocales.contains(proficientLocale)) {
							proficientLocales.add(proficientLocale);
							if (StringUtils.isNotEmpty(proficientLocale.getCountry())) {
								Locale languageOnlyLocale = LocaleUtility.fromSpecification(proficientLocale.getLanguage());
								if (!proficientLocales.contains(languageOnlyLocale)) {
									proficientLocales.add(LocaleUtility.fromSpecification(proficientLocale.getLanguage()));
								}
							}
						}
					}
				}
			}
		}
		return new ArrayList<>(proficientLocales);
	}
	@Override
	public Integer getId() {
		return getUserId();
	}
	@Override
	public void setId(Integer id) {
		setUserId(id);
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
    @Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	@Override
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	@Override
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	public Boolean isRetired() {
		return retired;
	}
    @Override
	public Boolean getRetired() {
		return retired;
	}
	@Override
	public void setRetired(Boolean retired) {
		this.retired = retired;
	}
	@Override
	public User getRetiredBy() {
		return retiredBy;
	}
	@Override
	public void setRetiredBy(User retiredBy) {
		this.retiredBy = retiredBy;
	}
	@Override
	public Date getDateRetired() {
		return dateRetired;
	}
	@Override
	public void setDateRetired(Date dateRetired) {
		this.dateRetired = dateRetired;
	}
	@Override
	public String getRetireReason() {
		return retireReason;
	}
	@Override
	public void setRetireReason(String retireReason) {
		this.retireReason = retireReason;
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.openmrs.api.APIException;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.order.OrderUtil;
import org.openmrs.util.OpenmrsUtil;
import java.util.Date;
@Audited
public class Order extends BaseCustomizableData<OrderAttribute> implements FormRecordable {
	public static final long serialVersionUID = 4334343L;
	public enum Urgency {
		ROUTINE,
		STAT,
		ON_SCHEDULED_DATE
	}
	public enum Action {
		NEW,
		REVISE,
		DISCONTINUE,
		RENEW
	}
	public enum FulfillerStatus {
		RECEIVED,
		IN_PROGRESS,
		EXCEPTION,
		ON_HOLD,
		DECLINED,
		COMPLETED
	}
	private Integer orderId;
	private Patient patient;
	private OrderType orderType;
	private Concept concept;
	private String instructions;
	private Date dateActivated;
	private Date autoExpireDate;
	private Encounter encounter;
	private Provider orderer;
	private Date dateStopped;
	private Concept orderReason;
	private String accessionNumber;
	private String orderReasonNonCoded;
	private Urgency urgency = Urgency.ROUTINE;
	private String orderNumber;
	private String commentToFulfiller;
	private CareSetting careSetting;
	private Date scheduledDate;
	private String formNamespaceAndPath;
	private Double sortWeight;
	private Order previousOrder;
	private Action action = Action.NEW;
	private OrderGroup orderGroup;
	private FulfillerStatus fulfillerStatus;
	private String fulfillerComment;
	public Order() {
	}
	public Order(Integer orderId) {
		this.orderId = orderId;
	}
	public Order copy() {
		return copyHelper(new Order());
	}
	protected Order copyHelper(Order target) {
		target.setPatient(getPatient());
		target.setOrderType(getOrderType());
		target.setConcept(getConcept());
		target.setInstructions(getInstructions());
		target.setDateActivated(getDateActivated());
		target.setAutoExpireDate(getAutoExpireDate());
		target.setEncounter(getEncounter());
		target.setOrderer(getOrderer());
		target.setCreator(getCreator());
		target.setDateCreated(getDateCreated());
		target.dateStopped = getDateStopped();
		target.setOrderReason(getOrderReason());
		target.setOrderReasonNonCoded(getOrderReasonNonCoded());
		target.setAccessionNumber(getAccessionNumber());
		target.setVoided(getVoided());
		target.setVoidedBy(getVoidedBy());
		target.setDateVoided(getDateVoided());
		target.setVoidReason(getVoidReason());
		target.setUrgency(getUrgency());
		target.setCommentToFulfiller(getCommentToFulfiller());
		target.previousOrder = getPreviousOrder();
		target.action = getAction();
		target.orderNumber = getOrderNumber();
		target.setCareSetting(getCareSetting());
		target.setChangedBy(getChangedBy());
		target.setDateChanged(getDateChanged());
		target.setScheduledDate(getScheduledDate());
		target.setOrderGroup(getOrderGroup());
		target.setSortWeight(getSortWeight());
		target.setFulfillerComment(getFulfillerComment());
		target.setFulfillerStatus(getFulfillerStatus());
		target.setFormNamespaceAndPath(getFormNamespaceAndPath());
		return target;
	}
	public Date getAutoExpireDate() {
		return autoExpireDate;
	}
	public void setAutoExpireDate(Date autoExpireDate) {
		this.autoExpireDate = autoExpireDate;
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		this.concept = concept;
	}
	public Date getScheduledDate() {
		return scheduledDate;
	}
	public void setScheduledDate(Date scheduledDate) {
		this.scheduledDate = scheduledDate;
	}
	public Date getDateStopped() {
		return dateStopped;
	}
	public Concept getOrderReason() {
		return orderReason;
	}
	public void setOrderReason(Concept orderReason) {
		this.orderReason = orderReason;
	}
	public Encounter getEncounter() {
		return encounter;
	}
	public void setEncounter(Encounter encounter) {
		this.encounter = encounter;
	}
	public String getInstructions() {
		return instructions;
	}
	public void setInstructions(String instructions) {
		this.instructions = instructions;
	}
	public String getAccessionNumber() {
		return accessionNumber;
	}
	public void setAccessionNumber(String accessionNumber) {
		this.accessionNumber = accessionNumber;
	}
	public Provider getOrderer() {
		return orderer;
	}
	public void setOrderer(Provider orderer) {
		this.orderer = orderer;
	}
	public Integer getOrderId() {
		return orderId;
	}
	public void setOrderId(Integer orderId) {
		this.orderId = orderId;
	}
	public Date getDateActivated() {
		return dateActivated;
	}
	public void setDateActivated(Date dateActivated) {
		this.dateActivated = dateActivated;
	}
	public String getOrderReasonNonCoded() {
		return orderReasonNonCoded;
	}
	public void setOrderReasonNonCoded(String orderReasonNonCoded) {
		this.orderReasonNonCoded = orderReasonNonCoded;
	}
	public String getCommentToFulfiller() {
		return commentToFulfiller;
	}
	public void setCommentToFulfiller(String commentToFulfiller) {
		this.commentToFulfiller = commentToFulfiller;
	}
	public boolean isActivated() {
		return isActivated(new Date());
	}
	public boolean isActivated(Date checkDate) {
		if (dateActivated == null) {
			return false;
		}
		if (checkDate == null) {
			checkDate = new Date();
		}
		return OpenmrsUtil.compare(dateActivated, checkDate) <= 0;
	}
	public boolean isActive() {
		return isActive(new Date());
	}
	public boolean isActive(Date aCheckDate) {
		if (getVoided() || action == Action.DISCONTINUE) {
			return false;
		}
		Date checkDate = aCheckDate == null ? new Date() : aCheckDate;
		return isActivated(checkDate) && !isDiscontinued(checkDate) && !isExpired(checkDate);
	}
	public boolean isStarted() {
		return isStarted(new Date());
	}
	public boolean isStarted(Date aCheckDate) {
		if (getVoided()) {
			return false;
		}
		if (getEffectiveStartDate() == null) {
			return false;
		}
		Date checkDate = aCheckDate == null ? new Date() : aCheckDate;
		return !checkDate.before(getEffectiveStartDate());
	}
	public boolean isDiscontinued(Date aCheckDate) {
		if (dateStopped != null && autoExpireDate != null && dateStopped.after(autoExpireDate)) {
			throw new APIException("Order.error.invalidDateStoppedAndAutoExpireDate", (Object[]) null);
		}
		if (getVoided()) {
			return false;
		}
		Date checkDate = aCheckDate == null ? new Date() : aCheckDate;
		if (!isActivated(checkDate) || dateStopped == null) {
			return false;
		}
		return checkDate.after(dateStopped);
	}
	public boolean isExpired() {
		return isExpired(new Date());
	}
	public boolean isExpired(Date aCheckDate) {
		if (dateStopped != null && autoExpireDate != null && dateStopped.after(autoExpireDate)) {
			throw new APIException("Order.error.invalidDateStoppedAndAutoExpireDate", (Object[]) null);
		}
		if (getVoided()) {
			return false;
		}
		Date checkDate = aCheckDate == null ? new Date() : aCheckDate;
		if (!isActivated(checkDate)) {
			return false;
		}
		if (isDiscontinued(checkDate) || autoExpireDate == null) {
			return false;
		}
		return checkDate.after(autoExpireDate);
	}
	public boolean isDiscontinuedRightNow() {
		return isDiscontinued(new Date());
	}
	public Patient getPatient() {
		return patient;
	}
	public void setPatient(Patient patient) {
		this.patient = patient;
	}
	@Override
	public Integer getId() {
		return getOrderId();
	}
	@Override
	public String toString() {
		String prefix = Action.DISCONTINUE == getAction() ? "DC " : "";
		return prefix + "Order. orderId: " + orderId + " patient: " + patient + " concept: " + concept + " care setting: "
		        + careSetting;
	}
	@Override
	public void setId(Integer id) {
		setOrderId(id);
	}
	public Urgency getUrgency() {
		return urgency;
	}
	public void setUrgency(Urgency urgency) {
		this.urgency = urgency;
	}
	public String getOrderNumber() {
		return orderNumber;
	}
	public Order getPreviousOrder() {
		return HibernateUtil.getRealObjectFromProxy(previousOrder);
	}
	public void setPreviousOrder(Order previousOrder) {
		this.previousOrder = previousOrder;
	}
	public Action getAction() {
		return action;
	}
	public void setAction(Action action) {
		this.action = action;
	}
	public CareSetting getCareSetting() {
		return careSetting;
	}
	public void setCareSetting(CareSetting careSetting) {
		this.careSetting = careSetting;
	}
	public OrderType getOrderType() {
		return orderType;
	}
	public void setOrderType(OrderType orderType) {
		this.orderType = orderType;
	}
	public Order cloneForDiscontinuing() {
		Order newOrder = new Order();
		newOrder.setCareSetting(getCareSetting());
		newOrder.setConcept(getConcept());
		newOrder.setAction(Action.DISCONTINUE);
		newOrder.setPreviousOrder(this);
		newOrder.setPatient(getPatient());
		newOrder.setOrderType(getOrderType());
		return newOrder;
	}
	public Order cloneForRevision() {
		return cloneForRevisionHelper(new Order());
	}
	protected Order cloneForRevisionHelper(Order target) {
		if (getAction() == Action.DISCONTINUE) {
			target.setAction(Action.DISCONTINUE);
			target.setPreviousOrder(getPreviousOrder());
			target.setDateActivated(getDateActivated());
		} else {
			target.setAction(Action.REVISE);
			target.setPreviousOrder(this);
			target.setAutoExpireDate(getAutoExpireDate());
		}
		target.setCareSetting(getCareSetting());
		target.setConcept(getConcept());
		target.setPatient(getPatient());
		target.setOrderType(getOrderType());
		target.setScheduledDate(getScheduledDate());
		target.setInstructions(getInstructions());
		target.setUrgency(getUrgency());
		target.setCommentToFulfiller(getCommentToFulfiller());
		target.setOrderReason(getOrderReason());
		target.setOrderReasonNonCoded(getOrderReasonNonCoded());
		target.setOrderGroup(getOrderGroup());
		target.setSortWeight(getSortWeight());
		target.setFulfillerStatus(getFulfillerStatus());
		target.setFulfillerComment(getFulfillerComment());
		target.setFormNamespaceAndPath(getFormNamespaceAndPath());
		return target;
	}
	public boolean isType(OrderType orderType) {
		return OrderUtil.isType(orderType, this.orderType);
	}
	public boolean hasSameOrderableAs(Order otherOrder) {
		if (otherOrder == null) {
			return false;
		}
		return OpenmrsUtil.nullSafeEquals(this.getConcept(), otherOrder.getConcept());
	}
	public Date getEffectiveStartDate() {
		return this.urgency == Urgency.ON_SCHEDULED_DATE ? this.getScheduledDate() : this.getDateActivated();
	}
	public Date getEffectiveStopDate() {
		return this.getDateStopped() != null ? this.getDateStopped() : this.getAutoExpireDate();
	}
	public OrderGroup getOrderGroup() {
		return orderGroup;
	}
	public void setOrderGroup(OrderGroup orderGroup) {
		this.orderGroup = orderGroup;
	}
	public Double getSortWeight() {
		return sortWeight;
	}
	public void setSortWeight(Double sortWeight) {
		this.sortWeight = sortWeight;
	}
	public FulfillerStatus getFulfillerStatus() {
		return fulfillerStatus;
	}
	public void setFulfillerStatus(FulfillerStatus fulfillerStatus) {
		this.fulfillerStatus = fulfillerStatus;
	}
	public String getFulfillerComment() {
		return fulfillerComment;
	}
	public void setFulfillerComment(String fulfillerComment) {
		this.fulfillerComment = fulfillerComment;		
	}
	public String getFormNamespaceAndPath() {
		return formNamespaceAndPath;
	}
	public void setFormNamespaceAndPath(String formNamespaceAndPath) {
		this.formNamespaceAndPath = formNamespaceAndPath;
	}
	@Override
	public String getFormFieldNamespace() {
		return BaseFormRecordableOpenmrsData.getFormFieldNamespace(formNamespaceAndPath);
	}
	@Override
	public String getFormFieldPath() {
		return BaseFormRecordableOpenmrsData.getFormFieldPath(formNamespaceAndPath);
	}
	@Override
	public void setFormField(String namespace, String formFieldPath) {
		formNamespaceAndPath = BaseFormRecordableOpenmrsData.getFormNamespaceAndPath(namespace, formFieldPath);
	}
}
package org.openmrs;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.TreeSet;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.Indexed;
@Indexed
@Audited
public class ConceptNumeric extends Concept {
	public static final long serialVersionUID = 47323L;
	private Double hiAbsolute;
	private Double hiCritical;
	private Double hiNormal;
	private Double lowAbsolute;
	private Double lowCritical;
	private Double lowNormal;
	private String units;
	private Boolean allowDecimal = false;
	private Set<ConceptReferenceRange> referenceRanges;
	private Integer displayPrecision;
	public ConceptNumeric() {
		referenceRanges = new LinkedHashSet<>();
	}
	public ConceptNumeric(Integer conceptId) {
		setConceptId(conceptId);
	}
	public ConceptNumeric(Concept c) {
		this.setChangedBy(c.getChangedBy());
		this.setConceptClass(c.getConceptClass());
		this.setConceptId(c.getConceptId());
		this.setCreator(c.getCreator());
		this.setDatatype(c.getDatatype());
		this.setDateChanged(c.getDateChanged());
		this.setDateCreated(c.getDateCreated());
		this.setSet(c.getSet());
		this.setRetired(c.getRetired());
		this.setRetiredBy(c.getRetiredBy());
		this.setRetireReason(c.getRetireReason());
		this.setVersion(c.getVersion());
		this.setUuid(c.getUuid());
		this.setNames(new HashSet<>(c.getNames()));
		for (ConceptName cName : this.getNames()) {
			cName.setConcept(this);
		}
		this.setAnswers(new HashSet<>(c.getAnswers(true)));
		for (ConceptAnswer cAnswer : this.getAnswers()) {
			cAnswer.setConcept(this);
		}
		this.setConceptSets(new TreeSet<>(c.getConceptSets()));
		for (ConceptSet cSet : this.getConceptSets()) {
			cSet.setConceptSet(this);
		}
		this.setDescriptions(new HashSet<>(c.getDescriptions()));
		for (ConceptDescription cDescription : this.getDescriptions()) {
			cDescription.setConcept(this);
		}
		this.setConceptMappings(new HashSet<>(c.getConceptMappings()));
		for (ConceptMap cMap : this.getConceptMappings()) {
			cMap.setConcept(this);
		}
		this.hiAbsolute = null;
		this.hiCritical = null;
		this.hiNormal = null;
		this.lowAbsolute = null;
		this.lowCritical = null;
		this.lowNormal = null;
		this.units = "";
		this.allowDecimal = false;
		referenceRanges = new LinkedHashSet<>();
	}
	public Double getHiAbsolute() {
		return this.hiAbsolute;
	}
	public void setHiAbsolute(Double hiAbsolute) {
		this.hiAbsolute = hiAbsolute;
	}
	public Double getHiCritical() {
		return this.hiCritical;
	}
	public void setHiCritical(Double hiCritical) {
		this.hiCritical = hiCritical;
	}
	public Double getHiNormal() {
		return this.hiNormal;
	}
	public void setHiNormal(Double hiNormal) {
		this.hiNormal = hiNormal;
	}
	public Double getLowAbsolute() {
		return this.lowAbsolute;
	}
	public void setLowAbsolute(Double lowAbsolute) {
		this.lowAbsolute = lowAbsolute;
	}
	public Double getLowCritical() {
		return this.lowCritical;
	}
	public void setLowCritical(Double lowCritical) {
		this.lowCritical = lowCritical;
	}
	public Double getLowNormal() {
		return this.lowNormal;
	}
	public void setLowNormal(Double lowNormal) {
		this.lowNormal = lowNormal;
	}
	public String getUnits() {
		return this.units;
	}
	public void setUnits(String units) {
		this.units = units;
	}
	@Override
	public boolean isNumeric() {
		return "Numeric".equals(getDatatype().getName());
	}
	public Integer getDisplayPrecision() {
		return displayPrecision;
	}
	public void setDisplayPrecision(Integer displayPrecision) {
		this.displayPrecision = displayPrecision;
	}
	public Boolean getAllowDecimal() {
		return allowDecimal == null ? Boolean.FALSE : allowDecimal;
	}
	public void setAllowDecimal(Boolean allowDecimal) {
		this.allowDecimal = allowDecimal;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isAllowDecimal() {
		return getAllowDecimal();
	}
	public Set<ConceptReferenceRange> getReferenceRanges() {
		return referenceRanges;
	}
	public void setReferenceRanges(Set<ConceptReferenceRange> referenceRanges) {
		this.referenceRanges = referenceRanges;
	}
	public void addReferenceRange(ConceptReferenceRange referenceRange) {
		getReferenceRanges().add(referenceRange);
	}
	public void removeReferenceRange(ConceptReferenceRange referenceRange) {
		getReferenceRanges().remove(referenceRange);
	}
}
package org.openmrs.api.context;
import org.aopalliance.aop.Advice;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.SessionFactory;
import org.openmrs.Allergen;
import org.openmrs.GlobalProperty;
import org.openmrs.OpenmrsObject;
import org.openmrs.PersonName;
import org.openmrs.Privilege;
import org.openmrs.Role;
import org.openmrs.User;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.CohortService;
import org.openmrs.api.ConceptService;
import org.openmrs.api.ConditionService;
import org.openmrs.api.DatatypeService;
import org.openmrs.api.DiagnosisService;
import org.openmrs.api.EncounterService;
import org.openmrs.api.FormService;
import org.openmrs.api.LocationService;
import org.openmrs.api.MedicationDispenseService;
import org.openmrs.api.ObsService;
import org.openmrs.api.OpenmrsService;
import org.openmrs.api.OrderService;
import org.openmrs.api.OrderSetService;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.ProviderService;
import org.openmrs.api.SerializationService;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.api.db.ContextDAO;
import org.openmrs.hl7.HL7Service;
import org.openmrs.logic.LogicService;
import org.openmrs.messagesource.MessageSourceService;
import org.openmrs.module.ModuleMustStartException;
import org.openmrs.module.ModuleUtil;
import org.openmrs.notification.AlertService;
import org.openmrs.notification.MessageException;
import org.openmrs.notification.MessagePreparator;
import org.openmrs.notification.MessageSender;
import org.openmrs.notification.MessageService;
import org.openmrs.notification.mail.MailMessageSender;
import org.openmrs.notification.mail.velocity.VelocityMessagePreparator;
import org.openmrs.scheduler.SchedulerService;
import org.openmrs.scheduler.SchedulerUtil;
import org.openmrs.util.ConfigUtil;
import org.openmrs.util.DatabaseUpdateException;
import org.openmrs.util.DatabaseUpdater;
import org.openmrs.util.InputRequiredException;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.validator.ValidateUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.aop.Advisor;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.NoSuchBeanDefinitionException;
import org.springframework.beans.factory.NoUniqueBeanDefinitionException;
import javax.mail.Authenticator;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.Future;
public class Context {
	private static final Logger log = LoggerFactory.getLogger(Context.class);
	private static ContextDAO contextDAO;
	private static Session mailSession;
	private static final ThreadLocal<Object[] > userContextHolder = new ThreadLocal<>();
	private static volatile ServiceContext serviceContext;
	private static Properties runtimeProperties = new Properties();
	private static Properties configProperties = new Properties();
	private static AuthenticationScheme authenticationScheme;
	public Context() {
	}
	static ContextDAO getContextDAO() {
		if (contextDAO == null) {
			throw new APIException("error.context.null", (Object[]) null);
		}
		return contextDAO;
	}
	public void setContextDAO(ContextDAO dao) {
		setDAO(dao);
	}
	public static void setDAO(ContextDAO dao) {
		contextDAO = dao;
	}
	private static void setAuthenticationScheme() {
		authenticationScheme = new UsernamePasswordAuthenticationScheme();
		try {
			authenticationScheme = Context.getServiceContext().getApplicationContext().getBean(AuthenticationScheme.class); 
			log.info("An authentication scheme override was provided. Using this one in place of the OpenMRS default authentication scheme.");
		}
		catch(NoUniqueBeanDefinitionException e) {
			log.error("Multiple authentication schemes overrides are being provided, this is currently not supported. Sticking to OpenMRS default authentication scheme.");
		}
		catch(NoSuchBeanDefinitionException e) {
			log.debug("No authentication scheme override was provided. Sticking to OpenMRS default authentication scheme.");
		}
		catch(BeansException e){
			log.error("Fatal error encountered when injecting the authentication scheme override. Sticking to OpenMRS default authentication scheme.");
		}
	}
	public static Class<?> loadClass(String className) throws ClassNotFoundException {
		return OpenmrsClassLoader.getInstance().loadClass(className);
	}
	public static void setUserContext(UserContext ctx) {
		log.trace("Setting user context {}", ctx);
		Object[] arr = new Object[] { ctx };
		userContextHolder.set(arr);
	}
	public static void clearUserContext() {
		log.trace("Clearing user context {}", Arrays.toString(userContextHolder.get()));
		userContextHolder.remove();
	}
	public static UserContext getUserContext() {
		Object[] arr = userContextHolder.get();
		log.trace("Getting user context {} from userContextHolder {}", Arrays.toString(arr), userContextHolder);
		if (arr == null) {
			log.trace("userContext is null.");
			throw new APIException(
					"A user context must first be passed to setUserContext()...use Context.openSession() (and closeSession() to prevent memory leaks!) before using the API");
		}
		return (UserContext) userContextHolder.get()[0];
	}
	static ServiceContext getServiceContext() {
		if (serviceContext == null) {
			synchronized (Context.class) {
				if (serviceContext == null) {
					log.info("Creating new service context");
					serviceContext = ServiceContext.getInstance();
				}
			}
		}
		log.trace("serviceContext: {}", serviceContext);
		return ServiceContext.getInstance();
	}
	public void setServiceContext(ServiceContext ctx) {
		setContext(ctx);
	}
	public static void setContext(ServiceContext ctx) {
		serviceContext = ctx;
	}
	public static AuthenticationScheme getAuthenticationScheme() {
		return authenticationScheme;
	}
	@Deprecated
	public static void authenticate(String username, String password) throws ContextAuthenticationException {
		authenticate(new UsernamePasswordCredentials(username, password));
	}
	public static Authenticated authenticate(Credentials credentials) throws ContextAuthenticationException {
		if (Daemon.isDaemonThread()) {
			log.error("Authentication attempted while operating on a "
					+ "daemon thread, authenticating is not necessary or allowed");
			return new BasicAuthenticated(Daemon.getDaemonThreadUser(), "No auth scheme used by Context - Daemon user is always authenticated.");
		}
		if (credentials == null) {
			throw new ContextAuthenticationException("Context cannot authenticate with null credentials.");
		}
		return getUserContext().authenticate(credentials);
	}
	public static void refreshAuthenticatedUser() {
		if (Daemon.isDaemonThread()) {
			return;
		}
		log.debug("Refreshing authenticated user");
		getUserContext().refreshAuthenticatedUser();
	}
	public static void becomeUser(String systemId) throws ContextAuthenticationException {
		log.info("systemId: {}", systemId);
		getUserContext().becomeUser(systemId);
	}
	public static Properties getRuntimeProperties() {
		log.trace("getting runtime properties. size: {}", runtimeProperties.size());
		Properties props = new Properties();
		props.putAll(runtimeProperties);
		return props;
	}
	public static void setRuntimeProperties(Properties props) {
		runtimeProperties = props;
	}
	public static ConceptService getConceptService() {
		return getServiceContext().getConceptService();
	}
	public static EncounterService getEncounterService() {
		return getServiceContext().getEncounterService();
	}
	public static LocationService getLocationService() {
		return getServiceContext().getLocationService();
	}
	public static ObsService getObsService() {
		return getServiceContext().getObsService();
	}
	public static PatientService getPatientService() {
		return getServiceContext().getPatientService();
	}
	public static CohortService getCohortService() {
		return getServiceContext().getCohortService();
	}
	public static PersonService getPersonService() {
		return getServiceContext().getPersonService();
	}
	public static ConditionService getConditionService(){
		return getServiceContext().getConditionService();
	}
	public static DiagnosisService getDiagnosisService(){
		return getServiceContext().getDiagnosisService();
	}
	public static MedicationDispenseService getMedicationDispenseService(){
		return getServiceContext().getMedicationDispenseService();
	}
	public static HL7Service getHL7Service() {
		return getServiceContext().getHL7Service();
	}
	public static UserService getUserService() {
		return getServiceContext().getUserService();
	}
	public static OrderService getOrderService() {
		return getServiceContext().getOrderService();
	}
	public static OrderSetService getOrderSetService() {
		return getServiceContext().getOrderSetService();
	}
	public static FormService getFormService() {
		return getServiceContext().getFormService();
	}
	public static SerializationService getSerializationService() {
		return getServiceContext().getSerializationService();
	}
	public static LogicService getLogicService() {
		return getServiceContext().getLogicService();
	}
	public static AdministrationService getAdministrationService() {
		return getServiceContext().getAdministrationService();
	}
	public static MessageSourceService getMessageSourceService() {
		return getServiceContext().getMessageSourceService();
	}
	public static SchedulerService getSchedulerService() {
		return getServiceContext().getSchedulerService();
	}
	public static AlertService getAlertService() {
		return getServiceContext().getAlertService();
	}
	public static ProgramWorkflowService getProgramWorkflowService() {
		return getServiceContext().getProgramWorkflowService();
	}
	public static MessageService getMessageService() {
		MessageService ms = getServiceContext().getMessageService();
		try {
			if (ms.getMessagePreparator() == null) {
				ms.setMessagePreparator(getMessagePreparator());
			}
			if (ms.getMessageSender() == null) {
				ms.setMessageSender(getMessageSender());
			}
		}
		catch (Exception e) {
			log.error("Unable to create message service due", e);
		}
		return ms;
	}
	public static Properties getMailProperties() {
		Properties p = new Properties();
		String prefix = "mail.";
		for (GlobalProperty gp : getAdministrationService().getGlobalPropertiesByPrefix(prefix)) {
			if (gp.getProperty().equals("mail.transport_protocol")) {
				p.setProperty("mail.transport.protocol", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_host")) {
				p.setProperty("mail.smtp.host", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_port")) {
				p.setProperty("mail.smtp.port", gp.getPropertyValue());
			}
			else if (gp.getProperty().equals("mail.smtp_auth")) {
				p.setProperty("mail.smtp.auth", gp.getPropertyValue());
			}
			else {
				p.setProperty(gp.getProperty(), gp.getPropertyValue());
			}
		}
		for (String runtimeProperty : runtimeProperties.stringPropertyNames()) {
			if (runtimeProperty.startsWith(prefix)) {
				p.setProperty(runtimeProperty, runtimeProperties.getProperty(runtimeProperty));
			}
		}
		for (String systemProperty : System.getProperties().stringPropertyNames()) {
			if (systemProperty.startsWith(prefix)) {
				p.setProperty(systemProperty, System.getProperty(systemProperty));
			}
		}
		return p;
	}
	private static Session getMailSession() {
		if (mailSession == null) {
			synchronized (Context.class) {
				if (mailSession == null) {
					Authenticator auth = new Authenticator() {
						@Override
						public PasswordAuthentication getPasswordAuthentication() {
							return new PasswordAuthentication(
								ConfigUtil.getProperty("mail.user"),
								ConfigUtil.getProperty("mail.password")
							);
						}
					};
					mailSession = Session.getInstance(getMailProperties(), auth);
				}
			}
		}
		return mailSession;
	}
	private static MessageSender getMessageSender() {
		return new MailMessageSender(getMailSession());
	}
	private static MessagePreparator getMessagePreparator() throws MessageException {
		return new VelocityMessagePreparator();
	}
	public static User getAuthenticatedUser() {
		if (Daemon.isDaemonThread()) {
			return Daemon.getDaemonThreadUser();
		}
		return getUserContext().getAuthenticatedUser();
	}
	public static boolean isAuthenticated() {
		if (Daemon.isDaemonThread()) {
			return true;
		} else {
			try {
				return getAuthenticatedUser() != null;
			} catch (APIException e) {
				log.info("Could not get authenticated user inside called to isAuthenticated(), assuming no user context has been defined", e);
				return false;
			}
		}
	}
	public static void logout() {
		if (!isSessionOpen()) {
			return; 
		}
		log.debug("Logging out : {}", getAuthenticatedUser());
		getUserContext().logout();
		setUserContext(new UserContext(getAuthenticationScheme()));
	}
	public static Set<Role> getAllRoles(User user) throws Exception {
		return getUserContext().getAllRoles();
	}
	public static boolean hasPrivilege(String privilege) {
		if (Daemon.isDaemonThread()) {
			return true;
		}
		return getUserContext().hasPrivilege(privilege);
	}
	public static void requirePrivilege(String privilege) throws ContextAuthenticationException {
		if (!hasPrivilege(privilege)) {
			String errorMessage;
			if (StringUtils.isNotBlank(privilege)) {
				errorMessage = Context.getMessageSourceService().getMessage("error.privilegesRequired",
						new Object[] { privilege }, null);
			} else {
				errorMessage = Context.getMessageSourceService().getMessage("error.privilegesRequiredNoArgs");
			}
			throw new ContextAuthenticationException(errorMessage);
		}
	}
	public static void addProxyPrivilege(String privilege) {
		getUserContext().addProxyPrivilege(privilege);
	}
	public static void removeProxyPrivilege(String privilege) {
		getUserContext().removeProxyPrivilege(privilege);
	}
	public static void setLocale(Locale locale) {
		getUserContext().setLocale(locale);
	}
	public static Locale getLocale() {
		if (!isSessionOpen()) {
			return LocaleUtility.getDefaultLocale();
		}
		return getUserContext().getLocale();
	}
	public static void openSession() {
		log.trace("opening session");
		setUserContext(new UserContext(getAuthenticationScheme())); 
		getContextDAO().openSession();
	}
	public static void closeSession() {
		log.trace("closing session");
		clearUserContext(); 
		getContextDAO().closeSession();
	}
	public static void openSessionWithCurrentUser() {
		getContextDAO().openSession();
	}
	public static void closeSessionWithCurrentUser() {
		getContextDAO().closeSession();
	}
	public static void clearSession() {
		log.trace("clearing session");
		getContextDAO().clearSession();
	}
	public static void flushSession() {
		log.trace("flushing session");
		getContextDAO().flushSession();
	}
	public static boolean isSessionOpen() {
		return userContextHolder.get() != null;
	}
	public static void refreshEntity(Object obj) {
		log.trace("refreshing object: {}", obj);
		getContextDAO().refreshEntity(obj);
	}
	public static void evictFromSession(Object obj) {
		log.trace("clearing session");
		getContextDAO().evictFromSession(obj);
	}
	public static void evictEntity(OpenmrsObject object) {
		log.debug("Clearing DB cache for entity: {} with id: {}", object.getClass(), object.getId());
		getContextDAO().evictEntity(object);
	}
	public static void evictAllEntities(Class<?> entityClass) {
		log.debug("Clearing DB cache for entities of type: {}", entityClass);
		getContextDAO().evictAllEntities(entityClass);
	}
	public static void clearEntireCache() {
		log.debug("Clearing DB cache from all regions");
		getContextDAO().clearEntireCache();
	}
	public static synchronized void startup(Properties props) throws DatabaseUpdateException, InputRequiredException,
	ModuleMustStartException {
		getContextDAO().startup(props);
		checkForDatabaseUpdates(props);
		OpenmrsUtil.startup(props);
		openSession();
		clearSession();
		checkCoreDataset();
		getContextDAO().setupSearchIndex();
		ModuleUtil.startup(props);
	}
	public static synchronized void startup(String url, String username, String password, Properties properties)
			throws DatabaseUpdateException, InputRequiredException, ModuleMustStartException {
		if (properties == null) {
			properties = new Properties();
		}
		properties.put("connection.url", url);
		properties.put("connection.username", username);
		properties.put("connection.password", password);
		setRuntimeProperties(properties);
		openSession(); 
		startup(properties);
		SchedulerUtil.startup(properties);
		closeSession();
	}
	public static void shutdown() {
		log.debug("Shutting down the scheduler");
		try {
			SchedulerUtil.shutdown();
		}
		catch (Exception e) {
			log.warn("Error while shutting down scheduler service", e);
		}
		log.debug("Shutting down the modules");
		try {
			ModuleUtil.shutdown();
		}
		catch (Exception e) {
			log.warn("Error while shutting down module system", e);
		}
		log.debug("Shutting down the context");
		try {
			ContextDAO dao = null;
			try {
				dao = getContextDAO();
			}
			catch (APIException e) {
			}
			if (dao != null) {
				dao.shutdown();
			}
		}
		catch (Exception e) {
			log.warn("Error while shutting down context dao", e);
		}
	}
	public static <T> T getService(Class<? extends T> cls) {
		return getServiceContext().getService(cls);
	}
	public static void addAdvisor(Class cls, Advisor advisor) {
		getServiceContext().addAdvisor(cls, advisor);
	}
	public static void addAdvice(Class cls, Advice advice) {
		getServiceContext().addAdvice(cls, advice);
	}
	public static void removeAdvisor(Class cls, Advisor advisor) {
		getServiceContext().removeAdvisor(cls, advisor);
	}
	public static void removeAdvice(Class cls, Advice advice) {
		getServiceContext().removeAdvice(cls, advice);
	}
	public static void checkCoreDataset() {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_ROLES);
			Set<String> currentRoleNames = new HashSet<>();
			for (Role role : Context.getUserService().getAllRoles()) {
				currentRoleNames.add(role.getRole().toUpperCase());
			}
			Map<String, String> map = OpenmrsUtil.getCoreRoles();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				String roleName = entry.getKey();
				if (!currentRoleNames.contains(roleName.toUpperCase())) {
					Role role = new Role();
					role.setRole(roleName);
					role.setDescription(entry.getValue());
					Context.getUserService().saveRole(role);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core roles for openmrs system", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_ROLES);
		}
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_PRIVILEGES);
			Set<String> currentPrivilegeNames = new HashSet<>();
			for (Privilege privilege : Context.getUserService().getAllPrivileges()) {
				currentPrivilegeNames.add(privilege.getPrivilege().toUpperCase());
			}
			Map<String, String> map = OpenmrsUtil.getCorePrivileges();
			for (Map.Entry<String, String> entry : map.entrySet()) {
				String privilegeName = entry.getKey();
				if (!currentPrivilegeNames.contains(privilegeName.toUpperCase())) {
					Privilege p = new Privilege();
					p.setPrivilege(privilegeName);
					p.setDescription(entry.getValue());
					Context.getUserService().savePrivilege(p);
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core privileges", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_PRIVILEGES);
		}
		try {
			Context.addProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			Context.addProxyPrivilege(PrivilegeConstants.GET_GLOBAL_PROPERTIES);
			Set<String> currentPropNames = new HashSet<>();
			Map<String, GlobalProperty> propsMissingDescription = new HashMap<>();
			Map<String, GlobalProperty> propsMissingDatatype = new HashMap<>();
			for (GlobalProperty prop : Context.getAdministrationService().getAllGlobalProperties()) {
				currentPropNames.add(prop.getProperty().toUpperCase());
				if (prop.getDescription() == null) {
					propsMissingDescription.put(prop.getProperty().toUpperCase(), prop);
				}
				if (prop.getDatatypeClassname() == null) {
					propsMissingDatatype.put(prop.getProperty().toUpperCase(), prop);
				}
			}
			for (GlobalProperty coreProp : OpenmrsConstants.CORE_GLOBAL_PROPERTIES()) {
				String corePropName = coreProp.getProperty().toUpperCase();
				if (!currentPropNames.contains(corePropName)) {
					Context.getAdministrationService().saveGlobalProperty(coreProp);
					currentPropNames.add(corePropName); 
				} else {
					GlobalProperty propToUpdate = propsMissingDescription.get(corePropName);
					if (propToUpdate != null) {
						propToUpdate.setDescription(coreProp.getDescription());
						Context.getAdministrationService().saveGlobalProperty(propToUpdate);
					}
					propToUpdate = propsMissingDatatype.get(corePropName);
					if (propToUpdate != null && coreProp.getDatatypeClassname() != null) {
						propToUpdate.setDatatypeClassname(coreProp.getDatatypeClassname());
						propToUpdate.setDatatypeConfig(coreProp.getDatatypeConfig());
						propToUpdate.setPreferredHandlerClassname(coreProp.getPreferredHandlerClassname());
						propToUpdate.setHandlerConfig(coreProp.getHandlerConfig());
						Context.getAdministrationService().saveGlobalProperty(propToUpdate);
					}
				}
			}
		}
		catch (Exception e) {
			log.error("Error while setting core global properties", e);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.MANAGE_GLOBAL_PROPERTIES);
			Context.removeProxyPrivilege(PrivilegeConstants.GET_GLOBAL_PROPERTIES);
		}
		AdministrationService as = Context.getAdministrationService();
		Boolean disableValidation = Boolean.valueOf(as.getGlobalProperty(OpenmrsConstants.GP_DISABLE_VALIDATION, "false"));
		ValidateUtil.setDisableValidation(disableValidation);
		PersonName.setFormat(Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GLOBAL_PROPERTY_LAYOUT_NAME_FORMAT));
		Allergen.setOtherNonCodedConceptUuid(Context.getAdministrationService().getGlobalProperty(
				OpenmrsConstants.GP_ALLERGEN_OTHER_NON_CODED_UUID));
	}
	private static void checkForDatabaseUpdates(Properties props) throws DatabaseUpdateException, InputRequiredException {
		boolean updatesRequired;
		try {
			updatesRequired = DatabaseUpdater.updatesRequired();
		}
		catch (Exception e) {
			throw new DatabaseUpdateException("Unable to check if database updates are required", e);
		}
		if (updatesRequired) {
			if (DatabaseUpdater.allowAutoUpdate()) {
				DatabaseUpdater.executeChangelog();
			} else {
				throw new DatabaseUpdateException(
						"Database updates are required.  Call Context.updateDatabase() before .startup() to continue.");
			}
		}
	}
	@Deprecated
	public static void updateDatabase(Map<String, Object> userInput) throws DatabaseUpdateException {
		throw new UnsupportedOperationException("As of 2.4, this method is not longer implemented");
	}
	public static SimpleDateFormat getDateFormat() {
		return OpenmrsUtil.getDateFormat(getLocale());
	}
	public static SimpleDateFormat getTimeFormat() {
		return OpenmrsUtil.getTimeFormat(getLocale());
	}
	public static SimpleDateFormat getDateTimeFormat() {
		return OpenmrsUtil.getDateTimeFormat(getLocale());
	}
	public static boolean isRefreshingContext() {
		return getServiceContext().isRefreshingContext();
	}
	public static <T> List<T> getRegisteredComponents(Class<T> type) {
		return getServiceContext().getRegisteredComponents(type);
	}
	public static <T> T getRegisteredComponent(String beanName, Class<T> type) throws APIException {
		return getServiceContext().getRegisteredComponent(beanName, type);
	}
	public static List<OpenmrsService> getModuleOpenmrsServices(String modulePackage) {
		return getServiceContext().getModuleOpenmrsServices(modulePackage);
	}
	public static VisitService getVisitService() {
		return getServiceContext().getVisitService();
	}
	public static ProviderService getProviderService() {
		return getServiceContext().getProviderService();
	}
	public static DatatypeService getDatatypeService() {
		return getServiceContext().getDatatypeService();
	}
	public static void addConfigProperty(Object key, Object value) {
		configProperties.put(key, value);
	}
	public static void removeConfigProperty(Object key) {
		configProperties.remove(key);
	}
	public static Properties getConfigProperties() {
		Properties props = new Properties();
		props.putAll(configProperties);
		return props;
	}
	public static void updateSearchIndex() {
		getContextDAO().updateSearchIndex();
	}
	public static Future<?> updateSearchIndexAsync() {
		return getContextDAO().updateSearchIndexAsync();
	}
	public static void updateSearchIndexForType(Class<?> type) {
		getContextDAO().updateSearchIndexForType(type);
	}
	public static void updateSearchIndexForObject(Object object) {
		getContextDAO().updateSearchIndexForObject(object);
	}
	public static void setUseSystemClassLoader(boolean useSystemClassLoader) {
		getServiceContext().setUseSystemClassLoader(useSystemClassLoader);
	}
	public static boolean isUseSystemClassLoader() {
		return getServiceContext().isUseSystemClassLoader();
	}
	public static Connection getDatabaseConnection() {
		return getContextDAO().getDatabaseConnection();
	}
}
package org.openmrs;
import org.hibernate.annotations.BatchSize;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
import org.hibernate.envers.Audited;
import org.openmrs.annotation.Independent;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import javax.persistence.AttributeOverride;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OrderBy;
import javax.persistence.Table;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
@Entity
@Table(name = "location")
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
@AttributeOverride(name = "attributes", column = @Column(name = "location_id"))
@Audited
public class Location extends BaseCustomizableMetadata<LocationAttribute> implements java.io.Serializable, Attributable<Location>, Address {
	public static final long serialVersionUID = 455634L;
	public static final int LOCATION_UNKNOWN = 1;
	@Id
	@Column(name = "location_id")
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer locationId;
	@ManyToOne
	@JoinColumn(name = "location_type_concept_id")
	private Concept type;
	@Column(name = "address1")
	private String address1;
	@Column(name = "address2")
	private String address2;
	@Column(name = "city_village")
	private String cityVillage;
	@Column(name = "state_province")
	private String stateProvince;
	@Column(name = "country", length = 50)
	private String country;
	@Column(name = "postal_code", length = 50)
	private String postalCode;
	@Column(name = "latitude", length = 50)
	private String latitude;
	@Column(name = "longitude", length = 50)
	private String longitude;
	@Column(name = "county_district")
	private String countyDistrict;
	@Column(name = "address3")
	private String address3;
	@Column(name = "address4")
	private String address4;
	@Column(name = "address6")
	private String address6;
	@Column(name = "address5")
	private String address5;
	@Column(name = "address7")
	private String address7;
	@Column(name = "address8")
	private String address8;
	@Column(name = "address9")
	private String address9;
	@Column(name = "address10")
	private String address10;
	@Column(name = "address11")
	private String address11;
	@Column(name = "address12")
	private String address12;
	@Column(name = "address13")
	private String address13;
	@Column(name = "address14")
	private String address14;
	@Column(name = "address15")
	private String address15;
	@ManyToOne
	@JoinColumn(name = "parent_location")
	private Location parentLocation;
	@OneToMany(mappedBy = "parentLocation", cascade = CascadeType.ALL, orphanRemoval = true)
	@BatchSize(size = 100)
	@OrderBy("name")
	private Set<Location> childLocations;
	@ManyToMany(fetch = FetchType.LAZY)
	@JoinTable(
		name = "location_tag_map",
		joinColumns = @JoinColumn(name = "location_id"),
		inverseJoinColumns = @JoinColumn(name = "location_tag_id"))
	@Independent
	private Set<LocationTag> tags;
	public Location() {
	}
	public Location(Integer locationId) {
		this.locationId = locationId;
	}
	@Override
	public String getAddress1() {
		return address1;
	}
	@Override
	public void setAddress1(String address1) {
		this.address1 = address1;
	}
	@Override
	public String getAddress2() {
		return address2;
	}
	@Override
	public void setAddress2(String address2) {
		this.address2 = address2;
	}
	@Override
	public String getCityVillage() {
		return cityVillage;
	}
	@Override
	public void setCityVillage(String cityVillage) {
		this.cityVillage = cityVillage;
	}
	@Override
	public String getCountry() {
		return country;
	}
	@Override
	public void setCountry(String country) {
		this.country = country;
	}
	@Override
	public String getLatitude() {
		return latitude;
	}
	@Override
	public void setLatitude(String latitude) {
		this.latitude = latitude;
	}
	public Integer getLocationId() {
		return locationId;
	}
	public void setLocationId(Integer locationId) {
		this.locationId = locationId;
	}
	@Override
	public String getLongitude() {
		return longitude;
	}
	@Override
	public void setLongitude(String longitude) {
		this.longitude = longitude;
	}
	@Override
	public String getPostalCode() {
		return postalCode;
	}
	@Override
	public void setPostalCode(String postalCode) {
		this.postalCode = postalCode;
	}
	@Override
	public String getStateProvince() {
		return stateProvince;
	}
	@Override
	public void setStateProvince(String stateProvince) {
		this.stateProvince = stateProvince;
	}
	@Override
	public String toString() {
		if (getName() != null) {
			return getName();
		}
		if (getId() != null) {
			return getId().toString();
		}
		return "";
	}
	@Override
	public String getCountyDistrict() {
		return countyDistrict;
	}
	@Override
	public void setCountyDistrict(String countyDistrict) {
		this.countyDistrict = countyDistrict;
	}
	public Concept getType() {
		return type;
	}
	public void setType(Concept type) {
		this.type = type;
	}
	@Override
	@Deprecated
	public List<Location> findPossibleValues(String searchText) {
		try {
			return Context.getLocationService().getLocations(searchText);
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	@Override
	@Deprecated
	public List<Location> getPossibleValues() {
		try {
			return Context.getLocationService().getAllLocations();
		}
		catch (Exception e) {
			return Collections.emptyList();
		}
	}
	@Override
	public Location hydrate(String locationId) {
		try {
			return Context.getLocationService().getLocation(Integer.valueOf(locationId));
		}
		catch (Exception e) {
			return new Location();
		}
	}
	@Override
	public String serialize() {
		if (getLocationId() != null) {
			return "" + getLocationId();
		} else {
			return "";
		}
	}
	@Override
	public String getDisplayString() {
		return getName();
	}
	public Location getParentLocation() {
		return parentLocation;
	}
	public void setParentLocation(Location parentLocationId) {
		this.parentLocation = parentLocationId;
	}
	public Set<Location> getChildLocations() {
		return childLocations;
	}
	public Set<Location> getChildLocations(boolean includeRetired) {
		Set<Location> ret = new HashSet<>();
		if (includeRetired) {
			ret = getChildLocations();
		} else if (getChildLocations() != null) {
			for (Location l : getChildLocations()) {
				if (!l.getRetired()) {
					ret.add(l);
				}
			}
		}
		return ret;
	}
	public Set<Location> getDescendantLocations(boolean includeRetired) {
		Set<Location> result = new HashSet<>();
		for (Location childLocation : getChildLocations()) {
			if (!childLocation.getRetired() || includeRetired) {
				result.add(childLocation);
				result.addAll(childLocation.getDescendantLocations(includeRetired));
			}
		}
		return result;
	}
	public void setChildLocations(Set<Location> childLocations) {
		this.childLocations = childLocations;
	}
	public void addChildLocation(Location child) {
		if (child == null) {
			return;
		}
		if (getChildLocations() == null) {
			childLocations = new HashSet<>();
		}
		if (child.equals(this)) {
			throw new APIException("Location.cannot.be.its.own.child", (Object[]) null);
		}
		Location root = this;
		while (root.getParentLocation() != null) {
			root = root.getParentLocation();
		}
		if (isInHierarchy(child, root)) {
			throw new APIException("Location.hierarchy.loop", new Object[] { child, this });
		}
		child.setParentLocation(this);
		childLocations.add(child);
	}
	public static Boolean isInHierarchy(Location location, Location root) {
		if (root == null) {
			return false;
		}
		while (true) {
			if (location == null) {
				return false;
			} else if (root.equals(location)) {
				return true;
			}
			location = location.getParentLocation();
		}
	}
	public void removeChildLocation(Location child) {
		if (getChildLocations() != null) {
			childLocations.remove(child);
		}
	}
	public Set<LocationTag> getTags() {
		return tags;
	}
	public void setTags(Set<LocationTag> tags) {
		this.tags = tags;
	}
	public void addTag(LocationTag tag) {
		if (getTags() == null) {
			tags = new HashSet<>();
		}
		if (tag != null && !tags.contains(tag)) {
			tags.add(tag);
		}
	}
	public void removeTag(LocationTag tag) {
		if (getTags() != null) {
			tags.remove(tag);
		}
	}
	public Boolean hasTag(String tagToFind) {
		if (tagToFind != null && getTags() != null) {
			for (LocationTag locTag : getTags()) {
				if (locTag.getName().equals(tagToFind)) {
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public String getAddress3() {
		return address3;
	}
	@Override
	public void setAddress3(String address3) {
		this.address3 = address3;
	}
	@Override
	public String getAddress4() {
		return address4;
	}
	@Override
	public void setAddress4(String address4) {
		this.address4 = address4;
	}
	@Override
	public String getAddress6() {
		return address6;
	}
	@Override
	public void setAddress6(String address6) {
		this.address6 = address6;
	}
	@Override
	public String getAddress5() {
		return address5;
	}
	@Override
	public void setAddress5(String address5) {
		this.address5 = address5;
	}
	@Override
	public Integer getId() {
		return getLocationId();
	}
	@Override
	public void setId(Integer id) {
		setLocationId(id);
	}
	@Override
	public String getAddress7() {
		return address7;
	}
	@Override
	public void setAddress7(String address7) {
		this.address7 = address7;
	}
	@Override
	public String getAddress8() {
		return address8;
	}
	@Override
	public void setAddress8(String address8) {
		this.address8 = address8;
	}
	@Override
	public String getAddress9() {
		return address9;
	}
	@Override
	public void setAddress9(String address9) {
		this.address9 = address9;
	}
	@Override
	public String getAddress10() {
		return address10;
	}
	@Override
	public void setAddress10(String address10) {
		this.address10 = address10;
	}
	@Override
	public String getAddress11() {
		return address11;
	}
	@Override
	public void setAddress11(String address11) {
		this.address11 = address11;
	}
	@Override
	public String getAddress12() {
		return address12;
	}
	@Override
	public void setAddress12(String address12) {
		this.address12 = address12;
	}
	@Override
	public String getAddress13() {
		return address13;
	}
	@Override
	public void setAddress13(String address13) {
		this.address13 = address13;
	}
	@Override
	public String getAddress14() {
		return address14;
	}
	@Override
	public void setAddress14(String address14) {
		this.address14 = address14;
	}
	@Override
	public String getAddress15() {
		return address15;
	}
	@Override
	public void setAddress15(String address15) {
		this.address15 = address15;
	}
}
package org.openmrs.util;
import org.apache.commons.lang.StringUtils;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.exception.ParseErrorException;
import org.joda.time.LocalTime;
import org.openmrs.Concept;
import org.openmrs.Obs;
import org.openmrs.Person;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import java.io.StringWriter;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
public class ConceptReferenceRangeUtility {
	public ConceptReferenceRangeUtility() {
	}
	public boolean evaluateCriteria(String criteria, Obs obs) {
		if (obs == null) {
			throw new IllegalArgumentException("Failed to evaluate criteria with reason: Obs is null");
		}
		if (obs.getPerson() == null) {
			throw new IllegalArgumentException("Failed to evaluate criteria with reason: patient is null");
		}
		if (StringUtils.isBlank(criteria)) {
			throw new IllegalArgumentException("Failed to evaluate criteria with reason: criteria is empty");
		}
		VelocityContext velocityContext = new VelocityContext();
		velocityContext.put("fn", this);
		velocityContext.put("obs", obs);
		velocityContext.put("patient", obs.getPerson());
		VelocityEngine velocityEngine = new VelocityEngine();
		StringWriter writer = new StringWriter();
		String wrappedCriteria = "#set( $criteria = " + criteria + " )$criteria";
		try {
			velocityEngine.evaluate(velocityContext, writer, ConceptReferenceRangeUtility.class.getName(), wrappedCriteria);
			return Boolean.parseBoolean(writer.toString());
		}
		catch (ParseErrorException e) {
			throw new APIException("An error occurred while evaluating criteria. Invalid criteria: " + criteria, e);
		}
		catch (Exception e) {
			throw new APIException("An error occurred while evaluating criteria: ", e);
		}
	}
	public Obs getLatestObs(String conceptRef, Person person) {
		Concept concept = Context.getConceptService().getConceptByReference(conceptRef);
		if (concept != null) {
			List<Obs> observations = Context.getObsService().getObservations(
				Collections.singletonList(person), 
				null, 
				Collections.singletonList(concept), 
				null, 
				null, 
				null,
				Collections.singletonList("dateCreated"), 
				1, 
				null,
				null, 
				null, 
				false
			);
			return observations.isEmpty() ? null : observations.get(0);
		}
		return null;
	}
	public int getCurrentHour() {
		return LocalTime.now().getHourOfDay();
	}
	public Obs getCurrentObs(String conceptRef, Obs currentObs) {
		Concept concept = Context.getConceptService().getConceptByReference(conceptRef);
		if (currentObs.getValueAsString(Locale.ENGLISH).isEmpty() && (concept != null && concept == currentObs.getConcept())) {
			return currentObs;
		} else {
			return getLatestObs(conceptRef, currentObs.getPerson());
		}
	}
}
package org.openmrs.api;
import org.openmrs.api.context.Context;
public class APIException extends RuntimeException {
	public static final long serialVersionUID = 12121212L;
	public APIException() {
	}
	public APIException(String message) {
		super(message);
	}
	public APIException(String message, Throwable cause) {
		super(message, cause);
	}
	public APIException(Throwable cause) {
		super(cause);
	}
	public APIException(String messageKey, Object[] parameters) {
		super(Context.getMessageSourceService().getMessage(messageKey, parameters, Context.getLocale()));
	}
	public APIException(String messageKey, Object[] parameters, Throwable cause) {
		super(Context.getMessageSourceService().getMessage(messageKey, parameters, Context.getLocale()), cause);
	}
}
package org.openmrs;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.ContainedIn;
import org.hibernate.search.annotations.DocumentId;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.FullTextFilterDef;
import org.hibernate.search.annotations.FullTextFilterDefs;
import org.hibernate.search.annotations.IndexedEmbedded;
import org.openmrs.annotation.AllowDirectAccess;
import org.openmrs.api.APIException;
import org.openmrs.api.ConceptNameType;
import org.openmrs.api.ConceptService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.hibernate.search.TermsFilterFactory;
import org.openmrs.customdatatype.CustomValueDescriptor;
import org.openmrs.customdatatype.Customizable;
import org.openmrs.util.LocaleUtility;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.ObjectUtils;
@FullTextFilterDefs( { @FullTextFilterDef(name = "termsFilterFactory", impl = TermsFilterFactory.class) })
@Audited
public class Concept extends BaseOpenmrsObject implements Auditable, Retireable, Serializable, Attributable<Concept>,Customizable<ConceptAttribute> {
	public static final long serialVersionUID = 57332L;
	private static final Logger log = LoggerFactory.getLogger(Concept.class);
	private static final String CONCEPT_NAME_LOCALE_NULL = "Concept.name.locale.null";
	@DocumentId
	private Integer conceptId;
	@Field
	private Boolean retired = false;
	private User retiredBy;
	private Date dateRetired;
	private String retireReason;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private ConceptDatatype datatype;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private ConceptClass conceptClass;
	private Boolean set = false;
	private String version;
	private User creator;
	private Date dateCreated;
	private User changedBy;
	private Date dateChanged;
	@AllowDirectAccess
	@ContainedIn
	private Collection<ConceptName> names;
	@AllowDirectAccess
	private Collection<ConceptAnswer> answers;
	private Collection<ConceptSet> conceptSets;
	private Collection<ConceptDescription> descriptions;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private Collection<ConceptMap> conceptMappings;
	private Map<Locale, List<ConceptName>> compatibleCache;
	private Set<ConceptAttribute> attributes = new LinkedHashSet<>();
	public Concept() {
		names = new HashSet<>();
		answers = new HashSet<>();
		conceptSets = new TreeSet<>();
		descriptions = new HashSet<>();
		conceptMappings = new HashSet<>();
	}
	public Concept(Integer conceptId) {
		this();
		this.conceptId = conceptId;
	}
	public Collection<ConceptAnswer> getAnswers() {
		if (answers == null) {
			answers = new HashSet<>();
		}
		return answers;
	}
	public Collection<ConceptAnswer> getAnswers(boolean includeRetired) {
		if (includeRetired) {
			return getAnswers();
		} else {
			return getAnswers().stream()
					.filter(a -> !a.getAnswerConcept().getRetired())
					.collect(Collectors.toSet());
		}
	}
	public void setAnswers(Collection<ConceptAnswer> answers) {
		this.answers = answers;
	}
	public void addAnswer(ConceptAnswer conceptAnswer) {
		if (conceptAnswer != null) {
			if (!getAnswers().contains(conceptAnswer)) {
				conceptAnswer.setConcept(this);
				getAnswers().add(conceptAnswer);
			}
			if ((conceptAnswer.getSortWeight() == null) || (conceptAnswer.getSortWeight() <= 0)) {
				ConceptAnswer a = Collections.max(answers);
				Double sortWeight = (a == null) ? 1d : ((a.getSortWeight() == null) ? 1d : a.getSortWeight() + 1d);
				conceptAnswer.setSortWeight(sortWeight);
			}
		}
	}
	public boolean removeAnswer(ConceptAnswer conceptAnswer) {
		return getAnswers().remove(conceptAnswer);
	}
	@Override
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	public ConceptClass getConceptClass() {
		return conceptClass;
	}
	public void setConceptClass(ConceptClass conceptClass) {
		this.conceptClass = conceptClass;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isSet() {
		return getSet();
	}
	public void setSet(Boolean set) {
		this.set = set;
	}
	public Boolean getSet() {
		return set;
	}
	public ConceptDatatype getDatatype() {
		return datatype;
	}
	public void setDatatype(ConceptDatatype conceptDatatype) {
		this.datatype = conceptDatatype;
	}
	public Integer getConceptId() {
		return conceptId;
	}
	public void setConceptId(Integer conceptId) {
		this.conceptId = conceptId;
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	@Override
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	public void setPreferredName(ConceptName preferredName) {
		if (preferredName == null || preferredName.getVoided() || preferredName.isIndexTerm()) {
			throw new APIException("Concept.error.preferredName.null", (Object[]) null);
		} else if (preferredName.getLocale() == null) {
			throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
		}
		ConceptName oldPreferredName = getPreferredName(preferredName.getLocale(), true);
		if (oldPreferredName != null) {
			oldPreferredName.setLocalePreferred(false);
		}
		preferredName.setLocalePreferred(true);
		if (preferredName.getConceptNameId() == null || !getNames().contains(preferredName)) {
			addName(preferredName);
		}
	}
	public ConceptName findNameTaggedWith(ConceptNameTag conceptNameTag) {
		ConceptName taggedName = null;
		for (ConceptName possibleName : getNames()) {
			if (possibleName.hasTag(conceptNameTag)) {
				taggedName = possibleName;
				break;
			}
		}
		return taggedName;
	}
	public ConceptName getName(Locale locale) {
		return getName(locale, false);
	}
	public ConceptName getName() {
		if (getNames().isEmpty()) {
			log.debug("there are no names defined for: {}", conceptId);
			return null;
		}
		for (Locale currentLocale : LocaleUtility.getLocalesInOrder()) {
			ConceptName preferredName = getPreferredName(currentLocale);
			if (preferredName != null) {
				return preferredName;
			}
			ConceptName fullySpecifiedName = getFullySpecifiedName(currentLocale);
			if (fullySpecifiedName != null) {
				return fullySpecifiedName;
			}
			if (!StringUtils.isBlank(currentLocale.getCountry()) || !StringUtils.isBlank(currentLocale.getVariant())) {
				Locale broaderLocale = new Locale(currentLocale.getLanguage());
				ConceptName prefNameInBroaderLoc = getPreferredName(broaderLocale);
				if (prefNameInBroaderLoc != null) {
					return prefNameInBroaderLoc;
				}
				ConceptName fullySpecNameInBroaderLoc = getFullySpecifiedName(broaderLocale);
				if (fullySpecNameInBroaderLoc != null) {
					return fullySpecNameInBroaderLoc;
				}
			}
		}
		for (ConceptName cn : getNames()) {
			if (cn.isFullySpecifiedName()) {
				return cn;
			}
		}
		if (!getSynonyms().isEmpty()) {
			return getSynonyms().iterator().next();
		}
		return null;
	}
	public boolean hasName(String name, Locale locale) {
		if (name == null) {
			return false;
		}
		Collection<ConceptName> currentNames;
		if (locale == null) {
			currentNames = getNames();
		} else {
			currentNames = getNames(locale);
		}
		for (ConceptName currentName : currentNames) {
			if (name.equalsIgnoreCase(currentName.getName())) {
				return true;
			}
		}
		return false;
	}
	public ConceptName getName(Locale locale, ConceptNameType ofType, ConceptNameTag havingTag) {
		Collection<ConceptName> namesInLocale = getNames(locale);
		if (!namesInLocale.isEmpty()) {
			List<ConceptName> matches = namesInLocale.stream().filter(
				c->(ofType==null || ofType.equals(c.getConceptNameType())) && (havingTag==null || c.hasTag(havingTag))
			).collect(Collectors.toList());
			if (matches.size() == 1) {
				return matches.get(0);
			} else if (matches.size() > 1) {
				for (ConceptName match : matches) {
					if (match.getLocalePreferred()) {
						return match;
					}
				}
				return matches.get(0);
			}
		}
		Locale parent = new Locale(locale.getLanguage());
		if (!parent.equals(locale)) {
			return getName(parent, ofType, havingTag);
		} else {
			return null;
		}
	}
	public ConceptName getName(Locale locale, boolean exact) {
		if (getNames().isEmpty()) {
			log.debug("there are no names defined for: {}", conceptId);
			return null;
		}
		log.debug("Getting conceptName for locale: {}", locale);
		ConceptName exactName = getNameInLocale(locale);
		if (exactName != null) {
			return exactName;
		}
		if (!exact) {
			Locale broaderLocale = new Locale(locale.getLanguage());
			ConceptName name = getNameInLocale(broaderLocale);
			return name != null ? name : getName();
		}
		return null;
	}
	private ConceptName getNameInLocale(Locale locale) {
		ConceptName preferredName = getPreferredName(locale);
		if (preferredName != null) {
			return preferredName;
		}
		ConceptName fullySpecifiedName = getFullySpecifiedName(locale);
		if (fullySpecifiedName != null) {
			return fullySpecifiedName;
		} else if (!getSynonyms(locale).isEmpty()) {
			return getSynonyms(locale).iterator().next();
		}
		return null;
	}
	public ConceptName getPreferredName(Locale forLocale) {
		return getPreferredName(forLocale, false);
	}
	public ConceptName getPreferredName(Locale forLocale, Boolean exact) {
		if (log.isDebugEnabled()) {
			log.debug("Getting preferred conceptName for locale: " + forLocale);
		}
		if (forLocale == null) {
			log.warn("Locale cannot be null");
			return null;
		}
		for (ConceptName nameInLocale : getNames(forLocale)) {
			if (ObjectUtils.nullSafeEquals(nameInLocale.getLocalePreferred(), true)) {
				return nameInLocale;
			}
		}
		if (exact) {
			return null;
		} else {
			ConceptName bestMatch = null;
			for (ConceptName nameInLocale : getPartiallyCompatibleNames(forLocale)) {
				if (ObjectUtils.nullSafeEquals(nameInLocale.getLocalePreferred(), true)) {
					Locale nameLocale = nameInLocale.getLocale();
					if (forLocale.getLanguage().equals(nameLocale.getLanguage())) {
						return nameInLocale;
					} else {
						bestMatch = nameInLocale;
					}
				}
			}
			if (bestMatch != null) {
				return bestMatch;
			}
			return getFullySpecifiedName(forLocale);
		}
	}
	public ConceptName getFullySpecifiedName(Locale locale) {
		if (locale != null && !getNames(locale).isEmpty()) {
			for (ConceptName conceptName : getNames(locale)) {
				if (ObjectUtils.nullSafeEquals(conceptName.isFullySpecifiedName(), true)) {
					return conceptName;
				}
			}
			ConceptName bestMatch = null;
			for (ConceptName conceptName : getPartiallyCompatibleNames(locale)) {
				if (ObjectUtils.nullSafeEquals(conceptName.isFullySpecifiedName(), true)) {
					Locale nameLocale = conceptName.getLocale();
					if (locale.getLanguage().equals(nameLocale.getLanguage())) {
						return conceptName;
					}
					bestMatch = conceptName;
				}
			}
			return bestMatch;
		}
		return null;
	}
	public Collection<ConceptName> getNames(Locale locale) {
		return getNames().stream()
				.filter(n -> n.getLocale().equals(locale))
				.collect(Collectors.toSet());
	}
	private Collection<ConceptName> getPartiallyCompatibleNames(Locale locale) {
		String language = locale.getLanguage();
		String country = locale.getCountry();
		return getNames().stream()
				.filter(n -> language.equals(n.getLocale().getLanguage()) || 
							StringUtils.isNotBlank(country) && country.equals(n.getLocale().getCountry()))
				.collect(Collectors.toSet());
	}
	public List<ConceptName> getCompatibleNames(Locale desiredLocale) {
		List<ConceptName> compatibleNames = null;
		if (compatibleCache == null) {
			compatibleCache = new HashMap<>();
		} else {
			compatibleNames = compatibleCache.get(desiredLocale);
		}
		if (compatibleNames == null) {
			compatibleNames = new ArrayList<>();
			for (ConceptName possibleName : getNames()) {
				if (LocaleUtility.areCompatible(possibleName.getLocale(), desiredLocale)) {
					compatibleNames.add(possibleName);
				}
			}
			compatibleCache.put(desiredLocale, compatibleNames);
		}
		return compatibleNames;
	}
	public void setFullySpecifiedName(ConceptName fullySpecifiedName) {
		if (fullySpecifiedName == null || fullySpecifiedName.getLocale() == null) {
			throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
		} else if (fullySpecifiedName.getVoided()) {
			throw new APIException("Concept.error.fullySpecifiedName.null", (Object[]) null);
		}
		ConceptName oldFullySpecifiedName = getFullySpecifiedName(fullySpecifiedName.getLocale());
		if (oldFullySpecifiedName != null) {
			oldFullySpecifiedName.setConceptNameType(null);
		}
		fullySpecifiedName.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
		if (fullySpecifiedName.getConceptNameId() == null || !getNames().contains(fullySpecifiedName)) {
			addName(fullySpecifiedName);
		}
	}
	public void setShortName(ConceptName shortName) {
		if (shortName != null) {
			if (shortName.getLocale() == null) {
				throw new APIException(CONCEPT_NAME_LOCALE_NULL, (Object[]) null);
			}
			ConceptName oldShortName = getShortNameInLocale(shortName.getLocale());
			if (oldShortName != null) {
				oldShortName.setConceptNameType(null);
			}
			shortName.setConceptNameType(ConceptNameType.SHORT);
			if (StringUtils.isNotBlank(shortName.getName())
			        && (shortName.getConceptNameId() == null || !getNames().contains(shortName))) {
				addName(shortName);
			}
		} else {
			throw new APIException("Concept.error.shortName.null", (Object[]) null);
		}
	}
	public ConceptName getShortNameInLocale(Locale locale) {
		ConceptName bestMatch = null;
		if (locale != null && !getShortNames().isEmpty()) {
			for (ConceptName shortName : getShortNames()) {
				Locale nameLocale = shortName.getLocale();
				if (nameLocale.equals(locale)) {
					return shortName;
				}
				if (OpenmrsUtil.nullSafeEquals(locale.getLanguage(), nameLocale.getLanguage())) {
					bestMatch = shortName;
				} else if (bestMatch == null && StringUtils.isNotBlank(locale.getCountry())
				        && locale.getCountry().equals(nameLocale.getCountry())) {
					bestMatch = shortName;
				}
			}
		}
		return bestMatch;
	}
	public Collection<ConceptName> getShortNames() {
		List<ConceptName> shortNames = new ArrayList<>();
		if (getNames().isEmpty()) {
			if (log.isDebugEnabled()) {
				log.debug("The Concept with id: " + conceptId + " has no names");
			}
		} else {
			shortNames = getNames().stream()
							.filter(ConceptName::isShort)
							.collect(Collectors.toList());
		}
		return shortNames;
	}
	public ConceptName getShortestName(Locale locale, Boolean exact) {
		if (log.isDebugEnabled()) {
			log.debug("Getting shortest conceptName for locale: " + locale);
		}
		ConceptName shortNameInLocale = getShortNameInLocale(locale);
		if (shortNameInLocale != null) {
			return shortNameInLocale;
		}
		ConceptName shortestNameForLocale = null;
		ConceptName shortestNameForConcept = null;
		if (locale != null) {
			for (ConceptName possibleName : getNames()) {
				if (possibleName.getLocale().equals(locale)
				        && ((shortestNameForLocale == null) || (possibleName.getName().length() < shortestNameForLocale
				                .getName().length()))) {
					shortestNameForLocale = possibleName;
				}
				if ((shortestNameForConcept == null)
				        || (possibleName.getName().length() < shortestNameForConcept.getName().length())) {
					shortestNameForConcept = possibleName;
				}
			}
		}
		if (exact) {
			if (shortestNameForLocale == null) {
				log.warn("No short concept name found for concept id " + conceptId + " for locale "
				        + locale.getDisplayName());
			}
			return shortestNameForLocale;
		}
		return shortestNameForConcept;
	}
	public boolean isNamed(String name) {
		return getNames().stream().anyMatch(cn -> name.equals(cn.getName()));
	}
	public Collection<ConceptName> getIndexTerms() {
		return getNames().stream()
				.filter(ConceptName::isIndexTerm)
				.collect(Collectors.toSet());		
	}
	public Collection<ConceptName> getIndexTermsForLocale(Locale locale) {
		return getIndexTerms().stream()
				.filter(n -> n.getLocale().equals(locale))
		        .collect(Collectors.toList());
	}
	public Collection<ConceptName> getNames() {
		return getNames(false);
	}
	public Collection<ConceptName> getNames(boolean includeVoided) {
		if (names == null) {
			names = new HashSet<>();
		}
		return names.stream()
				.filter(n -> includeVoided || !n.getVoided())
				.collect(Collectors.toSet());
	}
	public void setNames(Collection<ConceptName> names) {
		this.names = names;
	}
	public void addName(ConceptName conceptName) {
		if (conceptName != null) {
			conceptName.setConcept(this);
			if (names == null) {
				names = new HashSet<>();
			}
			if (!names.contains(conceptName)) {
				if (getNames().isEmpty()
				        && !ConceptNameType.FULLY_SPECIFIED.equals(conceptName.getConceptNameType())) {
					conceptName.setConceptNameType(ConceptNameType.FULLY_SPECIFIED);
				} else {
					if (conceptName.isPreferred() && !conceptName.isIndexTerm() && conceptName.getLocale() != null) {
						ConceptName prefName = getPreferredName(conceptName.getLocale(), true);
						if (prefName != null) {
							prefName.setLocalePreferred(false);
						}
					}
					if (conceptName.isFullySpecifiedName() && conceptName.getLocale() != null) {
						ConceptName fullySpecName = getFullySpecifiedName(conceptName.getLocale());
						if (fullySpecName != null) {
							fullySpecName.setConceptNameType(null);
						}
					} else if (conceptName.isShort() && conceptName.getLocale() != null) {
						ConceptName shortName = getShortNameInLocale(conceptName.getLocale());
						if (shortName != null) {
							shortName.setConceptNameType(null);
						}
					}
				}
				names.add(conceptName);
				if (compatibleCache != null) {
					compatibleCache.clear();
				}
			}
		}
	}
	public boolean removeName(ConceptName conceptName) {
		if (names != null) {
			return names.remove(conceptName);
		} else {
			return false;
		}
	}
	public ConceptDescription getDescription() {
		return getDescription(Context.getLocale());
	}
	public ConceptDescription getDescription(Locale locale) {
		return getDescription(locale, false);
	}
	public ConceptDescription getDescription(Locale locale, boolean exact) {
		log.debug("Getting ConceptDescription for locale: " + locale);
		ConceptDescription foundDescription = null;
		if (locale == null) {
			locale = LocaleUtility.getDefaultLocale();
		}
		Locale desiredLocale = locale;
		ConceptDescription defaultDescription = null;
		for (ConceptDescription availableDescription : getDescriptions()) {
			Locale availableLocale = availableDescription.getLocale();
			if (availableLocale.equals(desiredLocale)) {
				foundDescription = availableDescription;
				break;
			}
			if (!exact && LocaleUtility.areCompatible(availableLocale, desiredLocale)) {
				foundDescription = availableDescription;
			}
			if (availableLocale.equals(LocaleUtility.getDefaultLocale())) {
				defaultDescription = availableDescription;
			}
		}
		if (foundDescription == null) {
			if (exact) {
				log.debug("No concept description found for concept id " + conceptId + " for locale "
				        + desiredLocale.toString());
			} else {
				if (defaultDescription == null) {
					log.debug("No concept description found for default locale for concept id " + conceptId);
				} else {
					foundDescription = defaultDescription;
				}
			}
		}
		return foundDescription;
	}
	@Override
	public User getRetiredBy() {
		return retiredBy;
	}
	@Override
	public void setRetiredBy(User retiredBy) {
		this.retiredBy = retiredBy;
	}
	@Override
	public Date getDateRetired() {
		return dateRetired;
	}
	@Override
	public void setDateRetired(Date dateRetired) {
		this.dateRetired = dateRetired;
	}
	@Override
	public String getRetireReason() {
		return retireReason;
	}
	@Override
	public void setRetireReason(String retireReason) {
		this.retireReason = retireReason;
	}
	public Collection<ConceptDescription> getDescriptions() {
		if (descriptions == null) {
			descriptions = new HashSet<>();
		}
		return descriptions;
	}
	public void setDescriptions(Collection<ConceptDescription> descriptions) {
		this.descriptions = descriptions;
	}
	public void addDescription(ConceptDescription description) {
		if (description != null && StringUtils.isNotBlank(description.getDescription()) && !descriptions.contains(description)) {
			description.setConcept(this);
			descriptions.add(description);
		}
	}
	public boolean removeDescription(ConceptDescription description) {
		return descriptions.remove(description);
	}
	@Override
	@Deprecated
	@JsonIgnore
	public Boolean isRetired() {
		return getRetired();
	}
	@Override
	public Boolean getRetired() {
		return retired;
	}
	@Override
	public void setRetired(Boolean retired) {
		this.retired = retired;
	}
	public Collection<ConceptName> getSynonyms(Locale locale) {
		List<ConceptName> syns = new ArrayList<>();
		ConceptName preferredConceptName = null;
		for (ConceptName possibleSynonymInLoc : getSynonyms()) {
			if (locale.equals(possibleSynonymInLoc.getLocale())) {
				if (possibleSynonymInLoc.isPreferred()) {
					preferredConceptName = possibleSynonymInLoc;
				} else {
					syns.add(possibleSynonymInLoc);
				}
			}
		}
		if (preferredConceptName != null) {
			syns.add(0, preferredConceptName);
		}
		log.debug("returning: " + syns);
		return syns;
	}
	public Collection<ConceptName> getSynonyms() {
		return getNames().stream()
				.filter(ConceptName::isSynonym)
				.collect(Collectors.toSet());
	}
	public String getVersion() {
		return version;
	}
	public void setVersion(String version) {
		this.version = version;
	}
	public Collection<ConceptSet> getConceptSets() {
		return conceptSets;
	}
	public void setConceptSets(Collection<ConceptSet> conceptSets) {
		this.conceptSets = conceptSets;
	}
	public boolean isNumeric() {
		return false;
	}
	public Collection<ConceptMap> getConceptMappings() {
		if (conceptMappings == null) {
			conceptMappings = new HashSet<>();
		}
		return conceptMappings;
	}
	public void setConceptMappings(Collection<ConceptMap> conceptMappings) {
		this.conceptMappings = conceptMappings;
	}
	public void addConceptMapping(ConceptMap newConceptMap) {
		if (newConceptMap != null) {
			newConceptMap.setConcept(this);
		}
		if (newConceptMap != null && !getConceptMappings().contains(newConceptMap)) {
			if (newConceptMap.getConceptMapType() == null) {
				newConceptMap.setConceptMapType(Context.getConceptService().getDefaultConceptMapType());
			}
			getConceptMappings().add(newConceptMap);
		}
	}
	public boolean isComplex() {
		return false;
	}
	public boolean removeConceptMapping(ConceptMap conceptMap) {
		return getConceptMappings().remove(conceptMap);
	}
	@Override
	public String toString() {
		return "Concept #" + conceptId;
	}
	@Override
	@Deprecated
	public List<Concept> findPossibleValues(String searchText) {
		List<Concept> concepts = new ArrayList<>();
		try {
			for (ConceptSearchResult searchResult : Context.getConceptService().getConcepts(searchText,
			    Collections.singletonList(Context.getLocale()), false, null, null, null, null, null, null, null)) {
				concepts.add(searchResult.getConcept());
			}
		}
		catch (Exception e) {
		}
		return concepts;
	}
	@Override
	@Deprecated
	public List<Concept> getPossibleValues() {
		try {
			return Context.getConceptService().getConceptsByName("");
		}
		catch (Exception e) {
		}
		return Collections.emptyList();
	}
	@Override
	public Concept hydrate(String reference) {
		try {
			return Context.getConceptService().getConceptByReference(reference);
		}
		catch (Exception e) {
		}
		return null;
	}
	@Override
	public String serialize() {
		if (this.getConceptId() == null) {
			return "";
		}
		return "" + this.getConceptId();
	}
	@Override
	public String getDisplayString() {
		if (getName() == null) {
			return toString();
		} else {
			return getName().getName();
		}
	}
	public Set<Locale> getAllConceptNameLocales() {
		if (getNames().isEmpty()) {
			if (log.isDebugEnabled()) {
				log.debug("The Concept with id: " + conceptId + " has no names");
			}
			return null;
		}
		Set<Locale> locales = new HashSet<>();
		for (ConceptName cn : getNames()) {
			locales.add(cn.getLocale());
		}
		return locales;
	}
	@Override
	public Integer getId() {
		return getConceptId();
	}
	@Override
	public void setId(Integer id) {
		setConceptId(id);
	}
	private List<ConceptSet> getSortedConceptSets() {
		List<ConceptSet> cs = new ArrayList<>();
		if (conceptSets != null) {
			cs.addAll(conceptSets);
			Collections.sort(cs);
		}
		return cs;
	}
	public List<Concept> getSetMembers() {
		List<Concept> conceptMembers = new ArrayList<>();
		Collection<ConceptSet> sortedConceptSet = getSortedConceptSets();
		for (ConceptSet conceptSet : sortedConceptSet) {
			conceptMembers.add(conceptSet.getConcept());
		}
		return Collections.unmodifiableList(conceptMembers);
	}
	public List<Concept> getSetMembers(boolean includeRetired) {
		if (includeRetired) {
			return getSetMembers();
		} else {
			return getSetMembers().stream()
				.filter(a -> !a.getRetired())
				.collect(Collectors.toList());
		}
	}
	public void addSetMember(Concept setMember) {
		addSetMember(setMember, -1);
	}
	public void addSetMember(Concept setMember, int index) {
		List<ConceptSet> sortedConceptSets = getSortedConceptSets();
		int setsSize = sortedConceptSets.size();
		double weight = 990.0;
		for (ConceptSet conceptSet : sortedConceptSets) {
			weight += 10.0;
			conceptSet.setSortWeight(weight);
		}
		if (sortedConceptSets.isEmpty()) {
			weight = 1000.0;
		} else if (index == -1 || index >= setsSize) {
			weight = sortedConceptSets.get(setsSize - 1).getSortWeight() + 10.0;
		} else if (index == 0) {
			weight = sortedConceptSets.get(0).getSortWeight() - 10.0;
		} else {
			double prevSortWeight = sortedConceptSets.get(index - 1).getSortWeight();
			double nextSortWeight = sortedConceptSets.get(index).getSortWeight();
			weight = (prevSortWeight + nextSortWeight) / 2;
		}
		ConceptSet conceptSet = new ConceptSet(setMember, weight);
		conceptSet.setConceptSet(this);
		conceptSets.add(conceptSet);
	}
	@Override
	public Set<ConceptAttribute> getAttributes() {
		if (attributes == null) {
			attributes = new LinkedHashSet<>();
		}
		return attributes;
	}
	@Override
	public Collection<ConceptAttribute> getActiveAttributes() {
		return getAttributes().stream()
				.filter(attr -> !attr.getVoided())
				.collect(Collectors.toList());
	}
	@Override
	public List<ConceptAttribute> getActiveAttributes(CustomValueDescriptor ofType) {
		return getAttributes().stream()
				.filter(attr -> attr.getAttributeType().equals(ofType) && !attr.getVoided())
				.collect(Collectors.toList());
	}
	public void setAttributes(Set<ConceptAttribute> attributes) {
		this.attributes = attributes;
	}
	@Override
	public void addAttribute(ConceptAttribute attribute) {
		getAttributes().add(attribute);
		attribute.setOwner(this);
	}
}
package org.openmrs;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.envers.Audited;
import org.openmrs.api.APIException;
import javax.persistence.Column;
import javax.persistence.MappedSuperclass;
@MappedSuperclass
@Audited
public abstract class BaseFormRecordableOpenmrsData extends BaseChangeableOpenmrsData implements FormRecordable {
	private static final long serialVersionUID = 1L;
	protected static final String FORM_NAMESPACE_PATH_SEPARATOR = "^";
	protected static final int FORM_NAMESPACE_PATH_MAX_LENGTH = 255;
	@Column(name = "form_namespace_and_path")
	protected String formNamespaceAndPath;
	@Override
	public String getFormFieldNamespace() {
		return BaseFormRecordableOpenmrsData.getFormFieldNamespace(formNamespaceAndPath);
	}
	@Override
	public String getFormFieldPath() {
		return BaseFormRecordableOpenmrsData.getFormFieldPath(formNamespaceAndPath);
	}
	@Override
	public void setFormField(String namespace, String formFieldPath) {
		formNamespaceAndPath = BaseFormRecordableOpenmrsData.getFormNamespaceAndPath(namespace, formFieldPath);
	}
	public String getFormNamespaceAndPath() {
		return formNamespaceAndPath;
	}
	public void setFormNamespaceAndPath(String formNamespaceAndPath) {
		this.formNamespaceAndPath = formNamespaceAndPath;
	}
	public static String getFormFieldNamespace(String formNamespaceAndPath) {
		if (StringUtils.isNotBlank(formNamespaceAndPath)) {
			if (formNamespaceAndPath.startsWith(FORM_NAMESPACE_PATH_SEPARATOR)) {
				return null;
			}
			return formNamespaceAndPath.substring(0, formNamespaceAndPath.indexOf(FORM_NAMESPACE_PATH_SEPARATOR));
		}
		return formNamespaceAndPath;
	}
	public static String getFormFieldPath(String formNamespaceAndPath) {
		if (StringUtils.isNotBlank(formNamespaceAndPath)) {
			if (formNamespaceAndPath.endsWith(FORM_NAMESPACE_PATH_SEPARATOR)) {
				return null;
			}
			return formNamespaceAndPath.substring(formNamespaceAndPath.indexOf(FORM_NAMESPACE_PATH_SEPARATOR) + 1);
		}
		return formNamespaceAndPath;
	}
	public static String getFormNamespaceAndPath(String namespace, String formFieldPath) {
		if (namespace == null && formFieldPath == null) {
			return null;
		}
		String nsAndPathTemp = "";
		if (StringUtils.isNotBlank(namespace) && StringUtils.isNotBlank(formFieldPath)) {
			nsAndPathTemp = namespace + FORM_NAMESPACE_PATH_SEPARATOR + formFieldPath;
		} else if (StringUtils.isNotBlank(namespace)) {
			nsAndPathTemp = namespace + FORM_NAMESPACE_PATH_SEPARATOR;
		} else if (StringUtils.isNotBlank(formFieldPath)) {
			nsAndPathTemp = FORM_NAMESPACE_PATH_SEPARATOR + formFieldPath;
		}
		if (nsAndPathTemp.length() > FORM_NAMESPACE_PATH_MAX_LENGTH) {
			throw new APIException("BaseFormRecordableOpenmrsData.namespaceAndPathTooLong", (Object[]) null);
		}
		if (StringUtils.countMatches(nsAndPathTemp, FORM_NAMESPACE_PATH_SEPARATOR) > 1) {
			throw new APIException("BaseFormRecordableOpenmrsData.namespaceAndPathNotContainSeparator", (Object[]) null);
		}
		return nsAndPathTemp;
	}
}
package org.openmrs;
import java.util.Date;
import org.hibernate.envers.Audited;
import org.openmrs.util.OpenmrsConstants;
@Audited
public class ConceptProposal extends BaseOpenmrsObject {
	public static final long serialVersionUID = 57344L;
	private Integer conceptProposalId;
	private Encounter encounter;
	private Concept obsConcept;
	private Obs obs;
	private Concept mappedConcept;
	private String originalText;
	private String finalText;
	private String state;
	private String comments;
	private User creator;
	private Date dateCreated;
	private User changedBy;
	private Date dateChanged;
	public ConceptProposal() {
	}
	public ConceptProposal(Integer conceptProposalId) {
		this.conceptProposalId = conceptProposalId;
	}
	public User getChangedBy() {
		return changedBy;
	}
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	public Integer getConceptProposalId() {
		return conceptProposalId;
	}
	public void setConceptProposalId(Integer conceptProposalId) {
		this.conceptProposalId = conceptProposalId;
	}
	public User getCreator() {
		return creator;
	}
	public void setCreator(User creator) {
		this.creator = creator;
	}
	public Date getDateChanged() {
		return dateChanged;
	}
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	public Date getDateCreated() {
		return dateCreated;
	}
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	public String getOriginalText() {
		return originalText;
	}
	public void setOriginalText(String originalText) {
		this.originalText = originalText;
	}
	public String getFinalText() {
		return finalText;
	}
	public void setFinalText(String t) {
		this.finalText = t;
	}
	public String getComments() {
		return comments;
	}
	public void setComments(String comments) {
		this.comments = comments;
	}
	public String getState() {
		return state;
	}
	public void setState(String state) {
		this.state = state;
	}
	public Encounter getEncounter() {
		return encounter;
	}
	public void setEncounter(Encounter encounter) {
		this.encounter = encounter;
	}
	@Override
	public String toString() {
		if (conceptProposalId == null) {
			return "";
		}
		return conceptProposalId.toString();
	}
	public Obs getObs() {
		return obs;
	}
	public void setObs(Obs obs) {
		this.obs = obs;
	}
	public Concept getObsConcept() {
		return obsConcept;
	}
	public void setObsConcept(Concept obsConcept) {
		this.obsConcept = obsConcept;
	}
	public Concept getMappedConcept() {
		return mappedConcept;
	}
	public void setMappedConcept(Concept mappedConcept) {
		this.mappedConcept = mappedConcept;
	}
	public void rejectConceptProposal() {
		setState(OpenmrsConstants.CONCEPT_PROPOSAL_REJECT);
		setFinalText("");
	}
	@Override
	public Integer getId() {
		return getConceptProposalId();
	}
	@Override
	public void setId(Integer id) {
		setConceptProposalId(id);
	}
}
package org.openmrs;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Date;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import javax.persistence.Access;
import javax.persistence.AccessType;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OrderBy;
import javax.persistence.Table;
import org.hibernate.annotations.BatchSize;
import org.hibernate.annotations.Cascade;
import org.hibernate.envers.Audited;
import org.openmrs.annotation.AllowDirectAccess;
import org.openmrs.annotation.DisableHandlers;
import org.openmrs.api.context.Context;
import org.openmrs.api.handler.VoidHandler;
@Entity
@Table(name = "encounter")
@BatchSize(size = 25)
@Audited
public class Encounter extends BaseChangeableOpenmrsData {
	public static final long serialVersionUID = 2L;
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "encounter_id")
	private Integer encounterId;
	@Column(name = "encounter_datetime", nullable = false, length = 19)
	private Date encounterDatetime;
	@ManyToOne(optional = false)
	@JoinColumn(name = "patient_id")
	private Patient patient;
	@ManyToOne
	@JoinColumn(name = "location_id")
	private Location location;
	@ManyToOne
	@JoinColumn(name = "form_id")
	private Form form;
	@ManyToOne(optional = false)
	@JoinColumn(name = "encounter_type")
	private EncounterType encounterType;
	@OneToMany(mappedBy = "encounter")
	private Set<Order> orders;
	@OneToMany(mappedBy = "encounter")
	private Set<Diagnosis> diagnoses;
	@OneToMany(mappedBy = "encounter")
	private Set<Condition> conditions;
	@OneToMany(mappedBy = "encounter")
	@Access(AccessType.FIELD)
	@OrderBy("concept_id")
	@BatchSize(size = 25)
	@AllowDirectAccess
	private Set<Obs> obs;
	@ManyToOne
	@Cascade(org.hibernate.annotations.CascadeType.SAVE_UPDATE)
	@JoinColumn(name = "visit_id")
	private Visit visit;
	@OneToMany(mappedBy = "encounter", cascade = CascadeType.ALL)
	@OrderBy("provider_id")
	@DisableHandlers(handlerTypes = { VoidHandler.class })
	private Set<EncounterProvider> encounterProviders = new LinkedHashSet<>();
	@OneToMany(mappedBy = "encounter")
	private Set<Allergy> allergies;
	public Encounter() {
	}
	public Encounter(Integer encounterId) {
		this.encounterId = encounterId;
	}
	public Date getEncounterDatetime() {
		return encounterDatetime;
	}
	public void setEncounterDatetime(Date encounterDatetime) {
		this.encounterDatetime = encounterDatetime;
	}
	public Integer getEncounterId() {
		return encounterId;
	}
	public void setEncounterId(Integer encounterId) {
		this.encounterId = encounterId;
	}
	public EncounterType getEncounterType() {
		return encounterType;
	}
	public void setEncounterType(EncounterType encounterType) {
		this.encounterType = encounterType;
	}
	public Location getLocation() {
		return location;
	}
	public void setLocation(Location location) {
		this.location = location;
	}
	public Set<Obs> getObs() {
		Set<Obs> ret = new LinkedHashSet<>();
		if (this.obs != null) {
			for (Obs o : this.obs) {
				ret.addAll(getObsLeaves(o));
			}
		}
		return ret;
	}
	private List<Obs> getObsLeaves(Obs obsParent) {
		List<Obs> leaves = new ArrayList<>();
		if (obsParent.hasGroupMembers()) {
			for (Obs child : obsParent.getGroupMembers()) {
				if (!child.getVoided()) {
					if (!child.isObsGrouping()) {
						leaves.add(child);
					} else {
						leaves.addAll(getObsLeaves(child));
					}
				}
			}
		} else if (!obsParent.getVoided()) {
			leaves.add(obsParent);
		}
		return leaves;
	}
	private Set<Obs> getFlattenedObsLeaves(Obs obsParent, boolean includedVoided) {
		Set<Obs> leaves = new LinkedHashSet<>();
		if (includedVoided || (!obsParent.getVoided())) {
			leaves.add(obsParent);
			if (obsParent.hasGroupMembers()) {
				for (Obs child : obsParent.getGroupMembers(includedVoided)) {
					leaves.addAll(getFlattenedObsLeaves(child, includedVoided));
				}
			}
		}
		return leaves;
	}
	public Set<Obs> getAllObs(boolean includeVoided) {
		if (includeVoided && obs != null) {
			return obs;
		}
		Set<Obs> ret = new LinkedHashSet<>();
		if (this.obs != null) {
			ret = this.obs.stream().filter(o -> includeVoided || !o.getVoided()).collect(Collectors.toSet());
		}
		return ret;
	}
	public Set<Obs> getAllObs() {
		return getAllObs(false);
	}
	public Set<Obs> getAllFlattenedObs(boolean includeVoided) {
		Set<Obs> ret = new LinkedHashSet<>();
		if (this.obs != null) {
			for (Obs o : this.obs) {
				if (includeVoided || (!o.getVoided())) {
					ret.addAll(getFlattenedObsLeaves(o, includeVoided));
				}
			}
		}
		return ret;
	}
	public Set<Obs> getObsAtTopLevel(boolean includeVoided) {
		return getAllObs(includeVoided).stream().filter(o -> o.getObsGroup() == null)
		        .collect(Collectors.toCollection(LinkedHashSet::new));
	}
	public void setObs(Set<Obs> obs) {
		this.obs = obs;
	}
	public void addObs(Obs observation) {
		if (obs == null) {
			obs = new LinkedHashSet<>();
		}
		if (observation != null) {
			obs.add(observation);
			Deque<Obs> obsToUpdate = new ArrayDeque<>();
			obsToUpdate.add(observation);
			Set<Obs> seenIt = new LinkedHashSet<>();
			while (!obsToUpdate.isEmpty()) {
				Obs o = obsToUpdate.removeFirst();
				if (o == null || seenIt.contains(o)) {
					continue;
				}
				seenIt.add(o);
				o.setEncounter(this);
				if (o.getObsDatetime() == null) {
					o.setObsDatetime(getEncounterDatetime());
				}
				if (o.getPerson() == null) {
					o.setPerson(getPatient());
				}
				if (o.getLocation() == null) {
					o.setLocation(getLocation());
				}
				if (o.getGroupMembers(true) != null) {
					obsToUpdate.addAll(o.getGroupMembers());
				}
			}
		}
	}
	public void removeObs(Obs observation) {
		if (obs != null) {
			obs.remove(observation);
		}
	}
	public Set<Order> getOrders() {
		if (orders == null) {
			orders = new LinkedHashSet<>();
		}
		return orders;
	}
	public void setOrders(Set<Order> orders) {
		this.orders = orders;
	}
	public void addOrder(Order order) {
		if (order != null) {
			order.setEncounter(this);
			getOrders().add(order);
		}
	}
	public void removeOrder(Order order) {
		if (orders != null) {
			orders.remove(order);
		}
	}
	public Patient getPatient() {
		return patient;
	}
	public void setPatient(Patient patient) {
		this.patient = patient;
	}
	public Set<Diagnosis> getDiagnoses() {
		if (diagnoses == null) {
			diagnoses = new LinkedHashSet<>();
		}
		return diagnoses;
	}
	public void setDiagnoses(Set<Diagnosis> diagnoses) {
		this.diagnoses = diagnoses;
	}
	public Set<Condition> getConditions() {
		return getConditions(false);
	}
	public Set<Condition> getConditions(boolean includeVoided) {
		return Optional.ofNullable(conditions).orElse(new LinkedHashSet<>())
			.stream().filter(c -> includeVoided || !c.getVoided()).collect(Collectors.toSet());
	}
	public void setConditions(Set<Condition> conditions) {
		this.conditions = conditions;
	}
	public void addCondition(Condition condition) {
		if (conditions == null) {
			conditions = new LinkedHashSet<>();
		}
		if (condition != null) {
			condition.setEncounter(this);
			conditions.add(condition);
		}
	}
	public void removeCondition(Condition condition) {
		Optional.ofNullable(conditions).orElse(new LinkedHashSet<>()).stream().filter(c -> !c.getVoided() && c.equals(condition)).forEach(c -> {
			c.setVoided(true);
			c.setDateVoided(new Date());
			c.setVoidReason("Voided by the API");
			c.setVoidedBy(Context.getAuthenticatedUser());
		});
	}
	public Set<EncounterProvider> getEncounterProviders() {
		return encounterProviders;
	}
	public void setEncounterProviders(Set<EncounterProvider> encounterProviders) {
		this.encounterProviders = encounterProviders;
	}
	public Set<EncounterProvider> getActiveEncounterProviders() {
		Set<EncounterProvider> activeProviders = new LinkedHashSet<>();
		Set<EncounterProvider> providers = getEncounterProviders();
		if (providers != null && !providers.isEmpty()) {
			activeProviders = providers.stream().filter(p -> !p.getVoided()).collect(Collectors.toSet());
		}
		return activeProviders;
	}
	public Form getForm() {
		return form;
	}
	public void setForm(Form form) {
		this.form = form;
	}
	@Override
	public String toString() {
		String ret = "";
		ret += encounterId == null ? "(no ID) " : encounterId.toString() + " ";
		ret += this.getEncounterDatetime() == null ? "(no Date) " : this.getEncounterDatetime().toString() + " ";
		ret += this.getEncounterType() == null ? "(no Type) " : this.getEncounterType().getName() + " ";
		ret += this.getLocation() == null ? "(no Location) " : this.getLocation().getName() + " ";
		ret += this.getPatient() == null ? "(no Patient) " : this.getPatient().getPatientId().toString() + " ";
		ret += this.getForm() == null ? "(no Form) " : this.getForm().getName() + " ";
		ret += "num Obs: " + this.getObsAtTopLevel(false) + " ";
		ret += "num Orders: " + this.getOrders().size() + " ";
		return "Encounter: [" + ret + "]";
	}
	@Override
	public Integer getId() {
		return getEncounterId();
	}
	@Override
	public void setId(Integer id) {
		setEncounterId(id);
	}
	public Visit getVisit() {
		return visit;
	}
	public void setVisit(Visit visit) {
		this.visit = visit;
	}
	public Map<EncounterRole, Set<Provider>> getProvidersByRoles() {
		return getProvidersByRoles(false);
	}
	public Map<EncounterRole, Set<Provider>> getProvidersByRoles(boolean includeVoided) {
		return encounterProviders
		        .stream()
		        .filter(ep -> includeVoided || !ep.getVoided())
		        .collect(
		            Collectors.groupingBy(EncounterProvider::getEncounterRole,
		                Collectors.mapping(EncounterProvider::getProvider, Collectors.toSet())));
	}
	public Set<Provider> getProvidersByRole(EncounterRole role) {
		return getProvidersByRole(role, false);
	}
	public Set<Provider> getProvidersByRole(EncounterRole role, boolean includeVoided) {
		return encounterProviders.stream()
		        .filter(ep -> ep.getEncounterRole().equals(role) && (includeVoided || !ep.getVoided()))
		        .map(EncounterProvider::getProvider).collect(Collectors.toSet());
	}
	public void addProvider(EncounterRole role, Provider provider) {
		for (EncounterProvider ep : encounterProviders) {
			if (ep.getEncounterRole().equals(role) && ep.getProvider().equals(provider) && !ep.getVoided()) {
				return;
			}
		}
		EncounterProvider encounterProvider = new EncounterProvider();
		encounterProvider.setEncounter(this);
		encounterProvider.setEncounterRole(role);
		encounterProvider.setProvider(provider);
		encounterProvider.setDateCreated(new Date());
		encounterProvider.setCreator(Context.getAuthenticatedUser());
		encounterProviders.add(encounterProvider);
	}
	public void setProvider(EncounterRole role, Provider provider) {
		boolean hasProvider = false;
		for (EncounterProvider encounterProvider : encounterProviders) {
			if (encounterProvider.getEncounterRole().equals(role)) {
				if (!encounterProvider.getProvider().equals(provider)) {
					encounterProvider.setVoided(true);
					encounterProvider.setDateVoided(new Date());
					encounterProvider.setVoidedBy(Context.getAuthenticatedUser());
				} else if (!encounterProvider.getVoided()) {
					hasProvider = true;
				}
			}
		}
		if (!hasProvider) {
			addProvider(role, provider);
		}
	}
	public void removeProvider(EncounterRole role, Provider provider) {
		for (EncounterProvider encounterProvider : encounterProviders) {
			if (encounterProvider.getEncounterRole().equals(role) && encounterProvider.getProvider().equals(provider)
			        && !encounterProvider.getVoided()) {
				encounterProvider.setVoided(true);
				encounterProvider.setDateVoided(new Date());
				encounterProvider.setVoidedBy(Context.getAuthenticatedUser());
				return;
			}
		}
	}
	public Encounter copyAndAssignToAnotherPatient(Patient patient) {
		Encounter target = new Encounter();
		target.setChangedBy(getChangedBy());
		target.setCreator(getCreator());
		target.setDateChanged(getDateChanged());
		target.setDateCreated(getDateCreated());
		target.setDateVoided(getDateVoided());
		target.setVoided(getVoided());
		target.setVoidedBy(getVoidedBy());
		target.setVoidReason(getVoidReason());
		target.setEncounterDatetime(getEncounterDatetime());
		target.setEncounterType(getEncounterType());
		target.setForm(getForm());
		target.setLocation(getLocation());
		target.setPatient(patient);
		for (EncounterProvider encounterProvider : getEncounterProviders()) {
			EncounterProvider encounterProviderCopy = encounterProvider.copy();
			encounterProviderCopy.setEncounter(target);
			target.getEncounterProviders().add(encounterProviderCopy);
		}
		Context.getEncounterService().saveEncounter(target);
		for (Obs obs : getAllObs()) {
			Obs obsCopy = Obs.newInstance(obs);
			obsCopy.setEncounter(target);
			obsCopy.setPerson(patient);
			target.addObs(obsCopy);
		}
		return target;
	}
	public List<OrderGroup> getOrderGroups() {
		Map<String, OrderGroup> orderGroups = new HashMap<>();
		for (Order order : orders) {
			if (order.getOrderGroup() != null) {
				orderGroups.computeIfAbsent(order.getOrderGroup().getUuid(), k -> order.getOrderGroup());
				order.getOrderGroup().addOrder(order, null);
			}
		}
		return new ArrayList<>(orderGroups.values());
	}
	public List<Order> getOrdersWithoutOrderGroups() {
		return orders.stream().filter(o -> o.getOrderGroup() == null).collect(Collectors.toList());
	}
	public Boolean hasDiagnosis(Diagnosis diagnosis) {
		for (Diagnosis diagnosis1 : getDiagnoses()) {
			if (diagnosis.equals(diagnosis1)) {
				return true;
			}
		}
		return false;
	}
	public Set<Allergy> getAllergies() {
		return getAllergies(false);
	}
	public Set<Allergy> getAllergies(boolean includeVoided) {
		return Optional.ofNullable(allergies).orElse(new LinkedHashSet<>())
			.stream().filter(c -> includeVoided || !c.getVoided()).collect(Collectors.toSet());
	}
	public void setAllergies(Set<Allergy> allergies) {
		this.allergies = allergies;
	}
	public void addAllergy(Allergy allergy) {
		if (allergies == null) {
			allergies = new LinkedHashSet<>();
		}
		if (allergy != null) {
			allergy.setEncounter(this);
			allergies.add(allergy);
		}
	}
	public void removeAllergy(Allergy allergy) {
		Optional.ofNullable(allergies).orElse(new LinkedHashSet<>()).stream().filter(c -> !c.getVoided() && c.equals(allergy)).forEach(c -> {
			c.setVoided(true);
			c.setDateVoided(new Date());
			c.setVoidReason("Voided by the API");
			c.setVoidedBy(Context.getAuthenticatedUser());
		});
	}
}
package org.openmrs.api.handler;
import java.util.Date;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Cohort;
import org.openmrs.Encounter;
import org.openmrs.Obs;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.User;
import org.openmrs.Voidable;
import org.openmrs.annotation.Handler;
import org.openmrs.aop.RequiredDataAdvice;
@Handler(supports = { Patient.class, Encounter.class, Obs.class, Cohort.class, Order.class }, order = 1 )
public class RequireVoidReasonVoidHandler implements VoidHandler<Voidable> {
	@Override
	public void handle(Voidable voidableObject, User voidingUser, Date voidedDate, String voidReason) {
		if (StringUtils.isBlank(voidReason)) {
			throw new IllegalArgumentException("The 'reason' argument is required");
		}
	}
}
package org.openmrs.api.db;
import java.util.Date;
import java.util.List;
import org.openmrs.Concept;
import org.openmrs.ConceptName;
import org.openmrs.Encounter;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.ObsReferenceRange;
import org.openmrs.Person;
import org.openmrs.Visit;
import org.openmrs.api.ObsService;
import org.openmrs.util.OpenmrsConstants.PERSON_TYPE;
public interface ObsDAO {
	public Obs saveObs(Obs obs) throws DAOException;
	public Obs getObs(Integer obsId) throws DAOException;
	public void deleteObs(Obs obs) throws DAOException;
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<String> sort,
	        Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs,
	        String accessionNumber) throws DAOException;
	public Long getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, Integer obsGroupId,
	        Date fromDate, Date toDate, List<ConceptName> valueCodedNameAnswers, boolean includeVoidedObs,
	        String accessionNumber) throws DAOException;
	public Obs getObsByUuid(String uuid);
	public Obs getRevisionObs(Obs initialObs);
	public Obs.Status getSavedStatus(Obs obs);
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
			List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<String> sortList,
			List<Visit> visits, Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate,
			boolean includeVoidedObs, String accessionNumber) throws DAOException;
	public Long getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
			List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, Integer obsGroupId,
			Date fromDate, Date toDate, List<ConceptName> valueCodedNameAnswers, List<Visit> visits,
			boolean includeVoidedObs, String accessionNumber) throws DAOException;
}
package org.openmrs;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.Locale;
import org.apache.commons.lang3.StringUtils;
import org.apache.lucene.analysis.core.LowerCaseFilterFactory;
import org.apache.lucene.analysis.miscellaneous.ASCIIFoldingFilterFactory;
import org.apache.lucene.analysis.standard.StandardFilterFactory;
import org.apache.lucene.analysis.standard.StandardTokenizerFactory;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.Analyze;
import org.hibernate.search.annotations.Analyzer;
import org.hibernate.search.annotations.AnalyzerDef;
import org.hibernate.search.annotations.DocumentId;
import org.hibernate.search.annotations.Field;
import org.hibernate.search.annotations.FieldBridge;
import org.hibernate.search.annotations.Indexed;
import org.hibernate.search.annotations.IndexedEmbedded;
import org.hibernate.search.annotations.TokenFilterDef;
import org.hibernate.search.annotations.TokenizerDef;
import org.openmrs.api.ConceptNameType;
import org.openmrs.api.db.hibernate.search.bridge.LocaleFieldBridge;
@Indexed
@AnalyzerDef(
	name = "ConceptNameAnalyzer", tokenizer = @TokenizerDef(factory = StandardTokenizerFactory.class), filters = {
        @TokenFilterDef(factory = StandardFilterFactory.class), 
		@TokenFilterDef(factory = LowerCaseFilterFactory.class), 
		@TokenFilterDef(factory = ASCIIFoldingFilterFactory.class)
	})
@Analyzer(definition = "ConceptNameAnalyzer")
@Audited
public class ConceptName extends BaseOpenmrsObject implements Auditable, Voidable, java.io.Serializable {
	public static final long serialVersionUID = 2L;
	@DocumentId
	private Integer conceptNameId;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private Concept concept;
	@Field
	private String name;
	@Field(analyze = Analyze.NO)
	@FieldBridge(impl = LocaleFieldBridge.class)
	private Locale locale; 
	private User creator;
	private Date dateCreated;
	@Field
	private Boolean voided = false;
	private User voidedBy;
	private Date dateVoided;
	private String voidReason;
	private Collection<ConceptNameTag> tags;
	@Field
	private ConceptNameType conceptNameType;
	@Field
	private Boolean localePreferred = false;
	private User changedBy;
	private Date dateChanged;
	public ConceptName() {
	}
	public ConceptName(Integer conceptNameId) {
		this.conceptNameId = conceptNameId;
	}
	public ConceptName(String name, Locale locale) {
		setName(name);
		setLocale(locale);
	}
	public Integer getConceptNameId() {
		return conceptNameId;
	}
	public void setConceptNameId(Integer conceptNameId) {
		this.conceptNameId = conceptNameId;
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		this.concept = concept;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		if (name != null && StringUtils.isBlank(name) && StringUtils.isNotBlank(this.name)
		        && this.getConceptNameType().equals(ConceptNameType.SHORT)) {
			this.setVoided(true);
		} else {
			this.name = name;
		}
	}
	public Locale getLocale() {
		return locale;
	}
	public void setLocale(Locale locale) {
		this.locale = locale;
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	@Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	@Override
	@Deprecated
	@JsonIgnore
	public Boolean isVoided() {
		return getVoided();
	}
	@Override
	public Boolean getVoided() {
		return voided;
	}
	@Override
	public void setVoided(Boolean voided) {
		this.voided = voided;
	}
	@Override
	public User getVoidedBy() {
		return voidedBy;
	}
	@Override
	public void setVoidedBy(User voidedBy) {
		this.voidedBy = voidedBy;
	}
	@Override
	public Date getDateVoided() {
		return dateVoided;
	}
	@Override
	public void setDateVoided(Date dateVoided) {
		this.dateVoided = dateVoided;
	}
	@Override
	public String getVoidReason() {
		return voidReason;
	}
	@Override
	public void setVoidReason(String voidReason) {
		this.voidReason = voidReason;
	}
	public Collection<ConceptNameTag> getTags() {
		return tags;
	}
	public void setTags(Collection<ConceptNameTag> tags) {
		this.tags = tags;
	}
	public ConceptNameType getConceptNameType() {
		return this.conceptNameType;
	}
	public void setConceptNameType(ConceptNameType conceptNameType) {
		this.conceptNameType = conceptNameType;
	}
	@Deprecated
	@JsonIgnore
	public Boolean isLocalePreferred() {
		return getLocalePreferred();
	}
	public Boolean getLocalePreferred() {
		return localePreferred;
	}
	public void setLocalePreferred(Boolean localePreferred) {
		this.localePreferred = localePreferred;
	}
	public void addTag(String tag) {
		addTag(tag, "");
	}
	public void addTag(String tag, String description) {
		ConceptNameTag nameTag = new ConceptNameTag(tag, description);
		addTag(nameTag);
	}
	public void addTag(ConceptNameTag tag) {
		if (tags == null) {
			tags = new HashSet<>();
		}
		if (!tags.contains(tag)) {
			tags.add(tag);
		}
	}
	public void removeTag(ConceptNameTag tag) {
		if (tags.contains(tag)) {
			tags.remove(tag);
		}
	}
	public Boolean hasTag(ConceptNameTag tagToFind) {
		return hasTag(tagToFind.getTag());
	}
	public Boolean hasTag(String tagToFind) {
		boolean foundTag = false;
		if (tags != null) {
			for (ConceptNameTag nameTag : getTags()) {
				if (nameTag.getTag().equals(tagToFind)) {
					foundTag = true;
					break;
				}
			}
		}
		return foundTag;
	}
	public Boolean isPreferredInLanguage(String language) {
		return !StringUtils.isBlank(language) && this.locale != null && isPreferred()
				&& this.locale.getLanguage().equals(language);
	}
	public Boolean isPreferredInCountry(String country) {
		return !StringUtils.isBlank(country) && this.locale != null && isPreferred()
				&& this.locale.getCountry().equals(country);
	}
	public Boolean isPreferred() {
		return getLocalePreferred();
	}
	public Boolean isPreferredForLocale(Locale locale) {
		return getLocalePreferred() && this.locale.equals(locale);
	}
	public Boolean isFullySpecifiedName() {
		return ConceptNameType.FULLY_SPECIFIED.equals(getConceptNameType());
	}
	public Boolean isShort() {
		return ConceptNameType.SHORT.equals(getConceptNameType());
	}
	public Boolean isIndexTerm() {
		return ConceptNameType.INDEX_TERM.equals(getConceptNameType());
	}
	public Boolean isIndexTermInLocale(Locale locale) {
		return getConceptNameType() != null && getConceptNameType().equals(ConceptNameType.INDEX_TERM)
		        && locale.equals(getLocale());
	}
	public Boolean isSynonymInLocale(Locale locale) {
		return getConceptNameType() == null && locale.equals(getLocale());
	}
	public Boolean isSynonym() {
		return getConceptNameType() == null;
	}
	@Override
	public String toString() {
		if (this.name == null) {
			return "ConceptNameId: " + this.conceptNameId;
		}
		return this.name;
	}
	@Override
	public Integer getId() {
		return getConceptNameId();
	}
	@Override
	public void setId(Integer id) {
		setConceptNameId(id);
	}
	@Override
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	@Override
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
}
package org.openmrs.api.db.hibernate;
import org.openmrs.Obs;
import org.springframework.stereotype.Component;
@Component("immutableObsInterceptor")
public class ImmutableObsInterceptor extends ImmutableEntityInterceptor {
	private static final String[] MUTABLE_PROPERTY_NAMES = new String[] { "voided", "dateVoided", "voidedBy", "voidReason", "groupMembers" };
	@Override
	protected Class<?> getSupportedType() {
		return Obs.class;
	}
	@Override
	protected String[] getMutablePropertyNames() {
		return MUTABLE_PROPERTY_NAMES;
	}
	@Override
	protected boolean ignoreVoidedOrRetiredObjects() {
		return true;
	}
}
package org.openmrs.api.db.hibernate;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Join;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Subquery;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.Hibernate;
import org.hibernate.ScrollMode;
import org.hibernate.ScrollableResults;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.dialect.Dialect;
import org.hibernate.dialect.HSQLDialect;
import org.hibernate.dialect.PostgreSQL82Dialect;
import org.hibernate.engine.spi.SessionFactoryImplementor;
import org.hibernate.proxy.HibernateProxy;
import org.openmrs.Location;
import org.openmrs.LocationAttribute;
import org.openmrs.api.db.DAOException;
import org.openmrs.attribute.AttributeType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class HibernateUtil {
	private HibernateUtil() {
	}
	private static final Logger log = LoggerFactory.getLogger(HibernateUtil.class);
	private static Dialect dialect = null;
	private static Boolean isHSQLDialect = null;
	private static Boolean isPostgreSQLDialect = null;
	public static boolean isHSQLDialect(SessionFactory sessionFactory) {
		if (isHSQLDialect == null) {
			isHSQLDialect = HSQLDialect.class.getName().equals(getDialect(sessionFactory).getClass().getName());
		}
		return isHSQLDialect;
	}
	public static boolean isPostgreSQLDialect(SessionFactory sessionFactory) {
		if (isPostgreSQLDialect == null) {
			isPostgreSQLDialect = PostgreSQL82Dialect.class.getName()
			        .equals(getDialect(sessionFactory).getClass().getName());
		}
		return isPostgreSQLDialect;
	}
	public static Dialect getDialect(SessionFactory sessionFactory) {
		if (dialect != null) {
			return dialect;
		}
		SessionFactoryImplementor implementor = (SessionFactoryImplementor) sessionFactory;
		dialect = implementor.getDialect();
		log.debug("Getting dialect for session: {}", dialect);
		return dialect;
	}
	public static String escapeSqlWildcards(final String oldString, SessionFactory sessionFactory) {
		return sessionFactory.getCurrentSession().doReturningWork(connection -> escapeSqlWildcards(oldString, connection));
	}
	public static String escapeSqlWildcards(String oldString, Connection connection) {
		if (!StringUtils.isBlank(oldString)) {
			String escapeCharacter = "";
			try {
				escapeCharacter = connection.getMetaData().getSearchStringEscape();
			}
			catch (SQLException e) {
				log.warn("Error generated", e);
			}
			return StringUtils.replaceEach(oldString, new String[] { "%", "_", "*", "'" }, new String[] {
			        escapeCharacter + "%", escapeCharacter + "_", escapeCharacter + "*", "''" });
		} else {
			return oldString;
		}
	}
	public static <AT extends AttributeType> List<Predicate> getAttributePredicate(CriteriaBuilder cb,
	        Root<Location> locationRoot, Map<AT, String> serializedAttributeValues) {
		List<Predicate> predicates = new ArrayList<>();
		for (Map.Entry<AT, String> entry : serializedAttributeValues.entrySet()) {
			Subquery<Integer> subquery = cb.createQuery().subquery(Integer.class);
			Root<Location> locationSubRoot = subquery.from(Location.class);
			Join<Location, LocationAttribute> attributeJoin = locationSubRoot.join("attributes");
			Predicate[] attributePredicates = new Predicate[] { cb.equal(attributeJoin.get("attributeType"), entry.getKey()),
			        cb.equal(attributeJoin.get("valueReference"), entry.getValue()),
			        cb.isFalse(attributeJoin.get("voided")) };
			subquery.select(locationSubRoot.get("locationId")).where(attributePredicates);
			predicates.add(cb.in(locationRoot.get("locationId")).value(subquery));
		}
		return predicates;
	}
	public static <T> T getRealObjectFromProxy(T persistentObject) {
		if (persistentObject == null) {
			return null;
		}
		if (persistentObject instanceof HibernateProxy) {
			Hibernate.initialize(persistentObject);
			persistentObject = (T) ((HibernateProxy) persistentObject).getHibernateLazyInitializer().getImplementation();
		}
		return persistentObject;
	}
	public static <T> T getUniqueEntityByUUID(SessionFactory sessionFactory, Class<T> entityClass, String uuid) throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<T> query = cb.createQuery(entityClass);
		Root<T> root = query.from(entityClass);
		query.where(cb.equal(root.get("uuid"), uuid));
		return session.createQuery(query).uniqueResult();
	}
	public static <T> ScrollableResults getScrollableResult(SessionFactory sessionFactory, Class<T> type, int fetchSize) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder criteriaBuilder = session.getCriteriaBuilder();
		CriteriaQuery<T> criteriaQuery = criteriaBuilder.createQuery(type);
		Root<T> root = criteriaQuery.from(type);
		criteriaQuery.select(root);
		return session.createQuery(criteriaQuery)
			.setFetchSize(fetchSize)
			.scroll(ScrollMode.FORWARD_ONLY);
	}
}
package org.openmrs.validator;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import org.openmrs.Concept;
import org.openmrs.ConceptDatatype;
import org.openmrs.ConceptNumeric;
import org.openmrs.ConceptReferenceRange;
import org.openmrs.Obs;
import org.openmrs.ObsReferenceRange;
import org.openmrs.annotation.Handler;
import org.openmrs.api.APIException;
import org.openmrs.api.context.Context;
import org.openmrs.util.ConceptReferenceRangeUtility;
import org.springframework.validation.Errors;
import org.springframework.validation.Validator;
@Handler(supports = { Obs.class }, order = 50)
public class ObsValidator implements Validator {
	public static final int VALUE_TEXT_MAX_LENGTH = 65535;
	@Override
	public boolean supports(Class<?> c) {
		return Obs.class.isAssignableFrom(c);
	}
	@Override
	public void validate(Object obj, Errors errors) {
		Obs obs = (Obs) obj;
		if (obs == null) {
			throw new APIException("Obs can't be null");
		} else if (obs.getVoided()) {
			return;
		}
		List<Obs> ancestors = new ArrayList<>();
		validateConceptReferenceRange(obs, errors);
		validateHelper(obs, errors, ancestors, true);
		ValidateUtil.validateFieldLengths(errors, obj.getClass(), "accessionNumber", "valueModifier", "valueComplex",
		    "comment", "voidReason");
	}
	private void validateHelper(Obs obs, Errors errors, List<Obs> ancestors, boolean atRootNode) {
		if (obs.getPersonId() == null) {
			errors.rejectValue("person", "error.null");
		}
		if (obs.getObsDatetime() == null) {
			errors.rejectValue("obsDatetime", "error.null");
		}
		boolean isObsGroup = obs.hasGroupMembers(true);
		if (isObsGroup) {
			if (obs.getValueCoded() != null) {
				errors.rejectValue("valueCoded", "error.not.null");
			}
			if (obs.getValueDrug() != null) {
				errors.rejectValue("valueDrug", "error.not.null");
			}
			if (obs.getValueDatetime() != null) {
				errors.rejectValue("valueDatetime", "error.not.null");
			}
			if (obs.getValueNumeric() != null) {
				errors.rejectValue("valueNumeric", "error.not.null");
			}
			if (obs.getValueModifier() != null) {
				errors.rejectValue("valueModifier", "error.not.null");
			}
			if (obs.getValueText() != null) {
				errors.rejectValue("valueText", "error.not.null");
			}
			if (obs.getValueBoolean() != null) {
				errors.rejectValue("valueBoolean", "error.not.null");
			}
			if (obs.getValueComplex() != null) {
				errors.rejectValue("valueComplex", "error.not.null");
			}
		}
		else if (obs.getValueBoolean() == null && obs.getValueCoded() == null && obs.getValueCodedName() == null
		        && obs.getValueComplex() == null && obs.getValueDatetime() == null && obs.getValueDrug() == null
		        && obs.getValueModifier() == null && obs.getValueNumeric() == null && obs.getValueText() == null
		        && obs.getComplexData() == null) {
			errors.reject("error.noValue");
		}
		Concept c = obs.getConcept();
		if (c == null) {
			errors.rejectValue("concept", "error.null");
		}
		else if (!isObsGroup) {
			ConceptDatatype dt = c.getDatatype();
			if (dt != null) {
				if (dt.isBoolean() && obs.getValueBoolean() == null) {
					if (atRootNode) {
						errors.rejectValue("valueBoolean", "error.null");
					} else {
						errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
					}
				} else if (dt.isCoded() && obs.getValueCoded() == null) {
					if (atRootNode) {
						errors.rejectValue("valueCoded", "error.null");
					} else {
						errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
					}
				} else if ((dt.isDateTime() || dt.isDate() || dt.isTime()) && obs.getValueDatetime() == null) {
					if (atRootNode) {
						errors.rejectValue("valueDatetime", "error.null");
					} else {
						errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
					}
				} else if (dt.isNumeric() && obs.getValueNumeric() == null) {
					if (atRootNode) {
						errors.rejectValue("valueNumeric", "error.null");
					} else {
						errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
					}
				} else if (dt.isNumeric()) {
					ConceptNumeric cn = Context.getConceptService().getConceptNumeric(c.getConceptId());
					if (!cn.getAllowDecimal() && Math.ceil(obs.getValueNumeric()) != obs.getValueNumeric()) {
						if (atRootNode) {
							errors.rejectValue("valueNumeric", "Obs.error.precision");
						} else {
							errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
						}
					}
					if (cn.getHiAbsolute() != null && cn.getHiAbsolute() < obs.getValueNumeric()) {
						if (atRootNode) {
							errors.rejectValue("valueNumeric", "error.outOfRange.high");
						} else {
							errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
						}
					}
					if (cn.getLowAbsolute() != null && cn.getLowAbsolute() > obs.getValueNumeric()) {
						if (atRootNode) {
							errors.rejectValue("valueNumeric", "error.outOfRange.low");
						} else {
							errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
						}
					}
				} else if (dt.isText() && obs.getValueText() == null) {
					if (atRootNode) {
						errors.rejectValue("valueText", "error.null");
					} else {
						errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
					}
				}
				if (dt.isText() && obs.getValueText() != null && obs.getValueText().length() > VALUE_TEXT_MAX_LENGTH) {
					if (atRootNode) {
						errors.rejectValue("valueText", "error.exceededMaxLengthOfField");
					} else {
						errors.rejectValue("groupMembers", "Obs.error.inGroupMember");
					}
				}
			} else { 
				errors.rejectValue("concept", "must have a datatype");
			}
		}
		if (errors.hasErrors()) {
			return;
		}
		if (ancestors.contains(obs)) {
			errors.rejectValue("groupMembers", "Obs.error.groupContainsItself");
		}
		if (obs.isObsGrouping()) {
			ancestors.add(obs);
			for (Obs child : obs.getGroupMembers()) {
				validateHelper(child, errors, ancestors, false);
			}
			ancestors.remove(ancestors.size() - 1);
		}
		if (obs.getValueCoded() != null && obs.getValueDrug() != null && obs.getValueDrug().getConcept() != null) {
			Concept trueConcept = Context.getConceptService().getTrueConcept();
			Concept falseConcept = Context.getConceptService().getFalseConcept();
			if (!obs.getValueCoded().equals(trueConcept) && !obs.getValueCoded().equals(falseConcept)
			        && !obs.getValueDrug().getConcept().equals(obs.getValueCoded())) {
				errors.rejectValue("valueDrug", "Obs.error.invalidDrug");
			}
		}
	}
	private void validateConceptReferenceRange(Obs obs, Errors errors) {
		ConceptReferenceRange conceptReferenceRange = getReferenceRange(obs.getConcept(), obs);
		if (conceptReferenceRange != null) {
			validateAbsoluteRanges(obs, conceptReferenceRange, errors);
			if (obs.getId() == null) {
				setObsReferenceRange(obs, conceptReferenceRange);
			}
		} else if (obs.getId() == null) {
			setObsReferenceRange(obs);
		}
		setObsInterpretation(obs);
	}
	public ConceptReferenceRange getReferenceRange(Concept concept, Obs obs) {
		if (concept == null || concept.getDatatype() == null || !concept.getDatatype().isNumeric()) {
			return null;
		}
		List<ConceptReferenceRange> referenceRanges = Context.getConceptService()
			.getConceptReferenceRangesByConceptId(concept.getConceptId());
		if (referenceRanges.isEmpty()) {
			return null;
		}
		ConceptReferenceRangeUtility referenceRangeUtility = new ConceptReferenceRangeUtility();
		List<ConceptReferenceRange> validRanges = new ArrayList<>();
		for (ConceptReferenceRange referenceRange : referenceRanges) {
			if (referenceRangeUtility.evaluateCriteria(referenceRange.getCriteria(), obs)) {
				validRanges.add(referenceRange);
			}
		}
		if (validRanges.isEmpty()) {
			return null;
		}
		return findStrictestReferenceRange(validRanges);
	}
	private ConceptReferenceRange findStrictestReferenceRange(List<ConceptReferenceRange> conceptReferenceRanges) {
		ConceptReferenceRange strictestLowRange = conceptReferenceRanges.stream()
			.filter(range -> range.getLowAbsolute() != null)
			.max(Comparator.comparing(ConceptReferenceRange::getLowAbsolute))
			.orElse(null);
		ConceptReferenceRange strictestHiRange = conceptReferenceRanges.stream()
			.filter(range -> range.getHiAbsolute() != null)
			.min(Comparator.comparing(ConceptReferenceRange::getHiAbsolute))
			.orElse(null);
		ConceptReferenceRange strictestRange = new ConceptReferenceRange();
		if (strictestLowRange != null) {
			strictestRange.setLowAbsolute(strictestLowRange.getLowAbsolute());
			strictestRange.setLowNormal(strictestLowRange.getLowNormal());
			strictestRange.setLowCritical(strictestLowRange.getLowCritical());
		}
		if (strictestHiRange != null) {
			strictestRange.setHiAbsolute(strictestHiRange.getHiAbsolute());
			strictestRange.setHiNormal(strictestHiRange.getHiNormal());
			strictestRange.setHiCritical(strictestHiRange.getHiCritical());
		}
		return strictestRange;
	}
	private void validateAbsoluteRanges(Obs obs, ConceptReferenceRange conceptReferenceRange, Errors errors) {
		if (conceptReferenceRange.getHiAbsolute() != null && conceptReferenceRange.getHiAbsolute() < obs.getValueNumeric()) {
			errors.rejectValue(
				"valueNumeric", 
				"error.value.outOfRange.high", 
				new Object[] { conceptReferenceRange.getLowAbsolute() },
				null
			);
		}
		if (conceptReferenceRange.getLowAbsolute() != null && conceptReferenceRange.getLowAbsolute() > obs.getValueNumeric()) {
			errors.rejectValue(
				"valueNumeric", 
				"error.value.outOfRange.low", 
				new Object[] { conceptReferenceRange.getLowAbsolute() },
				null
			);
		}
	}
	private void setObsReferenceRange(Obs obs, ConceptReferenceRange conceptReferenceRange) {
		ObsReferenceRange obsRefRange = new ObsReferenceRange();
		obsRefRange.setHiAbsolute(conceptReferenceRange.getHiAbsolute());
		obsRefRange.setHiCritical(conceptReferenceRange.getHiCritical());
		obsRefRange.setHiNormal(conceptReferenceRange.getHiNormal());
		obsRefRange.setLowAbsolute(conceptReferenceRange.getLowAbsolute());
		obsRefRange.setLowCritical(conceptReferenceRange.getLowCritical());
		obsRefRange.setLowNormal(conceptReferenceRange.getLowNormal());
		obsRefRange.setObs(obs);
		obs.setReferenceRange(obsRefRange);
	}
	private void setObsReferenceRange(Obs obs) {
		if (obs.getConcept() == null) {
			return;
		}
		ConceptNumeric conceptNumeric = Context.getConceptService().getConceptNumeric(obs.getConcept().getId());
		if (conceptNumeric != null) {
			ObsReferenceRange obsRefRange = new ObsReferenceRange();
			obsRefRange.setHiAbsolute(conceptNumeric.getHiAbsolute());
			obsRefRange.setHiCritical(conceptNumeric.getHiCritical());
			obsRefRange.setHiNormal(conceptNumeric.getHiNormal());
			obsRefRange.setLowAbsolute(conceptNumeric.getLowAbsolute());
			obsRefRange.setLowCritical(conceptNumeric.getLowCritical());
			obsRefRange.setLowNormal(conceptNumeric.getLowNormal());
			obsRefRange.setObs(obs);
			obs.setReferenceRange(obsRefRange);
		}
	}
	private void setObsInterpretation(Obs obs) {
		ObsReferenceRange referenceRange = obs.getReferenceRange();
		if (referenceRange == null || obs.getValueNumeric() == null) {
			return;
		}
		if (referenceRange.getHiNormal() != null 
			&& referenceRange.getHiCritical() != null
			&& obs.getValueNumeric() > referenceRange.getHiNormal()
			&& obs.getValueNumeric() < referenceRange.getHiCritical()) {
			obs.setInterpretation(Obs.Interpretation.HIGH);
		} else if (referenceRange.getHiCritical() != null 
			&& obs.getValueNumeric() >= referenceRange.getHiCritical()) {
			obs.setInterpretation(Obs.Interpretation.CRITICALLY_HIGH);
		} else if (referenceRange.getLowNormal() != null 
			&& referenceRange.getLowCritical() != null
			&& obs.getValueNumeric() < referenceRange.getLowNormal() 
			&& obs.getValueNumeric() > referenceRange.getLowCritical()) {
			obs.setInterpretation(Obs.Interpretation.LOW);
		} else if (referenceRange.getLowNormal() != null 
			&& referenceRange.getHiNormal() != null
			&& obs.getValueNumeric() >= referenceRange.getLowNormal() 
			&& obs.getValueNumeric() <= referenceRange.getHiNormal()) {
			obs.setInterpretation(Obs.Interpretation.NORMAL);
		} else if (referenceRange.getLowCritical() != null 
			&& obs.getValueNumeric() <= referenceRange.getLowCritical()) {
			obs.setInterpretation(Obs.Interpretation.CRITICALLY_LOW);
		}
	}
}
package org.openmrs;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;
import org.apache.commons.lang3.StringUtils;
import org.codehaus.jackson.annotate.JsonIgnore;
import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.hibernate.search.annotations.DocumentId;
import org.hibernate.search.annotations.Indexed;
import org.hibernate.search.annotations.IndexedEmbedded;
import org.openmrs.api.context.Context;
@Indexed
@Audited
public class Drug extends BaseChangeableOpenmrsMetadata {
	public static final long serialVersionUID = 285L;
	@DocumentId
	private Integer drugId;
	private Boolean combination = false;
	private Concept dosageForm;
	private Double maximumDailyDose;
	private Double minimumDailyDose;
	private String strength;
	private Concept doseLimitUnits;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private Concept concept;
	@IndexedEmbedded(includeEmbeddedObjectId = true)
	private Set<DrugReferenceMap> drugReferenceMaps;
	private Collection<DrugIngredient> ingredients;
	public Drug() {
		ingredients = new LinkedHashSet<>();
	}
	public Drug(Integer drugId) {
		this.drugId = drugId;
	}
	public Integer getDrugId() {
		return this.drugId;
	}
	public void setDrugId(Integer drugId) {
		this.drugId = drugId;
	}
	public String getFullName(Locale locale) {
		if (concept == null) {
			return getName();
		} else {
			return getName() + " (" + concept.getName(locale).getName() + ")";
		}
	}
	@Deprecated
	@JsonIgnore
	public Boolean isCombination() {
		return getCombination();
	}
	public Boolean getCombination() {
		return combination;
	}
	public void setCombination(Boolean combination) {
		this.combination = combination;
	}
	public String getStrength() {
		return strength;
	}
	public void setStrength(String strength) {
		this.strength = strength;
	}
	public Concept getConcept() {
		return this.concept;
	}
	public void setConcept(Concept concept) {
		this.concept = concept;
	}
	public Concept getDosageForm() {
		return dosageForm;
	}
	public void setDosageForm(Concept dosageForm) {
		this.dosageForm = dosageForm;
	}
	public Double getMaximumDailyDose() {
		return maximumDailyDose;
	}
	public void setMaximumDailyDose(Double maximumDailyDose) {
		this.maximumDailyDose = maximumDailyDose;
	}
	public Double getMinimumDailyDose() {
		return minimumDailyDose;
	}
	public void setMinimumDailyDose(Double minimumDailyDose) {
		this.minimumDailyDose = minimumDailyDose;
	}
	public Collection<DrugIngredient> getIngredients() {
		return ingredients;
	}
	public void setIngredients(Collection<DrugIngredient> ingredients) {
		this.ingredients = ingredients;
	}
	@Override
	public Integer getId() {
		return getDrugId();
	}
	@Override
	public void setId(Integer id) {
		setDrugId(id);
	}
	public String getDisplayName() {
		if (StringUtils.isNotBlank(getName())) {
			return getName();
		}
		if (getConcept() != null) {
			return getConcept().getName().getName();
		}
		return "";
	}
	public Set<DrugReferenceMap> getDrugReferenceMaps() {
		if (drugReferenceMaps == null) {
			drugReferenceMaps = new LinkedHashSet<>();
		}
		return drugReferenceMaps;
	}
	public void setDrugReferenceMaps(Set<DrugReferenceMap> drugReferenceMaps) {
		this.drugReferenceMaps = drugReferenceMaps;
	}
	public void addDrugReferenceMap(DrugReferenceMap drugReferenceMap) {
		if (drugReferenceMap != null && !getDrugReferenceMaps().contains(drugReferenceMap)) {
			drugReferenceMap.setDrug(this);
			if (drugReferenceMap.getConceptMapType() == null) {
				drugReferenceMap.setConceptMapType(Context.getConceptService().getDefaultConceptMapType());
			}
			getDrugReferenceMaps().add(drugReferenceMap);
		}
	}
	public Concept getDoseLimitUnits() {
		return doseLimitUnits;
	}
	public void setDoseLimitUnits(Concept doseLimitUnits) {
		this.doseLimitUnits = doseLimitUnits;
	}
}
package org.openmrs;
import org.hibernate.envers.Audited;
import org.hibernate.search.annotations.DocumentId;
@Audited
public class ConceptDatatype extends BaseChangeableOpenmrsMetadata {
	public static final long serialVersionUID = 473L;
	public static final String BOOLEAN = "BIT";
	public static final String CODED = "CWE";
	public static final String DATE = "DT";
	public static final String DATETIME = "TS";
	public static final String DOCUMENT = "RP";
	public static final String NUMERIC = "NM";
	public static final String TEXT = "ST";
	public static final String TIME = "TM";
	public static final String NUMERIC_UUID = "8d4a4488-c2cc-11de-8d13-0010c6dffd0f";
	public static final String CODED_UUID = "8d4a48b6-c2cc-11de-8d13-0010c6dffd0f";
	public static final String TEXT_UUID = "8d4a4ab4-c2cc-11de-8d13-0010c6dffd0f";
	public static final String N_A_UUID = "8d4a4c94-c2cc-11de-8d13-0010c6dffd0f";
	public static final String DOCUMENT_UUID = "8d4a4e74-c2cc-11de-8d13-0010c6dffd0f";
	public static final String DATE_UUID = "8d4a505e-c2cc-11de-8d13-0010c6dffd0f";
	public static final String TIME_UUID = "8d4a591e-c2cc-11de-8d13-0010c6dffd0f";
	public static final String DATETIME_UUID = "8d4a5af4-c2cc-11de-8d13-0010c6dffd0f";
	public static final String BOOLEAN_UUID = "8d4a5cca-c2cc-11de-8d13-0010c6dffd0f";
	public static final String RULE_UUID = "8d4a5e96-c2cc-11de-8d13-0010c6dffd0f";
	public static final String STRUCTURED_NUMERIC_UUID = "8d4a606c-c2cc-11de-8d13-0010c6dffd0f";
	public static final String COMPLEX_UUID = "8d4a6242-c2cc-11de-8d13-0010c6dffd0f";
	@DocumentId
	private Integer conceptDatatypeId;
	private String hl7Abbreviation;
	public ConceptDatatype() {
	}
	public ConceptDatatype(Integer conceptDatatypeId) {
		this.conceptDatatypeId = conceptDatatypeId;
	}
	public Integer getConceptDatatypeId() {
		return this.conceptDatatypeId;
	}
	public void setConceptDatatypeId(Integer conceptDatatypeId) {
		this.conceptDatatypeId = conceptDatatypeId;
	}
	public String getHl7Abbreviation() {
		return hl7Abbreviation;
	}
	public void setHl7Abbreviation(String hl7Abbreviation) {
		this.hl7Abbreviation = hl7Abbreviation;
	}
	public boolean isAnswerOnly() {
		return N_A_UUID.equals(getUuid());
	}
	public boolean isNumeric() {
		return NUMERIC_UUID.equals(getUuid());
	}
	public boolean isCoded() {
		return CODED_UUID.equals(getUuid());
	}
	public boolean isDate() {
		return DATE_UUID.equals(getUuid());
	}
	public boolean isTime() {
		return TIME_UUID.equals(getUuid());
	}
	public boolean isDateTime() {
		return DATETIME_UUID.equals(getUuid());
	}
	public boolean containsDate() {
		return DATE_UUID.equals(getUuid()) || DATETIME_UUID.equals(getUuid());
	}
	public boolean containsTime() {
		return TIME_UUID.equals(getUuid()) || DATETIME_UUID.equals(getUuid());
	}
	public boolean isText() {
		return TEXT_UUID.equals(getUuid()) || DOCUMENT_UUID.equals(getUuid());
	}
	public boolean isBoolean() {
		return BOOLEAN_UUID.equals(getUuid());
	}
	@Override
	public Integer getId() {
		return getConceptDatatypeId();
	}
	@Override
	public void setId(Integer id) {
		setConceptDatatypeId(id);
	}
	public boolean isComplex() {
		return COMPLEX_UUID.equals(getUuid());
	}
	public boolean isRule() {
		return RULE_UUID.equals(getUuid());
	}
}
package org.openmrs.api;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import org.openmrs.Concept;
import org.openmrs.ConceptAnswer;
import org.openmrs.ConceptAttribute;
import org.openmrs.ConceptAttributeType;
import org.openmrs.ConceptClass;
import org.openmrs.ConceptComplex;
import org.openmrs.ConceptDatatype;
import org.openmrs.ConceptDescription;
import org.openmrs.ConceptMap;
import org.openmrs.ConceptMapType;
import org.openmrs.ConceptName;
import org.openmrs.ConceptNameTag;
import org.openmrs.ConceptNumeric;
import org.openmrs.ConceptProposal;
import org.openmrs.ConceptReferenceRange;
import org.openmrs.ConceptReferenceTerm;
import org.openmrs.ConceptReferenceTermMap;
import org.openmrs.ConceptSearchResult;
import org.openmrs.ConceptSet;
import org.openmrs.ConceptSource;
import org.openmrs.ConceptStopWord;
import org.openmrs.Drug;
import org.openmrs.DrugIngredient;
import org.openmrs.annotation.Authorized;
import org.openmrs.api.db.ConceptDAO;
import org.openmrs.util.PrivilegeConstants;
public interface ConceptService extends OpenmrsService {
	public void setConceptDAO(ConceptDAO dao);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getConceptByUuid(String uuid);
	@Authorized({ PrivilegeConstants.MANAGE_CONCEPTS })
	public Concept saveConcept(Concept concept) throws APIException;
	@Authorized({ PrivilegeConstants.MANAGE_CONCEPTS })
	public Drug saveDrug(Drug drug) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_CONCEPTS)
	public void purgeConcept(Concept conceptOrConceptNumeric) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
	public Concept retireConcept(Concept conceptOrConceptNumeric, String reason) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
	public Drug retireDrug(Drug drug, String reason) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
	public Drug unretireDrug(Drug drug) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_CONCEPTS)
	public void purgeDrug(Drug drug) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getConcept(Integer conceptId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptName getConceptName(Integer conceptNameId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptAnswer getConceptAnswer(Integer conceptAnswerId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Drug getDrug(Integer drugId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptNumeric getConceptNumeric(Integer conceptId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptClass getConceptClass(Integer conceptClassId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getAllConcepts() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getAllConcepts(String sortBy, boolean asc, boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getConceptsByName(String name) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getConceptByName(String name) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getConcept(String conceptIdOrName) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getConceptByReference(String conceptRef);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Drug getDrugByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public DrugIngredient getDrugIngredientByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Drug getDrug(String drugNameOrId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Drug> getAllDrugs() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Drug> getDrugsByConcept(Concept concept) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Drug> getAllDrugs(boolean includeRetired);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Drug> getDrugs(String phrase) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getConceptsByClass(ConceptClass cc) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_CLASSES)
	public ConceptClass getConceptClassByName(String name) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_CLASSES)
	public List<ConceptClass> getAllConceptClasses() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_CLASSES)
	public List<ConceptClass> getAllConceptClasses(boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_CLASSES)
	public ConceptClass getConceptClassByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptAnswer getConceptAnswerByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptName getConceptNameByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptSet getConceptSetByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
	public ConceptSource getConceptSourceByUuid(String uuid);
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_CLASSES)
	public ConceptClass saveConceptClass(ConceptClass cc) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_CONCEPT_CLASSES)
	public void purgeConceptClass(ConceptClass cc) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_NAME_TAGS)
	public void purgeConceptNameTag(ConceptNameTag cnt) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
	public List<ConceptDatatype> getAllConceptDatatypes() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
	public List<ConceptDatatype> getAllConceptDatatypes(boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
	public ConceptDatatype getConceptDatatype(Integer i) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
	public ConceptDatatype getConceptDatatypeByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPT_DATATYPES)
	public ConceptDatatype getConceptDatatypeByName(String name) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptSet> getConceptSetsByConcept(Concept concept) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getConceptsByConceptSet(Concept concept) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptSet> getSetsContainingConcept(Concept concept) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
	public List<ConceptProposal> getAllConceptProposals(boolean includeCompleted) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptNumeric getConceptNumericByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
	public ConceptProposal getConceptProposal(Integer conceptProposalId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
	public List<ConceptProposal> getConceptProposals(String text) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
	public List<Concept> getProposedConcepts(String text) throws APIException;
	@Authorized({ PrivilegeConstants.ADD_CONCEPT_PROPOSALS, PrivilegeConstants.EDIT_CONCEPT_PROPOSALS })
	public ConceptProposal saveConceptProposal(ConceptProposal conceptProposal) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_CONCEPT_PROPOSALS)
	public void purgeConceptProposal(ConceptProposal cp) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
	public Concept mapConceptProposalToConcept(ConceptProposal cp, Concept mappedConcept) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
	public Concept mapConceptProposalToConcept(ConceptProposal cp, Concept mappedConcept, Locale locale) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getConceptsByAnswer(Concept concept) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getPrevConcept(Concept concept) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getNextConcept(Concept concept) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public void checkIfLocked() throws ConceptsLockedException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_PROPOSALS)
	public ConceptProposal getConceptProposalByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getConceptsWithDrugsInFormulary() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptNameTag getConceptNameTagByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptComplex getConceptComplex(Integer conceptId);
	@Authorized({ PrivilegeConstants.GET_CONCEPTS })
	public ConceptNameTag getConceptNameTagByName(String tag);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Set<Locale> getLocalesOfConceptNames();
	@Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
	public List<ConceptSource> getAllConceptSources(boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
	public ConceptSource getConceptSource(Integer i) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_SOURCES)
	public ConceptSource saveConceptSource(ConceptSource conceptSource) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_CONCEPT_SOURCES)
	public ConceptSource purgeConceptSource(ConceptSource cs) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_CONCEPT_SOURCES)
	public ConceptSource retireConceptSource(ConceptSource cs, String reason) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_NAME_TAGS)
	public ConceptNameTag saveConceptNameTag(ConceptNameTag nameTag);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Integer getMaxConceptId();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Iterator<Concept> conceptIterator();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getConceptByMapping(String code, String sourceName) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getConceptByMapping(String code, String sourceName, Boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getConceptsByMapping(String code, String sourceName) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getConceptsByMapping(String code, String sourceName, boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Integer> getConceptIdsByMapping(String code, String sourceName, boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptNameTag> getAllConceptNameTags();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public ConceptNameTag getConceptNameTag(Integer id);
	@Authorized({ PrivilegeConstants.GET_CONCEPTS })
	public ConceptDescription getConceptDescriptionByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
	public ConceptSource getConceptSourceByName(String conceptSourceName) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
	public ConceptSource getConceptSourceByUniqueId(String uniqueId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_SOURCES)
	public ConceptSource getConceptSourceByHL7Code(String hl7Code) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public boolean hasAnyObservation(Concept concept);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getTrueConcept();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getFalseConcept();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Concept getUnknownConcept();
	@Authorized({ PrivilegeConstants.MANAGE_CONCEPTS })
	public void convertBooleanConceptToCoded(Concept conceptToChange) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public boolean hasAnyObservation(ConceptName conceptName) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptSearchResult> getConcepts(String phrase, List<Locale> locales, boolean includeRetired,
	        List<ConceptClass> requireClasses, List<ConceptClass> excludeClasses, List<ConceptDatatype> requireDatatypes,
	        List<ConceptDatatype> excludeDatatypes, Concept answersToConcept, Integer start, Integer size)
	                throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptSearchResult> findConceptAnswers(String phrase, Locale locale, Concept concept) throws APIException;
	@Authorized({ PrivilegeConstants.MANAGE_CONCEPTS })
	public void updateConceptIndex(Concept concept) throws APIException;
	@Authorized({ PrivilegeConstants.MANAGE_CONCEPTS })
	public void updateConceptIndexes() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptSearchResult> getConcepts(String phrase, Locale locale, boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Integer getCountOfConcepts(String phrase, List<Locale> locales, boolean includeRetired,
	        List<ConceptClass> requireClasses, List<ConceptClass> excludeClasses, List<ConceptDatatype> requireDatatypes,
	        List<ConceptDatatype> excludeDatatypes, Concept answersToConcept);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Integer getCountOfDrugs(String drugName, Concept concept, boolean searchOnPhrase, boolean searchDrugConceptNames,
	        boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Drug> getDrugs(String drugName, Concept concept, boolean searchKeywords, boolean searchDrugConceptNames,
	        boolean includeRetired, Integer start, Integer length) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<String> getConceptStopWords(Locale locale);
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_STOP_WORDS)
	public ConceptStopWord saveConceptStopWord(ConceptStopWord conceptStopWord) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_STOP_WORDS)
	public void deleteConceptStopWord(Integer conceptStopWordId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptStopWord> getAllConceptStopWords();
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Drug> getDrugsByIngredient(Concept ingredient);
	@Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
	public List<ConceptMapType> getActiveConceptMapTypes() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
	public List<ConceptMapType> getConceptMapTypes(boolean includeRetired, boolean includeHidden) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
	public ConceptMapType getConceptMapType(Integer conceptMapTypeId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
	public ConceptMapType getConceptMapTypeByUuid(String uuid) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
	public ConceptMapType getConceptMapTypeByName(String name) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_MAP_TYPES)
	public ConceptMapType saveConceptMapType(ConceptMapType conceptMapType) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_MAP_TYPES)
	public ConceptMapType retireConceptMapType(ConceptMapType conceptMapType, String retireReason) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_MAP_TYPES)
	public ConceptMapType unretireConceptMapType(ConceptMapType conceptMapType) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_CONCEPT_MAP_TYPES)
	public void purgeConceptMapType(ConceptMapType conceptMapType) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptMap> getConceptMappingsToSource(ConceptSource conceptSource) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public List<ConceptReferenceTerm> getAllConceptReferenceTerms() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public List<ConceptReferenceTerm> getConceptReferenceTerms(boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public ConceptReferenceTerm getConceptReferenceTerm(Integer conceptReferenceTermId) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public ConceptReferenceTerm getConceptReferenceTermByUuid(String uuid) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public ConceptReferenceTerm getConceptReferenceTermByName(String name, ConceptSource conceptSource) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public ConceptReferenceTerm getConceptReferenceTermByCode(String code, ConceptSource conceptSource) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public List<ConceptReferenceTerm> getConceptReferenceTermByCode(String code, ConceptSource conceptSource, boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_REFERENCE_TERMS)
	public ConceptReferenceTerm saveConceptReferenceTerm(ConceptReferenceTerm conceptReferenceTerm) throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_REFERENCE_TERMS)
	public ConceptReferenceTerm retireConceptReferenceTerm(ConceptReferenceTerm conceptReferenceTerm, String retireReason)
	        throws APIException;
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_REFERENCE_TERMS)
	public ConceptReferenceTerm unretireConceptReferenceTerm(ConceptReferenceTerm conceptReferenceTerm) throws APIException;
	@Authorized(PrivilegeConstants.PURGE_CONCEPT_REFERENCE_TERMS)
	public void purgeConceptReferenceTerm(ConceptReferenceTerm conceptReferenceTerm) throws APIException;
	@Authorized({ PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS })
	public List<ConceptReferenceTerm> getConceptReferenceTerms(String query, ConceptSource conceptSource, Integer start,
	        Integer length, boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public Integer getCountOfConceptReferenceTerms(String query, ConceptSource conceptSource, boolean includeRetired)
	        throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_REFERENCE_TERMS)
	public List<ConceptReferenceTermMap> getReferenceTermMappingsTo(ConceptReferenceTerm term) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Concept> getConceptsByName(String name, Locale locale, Boolean exactLocale) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPT_MAP_TYPES)
	public ConceptMapType getDefaultConceptMapType() throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public boolean isConceptNameDuplicate(ConceptName name);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Drug> getDrugs(String searchPhrase, Locale locale, boolean exactLocale, boolean includeRetired);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<Drug> getDrugsByMapping(String code, ConceptSource conceptSource,
	        Collection<ConceptMapType> withAnyOfTheseTypes, boolean includeRetired) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public Drug getDrugByMapping(String code, ConceptSource conceptSource,
	        Collection<ConceptMapType> withAnyOfTheseTypesOrOrderOfPreference) throws APIException;
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	public List<ConceptSearchResult> getOrderableConcepts(String phrase, List<Locale> locales, boolean includeRetired,
	        Integer start, Integer length);
	@Authorized(PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES)
	public List<ConceptAttributeType> getAllConceptAttributeTypes();
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_ATTRIBUTE_TYPES)
	public ConceptAttributeType saveConceptAttributeType(ConceptAttributeType conceptAttributeType);
	@Authorized(PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES)
	public ConceptAttributeType getConceptAttributeType(Integer id);
	@Authorized(PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES)
	public ConceptAttributeType getConceptAttributeTypeByUuid(String uuid);
	@Authorized(PrivilegeConstants.PURGE_CONCEPT_ATTRIBUTE_TYPES)
	void purgeConceptAttributeType(ConceptAttributeType conceptAttributeType);
	@Authorized({ PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES })
	public List<ConceptAttributeType> getConceptAttributeTypes(String name) throws APIException;
	@Authorized({ PrivilegeConstants.GET_CONCEPT_ATTRIBUTE_TYPES })
	public ConceptAttributeType getConceptAttributeTypeByName(String exactName);
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_ATTRIBUTE_TYPES)
	public ConceptAttributeType retireConceptAttributeType(ConceptAttributeType conceptAttributeType, String reason);
	@Authorized(PrivilegeConstants.MANAGE_CONCEPT_ATTRIBUTE_TYPES)
	public ConceptAttributeType unretireConceptAttributeType(ConceptAttributeType conceptAttributeType);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	ConceptAttribute getConceptAttributeByUuid(String uuid);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	boolean hasAnyConceptAttribute(ConceptAttributeType conceptAttributeType);
	@Authorized(PrivilegeConstants.MANAGE_CONCEPTS)
	ConceptReferenceRange saveConceptReferenceRange(ConceptReferenceRange conceptReferenceRange);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	List<ConceptReferenceRange> getConceptReferenceRangesByConceptId(Integer conceptId);
	@Authorized(PrivilegeConstants.GET_CONCEPTS)
	ConceptReferenceRange getConceptReferenceRangeByUuid(String uuid);
}
package org.openmrs.api.handler;
import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.util.Date;
import java.util.UUID;
import org.apache.commons.beanutils.PropertyUtils;
import org.openmrs.Obs;
import org.openmrs.OpenmrsObject;
import org.openmrs.User;
import org.openmrs.Voidable;
import org.openmrs.annotation.AllowEmptyStrings;
import org.openmrs.annotation.AllowLeadingOrTrailingWhitespace;
import org.openmrs.annotation.Handler;
import org.openmrs.aop.RequiredDataAdvice;
import org.openmrs.api.APIException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
@Handler(supports = OpenmrsObject.class)
public class OpenmrsObjectSaveHandler implements SaveHandler<OpenmrsObject> {
	private static final Logger log = LoggerFactory.getLogger(OpenmrsObjectSaveHandler.class);
	@Override
	public void handle(OpenmrsObject openmrsObject, User creator, Date dateCreated, String reason) {
		if (openmrsObject.getUuid() == null) {
			openmrsObject.setUuid(UUID.randomUUID().toString());
		}
		PropertyDescriptor[] properties = PropertyUtils.getPropertyDescriptors(openmrsObject);
		for (PropertyDescriptor property : properties) {
			if (property.getPropertyType() == null) {
				continue;
			}
			if (property.getWriteMethod() == null || property.getReadMethod() == null) {
				continue;
			}
			if (property.getWriteMethod().getAnnotation(Deprecated.class) != null
			        || property.getReadMethod().getAnnotation(Deprecated.class) != null) {
				continue;
			}
			if (openmrsObject instanceof Obs ||!property.getPropertyType().equals(String.class)) {
				continue;
			}
			try {
				Object value = PropertyUtils.getProperty(openmrsObject, property.getName());
				if (value == null) {
					continue;
				}
				Object valueBeforeTrim = value;
				if (property.getWriteMethod().getAnnotation(AllowLeadingOrTrailingWhitespace.class) == null) {
					value = ((String) value).trim();
					if (!valueBeforeTrim.equals(value)) {
						PropertyUtils.setProperty(openmrsObject, property.getName(), value);
					}
				}
				if (property.getWriteMethod().getAnnotation(AllowEmptyStrings.class) != null) {
					continue;
				}
				if ("".equals(value) && !(openmrsObject instanceof Voidable && ((Voidable) openmrsObject).getVoided())) {
					PropertyUtils.setProperty(openmrsObject, property.getName(), null);
				}
			}
			catch (UnsupportedOperationException ex) {
				if (log.isInfoEnabled()) {
					log.info("The property " + property.getName() + " is no longer supported and should be ignored.", ex);
				}
			}
			catch (InvocationTargetException ex) {
				if (log.isWarnEnabled()) {
					log.warn("Failed to access property " + property.getName() + "; accessor threw exception.", ex);
				}
			}
			catch (Exception ex) {
				throw new APIException("failed.change.property.value", new Object[] { property.getName() }, ex);
			}
		}
	}
}
package org.openmrs.logic.result;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.openmrs.Concept;
import org.openmrs.ConceptDatatype;
import org.openmrs.Obs;
import org.openmrs.api.context.Context;
import org.openmrs.logic.LogicException;
public class Result extends ArrayList<Result> {
	private static final long serialVersionUID = -5587574403423820797L;
	public enum Datatype {
		BOOLEAN,
		CODED,
		DATETIME,
		NUMERIC,
		TEXT
	}
	private Datatype datatype;
	private Date resultDatetime;
	private Boolean valueBoolean;
	private Concept valueCoded;
	private Date valueDatetime;
	private Double valueNumeric;
	private String valueText;
	private Object resultObject;
	private static final Result emptyResult = new EmptyResult();
	public Result() {
	}
	public Result(Result result) {
		if (result != null) {
			this.add(result);
		}
	}
	public Result(List<Result> list) {
		if (!(list == null || list.isEmpty())) {
			this.addAll(list);
		}
	}
	public Result(Boolean valueBoolean) {
		this(new Date(), valueBoolean, null);
	}
	public Result(Date resultDate, Boolean valueBoolean, Object obj) {
		this(resultDate, Datatype.BOOLEAN, valueBoolean, null, null, null, null, obj);
	}
	public Result(Concept valueCoded) {
		this(new Date(), valueCoded, null);
	}
	public Result(Date resultDate, Concept valueCoded, Object obj) {
		this(resultDate, Datatype.CODED, null, valueCoded, null, null, null, obj);
	}
	public Result(Obs obs) {
		this(obs.getObsDatetime(), null, obs.getValueAsBoolean(), obs.getValueCoded(), obs.getValueDatetime(), obs
		        .getValueNumeric(), obs.getValueText(), obs);
		Concept concept = obs.getConcept();
		ConceptDatatype conceptDatatype;
		if (concept != null) {
			conceptDatatype = concept.getDatatype();
			if (conceptDatatype == null) {
				return;
			}
			if (conceptDatatype.isCoded()) {
				this.datatype = Datatype.CODED;
			} else if (conceptDatatype.isNumeric()) {
				this.datatype = Datatype.NUMERIC;
			} else if (conceptDatatype.isDate()) {
				this.datatype = Datatype.DATETIME;
			} else if (conceptDatatype.isText()) {
				this.datatype = Datatype.TEXT;
			} else if (conceptDatatype.isBoolean()) {
				this.datatype = Datatype.BOOLEAN;
			}
		}
	}
	public Result(Date valueDatetime) {
		this(new Date(), valueDatetime, null);
	}
	public Result(Date resultDate, Date valueDatetime, Object obj) {
		this(resultDate, Datatype.DATETIME, null, null, valueDatetime, null, null, obj);
	}
	public Result(Double valueNumeric) {
		this(new Date(), valueNumeric, null);
	}
	public Result(Date resultDate, Double valueNumeric, Object obj) {
		this(resultDate, Datatype.NUMERIC, null, null, null, valueNumeric, null, obj);
	}
	public Result(Integer valueNumeric) {
		this(new Date(), valueNumeric, null);
	}
	public Result(Date resultDate, Integer valueNumeric, Object obj) {
		this(resultDate, Datatype.NUMERIC, null, null, null, valueNumeric.doubleValue(), null, obj);
	}
	public Result(String valueText) {
		this(new Date(), valueText, null);
	}
	public Result(Date resultDate, String valueText, Object obj) {
		this(resultDate, Datatype.TEXT, null, null, null, null, valueText, obj);
	}
	public Result(Date resultDate, Datatype datatype, Boolean valueBoolean, Concept valueCoded, Date valueDatetime,
	    Double valueNumeric, String valueText, Object object) {
		this.resultDatetime = resultDate;
		this.valueNumeric = valueNumeric;
		this.valueDatetime = valueDatetime;
		this.valueCoded = valueCoded;
		this.valueText = valueText;
		this.valueBoolean = valueBoolean;
		this.datatype = datatype;
		this.resultObject = object;
	}
	public static final Result emptyResult() {
		return emptyResult;
	}
	public Datatype getDatatype() {
		if (isSingleResult()) {
			return this.datatype;
		}
		return this.get(0).getDatatype();
	}
	public void setResultDate(Date resultDatetime) {
		this.resultDatetime = resultDatetime;
	}
	public void setDatatype(Datatype datatype) {
		this.datatype = datatype;
	}
	public void setValueBoolean(Boolean valueBoolean) {
		this.valueBoolean = valueBoolean;
	}
	public void setValueCoded(Concept valueCoded) {
		this.valueCoded = valueCoded;
	}
	public void setValueDatetime(Date valueDatetime) {
		this.valueDatetime = valueDatetime;
	}
	public void setValueNumeric(Integer valueNumeric) {
		this.valueNumeric = valueNumeric.doubleValue();
	}
	public void setValueNumeric(Double valueNumeric) {
		this.valueNumeric = valueNumeric;
	}
	public void setValueText(String valueText) {
		this.valueText = valueText;
	}
	public Date getResultDate() {
		if (isSingleResult()) {
			return resultDatetime;
		}
		return this.get(0).getResultDate();
	}
	public Object getResultObject() {
		return this.resultObject;
	}
	public void setResultObject(Object object) {
		this.resultObject = object;
	}
	public Boolean toBoolean() {
		if (isSingleResult()) {
			if (datatype == null) {
				return valueBoolean;
			}
			switch (datatype) {
				case BOOLEAN:
					return (valueBoolean == null ? false : valueBoolean);
				case CODED:
					return (valueCoded != null); 
				case DATETIME:
					return (valueDatetime != null);
				case NUMERIC:
					return (valueNumeric != null && valueNumeric != 0);
				case TEXT:
					return (valueText != null && valueText.length() >= 1);
				default:
					return valueBoolean;
			}
		}
		for (Result r : this) {
			if (!r.toBoolean()) {
				return false;
			}
		}
		return true;
	}
	public Concept toConcept() {
		if (isSingleResult()) {
			return valueCoded;
		}
		return this.get(0).toConcept();
	}
	public Date toDatetime() {
		if (isSingleResult()) {
			if (valueDatetime != null) {
				return valueDatetime;
			}
			if (datatype == Datatype.TEXT && valueText != null) {
				try {
					return Context.getDateFormat().parse(valueText);
				}
				catch (Exception e) {}
			}
			return valueDatetime;
		}
		return this.get(0).toDatetime();
	}
	public Double toNumber() {
		if (isSingleResult()) {
			if (datatype == null) {
				return valueNumeric;
			}
			switch (datatype) {
				case BOOLEAN:
					return (valueBoolean == null || !valueBoolean ? 0D : 1D);
				case CODED:
					return 0D;
				case DATETIME:
					return (valueDatetime == null ? 0 : Long.valueOf(valueDatetime.getTime()).doubleValue());
				case NUMERIC:
					return (valueNumeric == null ? 0D : valueNumeric);
				case TEXT:
					try {
						return Double.parseDouble(valueText);
					}
					catch (Exception e) {
						return 0D;
					}
				default:
					return valueNumeric;
			}
		}
		return this.get(0).toNumber();
	}
	@Override
	public String toString() {
		if (isSingleResult()) {
			if (datatype == null) {
				return valueText == null ? "" : valueText;
			}
			switch (datatype) {
				case BOOLEAN:
					return (valueBoolean ? "true" : "false");
				case CODED:
					return (valueCoded == null ? "" : valueCoded.getName(Context.getLocale()).getName());
				case DATETIME:
					return (valueDatetime == null ? "" : Context.getDateFormat().format(valueDatetime));
				case NUMERIC:
					return (valueNumeric == null ? "" : String.valueOf(valueNumeric));
				case TEXT:
					return (valueText == null ? "" : valueText);
				default:
					return valueText;
			}
		}
		StringBuilder s = new StringBuilder();
		for (Result r : this) {
			if (s.length() > 0) {
				s.append(",");
			}
			s.append(r.toString());
		}
		return s.toString();
	}
	public Object toObject() {
		if (isSingleResult()) {
			return resultObject;
		}
		if (this.size() == 1) {
			return this.get(0).toObject();
		}
		throw new LogicException("This result represents more than one result, you cannot call toObject on multiple results");
	}
	public boolean isNull() {
		return false; 
	}
	public boolean exists() {
		if (isSingleResult()) {
			return ((valueBoolean != null && valueBoolean) || valueCoded != null || valueDatetime != null
			        || (valueNumeric != null && valueNumeric != 0) || (valueText != null && valueText.length() > 0));
		}
		for (Result r : this) {
			if (r.exists()) {
				return true;
			}
		}
		return false;
	}
	public boolean contains(Concept concept) {
		return containsConcept(concept.getConceptId());
	}
	public Result gt(Integer value) {
		if (isSingleResult()) {
			if (valueNumeric == null || valueNumeric <= value) {
				return emptyResult;
			}
			return this;
		}
		List<Result> matches = new ArrayList<>();
		for (Result r : this) {
			if (!r.gt(value).isEmpty()) {
				matches.add(r);
			}
		}
		if (matches.size() < 1) {
			return emptyResult;
		}
		return new Result(matches);
	}
	public boolean containsConcept(Integer conceptId) {
		if (isSingleResult()) {
			return (valueCoded != null && valueCoded.getConceptId().equals(conceptId));
		}
		for (Result r : this) {
			if (r.containsConcept(conceptId)) {
				return true;
			}
		}
		return false;
	}
	public boolean contains(Result result) {
		if (isSingleResult()) {
			return this.equals(result);
		}
		for (Result r : this) {
			if (r.contains(result)) {
				return true;
			}
		}
		return false;
	}
	public Result unique() {
		if (isSingleResult()) {
			return this;
		}
		Integer something = 1;
		Map<Result, Integer> map = new HashMap<>();
		for (Result r : this) {
			map.put(r, something);
		}
		List<Result> uniqueList = new ArrayList<>(map.keySet());
		return new Result(uniqueList);
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == null || !(obj instanceof Result)) {
			return false;
		}
		Result r = (Result) obj;
		if (EmptyResult.class.isAssignableFrom(r.getClass()) && this.isEmpty()) {
			return true;
		}
		if (EmptyResult.class.isAssignableFrom(this.getClass()) && r.isEmpty()) {
			return true;
		}
		if (isSingleResult() && r.isSingleResult()) {
			if (datatype == null) {
				return false;
			}
			switch (datatype) {
				case BOOLEAN:
					return (valueBoolean.equals(r.valueBoolean));
				case CODED:
					return (valueCoded.equals(r.valueCoded));
				case DATETIME:
					return (valueDatetime.equals(r.valueDatetime));
				case NUMERIC:
					return (valueNumeric.equals(r.valueNumeric));
				case TEXT:
					return (valueText.equals(r.valueText));
				default:
					return false;
			}
		}
		if (isSingleResult() || r.isSingleResult()) {
			return false;
		}
		if (this.size() != r.size()) {
			return false;
		}
		for (int i = 0; i < this.size(); i++) {
			if (!this.get(i).equals(r.get(i))) {
				return false;
			}
		}
		return true;
	}
	@Override
	public int hashCode() {
		if (isSingleResult()) {
			return new HashCodeBuilder().append(datatype).hashCode();
		} else {
			return super.hashCode();
		}
	}
	@Override
	public Result get(int index) {
		if (isSingleResult()) {
			return (index == 0 ? this : emptyResult);
		}
		if (index >= this.size()) {
			return emptyResult;
		}
		return super.get(index);
	}
	public Result earliest() {
		if (isSingleResult()) {
			return this;
		}
		Result first = emptyResult();
		if (size() > 0) {
			first = get(0);
		}
		for (Result r : this) {
			if (r != null && r.getResultDate() != null
			        && (first.getResultDate() == null || r.getResultDate().before(first.getResultDate()))) {
				first = r;
			}
		}
		return first;
	}
	public Result latest() {
		if (isSingleResult()) {
			return this;
		}
		Result last = emptyResult();
		if (size() > 0) {
			last = get(0);
		}
		for (Result r : this) {
			if ((last.getResultDate() == null || (r.getResultDate() != null && r.getResultDate().after(last.getResultDate())))) {
				last = r;
			}
		}
		return last;
	}
	private boolean isSingleResult() {
		return (this.size() < 1);
	}
}
package org.openmrs.util;
import java.text.DateFormat;
import java.text.NumberFormat;
import java.util.Date;
import java.util.Locale;
import org.apache.commons.lang3.exception.ExceptionUtils;
import org.openmrs.api.context.Context;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Format {
	private static final Logger log = LoggerFactory.getLogger(Format.class);
	public enum FORMAT_TYPE {
		DATE,
		TIME,
		TIMESTAMP
	}
	public static String formatPercentage(double pct) {
		return NumberFormat.getPercentInstance().format(pct);
	}
	public static String formatPercentage(Number pct) {
		if (pct == null) {
			return "";
		} else {
			return NumberFormat.getPercentInstance().format(pct.doubleValue());
		}
	}
	public static String format(double d) {
		return "" + (d);
	}
	public static String format(Double d) {
		return d == null ? "" : format(d.doubleValue());
	}
	public static String formatTextBoxDate(Date date) {
		return format(date, Context.getLocale(), FORMAT_TYPE.DATE);
	}
	public static String format(Date date) {
		return format(date, Context.getLocale(), FORMAT_TYPE.DATE);
	}
	public static String format(Date date, FORMAT_TYPE type) {
		return format(date, Context.getLocale(), type);
	}
	public static String format(Date date, Locale locale, FORMAT_TYPE type) {
		if (date == null || locale == null || type == null) {
			return "";
		}
		log.debug("Formatting date: " + date + " with locale " + locale);
		DateFormat dateFormat;
		if (type == FORMAT_TYPE.TIMESTAMP) {
			dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG, locale);
		} else if (type == FORMAT_TYPE.TIME) {
			dateFormat = DateFormat.getTimeInstance(DateFormat.MEDIUM, locale);
		} else {
			dateFormat = DateFormat.getDateInstance(DateFormat.SHORT, locale);
		}
		return dateFormat.format(date);
	}
	public static String format(Throwable t) {
		return t + "\n" + ExceptionUtils.getStackTrace(t);
	}
}
package org.openmrs.api;
import java.util.Date;
import java.util.List;
import java.util.Map;
import org.openmrs.Concept;
import org.openmrs.ConceptName;
import org.openmrs.Encounter;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.ObsReferenceRange;
import org.openmrs.Person;
import org.openmrs.Visit;
import org.openmrs.annotation.Authorized;
import org.openmrs.api.db.ObsDAO;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.util.OpenmrsConstants.PERSON_TYPE;
import org.openmrs.util.PrivilegeConstants;
public interface ObsService extends OpenmrsService {
	public void setObsDAO(ObsDAO dao);
	@Authorized(PrivilegeConstants.GET_OBS)
	public Obs getObs(Integer obsId) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public Obs getObsByUuid(String uuid) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public Obs getRevisionObs(Obs initialObs);
	@Authorized( { PrivilegeConstants.ADD_OBS, PrivilegeConstants.EDIT_OBS })
	public Obs saveObs(Obs obs, String changeMessage) throws APIException;
	@Authorized(PrivilegeConstants.EDIT_OBS)
	public Obs voidObs(Obs obs, String reason) throws APIException;
	@Authorized(PrivilegeConstants.EDIT_OBS)
	public Obs unvoidObs(Obs obs) throws APIException;
	@Authorized(PrivilegeConstants.DELETE_OBS)
	public void purgeObs(Obs obs) throws APIException;
	@Authorized(PrivilegeConstants.DELETE_OBS)
	public void purgeObs(Obs obs, boolean cascade) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public List<Obs> getObservationsByPerson(Person who);
	@Authorized(PrivilegeConstants.GET_OBS)
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<String> sort,
	        Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs)
	        throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<String> sort,
	        Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs,
	        String accessionNumber) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public Integer getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, Integer obsGroupId,
	        Date fromDate, Date toDate, boolean includeVoidedObs) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public Integer getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, Integer obsGroupId,
	        Date fromDate, Date toDate, boolean includeVoidedObs, String accessionNumber) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public List<Obs> getObservations(String searchString) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public List<Obs> getObservationsByPersonAndConcept(Person who, Concept question) throws APIException;
	@Deprecated
	@Authorized( { PrivilegeConstants.GET_OBS })
	public Obs getComplexObs(Integer obsId, String view) throws APIException;
	public ComplexObsHandler getHandler(String key) throws APIException;
	public ComplexObsHandler getHandler(Obs obs) throws APIException;
	public void setHandlers(Map<String, ComplexObsHandler> handlers) throws APIException;
	public Map<String, ComplexObsHandler> getHandlers() throws APIException;
	public void registerHandler(String key, ComplexObsHandler handler) throws APIException;
	public void registerHandler(String key, String handlerClass) throws APIException;
	public void removeHandler(String key) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public Integer getObservationCount(List<ConceptName> conceptNames, boolean includeVoided);
	@Authorized(PrivilegeConstants.GET_OBS)
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
			List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<String> sort,
			List<Visit> visits, Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate,
			boolean includeVoidedObs, String accessionNumber) throws APIException;
	@Authorized(PrivilegeConstants.GET_OBS)
	public Integer getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
			List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<Visit> visits,
			Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs, String accessionNumber)
			throws APIException;
}
package org.openmrs;
import org.hibernate.envers.Audited;
import java.util.Date;
import java.util.Locale;
@Audited
public class ConceptDescription extends BaseOpenmrsObject implements Auditable, java.io.Serializable {
	private static final long serialVersionUID = -7223075113369136584L;
	private Integer conceptDescriptionId;
	private Concept concept;
	private String description;
	private Locale locale;
	private User creator;
	private Date dateCreated;
	private User changedBy;
	private Date dateChanged;
	public ConceptDescription() {
	}
	public ConceptDescription(Integer conceptDescriptionId) {
		this.conceptDescriptionId = conceptDescriptionId;
	}
	public ConceptDescription(String description, Locale locale) {
		setLocale(locale);
		setDescription(description);
	}
	public Integer getConceptDescriptionId() {
		return conceptDescriptionId;
	}
	public void setConceptDescriptionId(Integer conceptDescriptionId) {
		this.conceptDescriptionId = conceptDescriptionId;
	}
	public Concept getConcept() {
		return concept;
	}
	public void setConcept(Concept concept) {
		this.concept = concept;
	}
	public String getDescription() {
		return description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	public Locale getLocale() {
		return locale;
	}
	public void setLocale(Locale locale) {
		this.locale = locale;
	}
	@Override
	public User getCreator() {
		return creator;
	}
	@Override
	public void setCreator(User creator) {
		this.creator = creator;
	}
	@Override
	public Date getDateCreated() {
		return dateCreated;
	}
	@Override
	public void setDateCreated(Date dateCreated) {
		this.dateCreated = dateCreated;
	}
	@Override
	public User getChangedBy() {
		return changedBy;
	}
	@Override
	public void setChangedBy(User changedBy) {
		this.changedBy = changedBy;
	}
	@Override
	public Date getDateChanged() {
		return dateChanged;
	}
	@Override
	public void setDateChanged(Date dateChanged) {
		this.dateChanged = dateChanged;
	}
	@Override
	public String toString() {
		return this.description;
	}
	@Override
	public Integer getId() {
		return getConceptDescriptionId();
	}
	@Override
	public void setId(Integer id) {
		setConceptDescriptionId(id);
	}
}
package org.openmrs.obs.handler;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.FileImageInputStream;
import org.openmrs.Obs;
import org.openmrs.api.APIException;
import org.openmrs.obs.ComplexData;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.util.OpenmrsUtil;
import java.io.ByteArrayInputStream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class ImageHandler extends AbstractHandler implements ComplexObsHandler {
	private static final String[] supportedViews = { ComplexObsHandler.RAW_VIEW };
	private static final Logger log = LoggerFactory.getLogger(ImageHandler.class);
	private Set<String> extensions;
	public ImageHandler() {
		super();
		extensions = new HashSet<>();
		Collections.addAll(extensions, ImageIO.getWriterFormatNames());
	}
	@Override
	public Obs getObs(Obs obs, String view) {
		File file = getComplexDataFile(obs);
		if (ComplexObsHandler.RAW_VIEW.equals(view)) {
			BufferedImage img = null;
			try {
				img = ImageIO.read(file);
			}
			catch (IOException e) {
				log.error("Trying to read file: " + file.getAbsolutePath(), e);
			}
			ComplexData complexData = new ComplexData(file.getName(), img);
			String mimeType = null;
			try {
				FileImageInputStream imgStream = new FileImageInputStream(file);
				Iterator<ImageReader> imgReader = ImageIO.getImageReaders(imgStream);
				imgStream.close();
				if (imgReader.hasNext()) {
					mimeType = "image/" + imgReader.next().getFormatName().toLowerCase();
				} else {
					log.warn("MIME type of " + file.getAbsolutePath() + " is not known");
				}
			}
			catch (FileNotFoundException e) {
				log.error("Image " + file.getAbsolutePath() + " was not found", e);
			}
			catch (IOException e) {
				log.error("Trying to determine MIME type of " + file.getAbsolutePath(), e);
			}
			mimeType = mimeType != null ? mimeType : OpenmrsUtil.getFileMimeType(file);
			complexData.setMimeType(mimeType);	
			obs.setComplexData(complexData);
		} else {
			return null;
		}
		return obs;
	}
	@Override
	public String[] getSupportedViews() {
		return supportedViews;
	}
	@Override
	public Obs saveObs(Obs obs) throws APIException {
		BufferedImage img = null;
		Object data = obs.getComplexData().getData();
		if (data instanceof BufferedImage) {
			img = (BufferedImage) obs.getComplexData().getData();
		} else if (data instanceof byte[]) {
			  ByteArrayInputStream bis = new ByteArrayInputStream((byte[]) data);
			    try {
			      img = ImageIO.read(bis);
			    }
			    catch (IOException e) {
			      throw new APIException("Obs.error.unable.convert.complex.data", new Object[] { "input stream" }, e);
			    }
			}
		 else if (data instanceof InputStream) {
			try {
				img = ImageIO.read((InputStream) data);
				if (img == null) {
					throw new IllegalArgumentException("Invalid image file");
				}
			}
			catch (IOException e) {
				throw new APIException("Obs.error.unable.convert.complex.data", new Object[] { "input stream" }, e);
			}
		}
		if (img == null) {
			throw new APIException("Obs.error.cannot.save.complex", new Object[] { obs.getObsId() });
		}
		File outfile = null;
		try {
			outfile = getOutputFileToWrite(obs);
			String extension = getExtension(obs.getComplexData().getTitle());
			ImageIO.write(img, extension, outfile);
			obs.setValueComplex(extension + " image |" + outfile.getName());
			obs.setComplexData(null);
		}
		catch (IOException ioe) {
			if (outfile != null && outfile.length() == 0) {
				outfile.delete(); 
			}
			throw new APIException("Obs.error.trying.write.complex", null, ioe);
		}
		return obs;
	}
}
package org.openmrs.obs;
import org.openmrs.Obs;
import org.openmrs.api.APIException;
public interface ComplexObsHandler {
	public static final String RAW_VIEW = "RAW_VIEW";
	public static final String TITLE_VIEW = "TITLE_VIEW";
	public static final String TEXT_VIEW = "TEXT_VIEW";
	public static final String HTML_VIEW = "HTML_VIEW";
	public static final String PREVIEW_VIEW = "PREVIEW_VIEW";
	public static final String URI_VIEW = "URI_VIEW";
	public Obs saveObs(Obs obs) throws APIException;
	public Obs getObs(Obs obs, String view);
	public boolean purgeComplexData(Obs obs);
	public String[] getSupportedViews();
	public boolean supportsView(String view);
}
package org.openmrs.obs.handler;
import java.io.File;
import java.io.IOException;
import java.text.NumberFormat;
import java.util.Arrays;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Obs;
import org.openmrs.api.context.Context;
import org.openmrs.obs.ComplexData;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class AbstractHandler {
	private static final Logger log = LoggerFactory.getLogger(AbstractHandler.class);
	protected NumberFormat nf;
	public AbstractHandler() {
		nf = NumberFormat.getInstance();
		nf.setMaximumFractionDigits(0);
		nf.setMinimumIntegerDigits(2);
	}
	public File getOutputFileToWrite(Obs obs) throws IOException {
		String title = obs.getComplexData().getTitle();
		String titleWithoutExtension = FilenameUtils.removeExtension(title);
		String extension = "." + StringUtils.defaultIfEmpty(FilenameUtils.getExtension(title), "dat");
		String uuid = obs.getUuid();
		String filename;
		if (StringUtils.isNotBlank(titleWithoutExtension)) {
			filename = titleWithoutExtension + "_" + uuid + extension;
		} else {
			filename = uuid + extension;
		}
		File dir = OpenmrsUtil.getDirectoryInApplicationDataDirectory(
		    Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_COMPLEX_OBS_DIR));
		return new File(dir, filename);
	}
	@Deprecated
	public String getExtension(String filename) {
		String result = FilenameUtils.getExtension(filename);
		if (StringUtils.isEmpty(result)) {
			result = FilenameUtils.getBaseName(filename);
			if (StringUtils.isEmpty(result)) {
				result = "raw";
			}
		}
		return result;
	}
	public Obs getObs(Obs obs, String view) {
		File file = BinaryDataHandler.getComplexDataFile(obs);
		log.debug("value complex: " + obs.getValueComplex());
		log.debug("file path: " + file.getAbsolutePath());
		ComplexData complexData = null;
		try {
			complexData = new ComplexData(file.getName(), OpenmrsUtil.getFileAsBytes(file));
		}
		catch (IOException e) {
			log.error("Trying to read file: " + file.getAbsolutePath(), e);
		}
		String mimeType = OpenmrsUtil.getFileMimeType(file);
		complexData.setMimeType(mimeType);
		obs.setComplexData(complexData);
		return obs;
	}
	public boolean purgeComplexData(Obs obs) {
		File file = getComplexDataFile(obs);
		if (!file.exists()) {
			return true;
		} else if (file.delete()) {
			obs.setComplexData(null);
			return true;
		}
		log.warn(
		    "Could not delete complex data object for obsId=" + obs.getObsId() + " located at " + file.getAbsolutePath());
		return false;
	}
	public static File getComplexDataFile(Obs obs) {
		String[] names = obs.getValueComplex().split("\\|");
		String filename = names.length < 2 ? names[0] : names[names.length - 1];
		File dir = OpenmrsUtil.getDirectoryInApplicationDataDirectory(
		    Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GLOBAL_PROPERTY_COMPLEX_OBS_DIR));
		return new File(dir, filename);
	}
	public String[] getSupportedViews() {
		return new String[0];
	}
	public boolean supportsView(String view) {
		return Arrays.asList(getSupportedViews()).contains(view);
	}
}
package org.openmrs.obs.handler;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import org.apache.commons.io.IOUtils;
import org.openmrs.Obs;
import org.openmrs.api.APIException;
import org.openmrs.obs.ComplexData;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.Assert;
public class TextHandler extends AbstractHandler implements ComplexObsHandler {
	private static final String[] supportedViews = { ComplexObsHandler.TEXT_VIEW, ComplexObsHandler.RAW_VIEW,
	        ComplexObsHandler.URI_VIEW };
	private static final Logger log = LoggerFactory.getLogger(TextHandler.class);
	public TextHandler() {
		super();
	}
	@Override
	public Obs getObs(Obs obs, String view) {
		File file = getComplexDataFile(obs);
		log.debug("value complex: " + obs.getValueComplex());
		log.debug("file path: " + file.getAbsolutePath());
		ComplexData complexData = null;
		if (ComplexObsHandler.TEXT_VIEW.equals(view) || ComplexObsHandler.RAW_VIEW.equals(view)) {
			String[] names = obs.getValueComplex().split("\\|");
			String originalFilename = names[0];
			originalFilename = originalFilename.replaceAll(",", "").replaceAll(" ", "").replaceAll("file$", "");
			try {
				complexData = ComplexObsHandler.RAW_VIEW.equals(view) ? new ComplexData(originalFilename, OpenmrsUtil
				        .getFileAsBytes(file)) : new ComplexData(originalFilename, OpenmrsUtil.getFileAsString(file));
			}
			catch (IOException e) {
				log.error("Trying to read file: " + file.getAbsolutePath(), e);
			}
		} else if (ComplexObsHandler.URI_VIEW.equals(view)) {
			complexData = new ComplexData(file.getName(), file.getPath());
		} else {
			return null;
		}
		Assert.notNull(complexData, "Complex data must not be null");
		String mimeType = OpenmrsUtil.getFileMimeType(file);
		mimeType = !(mimeType.equals("application/octet-stream")) ? mimeType : "text/plain";
		complexData.setMimeType(mimeType);
		obs.setComplexData(complexData);
		return obs;
	}
	@Override
	public String[] getSupportedViews() {
		return supportedViews;
	}
	@Override
	public Obs saveObs(Obs obs) throws APIException {
		ComplexData complexData = obs.getComplexData();
		if (complexData == null) {
			log.error("Cannot save complex data where obsId=" + obs.getObsId() + " because its ComplexData is null.");
			return obs;
		}
		BufferedWriter fout = null;
		try {
			File outfile = getOutputFileToWrite(obs);
			fout = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outfile), StandardCharsets.UTF_8));
			Reader tempRd;
			Object data = obs.getComplexData().getData();
			if (data instanceof char[]) {
				fout.write((char[]) data);
			} else if (Reader.class.isAssignableFrom(data.getClass())) {
				try {
					tempRd = new BufferedReader((Reader) data);
					while (true) {
						int character = tempRd.read();
						if (character == -1) {
							break;
						}
						fout.write(character);
					}
					tempRd.close();
				}
				catch (IOException e) {
					throw new APIException("Obs.error.unable.convert.complex.data", new Object[] { "Reader" }, e);
				}
			} else if (InputStream.class.isAssignableFrom(data.getClass())) {
				try {
					IOUtils.copy((InputStream) data, fout);
				}
				catch (IOException e) {
					throw new APIException("Obs.error.unable.convert.complex.data", new Object[] { "input stream" }, e);
				}
			}
			obs.setValueComplex(outfile.getName() + " file |" + outfile.getName());
			obs.setComplexData(null);
		}
		catch (IOException ioe) {
			throw new APIException("Obs.error.trying.write.complex", null, ioe);
		}
		finally {
			try {
				fout.close();
			}
			catch (Exception e) {
			}
		}
		return obs;
	}
}
package org.openmrs.obs.handler;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import org.openmrs.Obs;
import org.openmrs.api.APIException;
import org.openmrs.obs.ComplexData;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.Assert;
public class BinaryDataHandler extends AbstractHandler implements ComplexObsHandler {
	private static final String[] supportedViews = { ComplexObsHandler.RAW_VIEW, };
	private static final Logger log = LoggerFactory.getLogger(BinaryDataHandler.class);
	public BinaryDataHandler() {
		super();
	}
	@Override
	public Obs getObs(Obs obs, String view) {
		File file = getComplexDataFile(obs);
		log.debug("value complex: " + obs.getValueComplex());
		log.debug("file path: " + file.getAbsolutePath());
		ComplexData complexData = null;
		if (ComplexObsHandler.RAW_VIEW.equals(view)) {
			String[] names = obs.getValueComplex().split("\\|");
			String originalFilename = names[0];
			originalFilename = originalFilename.replaceAll(",", "").replaceAll(" ", "").replaceAll("file$", "");
			try {
				complexData = new ComplexData(originalFilename, OpenmrsUtil.getFileAsBytes(file));
			}
			catch (IOException e) {
				log.error("Trying to read file: " + file.getAbsolutePath(), e);
			}
		} else {
			return null;
		}
		Assert.notNull(complexData, "Complex data must not be null");
		String mimeType = OpenmrsUtil.getFileMimeType(file);
		complexData.setMimeType(mimeType);
		obs.setComplexData(complexData);
		return obs;
	}
	@Override
	public String[] getSupportedViews() {
		return supportedViews;
	}
	@Override
	public Obs saveObs(Obs obs) throws APIException {
		ComplexData complexData = obs.getComplexData();
		if (complexData == null) {
			log.error("Cannot save complex data where obsId=" + obs.getObsId() + " because its ComplexData is null.");
			return obs;
		}
		FileOutputStream fout = null;
		try {
			File outfile = getOutputFileToWrite(obs);
			fout = new FileOutputStream(outfile);
			Object data = obs.getComplexData().getData();
			if (data instanceof byte[]) {
				fout.write((byte[]) data);
			} else if (InputStream.class.isAssignableFrom(data.getClass())) {
				try {
					OpenmrsUtil.copyFile((InputStream) data, fout);
				}
				catch (IOException e) {
					throw new APIException("Obs.error.unable.convert.complex.data", new Object[] { "input stream" }, e);
				}
			}
			obs.setValueComplex(outfile.getName() + " file |" + outfile.getName());
			obs.setComplexData(null);
		}
		catch (IOException ioe) {
			throw new APIException("Obs.error.trying.write.complex", null, ioe);
		}
		finally {
			try {
				fout.close();
			}
			catch (Exception e) {
			}
		}
		return obs;
	}
}
package org.openmrs.api.impl;
import java.io.File;
import java.util.Date;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import org.openmrs.Concept;
import org.openmrs.ConceptName;
import org.openmrs.Encounter;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.Patient;
import org.openmrs.Person;
import org.openmrs.Visit;
import org.openmrs.aop.RequiredDataAdvice;
import org.openmrs.api.APIException;
import org.openmrs.api.EncounterService;
import org.openmrs.api.ObsService;
import org.openmrs.api.PatientService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.ObsDAO;
import org.openmrs.api.handler.SaveHandler;
import org.openmrs.obs.ComplexData;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.obs.handler.AbstractHandler;
import org.openmrs.util.OpenmrsClassLoader;
import org.openmrs.util.OpenmrsConstants.PERSON_TYPE;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.springframework.transaction.annotation.Transactional;
@Transactional
public class ObsServiceImpl extends BaseOpenmrsService implements ObsService {
	protected ObsDAO dao;
	private static Map<String, ComplexObsHandler> handlers = null;
	public ObsServiceImpl() {
	}
	@Override
	public void setObsDAO(ObsDAO dao) {
		this.dao = dao;
	}
	@Override
	public void onShutdown() {
		setHandlers(null);
	}
	@Override
	public Obs saveObs(Obs obs, String changeMessage) throws APIException {
		if(obs == null){
			throw new APIException("Obs.error.cannot.be.null", (Object[]) null);
		}
		if(obs.getId() != null && changeMessage == null){
			throw new APIException("Obs.error.ChangeMessage.required", (Object[]) null);
		}
		handleExistingObsWithComplexConcept(obs);
		ensureRequirePrivilege(obs);
		if (obs.getObsId() == null || obs.getVoided()) {
			return saveNewOrVoidedObs(obs,changeMessage);
		} else if(!obs.isDirty()){
			setPersonFromEncounter(obs);
			return saveObsNotDirty(obs, changeMessage);
		} else {
			setPersonFromEncounter(obs);
			return saveExistingObs(obs,changeMessage);
		}
	}
	private void setPersonFromEncounter(Obs obs) {
		Encounter encounter = obs.getEncounter();
		if (encounter != null) {
			obs.setPerson(encounter.getPatient());
		}
	}
	private void voidExistingObs(Obs obs, String changeMessage, Obs newObs) {
		try {
			Context.addProxyPrivilege(PrivilegeConstants.DELETE_OBS);
			evictObsAndChildren(obs);
			obs = Context.getObsService().getObs(obs.getObsId());
			if (newObs.hasPreviousVersion() && newObs.getPreviousVersion().isComplex()) {
				File previousFile = AbstractHandler.getComplexDataFile(obs);
				previousFile.delete();
			}
			Context.getObsService().voidObs(obs, changeMessage);
		}
		finally {
			Context.removeProxyPrivilege(PrivilegeConstants.DELETE_OBS);
		}
	}
	private Obs saveExistingObs(Obs obs, String changeMessage) {
		Obs newObs = Obs.newInstance(obs);
		unsetVoidedAndCreationProperties(newObs,obs);
		Obs.Status originalStatus = dao.getSavedStatus(obs);
		updateStatusIfNecessary(newObs, originalStatus);
		RequiredDataAdvice.recursivelyHandle(SaveHandler.class, newObs, changeMessage);
		dao.saveObs(newObs);
		saveObsGroup(newObs,null);
		voidExistingObs(obs, changeMessage, newObs);
		return newObs;
	}
	private void updateStatusIfNecessary(Obs newObs, Obs.Status originalStatus) {
		if (Obs.Status.FINAL.equals(originalStatus)) {
			newObs.setStatus(Obs.Status.AMENDED);
		}
	}
	private void unsetVoidedAndCreationProperties(Obs newObs,Obs obs) {
		newObs.setVoided(false);
		newObs.setVoidReason(null);
		newObs.setDateVoided(null);
		newObs.setVoidedBy(null);
		newObs.setCreator(null);
		newObs.setDateCreated(null);
		newObs.setPreviousVersion(obs);
	}
	private Obs saveObsNotDirty(Obs obs, String changeMessage) {
		if(!obs.isObsGrouping()){
			return obs;
		}
		ObsService os = Context.getObsService();
		boolean refreshNeeded = false;
		for (Obs o : obs.getGroupMembers(true)) {
			if (o.getId() == null) {
				os.saveObs(o, null);
			} else {
				Obs newObs = os.saveObs(o, changeMessage);
				refreshNeeded = !newObs.equals(o) || refreshNeeded;
			}
		}
		if(refreshNeeded) {
			Context.refreshEntity(obs);
		}
		return obs;
	}
	private Obs saveNewOrVoidedObs(Obs obs, String changeMessage) {
		Obs ret = dao.saveObs(obs);
		saveObsGroup(ret,changeMessage);
		return ret;
	}
	private void evictObsAndChildren(Obs obs) {
		Context.evictFromSession(obs);
		if(obs.hasGroupMembers()) {
			for(Obs member : obs.getGroupMembers()) {
				evictObsAndChildren(member);
			}
		}
	}
	private void ensureRequirePrivilege(Obs obs){
		if (obs.getObsId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_OBS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_OBS);
		}
	}
	private void saveObsGroup(Obs obs, String changeMessage){
		if (obs.isObsGrouping()) {
			for (Obs o : obs.getGroupMembers(true)) {
				Context.getObsService().saveObs(o, changeMessage);
			}
		}
	}
	private void handleExistingObsWithComplexConcept(Obs obs) {
		ComplexData complexData = obs.getComplexData();
		Concept concept = obs.getConcept();
		if (null != concept && concept.isComplex()
		        && null != complexData && null != complexData.getData()) {
			ComplexObsHandler handler = getHandler(obs);
			if (null != handler) {
				handler.saveObs(obs);
			} else {
				throw new APIException("unknown.handler", new Object[] {concept});
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Obs getObs(Integer obsId) throws APIException {
		Obs obs = dao.getObs(obsId);
		if (obs != null && obs.isComplex()) {
			return getHandler(obs).getObs(obs,ComplexObsHandler.RAW_VIEW);
		}
		return obs;
	}
	@Override
	public Obs voidObs(Obs obs, String reason) throws APIException {
		return dao.saveObs(obs);
	}
	@Override
	public Obs unvoidObs(Obs obs) throws APIException {
		return Context.getObsService().saveObs(obs,"unvoid obs");
	}
	@Override
	public void purgeObs(Obs obs, boolean cascade) throws APIException {
		if (!purgeComplexData(obs)) {
			throw new APIException("Obs.error.unable.purge.complex.data", new Object[] { obs });
		}
		if (cascade) {
			throw new APIException("Obs.error.cascading.purge.not.implemented", (Object[]) null);
		}
		dao.deleteObs(obs);
	}
	@Override
	public void purgeObs(Obs obs) throws APIException {
		Context.getObsService().purgeObs(obs, false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	                                 List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations,
	                                 List<String> sort, Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate,
	                                 boolean includeVoidedObs) throws APIException {
		if (sort == null) {
			sort = new ArrayList<>();
		}
		if (sort.isEmpty()) {
			sort.add("obsDatetime");
		}
		return dao.getObservations(whom, encounters, questions, answers, personTypes, locations, sort, mostRecentN,
		    obsGroupId, fromDate, toDate, includeVoidedObs, null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	                                 List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations,
	                                 List<String> sort, Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate,
	                                 boolean includeVoidedObs, String accessionNumber) throws APIException {
		return this.getObservations(whom, encounters, questions, answers, personTypes, locations, sort, null,
				mostRecentN, obsGroupId, fromDate, toDate, includeVoidedObs, accessionNumber);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	                                 List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations,
	                                 List<String> sort, List<Visit> visits, Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate,
	                                 boolean includeVoidedObs, String accessionNumber) throws APIException {
		if (sort == null) {
			sort = new ArrayList<>();
		}
		if (sort.isEmpty()) {
			sort.add("obsDatetime");
		}
		return dao.getObservations(whom, encounters, questions, answers, personTypes, locations, sort, visits, mostRecentN,
		    obsGroupId, fromDate, toDate, includeVoidedObs, accessionNumber);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	                                   List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations,
	                                   Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs)
	    throws APIException {
		return OpenmrsUtil.convertToInteger(dao.getObservationCount(whom, encounters, questions, answers, personTypes,
		    locations, obsGroupId, fromDate, toDate, null, includeVoidedObs, null));
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	                                   List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations,
	                                   Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs,
	                                   String accessionNumber) throws APIException {
		return this.getObservationCount(whom, encounters, questions, answers, personTypes, locations, null, obsGroupId,
				fromDate, toDate, includeVoidedObs, accessionNumber);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	                                   List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<Visit> visits,
	                                   Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs,
	                                   String accessionNumber) throws APIException {
		return OpenmrsUtil.convertToInteger(dao.getObservationCount(whom, encounters, questions, answers, personTypes,
		    locations, obsGroupId, fromDate, toDate, null, visits, includeVoidedObs, accessionNumber));
	}
	@Override
	@Transactional(readOnly = true)
	public List<Obs> getObservations(String searchString) {
		PatientService ps = Context.getPatientService();
		List<Patient> patients = ps.getPatients(searchString);
		List<Person> persons = new ArrayList<>(patients);
		EncounterService es = Context.getEncounterService();
		List<Encounter> encounters = new ArrayList<>();
		try {
			Encounter e = es.getEncounter(Integer.valueOf(searchString));
			if (e != null) {
				encounters.add(e);
			}
		}
		catch (NumberFormatException e) {
		}
		List<Obs> returnList = new ArrayList<>();
		if (!encounters.isEmpty() || !persons.isEmpty()) {
			returnList = Context.getObsService().getObservations(persons, encounters, null, null, null, null, null, null,
			    null, null, null, false);
		}
		try {
			Obs o = getObs(Integer.valueOf(searchString));
			if (o != null) {
				returnList.add(o);
			}
		}
		catch (NumberFormatException e) {
		}
		return returnList;
	}
	@Override
	@Transactional(readOnly = true)
	public List<Obs> getObservationsByPerson(Person who) {
		List<Person> whom = new ArrayList<>();
		whom.add(who);
		return Context.getObsService().getObservations(whom, null, null, null, null, null, null, null, null, null, null,
		    false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Obs> getObservationsByPersonAndConcept(Person who, Concept question) throws APIException {
		List<Person> whom = new ArrayList<>();
		if (who != null && who.getPersonId() != null) {
			whom.add(who);
		}
		List<Concept> questions = new ArrayList<>();
		questions.add(question);
		return Context.getObsService().getObservations(whom, null, questions, null, null, null, null, null, null, null,
		    null, false);
	}
	@Override
	@Transactional(readOnly = true)
	public Obs getObsByUuid(String uuid) throws APIException {
		Obs obsByUuid = dao.getObsByUuid(uuid);
		if (obsByUuid != null && obsByUuid.isComplex()) {
			return getHandler(obsByUuid).getObs(obsByUuid,ComplexObsHandler.RAW_VIEW);
		}
		return obsByUuid;
	}
	@Transactional(readOnly = true)
	public Obs getRevisionObs(Obs initialObs) {
		return dao.getRevisionObs(initialObs);
	}
	@Override
	@Transactional(readOnly = true)
	public Obs getComplexObs(Integer obsId, String view) throws APIException {
		Obs obs = dao.getObs(obsId);
		if (obs != null && obs.isComplex()) {
			return getHandler(obs).getObs(obs, view);
		}
		return obs;
	}
	protected boolean purgeComplexData(Obs obs) throws APIException {
		if (obs.isComplex()) {
			ComplexObsHandler handler = getHandler(obs);
			if (null != handler) {
				return handler.purgeComplexData(obs);
			}
		}
		return true;
	}
	@Override
	@Transactional(readOnly = true)
	public ComplexObsHandler getHandler(Obs obs) throws APIException {
		if (obs.getConcept().isComplex()) {
			if (obs.getConcept() == null) {
				throw new APIException("Obs.error.unable.get.handler", new Object[] { obs });
			}
			String handlerString = Context.getConceptService().getConceptComplex(obs.getConcept().getConceptId())
			        .getHandler();
			if (handlerString == null) {
				throw new APIException("Obs.error.unable.get.handler.and.concept", new Object[] { obs, obs.getConcept() });
			}
			return this.getHandler(handlerString);
		}
		return null;
	}
	@Override
	public ComplexObsHandler getHandler(String key) {
		return handlers.get(key);
	}
	@Override
	public void setHandlers(Map<String, ComplexObsHandler> newHandlers) throws APIException {
		if (newHandlers == null) {
			ObsServiceImpl.setStaticHandlers(null);
			return;
		}
		for (Map.Entry<String, ComplexObsHandler> entry : newHandlers.entrySet()) {
			registerHandler(entry.getKey(), entry.getValue());
		}
	}
	private static void setStaticHandlers(Map<String, ComplexObsHandler> currentHandlers) {
		ObsServiceImpl.handlers = currentHandlers;
	}
	@Override
	@Transactional(readOnly = true)
	public Map<String, ComplexObsHandler> getHandlers() throws APIException {
		if (handlers == null) {
			handlers = new LinkedHashMap<>();
		}
		return handlers;
	}
	@Override
	public void registerHandler(String key, ComplexObsHandler handler) throws APIException {
		getHandlers().put(key, handler);
	}
	@Override
	public void registerHandler(String key, String handlerClass) throws APIException {
		try {
			Class<?> loadedClass = OpenmrsClassLoader.getInstance().loadClass(handlerClass);
			registerHandler(key, (ComplexObsHandler) loadedClass.newInstance());
		}
		catch (Exception e) {
			throw new APIException("unable.load.and.instantiate.handler", null, e);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getObservationCount(List<ConceptName> conceptNames, boolean includeVoided) {
		return OpenmrsUtil.convertToInteger(dao.getObservationCount(null, null, null, null, null, null, null, null, null,
		    conceptNames, true, null));
	}
	@Override
	public void removeHandler(String key) {
		handlers.remove(key);
	}
}
package org.openmrs.api.impl;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import org.apache.commons.lang3.StringUtils;
import org.openmrs.Allergen;
import org.openmrs.Allergies;
import org.openmrs.Allergy;
import org.openmrs.BaseOpenmrsMetadata;
import org.openmrs.Concept;
import org.openmrs.Encounter;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.Order;
import org.openmrs.Patient;
import org.openmrs.PatientIdentifier;
import org.openmrs.PatientIdentifierType;
import org.openmrs.PatientProgram;
import org.openmrs.Person;
import org.openmrs.PersonAddress;
import org.openmrs.PersonAttribute;
import org.openmrs.PersonName;
import org.openmrs.Relationship;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.api.APIException;
import org.openmrs.api.BlankIdentifierException;
import org.openmrs.api.DuplicateIdentifierException;
import org.openmrs.api.EncounterService;
import org.openmrs.api.InsufficientIdentifiersException;
import org.openmrs.api.MissingRequiredIdentifierException;
import org.openmrs.api.ObsService;
import org.openmrs.api.PatientIdentifierException;
import org.openmrs.api.PatientIdentifierTypeLockedException;
import org.openmrs.api.PatientService;
import org.openmrs.api.PersonService;
import org.openmrs.api.ProgramWorkflowService;
import org.openmrs.api.UserService;
import org.openmrs.api.VisitService;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.PatientDAO;
import org.openmrs.api.db.hibernate.HibernateUtil;
import org.openmrs.parameter.EncounterSearchCriteria;
import org.openmrs.parameter.EncounterSearchCriteriaBuilder;
import org.openmrs.patient.IdentifierValidator;
import org.openmrs.patient.impl.LuhnIdentifierValidator;
import org.openmrs.person.PersonMergeLog;
import org.openmrs.person.PersonMergeLogData;
import org.openmrs.serialization.SerializationException;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.util.PrivilegeConstants;
import org.openmrs.validator.PatientIdentifierValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.transaction.annotation.Transactional;
@Transactional
public class PatientServiceImpl extends BaseOpenmrsService implements PatientService {
	private static final Logger log = LoggerFactory.getLogger(PatientServiceImpl.class);
	private PatientDAO dao;
	private static Map<Class<? extends IdentifierValidator>, IdentifierValidator> identifierValidators = null;
	@Override
	public void setPatientDAO(PatientDAO dao) {
		this.dao = dao;
	}
	@Override
	public void onShutdown() {
		setIdentifierValidators(null);
	}
	@Override
	public Patient savePatient(Patient patient) throws APIException {
		requireAppropriatePatientModificationPrivilege(patient);
		if (!patient.getVoided() && patient.getIdentifiers().size() == 1) {
			patient.getPatientIdentifier().setPreferred(true);
		}
		if (!patient.getVoided()) {
			checkPatientIdentifiers(patient);
		}
		setPreferredPatientIdentifier(patient);
		setPreferredPatientName(patient);
		setPreferredPatientAddress(patient);
		return dao.savePatient(patient);
	}
	private void requireAppropriatePatientModificationPrivilege(Patient patient) {
		if (patient.getPatientId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_PATIENTS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_PATIENTS);
		}
		if (patient.getVoided()) {
			Context.requirePrivilege(PrivilegeConstants.DELETE_PATIENTS);
		}
	}
	private void setPreferredPatientIdentifier(Patient patient) {
		PatientIdentifier preferredIdentifier = null;
		PatientIdentifier possiblePreferredId = patient.getPatientIdentifier();
		if (possiblePreferredId != null && possiblePreferredId.getPreferred() && !possiblePreferredId.getVoided()) {
			preferredIdentifier = possiblePreferredId;
		}
		for (PatientIdentifier id : patient.getIdentifiers()) {
			if (preferredIdentifier == null && !id.getVoided()) {
				id.setPreferred(true);
				preferredIdentifier = id;
				continue;
			}
			if (!id.equals(preferredIdentifier)) {
				id.setPreferred(false);
			}
		}
	}
	private void setPreferredPatientName(Patient patient) {
		PersonName preferredName = null;
		PersonName possiblePreferredName = patient.getPersonName();
		if (possiblePreferredName != null && possiblePreferredName.getPreferred() && !possiblePreferredName.getVoided()) {
			preferredName = possiblePreferredName;
		}
		for (PersonName name : patient.getNames()) {
			if (preferredName == null && !name.getVoided()) {
				name.setPreferred(true);
				preferredName = name;
				continue;
			}
			if (!name.equals(preferredName)) {
				name.setPreferred(false);
			}
		}
	}
	private void setPreferredPatientAddress(Patient patient) {
		PersonAddress preferredAddress = null;
		PersonAddress possiblePreferredAddress = patient.getPersonAddress();
		if (possiblePreferredAddress != null && possiblePreferredAddress.getPreferred()
				&& !possiblePreferredAddress.getVoided()) {
			preferredAddress = possiblePreferredAddress;
		}
		for (PersonAddress address : patient.getAddresses()) {
			if (preferredAddress == null && !address.getVoided()) {
				address.setPreferred(true);
				preferredAddress = address;
				continue;
			}
			if (!address.equals(preferredAddress)) {
				address.setPreferred(false);
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatient(Integer patientId) throws APIException {
		return dao.getPatient(patientId);
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientOrPromotePerson(Integer patientOrPersonId) {
		Person person = Context.getPersonService().getPerson(patientOrPersonId);
		if (person == null) {
			return null;
		}
		person = HibernateUtil.getRealObjectFromProxy(person);
		if (person instanceof Patient) {
			return (Patient)person;
		}
		else {
			return new Patient(person);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getAllPatients() throws APIException {
		return Context.getPatientService().getAllPatients(false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getAllPatients(boolean includeVoided) throws APIException {
		return dao.getAllPatients(includeVoided);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly) throws APIException {
		return Context.getPatientService().getPatients(name, identifier, identifierTypes, matchIdentifierExactly, 0, null);
	}
	@Override
	@Transactional(readOnly = true)
	public void checkPatientIdentifiers(Patient patient) throws PatientIdentifierException {
		if (!patient.getVoided() && patient.getActiveIdentifiers().isEmpty()) {
			throw new InsufficientIdentifiersException("At least one nonvoided Patient Identifier is required");
		}
		final List<PatientIdentifier> patientIdentifiers = new ArrayList<>(patient.getIdentifiers());
		final Set<String> uniqueIdentifiers = new HashSet<>();
		patientIdentifiers.stream()
			.filter(pi -> !pi.getVoided())
			.forEach(pi -> {
				try {
					PatientIdentifierValidator.validateIdentifier(pi);
				}
				catch (BlankIdentifierException bie) {
					patient.removeIdentifier(pi);
					throw bie;
				}
				String compareString = pi.getIdentifier() + " id type #: " + pi.getIdentifierType().getPatientIdentifierTypeId();
				if(! uniqueIdentifiers.add(compareString)) {
					throw new DuplicateIdentifierException("This patient has two identical identifiers of type "
							+ compareString, pi);
				}
			});
		checkForMissingRequiredIdentifiers(patientIdentifiers);
	}
	private void checkForMissingRequiredIdentifiers(List<PatientIdentifier> patientIdentifiers) {
		final Set<PatientIdentifierType> patientIdentifierTypes =
				patientIdentifiers.stream()
						.map(PatientIdentifier::getIdentifierType)
						.collect(Collectors.toSet());
		final List<PatientIdentifierType> requiredTypes = this.getPatientIdentifierTypes(null, null, true, null);
		final Set<String> missingRequiredTypeNames =
				requiredTypes.stream()
						.filter(requiredType -> !patientIdentifierTypes.contains(requiredType))
						.map(BaseOpenmrsMetadata::getName)
						.collect(Collectors.toSet());
		if(! missingRequiredTypeNames.isEmpty()) {
			throw new MissingRequiredIdentifierException(
					"Patient is missing the following required identifier(s): " + String.join(", ", missingRequiredTypeNames));
		}
	}
	@Override
	public Patient voidPatient(Patient patient, String reason) throws APIException {
		if (patient == null) {
			return null;
		}
		return dao.savePatient(patient);
	}
	@Override
	public Patient unvoidPatient(Patient patient) throws APIException {
		if (patient == null) {
			return null;
		}
		return Context.getPatientService().savePatient(patient);
	}
	@Override
	public void purgePatient(Patient patient) throws APIException {
		dao.deletePatient(patient);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifier> getPatientIdentifiers(String identifier,
	        List<PatientIdentifierType> patientIdentifierTypes, List<Location> locations, List<Patient> patients,
	        Boolean isPreferred) throws APIException {
		if (patientIdentifierTypes == null) {
			patientIdentifierTypes = new ArrayList<>();
		}
		if (locations == null) {
			locations = new ArrayList<>();
		}
		if (patients == null) {
			patients = new ArrayList<>();
		}
		return dao.getPatientIdentifiers(identifier, patientIdentifierTypes, locations, patients, isPreferred);
	}
	@Override
	public PatientIdentifierType savePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		return dao.savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getAllPatientIdentifierTypes() throws APIException {
		return Context.getPatientService().getAllPatientIdentifierTypes(false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getAllPatientIdentifierTypes(boolean includeRetired) throws APIException {
		return dao.getAllPatientIdentifierTypes(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<PatientIdentifierType> getPatientIdentifierTypes(String name, String format, Boolean required,
	        Boolean hasCheckDigit) throws APIException {
		List<PatientIdentifierType> patientIdentifierTypes = dao.getPatientIdentifierTypes(name, format, required, hasCheckDigit);
		if (patientIdentifierTypes == null) {
			return new ArrayList<>();
		}
		return patientIdentifierTypes;
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierType(Integer patientIdentifierTypeId) throws APIException {
		return dao.getPatientIdentifierType(patientIdentifierTypeId);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierTypeByName(String name) throws APIException {
		List<PatientIdentifierType> types = getPatientIdentifierTypes(name, null, null, null);
		if (!types.isEmpty()) {
			return types.get(0);
		}
		return null;
	}
	@Override
	public PatientIdentifierType retirePatientIdentifierType(PatientIdentifierType patientIdentifierType, String reason)
	        throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		if (reason == null || reason.length() < 1) {
			throw new APIException("Patient.identifier.retire.reason", (Object[]) null);
		}
		patientIdentifierType.setRetired(true);
		patientIdentifierType.setRetiredBy(Context.getAuthenticatedUser());
		patientIdentifierType.setDateRetired(new Date());
		patientIdentifierType.setRetireReason(reason);
		return Context.getPatientService().savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	public PatientIdentifierType unretirePatientIdentifierType(PatientIdentifierType patientIdentifierType)
	        throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		patientIdentifierType.setRetired(false);
		patientIdentifierType.setRetiredBy(null);
		patientIdentifierType.setDateRetired(null);
		patientIdentifierType.setRetireReason(null);
		return Context.getPatientService().savePatientIdentifierType(patientIdentifierType);
	}
	@Override
	public void purgePatientIdentifierType(PatientIdentifierType patientIdentifierType) throws APIException {
		checkIfPatientIdentifierTypesAreLocked();
		dao.deletePatientIdentifierType(patientIdentifierType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query) throws APIException {
		return Context.getPatientService().getPatients(query, 0, null);
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientByExample(Patient patientToMatch) throws APIException {
		if (patientToMatch == null || patientToMatch.getPatientId() == null) {
			return null;
		}
		return Context.getPatientService().getPatient(patientToMatch.getPatientId());
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getDuplicatePatientsByAttributes(List<String> attributes) throws APIException {
		if (attributes == null || attributes.isEmpty()) {
			throw new APIException("Patient.no.attribute", (Object[]) null);
		}
		return dao.getDuplicatePatientsByAttributes(attributes);
	}
	private String relationshipHash(Relationship rel, Person primary) {
		boolean isA = rel.getPersonA().equals(primary);
		return rel.getRelationshipType().getRelationshipTypeId().toString() + (isA ? "A" : "B")
		        + (isA ? rel.getPersonB().getPersonId().toString() : rel.getPersonA().getPersonId().toString());
	}
	@Override
	public void mergePatients(Patient preferred, Patient notPreferred) throws APIException, SerializationException {
		log.debug("Merging patients: (preferred)" + preferred.getPatientId() + ", (notPreferred) "
		        + notPreferred.getPatientId());
		if (preferred.getPatientId().equals(notPreferred.getPatientId())) {
			log.debug("Merge operation cancelled: Cannot merge user" + preferred.getPatientId() + " to self");
			throw new APIException("Patient.merge.cancelled", new Object[] { preferred.getPatientId() });
		}
		requireNoActiveOrderOfSameType(preferred,notPreferred);
		PersonMergeLogData mergedData = new PersonMergeLogData();
		mergeVisits(preferred, notPreferred, mergedData);
		mergeEncounters(preferred, notPreferred, mergedData);
		mergeProgramEnrolments(preferred, notPreferred, mergedData);
		mergeRelationships(preferred, notPreferred, mergedData);
		mergeObservationsNotContainedInEncounters(preferred, notPreferred, mergedData);
		mergeIdentifiers(preferred, notPreferred, mergedData);
		mergeNames(preferred, notPreferred, mergedData);
		mergeAddresses(preferred, notPreferred, mergedData);
		mergePersonAttributes(preferred, notPreferred, mergedData);
		mergeGenderInformation(preferred, notPreferred, mergedData);
		mergeDateOfBirth(preferred, notPreferred, mergedData);
		mergeDateOfDeath(preferred, notPreferred, mergedData);
		Context.getPatientService().voidPatient(notPreferred, "Merged with patient #" + preferred.getPatientId());
		Context.getPersonService().voidPerson(notPreferred,
		    "The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
		changeUserAssociations(preferred, notPreferred, mergedData);
		savePatient(preferred);
		PersonMergeLog personMergeLog = new PersonMergeLog();
		personMergeLog.setWinner(preferred);
		personMergeLog.setLoser(notPreferred);
		personMergeLog.setPersonMergeLogData(mergedData);
		Context.getPersonService().savePersonMergeLog(personMergeLog);
	}
	private void requireNoActiveOrderOfSameType(Patient patient1, Patient patient2) {
		String messageKey = "Patient.merge.cannotHaveSameTypeActiveOrders";
		List<Order> ordersByPatient1 = Context.getOrderService().getAllOrdersByPatient(patient1);
		List<Order> ordersByPatient2 = Context.getOrderService().getAllOrdersByPatient(patient2);
		ordersByPatient1.forEach((Order order1) -> ordersByPatient2.forEach((Order order2) -> {
			if (order1.isActive() && order2.isActive() && order1.getOrderType().equals(order2.getOrderType())) {
				Object[] parameters = { patient1.getPatientId(), patient2.getPatientId(), order1.getOrderType() };
				String message = Context.getMessageSourceService().getMessage(messageKey, parameters,
						Context.getLocale());
				log.debug(message);
				throw new APIException(message);
			}
		}));
	}
	private void mergeProgramEnrolments(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		ProgramWorkflowService programService = Context.getProgramWorkflowService();
		for (PatientProgram pp : programService.getPatientPrograms(notPreferred, null, null, null, null, null, false)) {
			if (!pp.getVoided()) {
				pp.setPatient(preferred);
				log.debug("Moving patientProgram {} to {}", pp.getPatientProgramId(), preferred.getPatientId());
				PatientProgram persisted = programService.savePatientProgram(pp);
				mergedData.addMovedProgram(persisted.getUuid());
			}
		}
	}
	private void mergeVisits(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		VisitService visitService = Context.getVisitService();
		for (Visit visit : visitService.getVisitsByPatient(notPreferred, true, true)) {
			log.debug("Merging visit {} to {}", visit.getVisitId(), preferred.getPatientId());
			visit.setPatient(preferred);
			Visit persisted = visitService.saveVisit(visit);
			mergedData.addMovedVisit(persisted.getUuid());
		}
	}
	private void mergeEncounters(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		EncounterService es = Context.getEncounterService();
		EncounterSearchCriteria notPreferredPatientEncounterSearchCriteria = new EncounterSearchCriteriaBuilder()
				.setIncludeVoided(true)
				.setPatient(notPreferred)
				.createEncounterSearchCriteria();
		for (Encounter e : es.getEncounters(notPreferredPatientEncounterSearchCriteria)) {
			e.setPatient(preferred);
			log.debug("Merging encounter " + e.getEncounterId() + " to " + preferred.getPatientId());
			Encounter persisted = es.saveEncounter(e);
			mergedData.addMovedEncounter(persisted.getUuid());
		}
	}
	private void mergeRelationships(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		PersonService personService = Context.getPersonService();
		Set<String> existingRelationships = new HashSet<>();
		for (Relationship rel : personService.getRelationshipsByPerson(preferred)) {
			existingRelationships.add(relationshipHash(rel, preferred));
		}
		for (Relationship rel : personService.getRelationshipsByPerson(notPreferred)) {
			if (!rel.getVoided()) {
				boolean personAisPreferred = rel.getPersonA().equals(preferred);
				boolean personAisNotPreferred = rel.getPersonA().equals(notPreferred);
				boolean personBisPreferred = rel.getPersonB().equals(preferred);
				boolean personBisNotPreferred = rel.getPersonB().equals(notPreferred);
				String relHash = relationshipHash(rel, notPreferred);
				if ((personAisPreferred && personBisNotPreferred) || (personBisPreferred && personAisNotPreferred)) {
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged to person " + (personAisPreferred ? "A" : "B"));
				} else if (existingRelationships.contains(relHash)) {
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged and a relationship already exists");
				} else {
					Relationship tmpRel = rel.copy();
					if (personAisNotPreferred) {
						tmpRel.setPersonA(preferred);
					}
					if (personBisNotPreferred) {
						tmpRel.setPersonB(preferred);
					}
					log.debug("Copying relationship " + rel.getRelationshipId() + " to " + preferred.getPatientId());
					Relationship persisted = personService.saveRelationship(tmpRel);
					mergedData.addCreatedRelationship(persisted.getUuid());
					personService.voidRelationship(rel, "person " + (personAisNotPreferred ? "A" : "B")
					        + " was merged, relationship copied to #" + tmpRel.getRelationshipId());
					existingRelationships.add(relHash);
				}
				mergedData.addVoidedRelationship(rel.getUuid());
			}
		}
	}
	private void mergeObservationsNotContainedInEncounters(Patient preferred, Patient notPreferred,
	        PersonMergeLogData mergedData) {
		ObsService obsService = Context.getObsService();
		for (Obs obs : obsService.getObservationsByPerson(notPreferred)) {
			if (obs.getEncounter() == null && !obs.getVoided()) {
				obs.setPerson(preferred);
				Obs persisted = obsService.saveObs(obs, "Merged from patient #" + notPreferred.getPatientId());
				mergedData.addMovedIndependentObservation(persisted.getUuid());
			}
		}
	}
	private void mergeIdentifiers(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PatientIdentifier pi : notPreferred.getActiveIdentifiers()) {
			PatientIdentifier tmpIdentifier = new PatientIdentifier();
			tmpIdentifier.setIdentifier(pi.getIdentifier());
			tmpIdentifier.setIdentifierType(pi.getIdentifierType());
			tmpIdentifier.setLocation(pi.getLocation());
			tmpIdentifier.setPatient(preferred);
			boolean found = false;
			for (PatientIdentifier preferredIdentifier : preferred.getIdentifiers()) {
				if (preferredIdentifier.getIdentifier() != null
				        && preferredIdentifier.getIdentifier().equals(tmpIdentifier.getIdentifier())
				        && preferredIdentifier.getIdentifierType() != null
				        && preferredIdentifier.getIdentifierType().equals(tmpIdentifier.getIdentifierType())) {
					found = true;
				}
			}
			if (!found) {
				tmpIdentifier.setIdentifierType(pi.getIdentifierType());
				tmpIdentifier.setCreator(Context.getAuthenticatedUser());
				tmpIdentifier.setDateCreated(new Date());
				tmpIdentifier.setVoided(false);
				tmpIdentifier.setVoidedBy(null);
				tmpIdentifier.setVoidReason(null);
				tmpIdentifier.setUuid(UUID.randomUUID().toString());
				tmpIdentifier.setPreferred(false);
				preferred.addIdentifier(tmpIdentifier);
				mergedData.addCreatedIdentifier(tmpIdentifier.getUuid());
				log.debug("Merging identifier " + tmpIdentifier.getIdentifier() + " to " + preferred.getPatientId());
			}
		}
	}
	private void mergeDateOfDeath(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorDateOfDeath(preferred.getDeathDate());
		if (preferred.getDeathDate() == null) {
			preferred.setDeathDate(notPreferred.getDeathDate());
		}
		if (preferred.getCauseOfDeath() != null) {
			mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
		}
		if (preferred.getCauseOfDeath() == null) {
			preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
		}
	}
	private void mergeDateOfBirth(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorDateOfBirth(preferred.getBirthdate());
		mergedData.setPriorDateOfBirthEstimated(preferred.getBirthdateEstimated());
		if (preferred.getBirthdate() == null || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
			preferred.setBirthdate(notPreferred.getBirthdate());
			preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
		}
	}
	private void mergePersonAttributes(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PersonAttribute attr : notPreferred.getAttributes()) {
			if (!attr.getVoided()) {
				PersonAttribute tmpAttr = attr.copy();
				tmpAttr.setPerson(null);
				tmpAttr.setUuid(UUID.randomUUID().toString());
				preferred.addAttribute(tmpAttr);
				mergedData.addCreatedAttribute(tmpAttr.getUuid());
			}
		}
	}
	private void mergeGenderInformation(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		mergedData.setPriorGender(preferred.getGender());
		if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender())) {
			preferred.setGender(notPreferred.getGender());
		}
	}
	private void mergeNames(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData) {
		for (PersonName newName : notPreferred.getNames()) {
			boolean containsName = false;
			for (PersonName currentName : preferred.getNames()) {
				containsName = currentName.equalsContent(newName);
				if (containsName) {
					break;
				}
			}
			if (!containsName) {
				PersonName tmpName = constructTemporaryName(newName);
				preferred.addName(tmpName);
				mergedData.addCreatedName(tmpName.getUuid());
				log.debug("Merging name " + newName.getGivenName() + " to " + preferred.getPatientId());
			}
		}
	}
	private PersonName constructTemporaryName(PersonName newName) {
		PersonName tmpName = PersonName.newInstance(newName);
		tmpName.setPersonNameId(null);
		tmpName.setVoided(false);
		tmpName.setVoidedBy(null);
		tmpName.setVoidReason(null);
		tmpName.setPreferred(false);
		tmpName.setUuid(UUID.randomUUID().toString());
		return tmpName;
	}
	private void mergeAddresses(Patient preferred, Patient notPreferred, PersonMergeLogData mergedData)
	        throws SerializationException {
		for (PersonAddress newAddress : notPreferred.getAddresses()) {
			boolean containsAddress = false;
			for (PersonAddress currentAddress : preferred.getAddresses()) {
				containsAddress = currentAddress.equalsContent(newAddress);
				if (containsAddress) {
					break;
				}
			}
			if (!containsAddress) {
				PersonAddress tmpAddress = (PersonAddress) newAddress.clone();
				tmpAddress.setPersonAddressId(null);
				tmpAddress.setVoided(false);
				tmpAddress.setVoidedBy(null);
				tmpAddress.setVoidReason(null);
				tmpAddress.setPreferred(false); 
				tmpAddress.setUuid(UUID.randomUUID().toString());
				preferred.addAddress(tmpAddress);
				mergedData.addCreatedAddress(tmpAddress.getUuid());
				log.debug("Merging address " + newAddress.getPersonAddressId() + " to " + preferred.getPatientId());
			}
		}
		for (PersonAttribute attr : notPreferred.getAttributes()) {
			if (!attr.getVoided()) {
				PersonAttribute tmpAttr = attr.copy();
				tmpAttr.setPerson(null);
				tmpAttr.setUuid(UUID.randomUUID().toString());
				preferred.addAttribute(tmpAttr);
				mergedData.addCreatedAttribute(tmpAttr.getUuid());
			}
		}
		mergedData.setPriorGender(preferred.getGender());
		if (!"M".equals(preferred.getGender()) && !"F".equals(preferred.getGender())) {
			preferred.setGender(notPreferred.getGender());
		}
		mergedData.setPriorDateOfBirth(preferred.getBirthdate());
		mergedData.setPriorDateOfBirthEstimated(preferred.getBirthdateEstimated());
		if (preferred.getBirthdate() == null || (preferred.getBirthdateEstimated() && !notPreferred.getBirthdateEstimated())) {
			preferred.setBirthdate(notPreferred.getBirthdate());
			preferred.setBirthdateEstimated(notPreferred.getBirthdateEstimated());
		}
		mergedData.setPriorDateOfDeathEstimated(preferred.getDeathdateEstimated());
		if (preferred.getDeathdateEstimated() == null) {
			preferred.setDeathdateEstimated(notPreferred.getDeathdateEstimated());
		}
		mergedData.setPriorDateOfDeath(preferred.getDeathDate());
		if (preferred.getDeathDate() == null) {
			preferred.setDeathDate(notPreferred.getDeathDate());
		}
		if (preferred.getCauseOfDeath() != null) {
			mergedData.setPriorCauseOfDeath(preferred.getCauseOfDeath().getUuid());
		}
		if (preferred.getCauseOfDeath() == null) {
			preferred.setCauseOfDeath(notPreferred.getCauseOfDeath());
		}
		Context.getPatientService().voidPatient(notPreferred, "Merged with patient #" + preferred.getPatientId());
		Context.getPersonService().voidPerson(notPreferred,
		    "The patient corresponding to this person has been voided and Merged with patient #" + preferred.getPatientId());
		changeUserAssociations(preferred, notPreferred, mergedData);
		savePatient(preferred);
		PersonMergeLog personMergeLog = new PersonMergeLog();
		personMergeLog.setWinner(preferred);
		personMergeLog.setLoser(notPreferred);
		personMergeLog.setPersonMergeLogData(mergedData);
		Context.getPersonService().savePersonMergeLog(personMergeLog);
	}
	private void changeUserAssociations(Patient preferred, Person notPreferred, PersonMergeLogData mergedData) {
		UserService userService = Context.getUserService();
		List<User> users = userService.getUsersByPerson(notPreferred, true);
		for (User user : users) {
			user.setPerson(preferred);
			User persisted = userService.saveUser(user);
			if (mergedData != null) {
				mergedData.addMovedUser(persisted.getUuid());
			}
		}
	}
	public void exitFromCare(Patient patient, Date dateExited, Concept reasonForExit) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.invalid.care", (Object[]) null);
		}
		if (dateExited == null) {
			throw new APIException("Patient.no.valid.dateExited", (Object[]) null);
		}
		if (reasonForExit == null) {
			throw new APIException("Patient.no.valid.reasonForExit", (Object[]) null);
		}
		saveReasonForExitObs(patient, dateExited, reasonForExit);
	}
	private void saveReasonForExitObs(Patient patient, Date exitDate, Concept cause) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.null", (Object[]) null);
		}
		if (exitDate == null) {
			throw new APIException("Patient.exit.date.null", (Object[]) null);
		}
		if (cause == null) {
			throw new APIException("Patient.cause.null", (Object[]) null);
		}
		log.debug("Patient is exiting, so let's make sure there's an Obs for it");
		String codProp = Context.getAdministrationService().getGlobalProperty("concept.reasonExitedCare");
		Concept reasonForExit = Context.getConceptService().getConcept(codProp);
		if (reasonForExit != null) {
			List<Obs> obssExit = Context.getObsService().getObservationsByPersonAndConcept(patient, reasonForExit);
			if (obssExit != null) {
				if (obssExit.size() > 1) {
					log.error("Multiple reasons for exit (" + obssExit.size() + ")?  Shouldn't be...");
				} else {
					Obs obsExit;
					if (obssExit.size() == 1) {
						log.debug("Already has a reason for exit, so changing it");
						obsExit = obssExit.iterator().next();
					} else {
						log.debug("No reason for exit yet, let's create one.");
						obsExit = new Obs();
						obsExit.setPerson(patient);
						obsExit.setConcept(reasonForExit);
						Location loc = Context.getLocationService().getDefaultLocation();
						if (loc != null) {
							obsExit.setLocation(loc);
						} else {
							log.error("Could not find a suitable location for which to create this new Obs");
						}
					}
					if (obsExit != null) {
						obsExit.setValueCoded(cause);
						obsExit.setValueCodedName(cause.getName()); 
						obsExit.setObsDatetime(exitDate);
						Context.getObsService().saveObs(obsExit, "updated by PatientService.saveReasonForExit");
					}
				}
			}
		} else {
			log.debug("Reason for exit is null - should not have gotten here without throwing an error on the form.");
		}
	}
	@Override
	public void processDeath(Patient patient, Date dateDied, Concept causeOfDeath, String otherReason) throws APIException {
		if (patient != null && dateDied != null && causeOfDeath != null) {
			patient.setDead(true);
			patient.setDeathDate(dateDied);
			patient.setCauseOfDeath(causeOfDeath);
			this.savePatient(patient);
			saveCauseOfDeathObs(patient, dateDied, causeOfDeath, otherReason);
			String strPatientDied = Context.getAdministrationService().getGlobalProperty("concept.patientDied");
			Concept conceptPatientDied = Context.getConceptService().getConcept(strPatientDied);
			if (conceptPatientDied == null) {
				log.debug("ConceptPatientDied is null");
			}
			exitFromCare(patient, dateDied, conceptPatientDied);
		} else {
			if (patient == null) {
				throw new APIException("Patient.invalid.dead", (Object[]) null);
			}
			if (dateDied == null) {
				throw new APIException("Patient.no.valid.dateDied", (Object[]) null);
			}
			if (causeOfDeath == null) {
				throw new APIException("Patient.no.valid.causeOfDeath", (Object[]) null);
			}
		}
	}
	@Override
	public void saveCauseOfDeathObs(Patient patient, Date deathDate, Concept cause, String otherReason) throws APIException {
		if (patient == null) {
			throw new APIException("Patient.null", (Object[]) null);
		}
		if (deathDate == null) {
			throw new APIException("Patient.death.date.null", (Object[]) null);
		}
		if (cause == null) {
			throw new APIException("Patient.cause.null", (Object[]) null);
		}
		if (!patient.getDead()) {
			patient.setDead(true);
			patient.setDeathDate(deathDate);
			patient.setCauseOfDeath(cause);
		}
		log.debug("Patient is dead, so let's make sure there's an Obs for it");
		String codProp = Context.getAdministrationService().getGlobalProperty("concept.causeOfDeath");
		Concept causeOfDeath = Context.getConceptService().getConcept(codProp);
		if (causeOfDeath != null) {
			List<Obs> obssDeath = Context.getObsService().getObservationsByPersonAndConcept(patient, causeOfDeath);
			if (obssDeath != null) {
				if (obssDeath.size() > 1) {
					log.error("Multiple causes of death (" + obssDeath.size() + ")?  Shouldn't be...");
				} else {
					Obs obsDeath;
					if (obssDeath.size() == 1) {
						log.debug("Already has a cause of death, so changing it");
						obsDeath = obssDeath.iterator().next();
					} else {
						log.debug("No cause of death yet, let's create one.");
						obsDeath = new Obs();
						obsDeath.setPerson(patient);
						obsDeath.setConcept(causeOfDeath);
						Location location = Context.getLocationService().getDefaultLocation();
						if (location != null) {
							obsDeath.setLocation(location);
						} else {
							log.error("Could not find a suitable location for which to create this new Obs");
						}
					}
					Concept currCause = patient.getCauseOfDeath();
					if (currCause == null) {
						log.debug("Current cause is null, attempting to set to NONE");
						String noneConcept = Context.getAdministrationService().getGlobalProperty("concept.none");
						currCause = Context.getConceptService().getConcept(noneConcept);
					}
					if (currCause != null) {
						log.debug("Current cause is not null, setting to value_coded");
						obsDeath.setValueCoded(currCause);
						obsDeath.setValueCodedName(currCause.getName()); 
						Date dateDeath = patient.getDeathDate();
						if (dateDeath == null) {
							dateDeath = new Date();
						}
						obsDeath.setObsDatetime(dateDeath);
						String otherConcept = Context.getAdministrationService().getGlobalProperty("concept.otherNonCoded");
						Concept conceptOther = Context.getConceptService().getConcept(otherConcept);
						if (conceptOther != null) {
							if (conceptOther.equals(currCause)) {
								log.debug("Setting value_text as " + otherReason);
								obsDeath.setValueText(otherReason);
							} else {
								log.debug("New concept is NOT the OTHER concept, so setting to blank");
								obsDeath.setValueText("");
							}
						} else {
							log.debug("Don't seem to know about an OTHER concept, so deleting value_text");
							obsDeath.setValueText("");
						}
						Context.getObsService().saveObs(obsDeath, "updated by PatientService.saveCauseOfDeathObs");
					} else {
						log.debug("Current cause is still null - aborting mission");
					}
				}
			}
		} else {
			log.debug("Cause of death is null - should not have gotten here without throwing an error on the form.");
		}
	}
	@Override
	@Transactional(readOnly = true)
	public Patient getPatientByUuid(String uuid) throws APIException {
		return dao.getPatientByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifier getPatientIdentifierByUuid(String uuid) throws APIException {
		return dao.getPatientIdentifierByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifierType getPatientIdentifierTypeByUuid(String uuid) throws APIException {
		return dao.getPatientIdentifierTypeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public IdentifierValidator getDefaultIdentifierValidator() {
		String defaultPIV = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR, "");
		try {
			return identifierValidators.get(Class.forName(defaultPIV));
		}
		catch (ClassNotFoundException e) {
			log.error("Global Property " + OpenmrsConstants.GLOBAL_PROPERTY_DEFAULT_PATIENT_IDENTIFIER_VALIDATOR
			        + " not set to an actual class.", e);
			return identifierValidators.get(LuhnIdentifierValidator.class);
		}
	}
	@Override
	public IdentifierValidator getIdentifierValidator(Class<IdentifierValidator> identifierValidator) {
		return identifierValidators.get(identifierValidator);
	}
	public Map<Class<? extends IdentifierValidator>, IdentifierValidator> getIdentifierValidators() {
		if (identifierValidators == null) {
			identifierValidators = new LinkedHashMap<>();
		}
		return identifierValidators;
	}
	public void setIdentifierValidators(Map<Class<? extends IdentifierValidator>, IdentifierValidator> identifierValidators) {
		if (identifierValidators == null) {
			PatientServiceImpl.setStaticIdentifierValidators(null);
			return;
		}
		for (Map.Entry<Class<? extends IdentifierValidator>, IdentifierValidator> entry : identifierValidators.entrySet()) {
			getIdentifierValidators().put(entry.getKey(), entry.getValue());
		}
	}
	private static void setStaticIdentifierValidators(
	        Map<Class<? extends IdentifierValidator>, IdentifierValidator> currentIdentifierValidators) {
		PatientServiceImpl.identifierValidators = currentIdentifierValidators;
	}
	@Override
	public Collection<IdentifierValidator> getAllIdentifierValidators() {
		return identifierValidators.values();
	}
	@Override
	@SuppressWarnings("unchecked")
	@Transactional(readOnly = true)
	public IdentifierValidator getIdentifierValidator(String pivClassName) {
		if (StringUtils.isBlank(pivClassName)) {
			return null;
		}
		try {
			return getIdentifierValidator((Class<IdentifierValidator>) Context.loadClass(pivClassName));
		}
		catch (ClassNotFoundException e) {
			throw new PatientIdentifierException("Could not find patient identifier validator " + pivClassName, e);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier) {
		return dao.isIdentifierInUseByAnotherPatient(patientIdentifier);
	}
	@Override
	@Transactional(readOnly = true)
	public PatientIdentifier getPatientIdentifier(Integer patientIdentifierId) throws APIException {
		return dao.getPatientIdentifier(patientIdentifierId);
	}
	@Override
	public PatientIdentifier voidPatientIdentifier(PatientIdentifier patientIdentifier, String reason) throws APIException {
		if (patientIdentifier == null || StringUtils.isBlank(reason)) {
			throw new APIException("Patient.identifier.cannot.be.null", (Object[]) null);
		}
		return Context.getPatientService().savePatientIdentifier(patientIdentifier);
	}
	@Override
	public void mergePatients(Patient preferred, List<Patient> notPreferred) throws APIException, SerializationException {
		for (Patient nonPreferred : notPreferred) {
			mergePatients(preferred, nonPreferred);
		}
	}
	@Override
	public PatientIdentifier savePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException {
		PatientIdentifierType.LocationBehavior locationBehavior = null;
		if (patientIdentifier != null) {
			locationBehavior = patientIdentifier.getIdentifierType().getLocationBehavior();
		}
		if (patientIdentifier == null
		        || patientIdentifier.getPatient() == null
		        || patientIdentifier.getIdentifierType() == null
		        || StringUtils.isBlank(patientIdentifier.getIdentifier())
		        || (locationBehavior == PatientIdentifierType.LocationBehavior.REQUIRED && patientIdentifier.getLocation() == null)) {
			throw new APIException("Patient.identifier.null", (Object[]) null);
		}
		if (patientIdentifier.getPatientIdentifierId() == null) {
			Context.requirePrivilege(PrivilegeConstants.ADD_PATIENT_IDENTIFIERS);
		} else {
			Context.requirePrivilege(PrivilegeConstants.EDIT_PATIENT_IDENTIFIERS);
		}
		return dao.savePatientIdentifier(patientIdentifier);
	}
	@Override
	public void purgePatientIdentifier(PatientIdentifier patientIdentifier) throws APIException {
		dao.deletePatientIdentifier(patientIdentifier);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergies getAllergies(Patient patient) {
		if (patient == null) {
			throw new IllegalArgumentException("An existing (NOT NULL) patient is required to get allergies");
		}
		Allergies allergies = new Allergies();
		List<Allergy> allergyList = dao.getAllergies(patient);
		if (!allergyList.isEmpty()) {
			allergies.addAll(allergyList);
		} else {
			String status = dao.getAllergyStatus(patient);
			if (Allergies.NO_KNOWN_ALLERGIES.equals(status)) {
				allergies.confirmNoKnownAllergies();
			}
		}
		return allergies;
	}
	@Override
	public Allergies setAllergies(Patient patient, Allergies allergies) {
		List<Allergy> dbAllergyList = getAllergies(patient);
		for (Allergy originalAllergy : dbAllergyList) {
			if (allergies.contains(originalAllergy)) {
				Allergy potentiallyEditedAllergy = allergies.getAllergy(originalAllergy.getAllergyId());
				if (!potentiallyEditedAllergy.hasSameValues(originalAllergy)) {
					Allergy newAllergy = new Allergy();
					try {
						allergies.remove(potentiallyEditedAllergy);
						newAllergy.copy(potentiallyEditedAllergy);
						allergies.add(newAllergy);
						voidAllergy(originalAllergy);
					}
					catch (Exception ex) {
						throw new APIException("Failed to copy edited values", ex);
					}
				}
				continue;
			}
			voidAllergy(originalAllergy);
		}
		for (Allergy allergy : allergies) {
			if (allergy.getAllergyId() == null && allergy.getAllergen().getCodedAllergen() == null
			        && StringUtils.isNotBlank(allergy.getAllergen().getNonCodedAllergen())) {
				Concept otherNonCoded = Context.getConceptService().getConceptByUuid(Allergen.getOtherNonCodedConceptUuid());
				if (otherNonCoded == null) {
					throw new APIException("Can't find concept with uuid:" + Allergen.getOtherNonCodedConceptUuid());
				}
				allergy.getAllergen().setCodedAllergen(otherNonCoded);
			}
		}
		return dao.saveAllergies(patient, allergies);
	}
	private void voidAllergy(Allergy allergy) {
		allergy.setVoided(true);
		allergy.setVoidedBy(Context.getAuthenticatedUser());
		allergy.setDateVoided(new Date());
		allergy.setVoidReason("Voided by API");
		dao.saveAllergy(allergy);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergy getAllergy(Integer allergyId) throws APIException {
		return dao.getAllergy(allergyId);
	}
	@Override
	@Transactional(readOnly = true)
	public Allergy getAllergyByUuid(String uuid) throws APIException {
		return dao.getAllergyByUuid(uuid);
	}
	@Override
	public void saveAllergy(Allergy allergy) throws APIException {
		dao.saveAllergy(allergy);
	}
	@Override
	public void removeAllergy(Allergy allergy, String reason) throws APIException {
		voidAllergy(allergy, reason);
	}
	@Override
	public void voidAllergy(Allergy allergy, String reason) throws APIException {
		allergy.setVoided(true);
		allergy.setVoidedBy(Context.getAuthenticatedUser());
		allergy.setDateVoided(new Date());
		allergy.setVoidReason(reason);
		dao.saveAllergy(allergy);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfPatients(String query) {
		int count = 0;
		if (StringUtils.isBlank(query)) {
			return count;
		}
		return OpenmrsUtil.convertToInteger(dao.getCountOfPatients(query));
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfPatients(String query, boolean includeVoided) {
		int count = 0;
		if (StringUtils.isBlank(query)) {
			return count;
		}
		return OpenmrsUtil.convertToInteger(dao.getCountOfPatients(query, includeVoided));
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query, Integer start, Integer length) throws APIException {
		List<Patient> patients = new ArrayList<>();
		if (StringUtils.isBlank(query)) {
			return patients;
		}
		return dao.getPatients(query, start, length);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String query, boolean includeVoided, Integer start, Integer length) throws APIException {
		if (StringUtils.isBlank(query)) {
			return Collections.emptyList();
		}
		return dao.getPatients(query, includeVoided, start, length);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Patient> getPatients(String name, String identifier, List<PatientIdentifierType> identifierTypes,
	        boolean matchIdentifierExactly, Integer start, Integer length) throws APIException {
		if(identifierTypes == null) {
			return dao.getPatients(name != null ? name : identifier, start, length);
		}
		else {
			return dao.getPatients(name != null ? name : identifier, identifierTypes, matchIdentifierExactly, start, length);
		}
	}
	@Override
	public void checkIfPatientIdentifierTypesAreLocked() {
		String locked = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_PATIENT_IDENTIFIER_TYPES_LOCKED, "false");
		if ("true".equalsIgnoreCase(locked)) {
			throw new PatientIdentifierTypeLockedException();
		}
	}
	public List<PatientIdentifier> getPatientIdentifiersByPatientProgram(PatientProgram patientProgram) {
		return dao.getPatientIdentifierByProgram(patientProgram);
	}
}
package org.openmrs.obs.handler;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import org.openmrs.Obs;
import org.openmrs.api.APIException;
import org.openmrs.obs.ComplexData;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.Assert;
public class BinaryStreamHandler extends AbstractHandler implements ComplexObsHandler {
	private static final String[] supportedViews = { ComplexObsHandler.RAW_VIEW, };
	private static final Logger log = LoggerFactory.getLogger(BinaryStreamHandler.class);
	public BinaryStreamHandler() {
		super();
	}
	@Override
	public Obs getObs(Obs obs, String view) {
		ComplexData complexData = null;
		File file = null;
		if (ComplexObsHandler.RAW_VIEW.equals(view)) {
			try {
				file = getComplexDataFile(obs);
				String[] names = obs.getValueComplex().split("\\|");
				String originalFilename = names[0];
				originalFilename = originalFilename.replace(",", "").replace(" ", "");
				if (file.exists()) {
					FileInputStream fileInputStream = new FileInputStream(file);
					complexData = new ComplexData(originalFilename, fileInputStream);
				} else {
					log.error("Unable to find file associated with complex obs " + obs.getId());
				}
			}
			catch (Exception e) {
				throw new APIException("Obs.error.while.trying.get.binary.complex", null, e);
			}
		} else {
			return null;
		}
		Assert.notNull(complexData, "Complex data must not be null");
		String mimeType = OpenmrsUtil.getFileMimeType(file);
		complexData.setMimeType(mimeType);
		obs.setComplexData(complexData);
		return obs;
	}
	@Override
	public String[] getSupportedViews() {
		return supportedViews;
	}
	@Override
	public Obs saveObs(Obs obs) throws APIException {
		try {
			String fileName = obs.getComplexData().getTitle();
			InputStream in = (InputStream) obs.getComplexData().getData();
			File outfile = getOutputFileToWrite(obs);
			OutputStream out = new FileOutputStream(outfile, false);
			OpenmrsUtil.copyFile(in, out);
			obs.setComplexData(null);
			obs.setValueComplex(fileName + "|" + outfile.getName());
			out.close();
		}
		catch (Exception e) {
			throw new APIException("Obs.error.writing.binary.data.complex", null, e);
		}
		return obs;
	}
}
package org.openmrs.obs.handler;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import org.openmrs.Obs;
import org.openmrs.api.APIException;
import org.openmrs.obs.ComplexData;
import org.openmrs.obs.ComplexObsHandler;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class MediaHandler extends AbstractHandler implements ComplexObsHandler {
	private static final String[] supportedViews = { ComplexObsHandler.RAW_VIEW, };
	private static final Logger log = LoggerFactory.getLogger(MediaHandler.class);
	public MediaHandler() {
		super();
	}
	@Override
	public Obs getObs(Obs obs, String view) {
		File file = getComplexDataFile(obs);
		if (ComplexObsHandler.RAW_VIEW.equals(view)) {
			try {
				String[] names = obs.getValueComplex().split("\\|");
				String originalFilename = names[0];
				originalFilename = originalFilename.replace(",", "").replace(" ", "");
				FileInputStream mediaStream = new FileInputStream(file);
				ComplexData complexData = new ComplexData(originalFilename, mediaStream);
				String mimeType = OpenmrsUtil.getFileMimeType(file);
				complexData.setMimeType(mimeType);
				complexData.setLength(file.length());
				obs.setComplexData(complexData);
			}
			catch (FileNotFoundException e) {
				log.error("Trying to create media file stream from " + file.getAbsolutePath(), e);
			}
		}
		else {
			return null;
		}
		return obs;
	}
	@Override
	public String[] getSupportedViews() {
		return supportedViews;
	}
	@Override
	public Obs saveObs(Obs obs) throws APIException {
		try {
			String fileName = obs.getComplexData().getTitle();
			File outfile = getOutputFileToWrite(obs);
			OutputStream out = new FileOutputStream(outfile, false);
			FileInputStream mediaStream = (FileInputStream) obs.getComplexData().getData();
			OpenmrsUtil.copyFile(mediaStream, out);
			obs.setComplexData(null);
			obs.setValueComplex(fileName + "|" + outfile.getName());
			out.close();
		}
		catch (IOException ioe) {
			throw new APIException("Obs.error.trying.write.complex", null, ioe);
		}
		return obs;
	}
}
package org.openmrs.api.db.hibernate;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import javax.persistence.TypedQuery;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.Order;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.criteria.Subquery;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.hibernate.FlushMode;
import org.hibernate.SQLQuery;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.openmrs.Concept;
import org.openmrs.ConceptName;
import org.openmrs.Encounter;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.ObsReferenceRange;
import org.openmrs.Patient;
import org.openmrs.Person;
import org.openmrs.User;
import org.openmrs.Visit;
import org.openmrs.api.db.DAOException;
import org.openmrs.api.db.ObsDAO;
import org.openmrs.util.OpenmrsConstants.PERSON_TYPE;
public class HibernateObsDAO implements ObsDAO {
	protected SessionFactory sessionFactory;
	public void setSessionFactory(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}
	@Override
	public void deleteObs(Obs obs) throws DAOException {
		sessionFactory.getCurrentSession().delete(obs);
	}
	@Override
	public Obs getObs(Integer obsId) throws DAOException {
		return (Obs) sessionFactory.getCurrentSession().get(Obs.class, obsId);
	}
	@Override
	public Obs saveObs(Obs obs) throws DAOException {
		if (obs.hasGroupMembers() && obs.getObsId() != null) {
			for (Obs member : obs.getGroupMembers()) {
				if (member.getObsId() == null) {
					saveObs(member);
				}
			}
		}
		sessionFactory.getCurrentSession().saveOrUpdate(obs);
		return obs;
	}
	@Override
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<String> sortList,
	        Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs,
	        String accessionNumber) throws DAOException {
		return this.getObservations(whom, encounters, questions, answers, personTypes, locations, sortList, null, mostRecentN, obsGroupId, 
				fromDate, toDate, includeVoidedObs, accessionNumber);
	}
	@Override
	public List<Obs> getObservations(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, List<String> sortList, List<Visit> visits,
	        Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs,
	        String accessionNumber) throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Obs> cq = cb.createQuery(Obs.class);
		Root<Obs> root = cq.from(Obs.class);
		List<Predicate> predicates = createGetObservationsCriteria(cb, root, whom, encounters, questions, answers, personTypes, locations,
			obsGroupId, fromDate, toDate, null, visits, includeVoidedObs, accessionNumber);
		cq.where(predicates.toArray(new Predicate[]{}));
		cq.orderBy(createOrderList(cb, root, sortList));
		TypedQuery<Obs> query = session.createQuery(cq);
		if (mostRecentN != null && mostRecentN > 0) {
			query.setMaxResults(mostRecentN);
		}
		return query.getResultList();
	}
	@Override
	public Long getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, Integer obsGroupId,
	        Date fromDate, Date toDate, List<ConceptName> valueCodedNameAnswers, boolean includeVoidedObs,
	        String accessionNumber) throws DAOException {
		return this.getObservationCount(whom, encounters, questions, answers, personTypes, locations, obsGroupId, 
				fromDate, toDate, valueCodedNameAnswers, null, includeVoidedObs, accessionNumber);
	}
	@Override
	public Long getObservationCount(List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, Integer obsGroupId,
	        Date fromDate, Date toDate, List<ConceptName> valueCodedNameAnswers, List<Visit> visits, boolean includeVoidedObs,
	        String accessionNumber) throws DAOException {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Long> criteriaQuery = cb.createQuery(Long.class);
		Root<Obs> root = criteriaQuery.from(Obs.class);
		criteriaQuery.select(cb.count(root));
		List<Predicate> predicates = createGetObservationsCriteria(cb, root, whom, encounters, questions, answers,
			personTypes, locations, obsGroupId, fromDate, toDate,
			valueCodedNameAnswers, visits, includeVoidedObs, accessionNumber);
		criteriaQuery.where(predicates.toArray(new Predicate[]{}));
		return session.createQuery(criteriaQuery).getSingleResult();
	}
	private List<Predicate> createGetObservationsCriteria(CriteriaBuilder cb, Root<Obs> root, List<Person> whom, List<Encounter> encounters, List<Concept> questions,
	        List<Concept> answers, List<PERSON_TYPE> personTypes, List<Location> locations, Integer obsGroupId, Date fromDate, Date toDate, List<ConceptName> valueCodedNameAnswers,
	        List<Visit> visits, boolean includeVoidedObs, String accessionNumber) {
		List<Predicate> predicates = new ArrayList<>();
		if (CollectionUtils.isNotEmpty(whom)) {
			predicates.add(root.get("person").in(whom));
		}
		if (CollectionUtils.isNotEmpty(encounters)) {
			predicates.add(root.get("encounter").in(encounters));
		}
		if (CollectionUtils.isNotEmpty(questions)) {
			predicates.add(root.get("concept").in(questions));
		}
		if (CollectionUtils.isNotEmpty(answers)) {
			predicates.add(root.get("valueCoded").in(answers));
		}
		if (CollectionUtils.isNotEmpty(personTypes)) {
			predicates.addAll(getCriteriaPersonModifier(cb, root, personTypes));
		}
		if (CollectionUtils.isNotEmpty(locations)) {
			predicates.add(root.get("location").in(locations));
		}
		if (CollectionUtils.isNotEmpty(visits)) {
			predicates.add(root.get("encounter").get("visit").in(visits));
		}
		if (obsGroupId != null) {
			predicates.add(cb.equal(root.get("obsGroup").get("obsId"), obsGroupId));
		}
		if (fromDate != null) {
			predicates.add(cb.greaterThanOrEqualTo(root.get("obsDatetime"), fromDate));
		}
		if (toDate != null) {
			predicates.add(cb.lessThanOrEqualTo(root.get("obsDatetime"), toDate));
		}
		if (CollectionUtils.isNotEmpty(valueCodedNameAnswers)) {
			predicates.add(root.get("valueCodedName").in(valueCodedNameAnswers));
		}
		if (!includeVoidedObs) {
			predicates.add(cb.isFalse(root.get("voided")));
		}
		if (accessionNumber != null) {
			predicates.add(cb.equal(root.get("accessionNumber"), accessionNumber));
		}
		return predicates;
	}
	private List<Order> createOrderList(CriteriaBuilder cb, Root<Obs> root, List<String> sortList) {
		List<Order> orders = new ArrayList<>();
		if (CollectionUtils.isNotEmpty(sortList)) {
			for (String sort : sortList) {
				if (StringUtils.isNotEmpty(sort)) {
					String[] split = sort.split(" ", 2);
					String fieldName = split[0];
					if (split.length == 2 && "asc".equals(split[1])) {
						orders.add(cb.asc(root.get(fieldName)));
					} else {
						orders.add(cb.desc(root.get(fieldName)));
					}
				}
			}
		}
		return orders;
	}
	private List<Predicate> getCriteriaPersonModifier(CriteriaBuilder cb, Root<Obs> root, List<PERSON_TYPE> personTypes) {
		List<Predicate> predicates = new ArrayList<>();
		if (personTypes.contains(PERSON_TYPE.PATIENT)) {
			Subquery<Integer> patientSubquery = cb.createQuery().subquery(Integer.class);
			Root<Patient> patientRoot = patientSubquery.from(Patient.class);
			patientSubquery.select(patientRoot.get("patientId"));
			predicates.add(cb.in(root.get("person").get("personId")).value(patientSubquery));
		}
		if (personTypes.contains(PERSON_TYPE.USER)) {
			Subquery<Integer> userSubquery = cb.createQuery().subquery(Integer.class);
			Root<User> userRoot = userSubquery.from(User.class);
			userSubquery.select(userRoot.get("userId"));
			predicates.add(cb.in(root.get("person").get("personId")).value(userSubquery));
		}
		return predicates;
	}
	@Override
	public Obs getObsByUuid(String uuid) {
		return HibernateUtil.getUniqueEntityByUUID(sessionFactory, Obs.class, uuid);
	}
	@Override
	public Obs getRevisionObs(Obs initialObs) {
		Session session = sessionFactory.getCurrentSession();
		CriteriaBuilder cb = session.getCriteriaBuilder();
		CriteriaQuery<Obs> cq = cb.createQuery(Obs.class);
		Root<Obs> root = cq.from(Obs.class);
		cq.where(cb.equal(root.get("previousVersion"), initialObs));
		return session.createQuery(cq).uniqueResult();
	}
	@Override
	public Obs.Status getSavedStatus(Obs obs) {
		Session session = sessionFactory.getCurrentSession();
		FlushMode flushMode = session.getHibernateFlushMode();
		session.setHibernateFlushMode(FlushMode.MANUAL);
		try {
			SQLQuery sql = session.createSQLQuery("select status from obs where obs_id = :obsId");
			sql.setParameter("obsId", obs.getObsId());
			return Obs.Status.valueOf((String) sql.uniqueResult());
		}
		finally {
			session.setHibernateFlushMode(flushMode);
		}
	}
}
package org.openmrs.hl7.handler;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;
import org.openmrs.Concept;
import org.openmrs.ConceptAnswer;
import org.openmrs.ConceptName;
import org.openmrs.ConceptProposal;
import org.openmrs.Drug;
import org.openmrs.Encounter;
import org.openmrs.EncounterRole;
import org.openmrs.EncounterType;
import org.openmrs.Form;
import org.openmrs.Location;
import org.openmrs.Obs;
import org.openmrs.Patient;
import org.openmrs.Person;
import org.openmrs.PersonAttribute;
import org.openmrs.PersonAttributeType;
import org.openmrs.Provider;
import org.openmrs.Relationship;
import org.openmrs.RelationshipType;
import org.openmrs.User;
import org.openmrs.api.context.Context;
import org.openmrs.hl7.HL7Constants;
import org.openmrs.hl7.HL7InQueueProcessor;
import org.openmrs.obs.ComplexData;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;
import ca.uhn.hl7v2.HL7Exception;
import ca.uhn.hl7v2.app.Application;
import ca.uhn.hl7v2.app.ApplicationException;
import ca.uhn.hl7v2.model.DataTypeException;
import ca.uhn.hl7v2.model.Message;
import ca.uhn.hl7v2.model.Type;
import ca.uhn.hl7v2.model.Varies;
import ca.uhn.hl7v2.model.v25.datatype.CE;
import ca.uhn.hl7v2.model.v25.datatype.CWE;
import ca.uhn.hl7v2.model.v25.datatype.CX;
import ca.uhn.hl7v2.model.v25.datatype.DLD;
import ca.uhn.hl7v2.model.v25.datatype.DT;
import ca.uhn.hl7v2.model.v25.datatype.DTM;
import ca.uhn.hl7v2.model.v25.datatype.ED;
import ca.uhn.hl7v2.model.v25.datatype.EI;
import ca.uhn.hl7v2.model.v25.datatype.FT;
import ca.uhn.hl7v2.model.v25.datatype.ID;
import ca.uhn.hl7v2.model.v25.datatype.IS;
import ca.uhn.hl7v2.model.v25.datatype.NM;
import ca.uhn.hl7v2.model.v25.datatype.PL;
import ca.uhn.hl7v2.model.v25.datatype.ST;
import ca.uhn.hl7v2.model.v25.datatype.TM;
import ca.uhn.hl7v2.model.v25.datatype.TS;
import ca.uhn.hl7v2.model.v25.datatype.XCN;
import ca.uhn.hl7v2.model.v25.group.ORU_R01_OBSERVATION;
import ca.uhn.hl7v2.model.v25.group.ORU_R01_ORDER_OBSERVATION;
import ca.uhn.hl7v2.model.v25.group.ORU_R01_PATIENT_RESULT;
import ca.uhn.hl7v2.model.v25.message.ORU_R01;
import ca.uhn.hl7v2.model.v25.segment.MSH;
import ca.uhn.hl7v2.model.v25.segment.NK1;
import ca.uhn.hl7v2.model.v25.segment.OBR;
import ca.uhn.hl7v2.model.v25.segment.OBX;
import ca.uhn.hl7v2.model.v25.segment.ORC;
import ca.uhn.hl7v2.model.v25.segment.PID;
import ca.uhn.hl7v2.model.v25.segment.PV1;
import ca.uhn.hl7v2.parser.EncodingCharacters;
import ca.uhn.hl7v2.parser.PipeParser;
public class ORUR01Handler implements Application {
	private static final Logger log = LoggerFactory.getLogger(ORUR01Handler.class);
	private static EncounterRole unknownRole = null;
	@Override
	public boolean canProcess(Message message) {
		return message != null && "ORU_R01".equals(message.getName());
	}
	@Override
	public Message processMessage(Message message) throws ApplicationException {
		if (!(message instanceof ORU_R01)) {
			throw new ApplicationException(Context.getMessageSourceService().getMessage("ORUR01.error.invalidMessage"));
		}
		log.debug("Processing ORU_R01 message");
		Message response;
		try {
			ORU_R01 oru = (ORU_R01) message;
			response = processORU_R01(oru);
		}
		catch (ClassCastException e) {
			log.warn("Error casting " + message.getClass().getName() + " to ORU_R01", e);
			throw new ApplicationException(Context.getMessageSourceService().getMessage("ORUR01.error.invalidMessageType ",
			    new Object[] { message.getClass().getName() }, null), e);
		}
		catch (HL7Exception e) {
			log.warn("Error while processing ORU_R01 message", e);
			throw new ApplicationException(Context.getMessageSourceService().getMessage("ORUR01.error.WhileProcessing"), e);
		}
		log.debug("Finished processing ORU_R01 message");
		return response;
	}
	private Message processORU_R01(ORU_R01 oru) throws HL7Exception {
		validate(oru);
		MSH msh = getMSH(oru);
		PID pid = getPID(oru);
		List<NK1> nk1List = getNK1List(oru);
		PV1 pv1 = getPV1(oru);
		ORC orc = getORC(oru); 
		String messageControlId = msh.getMessageControlID().getValue();
		log.debug("Found HL7 message in inbound queue with control id = {}", messageControlId);
		Patient patient = getPatient(pid);
		log.debug("Processing HL7 message for patient {}", patient.getPatientId());
		Encounter encounter = createEncounter(msh, patient, pv1, orc);
		try {
			updateHealthCenter(patient, pv1);
		}
		catch (Exception e) {
			log.error("Error while processing Discharge To Location (" + messageControlId + ")", e);
		}
		for (NK1 nk1 : nk1List) {
			processNK1(patient, nk1);
		}
		List<ConceptProposal> conceptProposals = new ArrayList<>();
		log.debug("Creating observations for message {}...", messageControlId);
		List<Integer> ignoredConceptIds = new ArrayList<>();
		String obrConceptId = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_MEDICAL_RECORD_OBSERVATIONS, "1238");
		if (StringUtils.hasLength(obrConceptId)) {
			ignoredConceptIds.add(Integer.valueOf(obrConceptId));
		}
		String obrProblemListConceptId = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_PROBLEM_LIST, "1284");
		if (StringUtils.hasLength(obrProblemListConceptId)) {
			ignoredConceptIds.add(Integer.valueOf(obrProblemListConceptId));
		}
		ORU_R01_PATIENT_RESULT patientResult = oru.getPATIENT_RESULT();
		int numObr = patientResult.getORDER_OBSERVATIONReps();
		for (int i = 0; i < numObr; i++) {
			log.debug("Processing OBR ({} of {})", i, numObr);
			ORU_R01_ORDER_OBSERVATION orderObs = patientResult.getORDER_OBSERVATION(i);
			OBR obr = orderObs.getOBR();
			if (!StringUtils.hasText(obr.getUniversalServiceIdentifier().getIdentifier().getValue())) {
				throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.errorInvalidOBR ",
				    new Object[] { messageControlId }, null));
			}
			Obs obsGrouper = null;
			Concept obrConcept = getConcept(obr.getUniversalServiceIdentifier(), messageControlId);
			if (obrConcept != null && !ignoredConceptIds.contains(obrConcept.getId())) {
				obsGrouper = new Obs();
				obsGrouper.setConcept(obrConcept);
				obsGrouper.setPerson(encounter.getPatient());
				obsGrouper.setEncounter(encounter);
				Date datetime = getDatetime(obr);
				if (datetime == null) {
					datetime = encounter.getEncounterDatetime();
				}
				obsGrouper.setObsDatetime(datetime);
				obsGrouper.setLocation(encounter.getLocation());
				obsGrouper.setCreator(encounter.getCreator());
				StringBuilder comments = new StringBuilder();
				ORU_R01_ORDER_OBSERVATION parent = (ORU_R01_ORDER_OBSERVATION) obr.getParent();
				int totalNTEs = parent.getNTEReps();
				for (int iNTE = 0; iNTE < totalNTEs; iNTE++) {
					for (FT obxComment : parent.getNTE(iNTE).getComment()) {
						if (comments.length() > 0) {
							comments.append(" ");
						}
						comments.append(obxComment.getValue());
					}
				}
				if (StringUtils.hasText(comments.toString())) {
					obsGrouper.setComment(comments.toString());
				}
				encounter.addObs(obsGrouper);
			}
			int numObs = orderObs.getOBSERVATIONReps();
			HL7Exception errorInHL7Queue = null;
			for (int j = 0; j < numObs; j++) {
				if (log.isDebugEnabled()) {
					log.debug("Processing OBS ({} of {})", j, numObs);
				}
				OBX obx = orderObs.getOBSERVATION(j).getOBX();
				try {
					log.debug("Parsing observation");
					Obs obs = parseObs(encounter, obx, obr, messageControlId);
					if (obs != null) {
						if (encounter.getEncounterId() != null) {
							obs.setCreator(getEnterer(orc));
							obs.setDateCreated(new Date());
						}
						if (obsGrouper != null) {
							obsGrouper.addGroupMember(obs);
						} else {
							log.debug("Obs is not null. Adding to encounter object");
							encounter.addObs(obs);
							log.debug("Done with this obs");
						}
					}
				}
				catch (ProposingConceptException proposingException) {
					Concept questionConcept = proposingException.getConcept();
					String value = proposingException.getValueName();
					if (!StringUtils.isEmpty(value)) {
						conceptProposals.add(createConceptProposal(encounter, questionConcept, value));
					} else {
						errorInHL7Queue = new HL7Exception(Context.getMessageSourceService().getMessage(
						    "Hl7.proposed.concept.name.empty"), proposingException);
						break;
					}
				}
				catch (HL7Exception e) {
					errorInHL7Queue = e;
				}
				finally {
					if (errorInHL7Queue != null) {
						throw new HL7Exception(Context.getMessageSourceService().getMessage(
						    "ORUR01.error.improperlyFormattedOBX",
						    new Object[] { PipeParser.encode(obx, new EncodingCharacters('|', "^~\\&")) }, null),
						        HL7Exception.DATA_TYPE_ERROR, errorInHL7Queue);
					}
				}
			}
		}
		if (log.isDebugEnabled()) {
			log.debug("Finished creating observations");
			log.debug("Current thread: {}", Thread.currentThread());
			log.debug("Creating the encounter object");
		}
		Context.getEncounterService().saveEncounter(encounter);
		for (ConceptProposal proposal : conceptProposals) {
			Context.getConceptService().saveConceptProposal(proposal);
		}
		return oru;
	}
	protected void processNK1(Patient patient, NK1 nk1) throws HL7Exception {
		String relCodingSystem = nk1.getRelationship().getNameOfCodingSystem().getValue();
		if (!relCodingSystem.equals(HL7Constants.HL7_LOCAL_RELATIONSHIP)) {
			throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.relationshipCoding",
			    new Object[] { relCodingSystem }, null));
		}
		String relIdentifier = nk1.getRelationship().getIdentifier().getValue();
		if (!Pattern.matches("[0-9]+[AB]", relIdentifier)) {
			throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.relationshipType",
			    new Object[] { relIdentifier }, null));
		}
		Integer relTypeId;
		try {
			relTypeId = Integer.parseInt(relIdentifier.substring(0, relIdentifier.length() - 1));
		}
		catch (NumberFormatException e) {
			throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.relationshipType",
			    new Object[] { relIdentifier }, null));
		}
		RelationshipType relType = Context.getPersonService().getRelationshipType(relTypeId);
		if (relType == null) {
			throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.relationshipTypeNotFound",
			    new Object[] { relTypeId }, null));
		}
		Person relative = getRelative(nk1);
		boolean patientIsPersonA = relIdentifier.endsWith("B");
		boolean patientCanBeEitherPerson = relType.getbIsToA().equals(relType.getaIsToB());
		Set<Relationship> rels = new HashSet<>();
		if (relative != null) {
			if (patientCanBeEitherPerson || patientIsPersonA) {
				rels.addAll(Context.getPersonService().getRelationships(patient, relative, relType));
			}
			if (patientCanBeEitherPerson || !patientIsPersonA) {
				rels.addAll(Context.getPersonService().getRelationships(relative, patient, relType));
			}
		}
		if (rels.isEmpty()) {
			if (relative == null) {
				relative = Context.getHL7Service().createPersonFromNK1(nk1);
				if (relative == null) {
					throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.relativeNotCreated"));
				}
			}
			Relationship relation = new Relationship();
			if (patientCanBeEitherPerson || patientIsPersonA) {
				relation.setPersonA(patient);
				relation.setPersonB(relative);
			} else {
				relation.setPersonA(relative);
				relation.setPersonB(patient);
			}
			relation.setRelationshipType(relType);
			Context.getPersonService().saveRelationship(relation);
		}
	}
	private void validate(Message message) throws HL7Exception {
	}
	private MSH getMSH(ORU_R01 oru) {
		return oru.getMSH();
	}
	private PID getPID(ORU_R01 oru) {
		return oru.getPATIENT_RESULT().getPATIENT().getPID();
	}
	public List<NK1> getNK1List(ORU_R01 oru) throws HL7Exception {
		List<NK1> res = new ArrayList<>();
		for (int i = 0; i < oru.getPATIENT_RESULT().getPATIENT().getNK1Reps(); i++) {
			if (oru.getPATIENT_RESULT().getPATIENT().getNK1(i).getSetIDNK1().getValue() != null) {
				res.add(oru.getPATIENT_RESULT().getPATIENT().getNK1(i));
			}
		}
		return res;
	}
	private PV1 getPV1(ORU_R01 oru) {
		return oru.getPATIENT_RESULT().getPATIENT().getVISIT().getPV1();
	}
	private ORC getORC(ORU_R01 oru) {
		return oru.getPATIENT_RESULT().getORDER_OBSERVATION().getORC();
	}
	private Encounter createEncounter(MSH msh, Patient patient, PV1 pv1, ORC orc) throws HL7Exception {
		Encounter encounter;
		CX visitNumber = pv1.getVisitNumber();
		Integer encounterId = null;
		try {
			encounterId = Integer.valueOf(visitNumber.getIDNumber().getValue());
		}
		catch (NumberFormatException e) {
		}
		if (encounterId != null) {
			encounter = Context.getEncounterService().getEncounter(encounterId);
		} else {
			encounter = new Encounter();
			Date encounterDate = getEncounterDate(pv1);
			Provider provider = getProvider(pv1);
			Location location = getLocation(pv1);
			Form form = getForm(msh);
			EncounterType encounterType = getEncounterType(msh, form);
			User enterer = getEnterer(orc);
			encounter.setEncounterDatetime(encounterDate);
			if (unknownRole == null) {
				unknownRole = Context.getEncounterService()
				        .getEncounterRoleByUuid(EncounterRole.UNKNOWN_ENCOUNTER_ROLE_UUID);
			}
			encounter.setProvider(unknownRole, provider);
			encounter.setPatient(patient);
			encounter.setLocation(location);
			encounter.setForm(form);
			encounter.setEncounterType(encounterType);
			encounter.setCreator(enterer);
			encounter.setDateCreated(new Date());
		}
		return encounter;
	}
	private Obs parseObs(Encounter encounter, OBX obx, OBR obr, String uid) throws HL7Exception, ProposingConceptException {
		if (log.isDebugEnabled()) {
			log.debug("parsing observation: " + obx);
		}
		Varies[] values = obx.getObservationValue();
		if (values == null || values.length < 1) {
			return null;
		}
		String hl7Datatype = values[0].getName();
		if (log.isDebugEnabled()) {
			log.debug("  datatype = " + hl7Datatype);
		}
		Concept concept = getConcept(obx.getObservationIdentifier(), uid);
		if (log.isDebugEnabled()) {
			log.debug("  concept = " + concept.getConceptId());
		}
		ConceptName conceptName = getConceptName(obx.getObservationIdentifier());
		if (log.isDebugEnabled()) {
			log.debug("  concept-name = " + conceptName);
		}
		Date datetime = getDatetime(obx);
		if (log.isDebugEnabled()) {
			log.debug("  timestamp = " + datetime);
		}
		if (datetime == null) {
			datetime = encounter.getEncounterDatetime();
		}
		Obs obs = new Obs();
		obs.setPerson(encounter.getPatient());
		obs.setConcept(concept);
		obs.setEncounter(encounter);
		obs.setObsDatetime(datetime);
		obs.setLocation(encounter.getLocation());
		obs.setCreator(encounter.getCreator());
		obs.setDateCreated(encounter.getDateCreated());
		StringBuilder comments = new StringBuilder();
		ORU_R01_OBSERVATION parent = (ORU_R01_OBSERVATION) obx.getParent();
		for (int i = 0; i < parent.getNTEReps(); i++) {
			for (FT obxComment : parent.getNTE(i).getComment()) {
				if (comments.length() > 0) {
					comments.append(" ");
				}
				comments = comments.append(obxComment.getValue());
			}
		}
		if (StringUtils.hasText(comments.toString())) {
			obs.setComment(comments.toString());
		}
		Type obx5 = values[0].getData();
		if ("NM".equals(hl7Datatype)) {
			String value = ((NM) obx5).getValue();
			if (value == null || value.length() == 0) {
				log.warn("Not creating null valued obs for concept " + concept);
				return null;
			} else if ("0".equals(value) || "1".equals(value)) {
				concept = concept.hydrate(concept.getConceptId().toString());
				obs.setConcept(concept);
				if (concept.getDatatype().isBoolean()) {
					obs.setValueBoolean("1".equals(value));
				} else if (concept.getDatatype().isNumeric()) {
					try {
						obs.setValueNumeric(Double.valueOf(value));
					}
					catch (NumberFormatException e) {
						throw new HL7Exception(Context.getMessageSourceService().getMessage(
						    "ORUR01.error.notnumericConcept",
						    new Object[] { value, concept.getConceptId(), conceptName.getName(), uid }, null), e);
					}
				} else if (concept.getDatatype().isCoded()) {
					Concept answer = "1".equals(value) ? Context.getConceptService().getTrueConcept() : Context
					        .getConceptService().getFalseConcept();
					boolean isValidAnswer = false;
					Collection<ConceptAnswer> conceptAnswers = concept.getAnswers();
					if (conceptAnswers != null && !conceptAnswers.isEmpty()) {
						for (ConceptAnswer conceptAnswer : conceptAnswers) {
							if (conceptAnswer.getAnswerConcept().getId().equals(answer.getId())) {
								obs.setValueCoded(answer);
								isValidAnswer = true;
								break;
							}
						}
					}
					if (!isValidAnswer) {
						throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.invalidAnswer",
						    new Object[] { answer.toString(), uid }, null));
					}
				} else {
					throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.CannotSetBoolean",
					    new Object[] { obs.getConcept().getConceptId() }, null));
				}
			} else {
				try {
					obs.setValueNumeric(Double.valueOf(value));
				}
				catch (NumberFormatException e) {
					throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.notnumericConcept",
					    new Object[] { value, concept.getConceptId(), conceptName.getName(), uid }, null), e);
				}
			}
		} else if ("CWE".equals(hl7Datatype)) {
			log.debug("  CWE observation");
			CWE value = (CWE) obx5;
			String valueIdentifier = value.getIdentifier().getValue();
			log.debug("    value id = " + valueIdentifier);
			String valueName = value.getText().getValue();
			log.debug("    value name = " + valueName);
			if (isConceptProposal(valueIdentifier)) {
				if (log.isDebugEnabled()) {
					log.debug("Proposing concept");
				}
				throw new ProposingConceptException(concept, valueName);
			} else {
				log.debug("    not proposal");
				try {
					Concept valueConcept = getConcept(value, uid);
					obs.setValueCoded(valueConcept);
					if (HL7Constants.HL7_LOCAL_DRUG.equals(value.getNameOfAlternateCodingSystem().getValue())) {
						Drug valueDrug = new Drug();
						valueDrug.setDrugId(Integer.valueOf(value.getAlternateIdentifier().getValue()));
						obs.setValueDrug(valueDrug);
					} else {
						ConceptName valueConceptName = getConceptName(value);
						if (valueConceptName != null) {
							if (log.isDebugEnabled()) {
								log.debug("    value concept-name-id = " + valueConceptName.getConceptNameId());
								log.debug("    value concept-name = " + valueConceptName.getName());
							}
							obs.setValueCodedName(valueConceptName);
						}
					}
				}
				catch (NumberFormatException e) {
					throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.InvalidConceptId",
					    new Object[] { valueIdentifier, valueName }, null));
				}
			}
			if (log.isDebugEnabled()) {
				log.debug("  Done with CWE");
			}
		} else if ("CE".equals(hl7Datatype)) {
			CE value = (CE) obx5;
			String valueIdentifier = value.getIdentifier().getValue();
			String valueName = value.getText().getValue();
			if (isConceptProposal(valueIdentifier)) {
				throw new ProposingConceptException(concept, valueName);
			} else {
				try {
					obs.setValueCoded(getConcept(value, uid));
					obs.setValueCodedName(getConceptName(value));
				}
				catch (NumberFormatException e) {
					throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.InvalidConceptId",
					    new Object[] { valueIdentifier, valueName }, null));
				}
			}
		} else if ("DT".equals(hl7Datatype)) {
			DT value = (DT) obx5;
			if (value != null) {
				Date valueDate = getDate(value.getYear(), value.getMonth(), value.getDay(), 0, 0, 0);
				obs.setValueDatetime(valueDate);
			} else {
				log.warn("Not creating null valued obs for concept " + concept);
				return null;
			}
		} else if ("TS".equals(hl7Datatype)) {
			DTM value = ((TS) obx5).getTime();
			if (value != null) {
				Date valueDate = getDate(value.getYear(), value.getMonth(), value.getDay(), value.getHour(), value
				        .getMinute(), value.getSecond());
				obs.setValueDatetime(valueDate);
			} else {
				log.warn("Not creating null valued obs for concept " + concept);
				return null;
			}
		} else if ("TM".equals(hl7Datatype)) {
			TM value = (TM) obx5;
			if (value != null) {
				Date valueTime = getDate(0, 0, 0, value.getHour(), value.getMinute(), value.getSecond());
				obs.setValueDatetime(valueTime);
			} else {
				log.warn("Not creating null valued obs for concept " + concept);
				return null;
			}
		} else if ("ST".equals(hl7Datatype)) {
			ST value = (ST) obx5;
			if (value == null || value.getValue() == null || value.getValue().trim().length() == 0) {
				log.warn("Not creating null valued obs for concept " + concept);
				return null;
			}
			obs.setValueText(value.getValue());
		} else if ("ED".equals(hl7Datatype)) {
			ED value = (ED) obx5;
			if (value == null || value.getData() == null || !StringUtils.hasText(value.getData().getValue())) {
				log.warn("Not creating null valued obs for concept " + concept);
				return null;
			}
			Concept c = Context.getConceptService().getConcept(obs.getConcept().getConceptId());
			obs.setConcept(c);
			String title = null;
			if (obs.getValueCodedName() != null) {
				title = obs.getValueCodedName().getName();
			}
			if (!StringUtils.hasText(title)) {
				title = c.getName().getName();
			}
			obs.setComplexData(new ComplexData(title, value.getData().getValue()));
		} else {
			throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.UpsupportedObsType",
			    new Object[] { hl7Datatype }, null));
		}
		return obs;
	}
	private ConceptName getConceptName(CWE cwe) throws HL7Exception {
		ST altIdentifier = cwe.getAlternateIdentifier();
		ID altCodingSystem = cwe.getNameOfAlternateCodingSystem();
		return getConceptName(altIdentifier, altCodingSystem);
	}
	private ConceptName getConceptName(CE ce) throws HL7Exception {
		ST altIdentifier = ce.getAlternateIdentifier();
		ID altCodingSystem = ce.getNameOfAlternateCodingSystem();
		return getConceptName(altIdentifier, altCodingSystem);
	}
	private ConceptName getConceptName(ST altIdentifier, ID altCodingSystem) throws HL7Exception {
		if (altIdentifier != null && HL7Constants.HL7_LOCAL_CONCEPT_NAME.equals(altCodingSystem.getValue())) {
			String hl7ConceptNameId = altIdentifier.getValue();
			return getConceptName(hl7ConceptNameId);
		}
		return null;
	}
	private ConceptName getConceptName(String hl7ConceptNameId) throws HL7Exception {
		ConceptName specifiedConceptName = null;
		if (hl7ConceptNameId != null) {
			try {
				Integer conceptNameId = Integer.valueOf(hl7ConceptNameId);
				specifiedConceptName = new ConceptName();
				specifiedConceptName.setConceptNameId(conceptNameId);
			}
			catch (NumberFormatException e) {
				log.debug("Invalid concept name ID '" + hl7ConceptNameId + "'", e);
			}
		}
		return specifiedConceptName;
	}
	private boolean isConceptProposal(String identifier) {
		return OpenmrsUtil.nullSafeEquals(identifier, OpenmrsConstants.PROPOSED_CONCEPT_IDENTIFIER);
	}
	private Date getDate(int year, int month, int day, int hour, int minute, int second) {
		Calendar cal = Calendar.getInstance();
		cal.set(year, month - 1, day, hour, minute, second);
		return cal.getTime();
	}
	private Concept getConcept(CE codedElement, String uid) throws HL7Exception {
		String hl7ConceptId = codedElement.getIdentifier().getValue();
		String codingSystem = codedElement.getNameOfCodingSystem().getValue();
		return getConcept(hl7ConceptId, codingSystem, uid);
	}
	private Concept getConcept(CWE codedElement, String uid) throws HL7Exception {
		String hl7ConceptId = codedElement.getIdentifier().getValue();
		String codingSystem = codedElement.getNameOfCodingSystem().getValue();
		return getConcept(hl7ConceptId, codingSystem, uid);
	}
	protected Concept getConcept(String hl7ConceptId, String codingSystem, String uid) throws HL7Exception {
		if (codingSystem == null || HL7Constants.HL7_LOCAL_CONCEPT.equals(codingSystem)) {
			try {
				Integer conceptId = Integer.valueOf(hl7ConceptId);
				return Context.getConceptService().getConcept(conceptId);
			}
			catch (NumberFormatException e) {
				throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.hl7ConceptId",
				    new Object[] { hl7ConceptId, uid }, null));
			}
		} else {
			return Context.getConceptService().getConceptByMapping(hl7ConceptId, codingSystem);
		}
	}
	private Date getDatetime(OBX obx) throws HL7Exception {
		TS ts = obx.getDateTimeOfTheObservation();
		return getDatetime(ts);
	}
	private Date getDatetime(OBR obr) throws HL7Exception {
		TS ts = obr.getObservationDateTime();
		return getDatetime(ts);
	}
	private Date getDatetime(TS ts) throws HL7Exception {
		Date datetime = null;
		DTM value = ts.getTime();
		if (value.getYear() == 0 || value.getValue() == null) {
			return null;
		}
		try {
			datetime = getDate(value.getYear(), value.getMonth(), value.getDay(), value.getHour(), value.getMinute(), value
			        .getSecond());
		}
		catch (DataTypeException e) {
		}
		return datetime;
	}
	private Date getEncounterDate(PV1 pv1) throws HL7Exception {
		return tsToDate(pv1.getAdmitDateTime());
	}
	private Provider getProvider(PV1 pv1) throws HL7Exception {
		XCN hl7Provider = pv1.getAttendingDoctor(0);
		Provider provider = null;
		String id = hl7Provider.getIDNumber().getValue();
		String assignAuth = hl7Provider.getAssigningAuthority().getUniversalID().getValue();
		String type = hl7Provider.getAssigningAuthority().getUniversalIDType().getValue();
		String errorMessage;
		if (StringUtils.hasText(id)) {
			String specificErrorMsg = "";
			if (OpenmrsUtil.nullSafeEquals("L", type)) {
				if (HL7Constants.PROVIDER_ASSIGNING_AUTH_PROV_ID.equalsIgnoreCase(assignAuth)) {
					try {
						provider = Context.getProviderService().getProvider(Integer.valueOf(id));
					}
					catch (NumberFormatException e) {
					}
					specificErrorMsg = "with provider Id";
				} else if (HL7Constants.PROVIDER_ASSIGNING_AUTH_IDENTIFIER.equalsIgnoreCase(assignAuth)) {
					provider = Context.getProviderService().getProviderByIdentifier(id);
					specificErrorMsg = "with provider identifier";
				} else if (HL7Constants.PROVIDER_ASSIGNING_AUTH_PROV_UUID.equalsIgnoreCase(assignAuth)) {
					provider = Context.getProviderService().getProviderByUuid(id);
					specificErrorMsg = "with provider uuid";
				}
			} else {
				try {
					Person person = Context.getPersonService().getPerson(Integer.valueOf(id));
					Collection<Provider> providers = Context.getProviderService().getProvidersByPerson(person);
					if (!providers.isEmpty()) {
						provider = providers.iterator().next();
					}
				}
				catch (NumberFormatException e) {
				}
				specificErrorMsg = "associated to a person with person id";
			}
			errorMessage = "Could not resolve provider " + specificErrorMsg + ":" + id;
		} else {
			errorMessage = "No unique identifier was found for the provider";
		}
		if (provider == null) {
			throw new HL7Exception(errorMessage);
		}
		return provider;
	}
	private Patient getPatient(PID pid) throws HL7Exception {
		Integer patientId = Context.getHL7Service().resolvePatientId(pid);
		if (patientId == null) {
			throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.UnresolvedPatient"));
		}
		return Context.getPatientService().getPatient(patientId);
	}
	private Person getRelative(NK1 nk1) throws HL7Exception {
		if (nk1.getNextOfKinAssociatedPartySIdentifiers().length < 1) {
			return null;
		}
		return Context.getHL7Service().resolvePersonFromIdentifiers(nk1.getNextOfKinAssociatedPartySIdentifiers());
	}
	private Location getLocation(PV1 pv1) throws HL7Exception {
		PL hl7Location = pv1.getAssignedPatientLocation();
		Integer locationId = Context.getHL7Service().resolveLocationId(hl7Location);
		if (locationId == null) {
			throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.UnresolvedLocation"));
		}
		return Context.getLocationService().getLocation(locationId);
	}
	public Form getForm(MSH msh) throws HL7Exception {
		String uuid = null;
		String id = null;
		for (EI identifier : msh.getMessageProfileIdentifier()) {
			if (identifier != null && identifier.getNamespaceID() != null) {
				String identifierType = identifier.getNamespaceID().getValue();
				if (OpenmrsUtil.nullSafeEquals(identifierType, HL7Constants.HL7_FORM_UUID)) {
					uuid = identifier.getEntityIdentifier().getValue();
				} else if (OpenmrsUtil.nullSafeEquals(identifierType, HL7Constants.HL7_FORM_ID)) {
					id = identifier.getEntityIdentifier().getValue();
				} else {
					log.warn("Form identifier type of " + identifierType + " unknown to ORU R01 processor.");
				}
			}
		}
		Form form = null;
		if (uuid == null && id == null) {
			return form;
		}
		if (uuid != null) {
			form = Context.getFormService().getFormByUuid(uuid);
		}
		if (id != null) {
			try {
				Integer formId = Integer.parseInt(id);
				form = Context.getFormService().getForm(formId);
			} catch (NumberFormatException e) {
				throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.parseFormId"), e);
			}
		}
		return form;
	}
	private EncounterType getEncounterType(MSH msh, Form form) {
		if (form != null) {
			return form.getEncounterType();
		}
		return null;
	}
	private User getEnterer(ORC orc) throws HL7Exception {
		XCN hl7Enterer = orc.getEnteredBy(0);
		Integer entererId = Context.getHL7Service().resolveUserId(hl7Enterer);
		if (entererId == null) {
			throw new HL7Exception(Context.getMessageSourceService().getMessage("ORUR01.error.UnresolvedEnterer"));
		}
		User enterer = new User();
		enterer.setUserId(entererId);
		return enterer;
	}
	private Date tsToDate(TS ts) throws HL7Exception {
		String dtm = ts.getTime().getValue();
		int year = Integer.parseInt(dtm.substring(0, 4));
		int month = (dtm.length() >= 6 ? Integer.parseInt(dtm.substring(4, 6)) - 1 : 0);
		int day = (dtm.length() >= 8 ? Integer.parseInt(dtm.substring(6, 8)) : 1);
		int hour = (dtm.length() >= 10 ? Integer.parseInt(dtm.substring(8, 10)) : 0);
		int min = (dtm.length() >= 12 ? Integer.parseInt(dtm.substring(10, 12)) : 0);
		int sec = (dtm.length() >= 14 ? Integer.parseInt(dtm.substring(12, 14)) : 0);
		Calendar cal = Calendar.getInstance();
		cal.set(year, month, day, hour, min, sec);
		return cal.getTime();
	}
	private ConceptProposal createConceptProposal(Encounter encounter, Concept concept, String originalText) {
		ConceptProposal conceptProposal = new ConceptProposal();
		conceptProposal.setOriginalText(originalText);
		conceptProposal.setState(OpenmrsConstants.CONCEPT_PROPOSAL_UNMAPPED);
		conceptProposal.setEncounter(encounter);
		conceptProposal.setObsConcept(concept);
		return conceptProposal;
	}
	private void updateHealthCenter(Patient patient, PV1 pv1) {
		if (log.isDebugEnabled()) {
			log.debug("Checking for discharge to location");
		}
		DLD dld = pv1.getDischargedToLocation();
		log.debug("DLD = " + dld);
		if (dld == null) {
			return;
		}
		IS hl7DischargeToLocation = dld.getDischargeLocation();
		log.debug("is = " + hl7DischargeToLocation);
		if (hl7DischargeToLocation == null) {
			return;
		}
		String dischargeToLocation = hl7DischargeToLocation.getValue();
		log.debug("dischargeToLocation = " + dischargeToLocation);
		if (dischargeToLocation != null && dischargeToLocation.length() > 0) {
			if (log.isDebugEnabled()) {
				log.debug("Patient discharged to " + dischargeToLocation);
			}
			for (int i = 0; i < dischargeToLocation.length(); i++) {
				char ch = dischargeToLocation.charAt(i);
				if (ch == '&' || ch == '^') {
					dischargeToLocation = dischargeToLocation.substring(0, i);
					break;
				}
			}
			Integer newLocationId = Integer.parseInt(dischargeToLocation);
			patient = Context.getPatientService().getPatient(patient.getPatientId());
			PersonAttributeType healthCenterAttrType = Context.getPersonService().getPersonAttributeTypeByName(
			    "Health Center");
			if (healthCenterAttrType == null) {
				log.error("A person attribute type with name 'Health Center' is not defined but patient "
				        + patient.getPatientId() + " is trying to change their health center to " + newLocationId);
				return;
			}
			PersonAttribute currentHealthCenter = patient.getAttribute("Health Center");
			if (currentHealthCenter == null || !newLocationId.toString().equals(currentHealthCenter.getValue())) {
				PersonAttribute newHealthCenter = new PersonAttribute(healthCenterAttrType, newLocationId.toString());
				log.debug("Updating patient's location from " + currentHealthCenter + " to " + newLocationId);
				patient.addAttribute(newHealthCenter);
				Context.getPatientService().savePatient(patient);
			}
		}
		log.debug("finished discharge to location method");
	}
}
package org.openmrs.api.impl;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import org.apache.commons.beanutils.BeanUtils;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.hibernate.Hibernate;
import org.openmrs.Concept;
import org.openmrs.ConceptAnswer;
import org.openmrs.ConceptAttribute;
import org.openmrs.ConceptAttributeType;
import org.openmrs.ConceptClass;
import org.openmrs.ConceptComplex;
import org.openmrs.ConceptDatatype;
import org.openmrs.ConceptDescription;
import org.openmrs.ConceptMap;
import org.openmrs.ConceptMapType;
import org.openmrs.ConceptName;
import org.openmrs.ConceptNameTag;
import org.openmrs.ConceptNumeric;
import org.openmrs.ConceptProposal;
import org.openmrs.ConceptReferenceRange;
import org.openmrs.ConceptReferenceTerm;
import org.openmrs.ConceptReferenceTermMap;
import org.openmrs.ConceptSearchResult;
import org.openmrs.ConceptSet;
import org.openmrs.ConceptSource;
import org.openmrs.ConceptStopWord;
import org.openmrs.Drug;
import org.openmrs.DrugIngredient;
import org.openmrs.Obs;
import org.openmrs.api.APIException;
import org.openmrs.api.AdministrationService;
import org.openmrs.api.ConceptInUseException;
import org.openmrs.api.ConceptNameInUseException;
import org.openmrs.api.ConceptService;
import org.openmrs.api.ConceptStopWordException;
import org.openmrs.api.ConceptsLockedException;
import org.openmrs.api.context.Context;
import org.openmrs.api.db.ConceptDAO;
import org.openmrs.api.db.DAOException;
import org.openmrs.customdatatype.CustomDatatypeUtil;
import org.openmrs.util.OpenmrsConstants;
import org.openmrs.util.OpenmrsUtil;
import org.openmrs.validator.ValidateUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.transaction.annotation.Transactional;
@Transactional
public class ConceptServiceImpl extends BaseOpenmrsService implements ConceptService {
	private static final Logger log = LoggerFactory.getLogger(ConceptServiceImpl.class);
	private ConceptDAO dao;
	private static Concept trueConcept;
	private static Concept falseConcept;
	private static Concept unknownConcept;
	private static final String ERROR_MESSAGE = "Error generated";
	private static final String CONCEPT_IDS_BY_MAPPING_CACHE_NAME = "conceptIdsByMapping";
	@Override
	public void setConceptDAO(ConceptDAO dao) {
		this.dao = dao;
	}
	@Override
	@CacheEvict(value = CONCEPT_IDS_BY_MAPPING_CACHE_NAME, allEntries = true)
	public Concept saveConcept(Concept concept) throws APIException {
		ensureConceptMapTypeIsSet(concept);
		CustomDatatypeUtil.saveAttributesIfNecessary(concept);
		checkIfLocked();
		checkIfDatatypeCanBeChanged(concept);
		List<ConceptName> changedConceptNames = null;
		Map<String, ConceptName> uuidClonedConceptNameMap = null;
		if (concept.getConceptId() != null) {
			uuidClonedConceptNameMap = new HashMap<>();
			for (ConceptName conceptName : concept.getNames()) {
				if (conceptName.getConceptNameId() != null) {
					ConceptName clone = cloneConceptName(conceptName);
					clone.setConceptNameId(null);
					uuidClonedConceptNameMap.put(conceptName.getUuid(), clone);
					if (hasNameChanged(conceptName)) {
						if (changedConceptNames == null) {
							changedConceptNames = new ArrayList<>();
						}
						changedConceptNames.add(conceptName);
					} else {
						clone.setConceptNameId(conceptName.getConceptNameId());
						try {
							BeanUtils.copyProperties(conceptName, clone);
						}
						catch (IllegalAccessException | InvocationTargetException e) {
							log.error(ERROR_MESSAGE, e);
						}
					}
				}
			}
		}
		if (CollectionUtils.isNotEmpty(changedConceptNames)) {
			for (ConceptName changedName : changedConceptNames) {
				changedName.setVoided(true);
				changedName.setDateVoided(new Date());
				changedName.setVoidedBy(Context.getAuthenticatedUser());
				changedName.setVoidReason(Context.getMessageSourceService().getMessage("Concept.name.voidReason.nameChanged"));
				makeVoidedNameSynonym(changedName);
				makeLocaleNotPreferred(changedName);
				ConceptName clone = uuidClonedConceptNameMap.get(changedName.getUuid());
				clone.setUuid(UUID.randomUUID().toString());
				clone.setDateCreated(null);
				clone.setCreator(null);
				concept.addName(clone);
			}
		}
		ensurePreferredNameForLocale(concept);
		logConceptChangedData(concept);
		if (!concept.getSet() && (!concept.getSetMembers().isEmpty())) {
			concept.setSet(true);
		}
		return dao.saveConcept(concept);
	}
	private void ensureConceptMapTypeIsSet(Concept concept) {
		ConceptMapType defaultConceptMapType = null;
		for (ConceptMap map : concept.getConceptMappings()) {
			if (map.getConceptMapType() == null) {
				if (defaultConceptMapType == null) {
					defaultConceptMapType = Context.getConceptService().getDefaultConceptMapType();
				}
				map.setConceptMapType(defaultConceptMapType);
			}
		}
	}
	private void makeVoidedNameSynonym(ConceptName conceptName) {
		if (!conceptName.isSynonym()) {
			conceptName.setConceptNameType(null);
		}
	}
	private void makeLocaleNotPreferred(ConceptName conceptName) {
		if (conceptName.getLocalePreferred()) {
			conceptName.setLocalePreferred(false);
		}
	}
	private void ensurePreferredNameForLocale(Concept concept) {
		Set<Locale> checkedLocales = new HashSet<>();
		for (ConceptName n : concept.getNames()) {
			Locale locale = n.getLocale();
			if (checkedLocales.contains(locale)) {
				continue; 
			}
			ConceptName possiblePreferredName = concept.getPreferredName(locale);
			if (possiblePreferredName != null) {
			} else if (concept.getFullySpecifiedName(locale) != null) {
				possiblePreferredName = concept.getFullySpecifiedName(locale);
			} else if (!CollectionUtils.isEmpty(concept.getSynonyms(locale))) {
				concept.getSynonyms(locale).iterator().next().setLocalePreferred(true);
			}
			if (possiblePreferredName != null) { 
				possiblePreferredName.setLocalePreferred(true);
			}
			checkedLocales.add(locale);
		}
	}
	private void logConceptChangedData(Concept concept) {
		concept.setDateChanged(new Date());
		concept.setChangedBy(Context.getAuthenticatedUser());
	}
	@Override
	public Drug saveDrug(Drug drug) throws APIException {
		checkIfLocked();
		return dao.saveDrug(drug);
	}
	@Override
	public void purgeConcept(Concept concept) throws APIException {
		checkIfLocked();
		if (concept.getConceptId() != null) {
			for (ConceptName conceptName : concept.getNames()) {
				if (hasAnyObservation(conceptName)) {
					throw new ConceptNameInUseException("Can't delete concept with id : " + concept.getConceptId()
					        + " because it has a name '" + conceptName.getName()
					        + "' which is being used by some observation(s)");
				}
			}
		}
		dao.purgeConcept(concept);
	}
	@Override
	public Concept retireConcept(Concept concept, String reason) throws APIException {
		if (StringUtils.isBlank(reason)) {
			throw new IllegalArgumentException(Context.getMessageSourceService().getMessage("general.voidReason.empty"));
		}
		if (!concept.getRetired()) {
			checkIfLocked();
			concept.setRetired(true);
			concept.setRetireReason(reason);
			return Context.getConceptService().saveConcept(concept);
		}
		return concept;
	}
	@Override
	public Drug retireDrug(Drug drug, String reason) throws APIException {
		return dao.saveDrug(drug);
	}
	@Override
	public Drug unretireDrug(Drug drug) throws APIException {
		return Context.getConceptService().saveDrug(drug);
	}
	@Override
	public void purgeDrug(Drug drug) throws APIException {
		dao.purgeDrug(drug);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getConcept(Integer conceptId) throws APIException {
		return dao.getConcept(conceptId);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getConceptByReference(String conceptRef) {
		if (StringUtils.isBlank(conceptRef)) {
			return null;
		}
		Concept cpt = null;
		if (isValidUuidFormat(conceptRef)) {
			cpt = Context.getConceptService().getConceptByUuid(conceptRef);
			if (cpt != null) {
				return cpt;
			}
		}
		int idx = conceptRef.indexOf(":");
		if (idx >= 0 && idx < conceptRef.length() - 1) {
			String conceptSource = conceptRef.substring(0, idx);
			String conceptCode = conceptRef.substring(idx + 1);
			cpt = Context.getConceptService().getConceptByMapping(conceptCode, conceptSource);
			if (cpt != null) {
				return cpt;
			}
		}
		int conceptId = NumberUtils.toInt(conceptRef, -1);
		if (conceptId >= 0) {
			cpt = Context.getConceptService().getConcept(conceptId);
			if (cpt != null) {
				return cpt;
			}
		} else {
			cpt = Context.getConceptService().getConceptByName(conceptRef);
			if (cpt != null) {
				return cpt;
			}
		}
		if (conceptRef.contains(".")) {
			try {
				return getConceptByReference(evaluateStaticConstant(conceptRef));
			}
			catch (APIException e) {
				log.warn("Unable to translate '{}' into a concept", conceptRef, e);
			}
		}
		return cpt == null ? null : cpt;
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptName getConceptName(Integer conceptNameId) throws APIException {
		return dao.getConceptName(conceptNameId);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptAnswer getConceptAnswer(Integer conceptAnswerId) throws APIException {
		return dao.getConceptAnswer(conceptAnswerId);
	}
	@Override
	@Transactional(readOnly = true)
	public Drug getDrug(Integer drugId) throws APIException {
		return dao.getDrug(drugId);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptNumeric getConceptNumeric(Integer conceptId) throws APIException {
		return dao.getConceptNumeric(conceptId);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptComplex getConceptComplex(Integer conceptId) {
		return dao.getConceptComplex(conceptId);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getAllConcepts() throws APIException {
		return Context.getConceptService().getAllConcepts(null, true, true);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getAllConcepts(String sortBy, boolean asc, boolean includeRetired) throws APIException {
		String tmpSortBy = sortBy == null ? "conceptId" : sortBy;
		return dao.getAllConcepts(tmpSortBy, asc, includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getConceptsByName(String name) throws APIException {
		return getConcepts(name, Context.getLocale(), true, null, null);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getConceptByName(String name) {
		if (StringUtils.isBlank(name)) {
			return null;
		}
		return dao.getConceptByName(name);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getConcept(String conceptIdOrName) {
		Concept c;
		Integer conceptId;
		try {
			conceptId = Integer.valueOf(conceptIdOrName);
		}
		catch (NumberFormatException nfe) {
			conceptId = null;
		}
		if (conceptId != null) {
			c = Context.getConceptService().getConcept(conceptId);
		} else {
			c = Context.getConceptService().getConceptByName(conceptIdOrName);
		}
		return c;
	}
	private List<Concept> getConcepts(String name, Locale loc, boolean searchOnPhrase, List<ConceptClass> classes,
	        List<ConceptDatatype> datatypes) {
		List<ConceptClass> tmpClasses = classes == null ? new ArrayList<>() : classes;
		List<ConceptDatatype> tmpDatatypes = datatypes == null ? new ArrayList<>() : datatypes;
		return dao.getConcepts(name, loc, searchOnPhrase, tmpClasses, tmpDatatypes);
	}
	@Override
	@Transactional(readOnly = true)
	public Drug getDrug(String drugNameOrId) {
		Integer drugId;
		try {
			drugId = Integer.valueOf(drugNameOrId);
		}
		catch (NumberFormatException nfe) {
			drugId = null;
		}
		if (drugId != null) {
			return Context.getConceptService().getDrug(drugId);
		} else {
			List<Drug> drugs = dao.getDrugs(drugNameOrId, null, false);
			if (drugs.size() > 1) {
				log.warn("more than one drug name returned with name:" + drugNameOrId);
			}
			if (drugs.isEmpty()) {
				return null;
			}
			return drugs.get(0);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<Drug> getAllDrugs() {
		return Context.getConceptService().getAllDrugs(true);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Drug> getAllDrugs(boolean includeRetired) {
		return dao.getDrugs(null, null, includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Drug> getDrugsByConcept(Concept concept) {
		return dao.getDrugs(null, concept, false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Drug> getDrugs(String phrase) {
		List<Drug> drugs = new ArrayList<>();
		try {
			Integer drugId = Integer.parseInt(phrase);
			Drug targetDrug = Context.getConceptService().getDrug(drugId);
			if (targetDrug != null) {
				drugs.add(targetDrug);
			}
		}
		catch (NumberFormatException e) {
		}
		try {
			Integer conceptId = Integer.parseInt(phrase);
			Concept targetConcept = Context.getConceptService().getConcept(conceptId);
			if (targetConcept != null) {
				drugs.addAll(Context.getConceptService().getDrugsByConcept(targetConcept));
			}
		}
		catch (NumberFormatException e) {
		}
		drugs.addAll(dao.getDrugs(phrase));
		return drugs;
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getConceptsByClass(ConceptClass cc) {		
		return dao.getConceptsByClass(cc);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptClass> getAllConceptClasses(boolean includeRetired) {
		return dao.getAllConceptClasses(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptClass getConceptClass(Integer i) {
		return dao.getConceptClass(i);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptClass getConceptClassByName(String name) {
		List<ConceptClass> ccList = dao.getConceptClasses(name);
		if (ccList.size() > 1) {
			log.warn("More than one ConceptClass found with name: " + name);
		}
		if (ccList.size() == 1) {
			return ccList.get(0);
		}
		return null;
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptClass> getAllConceptClasses() throws APIException {
		return Context.getConceptService().getAllConceptClasses(true);
	}
	@Override
	public ConceptClass saveConceptClass(ConceptClass cc) throws APIException {
		return dao.saveConceptClass(cc);
	}
	@Override
	public void purgeConceptClass(ConceptClass cc) {
		dao.purgeConceptClass(cc);
	}
	@Override
	public void purgeConceptNameTag(ConceptNameTag cnt) {
		dao.deleteConceptNameTag(cnt);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptDatatype> getAllConceptDatatypes() {
		return Context.getConceptService().getAllConceptDatatypes(true);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptDatatype> getAllConceptDatatypes(boolean includeRetired) throws APIException {
		return dao.getAllConceptDatatypes(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptDatatype getConceptDatatype(Integer i) {
		return dao.getConceptDatatype(i);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptDatatype getConceptDatatypeByName(String name) {
		return dao.getConceptDatatypeByName(name);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptSet> getConceptSetsByConcept(Concept concept) throws APIException {
		return dao.getConceptSetsByConcept(concept);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getConceptsByConceptSet(Concept c) {
		Set<Integer> alreadySeen = new HashSet<>();
		List<Concept> ret = new ArrayList<>();
		explodeConceptSetHelper(c, ret, alreadySeen);
		return ret;
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptSet> getSetsContainingConcept(Concept concept) {
		if (concept.getConceptId() == null) {
			return Collections.emptyList();
		}
		return dao.getSetsContainingConcept(concept);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptProposal getConceptProposal(Integer conceptProposalId) {
		return dao.getConceptProposal(conceptProposalId);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptProposal> getAllConceptProposals(boolean includeCompleted) {
		return dao.getAllConceptProposals(includeCompleted);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptProposal> getConceptProposals(String cp) {
		return dao.getConceptProposals(cp);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getProposedConcepts(String text) {
		return dao.getProposedConcepts(text);
	}
	@Override
	public ConceptProposal saveConceptProposal(ConceptProposal conceptProposal) throws APIException {
		return dao.saveConceptProposal(conceptProposal);
	}
	@Override
	public void purgeConceptProposal(ConceptProposal cp) throws APIException {
		dao.purgeConceptProposal(cp);
	}
	@Override
	public Concept mapConceptProposalToConcept(ConceptProposal cp, Concept mappedConcept, Locale locale) throws APIException {
		if (cp.getState().equals(OpenmrsConstants.CONCEPT_PROPOSAL_REJECT)) {
			cp.rejectConceptProposal();
			Context.getConceptService().saveConceptProposal(cp);
			return null;
		}
		if (mappedConcept == null) {
			throw new APIException("Concept.mapped.illegal", (Object[]) null);
		}
		ConceptName conceptName = null;
		if (cp.getState().equals(OpenmrsConstants.CONCEPT_PROPOSAL_CONCEPT) || StringUtils.isBlank(cp.getFinalText())) {
			cp.setState(OpenmrsConstants.CONCEPT_PROPOSAL_CONCEPT);
			cp.setFinalText("");
		} else if (cp.getState().equals(OpenmrsConstants.CONCEPT_PROPOSAL_SYNONYM)) {
			checkIfLocked();
			String finalText = cp.getFinalText();
			conceptName = new ConceptName(finalText, null);
			conceptName.setConcept(mappedConcept);
			conceptName.setLocale(locale == null ? Context.getLocale() : locale);
			conceptName.setDateCreated(new Date());
			conceptName.setCreator(Context.getAuthenticatedUser());
			if (conceptName.getUuid() == null) {
				conceptName.setUuid(UUID.randomUUID().toString());
			}
			mappedConcept.addName(conceptName);
			mappedConcept.setChangedBy(Context.getAuthenticatedUser());
			mappedConcept.setDateChanged(new Date());
			ValidateUtil.validate(mappedConcept);
            Context.getConceptService().saveConcept(mappedConcept);
		}
		cp.setMappedConcept(mappedConcept);
		if (cp.getObsConcept() != null) {
			Obs ob = new Obs();
			ob.setEncounter(cp.getEncounter());
			ob.setConcept(cp.getObsConcept());
			ob.setValueCoded(cp.getMappedConcept());
			if (cp.getState().equals(OpenmrsConstants.CONCEPT_PROPOSAL_SYNONYM)) {
				ob.setValueCodedName(conceptName);
			}
			ob.setCreator(Context.getAuthenticatedUser());
			ob.setDateCreated(new Date());
			ob.setObsDatetime(cp.getEncounter().getEncounterDatetime());
			ob.setLocation(cp.getEncounter().getLocation());
			ob.setPerson(cp.getEncounter().getPatient());
			if (ob.getUuid() == null) {
				ob.setUuid(UUID.randomUUID().toString());
			}
            Context.getObsService().saveObs(ob, null);
			cp.setObs(ob);
		}
		return mappedConcept;
	}
	@Override
	public Concept mapConceptProposalToConcept(ConceptProposal cp, Concept mappedConcept) throws APIException {
		return Context.getConceptService().mapConceptProposalToConcept(cp, mappedConcept, null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getConceptsByAnswer(Concept concept) throws APIException {
		if (concept.getConceptId() == null) {
			return Collections.emptyList();
		}
		return dao.getConceptsByAnswer(concept);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getPrevConcept(Concept c) {
		return dao.getPrevConcept(c);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getNextConcept(Concept c) {
		return dao.getNextConcept(c);
	}
	@Override
	@Transactional(readOnly = true)
	public void checkIfLocked() throws ConceptsLockedException {
		String locked = Context.getAdministrationService().getGlobalProperty(
		    OpenmrsConstants.GLOBAL_PROPERTY_CONCEPTS_LOCKED, "false");
		if ("true".equalsIgnoreCase(locked)) {
			throw new ConceptsLockedException();
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getConceptsWithDrugsInFormulary() {
		return dao.getConceptsWithDrugsInFormulary();
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getMaxConceptId() {
		return dao.getMaxConceptId();
	}
	private void explodeConceptSetHelper(Concept concept, Collection<Concept> ret, Collection<Integer> alreadySeen) {
		if (alreadySeen.contains(concept.getConceptId())) {
			return;
		}
		alreadySeen.add(concept.getConceptId());
		List<ConceptSet> cs = getConceptSetsByConcept(concept);
		for (ConceptSet set : cs) {
			Concept c = set.getConcept();
			if (c.getSet()) {
				ret.add(c);
				explodeConceptSetHelper(c, ret, alreadySeen);
			} else {
				ret.add(c);
			}
		}
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptNameTag getConceptNameTagByName(String tagName) {
		return dao.getConceptNameTagByName(tagName);
	}
	@Override
	@Transactional(readOnly = true)
	public Set<Locale> getLocalesOfConceptNames() {
		return dao.getLocalesOfConceptNames();
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptSource getConceptSource(Integer conceptSourceId) {
		return dao.getConceptSource(conceptSourceId);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptSource> getAllConceptSources(boolean includeRetired) {
		return dao.getAllConceptSources(includeRetired);
	}
	@Override
	@CacheEvict(value = CONCEPT_IDS_BY_MAPPING_CACHE_NAME, allEntries = true)
	public ConceptSource purgeConceptSource(ConceptSource cs) throws APIException {
		return dao.deleteConceptSource(cs);
	}
	@Override
	public ConceptSource retireConceptSource(ConceptSource cs, String reason) throws APIException {
		return Context.getConceptService().saveConceptSource(cs);
	}
	@Override
	@CacheEvict(value = CONCEPT_IDS_BY_MAPPING_CACHE_NAME, allEntries = true)
	public ConceptSource saveConceptSource(ConceptSource conceptSource) throws APIException {
		return dao.saveConceptSource(conceptSource);
	}
	@Override
	public ConceptNameTag saveConceptNameTag(ConceptNameTag nameTag) {
		checkIfLocked();
		return dao.saveConceptNameTag(nameTag);
	}
	@Override
	@Transactional(readOnly = true)
	public Iterator<Concept> conceptIterator() {
		return dao.conceptIterator();
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getConceptByUuid(String uuid) {
		return dao.getConceptByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptClass getConceptClassByUuid(String uuid) {
		return dao.getConceptClassByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptAnswer getConceptAnswerByUuid(String uuid) {
		return dao.getConceptAnswerByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptName getConceptNameByUuid(String uuid) {
		return dao.getConceptNameByUuid(uuid);
	}
	@Override
	public ConceptSet getConceptSetByUuid(String uuid) {
		return dao.getConceptSetByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptSource getConceptSourceByUuid(String uuid) {
		return dao.getConceptSourceByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptDatatype getConceptDatatypeByUuid(String uuid) {
		return dao.getConceptDatatypeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptNumeric getConceptNumericByUuid(String uuid) {
		return dao.getConceptNumericByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptProposal getConceptProposalByUuid(String uuid) {
		return dao.getConceptProposalByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public Drug getDrugByUuid(String uuid) {
		return dao.getDrugByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public DrugIngredient getDrugIngredientByUuid(String uuid) {
		return dao.getDrugIngredientByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptDescription getConceptDescriptionByUuid(String uuid) {
		return dao.getConceptDescriptionByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptNameTag getConceptNameTagByUuid(String uuid) {
		return dao.getConceptNameTagByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptNameTag> getAllConceptNameTags() {
		return dao.getAllConceptNameTags();
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptNameTag getConceptNameTag(Integer id) {
		return dao.getConceptNameTag(id);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getConceptByMapping(String code, String sourceName) throws APIException {
		return Context.getConceptService().getConceptByMapping(code, sourceName, true);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getConceptByMapping(String code, String sourceName, Boolean includeRetired) throws APIException {
		List<Concept> concepts = Context.getConceptService().getConceptsByMapping(code, sourceName, includeRetired);
		if (concepts.isEmpty()) {
			return null;
		}
		else if (concepts.size() > 1 && !concepts.get(1).getRetired()) {
			throw new APIException("Concept.error.multiple.non.retired", new Object[] { code, sourceName });
		} else {
			return concepts.get(0);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getConceptsByMapping(String code, String sourceName) throws APIException {
		return Context.getConceptService().getConceptsByMapping(code, sourceName, true);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getConceptsByMapping(String code, String sourceName, boolean includeRetired) throws APIException {
		List<Concept> concepts = new ArrayList<>();
		for (Integer conceptId : Context.getConceptService().getConceptIdsByMapping(code, sourceName, includeRetired)) {
			concepts.add(getConcept(conceptId));
		}
		return concepts;
	}
	@Override
	@Transactional(readOnly = true)
	@Cacheable(value = CONCEPT_IDS_BY_MAPPING_CACHE_NAME)
	public List<Integer> getConceptIdsByMapping(String code, String sourceName, boolean includeRetired) throws APIException {
		return dao.getConceptIdsByMapping(code, sourceName, includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getFalseConcept() {
		if (falseConcept == null) {
			setBooleanConcepts();
		}
		return falseConcept;
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getTrueConcept() {
		if (trueConcept == null) {
			setBooleanConcepts();
		}
		return trueConcept;
	}
	@Override
	@Transactional(readOnly = true)
	public Concept getUnknownConcept() {
		if (unknownConcept == null) {
			try {
				Concept unknownConcept = Context.getConceptService().getConcept(
					Integer.parseInt(Context.getAdministrationService().getGlobalProperty(
						OpenmrsConstants.GLOBAL_PROPERTY_UNKNOWN_CONCEPT)));
				initializeLazyPropertiesForConcept(unknownConcept);
				ConceptServiceImpl.setStaticUnknownConcept(unknownConcept);
			}
			catch (NumberFormatException e) {
				log.warn("Concept id for unknown concept should be a number");
			}
		}
		return unknownConcept;
	}
	private static void setStaticUnknownConcept(Concept currentUnknownConcept) {
		ConceptServiceImpl.unknownConcept = currentUnknownConcept;
	}
	private void setBooleanConcepts() {
		try {
			trueConcept = Context.getConceptService().getConcept(
			    Integer.parseInt(Context.getAdministrationService().getGlobalProperty(
			        OpenmrsConstants.GLOBAL_PROPERTY_TRUE_CONCEPT)));
			initializeLazyPropertiesForConcept(trueConcept);
			falseConcept = Context.getConceptService().getConcept(
			    Integer.parseInt(Context.getAdministrationService().getGlobalProperty(
			        OpenmrsConstants.GLOBAL_PROPERTY_FALSE_CONCEPT)));
			initializeLazyPropertiesForConcept(falseConcept);
		}
		catch (NumberFormatException e) {
			log.warn("Concept ids for boolean concepts should be numbers");
		}
	}
	private void initializeLazyPropertiesForConcept(Concept concept) {
		Hibernate.initialize(concept.getRetiredBy());
		Hibernate.initialize(concept.getCreator());
		Hibernate.initialize(concept.getChangedBy());
		Hibernate.initialize(concept.getNames());
		Hibernate.initialize(concept.getAnswers());
		Hibernate.initialize(concept.getConceptSets());
		Hibernate.initialize(concept.getDescriptions());
		Hibernate.initialize(concept.getConceptMappings());
		Hibernate.initialize(concept.getAttributes());
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptSource getConceptSourceByName(String conceptSourceName) throws APIException {
		return dao.getConceptSourceByName(conceptSourceName);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptSource getConceptSourceByUniqueId(String uniqueId) throws APIException {
		if (uniqueId == null) {
			throw new IllegalArgumentException("uniqueId is required");
		}
		return dao.getConceptSourceByUniqueId(uniqueId);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptSource getConceptSourceByHL7Code(String hl7Code) throws APIException {
		if (hl7Code == null) {
			throw new IllegalArgumentException("hl7Code is required");
		}
		return dao.getConceptSourceByHL7Code(hl7Code);
	}
	private void checkIfDatatypeCanBeChanged(Concept concept) {
		if (concept.getId() != null && hasAnyObservation(concept) && hasDatatypeChanged(concept)) {
			if (!(dao.getSavedConceptDatatype(concept).isBoolean() && concept.getDatatype().isCoded())) {
				throw new ConceptInUseException();
			}
			log.debug("Converting datatype of concept with id {} from Boolean to coded", concept.getConceptId());
		}
	}
	private boolean hasDatatypeChanged(Concept concept) {
		ConceptDatatype oldConceptDatatype = dao.getSavedConceptDatatype(concept);
		return !oldConceptDatatype.equals(concept.getDatatype());
	}
	@Override
	@Transactional(readOnly = true)
	public boolean hasAnyObservation(Concept concept) {
		List<Concept> concepts = new ArrayList<>();
		concepts.add(concept);
		Integer count = Context.getObsService().getObservationCount(null, null, concepts, null, null, null, null, null,
		    null, true);
		return count > 0;
	}
	@Override
	public void convertBooleanConceptToCoded(Concept conceptToChange) throws APIException {
		if (conceptToChange != null) {
			if (!conceptToChange.getDatatype().isBoolean()) {
				throw new APIException("Concept.datatype.invalid", (Object[]) null);
			}
			conceptToChange.setDatatype(getConceptDatatypeByName("Coded"));
			conceptToChange.addAnswer(new ConceptAnswer(getTrueConcept()));
			conceptToChange.addAnswer(new ConceptAnswer(getFalseConcept()));
			Context.getConceptService().saveConcept(conceptToChange);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public boolean hasAnyObservation(ConceptName conceptName) throws APIException {
		List<ConceptName> conceptNames = new ArrayList<>();
		conceptNames.add(conceptName);
		Integer count = Context.getObsService().getObservationCount(conceptNames, true);
		return count > 0;
	}
	private boolean hasNameChanged(ConceptName conceptName) {
		String newName = conceptName.getName();
		String oldName = dao.getSavedConceptName(conceptName).getName();
		return !oldName.equalsIgnoreCase(newName);
	}
	private ConceptName cloneConceptName(ConceptName conceptName) {
		ConceptName copy = new ConceptName();
		try {
			copy = (ConceptName) BeanUtils.cloneBean(conceptName);
		}
		catch (IllegalAccessException | NoSuchMethodException | InvocationTargetException | InstantiationException e) {
			log.warn(ERROR_MESSAGE, e);
		}
		return copy;
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptSearchResult> findConceptAnswers(String phrase, Locale locale, Concept concept) throws APIException {
		return getConcepts(phrase, Collections.singletonList(locale), false, null, null, null, null,
		    concept, null, null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<String> getConceptStopWords(Locale locale) {
		return dao.getConceptStopWords(locale);
	}
	@Override
	public ConceptStopWord saveConceptStopWord(ConceptStopWord conceptStopWord) throws APIException {
		try {
			return dao.saveConceptStopWord(conceptStopWord);
		}
		catch (DAOException e) {
			if ("Duplicate ConceptStopWord Entry".equalsIgnoreCase(e.getMessage())) {
				throw new ConceptStopWordException("ConceptStopWord.duplicated", e);
			}
			throw new ConceptStopWordException("ConceptStopWord.notSaved", e);
		}
	}
	@Override
	public void deleteConceptStopWord(Integer conceptStopWordId) throws APIException {
		try {
			dao.deleteConceptStopWord(conceptStopWordId);
		}
		catch (DAOException e) {
			if (StringUtils.contains(e.getMessage(), "Concept Stop Word not found or already deleted")) {
				throw new ConceptStopWordException("ConceptStopWord.error.notfound", e);
			}
			throw new ConceptStopWordException("general.cannot.delete", e);
		}
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptStopWord> getAllConceptStopWords() {
		return dao.getAllConceptStopWords();
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptSearchResult> getConcepts(String phrase, List<Locale> locales, boolean includeRetired,
	        List<ConceptClass> requireClasses, List<ConceptClass> excludeClasses, List<ConceptDatatype> requireDatatypes,
	        List<ConceptDatatype> excludeDatatypes, Concept answersToConcept, Integer start, Integer size)
	        throws APIException {
		List<ConceptClass> tmpRequireClasses = requireClasses == null ? new ArrayList<>() : requireClasses;
		List<ConceptClass> tmpExcludeClasses = excludeClasses == null ? new ArrayList<>() : excludeClasses;
		List<ConceptDatatype> tmpRequireDatatypes = requireDatatypes == null ? new ArrayList<>() : requireDatatypes;
		List<ConceptDatatype> tmpExcludeDatatypes = excludeDatatypes == null ? new ArrayList<>() : excludeDatatypes;
		return dao.getConcepts(phrase, locales, includeRetired, tmpRequireClasses, tmpExcludeClasses, tmpRequireDatatypes,
		    tmpExcludeDatatypes, answersToConcept, start, size);
	}
	@Override
	public void updateConceptIndex(Concept concept) throws APIException {
		Context.updateSearchIndexForObject(concept);
	}
	@Override
	@CacheEvict(value = CONCEPT_IDS_BY_MAPPING_CACHE_NAME, allEntries = true)
	public void updateConceptIndexes() throws APIException {
		Context.updateSearchIndexForType(ConceptName.class);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfConcepts(String phrase, List<Locale> locales, boolean includeRetired,
	        List<ConceptClass> requireClasses, List<ConceptClass> excludeClasses, List<ConceptDatatype> requireDatatypes,
	        List<ConceptDatatype> excludeDatatypes, Concept answersToConcept) {
		List<ConceptClass> tmpRequireClasses = requireClasses == null ? new ArrayList<>() : requireClasses;
		List<ConceptClass> tmpExcludeClasses = excludeClasses == null ? new ArrayList<>() : excludeClasses;
		List<ConceptDatatype> tmpRequireDatatypes = requireDatatypes == null ? new ArrayList<>() : requireDatatypes;
		List<ConceptDatatype> tmpExcludeDatatypes = excludeDatatypes == null ? new ArrayList<>() : excludeDatatypes;
		return dao.getCountOfConcepts(phrase, locales, includeRetired, tmpRequireClasses, tmpExcludeClasses, tmpRequireDatatypes,
		    tmpExcludeDatatypes, answersToConcept);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfDrugs(String drugName, Concept concept, boolean searchOnPhrase, boolean searchDrugConceptNames,
	        boolean includeRetired) throws APIException {
		return OpenmrsUtil.convertToInteger(dao.getCountOfDrugs(drugName, concept, searchOnPhrase, searchDrugConceptNames,
		    includeRetired));
	}
	@Override
	@Transactional(readOnly = true)
	public List<Drug> getDrugs(String drugName, Concept concept, boolean searchOnPhrase, boolean searchDrugConceptNames,
	        boolean includeRetired, Integer start, Integer length) throws APIException {
		return dao.getDrugs(drugName, concept, searchOnPhrase, searchDrugConceptNames, includeRetired, start, length);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptSearchResult> getConcepts(String phrase, Locale locale, boolean includeRetired) throws APIException {
		List<Locale> locales = new ArrayList<>();
		if (locale != null) {
			locales.add(locale);
		}
		return Context.getConceptService().getConcepts(phrase, locales, includeRetired, null, null, null, null, null, null,
		    null);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Drug> getDrugsByIngredient(Concept ingredient) throws APIException {
		if (ingredient == null) {
			throw new IllegalArgumentException("ingredient is required");
		}
		return dao.getDrugsByIngredient(ingredient);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptMap> getConceptMappingsToSource(ConceptSource conceptSource) throws APIException {
		return dao.getConceptMapsBySource(conceptSource);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptMapType> getActiveConceptMapTypes() throws APIException {
		return Context.getConceptService().getConceptMapTypes(true, false);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptMapType> getConceptMapTypes(boolean includeRetired, boolean includeHidden) throws APIException {
		return dao.getConceptMapTypes(includeRetired, includeHidden);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptMapType getConceptMapType(Integer conceptMapTypeId) throws APIException {
		return dao.getConceptMapType(conceptMapTypeId);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptMapType getConceptMapTypeByUuid(String uuid) throws APIException {
		return dao.getConceptMapTypeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptMapType getConceptMapTypeByName(String name) throws APIException {
		return dao.getConceptMapTypeByName(name);
	}
	@Override
	public ConceptMapType saveConceptMapType(ConceptMapType conceptMapType) throws APIException {
		return dao.saveConceptMapType(conceptMapType);
	}
	@Override
	public ConceptMapType retireConceptMapType(ConceptMapType conceptMapType, String retireReason) throws APIException {
		String tmpRetireReason = retireReason;
		if (StringUtils.isBlank(tmpRetireReason)) {
			tmpRetireReason = Context.getMessageSourceService().getMessage("general.default.retireReason");
		}
		conceptMapType.setRetireReason(tmpRetireReason);
		return dao.saveConceptMapType(conceptMapType);
	}
	@Override
	public ConceptMapType unretireConceptMapType(ConceptMapType conceptMapType) throws APIException {
		return Context.getConceptService().saveConceptMapType(conceptMapType);
	}
	@Override
	public void purgeConceptMapType(ConceptMapType conceptMapType) throws APIException {
		if (dao.isConceptMapTypeInUse(conceptMapType)) {
			throw new APIException("ConceptMapType.inUse", (Object[]) null);
		}
		dao.deleteConceptMapType(conceptMapType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptReferenceTerm> getAllConceptReferenceTerms() throws APIException {
		return Context.getConceptService().getConceptReferenceTerms(true);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptReferenceTerm> getConceptReferenceTerms(boolean includeRetired) throws APIException {
		return dao.getConceptReferenceTerms(includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptReferenceTerm getConceptReferenceTerm(Integer conceptReferenceTermId) throws APIException {
		return dao.getConceptReferenceTerm(conceptReferenceTermId);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptReferenceTerm getConceptReferenceTermByUuid(String uuid) throws APIException {
		return dao.getConceptReferenceTermByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptReferenceTerm getConceptReferenceTermByName(String name, ConceptSource conceptSource) throws APIException {
		if (StringUtils.isBlank(name)) {
			return null;
		}
		return dao.getConceptReferenceTermByName(name, conceptSource);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptReferenceTerm getConceptReferenceTermByCode(String code, ConceptSource conceptSource) throws APIException {
		return dao.getConceptReferenceTermByCode(code, conceptSource);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptReferenceTerm> getConceptReferenceTermByCode(String code, ConceptSource conceptSource, boolean includeRetired) throws APIException {
		return dao.getConceptReferenceTermByCode(code, conceptSource, includeRetired);
	}
	@Override
	@CacheEvict(value = CONCEPT_IDS_BY_MAPPING_CACHE_NAME, allEntries = true)
	public ConceptReferenceTerm saveConceptReferenceTerm(ConceptReferenceTerm conceptReferenceTerm) throws APIException {
		return dao.saveConceptReferenceTerm(conceptReferenceTerm);
	}
	@Override
	public ConceptReferenceTerm retireConceptReferenceTerm(ConceptReferenceTerm conceptReferenceTerm, String retireReason)
	        throws APIException {
		String tmpRetireReason = retireReason;
		if (StringUtils.isBlank(tmpRetireReason)) {
			tmpRetireReason = Context.getMessageSourceService().getMessage("general.default.retireReason");
		}
		conceptReferenceTerm.setRetireReason(tmpRetireReason);
		return Context.getConceptService().saveConceptReferenceTerm(conceptReferenceTerm);
	}
	@Override
	public ConceptReferenceTerm unretireConceptReferenceTerm(ConceptReferenceTerm conceptReferenceTerm) throws APIException {
		return Context.getConceptService().saveConceptReferenceTerm(conceptReferenceTerm);
	}
	@Override
	@CacheEvict(value = CONCEPT_IDS_BY_MAPPING_CACHE_NAME, allEntries = true)
	public void purgeConceptReferenceTerm(ConceptReferenceTerm conceptReferenceTerm) throws APIException {
		if (dao.isConceptReferenceTermInUse(conceptReferenceTerm)) {
			throw new APIException("ConceptRefereceTerm.inUse", (Object[]) null);
		}
		dao.deleteConceptReferenceTerm(conceptReferenceTerm);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptReferenceTerm> getConceptReferenceTerms(String query, ConceptSource conceptSource, Integer start,
	        Integer length, boolean includeRetired) throws APIException {
		Integer tmpLength = length;
		if (tmpLength == null) {
			tmpLength = 10000;
		}
		return dao.getConceptReferenceTerms(query, conceptSource, start, tmpLength, includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public Integer getCountOfConceptReferenceTerms(String query, ConceptSource conceptSource, boolean includeRetired) {
		return OpenmrsUtil.convertToInteger(dao.getCountOfConceptReferenceTerms(query, conceptSource, includeRetired));
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptReferenceTermMap> getReferenceTermMappingsTo(ConceptReferenceTerm term) throws APIException {
		return dao.getReferenceTermMappingsTo(term);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Concept> getConceptsByName(String name, Locale locale, Boolean exactLocale) throws APIException {
		return dao.getConceptsByName(name, locale, exactLocale);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptMapType getDefaultConceptMapType() throws APIException {
		return dao.getDefaultConceptMapType();
	}
	@Override
	public boolean isConceptNameDuplicate(ConceptName name) {
		return dao.isConceptNameDuplicate(name);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Drug> getDrugs(String searchPhrase, Locale locale, boolean exactLocale, boolean includeRetired)
	        throws APIException {
		if (searchPhrase == null) {
			throw new IllegalArgumentException("searchPhrase is required");
		}
		return dao.getDrugs(searchPhrase, locale, exactLocale, includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public List<Drug> getDrugsByMapping(String code, ConceptSource conceptSource,
	        Collection<ConceptMapType> withAnyOfTheseTypes, boolean includeRetired) throws APIException {
		Collection<ConceptMapType> tmpWithAnyOfTheseTypes = withAnyOfTheseTypes == null ? Collections.emptyList() : withAnyOfTheseTypes;
		if (conceptSource == null) {
			throw new APIException("ConceptSource.is.required", (Object[]) null);
		}
		return dao.getDrugsByMapping(code, conceptSource, tmpWithAnyOfTheseTypes, includeRetired);
	}
	@Override
	@Transactional(readOnly = true)
	public Drug getDrugByMapping(String code, ConceptSource conceptSource,
	        Collection<ConceptMapType> withAnyOfTheseTypesOrOrderOfPreference) throws APIException {
		Collection<ConceptMapType> tmpWithAnyOfTheseTypesOrOrderOfPreference = withAnyOfTheseTypesOrOrderOfPreference == null
				? Collections.emptyList() : withAnyOfTheseTypesOrOrderOfPreference;
		if (conceptSource == null) {
			throw new APIException("ConceptSource.is.required", (Object[]) null);
		}
		return dao.getDrugByMapping(code, conceptSource, tmpWithAnyOfTheseTypesOrOrderOfPreference);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptSearchResult> getOrderableConcepts(String phrase, List<Locale> locales, boolean includeRetired,
	        Integer start, Integer length) {
		List<ConceptClass> mappedClasses = getConceptClassesOfOrderTypes();
		if (mappedClasses.isEmpty()) {
			return Collections.emptyList();
		}
		List<Locale> tmpLocales = locales;
		if (tmpLocales == null) {
			tmpLocales = new ArrayList<>();
			tmpLocales.add(Context.getLocale());
		}
		return dao.getConcepts(phrase, tmpLocales, false, mappedClasses, Collections.emptyList(), Collections.emptyList(),
		    Collections.emptyList(), null, start, length);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptAttributeType> getAllConceptAttributeTypes() {
		return dao.getAllConceptAttributeTypes();
	}
	@Override
	public ConceptAttributeType saveConceptAttributeType(ConceptAttributeType conceptAttributeType) {
		return dao.saveConceptAttributeType(conceptAttributeType);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptAttributeType getConceptAttributeType(Integer id) {
		return dao.getConceptAttributeType(id);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptAttributeType getConceptAttributeTypeByUuid(String uuid) {
		return dao.getConceptAttributeTypeByUuid(uuid);
	}
	@Override
	public void purgeConceptAttributeType(ConceptAttributeType conceptAttributeType) {
		dao.deleteConceptAttributeType(conceptAttributeType);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptAttributeType> getConceptAttributeTypes(String name) throws APIException {
		return dao.getConceptAttributeTypes(name);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptAttributeType getConceptAttributeTypeByName(String exactName) {
		return dao.getConceptAttributeTypeByName(exactName);
	}
	@Override
	public ConceptAttributeType retireConceptAttributeType(ConceptAttributeType conceptAttributeType, String reason) {
		return dao.saveConceptAttributeType(conceptAttributeType);
	}
	@Override
	public ConceptAttributeType unretireConceptAttributeType(ConceptAttributeType conceptAttributeType) {
		return Context.getConceptService().saveConceptAttributeType(conceptAttributeType);
	}
	@Override
	@Transactional(readOnly = true)
	public ConceptAttribute getConceptAttributeByUuid(String uuid) {
		return dao.getConceptAttributeByUuid(uuid);
	}
	@Override
	@Transactional(readOnly = true)
	public boolean hasAnyConceptAttribute(ConceptAttributeType conceptAttributeType) {
		return dao.getConceptAttributeCount(conceptAttributeType) > 0;
	}
	@Override
	public ConceptReferenceRange saveConceptReferenceRange(ConceptReferenceRange conceptReferenceRange) {
		return dao.saveConceptReferenceRange(conceptReferenceRange);
	}
	@Override
	@Transactional(readOnly = true)
	public List<ConceptReferenceRange> getConceptReferenceRangesByConceptId(Integer conceptId) {
		return dao.getConceptReferenceRangesByConceptId(conceptId);
	}
	@Override
	public ConceptReferenceRange getConceptReferenceRangeByUuid(String uuid) {
		return dao.getConceptReferenceRangeByUuid(uuid);
	}
	public static boolean isValidUuidFormat(String uuid) {
		if (uuid.length() < 36 || uuid.length() > 38 || uuid.contains(" ") || uuid.contains(".")) {
			return false;
		}
		return true;
	}
	private static String evaluateStaticConstant(String fqn) {
		int lastPeriod = fqn.lastIndexOf(".");
		String clazzName = fqn.substring(0, lastPeriod);
		String constantName = fqn.substring(lastPeriod + 1);
		try {
			Class<?> clazz = Context.loadClass(clazzName);
			Field constantField = clazz.getDeclaredField(constantName);
			constantField.setAccessible(true);
			Object val = constantField.get(null);
			return val != null ? String.valueOf(val) : null;
		}
		catch (Exception ex) {
			throw new APIException("Error while evaluating " + fqn + " as a constant" , ex);
		}
	}
	private List<ConceptClass> getConceptClassesOfOrderTypes() {
		List<ConceptClass> mappedClasses = new ArrayList<>();
		AdministrationService administrationService = Context.getAdministrationService();
		List<List<Object>> result = administrationService.executeSQL(
		    "SELECT DISTINCT concept_class_id FROM order_type_class_map", true);
		for (List<Object> temp : result) {
			for (Object value : temp) {s
				if (value != null) {
					mappedClasses.add(this.getConceptClass((Integer) value));
				}
			}
		}
		return mappedClasses;
	}
}