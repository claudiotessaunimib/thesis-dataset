/*
 * This file is part of the PDF Split And Merge source code
 * Created on 07/apr/2014
 * Copyright 2017 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.tools.splitbybookmarks;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.RequiredPdfData;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
import static org.pdfsam.ui.components.io.PdfDestinationPane.DestinationPanelFields.DISCARD_BOOKMARKS;
/**
 * Module to split a given PDF document based on bookmarks levels
 *
 * @author Andrea Vacondio
 */
@Auto
public class SplitByBookmarksTool implements Tool {
    static final String TOOL_ID = "split.bybookmarks";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.SPLIT)
            .inputTypes(ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Split by bookmarks"))
            .description(i18n().tr("Split a PDF document at bookmarked pages by specifying a bookmark level."))
            .priority(ToolPriority.DEFAULT.getPriority()).supportURL("https://pdfsam.org/pdf-split/")
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Pane panel() {
        return app().instance(SplitByBookmarksToolPanel.class);
    }
    @Override
    public RequiredPdfData[] requires() {
        return new RequiredPdfData[] { RequiredPdfData.DEFAULT, RequiredPdfData.BOOMARKS };
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.FILE_BOOKMARK_ALT);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            return new BrowsableOutputDirectoryField();
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            PdfDestinationPane panel = new PdfDestinationPane(outputField, TOOL_ID, DISCARD_BOOKMARKS);
            panel.enableSameAsSourceItem();
            return panel;
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 13/dic/2011
 * Copyright 2017 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.i18n;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ObservableValue;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.Optional;
import java.util.ResourceBundle;
import java.util.Set;
import static java.util.Objects.nonNull;
import static java.util.Optional.empty;
import static java.util.Optional.ofNullable;
import static org.pdfsam.eventstudio.StaticStudio.eventStudio;
/**
 * Context to deal with translations. It contains information about the mutable current locale and allow to translate strings to the current locale through static methods.
 *
 * @author Andrea Vacondio
 */
public final class I18nContext {
    private static final Logger LOG = LoggerFactory.getLogger(I18nContext.class);
    private final Set<Locale> supported = Set.of(Locale.of("af"), Locale.of("bs"), Locale.of("bg"), Locale.of("el"),
            Locale.of("eu"), Locale.of("pt", "BR"), Locale.SIMPLIFIED_CHINESE, Locale.TRADITIONAL_CHINESE,
            Locale.of("co"), Locale.of("ca"), Locale.of("hr"), Locale.of("cs"), Locale.of("da"), Locale.of("nl"),
            Locale.UK, Locale.FRENCH, Locale.GERMAN, Locale.of("he"), Locale.of("hi"), Locale.of("hu"), Locale.JAPANESE,
            Locale.ITALIAN, Locale.of("pl"), Locale.of("pt"), Locale.of("ro"), Locale.of("ru"), Locale.of("sk"),
            Locale.of("sl"), Locale.of("sr"), Locale.of("sv"), Locale.of("es"), Locale.of("tr"), Locale.of("uk"),
            Locale.of("fi"), Locale.of("ko"), Locale.of("oc"));
    private final SimpleObjectProperty<Locale> locale = new SimpleObjectProperty<>();
    private Optional<ResourceBundle> bundle = empty();
    I18nContext() {
        eventStudio().addAnnotatedListeners(this);
        locale.subscribe(this::loadBundles);
    }
    @EventListener
    public void setLocale(SetLocaleRequest e) {
        if (nonNull(e.languageTag()) && !e.languageTag().isBlank()) {
            LOG.trace("Setting locale to {}", e.languageTag());
            ofNullable(Locale.forLanguageTag(e.languageTag())).filter(supported::contains).ifPresent(locale::set);
        }
    }
    private void loadBundles(Locale l) {
        if (nonNull(l)) {
            Locale.setDefault(l);
            LOG.trace("Loading i18n bundle for {}", Locale.getDefault());
            try {
                this.bundle = ofNullable(ResourceBundle.getBundle("org.pdfsam.i18n.Messages", Locale.getDefault(),
                        I18nContext.class.getModule()));
                LOG.debug("Locale set to {}", Locale.getDefault());
            } catch (Exception e) {
                LOG.error("Unable to load translations bundle", e);
            }
        }
    }
    Locale getBestLocale() {
        if (supported.contains(Locale.getDefault())) {
            LOG.trace("Using best matching locale: {}", Locale.getDefault());
            return Locale.getDefault();
        }
        var onlyLanguage = Locale.of(Locale.getDefault().getLanguage());
        if (supported.contains(onlyLanguage)) {
            LOG.trace("Using supported locale closest to default {}", onlyLanguage);
            return onlyLanguage;
        }
        LOG.trace("Using fallback locale");
        return Locale.ENGLISH;
    }
    /**
     * @return the default {@link I18nContext} instance
     */
    public static I18nContext i18n() {
        return I18nContextHolder.CONTEXT;
    }
    /**
     * @return an {@link ObservableValue} {@link Locale} representing the current locale
     */
    public ObservableValue<Locale> locale() {
        return this.locale;
    }
    public String tr(String text) {
        initBundleIfRequired();
        return bundle.filter(r -> r.containsKey(text)).map(r -> r.getString(text)).orElse(text);
    }
    /**
     * @param text    text to be translated
     * @param replace replacements for the placeholders
     * @return the translated string where {0} and {1} (etc) placeholders are replaced by the replace[0], replace[1] etc
     */
    public String tr(String text, String... replace) {
        initBundleIfRequired();
        return MessageFormat.format(tr(text), (Object[]) replace);
    }
    private void initBundleIfRequired() {
        if (bundle.isEmpty()) {
            locale.set(getBestLocale());
        }
    }
    public Set<Locale> getSupported() {
        return supported;
    }
    /**
     * Lazy initialization holder class idiom (Joshua Bloch, Effective Java second edition, item 71).
     *
     * @author Andrea Vacondio
     */
    private static final class I18nContextHolder {
        private I18nContextHolder() {
            // hide constructor
        }
        static final I18nContext CONTEXT = new I18nContext();
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 15/ott/2013
 * Copyright 2017 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.ui.components.prefix;
import javafx.scene.control.ContextMenu;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextField;
import org.sejda.model.prefix.Prefix;
import static java.util.Optional.ofNullable;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.sejda.commons.util.RequireUtils.requireNotBlank;
/**
 * Text field providing PDFsam complex prefix functionalities (context menu to automatically set prefix values)
 * 
 * @author Andrea Vacondio
 * 
 */
public class PrefixField extends TextField {
    private final Menu menu;
    public PrefixField() {
        this.setPromptText(i18n().tr("Prefix for the generated files names"));
        this.menu = new Menu(i18n().tr("Add prefix"));
        this.menu.setId("addPrefixMenu");
        this.menu.getItems().addAll(new PrefixMenuItem(Prefix.TIMESTAMP), new PrefixMenuItem(Prefix.BASENAME));
        this.setContextMenu(new ContextMenu(this.menu));
        setPrefWidth(300);
    }
    /**
     * Adds a {@link MenuItem} for the given prefixes to the context menu. By default {@link Prefix#TIMESTAMP} and {@link Prefix#BASENAME} are always there, adding them again will
     * result in a duplication.
     * 
     * @param prefixes
     */
    public void addMenuItemFor(Prefix... prefixes) {
        for (Prefix current : prefixes) {
            this.menu.getItems().add(new PrefixMenuItem(current));
        }
    }
    /**
     * Adds a {@link MenuItem} for the given prefixes to the context menu. By default {@link Prefix#TIMESTAMP} and {@link Prefix#BASENAME} are always there, adding them again will
     * 
     * @param prefixes
     */
    public void addMenuItemFor(String... prefixes) {
        for (String current : prefixes) {
            this.menu.getItems().add(new PrefixMenuItem(current));
        }
    }
    /**
     * Menu item adding a Sejda prefix to the {@link TextField}, possibly replacing current selection.
     * 
     * @author Andrea Vacondio
     * 
     */
    private final class PrefixMenuItem extends MenuItem {
        private PrefixMenuItem(Prefix prefix) {
            this(ofNullable(prefix).map(Prefix::getFriendlyName)
                    .orElseThrow(() -> new IllegalArgumentException("Prefix cannot be null")));
        }
        private PrefixMenuItem(String prefix) {
            requireNotBlank(prefix, "Prefix cannot be blank");
            setText(prefix);
            setOnAction(e -> replaceSelection(prefix));
            this.setMnemonicParsing(false);
        }
    }
}
package org.pdfsam.tools.split;
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 03/10/22
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.VBox;
import org.apache.commons.lang3.builder.Builder;
import org.pdfsam.core.support.params.SinglePdfSourceMultipleOutputParametersBuilder;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.selection.single.TaskParametersBuilderSingleSelectionPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.parameter.AbstractSplitByPageParameters;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.split.SplitTool.TOOL_ID;
/**
 * @author Andrea Vacondio
 */
public class SplitToolPanel extends BaseToolPanel {
    private final TaskParametersBuilderSingleSelectionPane selectionPane;
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final SplitOptionsPane splitOptions = new SplitOptionsPane();
    private final PrefixPane prefix;
    @Inject
    public SplitToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.selectionPane = new TaskParametersBuilderSingleSelectionPane(id());
        this.selectionPane.setPromptText(i18n().tr("Select or drag and drop the PDF you want to split"));
        this.selectionPane.addOnLoaded(d -> splitOptions.setMaxPages(d.pages().getValue()));
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        splitOptions.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        destinationPane.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        selectionPane.restoreStateFrom(data);
        splitOptions.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    @Override
    protected Builder<? extends AbstractSplitByPageParameters> getBuilder(Consumer<String> onError) {
        Optional<SinglePdfSourceMultipleOutputParametersBuilder<? extends AbstractSplitByPageParameters>> builder = Optional.ofNullable(
                splitOptions.getBuilder(onError));
        builder.ifPresent(b -> {
            selectionPane.apply(b, onError);
            destinationDirectoryField.apply(b, onError);
            destinationPane.apply(b, onError);
            prefix.apply(b, onError);
        });
        return builder.orElse(null);
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.CURRENTPAGE);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        pane.getChildren().addAll(selectionPane, Views.titledPane(i18n().tr("Split settings"), splitOptions),
                Views.titledPane(i18n().tr("Output settings"), destinationPane), prefixTitled);
        return pane;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            splitOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
}
package org.pdfsam.tools.splitbysize;
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 03/10/22
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.VBox;
import org.apache.commons.lang3.builder.Builder;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.selection.single.TaskParametersBuilderSingleSelectionPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.parameter.SplitBySizeParameters;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.splitbysize.SplitBySizeTool.TOOL_ID;
/**
 * @author Andrea Vacondio
 */
public class SplitBySizeToolPanel extends BaseToolPanel {
    private final TaskParametersBuilderSingleSelectionPane selectionPane;
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final SplitOptionsPane splitOptions = new SplitOptionsPane();
    private final PrefixPane prefix;
    @Inject
    public SplitBySizeToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.selectionPane = new TaskParametersBuilderSingleSelectionPane(id());
        this.selectionPane.setPromptText(i18n().tr("Select or drag and drop the PDF you want to split"));
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        splitOptions.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        destinationPane.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        selectionPane.restoreStateFrom(data);
        splitOptions.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    @Override
    protected Builder<SplitBySizeParameters> getBuilder(Consumer<String> onError) {
        SplitBySizeParametersBuilder builder = new SplitBySizeParametersBuilder();
        splitOptions.apply(builder, onError);
        selectionPane.apply(builder, onError);
        destinationDirectoryField.apply(builder, onError);
        destinationPane.apply(builder, onError);
        prefix.apply(builder, onError);
        return builder;
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.CURRENTPAGE);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        pane.getChildren().addAll(selectionPane, Views.titledPane(i18n().tr("Split settings"), splitOptions),
                Views.titledPane(i18n().tr("Output settings"), destinationPane), prefixTitled);
        return pane;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            splitOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 07/apr/2014
 * Copyright 2017 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.tools.splitbysize;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
import static org.pdfsam.ui.components.io.PdfDestinationPane.DestinationPanelFields.DISCARD_BOOKMARKS;
/**
 * Split by size module to let the user split a pdf documents into documents of the given size.
 *
 * @author Andrea Vacondio
 */
@Auto
public class SplitBySizeTool implements Tool {
    static final String TOOL_ID = "split.bysize";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.SPLIT)
            .inputTypes(ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Split by size"))
            .description(i18n().tr("Split a PDF document in files of the given size (roughly)."))
            .priority(ToolPriority.LOW.getPriority()).supportURL("https://pdfsam.org/pdf-split/")
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Pane panel() {
        return app().instance(SplitBySizeToolPanel.class);
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.ARROWS_RESIZE_H);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            BrowsableOutputDirectoryField field = new BrowsableOutputDirectoryField();
            field.setId(TOOL_ID + "field");
            return field;
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            PdfDestinationPane panel = new PdfDestinationPane(outputField, TOOL_ID, DISCARD_BOOKMARKS);
            panel.enableSameAsSourceItem();
            return panel;
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
package org.pdfsam.tools.splitbybookmarks;
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 03/10/22
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.VBox;
import org.apache.commons.lang3.builder.Builder;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.selection.single.TaskParametersBuilderSingleSelectionPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.parameter.SplitByOutlineLevelParameters;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.splitbybookmarks.SplitByBookmarksTool.TOOL_ID;
/**
 * @author Andrea Vacondio
 */
public class SplitByBookmarksToolPanel extends BaseToolPanel {
    private final TaskParametersBuilderSingleSelectionPane selectionPane;
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final SplitOptionsPane splitOptions = new SplitOptionsPane();
    private final PrefixPane prefix;
    @Inject
    public SplitByBookmarksToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.selectionPane = new TaskParametersBuilderSingleSelectionPane(id());
        this.selectionPane.setPromptText(i18n().tr("Select or drag and drop the PDF you want to split"));
        this.selectionPane.addOnLoaded(d -> splitOptions.setValidBookmarkLevels(d.getValidBookmarksLevels()));
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        splitOptions.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        destinationPane.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        selectionPane.restoreStateFrom(data);
        splitOptions.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    @Override
    protected Builder<SplitByOutlineLevelParameters> getBuilder(Consumer<String> onError) {
        SplitByOutlineLevelParametersBuilder builder = new SplitByOutlineLevelParametersBuilder();
        splitOptions.apply(builder, onError);
        selectionPane.apply(builder, onError);
        destinationDirectoryField.apply(builder, onError);
        destinationPane.apply(builder, onError);
        prefix.apply(builder, onError);
        return builder;
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.CURRENTPAGE);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor(Prefix.BOOKMARK);
        prefix.addMenuItemFor(Prefix.BOOKMARK_STRICT);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        pane.getChildren().addAll(selectionPane, Views.titledPane(i18n().tr("Split settings"), splitOptions),
                Views.titledPane(i18n().tr("Output settings"), destinationPane), prefixTitled);
        return pane;
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            splitOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 19/09/22
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.core.context;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ObservableValue;
import org.pdfsam.persistence.PersistenceException;
import org.pdfsam.persistence.PreferencesRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.Arrays;
import java.util.Optional;
import static java.util.Objects.nonNull;
import static java.util.Optional.empty;
import static java.util.Optional.of;
import static java.util.Optional.ofNullable;
import static org.sejda.commons.util.RequireUtils.requireNotNullArg;
/**
 * Persistent settings for the application
 *
 * @author Andrea Vacondio
 */
public class ApplicationPersistentSettings {
    private static final Logger LOG = LoggerFactory.getLogger(ApplicationPersistentSettings.class);
    private final PreferencesRepository repo;
    private final SimpleObjectProperty<PersistentPropertyChange<String>> stringSettingsChanges = new SimpleObjectProperty<>();
    private final SimpleObjectProperty<PersistentPropertyChange<Integer>> intSettingsChanges = new SimpleObjectProperty<>();
    private final SimpleObjectProperty<PersistentPropertyChange<Boolean>> boolSettingsChanges = new SimpleObjectProperty<>();
    ApplicationPersistentSettings(PreferencesRepository repo) {
        this.repo = repo;
    }
    /**
     * @param prop
     * @return the value for the given {@link StringPersistentProperty} or the default associated value
     */
    public Optional<String> get(StringPersistentProperty prop) {
        requireNotNullArg(prop, "Cannot get value for a null property");
        try {
            return ofNullable(this.repo.getString(prop.key(), prop.defaultSupplier()));
        } catch (PersistenceException e) {
            LOG.error("Unable to get persistent property: " + prop, e);
        }
        return ofNullable(prop.defaultSupplier().get());
    }
    /**
     * @param prop
     * @return the value of the given {@link IntegerPersistentProperty} or the default associated value
     */
    public int get(IntegerPersistentProperty prop) {
        requireNotNullArg(prop, "Cannot get value for a null property");
        try {
            return this.repo.getInt(prop.key(), prop.defaultSupplier());
        } catch (PersistenceException e) {
            LOG.error("Unable to get persistent property: " + prop, e);
        }
        return prop.defaultSupplier().get();
    }
    /**
     * @param prop
     * @return the value of the given {@link BooleanPersistentProperty} or the default associated value
     */
    public boolean get(BooleanPersistentProperty prop) {
        requireNotNullArg(prop, "Cannot get value for a null property");
        try {
            return this.repo.getBoolean(prop.key(), prop.defaultSupplier());
        } catch (NumberFormatException | PersistenceException e) {
            LOG.error("Unable to get persistent property: " + prop, e);
        }
        return prop.defaultSupplier().get();
    }
    /**
     * Persists the given String property key/value
     */
    public void set(StringPersistentProperty prop, String value) {
        requireNotNullArg(prop, "Cannot set value for a null property");
        try {
            this.repo.saveString(prop.key(), value);
            stringSettingsChanges.set(new PersistentPropertyChange<>(prop, ofNullable(value)));
        } catch (PersistenceException e) {
            LOG.error("Unable to save persistent property", e);
        }
    }
    /**
     * Persists the given Integer property key/value
     */
    public void set(IntegerPersistentProperty prop, int value) {
        requireNotNullArg(prop, "Cannot set value for a null property");
        try {
            this.repo.saveInt(prop.key(), value);
            intSettingsChanges.set(new PersistentPropertyChange<>(prop, of(value)));
        } catch (PersistenceException e) {
            LOG.error("Unable to save persistent property", e);
        }
    }
    /**
     * Persists the given Boolean property key/value
     */
    public void set(BooleanPersistentProperty prop, boolean value) {
        requireNotNullArg(prop, "Cannot set value for a null property");
        try {
            this.repo.saveBoolean(prop.key(), value);
            boolSettingsChanges.set(new PersistentPropertyChange<>(prop, of(value)));
        } catch (PersistenceException e) {
            LOG.error("Unable to save persistent property", e);
        }
    }
    /**
     * @param property
     * @return true if there is a value stored for the given persistent property
     */
    public boolean hasValueFor(PersistentProperty<?> property) {
        if (nonNull(property)) {
            return Arrays.stream(this.repo.keys()).anyMatch(k -> k.equals(property.key()));
        }
        return false;
    }
    /**
     * Deletes the value stored for the given property
     *
     * @param property
     */
    public void delete(PersistentProperty<?> property) {
        if (nonNull(property)) {
            this.repo.delete(property.key());
        }
    }
    /**
     * @return an observable for changes to the given property
     */
    public ObservableValue<Optional<String>> settingsChanges(StringPersistentProperty prop) {
        var value = new SimpleObjectProperty<Optional<String>>(empty());
        stringSettingsChanges.subscribe((old, c) -> {
            if (c.property().equals(prop)) {
                value.set(c.value());
            }
        });
        return value;
    }
    /**
     * @return an observable for changes to the given property
     */
    public ObservableValue<Optional<Integer>> settingsChanges(IntegerPersistentProperty prop) {
        var value = new SimpleObjectProperty<Optional<Integer>>(empty());
        intSettingsChanges.subscribe((old, c) -> {
            if (c.property().equals(prop)) {
                value.set(c.value());
            }
        });
        return value;
    }
    /**
     * @return an observable for changes to the given property
     */
    public ObservableValue<Optional<Boolean>> settingsChanges(BooleanPersistentProperty prop) {
        var value = new SimpleObjectProperty<Optional<Boolean>>(empty());
        boolSettingsChanges.subscribe((old, c) -> {
            if (c.property().equals(prop)) {
                value.set(c.value());
            }
        });
        return value;
    }
    /**
     * Clears all the persistent settings
     */
    public void clean() {
        try {
            this.repo.clean();
            LOG.info("Persistent application settings deleted");
        } catch (PersistenceException e) {
            LOG.error("Unable to clear application settings", e);
        }
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 13 sep 2022
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.persistence;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.util.function.Supplier;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import static java.util.Objects.nonNull;
import static java.util.Optional.ofNullable;
import static org.sejda.commons.util.RequireUtils.requireNotBlank;
/**
 * A DAO providing basic CRUD functionalities for {@link String} keys and {@link String} values.
 *
 * @author Andrea Vacondio
 */
public class PreferencesRepository implements Repository {
    private static final Logger LOG = LoggerFactory.getLogger(PreferencesRepository.class);
    final String path;
    public PreferencesRepository(String path) {
        requireNotBlank(path, "Preferences path cannot be blank");
        this.path = path;
    }
    @Override
    public int getInt(String key, int defaultValue) {
        try {
            return Preferences.userRoot().node(path).getInt(key, defaultValue);
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to get value: [key '%s']", key), e);
        }
    }
    @Override
    public long getLong(String key, long defaultValue) {
        try {
            return Preferences.userRoot().node(path).getLong(key, defaultValue);
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to get value: [key '%s']", key), e);
        }
    }
    @Override
    public String getString(String key, Supplier<String> supplier) {
        requireNotBlank(key, "Key cannot be blank");
        try {
            return ofNullable(Preferences.userRoot().node(path).get(key, null)).orElseGet(supplier);
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to get value: [key '%s']", key), e);
        }
    }
    @Override
    public boolean getBoolean(String key, boolean defaultValue) {
        try {
            return Preferences.userRoot().node(path).getBoolean(key, defaultValue);
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to get value: [key '%s']", key), e);
        }
    }
    @Override
    public void saveInt(String key, int value) {
        requireNotBlank(key, "Key cannot be blank");
        try {
            Preferences.userRoot().node(path).putInt(key, value);
            LOG.trace("Saved entity [key '{}', value '{}']", key, value);
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to store value: [key '%s', value '%s']", key, value),
                    e);
        }
    }
    @Override
    public void saveLong(String key, long value) {
        requireNotBlank(key, "Key cannot be blank");
        try {
            Preferences.userRoot().node(path).putLong(key, value);
            LOG.trace("Saved entity [key '{}', value '{}']", key, value);
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to store value: [key '%s', value '%s']", key, value),
                    e);
        }
    }
    @Override
    public void saveString(String key, String value) {
        requireNotBlank(key, "Key cannot be blank");
        try {
            if (nonNull(value)) {
                Preferences.userRoot().node(path).put(key, value);
                LOG.trace("Saved entity [key '{}', value '{}']", key, value);
            } else {
                delete(key);
            }
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to store value: [key '%s', value '%s']", key, value),
                    e);
        }
    }
    @Override
    public void saveBoolean(String key, boolean value) {
        requireNotBlank(key, "Key cannot be blank");
        try {
            Preferences.userRoot().node(path).putBoolean(key, value);
            LOG.trace("Saved entity [key '{}', value '{}']", key, value);
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to store value: [key '%s', value '%s']", key, value),
                    e);
        }
    }
    @Override
    public String[] keys() {
        try {
            return Preferences.userRoot().node(path).keys();
        } catch (IllegalStateException | BackingStoreException e) {
            throw new PersistenceException("Unable to retrieve key values", e);
        }
    }
    /**
     * deletes the value corresponding to the given key
     *
     * @param key
     * @throws PersistenceException if this node (or an ancestor) has been removed or if key contains the null control character, code point U+0000.
     * @see Preferences#remove(String)
     */
    @Override
    public void delete(String key) {
        requireNotBlank(key, "Key cannot be blank");
        try {
            Preferences.userRoot().node(path).remove(key);
            LOG.trace("Deleted entity key '{}'", key);
        } catch (IllegalStateException | IllegalArgumentException e) {
            throw new PersistenceException(String.format("Unable to delete value: [key '%s']", key), e);
        }
    }
    /**
     * Removes all the persisted values and keys for this repository
     *
     * @throws PersistenceException if this operation cannot be completed due to a failure in the backing store, or inability to communicate with it orif this node (or an ancestor) has already been
     *                              removed with the removeNode() method.
     * @see Preferences#removeNode()
     */
    @Override
    public void clean() {
        var prefs = Preferences.userRoot().node(path);
        try {
            prefs.removeNode();
            prefs.flush();
        } catch (IllegalStateException | BackingStoreException e) {
            throw new PersistenceException(String.format("Unable to clear preferences: [path '%s']", path), e);
        }
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 19/09/22
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.core.context;
import javafx.application.ConditionalFeature;
import javafx.application.Platform;
import javafx.scene.Scene;
import org.apache.commons.lang3.StringUtils;
import org.pdfsam.injector.Injector;
import org.pdfsam.injector.Key;
import org.pdfsam.persistence.PreferencesRepository;
import java.io.Closeable;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Objects;
import java.util.Optional;
import static java.util.function.Predicate.not;
import static org.pdfsam.core.context.StringPersistentProperty.FONT_SIZE;
import static org.pdfsam.core.context.StringPersistentProperty.WORKING_PATH;
/**
 * @author Andrea Vacondio
 */
public class ApplicationContext implements Closeable {
    private static final ApplicationContext CONTEXT = new ApplicationContext();
    private final ApplicationPersistentSettings persistentSettings;
    private ApplicationRuntimeState runtimeState;
    private Optional<Injector> injector = Optional.empty();
    private ApplicationContext() {
        this(new ApplicationPersistentSettings(new PreferencesRepository("/org/pdfsam/user/conf")), null);
    }
    /**
     * @deprecated use in tests
     */
    @Deprecated
    ApplicationContext(ApplicationPersistentSettings persistentSettings, ApplicationRuntimeState runtimeState) {
        this.persistentSettings = persistentSettings;
        this.runtimeState = runtimeState;
    }
    /**
     * @return the application context
     */
    public static ApplicationContext app() {
        return CONTEXT;
    }
    /**
     * @return the application settings
     */
    public ApplicationPersistentSettings persistentSettings() {
        return this.persistentSettings;
    }
    /**
     * @return the application runtime state
     */
    public ApplicationRuntimeState runtimeState() {
        synchronized (this) {
            if (Objects.isNull(this.runtimeState)) {
                this.runtimeState = new ApplicationRuntimeState();
                //listen for changes in the working path
                this.persistentSettings().settingsChanges(WORKING_PATH).subscribe(path -> {
                    this.runtimeState.defaultWorkingPath(
                            path.filter(StringUtils::isNotBlank).map(Paths::get).filter(Files::isDirectory)
                                    .orElse(null));
                });
                var workingPath = persistentSettings().get(WORKING_PATH).filter(StringUtils::isNotBlank).map(Paths::get)
                        .filter(Files::isDirectory).orElse(null);
                this.runtimeState.defaultWorkingPath(workingPath);
            }
        }
        return this.runtimeState;
    }
    /**
     * Register the given scene to application context to listen to theme changes and other events
     *
     * @param scene
     */
    public void registerScene(Scene scene) {
        this.runtimeState().theme().subscribe(t -> {
            if (Objects.nonNull(t)) {
                Platform.runLater(() -> {
                    scene.getStylesheets().setAll(t.stylesheets());
                    if (!Platform.isSupported(ConditionalFeature.TRANSPARENT_WINDOW)) {
                        scene.getStylesheets().addAll(t.transparentIncapableStylesheets());
                    }
                });
            }
        });
        this.persistentSettings().settingsChanges(FONT_SIZE).subscribe(size -> {
            size.filter(StringUtils::isNotBlank).map(s -> String.format("-fx-font-size: %s;", s))
                    .ifPresentOrElse(scene.getRoot()::setStyle, () -> scene.getRoot().setStyle(""));
        });
        this.persistentSettings().get(FONT_SIZE).filter(not(String::isBlank))
                .ifPresent(size -> scene.getRoot().setStyle(String.format("-fx-font-size: %s;", size)));
    }
    /**
     * Sets the injector
     */
    public void injector(Injector injector) {
        this.injector = Optional.ofNullable(injector);
    }
    /**
     * @return an instance of type
     */
    public <T> T instance(Class<T> type) {
        return injector.orElseThrow(() -> new IllegalStateException("Injector not set for this application"))
                .instance(type);
    }
    public <T> T instance(Key<T> key) {
        return injector.orElseThrow(() -> new IllegalStateException("Injector not set for this application"))
                .instance(key);
    }
    public void clean() {
        persistentSettings.clean();
    }
    @Override
    public void close() {
        injector.ifPresent(Injector::close);
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 07/apr/2014
 * Copyright 2017 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.tools.split;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
import static org.pdfsam.ui.components.io.PdfDestinationPane.DestinationPanelFields.DISCARD_BOOKMARKS;
/**
 * Simple split module to let the user set page numbers to split an input pdf document.
 *
 * @author Andrea Vacondio
 */
@Auto
public class SplitTool implements Tool {
    static final String TOOL_ID = "split.simple";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.SPLIT)
            .inputTypes(ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Split"))
            .description(i18n().tr("Split a PDF document at the given page numbers."))
            .priority(ToolPriority.HIGH.getPriority()).supportURL("https://pdfsam.org/pdf-split/")
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public Pane panel() {
        return app().instance(SplitToolPanel.class);
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.IMAGE_BROKEN);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            return new BrowsableOutputDirectoryField();
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            PdfDestinationPane panel = new PdfDestinationPane(outputField, TOOL_ID, DISCARD_BOOKMARKS);
            panel.enableSameAsSourceItem();
            return panel;
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 18/09/22
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.core.context;
import org.sejda.model.pdf.PdfVersion;
import java.util.function.Supplier;
import static org.pdfsam.core.ConfigurableSystemProperty.LOCALE_PROP;
import static org.pdfsam.core.ConfigurableSystemProperty.PDFVERSION_PROP;
import static org.pdfsam.core.ConfigurableSystemProperty.PREFIX_PROP;
import static org.pdfsam.core.ConfigurableSystemProperty.THEME_PROP;
/**
 * Configurable String value property
 *
 * @author Andrea Vacondio
 */
public enum StringPersistentProperty implements PersistentProperty<String> {
    WORKSPACE_PATH(() -> ""),
    WORKING_PATH(() -> ""),
    STARTUP_MODULE(() -> ""),
    LOCALE(() -> System.getProperty(LOCALE_PROP)),
    THEME(() -> System.getProperty(THEME_PROP)),
    FONT_SIZE(() -> ""),
    PDF_VERSION(() -> {
        var version = System.getProperty(PDFVERSION_PROP, PdfVersion.VERSION_1_5.name());
        try {
            //we make sure the default supplier returns a valid version
            PdfVersion.valueOf(version);
            return version;
        } catch (IllegalArgumentException e) {
            return PdfVersion.VERSION_1_5.name();
        }
    }),
    PREFIX(() -> System.getProperty(PREFIX_PROP, "PDFsam_"));
    private final Supplier<String> defaultSupplier;
    StringPersistentProperty(Supplier<String> supplier) {
        this.defaultSupplier = supplier;
    }
    @Override
    public String key() {
        return this.name().toLowerCase();
    }
    @Override
    public Supplier<String> defaultSupplier() {
        return defaultSupplier;
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 07/apr/2014
 * Copyright 2017 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.tools.rotate;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
/**
 * Rotate module to let the user rotate multiple PDF documents
 *
 * @author Andrea Vacondio
 */
@Auto
public class RotateTool implements Tool {
    static final String TOOL_ID = "rotate";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.OTHER)
            .inputTypes(ToolInputOutputType.MULTIPLE_PDF, ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Rotate"))
            .description(i18n().tr("Rotate the pages of multiple PDF documents."))
            .priority(ToolPriority.DEFAULT.getPriority()).supportURL("https://pdfsam.org/rotate-pdf/")
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public Pane panel() {
        return app().instance(RotateToolPanel.class);
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.ROTATE_360);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            return new BrowsableOutputDirectoryField();
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            return new PdfDestinationPane(outputField, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 09/giu/2014
 * Copyright 2017 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.ui.components.prefix;
import javafx.geometry.HPos;
import javafx.geometry.VPos;
import javafx.scene.control.Label;
import javafx.scene.layout.GridPane;
import org.pdfsam.core.context.StringPersistentProperty;
import org.pdfsam.core.support.params.MultipleOutputTaskParametersBuilder;
import org.pdfsam.core.support.params.TaskParametersBuildStep;
import org.pdfsam.model.tool.TaskExecutionRequest;
import org.pdfsam.model.tool.ToolBound;
import org.pdfsam.model.ui.ResettableView;
import org.pdfsam.model.ui.workspace.RestorableView;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.support.Style;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.Optional;
import java.util.function.Consumer;
import static org.apache.commons.lang3.StringUtils.EMPTY;
import static org.apache.commons.lang3.StringUtils.defaultString;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.eventstudio.StaticStudio.eventStudio;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.ui.components.support.Views.helpIcon;
/**
 * Panel with a text field to set the prefix for a task
 *
 * @author Andrea Vacondio
 */
public class PrefixPane extends GridPane
        implements TaskParametersBuildStep<MultipleOutputTaskParametersBuilder<?>>, RestorableView, ResettableView,
        ToolBound {
    private final PrefixField field;
    private final String toolBinding;
    private final PreferencesRepository repository;
    public PrefixPane(String toolBinding, PreferencesRepository repository) {
        this.toolBinding = defaultString(toolBinding);
        this.repository = repository;
        this.field = new PrefixField();
        this.initPrefixValue();
        getStyleClass().addAll(Style.CONTAINER.css());
        getStyleClass().addAll(Style.GRID.css());
        var label = new Label(i18n().tr("Generated PDF documents name prefix:"));
        GridPane.setValignment(label, VPos.BOTTOM);
        GridPane.setHalignment(label, HPos.LEFT);
        add(label, 0, 0);
        GridPane.setValignment(field, VPos.BOTTOM);
        GridPane.setHalignment(field, HPos.LEFT);
        add(field, 1, 0);
        var helpIcon = helpIcon("""
                %s
                %s
                %s
                """.formatted(i18n().tr("Prefix for the output files name."),
                i18n().tr("Some special keywords are replaced with runtime values."),
                i18n().tr("Right click to add these keywords.")));
        GridPane.setValignment(helpIcon, VPos.CENTER);
        add(helpIcon, 2, 0);
        eventStudio().add(TaskExecutionRequest.class, e -> {
            if (toolBinding.equals(e.toolId())) {
                repository.saveString("DEFAULT_PREFIX", field.getText());
            }
        });
    }
    public void addMenuItemFor(Prefix... prefixes) {
        field.addMenuItemFor(prefixes);
    }
    public void addMenuItemFor(String... prefixes) {
        field.addMenuItemFor(prefixes);
    }
    public final String getText() {
        return field.getText();
    }
    @Override
    public void resetView() {
        this.initPrefixValue();
    }
    public void initPrefixValue() {
        field.setText(repository.getString("DEFAULT_PREFIX",
                () -> app().persistentSettings().get(StringPersistentProperty.PREFIX).orElse("PDFsam_")));
    }
    @Override
    public String toolBinding() {
        return toolBinding;
    }
    @Override
    public void apply(MultipleOutputTaskParametersBuilder<?> builder, Consumer<String> onError) {
        builder.prefix(getText());
    }
    @Override
    public void saveStateTo(Map<String, String> data) {
        data.put(defaultString(getId()) + "prefix", defaultString(field.getText()));
    }
    @Override
    public void restoreStateFrom(Map<String, String> data) {
        field.setText(Optional.ofNullable(data.get(defaultString(getId()) + "prefix")).orElse(EMPTY));
    }
}
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 07/apr/2014
 * Copyright 2017 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.pdfsam.tools.extract;
import jakarta.inject.Named;
import javafx.scene.Node;
import javafx.scene.layout.Pane;
import org.kordamp.ikonli.javafx.FontIcon;
import org.kordamp.ikonli.unicons.UniconsLine;
import org.pdfsam.injector.Auto;
import org.pdfsam.injector.Provides;
import org.pdfsam.model.tool.Tool;
import org.pdfsam.model.tool.ToolCategory;
import org.pdfsam.model.tool.ToolDescriptor;
import org.pdfsam.model.tool.ToolInputOutputType;
import org.pdfsam.model.tool.ToolPriority;
import org.pdfsam.persistence.PreferencesRepository;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.tool.Footer;
import org.pdfsam.ui.components.tool.OpenButton;
import org.pdfsam.ui.components.tool.RunButton;
import static org.pdfsam.core.context.ApplicationContext.app;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.model.tool.ToolDescriptorBuilder.builder;
import static org.pdfsam.ui.components.io.PdfDestinationPane.DestinationPanelFields.DISCARD_BOOKMARKS;
/**
 * Extract module to let the user extract pages from a single PDF document
 *
 * @author Andrea Vacondio
 */
@Auto
public class ExtractTool implements Tool {
    static final String TOOL_ID = "extract";
    private final ToolDescriptor descriptor = builder().category(ToolCategory.SPLIT)
            .inputTypes(ToolInputOutputType.MULTIPLE_PDF, ToolInputOutputType.SINGLE_PDF).name(i18n().tr("Extract"))
            .description(i18n().tr("Extract pages from PDF documents.")).priority(ToolPriority.DEFAULT.getPriority())
            .supportURL("https://pdfsam.org/pdf-extract-pages/")
            .build();
    @Override
    public ToolDescriptor descriptor() {
        return descriptor;
    }
    @Override
    public Pane panel() {
        return app().instance(ExtractToolPanel.class);
    }
    @Override
    public String id() {
        return TOOL_ID;
    }
    @Override
    public Node graphic() {
        var icon = new FontIcon(UniconsLine.FILE_EXPORT);
        icon.getStyleClass().addAll(this.descriptor().category().styleClass(), "tool-icon");
        return icon;
    }
    public static class ModuleConfig {
        @Provides
        @Named(TOOL_ID + "field")
        public BrowsableOutputDirectoryField destinationDirectoryField() {
            return new BrowsableOutputDirectoryField();
        }
        @Provides
        @Named(TOOL_ID + "pane")
        public PdfDestinationPane destinationPane(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField outputField) {
            return new PdfDestinationPane(outputField, TOOL_ID, DISCARD_BOOKMARKS);
        }
        @Provides
        @Named(TOOL_ID + "footer")
        public Footer footer(RunButton runButton, @Named(TOOL_ID + "openButton") OpenButton openButton) {
            return new Footer(runButton, openButton, TOOL_ID);
        }
        @Provides
        @Named(TOOL_ID + "openButton")
        public OpenButton openButton() {
            return new OpenButton(TOOL_ID, ToolInputOutputType.MULTIPLE_PDF);
        }
        @Provides
        @Named(TOOL_ID + "prefix")
        public PrefixPane prefixPane() {
            return new PrefixPane(TOOL_ID, new PreferencesRepository("/org/pdfsam/user/conf/" + TOOL_ID));
        }
    }
}
package org.pdfsam.tools.extract;
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 03/10/22
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.extract.ExtractTool.TOOL_ID;
import static org.pdfsam.ui.components.support.Views.titledPane;
/**
 * @author Andrea Vacondio
 */
public class ExtractToolPanel extends BaseToolPanel {
    private final ExtractSelectionPane selectionPane = new ExtractSelectionPane(TOOL_ID);
    private final ExtractOptionsPane extractOptions = new ExtractOptionsPane();
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final PrefixPane prefix;
    @Inject
    public ExtractToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    protected ExtractParametersBuilder getBuilder(Consumer<String> onError) {
        ExtractParametersBuilder builder = new ExtractParametersBuilder();
        extractOptions.apply(builder, onError);
        selectionPane.apply(builder, onError);
        destinationDirectoryField.apply(builder, onError);
        destinationPane.apply(builder, onError);
        prefix.apply(builder, onError);
        return builder;
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        extractOptions.saveStateTo(data);
        destinationPane.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        if (data.containsKey("input")) {
            data.put("input.0", data.get("input"));
            data.put("input.password.0", data.get("input.password"));
            data.put("input.size", "1");
        }
        selectionPane.restoreStateFrom(data);
        extractOptions.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        VBox.setVgrow(selectionPane, Priority.ALWAYS);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        pane.getChildren().addAll(selectionPane, titledPane(i18n().tr("Extract settings"), extractOptions),
                titledPane(i18n().tr("Output settings"), destinationPane), prefixTitled);
        return pane;
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            extractOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
}
package org.pdfsam.tools.rotate;
/*
 * This file is part of the PDF Split And Merge source code
 * Created on 03/10/22
 * Copyright 2022 by Sober Lemur S.r.l. (info@soberlemur.com).
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import jakarta.inject.Inject;
import jakarta.inject.Named;
import javafx.geometry.Pos;
import javafx.scene.control.TitledPane;
import javafx.scene.layout.Priority;
import javafx.scene.layout.VBox;
import org.pdfsam.eventstudio.annotation.EventListener;
import org.pdfsam.eventstudio.annotation.EventStation;
import org.pdfsam.model.tool.ClearToolRequest;
import org.pdfsam.ui.components.io.BrowsableOutputDirectoryField;
import org.pdfsam.ui.components.io.PdfDestinationPane;
import org.pdfsam.ui.components.prefix.PrefixPane;
import org.pdfsam.ui.components.support.Views;
import org.pdfsam.ui.components.tool.BaseToolPanel;
import org.pdfsam.ui.components.tool.Footer;
import org.sejda.model.prefix.Prefix;
import java.util.Map;
import java.util.function.Consumer;
import static org.pdfsam.i18n.I18nContext.i18n;
import static org.pdfsam.tools.rotate.RotateTool.TOOL_ID;
/**
 * @author Andrea Vacondio
 */
public class RotateToolPanel extends BaseToolPanel {
    private final RotateSelectionPane selectionPane = new RotateSelectionPane(TOOL_ID);
    private final RotateOptionsPane rotateOptions = new RotateOptionsPane();
    private final BrowsableOutputDirectoryField destinationDirectoryField;
    private final PdfDestinationPane destinationPane;
    private final PrefixPane prefix;
    @Inject
    public RotateToolPanel(@Named(TOOL_ID + "field") BrowsableOutputDirectoryField destinationDirectoryField,
            @Named(TOOL_ID + "pane") PdfDestinationPane destinationPane, @Named(TOOL_ID + "footer") Footer footer,
            @Named(TOOL_ID + "prefix") PrefixPane prefix) {
        super(TOOL_ID, footer);
        this.destinationDirectoryField = destinationDirectoryField;
        this.destinationPane = destinationPane;
        this.prefix = prefix;
        initModuleSettingsPanel(settingPanel());
    }
    @Override
    protected RotateParametersBuilder getBuilder(Consumer<String> onError) {
        RotateParametersBuilder builder = new RotateParametersBuilder();
        rotateOptions.apply(builder, onError);
        selectionPane.apply(builder, onError);
        destinationDirectoryField.apply(builder, onError);
        destinationPane.apply(builder, onError);
        prefix.apply(builder, onError);
        return builder;
    }
    @Override
    public void onSaveWorkspace(Map<String, String> data) {
        selectionPane.saveStateTo(data);
        rotateOptions.saveStateTo(data);
        destinationPane.saveStateTo(data);
        destinationDirectoryField.saveStateTo(data);
        prefix.saveStateTo(data);
    }
    @Override
    public void onLoadWorkspace(Map<String, String> data) {
        selectionPane.restoreStateFrom(data);
        rotateOptions.restoreStateFrom(data);
        destinationPane.restoreStateFrom(data);
        destinationDirectoryField.restoreStateFrom(data);
        prefix.restoreStateFrom(data);
    }
    private VBox settingPanel() {
        VBox pane = new VBox();
        pane.setAlignment(Pos.TOP_CENTER);
        VBox.setVgrow(selectionPane, Priority.ALWAYS);
        TitledPane prefixTitled = Views.titledPane(i18n().tr("File names settings"), prefix);
        prefix.addMenuItemFor(Prefix.FILENUMBER);
        prefix.addMenuItemFor("[TOTAL_FILESNUMBER]");
        TitledPane options = Views.titledPane(i18n().tr("Rotate settings"), rotateOptions);
        pane.getChildren()
                .addAll(selectionPane, options, Views.titledPane(i18n().tr("Output settings"), destinationPane),
                        prefixTitled);
        return pane;
    }
    @EventStation
    public String id() {
        return TOOL_ID;
    }
    @EventListener
    public void onClearModule(ClearToolRequest e) {
        if (e.clearEverything()) {
            rotateOptions.resetView();
            prefix.resetView();
            destinationPane.resetView();
        }
    }
}