package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.errorprone.annotations.Immutable;
import java.util.Objects;
import org.sosy_lab.java_smt.api.ArrayFormula;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.api.NumeralFormula.IntegerFormula;
import org.sosy_lab.java_smt.api.NumeralFormula.RationalFormula;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
@Immutable
public class OpenSmtFormula implements Formula {
  @SuppressWarnings("Immutable")
  private final Logic osmtLogic;
  @SuppressWarnings("Immutable")
  private final PTRef osmtTerm;
  OpenSmtFormula(Logic logic, PTRef term) {
    osmtLogic = logic;
    osmtTerm = term;
  }
  @Override
  public final String toString() {
    return osmtLogic.pp(osmtTerm);
  }
  @Override
  public final boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (!(o instanceof OpenSmtFormula)) {
      return false;
    }
    OpenSmtFormula that = (OpenSmtFormula) o;
    return this.osmtLogic.equals(that.osmtLogic) && this.osmtTerm.equals(that.osmtTerm);
  }
  @Override
  public final int hashCode() {
    return Objects.hash(osmtLogic, osmtTerm);
  }
  final PTRef getOsmtTerm() {
    return osmtTerm;
  }
  @Immutable
  @SuppressWarnings("ClassTypeParameterName")
  static final class OpenSmtArrayFormula<TI extends Formula, TE extends Formula>
      extends OpenSmtFormula implements ArrayFormula<TI, TE> {
    private final FormulaType<TI> indexType;
    private final FormulaType<TE> elementType;
    OpenSmtArrayFormula(
        Logic pLogic, PTRef pTerm, FormulaType<TI> pIndexType, FormulaType<TE> pElementType) {
      super(pLogic, pTerm);
      indexType = pIndexType;
      elementType = pElementType;
    }
    public FormulaType<TI> getIndexType() {
      return indexType;
    }
    public FormulaType<TE> getElementType() {
      return elementType;
    }
  }
  @Immutable
  static final class OpenSmtIntegerFormula extends OpenSmtFormula implements IntegerFormula {
    OpenSmtIntegerFormula(Logic pLogic, PTRef pTerm) {
      super(pLogic, pTerm);
    }
  }
  @Immutable
  static final class OpenSmtRationalFormula extends OpenSmtFormula implements RationalFormula {
    OpenSmtRationalFormula(Logic pLogic, PTRef pTerm) {
      super(pLogic, pTerm);
    }
  }
  @Immutable
  static final class OpenSmtBooleanFormula extends OpenSmtFormula implements BooleanFormula {
    OpenSmtBooleanFormula(Logic pLogic, PTRef pTerm) {
      super(pLogic, pTerm);
    }
  }
}
package org.sosy_lab.java_smt.api;
import com.google.errorprone.annotations.Immutable;
@SuppressWarnings("InterfaceTypeParameterName")
@Immutable
public interface ArrayFormula<TI extends Formula, TE extends Formula> extends Formula {}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class PTRef {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected PTRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(PTRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(PTRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_PTRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public boolean equals(Object object) {
    if(object instanceof PTRef) {
      PTRef that = (PTRef) object;
      return this.getX() == that.getX();
    }
    return false;
  }
  public int hashCode() {
    return Long.hashCode(this.getX());
  }
  public void setX(long value) {
    OsmtNativeJNI.PTRef_x_set(swigCPtr, this, value);
  }
  public long getX() {
    return OsmtNativeJNI.PTRef_x_get(swigCPtr, this);
  }
  public static PTRef getUndef() {
    long cPtr = OsmtNativeJNI.PTRef_Undef_get();
    return (cPtr == 0) ? null : new PTRef(cPtr, false);
  }
}
package org.sosy_lab.java_smt.api;
import static org.sosy_lab.java_smt.api.FloatingPointNumber.DOUBLE_PRECISION_EXPONENT_SIZE;
import static org.sosy_lab.java_smt.api.FloatingPointNumber.DOUBLE_PRECISION_MANTISSA_SIZE;
import static org.sosy_lab.java_smt.api.FloatingPointNumber.SINGLE_PRECISION_EXPONENT_SIZE;
import static org.sosy_lab.java_smt.api.FloatingPointNumber.SINGLE_PRECISION_MANTISSA_SIZE;
import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableSet;
import com.google.errorprone.annotations.Immutable;
import java.util.List;
import java.util.Set;
import org.sosy_lab.java_smt.api.NumeralFormula.IntegerFormula;
import org.sosy_lab.java_smt.api.NumeralFormula.RationalFormula;
@SuppressWarnings("checkstyle:constantname")
@Immutable
public abstract class FormulaType<T extends Formula> {
  private FormulaType() {}
  public boolean isArrayType() {
    return false;
  }
  public boolean isBitvectorType() {
    return false;
  }
  public boolean isBooleanType() {
    return false;
  }
  public boolean isFloatingPointType() {
    return false;
  }
  public boolean isFloatingPointRoundingModeType() {
    return false;
  }
  public boolean isNumeralType() {
    return false;
  }
  public boolean isRationalType() {
    return false;
  }
  public boolean isIntegerType() {
    return false;
  }
  public boolean isSLType() {
    return false;
  }
  public boolean isStringType() {
    return false;
  }
  public boolean isRegexType() {
    return false;
  }
  public boolean isEnumerationType() {
    return false;
  }
  @Override
  public abstract String toString();
  public abstract String toSMTLIBString();
  @Immutable
  public abstract static class NumeralType<T extends NumeralFormula> extends FormulaType<T> {
    @Override
    public final boolean isNumeralType() {
      return true;
    }
  }
  @SuppressWarnings("ClassInitializationDeadlock")
  public static final FormulaType<RationalFormula> RationalType =
      new NumeralType<>() {
        @Override
        public boolean isRationalType() {
          return true;
        }
        @Override
        public String toString() {
          return "Rational";
        }
        @Override
        public String toSMTLIBString() {
          return "Real";
        }
      };
  @SuppressWarnings("ClassInitializationDeadlock")
  public static final FormulaType<IntegerFormula> IntegerType =
      new NumeralType<>() {
        @Override
        public boolean isIntegerType() {
          return true;
        }
        @Override
        public String toString() {
          return "Integer";
        }
        @Override
        public String toSMTLIBString() {
          return "Int";
        }
      };
  public static final FormulaType<BooleanFormula> BooleanType =
      new FormulaType<>() {
        @Override
        public boolean isBooleanType() {
          return true;
        }
        @Override
        public String toString() {
          return "Boolean";
        }
        @Override
        public String toSMTLIBString() {
          return "Bool";
        }
      };
  public static BitvectorType getBitvectorTypeWithSize(int size) {
    return new BitvectorType(size);
  }
  @Immutable
  public static final class BitvectorType extends FormulaType<BitvectorFormula> {
    private final int size;
    private BitvectorType(int size) {
      this.size = size;
    }
    @Override
    public boolean isBitvectorType() {
      return true;
    }
    public int getSize() {
      return size;
    }
    @Override
    public String toString() {
      return "Bitvector<" + getSize() + ">";
    }
    @Override
    public boolean equals(Object pObj) {
      if (pObj == this) {
        return true;
      }
      if (!(pObj instanceof BitvectorType)) {
        return false;
      }
      BitvectorType other = (BitvectorType) pObj;
      return size == other.size;
    }
    @Override
    public int hashCode() {
      return size;
    }
    @Override
    public String toSMTLIBString() {
      return "(_ BitVec " + size + ")";
    }
  }
  public static FloatingPointType getFloatingPointType(int exponentSize, int mantissaSize) {
    return new FloatingPointType(exponentSize, mantissaSize);
  }
  public static FloatingPointType getSinglePrecisionFloatingPointType() {
    return FloatingPointType.SINGLE_PRECISION_FP_TYPE;
  }
  public static FloatingPointType getDoublePrecisionFloatingPointType() {
    return FloatingPointType.DOUBLE_PRECISION_FP_TYPE;
  }
  @Immutable
  public static final class FloatingPointType extends FormulaType<FloatingPointFormula> {
    private static final FloatingPointType SINGLE_PRECISION_FP_TYPE =
        new FloatingPointType(SINGLE_PRECISION_EXPONENT_SIZE, SINGLE_PRECISION_MANTISSA_SIZE);
    private static final FloatingPointType DOUBLE_PRECISION_FP_TYPE =
        new FloatingPointType(DOUBLE_PRECISION_EXPONENT_SIZE, DOUBLE_PRECISION_MANTISSA_SIZE);
    private final int exponentSize;
    private final int mantissaSize;
    private FloatingPointType(int pExponentSize, int pMantissaSize) {
      exponentSize = pExponentSize;
      mantissaSize = pMantissaSize;
    }
    @Override
    public boolean isFloatingPointType() {
      return true;
    }
    public int getExponentSize() {
      return exponentSize;
    }
    public int getMantissaSize() {
      return mantissaSize;
    }
    public int getTotalSize() {
      return exponentSize + mantissaSize + 1;
    }
    @Override
    public int hashCode() {
      return (31 + exponentSize) * 31 + mantissaSize;
    }
    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      }
      if (!(obj instanceof FloatingPointType)) {
        return false;
      }
      FloatingPointType other = (FloatingPointType) obj;
      return this.exponentSize == other.exponentSize && this.mantissaSize == other.mantissaSize;
    }
    @Override
    public String toString() {
      return "FloatingPoint<exp=" + exponentSize + ",mant=" + mantissaSize + ">";
    }
    @Override
    public String toSMTLIBString() {
      return "(_ FloatingPoint " + exponentSize + " " + mantissaSize + ")";
    }
  }
  public static final FormulaType<FloatingPointRoundingModeFormula> FloatingPointRoundingModeType =
      new FloatingPointRoundingModeType();
  private static final class FloatingPointRoundingModeType
      extends FormulaType<FloatingPointRoundingModeFormula> {
    @Override
    public boolean isFloatingPointRoundingModeType() {
      return true;
    }
    @Override
    public String toString() {
      return "FloatingPointRoundingMode";
    }
    @Override
    public String toSMTLIBString() {
      throw new UnsupportedOperationException(
          "rounding mode is not expected in symbol declarations");
    }
  }
  @SuppressWarnings("MethodTypeParameterName")
  public static <TD extends Formula, TR extends Formula> ArrayFormulaType<TD, TR> getArrayType(
      FormulaType<TD> pDomainSort, FormulaType<TR> pRangeSort) {
    return new ArrayFormulaType<>(pDomainSort, pRangeSort);
  }
  @SuppressWarnings("ClassTypeParameterName")
  public static final class ArrayFormulaType<TI extends Formula, TE extends Formula>
      extends FormulaType<ArrayFormula<TI, TE>> {
    private final FormulaType<TE> elementType;
    private final FormulaType<TI> indexType;
    private ArrayFormulaType(FormulaType<TI> pIndexType, FormulaType<TE> pElementType) {
      this.indexType = Preconditions.checkNotNull(pIndexType);
      this.elementType = Preconditions.checkNotNull(pElementType);
    }
    public FormulaType<TE> getElementType() {
      return elementType;
    }
    public FormulaType<TI> getIndexType() {
      return indexType;
    }
    @Override
    public boolean isArrayType() {
      return true;
    }
    @Override
    public String toString() {
      return String.format("Array<%s,%s>", indexType, elementType);
    }
    @Override
    public int hashCode() {
      return 31 * elementType.hashCode() + indexType.hashCode();
    }
    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      }
      if (!(obj instanceof ArrayFormulaType)) {
        return false;
      }
      ArrayFormulaType<?, ?> other = (ArrayFormulaType<?, ?>) obj;
      return elementType.equals(other.elementType) && indexType.equals(other.indexType);
    }
    @Override
    public String toSMTLIBString() {
      return "(Array " + indexType.toSMTLIBString() + " " + elementType.toSMTLIBString() + ")";
    }
  }
  public static EnumerationFormulaType getEnumerationType(String pName, Set<String> pElements) {
    return new EnumerationFormulaType(pName, pElements);
  }
  public static final class EnumerationFormulaType extends FormulaType<EnumerationFormula> {
    private final String name;
    private final ImmutableSet<String> elements;
    private EnumerationFormulaType(String pName, Set<String> pElements) {
      this.name = Preconditions.checkNotNull(pName);
      this.elements = ImmutableSet.copyOf(pElements);
    }
    public String getName() {
      return name;
    }
    public ImmutableSet<String> getElements() {
      return elements;
    }
    public int getCardinality() {
      return elements.size();
    }
    @Override
    public boolean isEnumerationType() {
      return true;
    }
    @Override
    public String toString() {
      return String.format("%s (%s)", name, Joiner.on(", ").join(elements));
    }
    @Override
    public int hashCode() {
      return 31 * name.hashCode() + elements.hashCode();
    }
    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      }
      if (!(obj instanceof EnumerationFormulaType)) {
        return false;
      }
      EnumerationFormulaType other = (EnumerationFormulaType) obj;
      return name.equals(other.name) && elements.equals(other.elements);
    }
    @Override
    public String toSMTLIBString() {
      return "(" + this + ")";
    }
  }
  public static final FormulaType<StringFormula> StringType =
      new FormulaType<>() {
        @Override
        public boolean isStringType() {
          return true;
        }
        @Override
        public String toString() {
          return "String";
        }
        @Override
        public String toSMTLIBString() {
          return "String";
        }
      };
  public static final FormulaType<RegexFormula> RegexType =
      new FormulaType<>() {
        @Override
        public boolean isRegexType() {
          return true;
        }
        @Override
        public String toString() {
          return "RegLan";
        }
        @Override
        public String toSMTLIBString() {
          return "RegLan";
        }
      };
  public static FormulaType<?> fromString(String t) {
    if (BooleanType.toString().equals(t)) {
      return BooleanType;
    } else if (IntegerType.toString().equals(t)) {
      return IntegerType;
    } else if (RationalType.toString().equals(t)) {
      return RationalType;
    } else if (StringType.toString().equals(t)) {
      return StringType;
    } else if (RegexType.toString().equals(t)) {
      return RegexType;
    } else if (FloatingPointRoundingModeType.toString().equals(t)) {
      return FloatingPointRoundingModeType;
    } else if (t.startsWith("FloatingPoint<")) {
      List<String> exman = Splitter.on(',').limit(2).splitToList(t.substring(14, t.length() - 1));
      return FormulaType.getFloatingPointType(
          Integer.parseInt(exman.get(0).substring(4)), Integer.parseInt(exman.get(1).substring(5)));
    } else if (t.startsWith("Bitvector<")) {
      return FormulaType.getBitvectorTypeWithSize(
          Integer.parseInt(t.substring(10, t.length() - 1)));
    } else if (t.matches(".*\\(.*\\)")) {
      String name = t.substring(0, t.indexOf("(") - 1);
      String elementsStr = t.substring(t.indexOf("(") + 1, t.length() - 1);
      Set<String> elements = ImmutableSet.copyOf(Splitter.on(", ").split(elementsStr));
      return new EnumerationFormulaType(name, elements);
    } else {
      throw new AssertionError("unknown type:" + t);
    }
  }
}
package org.sosy_lab.java_smt.api;
import com.google.errorprone.annotations.Immutable;
@Immutable
public interface BooleanFormula extends Formula {}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class Logic {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected Logic(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(Logic obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(Logic obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_Logic(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public Logic(Logic_t type) {
    this(OsmtNativeJNI.new_Logic__SWIG_0(type.swigValue()), true);
  }
  public Logic(Logic arg0) {
    this(OsmtNativeJNI.new_Logic__SWIG_1(Logic.swigRelease(arg0), arg0), true);
  }
  public Sort getSortDefinition(SRef s) {
    return new Sort(OsmtNativeJNI.Logic_getSortDefinition(swigCPtr, this, SRef.getCPtr(s), s), false);
  }
  public SortSymbol getSortSymbol(SSymRef ss) {
    return new SortSymbol(OsmtNativeJNI.Logic_getSortSymbol(swigCPtr, this, SSymRef.getCPtr(ss), ss), false);
  }
  public SRef getSortRef(PTRef tr) {
    return new SRef(OsmtNativeJNI.Logic_getSortRef(swigCPtr, this, PTRef.getCPtr(tr), tr), true);
  }
  public String printSort(SRef s) {
    return OsmtNativeJNI.Logic_printSort(swigCPtr, this, SRef.getCPtr(s), s);
  }
  public SRef declareUninterpretedSort(String arg0) {
    return new SRef(OsmtNativeJNI.Logic_declareUninterpretedSort(swigCPtr, this, arg0), true);
  }
  public boolean isArraySort(SRef sref) {
    return OsmtNativeJNI.Logic_isArraySort(swigCPtr, this, SRef.getCPtr(sref), sref);
  }
  public SRef getArraySort(SRef domain, SRef codomain) {
    return new SRef(OsmtNativeJNI.Logic_getArraySort(swigCPtr, this, SRef.getCPtr(domain), domain, SRef.getCPtr(codomain), codomain), true);
  }
  public boolean isArrayStore(PTRef arg0) {
    return OsmtNativeJNI.Logic_isArrayStore(swigCPtr, this, PTRef.getCPtr(arg0), arg0);
  }
  public boolean isArraySelect(PTRef arg0) {
    return OsmtNativeJNI.Logic_isArraySelect(swigCPtr, this, PTRef.getCPtr(arg0), arg0);
  }
  public Symbol getSym(SymRef s) {
    return new Symbol(OsmtNativeJNI.Logic_getSym(swigCPtr, this, SymRef.getCPtr(s), s), false);
  }
  public SymRef getSymRef(PTRef tr) {
    return new SymRef(OsmtNativeJNI.Logic_getSymRef(swigCPtr, this, PTRef.getCPtr(tr), tr), true);
  }
  public String getSymName(SymRef s) {
    return OsmtNativeJNI.Logic_getSymName(swigCPtr, this, SymRef.getCPtr(s), s);
  }
  public Pterm getPterm(PTRef tr) {
    return new Pterm(OsmtNativeJNI.Logic_getPterm(swigCPtr, this, PTRef.getCPtr(tr), tr), false);
  }
  public PTRef mkAnd(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkAnd__SWIG_0(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkOr(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkOr__SWIG_0(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkXor(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkXor(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkImpl(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkImpl__SWIG_0(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkNot(PTRef arg0) {
    return new PTRef(OsmtNativeJNI.Logic_mkNot(swigCPtr, this, PTRef.getCPtr(arg0), arg0), true);
  }
  public PTRef mkIte(PTRef c, PTRef t, PTRef e) {
    return new PTRef(OsmtNativeJNI.Logic_mkIte(swigCPtr, this, PTRef.getCPtr(c), c, PTRef.getCPtr(t), t, PTRef.getCPtr(e), e), true);
  }
  public PTRef mkEq(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.Logic_mkEq__SWIG_0(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkVar(SRef arg0, String arg1, boolean isInterpreted) {
    return new PTRef(OsmtNativeJNI.Logic_mkVar__SWIG_0(swigCPtr, this, SRef.getCPtr(arg0), arg0, arg1, isInterpreted), true);
  }
  public PTRef mkVar(SRef arg0, String arg1) {
    return new PTRef(OsmtNativeJNI.Logic_mkVar__SWIG_1(swigCPtr, this, SRef.getCPtr(arg0), arg0, arg1), true);
  }
  public PTRef mkConst(SRef arg0, String arg1) {
    return new PTRef(OsmtNativeJNI.Logic_mkConst(swigCPtr, this, SRef.getCPtr(arg0), arg0, arg1), true);
  }
  public PTRef mkBoolVar(String name) {
    return new PTRef(OsmtNativeJNI.Logic_mkBoolVar(swigCPtr, this, name), true);
  }
  public String dumpWithLets(PTRef formula) {
    return OsmtNativeJNI.Logic_dumpWithLets(swigCPtr, this, PTRef.getCPtr(formula), formula);
  }
  public PTRef parseFormula(String input) {
    return new PTRef(OsmtNativeJNI.Logic_parseFormula(swigCPtr, this, input), true);
  }
  public SRef getSort_bool() {
    return new SRef(OsmtNativeJNI.Logic_getSort_bool(swigCPtr, this), true);
  }
  public PTRef getTerm_true() {
    return new PTRef(OsmtNativeJNI.Logic_getTerm_true(swigCPtr, this), true);
  }
  public PTRef getTerm_false() {
    return new PTRef(OsmtNativeJNI.Logic_getTerm_false(swigCPtr, this), true);
  }
  public boolean isEquality(PTRef tr) {
    return OsmtNativeJNI.Logic_isEquality(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isDisequality(PTRef tr) {
    return OsmtNativeJNI.Logic_isDisequality(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isIte(PTRef tr) {
    return OsmtNativeJNI.Logic_isIte(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isConstant(PTRef tr) {
    return OsmtNativeJNI.Logic_isConstant(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isVar(PTRef tr) {
    return OsmtNativeJNI.Logic_isVar(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isUF(PTRef arg0) {
    return OsmtNativeJNI.Logic_isUF(swigCPtr, this, PTRef.getCPtr(arg0), arg0);
  }
  public boolean isAnd(PTRef tr) {
    return OsmtNativeJNI.Logic_isAnd(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isOr(PTRef tr) {
    return OsmtNativeJNI.Logic_isOr(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isNot(PTRef tr) {
    return OsmtNativeJNI.Logic_isNot(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isXor(PTRef tr) {
    return OsmtNativeJNI.Logic_isXor(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isImplies(PTRef tr) {
    return OsmtNativeJNI.Logic_isImplies(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isTrue(PTRef tr) {
    return OsmtNativeJNI.Logic_isTrue(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isFalse(PTRef tr) {
    return OsmtNativeJNI.Logic_isFalse(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isIff(PTRef tr) {
    return OsmtNativeJNI.Logic_isIff(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public String protectName(SymRef sr) {
    return OsmtNativeJNI.Logic_protectName(swigCPtr, this, SymRef.getCPtr(sr), sr);
  }
  public String pp(PTRef tr) {
    return OsmtNativeJNI.Logic_pp(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public PTRef mkStore(PTRef array, PTRef index, PTRef value) {
    return new PTRef(OsmtNativeJNI.Logic_mkStore(swigCPtr, this, PTRef.getCPtr(array), array, PTRef.getCPtr(index), index, PTRef.getCPtr(value), value), true);
  }
  public PTRef mkSelect(PTRef array, PTRef index) {
    return new PTRef(OsmtNativeJNI.Logic_mkSelect(swigCPtr, this, PTRef.getCPtr(array), array, PTRef.getCPtr(index), index), true);
  }
  public PTRef getDefaultValue(SRef sref) {
    return new PTRef(OsmtNativeJNI.Logic_getDefaultValue(swigCPtr, this, SRef.getCPtr(sref), sref), true);
  }
  public PTRef mkUninterpFun(SymRef f, VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkUninterpFun(swigCPtr, this, SymRef.getCPtr(f), f, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkAnd(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkAnd__SWIG_1(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkOr(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkOr__SWIG_1(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkImpl(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkImpl__SWIG_1(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkEq(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkEq__SWIG_1(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkDistinct(VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_mkDistinct__SWIG_0(swigCPtr, this, VectorPTRef.getCPtr(args), args), true);
  }
  public PTRef mkDistinct(PTRef a, PTRef b) {
    return new PTRef(OsmtNativeJNI.Logic_mkDistinct__SWIG_1(swigCPtr, this, PTRef.getCPtr(a), a, PTRef.getCPtr(b), b), true);
  }
  public SymRef declareFun(String fname, SRef rsort, VectorSRef args) {
    return new SymRef(OsmtNativeJNI.Logic_declareFun(swigCPtr, this, fname, SRef.getCPtr(rsort), rsort, VectorSRef.getCPtr(args), args), true);
  }
  public PTRef instantiateFunctionTemplate(TemplateFunction tmplt, VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_instantiateFunctionTemplate(swigCPtr, this, TemplateFunction.getCPtr(tmplt), tmplt, VectorPTRef.getCPtr(args), args), true);
  }
  public boolean isSortBool(SRef sort) {
    return OsmtNativeJNI.Logic_isSortBool(swigCPtr, this, SRef.getCPtr(sort), sort);
  }
  public PTRef insertTerm(SymRef sym, VectorPTRef args) {
    return new PTRef(OsmtNativeJNI.Logic_insertTerm(swigCPtr, this, SymRef.getCPtr(sym), sym, VectorPTRef.getCPtr(args), args), true);
  }
}
package org.sosy_lab.java_smt.api.visitors;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.List;
import org.sosy_lab.common.rationals.Rational;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaManager;
import org.sosy_lab.java_smt.api.FunctionDeclaration;
import org.sosy_lab.java_smt.api.QuantifiedFormulaManager.Quantifier;
public interface FormulaVisitor<R> {
  R visitFreeVariable(Formula f, String name);
  R visitBoundVariable(Formula f, int deBruijnIdx);
  R visitConstant(Formula f, Object value);
  R visitFunction(Formula f, List<Formula> args, FunctionDeclaration<?> functionDeclaration);
  R visitQuantifier(
      BooleanFormula f, Quantifier quantifier, List<Formula> boundVariables, BooleanFormula body);
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.math.BigInteger;
import java.util.List;
import org.sosy_lab.java_smt.api.NumeralFormula;
import org.sosy_lab.java_smt.basicimpl.AbstractNumeralFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.ArithLogic;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
@SuppressWarnings("ClassTypeParameterName")
abstract class OpenSmtNumeralFormulaManager<
        ParamFormulaType extends NumeralFormula, ResultFormulaType extends NumeralFormula>
    extends AbstractNumeralFormulaManager<
        PTRef, SRef, Logic, ParamFormulaType, ResultFormulaType, SymRef> {
  protected final ArithLogic osmtLogic;
  OpenSmtNumeralFormulaManager(
      OpenSmtFormulaCreator pCreator, NonLinearArithmetic pNonLinearArithmetic) {
    super(pCreator, pNonLinearArithmetic);
    osmtLogic = (ArithLogic) pCreator.getEnv();
  }
  protected abstract SRef getNumeralType();
  @Override
  protected boolean isNumeral(PTRef pVal) {
    return osmtLogic.isNumConst(pVal);
  }
  @Override
  protected PTRef makeNumberImpl(long i) {
    return makeNumberImpl(Long.toString(i));
  }
  @Override
  protected PTRef makeNumberImpl(BigInteger pI) {
    return makeNumberImpl(pI.toString());
  }
  @Override
  protected PTRef makeNumberImpl(String pI) {
    SRef type = getNumeralType();
    return osmtLogic.mkConst(type, pI);
  }
  @Override
  protected PTRef makeVariableImpl(String varName) {
    SRef type = getNumeralType();
    try {
      return getFormulaCreator().makeVariable(type, varName);
    } catch (RuntimeException e) {
      throw new IllegalArgumentException(e.getMessage());
    }
  }
  @Override
  protected PTRef multiply(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkTimes(pParam1, pParam2);
  }
  @Override
  protected PTRef modulo(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkMod(pParam1, pParam2);
  }
  @Override
  protected PTRef negate(PTRef pParam1) {
    return osmtLogic.mkNeg(pParam1);
  }
  @Override
  protected PTRef add(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkPlus(pParam1, pParam2);
  }
  @Override
  protected PTRef subtract(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkMinus(pParam1, pParam2);
  }
  @Override
  protected PTRef equal(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkEq(pParam1, pParam2);
  }
  @Override
  protected PTRef greaterThan(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkGt(pParam1, pParam2);
  }
  @Override
  protected PTRef greaterOrEquals(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkGeq(pParam1, pParam2);
  }
  @Override
  protected PTRef lessThan(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkLt(pParam1, pParam2);
  }
  @Override
  protected PTRef lessOrEquals(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkLeq(pParam1, pParam2);
  }
  @Override
  protected PTRef distinctImpl(List<PTRef> pParam) {
    return osmtLogic.mkDistinct(new VectorPTRef(pParam));
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class SRef {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected SRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(SRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(SRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_SRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public boolean equals(Object object) {
    if(object instanceof SRef) {
      SRef that = (SRef) object;
      return this.getX() == that.getX();
    }
    return false;
  }
  public int hashCode() {
    return Long.hashCode(this.getX());
  }
  public void setX(long value) {
    OsmtNativeJNI.SRef_x_set(swigCPtr, this, value);
  }
  public long getX() {
    return OsmtNativeJNI.SRef_x_get(swigCPtr, this);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class VectorPTRef extends java.util.AbstractList<PTRef> implements java.util.RandomAccess {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected VectorPTRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(VectorPTRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(VectorPTRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_VectorPTRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public VectorPTRef(PTRef[] initialElements) {
    this();
    reserve(initialElements.length);
    for (PTRef element : initialElements) {
      add(element);
    }
  }
  public VectorPTRef(Iterable<PTRef> initialElements) {
    this();
    for (PTRef element : initialElements) {
      add(element);
    }
  }
  public PTRef get(int index) {
    return doGet(index);
  }
  public PTRef set(int index, PTRef e) {
    return doSet(index, e);
  }
  public boolean add(PTRef e) {
    modCount++;
    doAdd(e);
    return true;
  }
  public void add(int index, PTRef e) {
    modCount++;
    doAdd(index, e);
  }
  public PTRef remove(int index) {
    modCount++;
    return doRemove(index);
  }
  protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    doRemoveRange(fromIndex, toIndex);
  }
  public int size() {
    return doSize();
  }
  public VectorPTRef() {
    this(OsmtNativeJNI.new_VectorPTRef__SWIG_0(), true);
  }
  public VectorPTRef(VectorPTRef other) {
    this(OsmtNativeJNI.new_VectorPTRef__SWIG_1(VectorPTRef.getCPtr(other), other), true);
  }
  public long capacity() {
    return OsmtNativeJNI.VectorPTRef_capacity(swigCPtr, this);
  }
  public void reserve(long n) {
    OsmtNativeJNI.VectorPTRef_reserve(swigCPtr, this, n);
  }
  public boolean isEmpty() {
    return OsmtNativeJNI.VectorPTRef_isEmpty(swigCPtr, this);
  }
  public void clear() {
    OsmtNativeJNI.VectorPTRef_clear(swigCPtr, this);
  }
  public VectorPTRef(int count, PTRef value) {
    this(OsmtNativeJNI.new_VectorPTRef__SWIG_2(count, PTRef.getCPtr(value), value), true);
  }
  private int doSize() {
    return OsmtNativeJNI.VectorPTRef_doSize(swigCPtr, this);
  }
  private void doAdd(PTRef x) {
    OsmtNativeJNI.VectorPTRef_doAdd__SWIG_0(swigCPtr, this, PTRef.getCPtr(x), x);
  }
  private void doAdd(int index, PTRef x) {
    OsmtNativeJNI.VectorPTRef_doAdd__SWIG_1(swigCPtr, this, index, PTRef.getCPtr(x), x);
  }
  private PTRef doRemove(int index) {
    return new PTRef(OsmtNativeJNI.VectorPTRef_doRemove(swigCPtr, this, index), true);
  }
  private PTRef doGet(int index) {
    return new PTRef(OsmtNativeJNI.VectorPTRef_doGet(swigCPtr, this, index), false);
  }
  private PTRef doSet(int index, PTRef val) {
    return new PTRef(OsmtNativeJNI.VectorPTRef_doSet(swigCPtr, this, index, PTRef.getCPtr(val), val), true);
  }
  private void doRemoveRange(int fromIndex, int toIndex) {
    OsmtNativeJNI.VectorPTRef_doRemoveRange(swigCPtr, this, fromIndex, toIndex);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.collect.ImmutableList;
import java.math.BigInteger;
import java.util.List;
import org.sosy_lab.common.rationals.Rational;
import org.sosy_lab.java_smt.api.ArrayFormula;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.api.FormulaType.ArrayFormulaType;
import org.sosy_lab.java_smt.api.FunctionDeclarationKind;
import org.sosy_lab.java_smt.api.visitors.FormulaVisitor;
import org.sosy_lab.java_smt.basicimpl.FormulaCreator;
import org.sosy_lab.java_smt.basicimpl.FunctionDeclarationImpl;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtFormula.OpenSmtArrayFormula;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtFormula.OpenSmtBooleanFormula;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtFormula.OpenSmtIntegerFormula;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtFormula.OpenSmtRationalFormula;
import org.sosy_lab.java_smt.solvers.opensmt.api.ArithLogic;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.LogicFactory;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic_t;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.Pterm;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorSRef;
public final class OpenSmtFormulaCreator extends FormulaCreator<PTRef, SRef, Logic, SymRef> {
  private final Logics logicToUse;
  private OpenSmtFormulaCreator(Logics logicType, Logic logic) {
    super(
        logic,
        logic.getSort_bool(),
        (logic instanceof ArithLogic) ? ((ArithLogic) logic).getSort_int() : null,
        (logic instanceof ArithLogic) ? ((ArithLogic) logic).getSort_real() : null,
        null,
        null);
    logicToUse = logicType;
  }
  public static OpenSmtFormulaCreator create(Logics logicType) {
    return new OpenSmtFormulaCreator(logicType, createLogic(logicType));
  }
  private static Logic createLogic(Logics logicType) {
    switch (logicType) {
      case CORE:
        return LogicFactory.getInstance(Logic_t.QF_BOOL);
      case QF_AX:
        return LogicFactory.getInstance(Logic_t.QF_AX);
      case QF_UF:
        return LogicFactory.getInstance(Logic_t.QF_UF);
      case QF_IDL:
        return LogicFactory.getLAInstance(Logic_t.QF_IDL);
      case QF_RDL:
        return LogicFactory.getLAInstance(Logic_t.QF_RDL);
      case QF_LIA:
        return LogicFactory.getLAInstance(Logic_t.QF_LIA);
      case QF_LRA:
        return LogicFactory.getLAInstance(Logic_t.QF_LRA);
      case QF_ALIA:
        return LogicFactory.getLAInstance(Logic_t.QF_ALIA);
      case QF_ALRA:
        return LogicFactory.getLAInstance(Logic_t.QF_ALRA);
      case QF_UFLIA:
        return LogicFactory.getLAInstance(Logic_t.QF_UFLIA);
      case QF_UFLRA:
        return LogicFactory.getLAInstance(Logic_t.QF_UFLRA);
      case QF_AUFLIA:
        return LogicFactory.getLAInstance(Logic_t.QF_AUFLIA);
      case QF_AUFLRA:
        return LogicFactory.getLAInstance(Logic_t.QF_AUFLRA);
      case QF_AUFLIRA:
        return LogicFactory.getLAInstance(Logic_t.QF_AUFLIRA);
      default:
        throw new AssertionError("no logic available");
    }
  }
  Logics getLogic() {
    return logicToUse;
  }
  @Override
  public PTRef extractInfo(Formula pT) {
    OpenSmtFormula formula = (OpenSmtFormula) pT;
    return formula.getOsmtTerm();
  }
  @Override
  public PTRef callFunctionImpl(SymRef declaration, List<PTRef> args) {
    return getEnv().insertTerm(declaration, new VectorPTRef(args));
  }
  @Override
  public SymRef declareUFImpl(String pName, SRef pReturnType, List<SRef> pArgTypes) {
    return getEnv().declareFun(pName, pReturnType, new VectorSRef(pArgTypes));
  }
  @Override
  public SRef getArrayType(SRef indexType, SRef elementType) {
    return getEnv().getArraySort(indexType, elementType);
  }
  @Override
  public SRef getBitvectorType(int bitwidth) {
    throw new UnsupportedOperationException("OpenSMT does not support bitvectors.");
  }
  @Override
  public SymRef getBooleanVarDeclarationImpl(PTRef pPTRef) {
    return getEnv().getSymRef(pPTRef);
  }
  @Override
  public SRef getFloatingPointType(FormulaType.FloatingPointType type) {
    throw new UnsupportedOperationException("OpenSMT does not support floating point operations.");
  }
  @Override
  @SuppressWarnings("MethodTypeParameterName")
  protected <TD extends Formula, TR extends Formula> FormulaType<TD> getArrayFormulaIndexType(
      ArrayFormula<TD, TR> pArray) {
    OpenSmtArrayFormula<TD, TR> array = (OpenSmtArrayFormula<TD, TR>) pArray;
    return array.getIndexType();
  }
  @Override
  @SuppressWarnings("MethodTypeParameterName")
  protected <TD extends Formula, TR extends Formula> FormulaType<TR> getArrayFormulaElementType(
      ArrayFormula<TD, TR> pArray) {
    OpenSmtArrayFormula<TD, TR> array = (OpenSmtArrayFormula<TD, TR>) pArray;
    return array.getElementType();
  }
  @SuppressWarnings("unchecked")
  @Override
  public <T extends Formula> FormulaType<T> getFormulaType(T pFormula) {
    if (pFormula instanceof ArrayFormula<?, ?>) {
      FormulaType<T> arrayIndexType = getArrayFormulaIndexType((ArrayFormula<T, T>) pFormula);
      FormulaType<T> arrayElementType = getArrayFormulaElementType((ArrayFormula<T, T>) pFormula);
      return (FormulaType<T>) FormulaType.getArrayType(arrayIndexType, arrayElementType);
    }
    return super.getFormulaType(pFormula);
  }
  @Override
  public FormulaType<?> getFormulaType(PTRef pFormula) {
    SRef sort = getEnv().getSortRef(pFormula);
    return getFormulaTypeFromTermType(sort);
  }
  private FormulaType<?> getFormulaTypeFromTermType(SRef sort) {
    Logic logic = getEnv();
    if (logic.isSortBool(sort)) {
      return FormulaType.BooleanType;
    }
    if (logic.isArraySort(sort)) {
      VectorSRef args = getEnv().getSortDefinition(sort).getArgs();
      FormulaType<?> indexType = getFormulaTypeFromTermType(args.get(0));
      FormulaType<?> elementType = getFormulaTypeFromTermType(args.get(1));
      return FormulaType.getArrayType(indexType, elementType);
    }
    ArithLogic alogic = (ArithLogic) getEnv();
    if (alogic.isSortInt(sort)) {
      return FormulaType.IntegerType;
    }
    if (alogic.isSortReal(sort)) {
      return FormulaType.RationalType;
    }
    throw new AssertionError(String.format("Encountered unhandled Type '%s'.", sort));
  }
  @SuppressWarnings("unchecked")
  @Override
  public <T extends Formula> T encapsulate(FormulaType<T> pType, PTRef pTerm) {
    assert pType.equals(getFormulaType(pTerm))
            || (pType.equals(FormulaType.RationalType)
                && getFormulaType(pTerm).equals(FormulaType.IntegerType))
        : String.format(
            "Cannot encapsulate formula %s of Type %s as %s", pTerm, getFormulaType(pTerm), pType);
    if (pType.isBooleanType()) {
      return (T) new OpenSmtBooleanFormula(getEnv(), pTerm);
    }
    if (pType.isIntegerType()) {
      return (T) new OpenSmtIntegerFormula(getEnv(), pTerm);
    }
    if (pType.isRationalType()) {
      return (T) new OpenSmtRationalFormula(getEnv(), pTerm);
    }
    if (pType.isArrayType()) {
      ArrayFormulaType<?, ?> arrFt = (ArrayFormulaType<?, ?>) pType;
      return (T)
          new OpenSmtArrayFormula<>(getEnv(), pTerm, arrFt.getIndexType(), arrFt.getElementType());
    }
    throw new IllegalArgumentException("Cannot create formulas of Type " + pType + " in OpenSMT");
  }
  public Formula encapsulate(PTRef pTerm) {
    return encapsulate(getFormulaType(pTerm), pTerm);
  }
  @Override
  public BooleanFormula encapsulateBoolean(PTRef pTerm) {
    assert getFormulaType(pTerm).isBooleanType()
        : String.format(
            "%s is not boolean, but %s (%s)",
            pTerm, getEnv().getSortRef(pTerm), getFormulaType(pTerm));
    return new OpenSmtBooleanFormula(getEnv(), pTerm);
  }
  @Override
  @SuppressWarnings("MethodTypeParameterName")
  protected <TI extends Formula, TE extends Formula> ArrayFormula<TI, TE> encapsulateArray(
      PTRef pTerm, FormulaType<TI> pIndexType, FormulaType<TE> pElementType) {
    assert getFormulaType(pTerm).equals(FormulaType.getArrayType(pIndexType, pElementType))
        : String.format(
            "%s is no array, but %s (%s)",
            pTerm, getEnv().getSortRef(pTerm), getFormulaType(pTerm));
    return new OpenSmtArrayFormula<>(getEnv(), pTerm, pIndexType, pElementType);
  }
  @Override
  public PTRef makeVariable(SRef type, String varName) {
    return getEnv().mkVar(type, varName);
  }
  @SuppressWarnings("unused")
  private FunctionDeclarationKind getDeclarationKind(PTRef f) {
    Logic logic = getEnv();
    if (logic.isAnd(f)) {
      return FunctionDeclarationKind.AND;
    } else if (logic.isIff(f)) {
      return FunctionDeclarationKind.IFF;
    } else if (logic.isImplies(f)) {
      return FunctionDeclarationKind.IMPLIES;
    } else if (logic.isIte(f)) {
      return FunctionDeclarationKind.ITE;
    } else if (logic.isNot(f)) {
      return FunctionDeclarationKind.NOT;
    } else if (logic.isOr(f)) {
      return FunctionDeclarationKind.OR;
    } else if (logic.isArraySelect(f)) {
      return FunctionDeclarationKind.SELECT;
    } else if (logic.isArrayStore(f)) {
      return FunctionDeclarationKind.STORE;
    } else if (logic.isUF(f)) {
      return FunctionDeclarationKind.UF;
    } else if (logic.isXor(f)) {
      return FunctionDeclarationKind.XOR;
    }
    ArithLogic alogic = (ArithLogic) getEnv();
    if (alogic.isPlus(f)) {
      return FunctionDeclarationKind.ADD;
    } else if (alogic.isDisequality(f)) {
      return FunctionDeclarationKind.DISTINCT;
    } else if (alogic.isDiv(f)) {
      return FunctionDeclarationKind.DIV;
    } else if (alogic.isEquality(f)) {
      return FunctionDeclarationKind.EQ;
    } else if (alogic.isGeq(f)) {
      return FunctionDeclarationKind.GT;
    } else if (alogic.isGt(f)) {
      return FunctionDeclarationKind.GTE;
    } else if (alogic.isLt(f)) {
      return FunctionDeclarationKind.LT;
    } else if (alogic.isLeq(f)) {
      return FunctionDeclarationKind.LTE;
    } else if (alogic.isMod(f)) {
      return FunctionDeclarationKind.MODULO;
    } else if (alogic.isTimes(f)) {
      return FunctionDeclarationKind.MUL;
    } else if (alogic.isMinus(f)) {
      return FunctionDeclarationKind.SUB;
    } else if (alogic.isNeg(f)) {
      return FunctionDeclarationKind.UMINUS;
    }
    throw new UnsupportedOperationException("Encountered unsupported declaration kind");
  }
  @Override
  public Object convertValue(PTRef value) {
    Logic logic = getEnv();
    if (logic.isTrue(value)) {
      return Boolean.TRUE;
    }
    if (logic.isFalse(value)) {
      return Boolean.FALSE;
    }
    ArithLogic alogic = (ArithLogic) getEnv();
    if (alogic.isIntConst(value)) {
      return new BigInteger(alogic.getNumConst(value));
    }
    if (alogic.isRealConst(value)) {
      Rational ratValue = Rational.ofString(alogic.getNumConst(value));
      return ratValue.isIntegral() ? ratValue.getNum() : ratValue;
    }
    throw new UnsupportedOperationException("Term `" + logic.pp(value) + "` is not a value");
  }
  @Override
  public <R> R visit(FormulaVisitor<R> visitor, Formula formula, PTRef f) {
    Logic logic = getEnv();
    if (logic.isConstant(f)) {
      return visitor.visitConstant(formula, convertValue(f));
    }
    if (logic.isVar(f)) {
      String varName = logic.getSymName(logic.getSymRef(f));
      return visitor.visitFreeVariable(formula, dequote(varName));
    }
    String varName = logic.getSymName(logic.getSymRef(f));
    ImmutableList.Builder<Formula> argTerms = ImmutableList.builder();
    ImmutableList.Builder<FormulaType<?>> argTypes = ImmutableList.builder();
    Pterm pterm = logic.getPterm(f);
    for (int i = 0; i < pterm.size(); i++) {
      PTRef sub = pterm.at(i);
      argTerms.add(encapsulate(sub));
      argTypes.add(getFormulaType(sub));
    }
    return visitor.visitFunction(
        formula,
        argTerms.build(),
        FunctionDeclarationImpl.of(
            varName,
            getDeclarationKind(f),
            argTypes.build(),
            getFormulaType(f),
            logic.getSymRef(f)));
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class ArithLogic extends Logic {
  private transient long swigCPtr;
  protected ArithLogic(long cPtr, boolean cMemoryOwn) {
    super(OsmtNativeJNI.ArithLogic_SWIGUpcast(cPtr), cMemoryOwn);
    swigCPtr = cPtr;
  }
  protected static long getCPtr(ArithLogic obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(ArithLogic obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_ArithLogic(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }
  public ArithLogic(ArithLogic arg0) {
    this(OsmtNativeJNI.new_ArithLogic(ArithLogic.swigRelease(arg0), arg0), true);
  }
  public SRef getSort_real() {
    return new SRef(OsmtNativeJNI.ArithLogic_getSort_real(swigCPtr, this), true);
  }
  public SRef getSort_int() {
    return new SRef(OsmtNativeJNI.ArithLogic_getSort_int(swigCPtr, this), true);
  }
  public PTRef mkConst(SRef s, String name) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkConst(swigCPtr, this, SRef.getCPtr(s), s, name), true);
  }
  public PTRef mkIntVar(String name) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkIntVar(swigCPtr, this, name), true);
  }
  public PTRef mkRealVar(String name) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkRealVar(swigCPtr, this, name), true);
  }
  public boolean isNumConst(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isNumConst(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isIntConst(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isIntConst(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isRealConst(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isRealConst(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isSortInt(SRef sr) {
    return OsmtNativeJNI.ArithLogic_isSortInt(swigCPtr, this, SRef.getCPtr(sr), sr);
  }
  public boolean isSortReal(SRef sr) {
    return OsmtNativeJNI.ArithLogic_isSortReal(swigCPtr, this, SRef.getCPtr(sr), sr);
  }
  public boolean isPlus(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isPlus(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isNeg(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isNeg(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isTimes(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isTimes(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isLeq(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isLeq(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isLt(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isLt(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isGeq(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isGeq(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isGt(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isGt(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public PTRef getTerm_IntZero() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_IntZero(swigCPtr, this), true);
  }
  public PTRef getTerm_RealZero() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_RealZero(swigCPtr, this), true);
  }
  public PTRef getTerm_IntOne() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_IntOne(swigCPtr, this), true);
  }
  public PTRef getTerm_RealOne() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_RealOne(swigCPtr, this), true);
  }
  public PTRef getTerm_IntMinusOne() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_IntMinusOne(swigCPtr, this), true);
  }
  public PTRef getTerm_RealMinusOne() {
    return new PTRef(OsmtNativeJNI.ArithLogic_getTerm_RealMinusOne(swigCPtr, this), true);
  }
  public PTRef mkNeg(PTRef tr) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkNeg(swigCPtr, this, PTRef.getCPtr(tr), tr), true);
  }
  public PTRef mkMinus(PTRef a1, PTRef a2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkMinus(swigCPtr, this, PTRef.getCPtr(a1), a1, PTRef.getCPtr(a2), a2), true);
  }
  public PTRef mkPlus(PTRef p1, PTRef p2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkPlus(swigCPtr, this, PTRef.getCPtr(p1), p1, PTRef.getCPtr(p2), p2), true);
  }
  public PTRef mkTimes(PTRef p1, PTRef p2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkTimes(swigCPtr, this, PTRef.getCPtr(p1), p1, PTRef.getCPtr(p2), p2), true);
  }
  public PTRef mkIntDiv(PTRef nom, PTRef den) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkIntDiv(swigCPtr, this, PTRef.getCPtr(nom), nom, PTRef.getCPtr(den), den), true);
  }
  public PTRef mkRealDiv(PTRef nom, PTRef den) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkRealDiv(swigCPtr, this, PTRef.getCPtr(nom), nom, PTRef.getCPtr(den), den), true);
  }
  public PTRef mkMod(PTRef first, PTRef second) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkMod(swigCPtr, this, PTRef.getCPtr(first), first, PTRef.getCPtr(second), second), true);
  }
  public PTRef mkLeq(PTRef arg1, PTRef arg2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkLeq(swigCPtr, this, PTRef.getCPtr(arg1), arg1, PTRef.getCPtr(arg2), arg2), true);
  }
  public PTRef mkGeq(PTRef arg1, PTRef arg2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkGeq(swigCPtr, this, PTRef.getCPtr(arg1), arg1, PTRef.getCPtr(arg2), arg2), true);
  }
  public PTRef mkLt(PTRef arg1, PTRef arg2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkLt(swigCPtr, this, PTRef.getCPtr(arg1), arg1, PTRef.getCPtr(arg2), arg2), true);
  }
  public PTRef mkGt(PTRef arg1, PTRef arg2) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkGt(swigCPtr, this, PTRef.getCPtr(arg1), arg1, PTRef.getCPtr(arg2), arg2), true);
  }
  public PTRef mkIntConst(String c) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkIntConst(swigCPtr, this, c), true);
  }
  public PTRef mkRealConst(String c) {
    return new PTRef(OsmtNativeJNI.ArithLogic_mkRealConst(swigCPtr, this, c), true);
  }
  public String getNumConst(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_getNumConst(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isMinus(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isMinus(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isDiv(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isDiv(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
  public boolean isMod(PTRef tr) {
    return OsmtNativeJNI.ArithLogic_isMod(swigCPtr, this, PTRef.getCPtr(tr), tr);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class SymRef {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected SymRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(SymRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(SymRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_SymRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public boolean equals(Object object) {
    if(object instanceof SymRef) {
      SymRef that = (SymRef) object;
      return this.getX() == that.getX();
    }
    return false;
  }
  public int hashCode() {
    return Long.hashCode(this.getX());
  }
  public void setX(long value) {
    OsmtNativeJNI.SymRef_x_set(swigCPtr, this, value);
  }
  public long getX() {
    return OsmtNativeJNI.SymRef_x_get(swigCPtr, this);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.math.BigDecimal;
import org.sosy_lab.java_smt.api.NumeralFormula;
import org.sosy_lab.java_smt.api.NumeralFormula.RationalFormula;
import org.sosy_lab.java_smt.api.RationalFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
public class OpenSmtRationalFormulaManager
    extends OpenSmtNumeralFormulaManager<NumeralFormula, RationalFormula>
    implements RationalFormulaManager {
  OpenSmtRationalFormulaManager(
      OpenSmtFormulaCreator pCreator, NonLinearArithmetic pNonLinearArithmetic) {
    super(pCreator, pNonLinearArithmetic);
  }
  @Override
  protected SRef getNumeralType() {
    return getFormulaCreator().getRationalType();
  }
  @Override
  protected PTRef makeNumberImpl(double pNumber) {
    return makeNumberImpl(Double.toString(pNumber));
  }
  @Override
  protected PTRef makeNumberImpl(BigDecimal pNumber) {
    return makeNumberImpl(pNumber.toPlainString());
  }
  @Override
  public PTRef divide(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkRealDiv(pParam1, pParam2);
  }
  @Override
  protected PTRef floor(PTRef pNumber) {
    throw new UnsupportedOperationException("OpenSMT does not support ´floor´ operation");
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class LogicFactory {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected LogicFactory(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(LogicFactory obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(LogicFactory obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_LogicFactory(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public static Logic getInstance(Logic_t arg0) {
    long cPtr = OsmtNativeJNI.LogicFactory_getInstance(arg0.swigValue());
    return (cPtr == 0) ? null : new Logic(cPtr, true);
  }
  public static ArithLogic getLAInstance(Logic_t arg0) {
    long cPtr = OsmtNativeJNI.LogicFactory_getLAInstance(arg0.swigValue());
    return (cPtr == 0) ? null : new ArithLogic(cPtr, true);
  }
  public static ArithLogic getLRAInstance() {
    long cPtr = OsmtNativeJNI.LogicFactory_getLRAInstance();
    return (cPtr == 0) ? null : new ArithLogic(cPtr, true);
  }
  public static ArithLogic getLIAInstance() {
    long cPtr = OsmtNativeJNI.LogicFactory_getLIAInstance();
    return (cPtr == 0) ? null : new ArithLogic(cPtr, true);
  }
  public static String getVersion() {
    return OsmtNativeJNI.LogicFactory_getVersion();
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.basicimpl.AbstractArrayFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
@SuppressWarnings("MethodTypeParameterName")
public class OpenSmtArrayFormulaManager
    extends AbstractArrayFormulaManager<PTRef, SRef, Logic, SymRef> {
  private final Logic logic;
  public OpenSmtArrayFormulaManager(OpenSmtFormulaCreator pFormulaCreator) {
    super(pFormulaCreator);
    logic = pFormulaCreator.getEnv();
  }
  @Override
  protected PTRef select(PTRef pArray, PTRef pIndex) {
    return logic.mkSelect(pArray, pIndex);
  }
  @Override
  protected PTRef store(PTRef pArray, PTRef pIndex, PTRef pValue) {
    return logic.mkStore(pArray, pIndex, pValue);
  }
  @Override
  @SuppressWarnings("MethodTypeParameterName")
  protected <TI extends Formula, TE extends Formula> PTRef internalMakeArray(
      String pName, FormulaType<TI> pIndexType, FormulaType<TE> pElementType) {
    final SRef osmtArrayType = toSolverType(FormulaType.getArrayType(pIndexType, pElementType));
    return getFormulaCreator().makeVariable(osmtArrayType, pName);
  }
  @Override
  protected <TI extends Formula, TE extends Formula> PTRef internalMakeArray(
      FormulaType<TI> pIndexType, FormulaType<TE> pElementType, PTRef defaultElement) {
    throw new UnsupportedOperationException();
  }
  @Override
  protected PTRef equivalence(PTRef pArray1, PTRef pArray2) {
    return logic.mkEq(pArray1, pArray2);
  }
}
package org.sosy_lab.java_smt.basicimpl;
import com.google.auto.value.AutoValue;
import com.google.common.collect.ImmutableList;
import com.google.errorprone.annotations.Immutable;
import java.util.List;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.api.FunctionDeclaration;
import org.sosy_lab.java_smt.api.FunctionDeclarationKind;
@Immutable(containerOf = "T")
@AutoValue
public abstract class FunctionDeclarationImpl<F extends Formula, T>
    implements FunctionDeclaration<F> {
  public static <F extends Formula, T> FunctionDeclaration<F> of(
      String name,
      FunctionDeclarationKind kind,
      List<FormulaType<?>> pArgumentTypes,
      FormulaType<F> pReturnType,
      T pDeclaration) {
    return new AutoValue_FunctionDeclarationImpl<>(
        kind, name, pReturnType, ImmutableList.copyOf(pArgumentTypes), pDeclaration);
  }
  public abstract T getSolverDeclaration();
  @Override
  public final String toString() {
    return String.format("%s (%s)", getKind(), getName());
  }
}
package org.sosy_lab.java_smt.basicimpl;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.errorprone.annotations.CanIgnoreReturnValue;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.Predicate;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.sosy_lab.java_smt.api.ArrayFormula;
import org.sosy_lab.java_smt.api.BitvectorFormula;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.EnumerationFormula;
import org.sosy_lab.java_smt.api.FloatingPointFormula;
import org.sosy_lab.java_smt.api.FloatingPointRoundingModeFormula;
import org.sosy_lab.java_smt.api.Formula;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.api.FormulaType.ArrayFormulaType;
import org.sosy_lab.java_smt.api.FormulaType.FloatingPointType;
import org.sosy_lab.java_smt.api.FunctionDeclaration;
import org.sosy_lab.java_smt.api.FunctionDeclarationKind;
import org.sosy_lab.java_smt.api.NumeralFormula.IntegerFormula;
import org.sosy_lab.java_smt.api.NumeralFormula.RationalFormula;
import org.sosy_lab.java_smt.api.QuantifiedFormulaManager.Quantifier;
import org.sosy_lab.java_smt.api.RegexFormula;
import org.sosy_lab.java_smt.api.StringFormula;
import org.sosy_lab.java_smt.api.visitors.DefaultFormulaVisitor;
import org.sosy_lab.java_smt.api.visitors.FormulaVisitor;
import org.sosy_lab.java_smt.api.visitors.TraversalProcess;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.ArrayFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.BitvectorFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.BooleanFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.EnumerationFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.FloatingPointFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.FloatingPointRoundingModeFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.IntegerFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.RationalFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.RegexFormulaImpl;
import org.sosy_lab.java_smt.basicimpl.AbstractFormula.StringFormulaImpl;
@SuppressWarnings({"ClassTypeParameterName", "MethodTypeParameterName"})
public abstract class FormulaCreator<TFormulaInfo, TType, TEnv, TFuncDecl> {
  private final TType boolType;
  private final @Nullable TType integerType;
  private final @Nullable TType rationalType;
  private final @Nullable TType stringType;
  private final @Nullable TType regexType;
  protected final TEnv environment;
  protected FormulaCreator(
      TEnv env,
      TType boolType,
      @Nullable TType pIntegerType,
      @Nullable TType pRationalType,
      @Nullable TType stringType,
      @Nullable TType regexType) {
    this.environment = env;
    this.boolType = boolType;
    this.integerType = pIntegerType;
    this.rationalType = pRationalType;
    this.stringType = stringType;
    this.regexType = regexType;
  }
  public final TEnv getEnv() {
    return environment;
  }
  public final TType getBoolType() {
    return boolType;
  }
  public final TType getIntegerType() {
    if (integerType == null) {
      throw new UnsupportedOperationException("Integer theory is not supported by this solver.");
    }
    return integerType;
  }
  public final TType getRationalType() {
    if (rationalType == null) {
      throw new UnsupportedOperationException("Rational theory is not supported by this solver.");
    }
    return rationalType;
  }
  public abstract TType getBitvectorType(int bitwidth);
  public abstract TType getFloatingPointType(FloatingPointType type);
  public abstract TType getArrayType(TType indexType, TType elementType);
  public final TType getStringType() {
    if (stringType == null) {
      throw new UnsupportedOperationException("String theory is not supported by this solver.");
    }
    return stringType;
  }
  public final TType getRegexType() {
    if (regexType == null) {
      throw new UnsupportedOperationException("String theory is not supported by this solver.");
    }
    return regexType;
  }
  public abstract TFormulaInfo makeVariable(TType type, String varName);
  public BooleanFormula encapsulateBoolean(TFormulaInfo pTerm) {
    checkArgument(
        getFormulaType(pTerm).isBooleanType(),
        "Boolean formula has unexpected type: %s",
        getFormulaType(pTerm));
    return new BooleanFormulaImpl<>(pTerm);
  }
  protected BitvectorFormula encapsulateBitvector(TFormulaInfo pTerm) {
    checkArgument(
        getFormulaType(pTerm).isBitvectorType(),
        "Bitvector formula has unexpected type: %s",
        getFormulaType(pTerm));
    return new BitvectorFormulaImpl<>(pTerm);
  }
  protected FloatingPointFormula encapsulateFloatingPoint(TFormulaInfo pTerm) {
    checkArgument(
        getFormulaType(pTerm).isFloatingPointType(),
        "Floatingpoint formula has unexpected type: %s",
        getFormulaType(pTerm));
    return new FloatingPointFormulaImpl<>(pTerm);
  }
  protected <TI extends Formula, TE extends Formula> ArrayFormula<TI, TE> encapsulateArray(
      TFormulaInfo pTerm, FormulaType<TI> pIndexType, FormulaType<TE> pElementType) {
    checkArgument(
        getFormulaType(pTerm).equals(FormulaType.getArrayType(pIndexType, pElementType)),
        "Array formula has unexpected type: %s",
        getFormulaType(pTerm));
    return new ArrayFormulaImpl<>(pTerm, pIndexType, pElementType);
  }
  protected StringFormula encapsulateString(TFormulaInfo pTerm) {
    checkArgument(
        getFormulaType(pTerm).isStringType(),
        "String formula has unexpected type: %s",
        getFormulaType(pTerm));
    return new StringFormulaImpl<>(pTerm);
  }
  protected RegexFormula encapsulateRegex(TFormulaInfo pTerm) {
    checkArgument(
        getFormulaType(pTerm).isRegexType(),
        "Regex formula has unexpected type: %s",
        getFormulaType(pTerm));
    return new RegexFormulaImpl<>(pTerm);
  }
  protected EnumerationFormula encapsulateEnumeration(TFormulaInfo pTerm) {
    checkArgument(
        getFormulaType(pTerm).isEnumerationType(),
        "Enumeration formula has unexpected type: %s",
        getFormulaType(pTerm));
    return new EnumerationFormulaImpl<>(pTerm);
  }
  public Formula encapsulateWithTypeOf(TFormulaInfo pTerm) {
    return encapsulate(getFormulaType(pTerm), pTerm);
  }
  @SuppressWarnings("unchecked")
  public <T extends Formula> T encapsulate(FormulaType<T> pType, TFormulaInfo pTerm) {
    checkArgument(
        pType.equals(getFormulaType(pTerm)),
        "Trying to encapsulate formula %s of type %s as %s",
        pTerm,
        getFormulaType(pTerm),
        pType);
    if (pType.isBooleanType()) {
      return (T) new BooleanFormulaImpl<>(pTerm);
    } else if (pType.isIntegerType()) {
      return (T) new IntegerFormulaImpl<>(pTerm);
    } else if (pType.isRationalType()) {
      return (T) new RationalFormulaImpl<>(pTerm);
    } else if (pType.isStringType()) {
      return (T) new StringFormulaImpl<>(pTerm);
    } else if (pType.isRegexType()) {
      return (T) new RegexFormulaImpl<>(pTerm);
    } else if (pType.isBitvectorType()) {
      return (T) new BitvectorFormulaImpl<>(pTerm);
    } else if (pType.isFloatingPointType()) {
      return (T) new FloatingPointFormulaImpl<>(pTerm);
    } else if (pType.isFloatingPointRoundingModeType()) {
      return (T) new FloatingPointRoundingModeFormulaImpl<>(pTerm);
    } else if (pType.isArrayType()) {
      ArrayFormulaType<?, ?> arrayType = (ArrayFormulaType<?, ?>) pType;
      return (T) encapsulateArray(pTerm, arrayType.getIndexType(), arrayType.getElementType());
    } else if (pType.isEnumerationType()) {
      return (T) new EnumerationFormulaImpl<>(pTerm);
    }
    throw new IllegalArgumentException(
        "Cannot create formulas of type " + pType + " in the Solver!");
  }
  @SuppressWarnings("unchecked")
  protected TFormulaInfo extractInfo(Formula pT) {
    if (pT instanceof AbstractFormula) {
      return ((AbstractFormula<TFormulaInfo>) pT).getFormulaInfo();
    }
    throw new IllegalArgumentException(
        "Cannot get the formula info of type " + pT.getClass().getSimpleName() + " in the Solver!");
  }
  @SuppressWarnings("unchecked")
  protected <TI extends Formula, TE extends Formula> FormulaType<TE> getArrayFormulaElementType(
      ArrayFormula<TI, TE> pArray) {
    return ((ArrayFormulaImpl<TI, TE, TFormulaInfo>) pArray).getElementType();
  }
  @SuppressWarnings("unchecked")
  protected <TI extends Formula, TE extends Formula> FormulaType<TI> getArrayFormulaIndexType(
      ArrayFormula<TI, TE> pArray) {
    return ((ArrayFormulaImpl<TI, TE, TFormulaInfo>) pArray).getIndexType();
  }
  @SuppressWarnings("unchecked")
  protected <T extends Formula> FormulaType<T> getFormulaType(T formula) {
    checkNotNull(formula);
    FormulaType<?> t;
    if (formula instanceof BooleanFormula) {
      t = FormulaType.BooleanType;
    } else if (formula instanceof IntegerFormula) {
      t = FormulaType.IntegerType;
    } else if (formula instanceof RationalFormula) {
      t = FormulaType.RationalType;
    } else if (formula instanceof StringFormula) {
      t = FormulaType.StringType;
    } else if (formula instanceof RegexFormula) {
      t = FormulaType.RegexType;
    } else if (formula instanceof FloatingPointRoundingModeFormula) {
      t = FormulaType.FloatingPointRoundingModeType;
    } else if (formula instanceof ArrayFormula) {
      throw new UnsupportedOperationException(
          "SMT solvers with support for arrays need to overwrite FormulaCreator.getFormulaType()");
    } else if (formula instanceof BitvectorFormula) {
      throw new UnsupportedOperationException(
          "SMT solvers with support for bitvectors "
              + "need to overwrite FormulaCreator.getFormulaType()");
    } else if (formula instanceof EnumerationFormula) {
      throw new UnsupportedOperationException(
          "SMT solvers with support for enumerations need to overwrite FormulaCreator"
              + ".getFormulaType()");
    } else {
      throw new IllegalArgumentException("Formula with unexpected type " + formula.getClass());
    }
    return (FormulaType<T>) t;
  }
  public abstract FormulaType<?> getFormulaType(TFormulaInfo formula);
  @CanIgnoreReturnValue
  public <R> R visit(Formula input, FormulaVisitor<R> visitor) {
    return visit(visitor, input, extractInfo(input));
  }
  public abstract <R> R visit(FormulaVisitor<R> visitor, Formula formula, TFormulaInfo f);
  protected List<TFormulaInfo> extractInfo(List<? extends Formula> input) {
    return Lists.transform(input, this::extractInfo);
  }
  public void visitRecursively(FormulaVisitor<TraversalProcess> pFormulaVisitor, Formula pF) {
    visitRecursively(pFormulaVisitor, pF, t -> true);
  }
  public void visitRecursively(
      FormulaVisitor<TraversalProcess> pFormulaVisitor,
      Formula pF,
      Predicate<Formula> shouldProcess) {
    RecursiveFormulaVisitorImpl recVisitor = new RecursiveFormulaVisitorImpl(pFormulaVisitor);
    recVisitor.addToQueue(pF);
    while (!recVisitor.isQueueEmpty()) {
      Formula tt = recVisitor.pop();
      if (shouldProcess.test(tt)) {
        TraversalProcess process = visit(tt, recVisitor);
        if (process == TraversalProcess.ABORT) {
          return;
        }
      }
    }
  }
  public <T extends Formula> T transformRecursively(
      FormulaVisitor<? extends Formula> pFormulaVisitor, T pF) {
    return transformRecursively(pFormulaVisitor, pF, t -> true);
  }
  public <T extends Formula> T transformRecursively(
      FormulaVisitor<? extends Formula> pFormulaVisitor, T pF, Predicate<Object> shouldProcess) {
    final Deque<Formula> toProcess = new ArrayDeque<>();
    Map<Formula, Formula> pCache = new HashMap<>();
    FormulaTransformationVisitorImpl recVisitor =
        new FormulaTransformationVisitorImpl(pFormulaVisitor, toProcess, pCache);
    toProcess.push(pF);
    while (!toProcess.isEmpty()) {
      Formula tt = toProcess.peek();
      if (pCache.containsKey(tt)) {
        toProcess.pop();
        continue;
      }
      if (shouldProcess.test(tt)) {
        visit(tt, recVisitor);
      } else {
        pCache.put(tt, tt);
      }
    }
    @SuppressWarnings("unchecked")
    T out = (T) pCache.get(pF);
    return out;
  }
  public Map<String, TFormulaInfo> extractVariablesAndUFs(
      final TFormulaInfo pFormula, final boolean extractUFs) {
    Map<String, TFormulaInfo> found = new LinkedHashMap<>();
    extractVariablesAndUFs(
        encapsulateWithTypeOf(pFormula), extractUFs, (name, f) -> found.put(name, extractInfo(f)));
    return found;
  }
  public void extractVariablesAndUFs(
      final TFormulaInfo pFormula,
      final boolean extractUFs,
      final BiConsumer<String, TFormulaInfo> pConsumer) {
    extractVariablesAndUFs(
        encapsulateWithTypeOf(pFormula),
        extractUFs,
        (name, f) -> pConsumer.accept(name, extractInfo(f)));
  }
  public void extractVariablesAndUFs(
      final Formula pFormula,
      final boolean extractUF,
      final BiConsumer<String, Formula> pConsumer) {
    visitRecursively(
        new VariableAndUFExtractor(extractUF, pConsumer, ImmutableSet.of(), new LinkedHashSet<>()),
        pFormula);
  }
  private class VariableAndUFExtractor extends DefaultFormulaVisitor<TraversalProcess> {
    private final boolean extractUF;
    private final BiConsumer<String, Formula> consumer;
    private final Set<Formula> boundVariablesInContext;
    private final Set<Formula> alreadyVisited;
    VariableAndUFExtractor(
        boolean pExtractUF,
        BiConsumer<String, Formula> pConsumer,
        Set<Formula> pBoundVariablesInContext,
        Set<Formula> pAlreadyVisited) {
      extractUF = pExtractUF;
      consumer = pConsumer;
      boundVariablesInContext = pBoundVariablesInContext;
      alreadyVisited = pAlreadyVisited;
    }
    @Override
    protected TraversalProcess visitDefault(Formula f) {
      return TraversalProcess.CONTINUE;
    }
    @Override
    public TraversalProcess visitFunction(
        Formula f, List<Formula> args, FunctionDeclaration<?> functionDeclaration) {
      if (!boundVariablesInContext.contains(f) 
          && functionDeclaration.getKind() == FunctionDeclarationKind.UF
          && extractUF) {
        if (alreadyVisited.add(f)) {
          consumer.accept(functionDeclaration.getName(), f);
        }
      }
      return TraversalProcess.CONTINUE;
    }
    @Override
    public TraversalProcess visitFreeVariable(Formula f, String name) {
      if (!boundVariablesInContext.contains(f)) {
        if (alreadyVisited.add(f)) {
          consumer.accept(name, f);
        }
      }
      return TraversalProcess.CONTINUE;
    }
    @Override
    public TraversalProcess visitQuantifier(
        BooleanFormula f, Quantifier q, List<Formula> boundVariables, BooleanFormula body) {
      visitRecursively(
          new VariableAndUFExtractor(
              extractUF,
              consumer,
              Sets.union(boundVariablesInContext, ImmutableSet.copyOf(boundVariables)),
              alreadyVisited),
          body);
      return TraversalProcess.SKIP;
    }
  }
  @SuppressWarnings("unchecked")
  public final <T extends Formula> T callFunction(
      FunctionDeclaration<T> declaration, List<? extends Formula> args) {
    checkArgument(
        args.size() >= declaration.getArgumentTypes().size(),
        "function application '%s' requires %s arguments, but received %s arguments",
        declaration,
        declaration.getArgumentTypes().size(),
        args.size());
    for (int i = 0; i < args.size(); i++) {
      int index = Math.min(i, declaration.getArgumentTypes().size() - 1);
      checkArgument(
          isCompatible(getFormulaType(args.get(i)), declaration.getArgumentTypes().get(index)),
          "function application '%s' requires argument types %s, but received argument types %s",
          declaration,
          declaration.getArgumentTypes(),
          Lists.transform(args, this::getFormulaType));
    }
    return encapsulate(
        declaration.getType(),
        callFunctionImpl(
            ((FunctionDeclarationImpl<T, TFuncDecl>) declaration).getSolverDeclaration(),
            extractInfo(args)));
  }
  protected boolean isCompatible(FormulaType<?> usedType, FormulaType<?> declaredType) {
    if (usedType.isIntegerType() && declaredType.isRationalType()) {
      return true;
    }
    return usedType.equals(declaredType);
  }
  public abstract TFormulaInfo callFunctionImpl(TFuncDecl declaration, List<TFormulaInfo> args);
  public abstract TFuncDecl declareUFImpl(String pName, TType pReturnType, List<TType> pArgTypes);
  public TFuncDecl getBooleanVarDeclaration(BooleanFormula var) {
    return getBooleanVarDeclarationImpl(extractInfo(var));
  }
  protected abstract TFuncDecl getBooleanVarDeclarationImpl(TFormulaInfo pTFormulaInfo);
  public Object convertValue(TFormulaInfo pF) {
    throw new UnsupportedOperationException(
        "This SMT solver needs a second term to determine a correct type. "
            + "Please use the other method 'convertValue(formula, formula)'.");
  }
  public Object convertValue(
      @SuppressWarnings("unused") TFormulaInfo pAdditionalF, TFormulaInfo pF) {
    return convertValue(pF);
  }
  protected static String dequote(String s) {
    int l = s.length();
    if (s.charAt(0) == '|' && s.charAt(l - 1) == '|') {
      return s.substring(1, l - 1);
    }
    return s;
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class Pterm {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected Pterm(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(Pterm obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(Pterm obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_Pterm(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public int size() {
    return OsmtNativeJNI.Pterm_size(swigCPtr, this);
  }
  public SymRef symb() {
    return new SymRef(OsmtNativeJNI.Pterm_symb(swigCPtr, this), true);
  }
  public PTRef at(int i) {
    return new PTRef(OsmtNativeJNI.Pterm_at(swigCPtr, this, i), true);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt.api;
public class VectorSRef extends java.util.AbstractList<SRef> implements java.util.RandomAccess {
  private transient long swigCPtr;
  protected transient boolean swigCMemOwn;
  protected VectorSRef(long cPtr, boolean cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = cPtr;
  }
  protected static long getCPtr(VectorSRef obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }
  protected static long swigRelease(VectorSRef obj) {
    long ptr = 0;
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new RuntimeException("Cannot release ownership as memory is not owned");
      ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.delete();
    }
    return ptr;
  }
  @SuppressWarnings("deprecation")
  protected void finalize() {
    delete();
  }
  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwn) {
        swigCMemOwn = false;
        OsmtNativeJNI.delete_VectorSRef(swigCPtr);
      }
      swigCPtr = 0;
    }
  }
  public VectorSRef(SRef[] initialElements) {
    this();
    reserve(initialElements.length);
    for (SRef element : initialElements) {
      add(element);
    }
  }
  public VectorSRef(Iterable<SRef> initialElements) {
    this();
    for (SRef element : initialElements) {
      add(element);
    }
  }
  public SRef get(int index) {
    return doGet(index);
  }
  public SRef set(int index, SRef e) {
    return doSet(index, e);
  }
  public boolean add(SRef e) {
    modCount++;
    doAdd(e);
    return true;
  }
  public void add(int index, SRef e) {
    modCount++;
    doAdd(index, e);
  }
  public SRef remove(int index) {
    modCount++;
    return doRemove(index);
  }
  protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    doRemoveRange(fromIndex, toIndex);
  }
  public int size() {
    return doSize();
  }
  public VectorSRef() {
    this(OsmtNativeJNI.new_VectorSRef__SWIG_0(), true);
  }
  public VectorSRef(VectorSRef other) {
    this(OsmtNativeJNI.new_VectorSRef__SWIG_1(VectorSRef.getCPtr(other), other), true);
  }
  public long capacity() {
    return OsmtNativeJNI.VectorSRef_capacity(swigCPtr, this);
  }
  public void reserve(long n) {
    OsmtNativeJNI.VectorSRef_reserve(swigCPtr, this, n);
  }
  public boolean isEmpty() {
    return OsmtNativeJNI.VectorSRef_isEmpty(swigCPtr, this);
  }
  public void clear() {
    OsmtNativeJNI.VectorSRef_clear(swigCPtr, this);
  }
  public VectorSRef(int count, SRef value) {
    this(OsmtNativeJNI.new_VectorSRef__SWIG_2(count, SRef.getCPtr(value), value), true);
  }
  private int doSize() {
    return OsmtNativeJNI.VectorSRef_doSize(swigCPtr, this);
  }
  private void doAdd(SRef x) {
    OsmtNativeJNI.VectorSRef_doAdd__SWIG_0(swigCPtr, this, SRef.getCPtr(x), x);
  }
  private void doAdd(int index, SRef x) {
    OsmtNativeJNI.VectorSRef_doAdd__SWIG_1(swigCPtr, this, index, SRef.getCPtr(x), x);
  }
  private SRef doRemove(int index) {
    return new SRef(OsmtNativeJNI.VectorSRef_doRemove(swigCPtr, this, index), true);
  }
  private SRef doGet(int index) {
    return new SRef(OsmtNativeJNI.VectorSRef_doGet(swigCPtr, this, index), false);
  }
  private SRef doSet(int index, SRef val) {
    return new SRef(OsmtNativeJNI.VectorSRef_doSet(swigCPtr, this, index, SRef.getCPtr(val), val), true);
  }
  private void doRemoveRange(int fromIndex, int toIndex) {
    OsmtNativeJNI.VectorSRef_doRemoveRange(swigCPtr, this, fromIndex, toIndex);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import java.util.Map;
import org.sosy_lab.java_smt.api.FormulaType;
import org.sosy_lab.java_smt.basicimpl.AbstractFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.Symbol;
class OpenSmtFormulaManager extends AbstractFormulaManager<PTRef, SRef, Logic, SymRef> {
  private final OpenSmtFormulaCreator creator;
  private final Logic osmtLogic;
  OpenSmtFormulaManager(
      OpenSmtFormulaCreator pFormulaCreator,
      OpenSmtUFManager pFfmgr,
      OpenSmtBooleanFormulaManager pBfmgr,
      OpenSmtIntegerFormulaManager pIfmgr,
      OpenSmtRationalFormulaManager pRfmgr,
      OpenSmtArrayFormulaManager pAfmgr) {
    super(
        pFormulaCreator,
        pFfmgr,
        pBfmgr,
        pIfmgr,
        pRfmgr,
        null,
        null,
        null,
        pAfmgr,
        null,
        null,
        null);
    creator = pFormulaCreator;
    osmtLogic = pFormulaCreator.getEnv();
  }
  @Override
  public PTRef parseImpl(String pS) throws IllegalArgumentException {
    return osmtLogic.parseFormula(pS);
  }
  @Override
  public String dumpFormulaImpl(PTRef f) {
    assert getFormulaCreator().getFormulaType(f) == FormulaType.BooleanType
        : "Only BooleanFormulas may be dumped";
    StringBuilder out = new StringBuilder();
    Map<String, PTRef> userDeclarations = creator.extractVariablesAndUFs(f, true);
    for (PTRef term : userDeclarations.values()) {
      SymRef ref = osmtLogic.getSymRef(term);
      Symbol sym = osmtLogic.getSym(ref);
      out.append("(declare-fun ")
          .append(osmtLogic.protectName(ref))
          .append(" (")
          .append(Joiner.on(' ').join(Lists.transform(sym.getArgTypes(), osmtLogic::printSort)))
          .append(") ")
          .append(osmtLogic.printSort(sym.rsort()))
          .append(")\n");
    }
    out.append("(assert ").append(osmtLogic.dumpWithLets(f)).append(')');
    return out.toString();
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.util.Collection;
import org.sosy_lab.java_smt.basicimpl.AbstractBooleanFormulaManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
public class OpenSmtBooleanFormulaManager
    extends AbstractBooleanFormulaManager<PTRef, SRef, Logic, SymRef> {
  private final Logic logic;
  private final PTRef openSmtTrue;
  private final PTRef openSmtFalse;
  OpenSmtBooleanFormulaManager(OpenSmtFormulaCreator pCreator) {
    super(pCreator);
    logic = pCreator.getEnv();
    openSmtTrue = logic.getTerm_true();
    openSmtFalse = logic.getTerm_false();
  }
  @Override
  protected PTRef and(PTRef pParam1, PTRef pParam2) {
    return logic.mkAnd(pParam1, pParam2);
  }
  @Override
  protected PTRef andImpl(Collection<PTRef> pParams) {
    return logic.mkAnd(new VectorPTRef(pParams));
  }
  @Override
  protected PTRef equivalence(PTRef bits1, PTRef bits2) {
    return logic.mkEq(bits1, bits2);
  }
  @Override
  protected PTRef ifThenElse(PTRef pCond, PTRef pF1, PTRef pF2) {
    if (isTrue(pCond)) {
      return pF1;
    } else if (isFalse(pCond)) {
      return pF2;
    } else if (pF1.equals(pF2)) {
      return pF1;
    } else if (isTrue(pF1) && isFalse(pF2)) {
      return pCond;
    } else if (isFalse(pF1) && isTrue(pF2)) {
      return not(pCond);
    }
    return logic.mkIte(pCond, pF1, pF2);
  }
  @Override
  protected boolean isFalse(PTRef bits) {
    return logic.isFalse(bits);
  }
  @Override
  protected boolean isTrue(PTRef bits) {
    return logic.isTrue(bits);
  }
  @Override
  protected PTRef makeBooleanImpl(boolean value) {
    return value ? openSmtTrue : openSmtFalse;
  }
  @Override
  protected PTRef makeVariableImpl(String pVar) {
    return logic.mkBoolVar(pVar);
  }
  @Override
  protected PTRef not(PTRef pParam1) {
    return logic.mkNot(pParam1);
  }
  @Override
  protected PTRef or(PTRef pParam1, PTRef pParam2) {
    return logic.mkOr(pParam1, pParam2);
  }
  @Override
  protected PTRef orImpl(Collection<PTRef> pParams) {
    return logic.mkOr(new VectorPTRef(pParams));
  }
  @Override
  protected PTRef xor(PTRef pParam1, PTRef pParam2) {
    return logic.mkXor(pParam1, pParam2);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import org.sosy_lab.java_smt.basicimpl.AbstractUFManager;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
class OpenSmtUFManager extends AbstractUFManager<PTRef, SymRef, SRef, Logic> {
  OpenSmtUFManager(OpenSmtFormulaCreator pCreator) {
    super(pCreator);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.math.BigDecimal;
import java.math.BigInteger;
import org.sosy_lab.java_smt.api.IntegerFormulaManager;
import org.sosy_lab.java_smt.api.NumeralFormula.IntegerFormula;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
class OpenSmtIntegerFormulaManager
    extends OpenSmtNumeralFormulaManager<IntegerFormula, IntegerFormula>
    implements IntegerFormulaManager {
  OpenSmtIntegerFormulaManager(
      OpenSmtFormulaCreator pCreator, NonLinearArithmetic pNonLinearArithmetic) {
    super(pCreator, pNonLinearArithmetic);
  }
  @Override
  protected SRef getNumeralType() {
    return getFormulaCreator().getIntegerType();
  }
  @Override
  protected PTRef makeNumberImpl(double pNumber) {
    return makeNumberImpl((long) pNumber);
  }
  @Override
  protected PTRef makeNumberImpl(BigDecimal pNumber) {
    return decimalAsInteger(pNumber);
  }
  @Override
  protected PTRef divide(PTRef pParam1, PTRef pParam2) {
    return osmtLogic.mkIntDiv(pParam1, pParam2);
  }
  @Override
  protected PTRef modularCongruence(PTRef pNumber1, PTRef pNumber2, long pModulo) {
    return modularCongruence(pNumber1, pNumber2, BigInteger.valueOf(pModulo));
  }
  @Override
  protected PTRef modularCongruence(PTRef pNumber1, PTRef pNumber2, BigInteger pModulo) {
    if (BigInteger.ZERO.compareTo(pModulo) < 0) {
      PTRef n = makeNumberImpl(pModulo);
      PTRef x = subtract(pNumber1, pNumber2);
      return osmtLogic.mkEq(x, osmtLogic.mkTimes(n, osmtLogic.mkIntDiv(x, n)));
    }
    return osmtLogic.getTerm_true();
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import java.util.Set;
import org.sosy_lab.common.ShutdownNotifier;
import org.sosy_lab.java_smt.api.FormulaManager;
import org.sosy_lab.java_smt.api.ProverEnvironment;
import org.sosy_lab.java_smt.api.SolverContext.ProverOptions;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtSolverContext.OpenSMTOptions;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
class OpenSmtTheoremProver extends OpenSmtAbstractProver<Void> implements ProverEnvironment {
  OpenSmtTheoremProver(
      OpenSmtFormulaCreator pFormulaCreator,
      FormulaManager pMgr,
      ShutdownNotifier pShutdownNotifier,
      Set<ProverOptions> pOptions,
      OpenSMTOptions pSolverOptions) {
    super(
        pFormulaCreator,
        pMgr,
        pShutdownNotifier,
        getConfigInstance(pOptions, pSolverOptions, false),
        pOptions);
  }
  @Override
  public Void addConstraintImpl(PTRef f) throws InterruptedException {
    osmtSolver.insertFormula(f);
    return null;
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Preconditions;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import org.checkerframework.checker.nullness.qual.Nullable;
import org.sosy_lab.common.ShutdownNotifier;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.Evaluator;
import org.sosy_lab.java_smt.api.FormulaManager;
import org.sosy_lab.java_smt.api.Model;
import org.sosy_lab.java_smt.api.Model.ValueAssignment;
import org.sosy_lab.java_smt.api.SolverContext.ProverOptions;
import org.sosy_lab.java_smt.api.SolverException;
import org.sosy_lab.java_smt.basicimpl.AbstractProverWithAllSat;
import org.sosy_lab.java_smt.basicimpl.ShutdownHook;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtSolverContext.OpenSMTOptions;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.MainSolver;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SMTConfig;
import org.sosy_lab.java_smt.solvers.opensmt.api.SMTOption;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.Symbol;
import org.sosy_lab.java_smt.solvers.opensmt.api.sstat;
public abstract class OpenSmtAbstractProver<T> extends AbstractProverWithAllSat<T> {
  protected final OpenSmtFormulaCreator creator;
  protected final MainSolver osmtSolver;
  protected final SMTConfig osmtConfig;
  private boolean changedSinceLastSatQuery = false;
  protected OpenSmtAbstractProver(
      OpenSmtFormulaCreator pFormulaCreator,
      FormulaManager pMgr,
      ShutdownNotifier pShutdownNotifier,
      SMTConfig pConfig,
      Set<ProverOptions> pOptions) {
    super(pOptions, pMgr.getBooleanFormulaManager(), pShutdownNotifier);
    creator = pFormulaCreator;
    osmtConfig = pConfig;
    osmtSolver = new MainSolver(creator.getEnv(), pConfig, "JavaSmt");
  }
  protected static SMTConfig getConfigInstance(
      Set<ProverOptions> pOptions, OpenSMTOptions pSolverOptions, boolean interpolation) {
    SMTConfig config = new SMTConfig();
    config.setOption(":random-seed", new SMTOption(pSolverOptions.randomSeed));
    config.setOption(
        ":produce-models",
        new SMTOption(
            pOptions.contains(ProverOptions.GENERATE_MODELS)
                || pOptions.contains(ProverOptions.GENERATE_ALL_SAT)));
    SMTOption optUnsatCore = new SMTOption(pOptions.contains(ProverOptions.GENERATE_UNSAT_CORE));
    config.setOption(":produce-unsat-cores", optUnsatCore);
    config.setOption(":print-cores-full", optUnsatCore);
    config.setOption(":produce-interpolants", new SMTOption(interpolation));
    if (interpolation) {
      config.setOption(":interpolation-bool-algorithm", new SMTOption(pSolverOptions.algBool));
      config.setOption(":interpolation-euf-algorithm", new SMTOption(pSolverOptions.algUf));
      config.setOption(":interpolation-lra-algorithm", new SMTOption(pSolverOptions.algLra));
    }
    return config;
  }
  final MainSolver getOsmtSolver() {
    return osmtSolver;
  }
  @Override
  protected void pushImpl() {
    setChanged();
    osmtSolver.push();
  }
  @Override
  protected void popImpl() {
    setChanged();
    osmtSolver.pop();
  }
  @Nullable
  protected abstract T addConstraintImpl(PTRef f) throws InterruptedException;
  @Override
  @Nullable
  protected T addConstraintImpl(BooleanFormula pF) throws InterruptedException {
    setChanged();
    PTRef f = creator.extractInfo(pF);
    return addConstraintImpl(f);
  }
  @SuppressWarnings("resource")
  @Override
  public Model getModel() {
    Preconditions.checkState(!closed);
    checkGenerateModels();
    Model model =
        new OpenSmtModel(
            this, creator, Collections2.transform(getAssertedFormulas(), creator::extractInfo));
    return registerEvaluator(model);
  }
  @Override
  public Evaluator getEvaluator() {
    Preconditions.checkState(!closed);
    checkGenerateModels();
    return getEvaluatorWithoutChecks();
  }
  @SuppressWarnings("resource")
  @Override
  protected Evaluator getEvaluatorWithoutChecks() {
    return registerEvaluator(new OpenSmtEvaluator(this, creator));
  }
  protected void setChanged() {
    if (!changedSinceLastSatQuery) {
      changedSinceLastSatQuery = true;
      closeAllEvaluators();
    }
  }
  @Override
  public ImmutableList<ValueAssignment> getModelAssignments() throws SolverException {
    Preconditions.checkState(!closed);
    Preconditions.checkState(!changedSinceLastSatQuery);
    return super.getModelAssignments();
  }
  private String getReasonFromSolverFeatures() {
    Logic osmtLogic = creator.getEnv();
    Map<String, PTRef> userDeclarations = new HashMap<>();
    for (PTRef asserted : Collections2.transform(getAssertedFormulas(), creator::extractInfo)) {
      userDeclarations.putAll(creator.extractVariablesAndUFs(asserted, true));
    }
    boolean usesUFs = false;
    boolean usesIntegers = false;
    boolean usesReals = false;
    boolean usesArrays = false;
    for (PTRef term : userDeclarations.values()) {
      SymRef ref = osmtLogic.getSymRef(term);
      Symbol sym = osmtLogic.getSym(ref);
      if (sym.size() > 1) {
        usesUFs = true;
      }
      SRef sort = sym.rsort();
      if (osmtLogic.isArraySort(sort)) {
        usesArrays = true;
      }
      if (sort.equals(creator.getIntegerType())) {
        usesIntegers = true;
      }
      if (sort.equals(creator.getRationalType())) {
        usesReals = true;
      }
    }
    return getReasonFromSolverFeatures(usesUFs, usesIntegers, usesReals, usesArrays);
  }
  protected String getReasonFromSolverFeatures(
      boolean usesUFs, boolean usesIntegers, boolean usesReals, boolean usesArrays) {
    if (usesIntegers && usesReals) {
      return "OpenSMT does not support mixed integer-real arithmetics.";
    }
    List<String> errors = new ArrayList<>();
    if (usesUFs && !creator.getLogic().doesLogicSupportUFs()) {
      errors.add("uninterpreted function");
    }
    if (usesIntegers && !creator.getLogic().doesLogicSupportIntegers()) {
      errors.add("integer");
    }
    if (usesReals && !creator.getLogic().doesLogicSupportReals()) {
      errors.add("real");
    }
    if (usesArrays && !creator.getLogic().doesLogicSupportArrays()) {
      errors.add("array");
    }
    if (errors.isEmpty()) {
      return "Unknown reason.";
    } else {
      return String.format(
          "Assertions use features %s that are not supported " + "by the specified logic %s.",
          errors, creator.getLogic());
    }
  }
  @Override
  @SuppressWarnings("try") 
  public boolean isUnsat() throws InterruptedException, SolverException {
    Preconditions.checkState(!closed);
    closeAllEvaluators();
    changedSinceLastSatQuery = false;
    sstat result;
    try (ShutdownHook listener = new ShutdownHook(shutdownNotifier, osmtSolver::stop)) {
      shutdownNotifier.shutdownIfNecessary();
      try {
        result = osmtSolver.check();
      } catch (Exception e) {
        if (e.getMessage().isEmpty()) {
          String reason = String.format(" Most likely reason: %s", getReasonFromSolverFeatures());
          throw new SolverException(
              String.format(
                  "OpenSMT crashed while checking satisfiability. Most likely reason: %s", reason));
        } else {
          throw new SolverException("OpenSMT crashed while checking satisfiability.", e);
        }
      }
      shutdownNotifier.shutdownIfNecessary();
    }
    if (result.equals(sstat.Error())) {
      throw new SolverException("OpenSMT crashed while checking satisfiability.");
    } else if (result.equals(sstat.Undef())) {
      throw new InterruptedException();
    } else {
      return result.equals(sstat.False());
    }
  }
  @Override
  public List<BooleanFormula> getUnsatCore() {
    Preconditions.checkState(!closed);
    checkGenerateUnsatCores();
    Preconditions.checkState(!changedSinceLastSatQuery);
    return Lists.transform(osmtSolver.getUnsatCore(), creator::encapsulateBoolean);
  }
  @Override
  public boolean isUnsatWithAssumptions(Collection<BooleanFormula> pAssumptions)
      throws SolverException, InterruptedException {
    throw new UnsupportedOperationException("OpenSMT does not support solving with assumptions.");
  }
  @Override
  public Optional<List<BooleanFormula>> unsatCoreOverAssumptions(
      Collection<BooleanFormula> pAssumptions) throws SolverException, InterruptedException {
    throw new UnsupportedOperationException("OpenSMT does not support solving with assumptions.");
  }
  @Override
  public void close() {
    if (!closed) {
      osmtSolver.delete();
    }
    super.close();
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Preconditions;
import java.util.Set;
import java.util.function.Consumer;
import org.sosy_lab.common.ShutdownNotifier;
import org.sosy_lab.common.configuration.Configuration;
import org.sosy_lab.common.configuration.InvalidConfigurationException;
import org.sosy_lab.common.configuration.Option;
import org.sosy_lab.common.configuration.Options;
import org.sosy_lab.common.log.LogManager;
import org.sosy_lab.java_smt.SolverContextFactory.Solvers;
import org.sosy_lab.java_smt.api.InterpolatingProverEnvironment;
import org.sosy_lab.java_smt.api.OptimizationProverEnvironment;
import org.sosy_lab.java_smt.api.ProverEnvironment;
import org.sosy_lab.java_smt.api.SolverContext;
import org.sosy_lab.java_smt.basicimpl.AbstractNumeralFormulaManager.NonLinearArithmetic;
import org.sosy_lab.java_smt.basicimpl.AbstractSolverContext;
import org.sosy_lab.java_smt.solvers.opensmt.api.LogicFactory;
public final class OpenSmtSolverContext extends AbstractSolverContext {
  private final OpenSmtFormulaCreator creator;
  private final OpenSmtFormulaManager manager;
  @SuppressWarnings("unused")
  private final LogManager logger;
  private final ShutdownNotifier shutdownNotifier;
  private final OpenSMTOptions solverOptions;
  private boolean closed = false;
  @Options(prefix = "solver.opensmt")
  static class OpenSMTOptions {
    @Option(secure = true, description = "SMT-LIB2 name of the logic to be used by the solver.")
    Logics logic = Logics.QF_AUFLIRA;
    @Option(secure = true, description = "Algorithm for boolean interpolation")
    int algBool = 0;
    @Option(secure = true, description = "Algorithm for UF interpolation")
    int algUf = 0;
    @Option(secure = true, description = "Algorithm for LRA interpolation")
    int algLra = 0;
    final int randomSeed;
    OpenSMTOptions(Configuration config, int pRandomSeed) throws InvalidConfigurationException {
      config.inject(this);
      randomSeed = pRandomSeed;
    }
  }
  private OpenSmtSolverContext(
      OpenSmtFormulaCreator pCreator,
      OpenSmtFormulaManager pManager,
      LogManager pLogger,
      ShutdownNotifier pShutdownNotifier,
      OpenSMTOptions pSolverOptions) {
    super(pManager);
    creator = pCreator;
    manager = pManager;
    logger = pLogger;
    shutdownNotifier = pShutdownNotifier;
    solverOptions = pSolverOptions;
  }
  public static SolverContext create(
      Configuration config,
      LogManager pLogger,
      ShutdownNotifier pShutdownNotifier,
      long pRandom,
      NonLinearArithmetic pNonLinearArithmetic,
      Consumer<String> pLoader)
      throws InvalidConfigurationException {
    pLoader.accept("opensmtj");
    OpenSMTOptions solverOptions = new OpenSMTOptions(config, (int) pRandom);
    OpenSmtFormulaCreator creator = OpenSmtFormulaCreator.create(solverOptions.logic);
    OpenSmtUFManager functionTheory = new OpenSmtUFManager(creator);
    OpenSmtBooleanFormulaManager booleanTheory = new OpenSmtBooleanFormulaManager(creator);
    OpenSmtIntegerFormulaManager integerTheory =
        new OpenSmtIntegerFormulaManager(creator, pNonLinearArithmetic);
    OpenSmtRationalFormulaManager rationalTheory =
        new OpenSmtRationalFormulaManager(creator, pNonLinearArithmetic);
    OpenSmtArrayFormulaManager arrayTheory = new OpenSmtArrayFormulaManager(creator);
    OpenSmtFormulaManager manager =
        new OpenSmtFormulaManager(
            creator, functionTheory, booleanTheory, integerTheory, rationalTheory, arrayTheory);
    return new OpenSmtSolverContext(creator, manager, pLogger, pShutdownNotifier, solverOptions);
  }
  @Override
  public void close() {
    if (!closed) {
      closed = true;
      creator.getEnv().delete();
    }
  }
  @Override
  public Solvers getSolverName() {
    return Solvers.OPENSMT;
  }
  @Override
  public String getVersion() {
    return "OpenSMT " + LogicFactory.getVersion();
  }
  @Override
  protected OptimizationProverEnvironment newOptimizationProverEnvironment0(
      Set<SolverContext.ProverOptions> options) {
    throw new UnsupportedOperationException("OpenSMT does not support optimization.");
  }
  @Override
  protected ProverEnvironment newProverEnvironment0(
      Set<SolverContext.ProverOptions> pProverOptions) {
    Preconditions.checkState(!closed, "solver context is already closed");
    return new OpenSmtTheoremProver(
        creator, manager, shutdownNotifier, pProverOptions, solverOptions);
  }
  @Override
  protected InterpolatingProverEnvironment<?> newProverEnvironmentWithInterpolation0(
      Set<SolverContext.ProverOptions> pProverOptions) {
    Preconditions.checkState(!closed, "solver context is already closed");
    return new OpenSmtInterpolatingProver(
        creator, manager, shutdownNotifier, pProverOptions, solverOptions);
  }
  @Override
  protected boolean supportsAssumptionSolving() {
    return false;
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.sosy_lab.java_smt.basicimpl.AbstractModel;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.Model;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SymRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.Symbol;
import org.sosy_lab.java_smt.solvers.opensmt.api.TemplateFunction;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
public class OpenSmtModel extends AbstractModel<PTRef, SRef, Logic> {
  private final Logic osmtLogic;
  private final Model osmtModel;
  private final ImmutableList<ValueAssignment> model;
  OpenSmtModel(
      OpenSmtAbstractProver<?> pProver,
      OpenSmtFormulaCreator pCreator,
      Collection<PTRef> pAssertedTerms) {
    super(pProver, pCreator);
    osmtLogic = pCreator.getEnv();
    osmtModel = pProver.getOsmtSolver().getModel();
    Map<String, PTRef> userDeclarations = new HashMap<>();
    for (PTRef asserted : pAssertedTerms) {
      userDeclarations.putAll(creator.extractVariablesAndUFs(asserted, true));
    }
    ImmutableList.Builder<ValueAssignment> builder = ImmutableList.builder();
    for (PTRef term : userDeclarations.values()) {
      SymRef ref = osmtLogic.getSymRef(term);
      Symbol sym = osmtLogic.getSym(ref);
      int numArgs = sym.size() - 1;
      SRef sort = sym.rsort();
      if (osmtLogic.isArraySort(sort)) {
        throw new UnsupportedOperationException(
            "OpenSMT does not support model generation when arrays are used");
      }
      if (numArgs == 0) {
        PTRef key = osmtLogic.mkVar(sort, osmtLogic.getSymName(ref));
        PTRef value = osmtModel.evaluate(key);
        builder.add(
            new ValueAssignment(
                pCreator.encapsulate(key),
                pCreator.encapsulate(value),
                pCreator.encapsulateBoolean(osmtLogic.mkEq(key, value)),
                osmtLogic.getSymName(ref),
                pCreator.convertValue(value),
                new ArrayList<>()));
      } else {
        TemplateFunction tf = osmtModel.getDefinition(ref);
        for (List<PTRef> path : unfold(numArgs, tf.getBody())) {
          List<PTRef> args = path.subList(0, numArgs);
          PTRef key = osmtLogic.insertTerm(ref, new VectorPTRef(args));
          PTRef value = path.get(numArgs);
          builder.add(
              new ValueAssignment(
                  pCreator.encapsulate(key),
                  pCreator.encapsulate(value),
                  pCreator.encapsulateBoolean(osmtLogic.mkEq(key, value)),
                  osmtLogic.getSymName(ref),
                  pCreator.convertValue(value),
                  Lists.transform(args, pCreator::convertValue)));
        }
      }
    }
    model = builder.build();
  }
  @Override
  public PTRef evalImpl(PTRef f) {
    Preconditions.checkState(!isClosed());
    Map<String, PTRef> userDeclarations = creator.extractVariablesAndUFs(f, true);
    for (PTRef term : userDeclarations.values()) {
      SRef sort = osmtLogic.getSortRef(term);
      if (osmtLogic.isArraySort(sort)) {
        throw new UnsupportedOperationException(
            "OpenSMT does not support model generation when arrays are used");
      }
    }
    return osmtModel.evaluate(f);
  }
  private List<List<PTRef>> unfold(int numArgs, PTRef body) {
    List<List<PTRef>> unwrapped = new ArrayList<>();
    if (osmtLogic.isIte(body)) {
      PTRef sub0 = osmtLogic.getPterm(body).at(0);
      PTRef sub1 = osmtLogic.getPterm(body).at(1);
      PTRef sub2 = osmtLogic.getPterm(body).at(2);
      PTRef sub00 = osmtLogic.getPterm(sub0).at(0);
      PTRef sub01 = osmtLogic.getPterm(sub0).at(1);
      PTRef value = osmtLogic.isVar(sub00) ? sub01 : sub00;
      for (List<PTRef> nested : unfold(numArgs - 1, sub1)) {
        List<PTRef> prefixed = new ArrayList<>();
        prefixed.add(value);
        prefixed.addAll(nested);
        unwrapped.add(prefixed);
      }
      unwrapped.addAll(unfold(numArgs, sub2));
    }
    if (numArgs == 0) {
      List<PTRef> value = new ArrayList<>();
      value.add(body);
      unwrapped.add(value);
    }
    return unwrapped;
  }
  @Override
  public ImmutableList<ValueAssignment> asList() {
    return model;
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import com.google.common.base.Preconditions;
import org.sosy_lab.java_smt.basicimpl.AbstractEvaluator;
import org.sosy_lab.java_smt.solvers.opensmt.api.Logic;
import org.sosy_lab.java_smt.solvers.opensmt.api.Model;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.SRef;
public class OpenSmtEvaluator extends AbstractEvaluator<PTRef, SRef, Logic> {
  private final Model osmtModel;
  OpenSmtEvaluator(OpenSmtAbstractProver<?> pProver, OpenSmtFormulaCreator pCreator) {
    super(pProver, pCreator);
    osmtModel = pProver.getOsmtSolver().getModel();
  }
  @Override
  public PTRef evalImpl(PTRef f) {
    Preconditions.checkState(!isClosed());
    return osmtModel.evaluate(f);
  }
}
package org.sosy_lab.java_smt.solvers.opensmt;
import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkState;
import com.google.common.collect.ImmutableSet;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Set;
import org.sosy_lab.common.ShutdownNotifier;
import org.sosy_lab.java_smt.api.BooleanFormula;
import org.sosy_lab.java_smt.api.FormulaManager;
import org.sosy_lab.java_smt.api.InterpolatingProverEnvironment;
import org.sosy_lab.java_smt.api.SolverContext.ProverOptions;
import org.sosy_lab.java_smt.solvers.opensmt.OpenSmtSolverContext.OpenSMTOptions;
import org.sosy_lab.java_smt.solvers.opensmt.api.PTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorInt;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorPTRef;
import org.sosy_lab.java_smt.solvers.opensmt.api.VectorVectorInt;
class OpenSmtInterpolatingProver extends OpenSmtAbstractProver<Integer>
    implements InterpolatingProverEnvironment<Integer> {
  private final Deque<Integer> trackedConstraints = new ArrayDeque<>();
  OpenSmtInterpolatingProver(
      OpenSmtFormulaCreator pFormulaCreator,
      FormulaManager pMgr,
      ShutdownNotifier pShutdownNotifier,
      Set<ProverOptions> pOptions,
      OpenSMTOptions pSolverOptions) {
    super(
        pFormulaCreator,
        pMgr,
        pShutdownNotifier,
        getConfigInstance(pOptions, pSolverOptions, true),
        pOptions);
    trackedConstraints.push(0); 
  }
  @Override
  public Integer addConstraintImpl(PTRef f) throws InterruptedException {
    osmtSolver.insertFormula(f);
    Integer id = trackedConstraints.pop();
    trackedConstraints.push(id + 1);
    return id;
  }
  @Override
  protected void pushImpl() {
    super.pushImpl();
    trackedConstraints.push(trackedConstraints.peek());
  }
  @Override
  protected void popImpl() {
    trackedConstraints.pop();
    super.popImpl();
  }
  @Override
  public BooleanFormula getInterpolant(Collection<Integer> formulasOfA) {
    checkState(!closed);
    checkArgument(
        getAssertedConstraintIds().containsAll(formulasOfA),
        "interpolation can only be done over previously asserted formulas.");
    return creator.encapsulateBoolean(
        osmtSolver.getInterpolationContext().getSingleInterpolant(new VectorInt(formulasOfA)));
  }
  @Override
  public List<BooleanFormula> getSeqInterpolants(
      List<? extends Collection<Integer>> partitionedFormulas) {
    checkState(!closed);
    checkArgument(!partitionedFormulas.isEmpty(), "Interpolation sequence must not be empty");
    final ImmutableSet<Integer> assertedConstraintIds = getAssertedConstraintIds();
    checkArgument(
        partitionedFormulas.stream().allMatch(assertedConstraintIds::containsAll),
        "interpolation can only be done over previously asserted formulas.");
    VectorVectorInt partitions = new VectorVectorInt();
    for (int i = 1; i < partitionedFormulas.size(); i++) {
      VectorInt prefix = new VectorInt();
      for (Collection<Integer> key : partitionedFormulas.subList(0, i)) {
        prefix.addAll(key);
      }
      partitions.add(prefix);
    }
    VectorPTRef itps = osmtSolver.getInterpolationContext().getPathInterpolants(partitions);
    List<BooleanFormula> result = new ArrayList<>();
    for (PTRef itp : itps) {
      result.add(creator.encapsulateBoolean(itp));
    }
    return result;
  }
  @Override
  public List<BooleanFormula> getTreeInterpolants(
      List<? extends Collection<Integer>> partitionedFormulas, int[] startOfSubTree) {
    throw new UnsupportedOperationException("OpenSMT does not support tree interpolants");
  }
  @Override
  protected String getReasonFromSolverFeatures(
      boolean usesUFs, boolean usesIntegers, boolean usesReals, boolean usesArrays) {
    if (!creator.getLogic().doesLogicSupportInterpolation()) {
      return String.format(
          "OpenSMT does not support interpolation for the specified logic %s.", creator.getLogic());
    }
    return super.getReasonFromSolverFeatures(usesUFs, usesIntegers, usesReals, usesArrays);
  }
}