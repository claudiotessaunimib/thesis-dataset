package it.niedermann.nextcloud.deck.ui.card.comments;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import android.content.Context;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.EditorInfo;
import android.widget.Toast;
import androidx.annotation.ColorInt;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import com.bumptech.glide.Glide;
import com.bumptech.glide.request.RequestOptions;
import com.nextcloud.android.common.ui.theme.utils.ColorRole;
import com.nextcloud.android.sso.api.EmptyResponse;
import java.time.Instant;
import java.util.stream.Stream;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.R;
import it.niedermann.nextcloud.deck.databinding.FragmentCardEditTabCommentsBinding;
import it.niedermann.nextcloud.deck.model.Account;
import it.niedermann.nextcloud.deck.model.ocs.comment.DeckComment;
import it.niedermann.nextcloud.deck.model.ocs.comment.full.FullDeckComment;
import it.niedermann.nextcloud.deck.remote.api.IResponseCallback;
import it.niedermann.nextcloud.deck.repository.SyncRepository;
import it.niedermann.nextcloud.deck.ui.card.EditActivity;
import it.niedermann.nextcloud.deck.ui.card.EditCardViewModel;
import it.niedermann.nextcloud.deck.ui.exception.ExceptionDialogFragment;
import it.niedermann.nextcloud.deck.ui.theme.ThemeUtils;
import it.niedermann.nextcloud.deck.ui.theme.Themed;
import it.niedermann.nextcloud.deck.ui.viewmodel.SyncViewModel;
import it.niedermann.nextcloud.deck.util.KeyboardUtils;
import okhttp3.Headers;
public class CardCommentsFragment extends Fragment implements Themed, CommentEditedListener, CommentDeletedListener, CommentSelectAsReplyListener {
    private static final String KEY_ACCOUNT = "account";
    private FragmentCardEditTabCommentsBinding binding;
    private EditCardViewModel editCardViewModel;
    private CommentsViewModel commentsViewModel;
    private CardCommentsAdapter adapter;
    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);
        final var args = getArguments();
        if (args == null || !args.containsKey(KEY_ACCOUNT)) {
            throw new IllegalArgumentException(KEY_ACCOUNT + " must be provided.");
        }
        final var account = (Account) args.getSerializable(KEY_ACCOUNT);
        if (account == null) {
            throw new IllegalArgumentException(KEY_ACCOUNT + " must not be null.");
        }
        editCardViewModel = new ViewModelProvider(requireActivity()).get(EditCardViewModel.class);
        commentsViewModel = new SyncViewModel.Provider(this, requireActivity().getApplication(), account).get(CommentsViewModel.class);
    }
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater,
                             ViewGroup container,
                             Bundle savedInstanceState) {
        binding = FragmentCardEditTabCommentsBinding.inflate(inflater, container, false);
        // This might be a zombie fragment with an empty EditCardViewModel after Android killed the activity (but not the fragment instance
        // See https://github.com/stefan-niedermann/nextcloud-deck/issues/478
        if (editCardViewModel.getFullCard() == null) {
            DeckLog.logError(new IllegalStateException("Cannot populate " + CardCommentsFragment.class.getSimpleName() + " because viewModel.getFullCard() is null"));
            if (requireActivity() instanceof EditActivity) {
                Toast.makeText(getContext(), R.string.error_edit_activity_killed_by_android, Toast.LENGTH_LONG).show();
                ((EditActivity) requireActivity()).directFinish();
            } else {
                requireActivity().finish();
            }
            return binding.getRoot();
        }
        adapter = new CardCommentsAdapter(requireContext(), editCardViewModel.getAccount(), requireActivity().getMenuInflater(), this, this, getChildFragmentManager(), this);
        binding.comments.setAdapter(adapter);
        binding.replyCommentCancelButton.setOnClickListener((v) -> commentsViewModel.setReplyToComment(null));
        Glide.with(binding.avatar.getContext())
                .load(editCardViewModel.getAccount().getAvatarUrl(binding.avatar.getResources().getDimensionPixelSize(R.dimen.icon_size_details)))
                .apply(RequestOptions.circleCropTransform())
                .placeholder(R.drawable.ic_person_24dp)
                .error(R.drawable.ic_person_24dp)
                .into(binding.avatar);
        commentsViewModel.getReplyToComment().observe(getViewLifecycleOwner(), (comment) -> {
            if (comment == null) {
                binding.replyComment.setVisibility(GONE);
            } else {
                binding.replyCommentText.setMarkdownString(comment.getComment().getMessage());
                binding.replyComment.setVisibility(VISIBLE);
            }
        });
        commentsViewModel.getFullCommentsForLocalCardId(editCardViewModel.getFullCard().getLocalId()).observe(getViewLifecycleOwner(),
                (comments) -> {
                    if (comments != null && comments.size() > 0) {
                        binding.emptyContentView.setVisibility(GONE);
                        binding.comments.setVisibility(VISIBLE);
                        adapter.updateComments(comments);
                    } else {
                        binding.emptyContentView.setVisibility(VISIBLE);
                        binding.comments.setVisibility(GONE);
                    }
                });
        if (editCardViewModel.canEdit()) {
            binding.addCommentLayout.setVisibility(VISIBLE);
            binding.fab.setOnClickListener(v -> {
                // Do not handle empty comments (https://github.com/stefan-niedermann/nextcloud-deck/issues/440)
                if (!TextUtils.isEmpty(binding.message.getText().toString().trim())) {
                    binding.emptyContentView.setVisibility(GONE);
                    binding.comments.setVisibility(VISIBLE);
                    final DeckComment comment = new DeckComment(binding.message.getText().toString().trim(), editCardViewModel.getAccount().getUserName(), Instant.now());
                    final FullDeckComment parent = commentsViewModel.getReplyToComment().getValue();
                    if (parent != null) {
                        comment.setParentId(parent.getId());
                        commentsViewModel.setReplyToComment(null);
                    }
                    commentsViewModel.addCommentToCard(editCardViewModel.getAccount().getId(), editCardViewModel.getFullCard().getLocalId(), comment);
                }
                binding.message.setText(null);
            });
            binding.message.setOnEditorActionListener((v, actionId, event) -> {
                if ((actionId == EditorInfo.IME_ACTION_SEND) || (event != null && event.getKeyCode() == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_UP)) {
                    return binding.fab.performClick();
                }
                return true;
            });
            binding.message.addTextChangedListener(new CardCommentsMentionProposer(getViewLifecycleOwner(), editCardViewModel.getAccount(), editCardViewModel.getBoardId(), binding.message, binding.mentionProposerWrapper, binding.mentionProposer));
        } else {
            binding.addCommentLayout.setVisibility(GONE);
        }
        return binding.getRoot();
    }
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        if (editCardViewModel.canEdit()) {
            KeyboardUtils.showKeyboardForEditText(binding.message);
        }
        editCardViewModel.getBoardColor().observe(getViewLifecycleOwner(), this::applyTheme);
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        this.binding = null;
    }
    @Override
    public void onCommentEdited(Long id, String comment) {
        commentsViewModel.updateComment(editCardViewModel.getAccount().getId(), editCardViewModel.getFullCard().getLocalId(), id, comment);
    }
    @Override
    public void onCommentDeleted(Long localId) {
        commentsViewModel.deleteComment(editCardViewModel.getAccount().getId(), editCardViewModel.getFullCard().getLocalId(), localId, new IResponseCallback<>() {
            @Override
            public void onResponse(EmptyResponse response, Headers headers) {
                DeckLog.info("Successfully deleted comment with localId", localId);
            }
            @Override
            public void onError(Throwable throwable) {
                if (SyncRepository.isNoOnVoidError(throwable)) {
                    IResponseCallback.super.onError(throwable);
                    requireActivity().runOnUiThread(() -> ExceptionDialogFragment.newInstance(throwable, editCardViewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName()));
                }
            }
        });
    }
    @Override
    public void applyTheme(@ColorInt int color) {
        final var utils = ThemeUtils.of(color, requireContext());
        utils.deck.themeEmptyContentView(binding.emptyContentView);
        utils.platform.colorViewBackground(binding.addCommentLayout);
        utils.material.themeFAB(binding.fab);
        utils.material.colorTextInputLayout(binding.messageWrapper);
        Stream.of(
                binding.replyCommentIcon,
                binding.replyCommentCancelButton,
                binding.mentionProposerIcon
        ).forEach(v -> utils.platform.colorImageView(v, ColorRole.SECONDARY));
        adapter.applyTheme(color);
    }
    @Override
    public void onSelectAsReply(FullDeckComment comment) {
        commentsViewModel.setReplyToComment(comment);
    }
    public static Fragment newInstance(@NonNull Account account) {
        final var fragment = new CardCommentsFragment();
        final var args = new Bundle();
        args.putSerializable(KEY_ACCOUNT, account);
        fragment.setArguments(args);
        return fragment;
    }
}
package it.niedermann.nextcloud.deck.remote.api;
import androidx.annotation.CallSuper;
import it.niedermann.nextcloud.deck.DeckLog;
import okhttp3.Headers;
public interface IResponseCallback<T> {
    Headers EMPTY_HEADERS = Headers.of();
    void onResponse(T response, Headers headers);
    @CallSuper
    default void onError(Throwable throwable) {
        DeckLog.logError(throwable);
    }
    /**
     * @return a default {@link IResponseCallback} which does nothing {@link #onResponse(Object, Headers)} and the default action fo {@link #onError(Throwable)}
     */
    static <T> IResponseCallback<T> empty() {
        return (response, headers) -> {
            // Does nothing on default
        };
    }
}
package it.niedermann.nextcloud.deck.model.full;
import androidx.annotation.NonNull;
import androidx.room.Junction;
import androidx.room.Relation;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import it.niedermann.nextcloud.deck.model.ocs.projects.JoinCardWithProject;
import it.niedermann.nextcloud.deck.model.ocs.projects.OcsProject;
import it.niedermann.nextcloud.deck.model.ocs.projects.full.OcsProjectWithResources;
public class FullCardWithProjects extends FullCard {
    @NonNull
    @Relation(entity = OcsProject.class, parentColumn = "localId", entityColumn = "localId",
            associateBy = @Junction(value = JoinCardWithProject.class, parentColumn = "cardId", entityColumn = "projectId"))
    private List<OcsProjectWithResources> projects = new ArrayList<>();
    public FullCardWithProjects() {
        super();
    }
    public FullCardWithProjects(FullCardWithProjects fullCard) {
        super(fullCard);
        this.projects = copyList(fullCard.getProjects());
    }
    @NonNull
    public List<OcsProjectWithResources> getProjects() {
        return projects;
    }
    public void setProjects(@NonNull List<OcsProjectWithResources> projects) {
        this.projects = projects;
    }
    @NonNull
    @Override
    public String toString() {
        return "FullCard{" +
                "card=" + card +
                ", labels=" + labels +
                ", assignedUsers=" + assignedUsers +
                ", owner=" + owner +
                ", attachments=" + attachments +
                '}';
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FullCardWithProjects fullCard = (FullCardWithProjects) o;
        if (!Objects.equals(card, fullCard.card)) return false;
        if (!Objects.equals(labels, fullCard.labels))
            return false;
        if (!Objects.equals(assignedUsers, fullCard.assignedUsers))
            return false;
        if (!Objects.equals(owner, fullCard.owner)) return false;
        if (!Objects.equals(attachments, fullCard.attachments))
            return false;
        return Objects.equals(commentIDs, fullCard.commentIDs);
    }
    @Override
    public int hashCode() {
        int result = (isAttachmentsSorted ? 1 : 0);
        result = 31 * result + (card != null ? card.hashCode() : 0);
        result = 31 * result + (labels != null ? labels.hashCode() : 0);
        result = 31 * result + (assignedUsers != null ? assignedUsers.hashCode() : 0);
        result = 31 * result + (owner != null ? owner.hashCode() : 0);
        result = 31 * result + (attachments != null ? attachments.hashCode() : 0);
        result = 31 * result + (commentIDs != null ? commentIDs.hashCode() : 0);
        return result;
    }
}
package it.niedermann.nextcloud.deck.model;
import androidx.annotation.NonNull;
import androidx.room.Entity;
import androidx.room.ForeignKey;
import androidx.room.Ignore;
import androidx.room.Index;
import com.google.gson.annotations.SerializedName;
import java.time.Instant;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import it.niedermann.nextcloud.deck.model.enums.DBStatus;
import it.niedermann.nextcloud.deck.model.interfaces.AbstractRemoteEntity;
@Entity(inheritSuperIndices = true,
        indices = {
                @Index(value = "accountId", name = "card_accID"),
                @Index("stackId")
        },
        foreignKeys = {
                @ForeignKey(
                        entity = Stack.class,
                        parentColumns = "localId",
                        childColumns = "stackId", onDelete = ForeignKey.CASCADE
                ),
                @ForeignKey(
                        entity = Account.class,
                        parentColumns = "id",
                        childColumns = "accountId", onDelete = ForeignKey.CASCADE
                )
        }
)
public class Card extends AbstractRemoteEntity {
    private static Pattern PATTERN_MD_TASK = Pattern.compile("\\[([xX ])]");
    public static class TaskStatus {
        public int taskCount;
        public int doneCount;
        public TaskStatus(int taskCount, int doneCount) {
            this.taskCount = taskCount;
            this.doneCount = doneCount;
        }
    }
    @Ignore
    private TaskStatus taskStatus = null;
    private String title;
    private String description;
    @NonNull
    private Long stackId;
    private String type;
    private Instant createdAt;
    private Instant deletedAt;
    private Instant done;
    private int attachmentCount;
    private Long userId;
    private int order;
    private boolean archived;
    @SerializedName("duedate")
    private Instant dueDate;
    private boolean notified;
    private int overdue;
    private int commentsUnread;
    public Card() {
    }
    @Ignore
    public Card(String title, String description, long stackId) {
        this.title = title;
        this.description = description;
        this.stackId = stackId;
    }
    public Card(Card card) {
        super(card);
        this.title = card.getTitle();
        this.description = card.getDescription();
        this.stackId = card.getStackId();
        this.type = card.getType();
        this.createdAt = card.getCreatedAt();
        this.deletedAt = card.getDeletedAt();
        this.attachmentCount = card.getAttachmentCount();
        this.userId = card.getUserId();
        this.order = card.getOrder();
        this.archived = card.isArchived();
        this.dueDate = card.getDueDate();
        this.done = card.getDone();
        this.notified = card.isNotified();
        this.overdue = card.getOverdue();
        this.commentsUnread = card.getCommentsUnread();
    }
    @NonNull
    public TaskStatus getTaskStatus() {
        if (taskStatus == null) {
            int count = 0, done = 0;
            if (description != null) {
                final Matcher matcher = PATTERN_MD_TASK.matcher(description);
                while (matcher.find()) {
                    count++;
                    char c = matcher.group().charAt(1);
                    if (c == 'x' || c == 'X') {
                        done++;
                    }
                }
            }
            taskStatus = new TaskStatus(count, done);
        }
        return taskStatus;
    }
    public boolean isNotified() {
        return notified;
    }
    public void setNotified(boolean notified) {
        this.notified = notified;
    }
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    public DBStatus getStatusEnum() {
        return DBStatus.findById(status);
    }
    public void setStatusEnum(DBStatus status) {
        this.status = status.getId();
    }
    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }
    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
        this.taskStatus = null;
    }
    public Long getStackId() {
        return stackId;
    }
    public void setStackId(Long stackId) {
        this.stackId = stackId;
    }
    public String getType() {
        return type;
    }
    public void setType(String type) {
        this.type = type;
    }
    public Instant getCreatedAt() {
        return createdAt;
    }
    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }
    public Instant getDeletedAt() {
        return deletedAt;
    }
    public void setDeletedAt(Instant deletedAt) {
        this.deletedAt = deletedAt;
    }
    public int getAttachmentCount() {
        return attachmentCount;
    }
    public void setAttachmentCount(int attachmentCount) {
        this.attachmentCount = attachmentCount;
    }
    public void setOrder(int order) {
        this.order = order;
    }
    public boolean isArchived() {
        return archived;
    }
    public void setArchived(boolean archived) {
        this.archived = archived;
    }
    public Instant getDueDate() {
        return dueDate;
    }
    public void setDueDate(Instant dateTime) {
        this.dueDate = dateTime;
    }
    public int getOverdue() {
        return overdue;
    }
    public void setOverdue(int overdue) {
        this.overdue = overdue;
    }
    public int getCommentsUnread() {
        return commentsUnread;
    }
    public void setCommentsUnread(int commentsUnread) {
        this.commentsUnread = commentsUnread;
    }
    public void setStatus(int status) {
        this.status = status;
    }
    public int getStatus() {
        return this.status;
    }
    public Long getUserId() {
        return this.userId;
    }
    public void setUserId(Long userId) {
        this.userId = userId;
    }
    public int getOrder() {
        return this.order;
    }
    public Instant getDone() {
        return done;
    }
    public void setDone(Instant done) {
        this.done = done;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Card card = (Card) o;
        if (stackId != card.stackId) return false;
        if (attachmentCount != card.attachmentCount) return false;
        if (order != card.order) return false;
        if (archived != card.archived) return false;
        if (notified != card.notified) return false;
        if (overdue != card.overdue) return false;
        if (commentsUnread != card.commentsUnread) return false;
        if (!Objects.equals(title, card.title)) return false;
        if (!Objects.equals(description, card.description))
            return false;
        if (!Objects.equals(type, card.type)) return false;
        if (!Objects.equals(createdAt, card.createdAt))
            return false;
        if (!Objects.equals(deletedAt, card.deletedAt))
            return false;
        if (!Objects.equals(done, card.done))
            return false;
        if (!Objects.equals(userId, card.userId)) return false;
        return Objects.equals(dueDate, card.dueDate);
    }
    @Override
    public int hashCode() {
        int result = title != null ? title.hashCode() : 0;
        result = 31 * result + (description != null ? description.hashCode() : 0);
        result = 31 * result + (int) (stackId ^ (stackId >>> 32));
        result = 31 * result + (type != null ? type.hashCode() : 0);
        result = 31 * result + (createdAt != null ? createdAt.hashCode() : 0);
        result = 31 * result + (deletedAt != null ? deletedAt.hashCode() : 0);
        result = 31 * result + (done != null ? done.hashCode() : 0);
        result = 31 * result + attachmentCount;
        result = 31 * result + (userId != null ? userId.hashCode() : 0);
        result = 31 * result + order;
        result = 31 * result + (archived ? 1 : 0);
        result = 31 * result + (dueDate != null ? dueDate.hashCode() : 0);
        result = 31 * result + (notified ? 1 : 0);
        result = 31 * result + overdue;
        result = 31 * result + commentsUnread;
        return result;
    }
    @Override
    public String toString() {
        return "Card{" +
                "title='" + title + '\'' +
                ", description='" + description + '\'' +
                ", stackId=" + stackId +
                ", type='" + type + '\'' +
                ", createdAt=" + createdAt +
                ", deletedAt=" + deletedAt +
                ", done=" + done +
                ", attachmentCount=" + attachmentCount +
                ", userId=" + userId +
                ", order=" + order +
                ", archived=" + archived +
                ", dueDate=" + dueDate +
                ", notified=" + notified +
                ", overdue=" + overdue +
                ", commentsUnread=" + commentsUnread +
                ", localId=" + localId +
                ", accountId=" + accountId +
                ", id=" + id +
                ", status=" + status +
                ", lastModified=" + lastModified +
                ", lastModifiedLocal=" + lastModifiedLocal +
                '}';
    }
}
package it.niedermann.nextcloud.deck.model;
import android.graphics.Color;
import androidx.annotation.ColorInt;
import androidx.annotation.NonNull;
import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.ForeignKey;
import androidx.room.Index;
import com.google.gson.annotations.JsonAdapter;
import java.io.Serializable;
import java.util.Objects;
import it.niedermann.android.util.ColorUtil;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.model.interfaces.AbstractRemoteEntity;
import it.niedermann.nextcloud.deck.remote.api.json.JsonColorSerializer;
@Entity(inheritSuperIndices = true,
        indices = {@Index("boardId"), @Index(value = {"boardId", "title"}, unique = true, name = "idx_label_title_unique")},
        foreignKeys = {
                @ForeignKey(
                        entity = Board.class,
                        parentColumns = "localId",
                        childColumns = "boardId",
                        onDelete = ForeignKey.CASCADE
                ),
                @ForeignKey(
                        entity = Account.class,
                        parentColumns = "id",
                        childColumns = "accountId", onDelete = ForeignKey.CASCADE
                )
        }
)
public class Label extends AbstractRemoteEntity implements Serializable {
    private String title;
    @JsonAdapter(JsonColorSerializer.class)
    @NonNull
    @ColumnInfo(defaultValue = "0")
    private Integer color;
    private long boardId;
    public Label() {
    }
    public Label(Label labelToCopy) {
        super(labelToCopy);
        this.title = labelToCopy.getTitle();
        this.color = labelToCopy.getColor();
        this.boardId = labelToCopy.getBoardId();
    }
    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }
    @NonNull
    @ColorInt
    public Integer getColor() {
        return color;
    }
    public void setColor(@NonNull @ColorInt Integer color) {
        this.color = color;
    }
    public void setColor(String color) {
        try {
            setColor(Color.parseColor(ColorUtil.formatColorToParsableHexString(color)));
        } catch (Exception e) {
            DeckLog.logError(e);
            setColor(Color.GRAY);
        }
    }
    public long getBoardId() {
        return boardId;
    }
    public void setBoardId(long boardId) {
        this.boardId = boardId;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Label label = (Label) o;
        if (boardId != label.boardId) return false;
        if (!Objects.equals(title, label.title)) return false;
        return color.equals(label.color);
    }
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (title != null ? title.hashCode() : 0);
        result = 31 * result + color.hashCode();
        result = 31 * result + (int) (boardId ^ (boardId >>> 32));
        return result;
    }
    @Override
    public String toString() {
        return "Label{" +
                "title='" + title + '\'' +
                ", color='" + color + '\'' +
                ", boardId=" + boardId +
                ", localId=" + localId +
                ", accountId=" + accountId +
                ", id=" + id +
                ", status=" + status +
                ", lastModified=" + lastModified +
                ", lastModifiedLocal=" + lastModifiedLocal +
                '}';
    }
}
package it.niedermann.nextcloud.deck.model;
import android.content.Context;
import android.net.Uri;
import androidx.annotation.ColorInt;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.Px;
import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.Ignore;
import androidx.room.Index;
import androidx.room.PrimaryKey;
import com.bumptech.glide.Glide;
import com.nextcloud.android.sso.AccountImporter;
import com.nextcloud.android.sso.exceptions.NextcloudFilesAppAccountNotFoundException;
import com.nextcloud.android.sso.model.SingleSignOnAccount;
import java.io.Serializable;
import java.util.Objects;
import java.util.Optional;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.model.ocs.Capabilities;
import it.niedermann.nextcloud.deck.model.ocs.Version;
import it.niedermann.nextcloud.sso.glide.SingleSignOnUrl;
@Entity(indices = {@Index(value = "name", unique = true)})
public class Account implements Serializable {
    @Ignore
    private static final long serialVersionUID = 0;
    @PrimaryKey(autoGenerate = true)
    protected Long id;
    @NonNull
    private String name;
    @NonNull
    private String userName;
    @Ignore
    @Nullable
    private String userDisplayName;
    @NonNull
    private String url;
    /**
     * See {@link Capabilities#DEFAULT_COLOR}
     */
    @NonNull
    @ColumnInfo(defaultValue = "0")
    private Integer color = Capabilities.DEFAULT_COLOR;
    @NonNull
    @ColumnInfo(defaultValue = "0")
    private Integer textColor = Capabilities.DEFAULT_TEXT_COLOR;
    @NonNull
    @ColumnInfo(defaultValue = "0.6.4")
    private String serverDeckVersion = "0.6.4";
    @NonNull
    @ColumnInfo(defaultValue = "0")
    private boolean maintenanceEnabled = false;
    private String etag;
    private String boardsEtag;
    @Ignore
    public Account(Long id, @NonNull String name, @NonNull String userName, @NonNull String url) {
        this(name, userName, url);
        this.id = id;
    }
    @Ignore
    public Account(@NonNull String name, @NonNull String userName, @NonNull String url) {
        this.name = name;
        this.userName = userName;
        this.url = url;
    }
    @Ignore
    public Account(Long id) {
        this.id = id;
    }
    public Account() {
    }
    public void applyCapabilities(Capabilities capabilities, String eTag) {
        if (capabilities == null) {
            maintenanceEnabled = true;
            return;
        }
        maintenanceEnabled = capabilities.isMaintenanceEnabled();
        if (!isMaintenanceEnabled()) {
            try {
                // Nextcloud might return color format #000 which cannot be parsed by Color.parseColor()
                // https://github.com/stefan-niedermann/nextcloud-deck/issues/466
                color = capabilities.getColor();
                textColor = capabilities.getTextColor();
            } catch (Exception e) {
                DeckLog.logError(e);
                color = Capabilities.DEFAULT_COLOR;
                textColor = Capabilities.DEFAULT_TEXT_COLOR;
            }
            if (capabilities.getDeckVersion() != null) {
                serverDeckVersion = capabilities.getDeckVersion().getOriginalVersion();
            }
            if (eTag != null) {
                this.etag = eTag;
            }
        }
    }
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    @NonNull
    public String getName() {
        return name;
    }
    public void setName(@NonNull String name) {
        this.name = name;
    }
    @NonNull
    public String getUserName() {
        return userName;
    }
    public void setUserName(@NonNull String userName) {
        this.userName = userName;
    }
    @NonNull
    public String getUrl() {
        return url;
    }
    public void setUrl(@NonNull String url) {
        this.url = url;
    }
    public static long getSerialVersionUID() {
        return serialVersionUID;
    }
    @ColorInt
    @NonNull
    public Integer getColor() {
        return color;
    }
    public void setColor(@NonNull Integer color) {
        this.color = color;
    }
    @NonNull
    public Integer getTextColor() {
        return textColor;
    }
    @Deprecated
    public void setTextColor(@NonNull Integer textColor) {
        this.textColor = textColor;
    }
    public Version getServerDeckVersionAsObject() {
        return Version.of(serverDeckVersion);
    }
    @NonNull
    public String getServerDeckVersion() {
        return serverDeckVersion;
    }
    public void setServerDeckVersion(@NonNull String serverDeckVersion) {
        this.serverDeckVersion = serverDeckVersion;
    }
    public boolean isMaintenanceEnabled() {
        return maintenanceEnabled;
    }
    public void setMaintenanceEnabled(boolean maintenanceEnabled) {
        this.maintenanceEnabled = maintenanceEnabled;
    }
    @Nullable
    public String getUserDisplayName() {
        return userDisplayName;
    }
    public void setUserDisplayName(@Nullable String userDisplayName) {
        this.userDisplayName = userDisplayName;
    }
    public String getEtag() {
        return etag;
    }
    public void setEtag(String etag) {
        this.etag = etag;
    }
    public String getBoardsEtag() {
        return boardsEtag;
    }
    public void setBoardsEtag(String boardsEtag) {
        this.boardsEtag = boardsEtag;
    }
    /**
     * @return The {@link #getAvatarUrl(int, String)} of this {@link Account}
     */
    public SingleSignOnUrl getAvatarUrl(@Px int size) {
        return getAvatarUrl(size, getUserName());
    }
    /**
     * @return a {@link SingleSignOnUrl} to fetch the avatar of the given <code>userName</code> from the instance of this {@link Account} via {@link Glide}.
     */
    public SingleSignOnUrl getAvatarUrl(@Px int size, @NonNull String userName) {
        return new SingleSignOnUrl(getName(), getUrl() + "/index.php/avatar/" + Uri.encode(userName) + "/" + size);
    }
    @NonNull
    public Optional<SingleSignOnAccount> getSingleSignOnAccount(@NonNull Context context) {
        try {
            return Optional.of(AccountImporter.getSingleSignOnAccount(context, getName()));
        } catch (NextcloudFilesAppAccountNotFoundException e) {
            return Optional.empty();
        }
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Account account = (Account) o;
        return maintenanceEnabled == account.maintenanceEnabled &&
                Objects.equals(id, account.id) &&
                name.equals(account.name) &&
                userName.equals(account.userName) &&
                Objects.equals(userDisplayName, account.userDisplayName) &&
                url.equals(account.url) &&
                color.equals(account.color) &&
                textColor.equals(account.textColor) &&
                serverDeckVersion.equals(account.serverDeckVersion);
    }
    @Override
    public int hashCode() {
        return Objects.hash(id, name, userName, userDisplayName, url, color, textColor, serverDeckVersion, maintenanceEnabled, etag, boardsEtag);
    }
    @NonNull
    @Override
    public String toString() {
        return "Account{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", userName='" + userName + '\'' +
                ", url='" + url + '\'' +
                ", color='" + color + '\'' +
                ", textColor='" + textColor + '\'' +
                ", serverDeckVersion='" + serverDeckVersion + '\'' +
                ", maintenanceEnabled=" + maintenanceEnabled +
                ", eTag='" + etag + '\'' +
                '}';
    }
}
package it.niedermann.nextcloud.deck.model.full;
import androidx.annotation.NonNull;
import androidx.room.Embedded;
import androidx.room.Ignore;
import androidx.room.Junction;
import androidx.room.Relation;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import it.niedermann.android.crosstabdnd.DragAndDropModel;
import it.niedermann.nextcloud.deck.model.Attachment;
import it.niedermann.nextcloud.deck.model.Card;
import it.niedermann.nextcloud.deck.model.JoinCardWithLabel;
import it.niedermann.nextcloud.deck.model.JoinCardWithUser;
import it.niedermann.nextcloud.deck.model.Label;
import it.niedermann.nextcloud.deck.model.User;
import it.niedermann.nextcloud.deck.model.interfaces.IRemoteEntity;
import it.niedermann.nextcloud.deck.model.ocs.comment.DeckComment;
public class FullCard implements IRemoteEntity, DragAndDropModel {
    @Ignore
    protected transient boolean isAttachmentsSorted = false;
    @Embedded
    public Card card;
    @Relation(entity = Label.class, parentColumn = "localId", entityColumn = "localId",
            associateBy = @Junction(value = JoinCardWithLabel.class, parentColumn = "cardId", entityColumn = "labelId"))
    public List<Label> labels = new ArrayList<>();
    @Relation(entity = User.class, parentColumn = "localId", entityColumn = "localId",
            associateBy = @Junction(value = JoinCardWithUser.class, parentColumn = "cardId", entityColumn = "userId"))
    public List<User> assignedUsers = new ArrayList<>();
    @Relation(parentColumn = "userId", entityColumn = "localId")
    public List<User> owner;
    @Relation(parentColumn = "localId", entityColumn = "cardId")
    public List<Attachment> attachments;
    @Relation(entity = DeckComment.class, parentColumn = "localId", entityColumn = "objectId", projection = "localId")
    public List<Long> commentIDs;
    public FullCard() {
        super();
    }
    public FullCard(FullCard fullCard) {
        this.card = new Card(fullCard.getCard());
        this.labels = copyList(fullCard.getLabels());
        this.assignedUsers = copyList(fullCard.getAssignedUsers());
        this.owner = copyList(fullCard.getOwner());
        this.attachments = copyList(fullCard.getAttachments());
        this.commentIDs = copyList(fullCard.getCommentIDs());
    }
    public Card getCard() {
        return card;
    }
    public void setCard(Card card) {
        this.card = card;
    }
    public List<Label> getLabels() {
        return labels;
    }
    public void setLabels(List<Label> labels) {
        this.labels = labels;
    }
    public List<User> getAssignedUsers() {
        return assignedUsers;
    }
    public void setAssignedUsers(List<User> assignedUsers) {
        this.assignedUsers = assignedUsers;
    }
    public void setCommentIDs(List<Long> commentIDs) {
        this.commentIDs = commentIDs;
    }
    public List<Long> getCommentIDs() {
        return commentIDs;
    }
    public int getCommentCount() {
        return commentIDs == null ? 0 : commentIDs.size();
    }
    public List<User> getOwner() {
        return owner;
    }
    public void setOwner(User owner) {
        List<User> user = new ArrayList<>();
        user.add(owner);
        this.owner = user;
    }
    public void setOwner(List<User> owner) {
        this.owner = owner;
    }
    public List<Attachment> getAttachments() {
        if (!isAttachmentsSorted && attachments != null) {
            Collections.sort(attachments);
            isAttachmentsSorted = true;
        }
        return attachments;
    }
    public void setAttachments(List<Attachment> attachments) {
        this.attachments = attachments;
    }
    @Ignore
    @Override
    public Card getEntity() {
        return card;
    }
    @NonNull
    @Override
    public String toString() {
        return "FullCard{" +
                "card=" + card +
                ", labels=" + labels +
                ", assignedUsers=" + assignedUsers +
                ", owner=" + owner +
                ", attachments=" + attachments +
                '}';
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FullCard fullCard = (FullCard) o;
        if (!Objects.equals(card, fullCard.card)) return false;
        if (!Objects.equals(labels, fullCard.labels))
            return false;
        if (!Objects.equals(assignedUsers, fullCard.assignedUsers))
            return false;
        if (!Objects.equals(owner, fullCard.owner)) return false;
        if (!Objects.equals(attachments, fullCard.attachments))
            return false;
        return Objects.equals(commentIDs, fullCard.commentIDs);
    }
    @Override
    public int hashCode() {
        int result = (isAttachmentsSorted ? 1 : 0);
        result = 31 * result + (card != null ? card.hashCode() : 0);
        result = 31 * result + (labels != null ? labels.hashCode() : 0);
        result = 31 * result + (assignedUsers != null ? assignedUsers.hashCode() : 0);
        result = 31 * result + (owner != null ? owner.hashCode() : 0);
        result = 31 * result + (attachments != null ? attachments.hashCode() : 0);
        result = 31 * result + (commentIDs != null ? commentIDs.hashCode() : 0);
        return result;
    }
    @NonNull
    @Override
    public Long getComparableId() {
        return getLocalId();
    }
}
package it.niedermann.nextcloud.deck.ui.card;
import static androidx.lifecycle.Transformations.distinctUntilChanged;
import android.app.Application;
import android.content.SharedPreferences;
import android.text.TextUtils;
import androidx.annotation.ColorInt;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MutableLiveData;
import androidx.preference.PreferenceManager;
import com.nextcloud.android.sso.api.EmptyResponse;
import com.nextcloud.android.sso.exceptions.NextcloudFilesAppAccountNotFoundException;
import java.io.File;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import it.niedermann.android.reactivelivedata.ReactiveLiveData;
import it.niedermann.android.sharedpreferences.SharedPreferenceBooleanLiveData;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.R;
import it.niedermann.nextcloud.deck.model.Account;
import it.niedermann.nextcloud.deck.model.Attachment;
import it.niedermann.nextcloud.deck.model.Board;
import it.niedermann.nextcloud.deck.model.Card;
import it.niedermann.nextcloud.deck.model.Label;
import it.niedermann.nextcloud.deck.model.full.FullBoard;
import it.niedermann.nextcloud.deck.model.full.FullCard;
import it.niedermann.nextcloud.deck.model.full.FullCardWithProjects;
import it.niedermann.nextcloud.deck.model.ocs.Activity;
import it.niedermann.nextcloud.deck.remote.api.IResponseCallback;
import it.niedermann.nextcloud.deck.repository.SyncRepository;
import it.niedermann.nextcloud.deck.ui.card.details.CardDetailsFragment;
import it.niedermann.nextcloud.deck.ui.viewmodel.BaseViewModel;
@SuppressWarnings("WeakerAccess")
public class EditCardViewModel extends BaseViewModel {
    private SyncRepository syncRepository;
    private Account account;
    private long boardId;
    private FullCardWithProjects originalCard;
    private FullCardWithProjects fullCard;
    private boolean isSupportedVersion = false;
    private boolean hasCommentsAbility = false;
    private boolean pendingSaveOperation = false;
    private boolean canEdit = false;
    private final MutableLiveData<String> descriptionChangedFromExternal$ = new MutableLiveData<>();
    private final MutableLiveData<Integer> boardColor$ = new MutableLiveData<>();
    private final SharedPreferences sharedPreferences;
    private final MutableLiveData<Boolean> descriptionIsPreview = new MutableLiveData<>(false);
    private boolean attachmentsBackPressedCallbackStatus = false;
    public EditCardViewModel(@NonNull Application application) {
        super(application);
        this.boardColor$.setValue(ContextCompat.getColor(application, R.color.primary));
        sharedPreferences = PreferenceManager.getDefaultSharedPreferences(application);
    }
    /**
     * The result {@link LiveData} will emit <code>true</code> if the preview mode is enabled and <code>false</code> if the edit mode is enabled.
     */
    public LiveData<Boolean> getDescriptionMode() {
        return new ReactiveLiveData<>(new SharedPreferenceBooleanLiveData(sharedPreferences, getApplication().getString(R.string.shared_preference_description_preview), false))
                .distinctUntilChanged()
                .flatMap(isPreview -> {
                    // When we are in preview mode but the description of the card is empty, we explicitly switch to the edit mode
                    final var fullCard = getFullCard();
                    if (fullCard == null) {
                        throw new IllegalStateException("Description mode must be queried after initializing " + EditCardViewModel.class.getSimpleName() + " with a card.");
                    }
                    if (isPreview && TextUtils.isEmpty(fullCard.getCard().getDescription())) {
                        descriptionIsPreview.setValue(false);
                    } else {
                        descriptionIsPreview.setValue(isPreview);
                    }
                    return descriptionIsPreview;
                })
                .distinctUntilChanged();
    }
    /**
     * To be called when the description is mutated from <em>outside</em> of the {@link CardDetailsFragment}.
     */
    public void changeDescriptionFromExternal(@Nullable String description) {
        getFullCard().getCard().setDescription(description);
        this.descriptionChangedFromExternal$.postValue(description);
    }
    /**
     * @return a {@link LiveData} that gets triggered with the latest {@link Card#getDescription()} was changed from <em>outside</em> of the {@link CardDetailsFragment}.
     */
    public LiveData<String> descriptionChangedFromExternal() {
        return new ReactiveLiveData<>(this.descriptionChangedFromExternal$)
                .distinctUntilChanged();
    }
    /**
     * Will toggle the edit / preview mode and persist the new state
     */
    public void toggleDescriptionPreviewMode() {
        final boolean newValue = Boolean.FALSE.equals(descriptionIsPreview.getValue());
        descriptionIsPreview.setValue(newValue);
        sharedPreferences
                .edit()
                .putBoolean(getApplication().getString(R.string.shared_preference_description_preview), newValue)
                .apply();
    }
    public LiveData<Integer> getBoardColor() {
        return distinctUntilChanged(this.boardColor$);
    }
    public void setBoardColor(@ColorInt int color) {
        this.boardColor$.setValue(color);
    }
    /**
     * Stores a deep copy of the given fullCard to be able to compare the state at every time in #{@link EditCardViewModel#hasChanges()}
     *
     * @param boardId  Local ID, expecting a positive long value
     * @param fullCard The card that is currently edited
     */
    public void initializeExistingCard(long boardId, @NonNull FullCardWithProjects fullCard, boolean isSupportedVersion) {
        this.boardId = boardId;
        this.fullCard = fullCard;
        this.originalCard = new FullCardWithProjects(this.fullCard);
        this.isSupportedVersion = isSupportedVersion;
    }
    public void setAccount(@NonNull Account account) throws NextcloudFilesAppAccountNotFoundException {
        this.account = account;
        this.syncRepository = new SyncRepository(getApplication(), account);
        hasCommentsAbility = account.getServerDeckVersionAsObject().supportsComments();
    }
    public CompletableFuture<Integer> getCurrentBoardColor(long accountId, long boardId) {
        return baseRepository.getCurrentBoardColor(accountId, boardId);
    }
    public boolean hasChanges() {
        if (fullCard == null) {
            DeckLog.info("Can not check for changes because fullCard is null → assuming no changes have been made yet.");
            return false;
        }
        return fullCard.equals(originalCard);
    }
    public boolean hasCommentsAbility() {
        return hasCommentsAbility;
    }
    public Account getAccount() {
        return account;
    }
    public FullCardWithProjects getFullCard() {
        return fullCard;
    }
    public boolean isPendingSaveOperation() {
        return pendingSaveOperation;
    }
    public void setPendingSaveOperation(boolean pendingSaveOperation) {
        this.pendingSaveOperation = pendingSaveOperation;
    }
    public boolean canEdit() {
        return canEdit && isSupportedVersion;
    }
    public void setCanEdit(boolean canEdit) {
        this.canEdit = canEdit;
    }
    public long getBoardId() {
        return boardId;
    }
    public LiveData<FullBoard> getFullBoardById(Long accountId, Long localId) {
        return baseRepository.getFullBoardById(accountId, localId);
    }
    public void createLabel(long accountId, Label label, long localBoardId, @NonNull IResponseCallback<Label> callback) {
        syncRepository.createLabel(accountId, label, localBoardId, callback);
    }
    public LiveData<FullCardWithProjects> getFullCardWithProjectsByLocalId(long accountId, long cardLocalId) {
        return baseRepository.getFullCardWithProjectsByLocalId(accountId, cardLocalId);
    }
    /**
     * Saves the current {@link #fullCard}. If it is a new card, it will be created, otherwise it will be updated.
     */
    public void saveCard(@NonNull IResponseCallback<FullCard> callback) {
        syncRepository.updateCard(getFullCard(), callback);
    }
    public LiveData<List<Activity>> syncActivitiesForCard(@NonNull Card card) {
        return syncRepository.syncActivitiesForCard(card);
    }
    public void addAttachmentToCard(long accountId, long localCardId, @NonNull String mimeType, @NonNull File file, @NonNull IResponseCallback<Attachment> callback) {
        syncRepository.addAttachmentToCard(accountId, localCardId, mimeType, file, callback);
    }
    public void deleteAttachmentOfCard(long accountId, long localCardId, long localAttachmentId, @NonNull IResponseCallback<EmptyResponse> callback) {
        syncRepository.deleteAttachmentOfCard(accountId, localCardId, localAttachmentId, callback);
    }
    public LiveData<Card> getCardByRemoteID(long accountId, long remoteId) {
        return baseRepository.getCardByRemoteID(accountId, remoteId);
    }
    public LiveData<Board> getBoardByRemoteId(long accountId, long remoteId) {
        return baseRepository.getBoardByRemoteId(accountId, remoteId);
    }
    public void setAttachmentsBackPressedCallbackStatus(boolean enabled) {
        this.attachmentsBackPressedCallbackStatus = enabled;
    }
    public boolean getAttachmentsBackPressedCallbackStatus() {
        return this.attachmentsBackPressedCallbackStatus;
    }
}
package it.niedermann.nextcloud.deck.repository;
import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
import android.annotation.SuppressLint;
import android.content.Context;
import android.database.sqlite.SQLiteConstraintException;
import android.util.Pair;
import androidx.annotation.AnyThread;
import androidx.annotation.ColorInt;
import androidx.annotation.MainThread;
import androidx.annotation.NonNull;
import androidx.annotation.VisibleForTesting;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MediatorLiveData;
import androidx.lifecycle.MutableLiveData;
import com.nextcloud.android.sso.AccountImporter;
import com.nextcloud.android.sso.api.EmptyResponse;
import com.nextcloud.android.sso.exceptions.NextcloudFilesAppAccountNotFoundException;
import com.nextcloud.android.sso.exceptions.NextcloudHttpRequestFailedException;
import com.nextcloud.android.sso.model.SingleSignOnAccount;
import java.io.File;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.database.DataBaseAdapter;
import it.niedermann.nextcloud.deck.exceptions.DeckException;
import it.niedermann.nextcloud.deck.exceptions.OfflineException;
import it.niedermann.nextcloud.deck.model.AccessControl;
import it.niedermann.nextcloud.deck.model.Account;
import it.niedermann.nextcloud.deck.model.Attachment;
import it.niedermann.nextcloud.deck.model.Board;
import it.niedermann.nextcloud.deck.model.Card;
import it.niedermann.nextcloud.deck.model.JoinCardWithUser;
import it.niedermann.nextcloud.deck.model.Label;
import it.niedermann.nextcloud.deck.model.Stack;
import it.niedermann.nextcloud.deck.model.User;
import it.niedermann.nextcloud.deck.model.enums.DBStatus;
import it.niedermann.nextcloud.deck.model.full.FullBoard;
import it.niedermann.nextcloud.deck.model.full.FullCard;
import it.niedermann.nextcloud.deck.model.full.FullStack;
import it.niedermann.nextcloud.deck.model.internal.FilterInformation;
import it.niedermann.nextcloud.deck.model.ocs.Capabilities;
import it.niedermann.nextcloud.deck.model.ocs.comment.DeckComment;
import it.niedermann.nextcloud.deck.model.ocs.comment.OcsComment;
import it.niedermann.nextcloud.deck.model.ocs.user.OcsUserList;
import it.niedermann.nextcloud.deck.model.ocs.user.UserForAssignment;
import it.niedermann.nextcloud.deck.remote.adapters.ServerAdapter;
import it.niedermann.nextcloud.deck.remote.api.GsonConfig;
import it.niedermann.nextcloud.deck.remote.api.IResponseCallback;
import it.niedermann.nextcloud.deck.remote.api.LastSyncUtil;
import it.niedermann.nextcloud.deck.remote.api.ResponseCallback;
import it.niedermann.nextcloud.deck.remote.helpers.DataPropagationHelper;
import it.niedermann.nextcloud.deck.remote.helpers.SyncHelper;
import it.niedermann.nextcloud.deck.remote.helpers.providers.AbstractSyncDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.AccessControlDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.ActivityDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.AttachmentDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.BoardDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.CardDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.CardPropagationDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.DeckCommentsDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.LabelDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.StackDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.partial.BoardWithAclDownSyncDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.providers.partial.BoardWithStacksAndLabelsUpSyncDataProvider;
import it.niedermann.nextcloud.deck.remote.helpers.util.ConnectivityUtil;
import okhttp3.Headers;
/**
 * Extends {@link BaseRepository} by synchronization capabilities.
 * Therefore it always requires an {@link Account} to choose the correct {@link SingleSignOnAccount} for network operations.
 */
@SuppressWarnings("WeakerAccess")
public class SyncRepository extends BaseRepository {
    @NonNull
    private final ServerAdapter serverAdapter;
    @NonNull
    private final SyncHelper.Factory syncHelperFactory;
    @AnyThread
    public SyncRepository(@NonNull Context context, @NonNull Account account) throws NextcloudFilesAppAccountNotFoundException {
        this(context, AccountImporter.getSingleSignOnAccount(context, account.getName()), new ConnectivityUtil(context));
    }
    private SyncRepository(@NonNull Context context,
                           @NonNull SingleSignOnAccount ssoAccount,
                           @NonNull ConnectivityUtil connectivityUtil) {
        this(context, new ServerAdapter(context.getApplicationContext(), ssoAccount, connectivityUtil), connectivityUtil, SyncHelper::new);
    }
    protected SyncRepository(@NonNull Context context,
                             @NonNull ServerAdapter serverAdapter,
                             @NonNull ConnectivityUtil connectivityUtil,
                             @NonNull SyncHelper.Factory syncHelperFactory) {
        super(context, connectivityUtil);
        this.serverAdapter = serverAdapter;
        this.syncHelperFactory = syncHelperFactory;
        LastSyncUtil.init(context.getApplicationContext());
    }
    @VisibleForTesting
    protected SyncRepository(@NonNull Context context,
                             @NonNull ServerAdapter serverAdapter,
                             @NonNull ConnectivityUtil connectivityUtil,
                             @NonNull SyncHelper.Factory syncHelperFactory,
                             @NonNull DataBaseAdapter databaseAdapter,
                             @NonNull ExecutorService executor) {
        super(context, connectivityUtil, databaseAdapter, executor);
        this.serverAdapter = serverAdapter;
        this.syncHelperFactory = syncHelperFactory;
        LastSyncUtil.init(context.getApplicationContext());
    }
    @AnyThread
    public void fetchBoardsFromServer(@NonNull ResponseCallback<List<FullBoard>> callback) {
        executor.submit(() -> serverAdapter.getBoards(callback));
    }
    @AnyThread
    public LiveData<Pair<Integer, Integer>> synchronize(@NonNull ResponseCallback<Boolean> responseCallback) {
        final var progress$ = new MutableLiveData<Pair<Integer, Integer>>();
        final var callbackAccount = responseCallback.getAccount();
        final long callbackAccountId = callbackAccount.getId();
        executor.submit(() -> {
            refreshCapabilities(new ResponseCallback<>(responseCallback.getAccount()) {
                @Override
                public void onResponse(Capabilities response, Headers headers) {
                    if (response != null && !response.isMaintenanceEnabled()) {
                        if (response.getDeckVersion().isSupported()) {
                            final var lastSyncDate = LastSyncUtil.getLastSyncDate(callbackAccountId);
                            final var syncHelper = syncHelperFactory.create(serverAdapter, dataBaseAdapter, lastSyncDate);
                            final var callback = new ResponseCallback<Boolean>(callbackAccount) {
                                @Override
                                public void onResponse(Boolean response, Headers headers) {
                                    syncHelper.setResponseCallback(new ResponseCallback<>(account) {
                                        @Override
                                        public void onResponse(Boolean response, Headers headers) {
                                            LastSyncUtil.setLastSyncDate(callbackAccountId, Instant.now());
                                            responseCallback.onResponse(response, headers);
                                        }
                                        @Override
                                        public void onError(Throwable throwable) {
                                            super.onError(throwable);
                                            responseCallback.onResponse(response, headers);
                                        }
                                    });
                                    executor.submit(() -> {
                                        try {
                                            syncHelper.doUpSyncFor(new BoardDataProvider(progress$));
                                        } catch (Throwable e) {
                                            DeckLog.logError(e);
                                            responseCallback.onError(e);
                                        }
                                    });
                                }
                                @Override
                                public void onError(Throwable throwable) {
                                    super.onError(throwable);
                                    responseCallback.onError(throwable);
                                }
                            };
                            syncHelper.setResponseCallback(callback);
                            try {
                                syncHelper.doSyncFor(new BoardDataProvider(progress$, false), false);
                            } catch (Throwable e) {
                                DeckLog.logError(e);
                                responseCallback.onError(e);
                            }
                        } else {
                            DeckLog.warn("No sync. Server version not supported:", response.getDeckVersion().getOriginalVersion());
                            responseCallback.onResponse(Boolean.FALSE, headers);
                        }
                    } else {
                        responseCallback.onResponse(Boolean.FALSE, headers);
                        if (response != null) {
                            DeckLog.warn("No sync. Status maintenance mode:", response.isMaintenanceEnabled());
                        }
                    }
                }
                @SuppressLint("MissingSuperCall")
                @Override
                public void onError(Throwable throwable) {
                    responseCallback.onError(throwable);
                }
            });
        });
        return progress$;
    }
    @AnyThread
    public void synchronizeBoard(long localBoardId, @NonNull ResponseCallback<Boolean> responseCallback) {
        executor.submit(() -> {
            FullBoard board = dataBaseAdapter.getFullBoardByLocalIdDirectly(responseCallback.getAccount().getId(), localBoardId);
            try {
                syncHelperFactory.create(serverAdapter, dataBaseAdapter, null)
                        .setResponseCallback(responseCallback)
                        .doSyncFor(new StackDataProvider(null, board));
            } catch (OfflineException e) {
                responseCallback.onError(e);
            }
        });
    }
    @AnyThread
    public void synchronizeCard(@NonNull ResponseCallback<Boolean> responseCallback, @NonNull Card card) {
        executor.submit(() -> {
            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(card.getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getStack().getBoardId());
            try {
                syncHelperFactory.create(serverAdapter, dataBaseAdapter, null)
                        .setResponseCallback(responseCallback)
                        .doSyncFor(new CardDataProvider(null, board, stack));
            } catch (OfflineException e) {
                responseCallback.onError(e);
            }
        });
    }
//    private <T extends AbstractRemoteEntity> T applyUpdatesFromRemote(T localEntity, T remoteEntity, Long accountId) {
//        if (!localEntity.getId().equals(remoteEntity.getId())
//                || !accountId.equals(localEntity.getAccountId())) {
//            throw new IllegalArgumentException("IDs of Account or Entity are not matching! WTF are you doin?!");
//        }
//        remoteEntity.setLastModifiedLocal(remoteEntity.getLastModified()); // not an error! local-modification = remote-mod
//        remoteEntity.setLocalId(localEntity.getLocalId());
//        return remoteEntity;
//    }
    /**
     * <p>
     * Since the return value is a {@link LiveData}, it should immediately return the available values from the database
     * and then perform a synchronization (not full but only for the needed data) to update the return value.
     * <p>
     * See https://github.com/stefan-niedermann/nextcloud-deck/issues/498#issuecomment-631615680
     *
     * @param host e. g. "example.com:4711"
     * @return a {@link List<Account>} of {@link Account}s which are
     * - located at the given {@param host}
     * - and have the permission to read the board with the given {@param boardRemoteId} (aka the {@link Board} is shared with this {@link User}).
     */
    @MainThread
    public LiveData<List<Account>> readAccountsForHostWithReadAccessToBoard(String host, long boardRemoteId) {
        MediatorLiveData<List<Account>> liveData = new MediatorLiveData<>();
        liveData.addSource(dataBaseAdapter.readAccountsForHostWithReadAccessToBoard(host, boardRemoteId), accounts -> {
            liveData.postValue(accounts);
            executor.submit(() -> {
                for (Account account : accounts) {
                    syncHelperFactory.create(serverAdapter, dataBaseAdapter, null)
                            .setResponseCallback(new ResponseCallback<>(account) {
                                @Override
                                public void onResponse(Boolean response, Headers headers) {
                                    liveData.postValue(dataBaseAdapter.readAccountsForHostWithReadAccessToBoardDirectly(host, boardRemoteId));
                                }
                            }).doSyncFor(new BoardWithAclDownSyncDataProvider());
                }
            });
        });
        return liveData;
    }
    @AnyThread
    public Future<?> refreshCapabilities(@NonNull ResponseCallback<Capabilities> callback) {
        return executor.submit(() -> {
            try {
                Account accountForEtag = dataBaseAdapter.getAccountByIdDirectly(callback.getAccount().getId());
                serverAdapter.getCapabilities(accountForEtag.getEtag(), new ResponseCallback<>(callback.getAccount()) {
                    @Override
                    public void onResponse(Capabilities response, Headers headers) {
                        Account acc = dataBaseAdapter.getAccountByIdDirectly(account.getId());
                        acc.applyCapabilities(response, headers.get("ETag"));
                        dataBaseAdapter.updateAccount(acc);
                        callback.getAccount().setServerDeckVersion(acc.getServerDeckVersion());
                        callback.onResponse(response, headers);
                    }
                    @SuppressLint("MissingSuperCall")
                    @Override
                    public void onError(Throwable throwable) {
                        if (throwable instanceof NextcloudHttpRequestFailedException requestFailedException) {
                            DeckLog.verbose("HTTP Status " + requestFailedException.getStatusCode());
                            if (requestFailedException.getStatusCode() == HTTP_UNAVAILABLE && requestFailedException.getCause() != null) {
                                final String errorString = requestFailedException.getCause().getMessage();
                                final Capabilities capabilities = GsonConfig.getGson().fromJson(errorString, Capabilities.class);
                                if (capabilities.isMaintenanceEnabled()) {
                                    DeckLog.verbose("Yes, it is in maintenance mode according to the capabilities");
                                    executor.submit(() -> onResponse(capabilities, IResponseCallback.EMPTY_HEADERS));
                                } else {
                                    DeckLog.error("No, it is not in maintenance mode according to the capabilities.");
                                    callback.onError(throwable);
                                }
                            } else if (requestFailedException.getStatusCode() == HTTP_NOT_MODIFIED) {
                                DeckLog.verbose("HTTP Status", HTTP_NOT_MODIFIED + ": There haven't been any changes on the server side for this request.");
                                // could be after maintenance. so we have to at least revert the maintenance flag
                                executor.submit(() -> {
                                    final Account acc = dataBaseAdapter.getAccountByIdDirectly(account.getId());
                                    if (acc.isMaintenanceEnabled()) {
                                        acc.setMaintenanceEnabled(false);
                                        dataBaseAdapter.updateAccount(acc);
                                    }
                                    final Capabilities capabilities = new Capabilities();
                                    capabilities.setMaintenanceEnabled(false);
                                    capabilities.setDeckVersion(acc.getServerDeckVersionAsObject());
                                    capabilities.setTextColor(acc.getTextColor());
                                    capabilities.setColor(acc.getColor());
                                    callback.onResponse(capabilities, IResponseCallback.EMPTY_HEADERS);
                                });
                            } else {
                                callback.onError(throwable);
                            }
                        } else {
                            callback.onError(throwable);
                        }
                    }
                });
            } catch (OfflineException e) {
                callback.onError(e);
            }
        });
    }
    @AnyThread
    public void createBoard(@NonNull Account account, @NonNull Board board, @NonNull IResponseCallback<FullBoard> callback) {
        executor.submit(() -> {
            final User owner = dataBaseAdapter.getUserByUidDirectly(account.getId(), account.getUserName());
            if (owner == null) {
                StringBuilder sb = buildOwnerNullMessage(account);
                callback.onError(new IllegalStateException(sb.toString()));
            } else {
                final FullBoard fullBoard = new FullBoard();
                board.setOwnerId(owner.getLocalId());
                fullBoard.setOwner(owner);
                fullBoard.setBoard(board);
                board.setAccountId(account.getId());
                fullBoard.setAccountId(account.getId());
                new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).createEntity(new BoardDataProvider(), fullBoard, ResponseCallback.from(account, callback));
            }
        });
    }
    @NonNull
    private StringBuilder buildOwnerNullMessage(@NonNull Account account) {
        StringBuilder sb = new StringBuilder("Owner is null. This can be the case if the Deck app has never before been opened in the webinterface. More:");
        sb.append("\naccount_id:");
        sb.append(account.getId());
        sb.append("\nusername:");
        sb.append(account.getUserName());
        sb.append("\nList of available Users:");
        sb.append(account.getUserName());
        List<User> allUsers = dataBaseAdapter.getAllUsersDirectly();
        if (allUsers != null) {
            for (User u : allUsers) {
                sb.append("\nuid:");
                sb.append(u.getUid());
                sb.append(" | account_id:");
                sb.append(u.getAccountId());
            }
        } else {
            sb.append("[none]");
        }
        return sb;
    }
    /**
     * Creates a new {@link Board} and adds the same {@link Label} and {@link Stack} as in the origin {@link Board}.
     * Owner of the target {@link Board} will be the {@link User} with the {@link Account} of {@param targetAccountId}.
     *
     * @param cloneCards determines whether or not the cards in this {@link Board} shall be cloned or not
     *                   Does <strong>not</strong> clone any {@link Card} or {@link AccessControl} from the origin {@link Board}.
     */
    @AnyThread
    public void cloneBoard(long originAccountId, long originBoardLocalId, long targetAccountId, @ColorInt int targetBoardColor, boolean cloneCards, @NonNull IResponseCallback<FullBoard> callback) {
        executor.submit(() -> {
            Account originAccount = dataBaseAdapter.getAccountByIdDirectly(originAccountId);
            User newOwner = dataBaseAdapter.getUserByUidDirectly(originAccountId, originAccount.getUserName());
            if (newOwner == null) {
                callback.onError(new DeckException(DeckException.Hint.UNKNOWN_ACCOUNT_USER_ID, "User with Account-UID \"" + originAccount.getUserName() + "\" not found."));
                return;
            }
            FullBoard originalBoard = dataBaseAdapter.getFullBoardByLocalIdDirectly(originAccountId, originBoardLocalId);
            String newBoardTitleBaseName = originalBoard.getBoard().getTitle().trim();
            int newBoardTitleCopyIndex = 0;
            //already a copy?
            String regex = " \\(copy [0-9]+\\)$";
            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(originalBoard.getBoard().getTitle());
            if (matcher.find()) {
                String found = matcher.group();
                newBoardTitleBaseName = newBoardTitleBaseName.substring(0, newBoardTitleBaseName.length() - found.length());
                Matcher indexMatcher = Pattern.compile("[0-9]+").matcher(found);
                //noinspection ResultOfMethodCallIgnored
                indexMatcher.find();
                String oldIndexString = indexMatcher.group();
                newBoardTitleCopyIndex = Integer.parseInt(oldIndexString);
            }
            String newBoardTitle;
            do {
                newBoardTitleCopyIndex++;
                newBoardTitle = newBoardTitleBaseName + " (copy " + newBoardTitleCopyIndex + ")";
            } while (dataBaseAdapter.getBoardForAccountByNameDirectly(targetAccountId, newBoardTitle) != null);
            originalBoard.setAccountId(targetAccountId);
            originalBoard.setId(null);
            originalBoard.setLocalId(null);
            originalBoard.getBoard().setTitle(newBoardTitle);
            originalBoard.getBoard().setColor(String.format("%06X", 0xFFFFFF & targetBoardColor));
            originalBoard.getBoard().setOwnerId(newOwner.getLocalId());
            originalBoard.setStatusEnum(DBStatus.LOCAL_EDITED);
            originalBoard.setOwner(newOwner);
            long newBoardId = dataBaseAdapter.createBoardDirectly(originAccountId, originalBoard.getBoard());
            originalBoard.setLocalId(newBoardId);
            boolean isSameAccount = targetAccountId == originAccountId;
            if (isSameAccount) {
                List<AccessControl> aclList = originalBoard.getParticipants();
                for (AccessControl acl : aclList) {
                    acl.setLocalId(null);
                    acl.setId(null);
                    acl.setBoardId(newBoardId);
                    dataBaseAdapter.createAccessControl(targetAccountId, acl);
                }
            }
            Map<Long, Long> oldToNewLabelIdsDictionary = new HashMap<>();
            for (Label label : originalBoard.getLabels()) {
                Long oldLocalId = label.getLocalId();
                label.setLocalId(null);
                label.setId(null);
                label.setAccountId(targetAccountId);
                label.setStatusEnum(DBStatus.LOCAL_EDITED);
                label.setBoardId(newBoardId);
                long newLocalId = dataBaseAdapter.createLabelDirectly(targetAccountId, label);
                oldToNewLabelIdsDictionary.put(oldLocalId, newLocalId);
            }
            List<Stack> oldStacks = originalBoard.getStacks();
            for (Stack stack : oldStacks) {
                Long oldStackId = stack.getLocalId();
                stack.setLocalId(null);
                stack.setId(null);
                stack.setStatusEnum(DBStatus.LOCAL_EDITED);
                stack.setAccountId(targetAccountId);
                stack.setBoardId(newBoardId);
                long createdStackId = dataBaseAdapter.createStack(targetAccountId, stack);
                if (cloneCards) {
                    List<FullCard> oldCards = dataBaseAdapter.getFullCardsForStackDirectly(originAccountId, oldStackId, null);
                    for (FullCard oldCard : oldCards) {
                        Card newCard = oldCard.getCard();
                        newCard.setId(null);
                        newCard.setUserId(newOwner.getLocalId());
                        newCard.setLocalId(null);
                        newCard.setStackId(createdStackId);
                        newCard.setAccountId(targetAccountId);
                        newCard.setStatusEnum(DBStatus.LOCAL_EDITED);
                        long createdCardId = dataBaseAdapter.createCardDirectly(targetAccountId, newCard);
                        if (oldCard.getLabels() != null) {
                            for (Label oldLabel : oldCard.getLabels()) {
                                Long newLabelId = oldToNewLabelIdsDictionary.get(oldLabel.getLocalId());
                                if (newLabelId != null) {
                                    dataBaseAdapter.createJoinCardWithLabel(newLabelId, createdCardId, DBStatus.LOCAL_EDITED);
                                } else
                                    DeckLog.error("ID of created Label is null! Skipping assignment of ", oldLabel.getTitle(), "…");
                            }
                        }
                        if (isSameAccount && oldCard.getAssignedUsers() != null) {
                            for (User assignedUser : oldCard.getAssignedUsers()) {
                                dataBaseAdapter.createJoinCardWithUser(assignedUser.getLocalId(), createdCardId, DBStatus.LOCAL_EDITED);
                            }
                        }
                    }
                }
            }
            if (connectivityUtil.hasInternetConnection()) {
                Account targetAccount = dataBaseAdapter.getAccountByIdDirectly(targetAccountId);
                final ServerAdapter serverAdapterToUse;
                if (originAccountId == targetAccountId) {
                    serverAdapterToUse = this.serverAdapter;
                } else {
                    try {
                        serverAdapterToUse = new ServerAdapter(context, AccountImporter.getSingleSignOnAccount(context, targetAccount.getName()), connectivityUtil);
                    } catch (NextcloudFilesAppAccountNotFoundException e) {
                        callback.onError(e);
                        return;
                    }
                }
                syncHelperFactory.create(serverAdapterToUse, dataBaseAdapter, null)
                        .setResponseCallback(new ResponseCallback<>(targetAccount) {
                            @Override
                            public void onResponse(Boolean response, Headers headers) {
                                callback.onResponse(dataBaseAdapter.getFullBoardByLocalIdDirectly(targetAccountId, newBoardId), headers);
                            }
                            @SuppressLint("MissingSuperCall")
                            @Override
                            public void onError(Throwable throwable) {
                                callback.onError(throwable);
                            }
                        }).doUpSyncFor(new BoardWithStacksAndLabelsUpSyncDataProvider(dataBaseAdapter.getFullBoardByLocalIdDirectly(targetAccountId, newBoardId)));
            } else {
                callback.onResponse(dataBaseAdapter.getFullBoardByLocalIdDirectly(targetAccountId, newBoardId), IResponseCallback.EMPTY_HEADERS);
            }
        });
    }
    @AnyThread
    public LiveData<List<it.niedermann.nextcloud.deck.model.ocs.Activity>> syncActivitiesForCard(@NonNull Card card) {
        executor.submit(() -> {
            if (connectivityUtil.hasInternetConnection()) {
                if (card.getId() != null) {
                    syncHelperFactory.create(serverAdapter, dataBaseAdapter, null)
                            .setResponseCallback(new ResponseCallback<>(dataBaseAdapter.getAccountByIdDirectly(card.getAccountId())) {
                                @Override
                                public void onResponse(Boolean response, Headers headers) {
                                    // do nothing
                                }
                            }).doSyncFor(new ActivityDataProvider(null, card));
                } else {
                    DeckLog.log("Can not fetch activities for card ", card.getTitle(), "because this card does not have a remote id yet.");
                }
            }
        });
        return dataBaseAdapter.getActivitiesForCard(card.getLocalId());
    }
    @AnyThread
    public void addCommentToCard(long accountId, long cardId, @NonNull DeckComment comment) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            Card card = dataBaseAdapter.getCardByLocalIdDirectly(accountId, cardId);
            OcsComment commentEntity = OcsComment.of(comment);
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).createEntity(new DeckCommentsDataProvider(null, card), commentEntity, new ResponseCallback<>(account) {
                @Override
                public void onResponse(OcsComment response, Headers headers) {
                    // nothing so far
                }
            });
        });
    }
    @AnyThread
    public void updateComment(long accountId, long localCardId, long localCommentId, String comment) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            Card card = dataBaseAdapter.getCardByLocalIdDirectly(accountId, localCardId);
            DeckComment entity = dataBaseAdapter.getCommentByLocalIdDirectly(accountId, localCommentId);
            entity.setMessage(comment);
            OcsComment commentEntity = OcsComment.of(entity);
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).updateEntity(new DeckCommentsDataProvider(null, card), commentEntity, new ResponseCallback<>(account) {
                @Override
                public void onResponse(OcsComment response, Headers headers) {
                    // nothing so far
                }
            });
        });
    }
    @AnyThread
    public void deleteComment(long accountId, long localCardId, long localCommentId, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            final Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            final Card card = dataBaseAdapter.getCardByLocalIdDirectly(accountId, localCardId);
            final DeckComment entity = dataBaseAdapter.getCommentByLocalIdDirectly(accountId, localCommentId);
            final OcsComment commentEntity = OcsComment.of(entity);
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).deleteEntity(new DeckCommentsDataProvider(null, card),
                    commentEntity, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void deleteBoard(@NonNull Board board, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            long accountId = board.getAccountId();
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            FullBoard fullBoard = dataBaseAdapter.getFullBoardByLocalIdDirectly(accountId, board.getLocalId());
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).deleteEntity(new BoardDataProvider(), fullBoard, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void updateBoard(@NonNull FullBoard board, @NonNull IResponseCallback<FullBoard> callback) {
        executor.submit(() -> {
            long accountId = board.getAccountId();
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).updateEntity(new BoardDataProvider(), board, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void createAccessControl(long accountId, @NonNull AccessControl entity, @NonNull IResponseCallback<AccessControl> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            FullBoard board = dataBaseAdapter.getFullBoardByLocalIdDirectly(accountId, entity.getBoardId());
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).createEntity(
                    new AccessControlDataProvider(null, board, Collections.singletonList(entity)), entity, ResponseCallback.from(account, callback), ((entity1, response) -> {
                        response.setBoardId(entity.getBoardId());
                        response.setUserId(entity.getUser().getLocalId());
                    })
            );
        });
    }
    @AnyThread
    public void updateAccessControl(@NonNull AccessControl entity, @NonNull IResponseCallback<AccessControl> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(entity.getAccountId());
            FullBoard board = dataBaseAdapter.getFullBoardByLocalIdDirectly(entity.getAccountId(), entity.getBoardId());
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).updateEntity(
                    new AccessControlDataProvider(null, board, Collections.singletonList(entity)), entity, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void deleteAccessControl(@NonNull AccessControl entity, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(entity.getAccountId());
            FullBoard board = dataBaseAdapter.getFullBoardByLocalIdDirectly(entity.getAccountId(), entity.getBoardId());
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).deleteEntity(
                    new AccessControlDataProvider(null, board, Collections.singletonList(entity)), entity, new ResponseCallback<>(account) {
                        @Override
                        public void onResponse(EmptyResponse response, Headers headers) {
                            // revoked own board-access?
                            if (entity.getAccountId() == entity.getAccountId() && entity.getUser().getUid().equals(account.getUserName())) {
                                dataBaseAdapter.saveNeighbourOfBoard(board.getAccountId(), board.getLocalId());
                                dataBaseAdapter.removeCurrentStackId(board.getAccountId(), board.getLocalId());
                                dataBaseAdapter.deleteBoardPhysically(board.getBoard());
                            }
                            callback.onResponse(response, headers);
                        }
                        @SuppressLint("MissingSuperCall")
                        @Override
                        public void onError(Throwable throwable) {
                            callback.onError(throwable);
                        }
                    });
        });
    }
    @AnyThread
    public void createStack(long accountId, long boardLocalId, @NonNull String title, @NonNull IResponseCallback<FullStack> callback) {
        executor.submit(() -> {
            DeckLog.info("Create Stack in account", accountId, "on board with local ID ", boardLocalId);
            Stack stack = new Stack(title, boardLocalId);
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            FullBoard board = dataBaseAdapter.getFullBoardByLocalIdDirectly(accountId, stack.getBoardId());
            FullStack fullStack = new FullStack();
            stack.setOrder(dataBaseAdapter.getHighestStackOrderInBoard(stack.getBoardId()) + 1);
            stack.setAccountId(accountId);
            stack.setBoardId(board.getLocalId());
            fullStack.setStack(stack);
            fullStack.setAccountId(accountId);
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).createEntity(new StackDataProvider(null, board), fullStack, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void deleteStack(long accountId, long boardLocalId, long stackLocalId, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            FullStack fullStack = dataBaseAdapter.getFullStackByLocalIdDirectly(stackLocalId);
            FullBoard board = dataBaseAdapter.getFullBoardByLocalIdDirectly(accountId, boardLocalId);
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).deleteEntity(new StackDataProvider(null, board), fullStack, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void updateStackTitle(long localStackId, @NonNull String newTitle, @NonNull IResponseCallback<FullStack> callback) {
        executor.submit(() -> {
            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(localStackId);
            FullBoard fullBoard = dataBaseAdapter.getFullBoardByLocalIdDirectly(stack.getAccountId(), stack.getStack().getBoardId());
            Account account = dataBaseAdapter.getAccountByIdDirectly(stack.getAccountId());
            stack.getStack().setTitle(newTitle);
            updateStack(account, fullBoard, stack, callback);
        });
    }
    @AnyThread
    private void updateStack(@NonNull Account account, @NonNull FullBoard board, @NonNull FullStack stack, @NonNull IResponseCallback<FullStack> callback) {
        executor.submit(() -> new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).updateEntity(new StackDataProvider(null, board), stack, ResponseCallback.from(account, callback)));
    }
    /**
     * Reorders stacks and ensures order validity
     *
     * @param accountId    The ID of the Account
     * @param boardLocalId The ID of the Board the stack is in
     * @param stackLocalId The ID of the stack to move
     * @param moveToRight  <code>true</code> to move right, <code>false</code> to move left
     */
    @AnyThread
    public void reorderStack(long accountId, long boardLocalId, long stackLocalId, boolean moveToRight) {
        executor.submit(() -> {
            final Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            final FullBoard fullBoard = dataBaseAdapter.getFullBoardByLocalIdDirectly(accountId, boardLocalId);
            final List<FullStack> stacks = dataBaseAdapter.getFullStacksForBoardDirectly(accountId, boardLocalId);
            int lastOrderValue = -1;
            boolean moveDone = false;
            for (int i = 0; i < stacks.size(); i++) {
                FullStack s = stacks.get(i);
                boolean currentStackChanged = false;
                // ensure order validity
                if (lastOrderValue >= s.getStack().getOrder()) {
                    s.getStack().setOrder(lastOrderValue + 1);
                    currentStackChanged = true;
                }
                lastOrderValue = s.getStack().getOrder();
                if (!moveDone && i < stacks.size() - 1 && (moveToRight ? s : stacks.get(i + 1)).getLocalId() == stackLocalId) {
                    FullStack rightStack = stacks.get(i + 1);
                    // fix orders
                    rightStack.getStack().setOrder(lastOrderValue);
                    s.getStack().setOrder(lastOrderValue + 1);
                    // update the other one
                    updateStack(account, fullBoard, rightStack, IResponseCallback.empty());
                    // ensure the current one is updated as well
                    currentStackChanged = true;
                    stacks.set(i, stacks.get(i + 1));
                    stacks.set(i + 1, s);
                    moveDone = true;
                }
                if (currentStackChanged) {
                    updateStack(account, fullBoard, s, IResponseCallback.empty());
                }
            }
        });
    }
    // TODO implement, see https://github.com/stefan-niedermann/nextcloud-deck/issues/395
    public LiveData<List<FullCard>> getArchivedFullCardsForBoard(long accountId, long localBoardId) {
        MutableLiveData<List<FullCard>> dummyData = new MutableLiveData<>();
        dummyData.postValue(new ArrayList<>());
        return dummyData;
    }
//    public LiveData<FullCard> createCard(long accountId, long localBoardId, long localStackId, Card card) {
//
//        MutableLiveData<FullCard> liveData = new MutableLiveData<>();
//        executor.submit(() -> {
//            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
//            User owner = dataBaseAdapter.getUserByUidDirectly(accountId, account.getUserName());
//            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(localStackId);
//            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(localBoardId);
//            card.setStackId(stack.getLocalId());
//            FullCard fullCard = new FullCard();
//            fullCard.setCard(card);
//            fullCard.setOwner(owner);
//            fullCard.setAccountId(accountId);
//            new DataPropagationHelper(serverAdapter, dataBaseAdapter).createEntity(new CardPropagationDataProvider(null, board, stack), fullCard, new IResponseCallback<FullCard>(account) {
//                @Override
//                public void onResponse(FullCard response) {
//                    liveData.postValue(response);
//                }
//            }, (FullCard entity, FullCard response) -> {
//                response.getCard().setUserId(entity.getCard().getUserId());
//                response.getCard().setStackId(stack.getLocalId());
//            });
//        });
//        return liveData;
//    }
    @AnyThread
    public void createFullCard(long accountId, long localBoardId, long localStackId, @NonNull FullCard card, @NonNull IResponseCallback<FullCard> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            User owner = dataBaseAdapter.getUserByUidDirectly(accountId, account.getUserName());
            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(localStackId);
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(localBoardId);
            card.getCard().setUserId(owner.getLocalId());
            card.getCard().setStackId(stack.getLocalId());
            card.getCard().setAccountId(accountId);
            card.getCard().setStatusEnum(DBStatus.LOCAL_EDITED);
            card.getCard().setOrder(dataBaseAdapter.getHighestCardOrderInStack(localStackId) + 1);
            long localCardId = dataBaseAdapter.createCardDirectly(accountId, card.getCard());
            card.getCard().setLocalId(localCardId);
            List<User> assignedUsers = card.getAssignedUsers();
            if (assignedUsers != null) {
                for (User assignedUser : assignedUsers) {
                    dataBaseAdapter.createJoinCardWithUser(assignedUser.getLocalId(), localCardId, DBStatus.LOCAL_EDITED);
                }
            }
            List<Label> labels = card.getLabels();
            if (labels != null) {
                for (Label label : labels) {
                    dataBaseAdapter.createJoinCardWithLabel(label.getLocalId(), localCardId, DBStatus.LOCAL_EDITED);
                }
            }
            if (card.getAttachments() != null) {
                for (Attachment attachment : card.getAttachments()) {
                    if (attachment.getLocalId() == null) {
                        attachment.setCardId(localCardId);
                        dataBaseAdapter.createAttachment(accountId, attachment);
                    }
                }
            }
            if (connectivityUtil.hasInternetConnection()) {
                syncHelperFactory.create(serverAdapter, dataBaseAdapter, null)
                        .setResponseCallback(new ResponseCallback<>(account) {
                            @Override
                            public void onResponse(Boolean response, Headers headers) {
                                callback.onResponse(card, headers);
                            }
                            @SuppressLint("MissingSuperCall")
                            @Override
                            public void onError(Throwable throwable) {
                                if (throwable.getClass() == DeckException.class && ((DeckException) throwable).getHint().equals(DeckException.Hint.DEPENDENCY_NOT_SYNCED_YET)) {
                                    callback.onResponse(card, IResponseCallback.EMPTY_HEADERS);
                                } else {
                                    callback.onError(throwable);
                                }
                            }
                        })
                        .doUpSyncFor(new CardDataProvider(null, board, stack));
            } else {
                callback.onResponse(card, IResponseCallback.EMPTY_HEADERS);
            }
        });
    }
    @AnyThread
    public void deleteCard(@NonNull Card card, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            FullCard fullCard = dataBaseAdapter.getFullCardByLocalIdDirectly(card.getAccountId(), card.getLocalId());
            if (fullCard == null) {
                throw new IllegalArgumentException("card with id " + card.getLocalId() + " to delete does not exist.");
            }
            Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(card.getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getStack().getBoardId());
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).deleteEntity(new CardPropagationDataProvider(null, board, stack), fullCard, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void archiveCard(@NonNull FullCard card, @NonNull IResponseCallback<FullCard> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(card.getCard().getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getStack().getBoardId());
            card.getCard().setArchived(true);
            updateCardForArchive(stack, board, card, ResponseCallback.from(account, callback));
        });
    }
    private void updateCardForArchive(FullStack stack, Board board, FullCard card, @NonNull ResponseCallback<FullCard> callback) {
        new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).updateEntity(new CardDataProvider(null, board, stack), card, callback);
    }
    @AnyThread
    public void dearchiveCard(@NonNull FullCard card, @NonNull IResponseCallback<FullCard> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(card.getCard().getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getStack().getBoardId());
            card.getCard().setArchived(false);
            updateCardForArchive(stack, board, card, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void archiveCardsInStack(long accountId, long stackLocalId, @NonNull FilterInformation filterInformation, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(stackLocalId);
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getStack().getBoardId());
            List<FullCard> cards = dataBaseAdapter.getFullCardsForStackDirectly(accountId, stackLocalId, filterInformation);
            if (cards.size() <= 0) {
                callback.onResponse(null, IResponseCallback.EMPTY_HEADERS);
                return;
            }
            final CountDownLatch latch = new CountDownLatch(cards.size());
            for (FullCard card : cards) {
                if (card.getCard().isArchived()) {
                    latch.countDown();
                    continue;
                }
                card.getCard().setArchived(true);
                updateCardForArchive(stack, board, card, new ResponseCallback<>(account) {
                    @Override
                    public void onResponse(FullCard response, Headers headers) {
                        latch.countDown();
                    }
                    @SuppressLint("MissingSuperCall")
                    @Override
                    public void onError(Throwable throwable) {
                        latch.countDown();
                        callback.onError(throwable);
                    }
                });
            }
            try {
                latch.await();
                callback.onResponse(null, IResponseCallback.EMPTY_HEADERS);
            } catch (InterruptedException e) {
                callback.onError(e);
            }
        });
    }
    @AnyThread
    public void archiveBoard(@NonNull Board board, @NonNull IResponseCallback<FullBoard> callback) {
        executor.submit(() -> {
            try {
                final var fullBoard = dataBaseAdapter.getFullBoardByLocalIdDirectly(board.getAccountId(), board.getLocalId());
                fullBoard.getBoard().setArchived(true);
                updateBoard(fullBoard, new IResponseCallback<>() {
                    @Override
                    public void onResponse(FullBoard response, Headers headers) {
                        dataBaseAdapter.saveNeighbourOfBoard(fullBoard.getAccountId(), fullBoard.getLocalId());
                        callback.onResponse(response, headers);
                    }
                    @SuppressLint("MissingSuperCall")
                    @Override
                    public void onError(Throwable throwable) {
                        callback.onError(throwable);
                    }
                });
            } catch (Throwable e) {
                callback.onError(e);
            }
        });
    }
    @AnyThread
    public void dearchiveBoard(@NonNull Board board, @NonNull IResponseCallback<FullBoard> callback) {
        executor.submit(() -> {
            try {
                FullBoard b = dataBaseAdapter.getFullBoardByLocalIdDirectly(board.getAccountId(), board.getLocalId());
                b.getBoard().setArchived(false);
                updateBoard(b, new IResponseCallback<>() {
                    @Override
                    public void onResponse(FullBoard response, Headers headers) {
                        dataBaseAdapter.saveCurrentBoardId(b.getAccountId(), b.getLocalId());
                        callback.onResponse(response, headers);
                    }
                    @SuppressLint("MissingSuperCall")
                    @Override
                    public void onError(Throwable throwable) {
                        callback.onError(throwable);
                    }
                });
            } catch (Throwable e) {
                callback.onError(e);
            }
        });
    }
    @AnyThread
    public void updateCard(@NonNull FullCard card, @NonNull IResponseCallback<FullCard> callback) {
        executor.submit(() -> {
            final FullCard fullCardFromDB = dataBaseAdapter.getFullCardByLocalIdDirectly(card.getAccountId(), card.getLocalId());
            if (fullCardFromDB == null) {
                throw new IllegalArgumentException("card to update does not exist.");
            }
            dataBaseAdapter.filterRelationsForCard(fullCardFromDB);
            List<User> deletedUsers = AbstractSyncDataProvider.findDelta(card.getAssignedUsers(), fullCardFromDB.getAssignedUsers());
            List<User> addedUsers = AbstractSyncDataProvider.findDelta(fullCardFromDB.getAssignedUsers(), card.getAssignedUsers());
            for (User addedUser : addedUsers) {
                dataBaseAdapter.createJoinCardWithUser(addedUser.getLocalId(), card.getLocalId(), DBStatus.LOCAL_EDITED);
            }
            for (User deletedUser : deletedUsers) {
                dataBaseAdapter.deleteJoinedUserForCard(card.getLocalId(), deletedUser.getLocalId());
            }
            List<Label> deletedLabels = AbstractSyncDataProvider.findDelta(card.getLabels(), fullCardFromDB.getLabels());
            List<Label> addedLabels = AbstractSyncDataProvider.findDelta(fullCardFromDB.getLabels(), card.getLabels());
            for (Label addedLabel : addedLabels) {
                dataBaseAdapter.createJoinCardWithLabel(addedLabel.getLocalId(), card.getLocalId(), DBStatus.LOCAL_EDITED);
            }
            for (Label deletedLabel : deletedLabels) {
                dataBaseAdapter.deleteJoinedLabelForCard(card.getLocalId(), deletedLabel.getLocalId());
            }
            FullStack stack = dataBaseAdapter.getFullStackByLocalIdDirectly(card.getCard().getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getStack().getBoardId());
            fullCardFromDB.setCard(card.getCard());
            card.getCard().setStatus(DBStatus.LOCAL_EDITED.getId());
            dataBaseAdapter.updateCard(card.getCard(), false);
            if (connectivityUtil.hasInternetConnection()) {
                Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
                syncHelperFactory.create(serverAdapter, dataBaseAdapter, null)
                        .setResponseCallback(new ResponseCallback<>(account) {
                            @Override
                            public void onResponse(Boolean response, Headers headers) {
                                callback.onResponse(dataBaseAdapter.getFullCardByLocalIdDirectly(card.getAccountId(), card.getLocalId()), headers);
                            }
                            @SuppressLint("MissingSuperCall")
                            @Override
                            public void onError(Throwable throwable) {
                                callback.onError(throwable);
                            }
                        }).doUpSyncFor(new CardPropagationDataProvider(null, board, stack));
            } else {
                callback.onResponse(card, IResponseCallback.EMPTY_HEADERS);
            }
        });
    }
    /**
     * Moves the given {@param originCardLocalId} to the new target coordinates specified by {@param targetAccountId}, {@param targetBoardLocalId} and {@param targetStackLocalId}.
     * If the {@param targetBoardLocalId} changes, this will apply some logic to make sure that we migrate as much data as possible without the risk of getting an illegal state.
     * Attachments are not copied or anything.
     * <p>
     * 1) {@link FullCard#labels}
     * <p>
     * a) If a {@link Label} with the same {@link Label#title} exists (case insensitive) in the target, assign this {@link Label} instead of the origin
     * b) If no similar {@link Label} exists:
     * i) If user has {@link AccessControl#permissionManage}, create a new {@link Label} with this {@link Label#color} and {@link Label#title} and assign it
     * ii) Else remove this {@link Label} from the {@link Card}
     * <p>
     * 2) {@link FullCard#assignedUsers}
     * <p>
     * a) If the {@link User} has at least view permission at the target {@link Board}, keep it (<strong>can</strong> be the case if the target {@link Account} is the same as the origin {@link Account} <strong>or</strong> the target {@link Account} is on the same Nextcloud instance as the origin {@link Account}
     * b) Else {@link #unassignUserFromCard(User, Card)} (will always be the case if the target {@link Account} is on another Nextcloud isntance as the origin {@link Account})
     * <p>
     * <p>
     * https://github.com/stefan-niedermann/nextcloud-deck/issues/453
     */
    @SuppressWarnings("JavadocReference")
    @AnyThread
    public void moveCard(long originAccountId, long originCardLocalId, long targetAccountId, long targetBoardLocalId, long targetStackLocalId, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            final FullCard originalCard = dataBaseAdapter.getFullCardByLocalIdDirectly(originAccountId, originCardLocalId);
            final int newIndex = dataBaseAdapter.getHighestCardOrderInStack(targetStackLocalId) + 1;
            final FullBoard originalBoard = dataBaseAdapter.getFullBoardByLocalCardIdDirectly(originCardLocalId);
            // ### maybe shortcut possible? (just moved to another stack)
            if (targetBoardLocalId == originalBoard.getLocalId()) {
                reorder(originAccountId, originalCard, targetStackLocalId, newIndex);
                callback.onResponse(null, IResponseCallback.EMPTY_HEADERS);
                return;
            }
            // ### get rid of original card where it is now.
            final Card originalInnerCard = originalCard.getCard();
            deleteCard(new Card(originalInnerCard), IResponseCallback.empty());
            // ### clone card itself
            // TODO Why not use copy constructor? Attention, something might missing, e. g. accountId
            originalInnerCard.setAccountId(targetAccountId);
            originalInnerCard.setId(null);
            originalInnerCard.setLocalId(null);
            originalInnerCard.setStatusEnum(DBStatus.LOCAL_EDITED);
            originalInnerCard.setStackId(targetStackLocalId);
            originalInnerCard.setOrder(newIndex);
            originalInnerCard.setArchived(false);
            originalInnerCard.setAttachmentCount(0);
            originalInnerCard.setCommentsUnread(0);
            final FullCard fullCardForServerPropagation = new FullCard();
            fullCardForServerPropagation.setCard(originalInnerCard);
            final Account targetAccount = dataBaseAdapter.getAccountByIdDirectly(targetAccountId);
            final FullBoard targetBoard = dataBaseAdapter.getFullBoardByLocalIdDirectly(targetAccountId, targetBoardLocalId);
            final FullStack targetFullStack = dataBaseAdapter.getFullStackByLocalIdDirectly(targetStackLocalId);
            final User userOfTargetAccount = dataBaseAdapter.getUserByUidDirectly(targetAccountId, targetAccount.getUserName());
            final CountDownLatch latch = new CountDownLatch(1);
            ServerAdapter serverToUse = serverAdapter;
            if (originAccountId != targetAccountId) {
                try {
                    serverToUse = new ServerAdapter(context, AccountImporter.getSingleSignOnAccount(context, targetAccount.getName()), connectivityUtil);
                } catch (NextcloudFilesAppAccountNotFoundException e) {
                    callback.onError(e);
                    throw new RuntimeException(e);
                }
            }
            new DataPropagationHelper(serverToUse, dataBaseAdapter, executor).createEntity(new CardPropagationDataProvider(null, targetBoard.getBoard(), targetFullStack), fullCardForServerPropagation, new ResponseCallback<>(targetAccount) {
                @Override
                public void onResponse(FullCard response, Headers headers) {
                    originalInnerCard.setId(response.getId());
                    originalInnerCard.setLocalId(response.getLocalId());
                    latch.countDown();
                }
                @Override
                @SuppressLint("MissingSuperCall")
                public void onError(Throwable throwable) {
                    callback.onError(new RuntimeException("unable to create card in moveCard target", throwable));
                }
            }, (FullCard entity, FullCard response) -> {
                response.getCard().setUserId(userOfTargetAccount.getLocalId());
                response.getCard().setStackId(targetFullStack.getLocalId());
                entity.getCard().setUserId(userOfTargetAccount.getLocalId());
                entity.getCard().setStackId(targetFullStack.getLocalId());
            });
            try {
                latch.await();
            } catch (InterruptedException e) {
                callback.onError(new RuntimeException("error fulfilling countDownLatch", e));
            }
            final long newCardId = originalInnerCard.getLocalId();
            // ### clone labels, assign them
            // prepare
            // has user of targetaccount manage permissions?
            boolean hasManagePermission = targetBoard.getBoard().getOwnerId() == userOfTargetAccount.getLocalId();
            List<AccessControl> aclOfTargetBoard = dataBaseAdapter.getAccessControlByLocalBoardIdDirectly(targetAccountId, targetBoard.getLocalId());
            if (!hasManagePermission) {
                for (AccessControl accessControl : aclOfTargetBoard) {
                    if (accessControl.getUserId().equals(userOfTargetAccount.getLocalId()) && accessControl.isPermissionManage()) {
                        hasManagePermission = true;
                        break;
                    }
                }
            }
            // actual doing
            for (Label originalLabel : originalCard.getLabels()) {
                // already exists?
                Label existingMatch = null;
                for (Label targetBoardLabel : targetBoard.getLabels()) {
                    if (originalLabel.getTitle().trim().equalsIgnoreCase(targetBoardLabel.getTitle().trim())) {
                        existingMatch = targetBoardLabel;
                        break;
                    }
                }
                if (existingMatch == null) {
                    if (hasManagePermission) {
                        originalLabel.setBoardId(targetBoardLocalId);
                        originalLabel.setId(null);
                        originalLabel.setLocalId(null);
                        originalLabel.setStatusEnum(DBStatus.LOCAL_EDITED);
                        originalLabel.setAccountId(targetBoard.getAccountId());
                        createAndAssignLabelToCard(targetBoard.getAccountId(), originalLabel, newCardId, serverToUse);
                    }
                } else {
                    assignLabelToCard(existingMatch, originalInnerCard, serverToUse);
                }
            }
            // ### Clone assigned users
            final Account originalAccount = dataBaseAdapter.getAccountByIdDirectly(originAccountId);
            // same instance? otherwise doesn't make sense
            if (originalAccount.getUrl().equalsIgnoreCase(targetAccount.getUrl())) {
                for (User assignedUser : originalCard.getAssignedUsers()) {
                    // has assignedUser at least view permissions?
                    boolean hasViewPermission = targetBoard.getBoard().getOwnerId() == assignedUser.getLocalId();
                    if (!hasViewPermission) {
                        for (AccessControl accessControl : aclOfTargetBoard) {
                            if (accessControl.getUserId().equals(userOfTargetAccount.getLocalId())) {
                                // ACL exists, so viewing is granted
                                hasViewPermission = true;
                                break;
                            }
                        }
                    }
                    if (hasViewPermission) {
                        assignUserToCard(assignedUser, originalInnerCard);
                    }
                }
            }
            callback.onResponse(null, IResponseCallback.EMPTY_HEADERS);
        });
    }
    @AnyThread
    public void createLabel(long accountId, Label label, long localBoardId, @NonNull IResponseCallback<Label> callback) {
        executor.submit(() -> {
            Label existing = dataBaseAdapter.getLabelByBoardIdAndTitleDirectly(label.getBoardId(), label.getTitle());
            if (existing != null) {
                callback.onError(new SQLiteConstraintException("label \"" + label.getTitle() + "\" already exists for this board!"));
                return;
            }
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(localBoardId);
            label.setAccountId(accountId);
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).createEntity(new LabelDataProvider(null, board, null), label, ResponseCallback.from(account, callback), (entity, response) -> response.setBoardId(board.getLocalId()));
        });
    }
    @AnyThread
    private MutableLiveData<Label> createAndAssignLabelToCard(long accountId, @NonNull Label label, long localCardId, ServerAdapter serverAdapterToUse) {
        MutableLiveData<Label> liveData = new MutableLiveData<>();
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(accountId);
            Board board = dataBaseAdapter.getBoardByLocalCardIdDirectly(localCardId);
            label.setAccountId(accountId);
            new DataPropagationHelper(serverAdapterToUse, dataBaseAdapter, executor).createEntity(new LabelDataProvider(null, board, null), label, new ResponseCallback<>(account) {
                @Override
                public void onResponse(Label response, Headers headers) {
                    assignLabelToCard(response, dataBaseAdapter.getCardByLocalIdDirectly(accountId, localCardId));
                    liveData.postValue(response);
                }
                @Override
                public void onError(Throwable throwable) {
                    super.onError(throwable);
                    assignLabelToCard(label, dataBaseAdapter.getCardByLocalIdDirectly(accountId, localCardId));
                }
            }, (entity, response) -> response.setBoardId(board.getLocalId()));
        });
        return liveData;
    }
    @AnyThread
    public void deleteLabel(@NonNull Label label, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(label.getAccountId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(label.getBoardId());
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor)
                    .deleteEntity(new LabelDataProvider(null, board, Collections.emptyList()), label, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void updateLabel(@NonNull Label label, @NonNull IResponseCallback<Label> callback) {
        executor.submit(() -> {
            Account account = dataBaseAdapter.getAccountByIdDirectly(label.getAccountId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(label.getBoardId());
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor)
                    .updateEntity(new LabelDataProvider(null, board, Collections.emptyList()), label, ResponseCallback.from(account, callback));
        });
    }
    @AnyThread
    public void assignUserToCard(@NonNull User user, @NonNull Card card) {
        executor.submit(() -> {
            final long localUserId = user.getLocalId();
            final long localCardId = card.getLocalId();
            JoinCardWithUser joinCardWithUser = dataBaseAdapter.getJoinCardWithUser(localUserId, localCardId);
            if (joinCardWithUser != null && joinCardWithUser.getStatus() != DBStatus.LOCAL_DELETED.getId()) {
                return;
            }
            dataBaseAdapter.createJoinCardWithUser(localUserId, localCardId, DBStatus.LOCAL_EDITED);
            Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(card.getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getBoardId());
            Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
            if (connectivityUtil.hasInternetConnection()) {
                UserForAssignment userForAssignment = dataBaseAdapter.getUserForAssignmentDirectly(user.getLocalId());
                serverAdapter.assignUserToCard(board.getId(), stack.getId(), card.getId(), userForAssignment, new ResponseCallback<>(account) {
                    @Override
                    public void onResponse(EmptyResponse response, Headers headers) {
                        dataBaseAdapter.setStatusForJoinCardWithUser(localCardId, localUserId, DBStatus.UP_TO_DATE.getId());
                    }
                });
            }
        });
    }
    @AnyThread
    public void assignLabelToCard(@NonNull Label label, @NonNull Card card) {
        assignLabelToCard(label, card, serverAdapter);
    }
    @AnyThread
    public void assignLabelToCard(@NonNull Label label, @NonNull Card card, ServerAdapter serverAdapterToUse) {
        executor.submit(() -> {
            final long localLabelId = label.getLocalId();
            final long localCardId = card.getLocalId();
            dataBaseAdapter.createJoinCardWithLabel(localLabelId, localCardId, DBStatus.LOCAL_EDITED);
            if (label.getId() == null || card.getId() == null) {
                return;
            }
            Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(card.getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getBoardId());
            Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
            if (connectivityUtil.hasInternetConnection()) {
                serverAdapterToUse.assignLabelToCard(board.getId(), stack.getId(), card.getId(), label.getId(), new ResponseCallback<>(account) {
                    @Override
                    public void onResponse(EmptyResponse response, Headers headers) {
                        dataBaseAdapter.setStatusForJoinCardWithLabel(localCardId, localLabelId, DBStatus.UP_TO_DATE.getId());
                    }
                });
            }
        });
    }
    @AnyThread
    public void unassignLabelFromCard(@NonNull Label label, @NonNull Card card) {
        executor.submit(() -> {
            dataBaseAdapter.deleteJoinedLabelForCard(card.getLocalId(), label.getLocalId());
            Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(card.getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getBoardId());
            Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
            if (connectivityUtil.hasInternetConnection()) {
                serverAdapter.unassignLabelFromCard(board.getId(), stack.getId(), card.getId(), label.getId(), new ResponseCallback<>(account) {
                    @Override
                    public void onResponse(EmptyResponse response, Headers headers) {
                        dataBaseAdapter.deleteJoinedLabelForCardPhysically(card.getLocalId(), label.getLocalId());
                    }
                });
            }
        });
    }
    @AnyThread
    public void unassignUserFromCard(@NonNull User user, @NonNull Card card) {
        executor.submit(() -> {
            dataBaseAdapter.deleteJoinedUserForCard(card.getLocalId(), user.getLocalId());
            if (connectivityUtil.hasInternetConnection()) {
                Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(card.getStackId());
                Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getBoardId());
                Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
                UserForAssignment userForAssignment = dataBaseAdapter.getUserForAssignmentDirectly(user.getLocalId());
                serverAdapter.assignUserToCard(board.getId(), stack.getId(), card.getId(), userForAssignment, new ResponseCallback<>(account) {
                    @Override
                    public void onResponse(EmptyResponse response, Headers headers) {
                        dataBaseAdapter.deleteJoinedUserForCardPhysically(card.getLocalId(), user.getLocalId());
                    }
                });
            }
        });
    }
    public void triggerUserSearch(@NonNull Account account, @NonNull String constraint) {
        executor.submit(() -> serverAdapter.searchUser(constraint, new ResponseCallback<>(account) {
            @Override
            public void onResponse(OcsUserList response, Headers headers) {
                if (response == null || response.getUsers().isEmpty()) {
                    return;
                }
                for (var user : response.getUsers()) {
                    final var existingUser = dataBaseAdapter.getUserByUidDirectly(account.getId(), user.getId());
                    if (existingUser == null) {
                        User newUser = new User();
                        newUser.setStatus(DBStatus.UP_TO_DATE.getId());
                        newUser.setPrimaryKey(user.getId());
                        newUser.setUid(user.getId());
                        newUser.setType(User.TYPE_USER);
                        newUser.setDisplayname(user.getDisplayName());
                        dataBaseAdapter.createUser(account.getId(), newUser);
                    }
                }
                for (var group : response.getGroups()) {
                    final var existingGroup = dataBaseAdapter.getUserByUidDirectly(account.getId(), group.getId());
                    if (existingGroup == null) {
                        User newGroup = new User();
                        newGroup.setStatus(DBStatus.UP_TO_DATE.getId());
                        newGroup.setPrimaryKey(group.getId());
                        newGroup.setUid(group.getId());
                        newGroup.setType(User.TYPE_GROUP);
                        newGroup.setDisplayname(group.getDisplayName());
                        dataBaseAdapter.createUser(account.getId(), newGroup);
                    }
                }
            }
            @Override
            public void onError(Throwable throwable) {
                super.onError(throwable);
            }
        }));
    }
    /**
     * @see <a href="https://github.com/stefan-niedermann/nextcloud-deck/issues/360">reenable reorder</a>
     */
    @AnyThread
    public void reorder(long accountId, @NonNull FullCard movedCard, long newStackId, int newIndex) {
        executor.submit(() -> {
            // read cards of new stack
            List<FullCard> cardsOfNewStack = dataBaseAdapter.getFullCardsForStackDirectly(accountId, newStackId, null);
            int newOrder = newIndex;
            if (cardsOfNewStack.size() > newIndex) {
                newOrder = cardsOfNewStack.get(newIndex).getCard().getOrder();
            }
            boolean orderIsCorrect = true;
            if (newOrder == movedCard.getCard().getOrder() && newStackId == movedCard.getCard().getStackId()) {
                int lastOrder = Integer.MIN_VALUE;
                for (FullCard fullCard : cardsOfNewStack) {
                    int currentOrder = fullCard.getCard().getOrder();
                    if (currentOrder > lastOrder) {
                        lastOrder = currentOrder;
                    } else {
                        // the order is messed up. this could happen for a while,
                        // because the new cards by the app had all the same order: 0
                        orderIsCorrect = false;
                        break;
                    }
                }
                if (orderIsCorrect) {
                    return;
                } else {
                    // we need to fix the order.
                    cardsOfNewStack.remove(movedCard);
                    cardsOfNewStack.add(newIndex, movedCard);
                    for (int i = 0; i < cardsOfNewStack.size(); i++) {
                        Card card = cardsOfNewStack.get(i).getCard();
                        card.setOrder(i);
                        dataBaseAdapter.updateCard(card, true);
                    }
                }
            }
//            if (connectivityUtil.hasInternetConnection()){
//                // call reorder
//                Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(movedCard.getCard().getStackId());
//                Stack newStack = newStackId == stack.getLocalId() ? stack :  dataBaseAdapter.getStackByLocalIdDirectly(newStackId);
//                Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getBoardId());
//                Account account = dataBaseAdapter.getAccountByIdDirectly(movedCard.getCard().getAccountId());
//                movedCard.getCard().setStackId(newStackId);
//                movedCard.getCard().setOrder(newOrder);
//                movedCard.setStatusEnum(DBStatus.LOCAL_MOVED);
//                dataBaseAdapter.updateCard(movedCard.getCard(), false);
//                serverAdapter.reorder(board.getId(), stack.getId(), movedCard.getId(), newStack.getId(), newOrder+1, new IResponseCallback<List<FullCard>>(account){
//
//                    @Override
//                    public void onResponse(List<FullCard> response) {
//                        for (FullCard fullCard : response) {
//                            Card card = fullCard.getCard();
//                            card.setAccountId(accountId);
//                            card.setStackId(dataBaseAdapter.getLocalStackIdByRemoteStackIdDirectly(accountId, card.getStackId()));
//                            card.setStatusEnum(DBStatus.UP_TO_DATE);
//                            dataBaseAdapter.updateCard(card, false);
//                            DeckLog.log("move: stackid "+card.getStackId());
//                        }
//                        movedCard.setStatusEnum(DBStatus.UP_TO_DATE);
//                        dataBaseAdapter.updateCard(movedCard.getCard(), false);
//                    }
//                });
//            } else {
            if (orderIsCorrect) {
                reorderLocally(cardsOfNewStack, movedCard, newStackId, newOrder);
            }
            //FIXME: remove the sync-block, when commentblock up there is activated. (waiting for deck server bugfix)
            if (connectivityUtil.hasInternetConnection()) {
                Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(movedCard.getCard().getStackId());
                FullBoard board = dataBaseAdapter.getFullBoardByLocalIdDirectly(accountId, stack.getBoardId());
                Account account = dataBaseAdapter.getAccountByIdDirectly(movedCard.getCard().getAccountId());
                syncHelperFactory.create(serverAdapter, dataBaseAdapter, Instant.now()).setResponseCallback(new ResponseCallback<>(account) {
                    @Override
                    public void onResponse(Boolean response, Headers headers) {
                        // doNothing();
                    }
                }).doUpSyncFor(new StackDataProvider(null, board));
            }
//        }
        });
    }
    /**
     * FIXME clean up on error
     * When uploading the exact same attachment 2 times to the same card, the server starts burning and gets mad and returns status 500
     * The problem is, that the attachment is still in our local database and everytime one tries to sync, the log is spammed with 500 errors
     * Also this leads to the attachment being present in the card forever with a DBStatus.LOCAL_EDITED
     */
    @AnyThread
    public void addAttachmentToCard(long accountId, long localCardId, @NonNull String mimeType, @NonNull File file, @NonNull IResponseCallback<Attachment> callback) {
        executor.submit(() -> {
            Attachment attachment = populateAttachmentEntityForFile(new Attachment(), localCardId, mimeType, file);
            final Instant now = Instant.now();
            attachment.setLastModifiedLocal(now);
            attachment.setCreatedAt(now);
            FullCard card = dataBaseAdapter.getFullCardByLocalIdDirectly(accountId, localCardId);
            Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(card.getCard().getStackId());
            Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getBoardId());
            Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
            new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor).createEntity(
                    new AttachmentDataProvider(null, board, stack, card, Collections.singletonList(attachment)),
                    attachment, ResponseCallback.from(account, callback)
            );
        });
    }
    @AnyThread
    public LiveData<Attachment> updateAttachmentForCard(long accountId, @NonNull Attachment existing, @NonNull String mimeType, @NonNull File file) {
        final var liveData = new MutableLiveData<Attachment>();
        executor.submit(() -> {
            Attachment attachment = populateAttachmentEntityForFile(existing, existing.getCardId(), mimeType, file);
            attachment.setLastModifiedLocal(Instant.now());
            if (connectivityUtil.hasInternetConnection()) {
                FullCard card = dataBaseAdapter.getFullCardByLocalIdDirectly(accountId, existing.getCardId());
                Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(card.getCard().getStackId());
                Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getBoardId());
                Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
                new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor)
                        .updateEntity(new AttachmentDataProvider(null, board, stack, card, Collections.singletonList(attachment)), attachment, new ResponseCallback<>(account) {
                            @Override
                            public void onResponse(Attachment response, Headers headers) {
                                liveData.postValue(response);
                            }
                            @SuppressLint("MissingSuperCall")
                            @Override
                            public void onError(Throwable throwable) {
                                DeckLog.error(throwable);
//                                liveData.postError(throwable);
                            }
                        });
            }
        });
        return liveData;
    }
    @AnyThread
    private static Attachment populateAttachmentEntityForFile(@NonNull Attachment target, long localCardId, @NonNull String mimeType, @NonNull File file) {
        target.setCardId(localCardId);
        target.setMimetype(mimeType);
        target.setData(file.getName());
        target.setFilename(file.getName());
        target.setBasename(file.getName());
        target.setLocalPath(file.getAbsolutePath());
        target.setFilesize(file.length());
        return target;
    }
    @AnyThread
    public void deleteAttachmentOfCard(long accountId, long localCardId, long localAttachmentId, @NonNull IResponseCallback<EmptyResponse> callback) {
        executor.submit(() -> {
            if (connectivityUtil.hasInternetConnection()) {
                FullCard card = dataBaseAdapter.getFullCardByLocalIdDirectly(accountId, localCardId);
                Stack stack = dataBaseAdapter.getStackByLocalIdDirectly(card.getCard().getStackId());
                Board board = dataBaseAdapter.getBoardByLocalIdDirectly(stack.getBoardId());
                Attachment attachment = dataBaseAdapter.getAttachmentByLocalIdDirectly(accountId, localAttachmentId);
                Account account = dataBaseAdapter.getAccountByIdDirectly(card.getAccountId());
                new DataPropagationHelper(serverAdapter, dataBaseAdapter, executor)
                        .deleteEntity(new AttachmentDataProvider(null, board, stack, card, Collections.singletonList(attachment)), attachment, ResponseCallback.from(account, callback));
            }
        });
    }
    /**
     * FIXME <a href="https://github.com/stefan-niedermann/nextcloud-deck/issues/640">GitHub Issue #640</a>
     */
    public static boolean isNoOnVoidError(Throwable t) {
        return !(t instanceof NullPointerException) || !"Attempt to invoke interface method 'void io.reactivex.disposables.Disposable.dispose()' on a null object reference".equals(t.getMessage());
    }
}
package it.niedermann.nextcloud.deck.ui.card;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.text.InputFilter;
import android.view.Menu;
import android.view.MenuItem;
import androidx.annotation.ColorInt;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.content.ContextCompat;
import androidx.core.graphics.drawable.DrawableCompat;
import androidx.lifecycle.ViewModelProvider;
import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import com.google.android.material.tabs.TabLayout;
import com.google.android.material.tabs.TabLayoutMediator;
import com.nextcloud.android.sso.exceptions.NextcloudFilesAppAccountNotFoundException;
import it.niedermann.android.reactivelivedata.ReactiveLiveData;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.R;
import it.niedermann.nextcloud.deck.databinding.ActivityEditBinding;
import it.niedermann.nextcloud.deck.model.Account;
import it.niedermann.nextcloud.deck.model.full.FullCard;
import it.niedermann.nextcloud.deck.model.ocs.Version;
import it.niedermann.nextcloud.deck.ui.exception.ExceptionHandler;
import it.niedermann.nextcloud.deck.ui.main.MainActivity;
import it.niedermann.nextcloud.deck.ui.theme.ThemeUtils;
import it.niedermann.nextcloud.deck.util.CardUtil;
import it.niedermann.nextcloud.deck.util.OnTextChangedWatcher;
public class EditActivity extends AppCompatActivity {
    private static final String BUNDLE_KEY_ACCOUNT = "account";
    private static final String BUNDLE_KEY_BOARD_LOCAL_ID = "boardLocalId";
    private static final String BUNDLE_KEY_CARD_LOCAL_ID = "cardLocalId";
    private ActivityEditBinding binding;
    private EditCardViewModel viewModel;
    /**
     * @deprecated This is only here to maintain compatibility with {@link Version#supportsComments()}
     */
    @Deprecated
    private static final int[] tabTitles = new int[]{
            R.string.card_edit_details,
            R.string.card_edit_attachments,
            R.string.card_edit_activity
    };
    private static final int[] tabTitlesWithComments = new int[]{
            R.string.card_edit_details,
            R.string.card_edit_attachments,
            R.string.card_edit_comments,
            R.string.card_edit_activity
    };
    /**
     * @deprecated This is only here to maintain compatibility with {@link Version#supportsComments()}
     */
    @Deprecated
    private static final int[] tabIcons = new int[]{
            R.drawable.ic_home_24dp,
            R.drawable.ic_attach_file_24dp,
            R.drawable.ic_activity_72dp
    };
    private static final int[] tabIconsWithComments = new int[]{
            R.drawable.ic_home_24dp,
            R.drawable.ic_attach_file_24dp,
            R.drawable.type_comment_36dp,
            R.drawable.ic_activity_72dp
    };
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Thread.currentThread().setUncaughtExceptionHandler(new ExceptionHandler(this));
        binding = ActivityEditBinding.inflate(getLayoutInflater());
        viewModel = new ViewModelProvider(this).get(EditCardViewModel.class);
        setContentView(binding.getRoot());
        setSupportActionBar(binding.toolbar);
        viewModel.getBoardColor().observe(this, this::applyTheme);
        loadDataFromIntent();
    }
    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        viewModel.setBoardColor(ContextCompat.getColor(this, R.color.primary));
        setIntent(intent);
        loadDataFromIntent();
    }
    @Override
    protected void onDestroy() {
        super.onDestroy();
        this.binding = null;
    }
    private void loadDataFromIntent() {
        final var args = getIntent().getExtras();
        if (args == null || !args.containsKey(BUNDLE_KEY_ACCOUNT) || !args.containsKey(BUNDLE_KEY_BOARD_LOCAL_ID) || !args.containsKey(BUNDLE_KEY_CARD_LOCAL_ID)) {
            throw new IllegalArgumentException("Provide at least " + BUNDLE_KEY_ACCOUNT + " and " + BUNDLE_KEY_BOARD_LOCAL_ID + " and " + BUNDLE_KEY_CARD_LOCAL_ID + " of the card that should be edited.");
        }
        final var account = (Account) args.getSerializable(BUNDLE_KEY_ACCOUNT);
        if (account == null) {
            throw new IllegalArgumentException(BUNDLE_KEY_ACCOUNT + " must not be null.");
        }
        try {
            viewModel.setAccount(account);
        } catch (NextcloudFilesAppAccountNotFoundException e) {
            throw new RuntimeException(e);
        }
        final long cardLocalId = args.getLong(BUNDLE_KEY_CARD_LOCAL_ID);
        if (cardLocalId <= 0L) {
            throw new IllegalArgumentException(BUNDLE_KEY_CARD_LOCAL_ID + " must be a positive long but was " + cardLocalId);
        }
        final long boardLocalId = args.getLong(BUNDLE_KEY_BOARD_LOCAL_ID);
        if (boardLocalId <= 0L) {
            throw new IllegalArgumentException(BUNDLE_KEY_BOARD_LOCAL_ID + " must be a positive integer but was " + boardLocalId);
        }
        new ReactiveLiveData<>(viewModel.getFullBoardById(account.getId(), boardLocalId))
                .observeOnce(EditActivity.this, fullBoard -> {
                    viewModel.setBoardColor(fullBoard.getBoard().getColor());
                    viewModel.setCanEdit(fullBoard.getBoard().isPermissionEdit());
                    invalidateOptionsMenu();
                    new ReactiveLiveData<>(viewModel.getFullCardWithProjectsByLocalId(account.getId(), cardLocalId))
                            .observeOnce(EditActivity.this, fullCard -> {
                                if (fullCard == null) {
                                    new MaterialAlertDialogBuilder(this)
                                            .setTitle(R.string.card_not_found)
                                            .setMessage(R.string.card_not_found_message)
                                            .setPositiveButton(R.string.simple_close, (a, b) -> super.finish())
                                            .show();
                                } else {
                                    viewModel.initializeExistingCard(boardLocalId, fullCard, account.getServerDeckVersionAsObject().isSupported());
                                    invalidateOptionsMenu();
                                    setupViewPager(account);
                                    setupTitle();
                                }
                            });
                });
        DeckLog.verbose("Finished loading intent data: { accountId =", viewModel.getAccount().getId(), "cardId =", cardLocalId, "}");
    }
    @Override
    public boolean onCreateOptionsMenu(@NonNull Menu menu) {
        if (viewModel.canEdit()) {
            getMenuInflater().inflate(R.menu.card_edit_menu, menu);
            @ColorInt final int color = ContextCompat.getColor(this, R.color.onSurface);
            final var utils = ThemeUtils.of(color, this);
            for (int i = 0; i < menu.size(); i++) {
                utils.platform.colorToolbarMenuIcon(this, menu.getItem(i));
            }
        } else {
            menu.clear();
        }
        return super.onCreateOptionsMenu(menu);
    }
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == R.id.action_card_save) {
            saveAndFinish();
        }
        return super.onOptionsItemSelected(item);
    }
    @Override
    public boolean onSupportNavigateUp() {
        if (isTaskRoot()) {
            Intent intent = new Intent(EditActivity.this, MainActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
            startActivity(intent);
        } else {
            finish();
        }
        return true;
    }
    /**
     * Tries to save the current {@link FullCard} from the {@link EditCardViewModel} and then finishes this activity.
     */
    private void saveAndFinish() {
        if (!viewModel.isPendingSaveOperation()) {
            viewModel.setPendingSaveOperation(true);
            final String title = viewModel.getFullCard().getCard().getTitle();
            if (title == null || title.trim().isEmpty()) {
                viewModel.getFullCard().getCard().setTitle(CardUtil.generateTitleFromDescription(viewModel.getFullCard().getCard().getDescription()));
            }
            viewModel.getFullCard().getCard().setTitle(viewModel.getFullCard().getCard().getTitle().trim());
            binding.title.setText(viewModel.getFullCard().getCard().getTitle());
            if (viewModel.getFullCard().getCard().getTitle().isEmpty()) {
                new MaterialAlertDialogBuilder(this)
                        .setTitle(R.string.title_is_mandatory)
                        .setMessage(R.string.provide_at_least_a_title_or_description)
                        .setPositiveButton(android.R.string.ok, null)
                        .setOnDismissListener(dialog -> viewModel.setPendingSaveOperation(false))
                        .show();
            } else {
                viewModel.saveCard((response, headers) -> DeckLog.info("Successfully saved card", response.getCard().getTitle()));
                super.finish();
            }
        }
    }
    private void setupViewPager(@NonNull Account account) {
        binding.tabLayout.removeAllTabs();
        binding.tabLayout.setTabGravity(TabLayout.GRAVITY_FILL);
        final var adapter = new CardTabAdapter(this, account);
        final var mediator = new TabLayoutMediator(binding.tabLayout, binding.pager, (tab, position) -> {
            tab.setIcon(viewModel.hasCommentsAbility()
                    ? tabIconsWithComments[position]
                    : tabIcons[position]
            );
            tab.setContentDescription(viewModel.hasCommentsAbility()
                    ? tabTitlesWithComments[position]
                    : tabTitles[position]
            );
        });
        binding.pager.setAdapter(adapter);
        if (viewModel.hasCommentsAbility()) {
            adapter.enableComments();
            binding.pager.setOffscreenPageLimit(3);
        } else {
            binding.pager.setOffscreenPageLimit(2);
        }
        mediator.attach();
    }
    private void setupTitle() {
        binding.title.setText(viewModel.getFullCard().getCard().getTitle());
        binding.title.setFilters(new InputFilter[]{new InputFilter.LengthFilter(viewModel.getAccount().getServerDeckVersionAsObject().getCardTitleMaxLength())});
        if (viewModel.canEdit()) {
            binding.title.setHint(R.string.edit);
            binding.title.addTextChangedListener(new OnTextChangedWatcher(s -> viewModel.getFullCard().getCard().setTitle(binding.title.getText().toString())));
        } else {
            binding.title.setEnabled(false);
        }
    }
    @Override
    public void finish() {
        if (!viewModel.hasChanges() && viewModel.canEdit()) {
            new MaterialAlertDialogBuilder(this)
                    .setTitle(R.string.simple_save)
                    .setMessage(R.string.do_you_want_to_save_your_changes)
                    .setPositiveButton(R.string.simple_save, (dialog, whichButton) -> saveAndFinish())
                    .setNegativeButton(R.string.simple_discard, (dialog, whichButton) -> super.finish()).show();
        } else {
            super.finish();
        }
    }
    /**
     * Performs a call of {@link AppCompatActivity#finish()} without checking for changes
     */
    public void directFinish() {
        super.finish();
    }
    private void applyTheme(int color) {
        final var navigationIcon = binding.toolbar.getNavigationIcon();
        if (navigationIcon == null) {
            DeckLog.error("Expected navigationIcon to be present.");
        } else {
            DrawableCompat.setTint(binding.toolbar.getNavigationIcon(), ContextCompat.getColor(this, R.color.onSurface));
        }
        final var utils = ThemeUtils.of(color, this);
        utils.material.themeToolbar(binding.toolbar);
        utils.deck.themeStatusBar(this, binding.appBarLayout);
        utils.material.colorTextInputLayout(binding.titleWrapper);
        utils.material.themeTabLayoutOnSurface(binding.tabLayout);
    }
    @NonNull
    public static Intent createEditCardIntent(@NonNull Context context, @NonNull Account account, long boardLocalId, long cardLocalId) {
        return new Intent(context, EditActivity.class)
                .putExtra(BUNDLE_KEY_ACCOUNT, account)
                .putExtra(BUNDLE_KEY_BOARD_LOCAL_ID, boardLocalId)
                .putExtra(BUNDLE_KEY_CARD_LOCAL_ID, cardLocalId)
                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
    }
}
package it.niedermann.nextcloud.deck;
import android.content.Context;
import android.content.Intent;
import android.text.TextUtils;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.FileProvider;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import it.niedermann.nextcloud.deck.util.MimeTypeUtil;
public class DeckLog {
    private DeckLog() {
        throw new UnsupportedOperationException("This class must not get instantiated");
    }
    private static final StringBuffer DEBUG_LOG = new StringBuffer();
    private static boolean PERSIST_LOGS = false;
    private static final String TAG = DeckLog.class.getSimpleName();
    private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    public static void enablePersistentLogs(boolean persistLogs) {
        PERSIST_LOGS = persistLogs;
        if (!persistLogs) {
            clearDebugLog();
        }
    }
    public static String getStacktraceAsString(Throwable e) {
        final var sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        return sw.toString();
    }
    public enum Severity {
        VERBOSE, DEBUG, LOG, INFO, WARN, ERROR, WTF
    }
    public static void verbose(Object... message) {
        log(Severity.VERBOSE, 4, message);
    }
    public static void log(Object... message) {
        log(Severity.DEBUG, 4, message);
    }
    public static void info(Object... message) {
        log(Severity.INFO, 4, message);
    }
    public static void warn(Object... message) {
        log(Severity.WARN, 4, message);
    }
    public static void error(Object... message) {
        log(Severity.ERROR, 4, message);
    }
    public static void wtf(Object... message) {
        log(Severity.WTF, 4, message);
    }
    public static void log(@NonNull Severity severity, Object... message) {
        log(severity, 3, message);
    }
    private static void log(@NonNull Severity severity, int stackTracePosition, Object... messages) {
        if (!(PERSIST_LOGS || BuildConfig.DEBUG)) {
            return;
        }
        final StackTraceElement caller = Thread.currentThread().getStackTrace()[stackTracePosition];
        final String print = "(" + caller.getFileName() + ":" + caller.getLineNumber() + ") " + caller.getMethodName() + "() → " + TextUtils.join(" ", messages);
        if (PERSIST_LOGS) {
            DEBUG_LOG
                    .append(dtf.format(Instant.now().atZone(ZoneId.systemDefault())))
                    .append(" ")
                    .append(severity.name())
                    .append(" ")
                    .append(print)
                    .append("\n");
        }
        switch (severity) {
            case DEBUG -> Log.d(TAG, print);
            case INFO -> Log.i(TAG, print);
            case WARN -> Log.w(TAG, print);
            case ERROR -> Log.e(TAG, print);
            case WTF -> Log.wtf(TAG, print);
            default -> Log.v(TAG, print);
        }
    }
    public static void logError(@Nullable Throwable e) {
        if (!(PERSIST_LOGS || BuildConfig.DEBUG)) {
            return;
        }
        if (e == null) {
            error("Could not log error because given error was null");
            return;
        }
        final StringWriter sw = new StringWriter();
        e.printStackTrace(new PrintWriter(sw));
        final String stacktrace = sw.toString();
        final StackTraceElement caller = Thread.currentThread().getStackTrace()[3];
        final String print = "(" + caller.getFileName() + ":" + caller.getLineNumber() + ") " + caller.getMethodName() + "() → " + stacktrace;
        if (PERSIST_LOGS) {
            DEBUG_LOG.append(print).append("\n");
        }
        Log.e(TAG, print);
    }
    @NonNull
    public static String getDebugLog() {
        return DEBUG_LOG.toString();
    }
    public static void clearDebugLog() {
        DEBUG_LOG.setLength(0);
    }
    /**
     * Writes the current log to a temporary file and starts a share intent.
     */
    public static void shareLogAsFile(@NonNull Context context) throws IOException {
        Toast.makeText(context, R.string.copying_logs_to_file, Toast.LENGTH_LONG).show();
        final File logFile = new File(context.getCacheDir().getAbsolutePath() + "/log.txt");
        final FileWriter writer = new FileWriter(logFile);
        writer.write(DeckLog.getDebugLog());
        writer.close();
        context.startActivity(new Intent(Intent.ACTION_SEND)
                .putExtra(Intent.EXTRA_TITLE, context.getString(R.string.log_file))
                .putExtra(Intent.EXTRA_STREAM, FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + ".provider", logFile))
                .setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                .setType(MimeTypeUtil.TEXT_PLAIN));
    }
}
package it.niedermann.nextcloud.deck.model.full;
import androidx.annotation.NonNull;
import androidx.room.Embedded;
import androidx.room.Ignore;
import androidx.room.Relation;
import java.util.List;
import java.util.Objects;
import it.niedermann.nextcloud.deck.model.AccessControl;
import it.niedermann.nextcloud.deck.model.Board;
import it.niedermann.nextcloud.deck.model.Label;
import it.niedermann.nextcloud.deck.model.Stack;
import it.niedermann.nextcloud.deck.model.User;
import it.niedermann.nextcloud.deck.model.interfaces.IRemoteEntity;
public class FullBoard implements IRemoteEntity {
    @Embedded
    public Board board;
    @Relation(entity = Label.class, parentColumn = "localId", entityColumn = "boardId")
    public List<Label> labels;
    @Relation(parentColumn = "ownerId", entityColumn = "localId")
    public User owner;
    @Relation(entity = AccessControl.class, parentColumn = "localId", entityColumn = "boardId")
    public List<AccessControl> participants;
    @Relation(entity = Stack.class, parentColumn = "localId", entityColumn = "boardId")
    public List<Stack> stacks;
    @Ignore
    public List<User> users;
    public User getOwner() {
        return owner;
    }
    public void setOwner(User owner) {
        this.owner = owner;
    }
    public Board getBoard() {
        return board;
    }
    public void setBoard(Board board) {
        this.board = board;
    }
    public List<Label> getLabels() {
        return labels;
    }
    public void setLabels(List<Label> labels) {
        this.labels = labels;
    }
    public List<User> getUsers() {
        return users;
    }
    public void setUsers(List<User> users) {
        this.users = users;
    }
    @Ignore
    @Override
    public Board getEntity() {
        return board;
    }
    public List<AccessControl> getParticipants() {
        return participants;
    }
    public void setParticipants(List<AccessControl> participants) {
        this.participants = participants;
    }
    public List<Stack> getStacks() {
        return stacks;
    }
    public void setStacks(List<Stack> stacks) {
        this.stacks = stacks;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FullBoard fullBoard = (FullBoard) o;
        if (!Objects.equals(board, fullBoard.board)) return false;
        if (!Objects.equals(labels, fullBoard.labels))
            return false;
        if (!Objects.equals(owner, fullBoard.owner)) return false;
        if (!Objects.equals(participants, fullBoard.participants))
            return false;
        return Objects.equals(stacks, fullBoard.stacks);
    }
    @Override
    public int hashCode() {
        int result = board != null ? board.hashCode() : 0;
        result = 31 * result + (labels != null ? labels.hashCode() : 0);
        result = 31 * result + (owner != null ? owner.hashCode() : 0);
        result = 31 * result + (participants != null ? participants.hashCode() : 0);
        result = 31 * result + (stacks != null ? stacks.hashCode() : 0);
        return result;
    }
    @NonNull
    @Override
    public String toString() {
        return "FullBoard{" +
                "board=" + board +
                ", labels=" + labels +
                ", owner=" + owner +
                ", participants=" + participants +
                ", stacks=" + stacks +
                '}';
    }
}
package it.niedermann.nextcloud.deck.ui.card.attachments;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_COLLAPSED;
import static com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_HIDDEN;
import static java.net.HttpURLConnection.HTTP_CONFLICT;
import static it.niedermann.nextcloud.deck.ui.card.attachments.CardAttachmentAdapter.VIEW_TYPE_IMAGE;
import static it.niedermann.nextcloud.deck.util.FilesUtil.copyContentUriToTempFile;
import android.Manifest;
import android.content.ActivityNotFoundException;
import android.content.ContentResolver;
import android.content.Intent;
import android.graphics.Bitmap;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;
import android.widget.Toast;
import androidx.activity.OnBackPressedCallback;
import androidx.activity.result.PickVisualMediaRequest;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.annotation.ColorInt;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.SharedElementCallback;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import androidx.preference.PreferenceManager;
import androidx.recyclerview.widget.GridLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import com.google.android.material.bottomsheet.BottomSheetBehavior;
import com.google.android.material.snackbar.Snackbar;
import com.nextcloud.android.common.ui.theme.utils.ColorRole;
import com.nextcloud.android.sso.api.EmptyResponse;
import com.nextcloud.android.sso.exceptions.NextcloudHttpRequestFailedException;
import java.io.File;
import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Consumer;
import id.zelory.compressor.constraint.FormatConstraint;
import id.zelory.compressor.constraint.QualityConstraint;
import id.zelory.compressor.constraint.ResolutionConstraint;
import id.zelory.compressor.constraint.SizeConstraint;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.R;
import it.niedermann.nextcloud.deck.databinding.FragmentCardEditTabAttachmentsBinding;
import it.niedermann.nextcloud.deck.exceptions.UploadAttachmentFailedException;
import it.niedermann.nextcloud.deck.model.Attachment;
import it.niedermann.nextcloud.deck.model.Card;
import it.niedermann.nextcloud.deck.model.enums.DBStatus;
import it.niedermann.nextcloud.deck.remote.api.IResponseCallback;
import it.niedermann.nextcloud.deck.repository.SyncRepository;
import it.niedermann.nextcloud.deck.ui.card.EditCardViewModel;
import it.niedermann.nextcloud.deck.ui.card.attachments.picker.AttachmentPicker;
import it.niedermann.nextcloud.deck.ui.card.attachments.picker.AttachmentPickerAdapter;
import it.niedermann.nextcloud.deck.ui.card.attachments.previewdialog.PreviewDialogViewModel;
import it.niedermann.nextcloud.deck.ui.exception.ExceptionDialogFragment;
import it.niedermann.nextcloud.deck.ui.takephoto.TakePhotoActivity;
import it.niedermann.nextcloud.deck.ui.theme.ThemeUtils;
import it.niedermann.nextcloud.deck.ui.theme.ThemedSnackbar;
import it.niedermann.nextcloud.deck.util.JavaCompressor;
import it.niedermann.nextcloud.deck.util.MimeTypeUtil;
import it.niedermann.nextcloud.deck.util.VCardUtil;
import okhttp3.Headers;
public class CardAttachmentsFragment extends Fragment implements AttachmentDeletedListener, AttachmentInteractionListener, Consumer<CompletableFuture<List<Uri>>> {
    private FragmentCardEditTabAttachmentsBinding binding;
    private EditCardViewModel editViewModel;
    private PreviewDialogViewModel previewViewModel;
    private BottomSheetBehavior<LinearLayout> mBottomSheetBehaviour;
    private boolean compressImagesOnUpload = true;
    private final ExecutorService executor = Executors.newCachedThreadPool();
    private final List<AttachmentPicker<?, ?>> pickers = new ArrayList<>();
    private CardAttachmentAdapter adapter;
    private AttachmentPickerAdapter attachmentPickerAdapter;
    private final OnBackPressedCallback backPressedCallback = new OnBackPressedCallback(true) {
        @Override
        public void handleOnBackPressed() {
            mBottomSheetBehaviour.setState(STATE_HIDDEN);
        }
    };
    private int clickedItemPosition;
    @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final var registry = requireActivity().getActivityResultRegistry();
        final var cr = requireContext().getContentResolver();
        pickers.addAll(List.of(
                new AttachmentPicker.MultiBuilder<>(registry, R.string.files, R.drawable.type_file_36dp,
                        new ActivityResultContracts.GetMultipleContents())
                        .setPermissions(Manifest.permission.READ_EXTERNAL_STORAGE)
                        .setInput("*/*")
                        .build(),
                new AttachmentPicker.SingleBuilder<>(registry, R.string.camera, R.drawable.ic_photo_camera_24,
                        new TakePhotoActivity.TakePhoto())
                        .setPermissions(Manifest.permission.CAMERA)
                        .build(),
                new AttachmentPicker.MultiBuilder<>(registry, R.string.gallery, R.drawable.ic_image_24dp,
                        new ActivityResultContracts.PickMultipleVisualMedia())
                        .setResultMapper((Consumer<List<Uri>>) uris -> uris.forEach(uri -> cr.takePersistableUriPermission(uri, Intent.FLAG_GRANT_READ_URI_PERMISSION)))
                        .setInput(new PickVisualMediaRequest.Builder()
                                .setMediaType(ActivityResultContracts.PickVisualMedia.ImageOnly.INSTANCE)
                                .build())
                        .build(),
//                new AttachmentPicker.SingleBuilder<>(registry, R.string.voice_recorder, R.drawable.ic_music_note_24dp,
//                        new VoiceRecorder())
//                        .setResultMapper((Function<Uri, Uri>) uri -> {
//                            String[] proj = {MediaStore.Audio.Media.DATA};
//                            //Cursor cursor = managedQuery(contentUri, proj, null, null, null);
//                            Cursor cursor = requireContext().getContentResolver().query(uri, proj, null, null, null); //Since manageQuery is deprecated
//                            int column_index = cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DATA);
//                            cursor.moveToFirst();
//                            final var newUri = cursor.getString(column_index);
//                            return Uri.parse(newUri);
//                        })
//                        .setPermissions(Manifest.permission.READ_EXTERNAL_STORAGE)
//                        .build(),
                new AttachmentPicker.MultiBuilder<>(registry, R.string.videos, R.drawable.ic_local_movies_24dp,
                        new ActivityResultContracts.PickMultipleVisualMedia())
                        .setInput(new PickVisualMediaRequest.Builder()
                                .setMediaType(ActivityResultContracts.PickVisualMedia.VideoOnly.INSTANCE)
                                .build())
                        .build(),
                new AttachmentPicker.SingleBuilder<>(registry, R.string.contacts, R.drawable.ic_person_24dp,
                        new ActivityResultContracts.PickContact())
                        .setPermissions(Manifest.permission.READ_CONTACTS)
                        .setResultMapper(uri -> uri == null ? null : VCardUtil.getVCardContentUri(requireContext(), uri))
                        .build()
        ));
        final var lifecycle = getLifecycle();
        pickers.forEach(lifecycle::addObserver);
    }
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        binding = FragmentCardEditTabAttachmentsBinding.inflate(inflater, container, false);
        editViewModel = new ViewModelProvider(requireActivity()).get(EditCardViewModel.class);
        previewViewModel = new ViewModelProvider(requireActivity()).get(PreviewDialogViewModel.class);
        // This might be a zombie fragment with an empty EditCardViewModel after Android killed the activity (but not the fragment instance
        // See https://github.com/stefan-niedermann/nextcloud-deck/issues/478
        if (editViewModel.getFullCard() == null) {
            DeckLog.logError(new IllegalStateException("Cannot populate " + CardAttachmentsFragment.class.getSimpleName() + " because viewModel.getFullCard() is null"));
            return binding.getRoot();
        }
        setupAttachments();
        setupPickers();
        if (editViewModel.canEdit()) {
            binding.fab.setOnClickListener(v -> {
                mBottomSheetBehaviour.setState(STATE_COLLAPSED);
                backPressedCallback.setEnabled(true);
                requireActivity().getOnBackPressedDispatcher().addCallback(getViewLifecycleOwner(), backPressedCallback);
            });
            binding.fab.show();
            binding.attachmentsList.addOnScrollListener(new RecyclerView.OnScrollListener() {
                @Override
                public void onScrolled(@NonNull RecyclerView recyclerView, int dx, int dy) {
                    if (dy > 0) binding.fab.hide();
                    else if (dy < 0) binding.fab.show();
                }
            });
        } else {
            binding.fab.hide();
            binding.emptyContentView.hideDescription();
        }
        final var sharedPreferences = PreferenceManager.getDefaultSharedPreferences(requireContext());
        compressImagesOnUpload = sharedPreferences.getBoolean(getString(R.string.pref_key_compress_image_attachments), true);
        editViewModel.getBoardColor().observe(getViewLifecycleOwner(), this::applyTheme);
        return binding.getRoot();
    }
    @Override
    public void onResume() {
        super.onResume();
        backPressedCallback.setEnabled(editViewModel.getAttachmentsBackPressedCallbackStatus());
    }
    private void setupAttachments() {
        adapter = new CardAttachmentAdapter(getChildFragmentManager(),
                requireActivity().getMenuInflater(),
                this,
                editViewModel.getAccount(),
                editViewModel.getFullCard().getLocalId());
        binding.attachmentsList.setAdapter(adapter);
        adapter.isEmpty().observe(getViewLifecycleOwner(), (isEmpty) -> {
            if (isEmpty) {
                this.binding.emptyContentView.setVisibility(VISIBLE);
                this.binding.attachmentsList.setVisibility(GONE);
            } else {
                this.binding.emptyContentView.setVisibility(GONE);
                this.binding.attachmentsList.setVisibility(VISIBLE);
            }
        });
        final var displayMetrics = getResources().getDisplayMetrics();
        final int spanCount = (int) ((displayMetrics.widthPixels / displayMetrics.density) / getResources().getInteger(R.integer.max_dp_attachment_picker));
        final var attachmentGlm = new GridLayoutManager(getContext(), spanCount);
        attachmentGlm.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {
            @Override
            public int getSpanSize(int position) {
                return switch (adapter.getItemViewType(position)) {
                    case VIEW_TYPE_IMAGE -> 1;
                    default -> spanCount;
                };
            }
        });
        binding.attachmentsList.setLayoutManager(attachmentGlm);
        // https://android-developers.googleblog.com/2018/02/continuous-shared-element-transitions.html?m=1
        // https://github.com/android/animation-samples/blob/master/GridToPager/app/src/main/java/com/google/samples/gridtopager/fragment/ImagePagerFragment.java
        setExitSharedElementCallback(new SharedElementCallback() {
            @Override
            public void onMapSharedElements(List<String> names, Map<String, View> sharedElements) {
                final var selectedViewHolder = (AttachmentViewHolder) binding.attachmentsList.findViewHolderForAdapterPosition(clickedItemPosition);
                if (selectedViewHolder != null) {
                    sharedElements.put(names.get(0), selectedViewHolder.getPreview());
                }
            }
        });
        adapter.setAttachments(editViewModel.getFullCard().getAttachments(), editViewModel.getFullCard().getId());
    }
    private void setupPickers() {
        final var displayMetrics = getResources().getDisplayMetrics();
        final int spanCount = (int) ((displayMetrics.widthPixels / displayMetrics.density) / getResources().getInteger(R.integer.max_dp_attachment_picker));
        attachmentPickerAdapter = new AttachmentPickerAdapter(pickers, this);
        binding.attachmentPicker.setAdapter(attachmentPickerAdapter);
        binding.attachmentPicker.setLayoutManager(new GridLayoutManager(requireContext(), spanCount));
        mBottomSheetBehaviour = BottomSheetBehavior.from(binding.bottomSheetParent);
        mBottomSheetBehaviour.setDraggable(true);
        mBottomSheetBehaviour.setHideable(true);
        mBottomSheetBehaviour.setState(STATE_HIDDEN);
        mBottomSheetBehaviour.addBottomSheetCallback(new CardAttachmentsBottomsheetBehaviorCallback(requireContext(), backPressedCallback, binding.fab, binding.pickerBackdrop));
        binding.pickerBackdrop.setOnClickListener(v -> mBottomSheetBehaviour.setState(STATE_HIDDEN));
    }
    @Override
    public void accept(@NonNull CompletableFuture<List<Uri>> result) {
        result.whenComplete((uris, throwable) -> {
            if (throwable != null) {
                handlePickerException(throwable);
            } else if (uris == null || uris.isEmpty()) {
                DeckLog.info("No items selected");
            } else {
                DeckLog.verbose("Number of items selected: " + uris.size());
                try {
                    for (final var uri : uris) {
                        // TODO parallel?
                        uploadNewAttachmentFromUri(uri);
                    }
                } catch (Throwable t) {
                    ExceptionDialogFragment.newInstance(t, editViewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName());
                } finally {
                    mBottomSheetBehaviour.setState(STATE_HIDDEN);
                }
            }
        });
    }
    private void handlePickerException(@NonNull Throwable throwable) {
        final var cause = throwable instanceof CompletionException ? throwable.getCause() : throwable;
        if (cause instanceof SecurityException) {
            Toast.makeText(requireContext(), R.string.cannot_upload_files_without_permission, Toast.LENGTH_LONG).show();
        } else if (cause instanceof ActivityNotFoundException) {
            Toast.makeText(requireContext(), R.string.no_matching_app_installed, Toast.LENGTH_LONG).show();
        } else {
            mBottomSheetBehaviour.setState(STATE_HIDDEN);
            ExceptionDialogFragment.newInstance(cause == null ? throwable : cause, editViewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName());
        }
    }
    private void uploadNewAttachmentFromUri(@NonNull Uri sourceUri) throws UploadAttachmentFailedException {
        switch (sourceUri.getScheme()) {
            case ContentResolver.SCHEME_CONTENT, ContentResolver.SCHEME_FILE -> {
                final var mimeType = requireContext().getContentResolver().getType(sourceUri);
                DeckLog.verbose("--- found content URL", sourceUri.getPath());
                // Separate Thread required because picked file might not yet be locally available
                // https://github.com/stefan-niedermann/nextcloud-deck/issues/814
                executor.submit(() -> {
                    try {
                        final File originalFile = copyContentUriToTempFile(requireContext(), sourceUri, editViewModel.getAccount().getId(), editViewModel.getFullCard().getLocalId());
                        requireActivity().runOnUiThread(() -> {
                            if (compressImagesOnUpload && MimeTypeUtil.isImage(mimeType)) {
                                try {
                                    JavaCompressor.compress((AppCompatActivity) requireActivity(), originalFile, (status, file) -> uploadNewAttachmentFromFile(status && file != null ? file : originalFile, mimeType), new ResolutionConstraint(1920, 1920), new SizeConstraint(1_000_000, 10, 10, 10), new FormatConstraint(Bitmap.CompressFormat.JPEG), new QualityConstraint(80));
                                } catch (Throwable t) {
                                    DeckLog.logError(t);
                                    uploadNewAttachmentFromFile(originalFile, mimeType);
                                }
                            } else {
                                uploadNewAttachmentFromFile(originalFile, mimeType);
                            }
                        });
                    } catch (IOException e) {
                        requireActivity().runOnUiThread(() -> ExceptionDialogFragment.newInstance(e, editViewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName()));
                    }
                });
            }
            default ->
                    throw new UploadAttachmentFailedException("Unknown URI scheme: " + sourceUri.getScheme());
        }
    }
    private void uploadNewAttachmentFromFile(@NonNull File fileToUpload, String mimeType) {
        final int color = editViewModel.getAccount().getColor();
        for (final var existingAttachment : editViewModel.getFullCard().getAttachments()) {
            final String existingPath = existingAttachment.getLocalPath();
            if (existingPath != null && existingPath.equals(fileToUpload.getAbsolutePath())) {
                ThemedSnackbar.make(binding.coordinatorLayout, R.string.attachment_already_exists, Snackbar.LENGTH_LONG, color).show();
                return;
            }
        }
        final var now = Instant.now();
        final var a = new Attachment();
        a.setMimetype(mimeType);
        a.setData(fileToUpload.getName());
        a.setFilename(fileToUpload.getName());
        a.setBasename(fileToUpload.getName());
        a.setFilesize(fileToUpload.length());
        a.setLocalPath(fileToUpload.getAbsolutePath());
        a.setLastModifiedLocal(now);
        a.setCreatedAt(now);
        a.setStatusEnum(DBStatus.LOCAL_EDITED);
        editViewModel.getFullCard().getAttachments().add(0, a);
        adapter.addAttachment(a);
        editViewModel.addAttachmentToCard(editViewModel.getAccount().getId(), editViewModel.getFullCard().getLocalId(), a.getMimetype(), fileToUpload, new IResponseCallback<>() {
            @Override
            public void onResponse(Attachment response, Headers headers) {
                requireActivity().runOnUiThread(() -> {
                    editViewModel.getFullCard().getAttachments().remove(a);
                    editViewModel.getFullCard().getAttachments().add(0, response);
                    adapter.replaceAttachment(a, response);
                });
            }
            @Override
            public void onError(Throwable throwable) {
                if (throwable instanceof NextcloudHttpRequestFailedException && ((NextcloudHttpRequestFailedException) throwable).getStatusCode() == HTTP_CONFLICT) {
                    IResponseCallback.super.onError(throwable);
                    // https://github.com/stefan-niedermann/nextcloud-deck/issues/534
                    editViewModel.getFullCard().getAttachments().remove(a);
                    adapter.removeAttachment(a);
                    ThemedSnackbar.make(binding.coordinatorLayout, R.string.attachment_already_exists, Snackbar.LENGTH_LONG, color).show();
                } else {
                    ExceptionDialogFragment.newInstance(new UploadAttachmentFailedException("Unknown URI scheme", throwable), editViewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName());
                }
            }
        });
    }
    @Override
    public void onAttachmentDeleted(Attachment attachment) {
        adapter.removeAttachment(attachment);
        editViewModel.getFullCard().getAttachments().remove(attachment);
        if (attachment.getLocalId() != null) {
            editViewModel.deleteAttachmentOfCard(editViewModel.getAccount().getId(), editViewModel.getFullCard().getLocalId(), attachment.getLocalId(), new IResponseCallback<>() {
                @Override
                public void onResponse(EmptyResponse response, Headers headers) {
                    DeckLog.info("Successfully delete", Attachment.class.getSimpleName(), attachment.getFilename(), "from", Card.class.getSimpleName(), editViewModel.getFullCard().getCard().getTitle());
                }
                @Override
                public void onError(Throwable throwable) {
                    if (SyncRepository.isNoOnVoidError(throwable)) {
                        IResponseCallback.super.onError(throwable);
                        requireActivity().runOnUiThread(() -> ExceptionDialogFragment.newInstance(throwable, editViewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName()));
                    }
                }
            });
        }
    }
    @Override
    public void onAttachmentClicked(int position) {
        this.clickedItemPosition = position;
    }
    @Override
    public void onAppendToDescription(@NonNull String markdown) {
        if (editViewModel.canEdit()) {
            final var oldDescription = editViewModel.getFullCard().getCard().getDescription();
            if (TextUtils.isEmpty(oldDescription)) {
                editViewModel.changeDescriptionFromExternal(markdown);
            } else {
                editViewModel.changeDescriptionFromExternal(oldDescription + "\n\n" + markdown);
            }
        } else {
            Toast.makeText(requireContext(), R.string.insufficient_permission, Toast.LENGTH_LONG).show();
        }
    }
    private void applyTheme(@ColorInt int color) {
        final var utils = ThemeUtils.of(color, requireContext());
        utils.deck.themeEmptyContentView(binding.emptyContentView);
        utils.material.themeFAB(binding.fab);
        utils.platform.colorViewBackground(binding.bottomSheetParent, ColorRole.SURFACE);
        utils.material.themeDragHandleView(binding.dragHandle);
        adapter.applyTheme(color);
        attachmentPickerAdapter.applyTheme(color);
    }
    @Override
    public void onPause() {
        editViewModel.setAttachmentsBackPressedCallbackStatus(backPressedCallback.isEnabled());
        backPressedCallback.setEnabled(false);
        super.onPause();
    }
    @Override
    public void onDestroy() {
        this.binding = null;
        super.onDestroy();
    }
    public static Fragment newInstance() {
        return new CardAttachmentsFragment();
    }
// THROWS SECURITYEXCEPTION
//    private static final class VoiceRecorder extends ActivityResultContract<Void, Uri> {
//        @NonNull
//        @Override
//        public Intent createIntent(@NonNull Context context, Void unused) {
//            return new Intent(MediaStore.Audio.Media.RECORD_SOUND_ACTION);
//        }
//
//        @Override
//        public Uri parseResult(int resultCode, @Nullable Intent data) {
//            if (data == null) {
//                DeckLog.error("Recording voice failed.");
//                return null;
//            }
//
//            final var uri = data.getData();
//
//            if (uri == null) {
//                DeckLog.error("Recording voice failed.");
//                return null;
//            }
//
//            return uri;//Uri.withAppendedPath(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, uri.getLastPathSegment());
//        }
//    }
}
package it.niedermann.nextcloud.deck.model;
import androidx.annotation.Nullable;
import androidx.room.Entity;
import androidx.room.ForeignKey;
import androidx.room.Index;
import java.io.Serializable;
import java.time.Instant;
import java.util.Objects;
import it.niedermann.nextcloud.deck.model.enums.EAttachmentType;
import it.niedermann.nextcloud.deck.model.interfaces.AbstractRemoteEntity;
@Entity(inheritSuperIndices = true,
        indices = {@Index("cardId")},
        foreignKeys = {
                @ForeignKey(
                        entity = Card.class,
                        parentColumns = "localId",
                        childColumns = "cardId",
                        onDelete = ForeignKey.CASCADE
                ),
                @ForeignKey(
                        entity = Account.class,
                        parentColumns = "id",
                        childColumns = "accountId", onDelete = ForeignKey.CASCADE
                )
        }
)
public class Attachment extends AbstractRemoteEntity implements Comparable<Attachment>, Serializable {
    private long cardId;
    // TODO use EAttachmentType
    private EAttachmentType type = EAttachmentType.DECK_FILE;
    private String data;
    private Instant createdAt;
    private String createdBy;
    private Instant deletedAt;
    private long filesize;
    private String mimetype;
    private String dirname;
    private String basename;
    private String extension;
    private String filename;
    private String localPath;
    @Nullable
    private Long fileId;
    public long getCardId() {
        return cardId;
    }
    public void setCardId(long cardId) {
        this.cardId = cardId;
    }
    public EAttachmentType getType() {
        return type;
    }
    public void setType(EAttachmentType type) {
        this.type = type;
    }
    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    public Instant getCreatedAt() {
        return createdAt;
    }
    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }
    public String getCreatedBy() {
        return createdBy;
    }
    public void setCreatedBy(String createdBy) {
        this.createdBy = createdBy;
    }
    public Instant getDeletedAt() {
        return deletedAt;
    }
    public void setDeletedAt(Instant deletedAt) {
        this.deletedAt = deletedAt;
    }
    public long getFilesize() {
        return filesize;
    }
    public void setFilesize(long filesize) {
        this.filesize = filesize;
    }
    public String getMimetype() {
        return mimetype;
    }
    public void setMimetype(String mimetype) {
        this.mimetype = mimetype;
    }
    public String getDirname() {
        return dirname;
    }
    public void setDirname(String dirname) {
        this.dirname = dirname;
    }
    public String getBasename() {
        return basename;
    }
    public void setBasename(String basename) {
        this.basename = basename;
    }
    public String getExtension() {
        return extension;
    }
    public void setExtension(String extension) {
        this.extension = extension;
    }
    public String getFilename() {
        return filename;
    }
    public void setFilename(String filename) {
        this.filename = filename;
    }
    public String getLocalPath() {
        return localPath;
    }
    public void setLocalPath(String localPath) {
        this.localPath = localPath;
    }
    @Nullable
    public Long getFileId() {
        return this.fileId;
    }
    public void setFileId(@Nullable Long fileId) {
        this.fileId = fileId;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Attachment that = (Attachment) o;
        if (cardId != that.cardId) return false;
        if (filesize != that.filesize) return false;
        if (!Objects.equals(type, that.type)) return false;
        if (!Objects.equals(data, that.data)) return false;
        if (!Objects.equals(createdAt, that.createdAt))
            return false;
        if (!Objects.equals(createdBy, that.createdBy))
            return false;
        if (!Objects.equals(deletedAt, that.deletedAt))
            return false;
        if (!Objects.equals(mimetype, that.mimetype))
            return false;
        if (!Objects.equals(dirname, that.dirname)) return false;
        if (!Objects.equals(basename, that.basename))
            return false;
        if (!Objects.equals(extension, that.extension))
            return false;
        if (!Objects.equals(filename, that.filename))
            return false;
        return Objects.equals(localPath, that.localPath);
    }
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (int) (cardId ^ (cardId >>> 32));
        result = 31 * result + (type != null ? type.hashCode() : 0);
        result = 31 * result + (data != null ? data.hashCode() : 0);
        result = 31 * result + (createdAt != null ? createdAt.hashCode() : 0);
        result = 31 * result + (createdBy != null ? createdBy.hashCode() : 0);
        result = 31 * result + (deletedAt != null ? deletedAt.hashCode() : 0);
        result = 31 * result + (int) (filesize ^ (filesize >>> 32));
        result = 31 * result + (mimetype != null ? mimetype.hashCode() : 0);
        result = 31 * result + (dirname != null ? dirname.hashCode() : 0);
        result = 31 * result + (basename != null ? basename.hashCode() : 0);
        result = 31 * result + (extension != null ? extension.hashCode() : 0);
        result = 31 * result + (filename != null ? filename.hashCode() : 0);
        result = 31 * result + (localPath != null ? localPath.hashCode() : 0);
        return result;
    }
    @Override
    public int compareTo(Attachment other) {
        // DESC order
        long res = other.getModificationTimeForComparsion() - getModificationTimeForComparsion();
        if (res == 0) {
            return longToComparsionResult(other.getCreationTimeForComparsion() - getCreationTimeForComparsion());
        }
        return longToComparsionResult(res);
    }
    private static int longToComparsionResult(long diff) {
        if (diff > 0) {
            return 1;
        } else if (diff < 0) {
            return -1;
        }
        return 0;
    }
    public long getModificationTimeForComparsion() {
        if (lastModifiedLocal != null) {
            return lastModifiedLocal.toEpochMilli();
        }
        if (lastModified != null) {
            return lastModified.toEpochMilli();
        }
        return Instant.now().toEpochMilli();
    }
    public long getCreationTimeForComparsion() {
        if (createdAt != null) {
            return createdAt.toEpochMilli();
        }
        return Instant.now().toEpochMilli();
    }
}
package it.niedermann.nextcloud.deck.model;
import android.graphics.Color;
import androidx.annotation.ColorInt;
import androidx.room.Entity;
import androidx.room.ForeignKey;
import androidx.room.Ignore;
import androidx.room.Index;
import com.google.gson.annotations.JsonAdapter;
import java.io.Serializable;
import java.time.Instant;
import java.util.Objects;
import it.niedermann.android.util.ColorUtil;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.model.enums.DBStatus;
import it.niedermann.nextcloud.deck.model.interfaces.AbstractRemoteEntity;
import it.niedermann.nextcloud.deck.remote.api.json.JsonColorSerializer;
@Entity(
        inheritSuperIndices = true,
        indices = {@Index("ownerId")},
        foreignKeys = {
                @ForeignKey(
                        entity = User.class,
                        parentColumns = "localId",
                        childColumns = "ownerId", onDelete = ForeignKey.CASCADE
                ),
                @ForeignKey(
                        entity = Account.class,
                        parentColumns = "id",
                        childColumns = "accountId", onDelete = ForeignKey.CASCADE
                )
        }
)
public class Board extends AbstractRemoteEntity implements Serializable {
    public Board() {
    }
    @Ignore
    public Board(String title, @ColorInt int color) {
        setTitle(title);
        setColor(color);
    }
    private String title;
    private long ownerId;
    @JsonAdapter(JsonColorSerializer.class)
    private Integer color;
    private boolean archived;
    private int shared;
    private Instant deletedAt;
    private boolean permissionRead = false;
    private boolean permissionEdit = false;
    private boolean permissionManage = false;
    private boolean permissionShare = false;
    @Override
    public Instant getLastModified() {
        return lastModified;
    }
    @Override
    public void setLastModified(Instant lastModified) {
        this.lastModified = lastModified;
    }
    @Override
    public Instant getLastModifiedLocal() {
        return lastModifiedLocal;
    }
    @Override
    public void setLastModifiedLocal(Instant lastModifiedLocal) {
        this.lastModifiedLocal = lastModifiedLocal;
    }
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    @ColorInt
    public Integer getColor() {
        return color;
    }
    public void setColor(String color) {
        try {
            setColor(Color.parseColor(ColorUtil.formatColorToParsableHexString(color)));
        } catch (Exception e) {
            DeckLog.logError(e);
            setColor(Color.GRAY);
        }
    }
    public void setColor(@ColorInt Integer color) {
        this.color = color;
    }
    public boolean isArchived() {
        return archived;
    }
//
//    public String getAcl() {
//        return acl;
//    }
//
//    public void setAcl(String acl) {
//        this.acl = acl;
//    }
    public int getShared() {
        return shared;
    }
    public void setShared(int shared) {
        this.shared = shared;
    }
    public Instant getDeletedAt() {
        return deletedAt;
    }
    public void setDeletedAt(Instant deletedAt) {
        this.deletedAt = deletedAt;
    }
    public String getTitle() {
        return title;
    }
    public void setTitle(String title) {
        this.title = title;
    }
    public DBStatus getStatusEnum() {
        return DBStatus.findById(status);
    }
    public void setStatusEnum(DBStatus status) {
        this.status = status.getId();
    }
    public void setStatus(int status) {
        this.status = status;
    }
    public int getStatus() {
        return this.status;
    }
    public long getOwnerId() {
        return this.ownerId;
    }
    public void setOwnerId(long ownerId) {
        this.ownerId = ownerId;
    }
    public void setArchived(boolean archived) {
        this.archived = archived;
    }
    public boolean isPermissionRead() {
        return permissionRead;
    }
    public void setPermissionRead(boolean permissionRead) {
        this.permissionRead = permissionRead;
    }
    public boolean isPermissionEdit() {
        return permissionEdit;
    }
    public void setPermissionEdit(boolean permissionEdit) {
        this.permissionEdit = permissionEdit;
    }
    public boolean isPermissionManage() {
        return permissionManage;
    }
    public void setPermissionManage(boolean permissionManage) {
        this.permissionManage = permissionManage;
    }
    public boolean isPermissionShare() {
        return permissionShare;
    }
    public void setPermissionShare(boolean permissionShare) {
        this.permissionShare = permissionShare;
    }
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Board board = (Board) o;
        if (ownerId != board.ownerId) return false;
        if (archived != board.archived) return false;
        if (shared != board.shared) return false;
        if (permissionRead != board.permissionRead) return false;
        if (permissionEdit != board.permissionEdit) return false;
        if (permissionManage != board.permissionManage) return false;
        if (permissionShare != board.permissionShare) return false;
        if (!Objects.equals(title, board.title)) return false;
        if (!Objects.equals(color, board.color)) return false;
        return Objects.equals(deletedAt, board.deletedAt);
    }
    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (title != null ? title.hashCode() : 0);
        result = 31 * result + (int) (ownerId ^ (ownerId >>> 32));
        result = 31 * result + (color != null ? color.hashCode() : 0);
        result = 31 * result + (archived ? 1 : 0);
        result = 31 * result + shared;
        result = 31 * result + (deletedAt != null ? deletedAt.hashCode() : 0);
        result = 31 * result + (permissionRead ? 1 : 0);
        result = 31 * result + (permissionEdit ? 1 : 0);
        result = 31 * result + (permissionManage ? 1 : 0);
        result = 31 * result + (permissionShare ? 1 : 0);
        return result;
    }
}
package it.niedermann.nextcloud.deck.ui.card.details;
import static android.view.View.GONE;
import static android.view.View.INVISIBLE;
import static android.view.View.VISIBLE;
import static java.util.Objects.requireNonNull;
import android.content.res.ColorStateList;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.text.TextUtils;
import android.text.method.LinkMovementMethod;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.LinearLayout;
import androidx.annotation.ColorInt;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.Px;
import androidx.core.content.ContextCompat;
import androidx.core.graphics.ColorUtils;
import androidx.core.graphics.drawable.DrawableCompat;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import androidx.recyclerview.widget.GridLayoutManager;
import com.google.android.material.chip.Chip;
import com.google.android.material.snackbar.Snackbar;
import com.nextcloud.android.common.ui.theme.utils.ColorRole;
import com.nextcloud.android.sso.exceptions.NextcloudFilesAppAccountNotFoundException;
import java.time.Instant;
import java.util.Optional;
import java.util.stream.Stream;
import it.niedermann.android.markdown.MarkdownEditor;
import it.niedermann.android.markdown.MarkdownViewerImpl;
import it.niedermann.android.util.ColorUtil;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.R;
import it.niedermann.nextcloud.deck.databinding.FragmentCardEditTabDetailsBinding;
import it.niedermann.nextcloud.deck.model.Account;
import it.niedermann.nextcloud.deck.model.Label;
import it.niedermann.nextcloud.deck.model.User;
import it.niedermann.nextcloud.deck.model.full.FullCard;
import it.niedermann.nextcloud.deck.remote.api.IResponseCallback;
import it.niedermann.nextcloud.deck.ui.card.EditCardViewModel;
import it.niedermann.nextcloud.deck.ui.card.LabelAutoCompleteAdapter;
import it.niedermann.nextcloud.deck.ui.card.UserAutoCompleteAdapter;
import it.niedermann.nextcloud.deck.ui.card.assignee.CardAssigneeDialog;
import it.niedermann.nextcloud.deck.ui.card.assignee.CardAssigneeListener;
import it.niedermann.nextcloud.deck.ui.exception.ExceptionDialogFragment;
import it.niedermann.nextcloud.deck.ui.theme.ThemeUtils;
import it.niedermann.nextcloud.deck.ui.theme.ThemedSnackbar;
import okhttp3.Headers;
public class CardDetailsFragment extends Fragment implements CardDueDateView.DueDateChangedListener, CardAssigneeListener {
    private FragmentCardEditTabDetailsBinding binding;
    private EditCardViewModel viewModel;
    private AssigneeAdapter adapter;
    private static final String KEY_ACCOUNT = "account";
    public static Fragment newInstance(@NonNull Account account) {
        final var fragment = new CardDetailsFragment();
        final var args = new Bundle();
        args.putSerializable(KEY_ACCOUNT, account);
        fragment.setArguments(args);
        return fragment;
    }
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater,
                             ViewGroup container,
                             Bundle savedInstanceState) {
        binding = FragmentCardEditTabDetailsBinding.inflate(inflater, container, false);
        viewModel = new ViewModelProvider(requireActivity()).get(EditCardViewModel.class);
        final var args = getArguments();
        if (args == null || !args.containsKey(KEY_ACCOUNT)) {
            throw new IllegalStateException(KEY_ACCOUNT + " must be provided");
        }
        // This might be a zombie fragment with an empty EditCardViewModel after Android killed the activity (but not the fragment instance
        // See https://github.com/stefan-niedermann/nextcloud-deck/issues/478
        if (viewModel.getFullCard() == null) {
            DeckLog.logError(new IllegalStateException("Cannot populate " + CardDetailsFragment.class.getSimpleName() + " because viewModel.getFullCard() is null"));
            return binding.getRoot();
        }
        @Px final int avatarSize = getResources().getDimensionPixelSize(R.dimen.avatar_size);
        final var avatarLayoutParams = new LinearLayout.LayoutParams(avatarSize, avatarSize);
        avatarLayoutParams.setMargins(0, 0, getResources().getDimensionPixelSize(R.dimen.spacer_1x), 0);
        setupAssignees();
        setupLabels((Account) requireNonNull(args.getSerializable(KEY_ACCOUNT)));
        setupDueDate();
        setupDescription();
        setupProjects();
        return binding.getRoot();
    }
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        final var ssoAccount = viewModel.getAccount().getSingleSignOnAccount(requireContext()).orElse(null);
        viewModel.getBoardColor().observe(getViewLifecycleOwner(), color -> {
            applyTheme(color);
            binding.descriptionEditor.setCurrentSingleSignOnAccount(ssoAccount, color);
            binding.descriptionViewer.setCurrentSingleSignOnAccount(ssoAccount, color);
        });
    }
//    @Override
//    public void onResume() {
//        super.onResume();
//
//        // https://github.com/wdullaer/MaterialDateTimePicker#why-are-my-callbacks-lost-when-the-device-changes-orientation
//        final var dpd = (DatePickerDialog) getChildFragmentManager().findFragmentByTag(ThemedDatePickerDialog.class.getCanonicalName());
//        final var tpd = (TimePickerDialog) getChildFragmentManager().findFragmentByTag(ThemedTimePickerDialog.class.getCanonicalName());
//        if (tpd != null) tpd.setOnTimeSetListener(this);
//        if (dpd != null) dpd.setOnDateSetListener(this);
//    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        this.binding = null;
    }
    private void applyTheme(@ColorInt int color) {
        final var utils = ThemeUtils.of(color, requireContext());
        Stream.of(
                binding.labelsWrapper,
                binding.peopleWrapper,
                binding.descriptionEditorWrapper
        ).forEach(utils.material::colorTextInputLayout);
        utils.platform.colorImageView(binding.descriptionToggle, ColorRole.SECONDARY);
        binding.cardDueDateView.applyTheme(color);
        // TODO apply correct branding on the BrandedDatePicker
    }
    private void setupDescription() {
        binding.descriptionViewer.setMovementMethod(LinkMovementMethod.getInstance());
        binding.descriptionViewer.setMarkdownString(viewModel.getFullCard().getCard().getDescription());
        if (viewModel.canEdit()) {
            binding.descriptionEditor.setMarkdownString(viewModel.getFullCard().getCard().getDescription());
            viewModel.getDescriptionMode().observe(getViewLifecycleOwner(), isPreviewMode -> {
                if (isPreviewMode) {
                    toggleEditorView(binding.descriptionViewer, binding.descriptionEditorWrapper, binding.descriptionViewer);
                    binding.descriptionToggle.setImageResource(R.drawable.ic_edit_24dp);
                } else {
                    toggleEditorView(binding.descriptionEditorWrapper, binding.descriptionViewer, binding.descriptionEditor);
                    binding.descriptionToggle.setImageResource(R.drawable.ic_eye_24);
                }
            });
            viewModel.descriptionChangedFromExternal().observe(getViewLifecycleOwner(), description -> {
                binding.descriptionEditor.setMarkdownString(description);
                binding.descriptionViewer.setMarkdownString(description);
                // TODO Workaround when toggling first time from editor to viewer and content contains one or more @mention causing the viewer to be scrolled
                if (Optional.ofNullable(description).map(d -> d.contains("@")).orElse(false)) {
                    binding.descriptionViewer.post(() -> binding.descriptionViewer.scrollTo(0, 0));
                }
            });
            binding.descriptionToggle.setOnClickListener((v) -> viewModel.toggleDescriptionPreviewMode());
            registerEditorListener(binding.descriptionEditor);
            registerEditorListener(binding.descriptionViewer);
        } else {
            binding.descriptionEditor.setEnabled(false);
            binding.descriptionEditorWrapper.setVisibility(GONE);
            binding.descriptionViewer.setEnabled(true);
            binding.descriptionViewer.setVisibility(VISIBLE);
            viewModel.descriptionChangedFromExternal().observe(getViewLifecycleOwner(), description -> binding.descriptionViewer.setMarkdownString(description));
        }
    }
    private void registerEditorListener(@NonNull MarkdownEditor editor) {
        editor.setMarkdownStringChangedListener(newDescription -> {
            binding.descriptionToggle.setVisibility(TextUtils.isEmpty(newDescription) ? INVISIBLE : VISIBLE);
            if (viewModel.getFullCard() == null) {
                ExceptionDialogFragment.newInstance(new IllegalStateException(FullCard.class.getSimpleName() + " was empty when trying to setup description"), viewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName());
            }
            // TODO This is the preferred way, but we need to preserve scroll and selection state
            viewModel.getFullCard().getCard().setDescription(newDescription == null ? "" : newDescription.toString());
        });
    }
    private void toggleEditorView(@NonNull View viewToShow,
                                  @NonNull View viewToHide,
                                  @NonNull MarkdownEditor editorToShow) {
        final var description = viewModel.getFullCard().getCard().getDescription();
        editorToShow.setMarkdownString(description);
        // TODO Workaround when toggling first time from editor to viewer and content contains one or more checkboxes or @mentions causing the viewer to be scrolled
        if (editorToShow instanceof MarkdownViewerImpl && Optional.ofNullable(description).map(d -> d.contains("@") || d.contains(" [")).orElse(false)) {
            binding.descriptionViewer.post(() -> binding.descriptionViewer.scrollTo(0, 0));
        }
        viewToHide.setVisibility(GONE);
        viewToShow.setVisibility(VISIBLE);
    }
    private void setupDueDate() {
        final var version = this.viewModel.getAccount().getServerDeckVersionAsObject();
        final var card = this.viewModel.getFullCard().getCard();
        binding.cardDueDateView.setDueDateListener(this);
        binding.cardDueDateView.setEnabled(this.viewModel.canEdit());
        binding.cardDueDateView.setDueDate(getChildFragmentManager(), version, card.getDueDate(), card.getDone());
    }
    @Override
    public void onDueDateChanged(@Nullable Instant dueDate) {
        final var version = this.viewModel.getAccount().getServerDeckVersionAsObject();
        final var card = this.viewModel.getFullCard().getCard();
        card.setDueDate(dueDate);
        binding.cardDueDateView.setDueDate(getChildFragmentManager(), version, card.getDueDate(), card.getDone());
    }
    @Override
    public void onDoneChanged(@Nullable Instant done) {
        final var version = this.viewModel.getAccount().getServerDeckVersionAsObject();
        final var card = this.viewModel.getFullCard().getCard();
        card.setDone(done);
        binding.cardDueDateView.setDueDate(getChildFragmentManager(), version, card.getDueDate(), card.getDone());
    }
    private void setupLabels(@NonNull Account account) {
        final long accountId = viewModel.getAccount().getId();
        final long boardId = viewModel.getBoardId();
        binding.labelsGroup.removeAllViews();
        if (viewModel.canEdit()) {
            Long localCardId = viewModel.getFullCard().getCard().getLocalId();
            localCardId = localCardId == null ? -1 : localCardId;
            try {
                binding.labels.setAdapter(new LabelAutoCompleteAdapter(requireActivity(), account, boardId, localCardId));
            } catch (NextcloudFilesAppAccountNotFoundException e) {
                ExceptionDialogFragment.newInstance(e, account).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName());
                // TODO Handle error
            }
            binding.labels.setOnItemClickListener((adapterView, view, position, id) -> {
                final var label = (Label) adapterView.getItemAtPosition(position);
                if (label.getLocalId() == null) {
                    viewModel.createLabel(accountId, label, boardId, new IResponseCallback<>() {
                        @Override
                        public void onResponse(Label response, Headers headers) {
                            requireActivity().runOnUiThread(() -> {
                                label.setLocalId(response.getLocalId());
                                ((LabelAutoCompleteAdapter) binding.labels.getAdapter()).exclude(response);
                                viewModel.getFullCard().getLabels().add(response);
                                binding.labelsGroup.addView(createChipFromLabel(label));
                                binding.labelsGroup.setVisibility(VISIBLE);
                            });
                        }
                        @Override
                        public void onError(Throwable throwable) {
                            IResponseCallback.super.onError(throwable);
                            viewModel.getCurrentBoardColor(viewModel.getAccount().getId(), viewModel.getBoardId())
                                    .thenAcceptAsync(color -> ThemedSnackbar.make(requireView(), getString(R.string.error_create_label, label.getTitle()), Snackbar.LENGTH_LONG, color)
                                            .setAction(R.string.simple_more, v -> ExceptionDialogFragment.newInstance(throwable, viewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName())).show(), ContextCompat.getMainExecutor(requireContext()));
                        }
                    });
                } else {
                    ((LabelAutoCompleteAdapter) binding.labels.getAdapter()).exclude(label);
                    viewModel.getFullCard().getLabels().add(label);
                    binding.labelsGroup.addView(createChipFromLabel(label));
                    binding.labelsGroup.setVisibility(VISIBLE);
                }
                binding.labels.setText("");
            });
        } else {
            binding.labels.setEnabled(false);
        }
        if (viewModel.getFullCard().getLabels() != null && !viewModel.getFullCard().getLabels().isEmpty()) {
            for (final var label : viewModel.getFullCard().getLabels()) {
                binding.labelsGroup.addView(createChipFromLabel(label));
            }
            binding.labelsGroup.setVisibility(VISIBLE);
        } else {
            binding.labelsGroup.setVisibility(INVISIBLE);
        }
    }
    private Chip createChipFromLabel(Label label) {
        final var chip = new Chip(requireContext());
        chip.setText(label.getTitle());
        if (viewModel.canEdit()) {
            chip.setCloseIcon(ContextCompat.getDrawable(requireContext(), R.drawable.ic_close_circle));
            chip.setCloseIconVisible(true);
            chip.setOnCloseIconClickListener(v -> {
                binding.labelsGroup.removeView(chip);
                viewModel.getFullCard().getLabels().remove(label);
                ((LabelAutoCompleteAdapter) binding.labels.getAdapter()).doNotLongerExclude(label);
            });
        }
        try {
            final int labelColor = label.getColor();
            chip.setChipBackgroundColor(ColorStateList.valueOf(labelColor));
            final int color = ColorUtil.getForegroundColorForBackgroundColor(labelColor);
            chip.setTextColor(color);
            if (chip.getCloseIcon() != null) {
                Drawable wrapDrawable = DrawableCompat.wrap(chip.getCloseIcon());
                DrawableCompat.setTint(wrapDrawable, ColorUtils.setAlphaComponent(color, 150));
            }
        } catch (IllegalArgumentException e) {
            DeckLog.logError(e);
        }
        return chip;
    }
    private void setupAssignees() {
        adapter = new AssigneeAdapter((user) -> CardAssigneeDialog.newInstance(user).show(getChildFragmentManager(), CardAssigneeDialog.class.getSimpleName()), viewModel.getAccount());
        binding.assignees.setAdapter(adapter);
        binding.assignees.post(() -> {
            @Px final int gutter = getResources().getDimensionPixelSize(R.dimen.spacer_1x);
            final int spanCount = (int) (float) binding.labelsWrapper.getWidth() / (getResources().getDimensionPixelSize(R.dimen.avatar_size) + gutter);
            binding.assignees.setLayoutManager(new GridLayoutManager(getContext(), spanCount));
            binding.assignees.addItemDecoration(new AssigneeDecoration(spanCount, gutter));
        });
        if (viewModel.canEdit()) {
            Long localCardId = viewModel.getFullCard().getCard().getLocalId();
            localCardId = localCardId == null ? -1 : localCardId;
            try {
                binding.people.setAdapter(new UserAutoCompleteAdapter(requireActivity(), viewModel.getAccount(), viewModel.getBoardId(), localCardId));
            } catch (NextcloudFilesAppAccountNotFoundException e) {
                ExceptionDialogFragment.newInstance(e, viewModel.getAccount()).show(getChildFragmentManager(), ExceptionDialogFragment.class.getSimpleName());
                // TODO Handle error
            }
            binding.people.setOnItemClickListener((adapterView, view, position, id) -> {
                final var user = (User) adapterView.getItemAtPosition(position);
                viewModel.getFullCard().getAssignedUsers().add(user);
                ((UserAutoCompleteAdapter) binding.people.getAdapter()).exclude(user);
                adapter.addUser(user);
                binding.people.setText("");
            });
        } else {
            binding.people.setEnabled(false);
        }
        if (this.viewModel.getFullCard().getAssignedUsers() != null) {
            adapter.setUsers(this.viewModel.getFullCard().getAssignedUsers());
        }
    }
    private void setupProjects() {
        if (!viewModel.getFullCard().getProjects().isEmpty()) {
            binding.projectsTitle.setVisibility(VISIBLE);
            binding.projects.setNestedScrollingEnabled(false);
            final var adapter = new CardProjectsAdapter(viewModel.getFullCard().getProjects(), getChildFragmentManager());
            binding.projects.setAdapter(adapter);
            binding.projects.setVisibility(VISIBLE);
        } else {
            binding.projectsTitle.setVisibility(GONE);
            binding.projects.setVisibility(GONE);
        }
    }
    @Override
    public void onUnassignUser(@NonNull User user) {
        viewModel.getFullCard().getAssignedUsers().remove(user);
        adapter.removeUser(user);
        ((UserAutoCompleteAdapter) binding.people.getAdapter()).doNotLongerExclude(user);
        viewModel.getCurrentBoardColor(viewModel.getAccount().getId(), viewModel.getBoardId())
                .thenAcceptAsync(color -> ThemedSnackbar.make(requireView(), getString(R.string.unassigned_user, user.getDisplayname()), Snackbar.LENGTH_LONG, color)
                        .setAction(R.string.simple_undo, v1 -> {
                            viewModel.getFullCard().getAssignedUsers().add(user);
                            ((UserAutoCompleteAdapter) binding.people.getAdapter()).exclude(user);
                            adapter.addUser(user);
                        })
                        .show(), ContextCompat.getMainExecutor(requireContext()));
    }
}
package it.niedermann.nextcloud.deck.ui.card.assignee;
import static com.nextcloud.android.common.ui.util.PlatformThemeUtil.isDarkMode;
import android.app.Dialog;
import android.content.Context;
import android.graphics.Color;
import android.os.Bundle;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.DialogFragment;
import androidx.lifecycle.ViewModelProvider;
import androidx.swiperefreshlayout.widget.CircularProgressDrawable;
import com.bumptech.glide.Glide;
import it.niedermann.nextcloud.deck.R;
import it.niedermann.nextcloud.deck.databinding.DialogPreviewBinding;
import it.niedermann.nextcloud.deck.model.User;
import it.niedermann.nextcloud.deck.ui.card.EditCardViewModel;
import it.niedermann.nextcloud.deck.ui.card.attachments.previewdialog.PreviewDialog;
import it.niedermann.nextcloud.deck.ui.theme.DeleteAlertDialogBuilder;
/**
 * TODO maybe this can be merged with {@link PreviewDialog}
 */
public class CardAssigneeDialog extends DialogFragment {
    private static final String KEY_USER = "user";
    private DialogPreviewBinding binding;
    private EditCardViewModel viewModel;
    @Nullable
    private CardAssigneeListener cardAssigneeListener = null;
    @SuppressWarnings("NotNullFieldNotInitialized")
    @NonNull
    private User user;
    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);
        if (getParentFragment() instanceof CardAssigneeListener) {
            this.cardAssigneeListener = (CardAssigneeListener) getParentFragment();
        } else if (context instanceof CardAssigneeListener) {
            this.cardAssigneeListener = (CardAssigneeListener) context;
        }
        final var args = requireArguments();
        if (!args.containsKey(KEY_USER)) {
            throw new IllegalArgumentException("Provide at least " + KEY_USER);
        }
        final var user = args.getSerializable(KEY_USER);
        if (user == null) {
            throw new IllegalArgumentException(KEY_USER + " must not be null.");
        }
        this.user = (User) user;
    }
    @NonNull
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        binding = DialogPreviewBinding.inflate(getLayoutInflater());
        viewModel = new ViewModelProvider(requireActivity()).get(EditCardViewModel.class);
        final var dialogBuilder = new DeleteAlertDialogBuilder(requireContext());
        if (viewModel.canEdit() && cardAssigneeListener != null) {
            dialogBuilder.setPositiveButton(R.string.simple_unassign, (d, w) -> cardAssigneeListener.onUnassignUser(user));
        }
        return dialogBuilder
                .setView(binding.getRoot())
                .setNeutralButton(R.string.simple_close, null)
                .create();
    }
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        final var context = requireContext();
        final var circularProgressDrawable = new CircularProgressDrawable(context);
        circularProgressDrawable.setStrokeWidth(5f);
        circularProgressDrawable.setCenterRadius(30f);
        circularProgressDrawable.setColorSchemeColors(isDarkMode(context) ? Color.LTGRAY : Color.DKGRAY);
        circularProgressDrawable.start();
        binding.avatar.post(() -> Glide.with(binding.avatar.getContext())
                .load(viewModel.getAccount().getAvatarUrl(binding.avatar.getWidth(), user.getUid()))
                .placeholder(circularProgressDrawable)
                .error(R.drawable.ic_person_24dp)
                .into(binding.avatar));
        binding.title.setText(user.getDisplayname());
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        this.binding = null;
    }
    public static DialogFragment newInstance(@NonNull User user) {
        final var fragment = new CardAssigneeDialog();
        final var args = new Bundle();
        args.putSerializable(KEY_USER, user);
        fragment.setArguments(args);
        return fragment;
    }
}
package it.niedermann.nextcloud.deck.ui.card.projectresources;
import android.view.LayoutInflater;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.lifecycle.LifecycleOwner;
import androidx.recyclerview.widget.RecyclerView;
import java.util.ArrayList;
import java.util.List;
import it.niedermann.nextcloud.deck.databinding.ItemProjectResourceBinding;
import it.niedermann.nextcloud.deck.model.ocs.projects.OcsProjectResource;
import it.niedermann.nextcloud.deck.ui.card.EditCardViewModel;
public class CardProjectResourceAdapter extends RecyclerView.Adapter<CardProjectResourceViewHolder> {
    @NonNull
    private final EditCardViewModel viewModel;
    @NonNull
    private final List<OcsProjectResource> resources;
    @NonNull
    private final LifecycleOwner owner;
    public CardProjectResourceAdapter(@NonNull EditCardViewModel viewModel, @NonNull List<OcsProjectResource> resources, @NonNull LifecycleOwner owner) {
        this.viewModel = viewModel;
        this.resources = new ArrayList<>(resources.size());
        this.resources.addAll(resources);
        this.owner = owner;
        setHasStableIds(true);
    }
    @Override
    public long getItemId(int position) {
        return resources.get(position).getLocalId();
    }
    @NonNull
    @Override
    public CardProjectResourceViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        return new CardProjectResourceViewHolder(ItemProjectResourceBinding.inflate(LayoutInflater.from(parent.getContext()), parent, false));
    }
    @Override
    public void onBindViewHolder(@NonNull CardProjectResourceViewHolder holder, int position) {
        holder.bind(viewModel, resources.get(position), owner);
    }
    @Override
    public int getItemCount() {
        return this.resources.size();
    }
}
package it.niedermann.nextcloud.deck.ui.card.projectresources;
import static android.view.View.GONE;
import static android.view.View.VISIBLE;
import static it.niedermann.nextcloud.deck.util.ProjectUtil.getResourceUri;
import android.content.Intent;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.lifecycle.LifecycleOwner;
import androidx.recyclerview.widget.RecyclerView;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.R;
import it.niedermann.nextcloud.deck.databinding.ItemProjectResourceBinding;
import it.niedermann.nextcloud.deck.model.Account;
import it.niedermann.nextcloud.deck.model.ocs.projects.OcsProjectResource;
import it.niedermann.nextcloud.deck.ui.card.EditActivity;
import it.niedermann.nextcloud.deck.ui.card.EditCardViewModel;
import it.niedermann.nextcloud.deck.util.ProjectUtil;
public class CardProjectResourceViewHolder extends RecyclerView.ViewHolder {
    @NonNull
    private final ItemProjectResourceBinding binding;
    public CardProjectResourceViewHolder(@NonNull ItemProjectResourceBinding binding) {
        super(binding.getRoot());
        this.binding = binding;
    }
    public void bind(@NonNull EditCardViewModel viewModel, @NonNull OcsProjectResource resource, @NonNull LifecycleOwner owner) {
        final var account = viewModel.getAccount();
        final var resources = itemView.getResources();
        binding.name.setText(resource.getName());
        final @Nullable String link = resource.getLink();
        binding.type.setVisibility(VISIBLE);
        if (resource.getType() != null) {
            switch (resource.getType()) {
                case "deck": {
                    // TODO https://github.com/stefan-niedermann/nextcloud-deck/issues/671
                    linkifyViewHolder(account, link);
                    binding.type.setText(resources.getString(R.string.project_type_deck_board));
                    binding.image.setImageResource(R.drawable.project_deck_36dp);
                    break;
                }
                case "deck-card": {
                    try {
                        final long[] ids = ProjectUtil.extractBoardIdAndCardIdFromUrl(link);
                        if (ids.length == 2) {
                            viewModel.getCardByRemoteID(account.getId(), ids[1]).observe(owner, (fullCard) -> {
                                if (fullCard != null) {
                                    viewModel.getBoardByRemoteId(account.getId(), ids[0]).observe(owner, (board) -> {
                                        if (board != null) {
                                            binding.getRoot().setOnClickListener((v) -> itemView.getContext().startActivity(EditActivity.createEditCardIntent(itemView.getContext(), account, board.getLocalId(), fullCard.getLocalId())));
                                        } else {
                                            linkifyViewHolder(account, link);
                                        }
                                    });
                                } else {
                                    linkifyViewHolder(account, link);
                                }
                            });
                        } else {
                            linkifyViewHolder(account, link);
                        }
                    } catch (IllegalArgumentException e) {
                        DeckLog.logError(e);
                        linkifyViewHolder(account, link);
                    }
                    binding.type.setText(resources.getString(R.string.project_type_deck_card));
                    binding.image.setImageResource(R.drawable.project_deck_36dp);
                    break;
                }
                case "file": {
                    binding.type.setText(resources.getString(R.string.project_type_file));
                    linkifyViewHolder(account, link);
                    binding.image.setImageResource(R.drawable.project_file_36dp);
                    break;
                }
                case "room": {
                    binding.type.setText(resources.getString(R.string.project_type_room));
                    linkifyViewHolder(account, link);
                    binding.image.setImageResource(R.drawable.project_talk_36dp);
                    break;
                }
                default: {
                    DeckLog.info("Unknown resource type for", resource.getName() + ":", resource.getType());
                    binding.type.setVisibility(GONE);
                    linkifyViewHolder(account, link);
                    break;
                }
            }
        } else {
            DeckLog.warn("Resource type for", resource.getName(), "is null");
            binding.type.setVisibility(GONE);
        }
    }
    private void linkifyViewHolder(@NonNull Account account, @Nullable String link) {
        if (link != null) {
            try {
                binding.getRoot().setOnClickListener((v) -> itemView.getContext().startActivity(new Intent(Intent.ACTION_VIEW).setData(getResourceUri(account, link))));
            } catch (IllegalArgumentException e) {
                DeckLog.logError(e);
            }
        }
    }
}
package it.niedermann.nextcloud.deck.ui.card.projectresources;
import android.app.Dialog;
import android.content.Context;
import android.os.Bundle;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.fragment.app.DialogFragment;
import androidx.lifecycle.ViewModelProvider;
import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import it.niedermann.nextcloud.deck.R;
import it.niedermann.nextcloud.deck.databinding.DialogProjectResourcesBinding;
import it.niedermann.nextcloud.deck.model.ocs.projects.OcsProjectResource;
import it.niedermann.nextcloud.deck.ui.card.EditCardViewModel;
public class CardProjectResourcesDialog extends DialogFragment {
    private static final String KEY_RESOURCES = "resources";
    private static final String KEY_PROJECT_NAME = "projectName";
    private DialogProjectResourcesBinding binding;
    private EditCardViewModel viewModel;
    private String projectName;
    @NonNull
    private final List<OcsProjectResource> resources = new ArrayList<>();
    @Override
    public void onAttach(@NonNull Context context) {
        super.onAttach(context);
        final var args = requireArguments();
        if (!args.containsKey(KEY_RESOURCES)) {
            throw new IllegalArgumentException("Provide at least " + KEY_RESOURCES);
        }
        //noinspection unchecked
        this.resources.addAll((ArrayList<OcsProjectResource>) Objects.requireNonNull(args.getSerializable(KEY_RESOURCES)));
        this.projectName = args.getString(KEY_PROJECT_NAME);
    }
    @NonNull
    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        binding = DialogProjectResourcesBinding.inflate(getLayoutInflater());
        viewModel = new ViewModelProvider(requireActivity()).get(EditCardViewModel.class);
        return new MaterialAlertDialogBuilder(requireContext())
                .setTitle(projectName)
                .setView(binding.getRoot())
                .setNeutralButton(R.string.simple_close, null)
                .create();
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        this.binding = null;
    }
    @Override
    public void onActivityCreated(@Nullable Bundle savedInstanceState) {
        final var adapter = new CardProjectResourceAdapter(viewModel, resources, requireActivity());
        binding.getRoot().setAdapter(adapter);
        super.onActivityCreated(savedInstanceState);
    }
    public static DialogFragment newInstance(@Nullable String projectName, @NonNull List<OcsProjectResource> resources) {
        final var fragment = new CardProjectResourcesDialog();
        final var args = new Bundle();
        args.putString(KEY_PROJECT_NAME, projectName);
        args.putSerializable(KEY_RESOURCES, new ArrayList<>(resources));
        fragment.setArguments(args);
        return fragment;
    }
}
package it.niedermann.nextcloud.deck.model.ocs;
import androidx.room.Entity;
import androidx.room.ForeignKey;
import androidx.room.Index;
import it.niedermann.nextcloud.deck.model.Account;
import it.niedermann.nextcloud.deck.model.Card;
import it.niedermann.nextcloud.deck.model.interfaces.AbstractRemoteEntity;
@Entity(inheritSuperIndices = true,
        indices = {
                @Index(value = "accountId", name = "activity_accID"),
                @Index(value = "cardId", name = "activity_cardID")
        },
        foreignKeys = {
                @ForeignKey(
                        entity = Card.class,
                        parentColumns = "localId",
                        childColumns = "cardId", onDelete = ForeignKey.CASCADE
                ),
                @ForeignKey(
                        entity = Account.class,
                        parentColumns = "id",
                        childColumns = "accountId", onDelete = ForeignKey.CASCADE
                )
        }
)
public class Activity extends AbstractRemoteEntity {
    private long cardId;
    private String subject;
    private int type;
    public long getCardId() {
        return cardId;
    }
    public void setCardId(long cardId) {
        this.cardId = cardId;
    }
    public String getSubject() {
        return subject;
    }
    public void setSubject(String subject) {
        this.subject = subject;
    }
    public int getType() {
        return type;
    }
    public void setType(int type) {
        this.type = type;
    }
//    {
//        "ocs": {
//        "meta": {
//            "status": "ok",
//                    "statuscode": 200,
//                    "message": "OK"
//        },
//        "data": [
//        {
//            "
//            ": 29067,
//                "app": "deck",
//                "type": "deck",
//                "user": "artur",
//                "subject": "You have created card test 3 in stack asdf on board Deck app",
//                "subject_rich": [
//            "You have created card {card} in stack {stack} on board {board}",
//                    {
//                            "user": {
//            "type": "user",
//                    "id": "artur",
//                    "name": "artur"
//        },
//            "card": {
//            "type": "highlight",
//                    "id": 156,
//                    "name": "test 3",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90//card/156"
//        },
//            "board": {
//            "type": "highlight",
//                    "id": 90,
//                    "name": "Deck app",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90/"
//        },
//            "stack": {
//            "type": "highlight",
//                    "id": 447,
//                    "name": "asdf"
//        }
//          }
//        ],
//            "message": "",
//                "message_rich": [
//            "",
//          []
//        ],
//            "object_type": "deck_card",
//                "object_id": 156,
//                "object_name": "test 3",
//                "objects": {
//            "156": "test 3"
//        },
//            "link": "",
//                "icon": "/apps/files/img/add-color.svg",
//                "datetime": "2019-09-16T15:47:07+00:00"
//        },
//        {
//            "activity_id": 29833,
//                "app": "deck",
//                "type": "deck",
//                "user": "artur",
//                "subject": "You have moved the card test 3 from stack asdf to asdf",
//                "subject_rich": [
//            "You have moved the card {card} from stack {stackBefore} to {stack}",
//                    {
//                            "user": {
//            "type": "user",
//                    "id": "artur",
//                    "name": "artur"
//        },
//            "card": {
//            "type": "highlight",
//                    "id": 156,
//                    "name": "test 3",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90//card/156"
//        },
//            "board": {
//            "type": "highlight",
//                    "id": 90,
//                    "name": "Deck app",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90/"
//        },
//            "stack": {
//            "type": "highlight",
//                    "id": 447,
//                    "name": "asdf"
//        },
//            "stackBefore": {
//            "type": "highlight",
//                    "id": 447,
//                    "name": "asdf"
//        },
//            "before": {
//            "type": "highlight",
//                    "id": 447,
//                    "name": 447
//        },
//            "after": {
//            "type": "highlight",
//                    "id": 460,
//                    "name": 460
//        }
//          }
//        ],
//            "message": "",
//                "message_rich": [
//            "",
//          []
//        ],
//            "object_type": "deck_card",
//                "object_id": 156,
//                "object_name": "test 3",
//                "objects": {
//            "156": "test 3"
//        },
//            "link": "",
//                "icon": "/apps/files/img/change.svg",
//                "datetime": "2019-09-17T10:41:37+00:00"
//        },
//        {
//            "activity_id": 29834,
//                "app": "deck",
//                "type": "deck_card_description",
//                "user": "artur",
//                "subject": "You have updated the description of card test 3 in stack asdfd on board Deck app",
//                "subject_rich": [
//            "You have updated the description of card {card} in stack {stack} on board {board}",
//                    {
//                            "user": {
//            "type": "user",
//                    "id": "artur",
//                    "name": "artur"
//        },
//            "card": {
//            "type": "highlight",
//                    "id": 156,
//                    "name": "test 3",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90//card/156"
//        },
//            "board": {
//            "type": "highlight",
//                    "id": 90,
//                    "name": "Deck app",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90/"
//        },
//            "stack": {
//            "type": "highlight",
//                    "id": 460,
//                    "name": "asdfd"
//        }
//          }
//        ],
//            "message": "<pre class=\"visualdiff\"></pre>",
//                "message_rich": [
//            "",
//          []
//        ],
//            "object_type": "deck_card",
//                "object_id": 156,
//                "object_name": "test 3",
//                "objects": {
//            "156": "test 3"
//        },
//            "link": "",
//                "icon": "/apps/files/img/change.svg",
//                "datetime": "2019-09-17T10:45:32+00:00"
//        },
//        {
//            "activity_id": 29835,
//                "app": "deck",
//                "type": "deck",
//                "user": "artur",
//                "subject": "You have added the tag To review to card test 3 in stack asdfd on board Deck app",
//                "subject_rich": [
//            "You have added the tag {label} to card {card} in stack {stack} on board {board}",
//                    {
//                            "user": {
//            "type": "user",
//                    "id": "artur",
//                    "name": "artur"
//        },
//            "card": {
//            "type": "highlight",
//                    "id": 156,
//                    "name": "test 3",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90//card/156"
//        },
//            "board": {
//            "type": "highlight",
//                    "id": 90,
//                    "name": "Deck app",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90/"
//        },
//            "stack": {
//            "type": "highlight",
//                    "id": 460,
//                    "name": "asdfd"
//        },
//            "label": {
//            "type": "highlight",
//                    "id": 397,
//                    "name": "To review"
//        }
//          }
//        ],
//            "message": "",
//                "message_rich": [
//            "",
//          []
//        ],
//            "object_type": "deck_card",
//                "object_id": 156,
//                "object_name": "test 3",
//                "objects": {
//            "156": "test 3"
//        },
//            "link": "",
//                "icon": "/apps/deck/img/deck-dark.svg",
//                "datetime": "2019-09-17T10:47:20+00:00"
//        },
//        {
//            "activity_id": 29836,
//                "app": "deck",
//                "type": "deck_card_description",
//                "user": "artur",
//                "subject": "You have updated the description of card test 3 in stack asdfd on board Deck app",
//                "subject_rich": [
//            "You have updated the description of card {card} in stack {stack} on board {board}",
//                    {
//                            "user": {
//            "type": "user",
//                    "id": "artur",
//                    "name": "artur"
//        },
//            "card": {
//            "type": "highlight",
//                    "id": 156,
//                    "name": "test 3",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90//card/156"
//        },
//            "board": {
//            "type": "highlight",
//                    "id": 90,
//                    "name": "Deck app",
//                    "link": "https://nextcloud.niedermann.it/index.php/apps/deck/#!/board/90/"
//        },
//            "stack": {
//            "type": "highlight",
//                    "id": 460,
//                    "name": "asdfd"
//        }
//          }
//        ],
//            "message": "<pre class=\"visualdiff\"><ins>great description.</ins></pre>",
//                "message_rich": [
//            "",
//          []
//        ],
//            "object_type": "deck_card",
//                "object_id": 156,
//                "object_name": "test 3",
//                "objects": {
//            "156": "test 3"
//        },
//            "link": "",
//                "icon": "/apps/files/img/change.svg",
//                "datetime": "2019-09-17T10:50:13+00:00"
//        }
//    ]
//    }
//    }
}
package it.niedermann.nextcloud.deck.ui.card.activities;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.fragment.app.Fragment;
import androidx.lifecycle.ViewModelProvider;
import it.niedermann.android.reactivelivedata.ReactiveLiveData;
import it.niedermann.nextcloud.deck.DeckLog;
import it.niedermann.nextcloud.deck.databinding.FragmentCardEditTabActivitiesBinding;
import it.niedermann.nextcloud.deck.ui.card.EditCardViewModel;
import it.niedermann.nextcloud.deck.ui.theme.ThemeUtils;
import it.niedermann.nextcloud.deck.ui.theme.Themed;
public class CardActivityFragment extends Fragment implements Themed {
    private FragmentCardEditTabActivitiesBinding binding;
    public static Fragment newInstance() {
        return new CardActivityFragment();
    }
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater,
                             ViewGroup container,
                             Bundle savedInstanceState) {
        binding = FragmentCardEditTabActivitiesBinding.inflate(inflater, container, false);
        final var viewModel = new ViewModelProvider(requireActivity()).get(EditCardViewModel.class);
        // This might be a zombie fragment with an empty EditCardViewModel after Android killed the activity (but not the fragment instance
        // See https://github.com/stefan-niedermann/nextcloud-deck/issues/478
        if (viewModel.getFullCard() == null) {
            DeckLog.logError(new IllegalStateException("Cannot populate " + CardActivityFragment.class.getSimpleName() + " because viewModel.getFullCard() is null"));
            return binding.getRoot();
        }
        final var adapter = new CardActivityAdapter(requireActivity().getMenuInflater());
        binding.activitiesList.setAdapter(adapter);
        new ReactiveLiveData<>(viewModel.syncActivitiesForCard(viewModel.getFullCard().getCard()))
                .combineWith(viewModel::getBoardColor)
                .observe(getViewLifecycleOwner(), data -> {
                    applyTheme(data.second);
                    if (data.first == null || data.first.size() == 0) {
                        binding.emptyContentView.setVisibility(View.VISIBLE);
                        binding.activitiesList.setVisibility(View.GONE);
                    } else {
                        binding.emptyContentView.setVisibility(View.GONE);
                        binding.activitiesList.setVisibility(View.VISIBLE);
                    }
                    adapter.setData(data.first, ThemeUtils.of(data.second, requireContext()));
                });
        return binding.getRoot();
    }
    @Override
    public void onDestroy() {
        super.onDestroy();
        this.binding = null;
    }
    @Override
    public void applyTheme(int color) {
        final var utils = ThemeUtils.of(color, requireContext());
        utils.deck.themeEmptyContentView(binding.emptyContentView);
    }
}
package it.niedermann.nextcloud.deck.ui.viewmodel;
import android.app.Application;
import androidx.annotation.NonNull;
import androidx.lifecycle.AndroidViewModel;
import androidx.lifecycle.ViewModel;
import java.util.concurrent.ExecutorService;
import it.niedermann.nextcloud.deck.repository.BaseRepository;
import it.niedermann.nextcloud.deck.util.ExecutorServiceProvider;
/**
 * To be used for {@link ViewModel}s which need an {@link BaseRepository} instance
 */
public abstract class BaseViewModel extends AndroidViewModel {
    protected final Application application;
    protected final BaseRepository baseRepository;
    protected final ExecutorService executor;
    public BaseViewModel(@NonNull Application application) {
        this(application, new BaseRepository(application));
    }
    public BaseViewModel(@NonNull Application application,
                         @NonNull BaseRepository baseRepository) {
        this(application, baseRepository, ExecutorServiceProvider.getLinkedBlockingQueueExecutor());
    }
    public BaseViewModel(@NonNull Application application,
                         @NonNull BaseRepository baseRepository,
                         @NonNull ExecutorService executor) {
        super(application);
        this.application = application;
        this.baseRepository = baseRepository;
        this.executor = executor;
    }
}