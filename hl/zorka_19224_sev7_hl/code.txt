package bsh;
import bsh.ast.*;
import bsh.interpreter.BshEvaluatingVisitor;
import bsh.interpreter.BshInterpreterUtil;
import org.objectweb.asm.*;
import org.objectweb.asm.Type;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;
/**
 * ClassGeneratorUtil utilizes the ASM (www.objectweb.org) bytecode generator
 * by Eric Bruneton in order to generate class "stubs" for BeanShell at
 * runtime.
 * <p/>
 * <p/>
 * Stub classes contain all of the fields of a BeanShell scripted class
 * as well as two "callback" references to BeanShell namespaces: one for
 * static methods and one for instance methods.  Methods of the class are
 * delegators which invoke corresponding methods on either the static or
 * instance bsh object and then unpack and return the results.  The static
 * namespace utilizes a static import to delegate variable access to the
 * class' static fields.  The instance namespace utilizes a dynamic import
 * (i.e. mixin) to delegate variable access to the class' instance variables.
 * <p/>
 * <p/>
 * Constructors for the class delegate to the static initInstance() method of
 * ClassGeneratorUtil to initialize new instances of the object.  initInstance()
 * invokes the instance intializer code (init vars and instance blocks) and
 * then delegates to the corresponding scripted constructor method in the
 * instance namespace.  Constructors contain special switch logic which allows
 * the BeanShell to control the calling of alternate constructors (this() or
 * super() references) at runtime.
 * <p/>
 * <p/>
 * Specially named superclass delegator methods are also generated in order to
 * allow BeanShell to access overridden methods of the superclass (which
 * reflection does not normally allow).
 * <p/>
 *
 * @author Pat Niemeyer
 */
/*
	Notes:
	It would not be hard to eliminate the use of org.objectweb.asm.Type from
	this class, making the distribution a tiny bit smaller.
*/
public class ClassGeneratorUtil implements Opcodes {
	/**
	 * The name of the static field holding the reference to the bsh
	 * static This (the callback namespace for static methods)
	 */
	static final String BSHSTATIC = "_bshStatic";
	/**
	 * The name of the instance field holding the reference to the bsh
	 * instance This (the callback namespace for instance methods)
	 */
	private static final String BSHTHIS = "_bshThis";
	/**
	 * The prefix for the name of the super delegate methods. e.g.
	 * _bshSuperfoo() is equivalent to super.foo()
	 */
	static final String BSHSUPER = "_bshSuper";
	/**
	 * The bsh static namespace variable name of the instance initializer
	 */
	static final String BSHINIT = "_bshInstanceInitializer";
	/**
	 * The bsh static namespace variable that holds the constructor methods
	 */
	private static final String BSHCONSTRUCTORS = "_bshConstructors";
	/**
	 * The switch branch number for the default constructor.
	 * The value -1 will cause the default branch to be taken.
	 */
	private static final int DEFAULTCONSTRUCTOR = -1;
	private static final String OBJECT = "Ljava/lang/Object;";
	private final String className;
	/**
	 * fully qualified class name (with package) e.g. foo/bar/Blah
	 */
	private final String fqClassName;
	private final Class superClass;
	private final String superClassName;
	private final Class[] interfaces;
	private final Variable[] vars;
	private final Constructor[] superConstructors;
	private final DelayedEvalBshMethod[] constructors;
	private final DelayedEvalBshMethod[] methods;
	private final NameSpace classStaticNameSpace;
	private final Modifiers classModifiers;
	private boolean isInterface;
	/**
	 * @param packageName e.g. "com.foo.bar"
	 */
	public ClassGeneratorUtil(Modifiers classModifiers, String className, String packageName, Class superClass, Class[] interfaces, Variable[] vars, DelayedEvalBshMethod[] bshmethods, NameSpace classStaticNameSpace, boolean isInterface) {
		this.classModifiers = classModifiers;
		this.className = className;
		if (packageName != null) {
			this.fqClassName = packageName.replace('.', '/') + "/" + className;
		} else {
			this.fqClassName = className;
		}
		if (superClass == null) {
			superClass = Object.class;
		}
		this.superClass = superClass;
		this.superClassName = Type.getInternalName(superClass);
		if (interfaces == null) {
			interfaces = new Class[0];
		}
		this.interfaces = interfaces;
		this.vars = vars;
		this.classStaticNameSpace = classStaticNameSpace;
		this.superConstructors = superClass.getDeclaredConstructors();
		// Split the methods into constructors and regular method lists
		List consl = new ArrayList();
		List methodsl = new ArrayList();
		String classBaseName = getBaseName(className); // for inner classes
		for (DelayedEvalBshMethod bshmethod : bshmethods) {
			if (bshmethod.getName().equals(classBaseName)) {
				consl.add(bshmethod);
			} else {
				methodsl.add(bshmethod);
			}
		}
		this.constructors = (DelayedEvalBshMethod[]) consl.toArray(new DelayedEvalBshMethod[consl.size()]);
		this.methods = (DelayedEvalBshMethod[]) methodsl.toArray(new DelayedEvalBshMethod[methodsl.size()]);
		try {
			classStaticNameSpace.setLocalVariable(BSHCONSTRUCTORS, constructors, false/*strict*/);
		} catch (UtilEvalError e) {
			throw new InterpreterError("can't set cons var");
		}
		this.isInterface = isInterface;
	}
	/**
	 * Generate the class bytecode for this class.
	 */
	public byte[] generateClass() {
		// Force the class public for now...
		int classMods = getASMModifiers(classModifiers) | ACC_PUBLIC;
		if (isInterface) {
			classMods |= (ACC_INTERFACE|ACC_ABSTRACT);
		}
		String[] interfaceNames = new String[interfaces.length + (isInterface ? 0 : 1)]; // one more interface for instance init callback
		for (int i = 0; i < interfaces.length; i++) {
			interfaceNames[i] = Type.getInternalName(interfaces[i]);
		}
		if ( ! isInterface) {
			interfaceNames[interfaces.length] = Type.getInternalName(GeneratedClass.class);
		}
		String sourceFile = "BeanShell Generated via ASM (www.objectweb.org)";
		ClassWriter cw = new ClassWriter(0);
		cw.visit(Opcodes.V1_6, classMods, fqClassName, null, superClassName, interfaceNames);
		if ( ! isInterface) {
			// Generate the bsh instance 'This' reference holder field
			generateField(BSHTHIS + className, "Lbsh/This;", ACC_PUBLIC, cw);
			// Generate the static bsh static reference holder field
			generateField(BSHSTATIC + className, "Lbsh/This;", ACC_PUBLIC + ACC_STATIC, cw);
		}
		// Generate the fields
		for (Variable var : vars) {
			String type = var.getTypeDescriptor();
			// Don't generate private or loosely typed fields
			// Note: loose types aren't currently parsed anyway...
			if (var.hasModifier("private") || type == null) {
				continue;
			}
			int modifiers;
			if (isInterface) {
				modifiers = ACC_PUBLIC | ACC_STATIC | ACC_FINAL;
			} else {
				modifiers = getASMModifiers(var.getModifiers());
			}
			generateField(var.getName(), type, modifiers, cw);
		}
		// Generate the constructors
		boolean hasConstructor = false;
		for (int i = 0; i < constructors.length; i++) {
			// Don't generate private constructors
			if (constructors[i].hasModifier("private")) {
				continue;
			}
			int modifiers = getASMModifiers(constructors[i].getModifiers());
			generateConstructor(i, constructors[i].getParamTypeDescriptors(), modifiers, cw);
			hasConstructor = true;
		}
		// If no other constructors, generate a default constructor
		if ( ! isInterface &&  ! hasConstructor) {
			generateConstructor(DEFAULTCONSTRUCTOR/*index*/, new String[0], ACC_PUBLIC, cw);
		}
		// Generate the delegate methods
		for (DelayedEvalBshMethod method : methods) {
			String returnType = method.getReturnTypeDescriptor();
			// Don't generate private /*or loosely return typed */ methods
			if (method.hasModifier("private") /*|| returnType == null*/) {
				continue;
			}
			int modifiers = getASMModifiers(method.getModifiers());
			if (isInterface) {
				modifiers |= (ACC_PUBLIC | ACC_ABSTRACT);
			}
			generateMethod(className, fqClassName, method.getName(), returnType, method.getParamTypeDescriptors(), modifiers, cw);
			boolean isStatic = (modifiers & ACC_STATIC) > 0;
			boolean overridden = classContainsMethod(superClass, method.getName(), method.getParamTypeDescriptors());
			if (!isStatic && overridden) {
				generateSuperDelegateMethod(superClassName, method.getName(), returnType, method.getParamTypeDescriptors(), modifiers, cw);
			}
		}
		return cw.toByteArray();
	}
	/**
	 * Translate bsh.Modifiers into ASM modifier bitflags.
	 */
	private static int getASMModifiers(Modifiers modifiers) {
		int mods = 0;
		if (modifiers == null) {
			return mods;
		}
		if (modifiers.hasModifier("public")) {
			mods += ACC_PUBLIC;
		}
		if (modifiers.hasModifier("protected")) {
			mods += ACC_PROTECTED;
		}
		if (modifiers.hasModifier("static")) {
			mods += ACC_STATIC;
		}
		if (modifiers.hasModifier("synchronized")) {
			mods += ACC_SYNCHRONIZED;
		}
		if (modifiers.hasModifier("abstract")) {
			mods += ACC_ABSTRACT;
		}
		return mods;
	}
	/**
	 * Generate a field - static or instance.
	 */
	private static void generateField(String fieldName, String type, int modifiers, ClassWriter cw) {
		cw.visitField(modifiers, fieldName, type, null, null);
	}
	/**
	 * Generate a delegate method - static or instance.
	 * The generated code packs the method arguments into an object array
	 * (wrapping primitive types in bsh.Primitive), invokes the static or
	 * instance namespace invokeMethod() method, and then unwraps / returns
	 * the result.
	 */
	private static void generateMethod(String className, String fqClassName, String methodName, String returnType, String[] paramTypes, int modifiers, ClassWriter cw) {
		String[] exceptions = null;
		boolean isStatic = (modifiers & ACC_STATIC) != 0;
		if (returnType == null) // map loose return type to Object
		{
			returnType = OBJECT;
		}
		String methodDescriptor = getMethodDescriptor(returnType, paramTypes);
		// Generate method body
		MethodVisitor cv = cw.visitMethod(modifiers, methodName, methodDescriptor, null, exceptions);
		if ((modifiers & ACC_ABSTRACT) != 0) {
			return;
		}
		// Generate code to push the BSHTHIS or BSHSTATIC field
		if (isStatic) {
			cv.visitFieldInsn(GETSTATIC, fqClassName, BSHSTATIC + className, "Lbsh/This;");
		} else {
			// Push 'this'
			cv.visitVarInsn(ALOAD, 0);
			// Get the instance field
			cv.visitFieldInsn(GETFIELD, fqClassName, BSHTHIS + className, "Lbsh/This;");
		}
		// Push the name of the method as a constant
		cv.visitLdcInsn(methodName);
		// Generate code to push arguments as an object array
		generateParameterReifierCode(paramTypes, isStatic, cv);
		// Push nulls for various args of invokeMethod
		cv.visitInsn(ACONST_NULL); // interpreter
		cv.visitInsn(ACONST_NULL); // callstack
		cv.visitInsn(ACONST_NULL); // callerinfo
		// Push the boolean constant 'true' (for declaredOnly)
		cv.visitInsn(ICONST_1);
		// Invoke the method This.invokeMethod( name, Class [] sig, boolean )
		cv.visitMethodInsn(INVOKEVIRTUAL, "bsh/This", "invokeMethod", Type.getMethodDescriptor(Type.getType(Object.class),
                new Type[]{Type.getType(String.class), Type.getType(Object[].class), Type.getType(Interpreter.class),
                        Type.getType(CallStack.class), Type.getType(SimpleNode.class), Type.getType(Boolean.TYPE)}));
		// Generate code to unwrap bsh Primitive types
		cv.visitMethodInsn(INVOKESTATIC, "bsh/Primitive", "unwrap", "(Ljava/lang/Object;)Ljava/lang/Object;");
		// Generate code to return the value
		generateReturnCode(returnType, cv);
		// Need to calculate this... just fudging here for now.
	    cv.visitMaxs(20, 20);
	}
	/**
	 * Generate a constructor.
	 */
	public void generateConstructor(int index, String[] paramTypes, int modifiers, ClassWriter cw) {
		/** offset after params of the args object [] var */
		final int argsVar = paramTypes.length + 1;
		/** offset after params of the ConstructorArgs var */
		final int consArgsVar = paramTypes.length + 2;
		String[] exceptions = null;
		String methodDescriptor = getMethodDescriptor("V", paramTypes);
		// Create this constructor method
		MethodVisitor cv = cw.visitMethod(modifiers, "<init>", methodDescriptor, null, exceptions);
		// Generate code to push arguments as an object array
		generateParameterReifierCode(paramTypes, false/*isStatic*/, cv);
		cv.visitVarInsn(ASTORE, argsVar);
		// Generate the code implementing the alternate constructor switch
		generateConstructorSwitch(index, argsVar, consArgsVar, cv);
		// Generate code to invoke the ClassGeneratorUtil initInstance() method
		// push 'this'
		cv.visitVarInsn(ALOAD, 0);
		// Push the class/constructor name as a constant
		cv.visitLdcInsn(className);
		// Push arguments as an object array
		cv.visitVarInsn(ALOAD, argsVar);
		// invoke the initInstance() method
		cv.visitMethodInsn(INVOKESTATIC, "bsh/ClassGeneratorUtil", "initInstance", "(L" + GeneratedClass.class.getName().replace('.', '/') + ";Ljava/lang/String;[Ljava/lang/Object;)V");
		cv.visitInsn(RETURN);
		// Need to calculate this... just fudging here for now.
		cv.visitMaxs(20, 20);
	}
	/**
	 * Generate a switch with a branch for each possible alternate
	 * constructor.  This includes all superclass constructors and all
	 * constructors of this class.  The default branch of this switch is the
	 * default superclass constructor.
	 * <p/>
	 * This method also generates the code to call the static
	 * ClassGeneratorUtil
	 * getConstructorArgs() method which inspects the scripted constructor to
	 * find the alternate constructor signature (if any) and evalute the
	 * arguments at runtime.  The getConstructorArgs() method returns the
	 * actual arguments as well as the index of the constructor to call.
	 */
	void generateConstructorSwitch(int consIndex, int argsVar, int consArgsVar, MethodVisitor cv) {
		Label defaultLabel = new Label();
		Label endLabel = new Label();
		int cases = superConstructors.length + constructors.length;
		Label[] labels = new Label[cases];
		for (int i = 0; i < cases; i++) {
			labels[i] = new Label();
		}
		// Generate code to call ClassGeneratorUtil to get our switch index
		// and give us args...
		// push super class name
		cv.visitLdcInsn(superClass.getName()); // use superClassName var?
		// push class static This object
		cv.visitFieldInsn(GETSTATIC, fqClassName, BSHSTATIC + className, "Lbsh/This;");
		// push args
		cv.visitVarInsn(ALOAD, argsVar);
		// push this constructor index number onto stack
		cv.visitIntInsn(BIPUSH, consIndex);
		// invoke the ClassGeneratorUtil getConstructorsArgs() method
		cv.visitMethodInsn(INVOKESTATIC, "bsh/ClassGeneratorUtil", "getConstructorArgs", "(Ljava/lang/String;Lbsh/This;[Ljava/lang/Object;I)" + "Lbsh/ClassGeneratorUtil$ConstructorArgs;");
		// store ConstructorArgs in consArgsVar
		cv.visitVarInsn(ASTORE, consArgsVar);
		// Get the ConstructorArgs selector field from ConstructorArgs
		// push ConstructorArgs
		cv.visitVarInsn(ALOAD, consArgsVar);
		cv.visitFieldInsn(GETFIELD, "bsh/ClassGeneratorUtil$ConstructorArgs", "selector", "I");
		// start switch
		cv.visitTableSwitchInsn(0/*min*/, cases - 1/*max*/, defaultLabel, labels);
		// generate switch body
		int index = 0;
		for (int i = 0; i < superConstructors.length; i++, index++) {
			doSwitchBranch(index, superClassName, getTypeDescriptors(superConstructors[i].getParameterTypes()), endLabel, labels, consArgsVar, cv);
		}
		for (int i = 0; i < constructors.length; i++, index++) {
			doSwitchBranch(index, fqClassName, constructors[i].getParamTypeDescriptors(), endLabel, labels, consArgsVar, cv);
		}
		// generate the default branch of switch
		cv.visitLabel(defaultLabel);
		// default branch always invokes no args super
		cv.visitVarInsn(ALOAD, 0); // push 'this'
		cv.visitMethodInsn(INVOKESPECIAL, superClassName, "<init>", "()V");
		// done with switch
		cv.visitLabel(endLabel);
	}
	/*
			 Generate a branch of the constructor switch.  This method is called by
			 generateConstructorSwitch.
			 The code generated by this method assumes that the argument array is
			 on the stack.
		 */
	private static void doSwitchBranch(int index, String targetClassName, String[] paramTypes, Label endLabel, Label[] labels, int consArgsVar, MethodVisitor cv) {
		cv.visitLabel(labels[index]);
		//cv.visitLineNumber( index, labels[index] );
		cv.visitVarInsn(ALOAD, 0); // push this before args
		// Unload the arguments from the ConstructorArgs object
		for (String type : paramTypes) {
			final String method;
			if (type.equals("Z")) {
				method = "getBoolean";
			} else if (type.equals("B")) {
				method = "getByte";
			} else if (type.equals("C")) {
				method = "getChar";
			} else if (type.equals("S")) {
				method = "getShort";
			} else if (type.equals("I")) {
				method = "getInt";
			} else if (type.equals("J")) {
				method = "getLong";
			} else if (type.equals("D")) {
				method = "getDouble";
			} else if (type.equals("F")) {
				method = "getFloat";
			} else {
				method = "getObject";
			}
			// invoke the iterator method on the ConstructorArgs
			cv.visitVarInsn(ALOAD, consArgsVar); // push the ConstructorArgs
			String className = "bsh/ClassGeneratorUtil$ConstructorArgs";
			String retType;
			if (method.equals("getObject")) {
				retType = OBJECT;
			} else {
				retType = type;
			}
			cv.visitMethodInsn(INVOKEVIRTUAL, className, method, "()" + retType);
			// if it's an object type we must do a check cast
			if (method.equals("getObject")) {
				cv.visitTypeInsn(CHECKCAST, descriptorToClassName(type));
			}
		}
		// invoke the constructor for this branch
		String descriptor = getMethodDescriptor("V", paramTypes);
		cv.visitMethodInsn(INVOKESPECIAL, targetClassName, "<init>", descriptor);
		cv.visitJumpInsn(GOTO, endLabel);
	}
	private static String getMethodDescriptor(String returnType, String[] paramTypes) {
		StringBuilder sb = new StringBuilder("(");
		for (String paramType : paramTypes) {
			sb.append(paramType);
		}
		sb.append(')').append(returnType);
		return sb.toString();
	}
	/**
	 * Generate a superclass method delegate accessor method.
	 * These methods are specially named methods which allow access to
	 * overridden methods of the superclass (which the Java reflection API
	 * normally does not allow).
	 */
	// Maybe combine this with generateMethod()
	private static void generateSuperDelegateMethod(String superClassName, String methodName, String returnType, String[] paramTypes, int modifiers, ClassWriter cw) {
		String[] exceptions = null;
		if (returnType == null) // map loose return to Object
		{
			returnType = OBJECT;
		}
		String methodDescriptor = getMethodDescriptor(returnType, paramTypes);
		// Add method body
		MethodVisitor cv = cw.visitMethod(modifiers, "_bshSuper" + methodName, methodDescriptor, null, exceptions);
		cv.visitVarInsn(ALOAD, 0);
		// Push vars
		int localVarIndex = 1;
		for (String paramType : paramTypes) {
			if (isPrimitive(paramType)) {
				cv.visitVarInsn(ILOAD, localVarIndex);
			} else {
				cv.visitVarInsn(ALOAD, localVarIndex);
			}
			localVarIndex += ((paramType.equals("D") || paramType.equals("J")) ? 2 : 1);
		}
		cv.visitMethodInsn(INVOKESPECIAL, superClassName, methodName, methodDescriptor);
		generatePlainReturnCode(returnType, cv);
		// Need to calculate this... just fudging here for now.
		cv.visitMaxs(20, 20);
	}
	boolean classContainsMethod(Class clas, String methodName, String[] paramTypes) {
		while (clas != null) {
			Method[] methods = clas.getDeclaredMethods();
			for (Method method : methods) {
				if (method.getName().equals(methodName)) {
					String[] methodParamTypes = getTypeDescriptors(method.getParameterTypes());
					boolean found = true;
					for (int j = 0; j < methodParamTypes.length; j++) {
						if (!paramTypes[j].equals(methodParamTypes[j])) {
							found = false;
							break;
						}
					}
					if (found) {
						return true;
					}
				}
			}
			clas = clas.getSuperclass();
		}
		return false;
	}
	/**
	 * Generate return code for a normal bytecode
	 */
	private static void generatePlainReturnCode(String returnType, MethodVisitor cv) {
		if (returnType.equals("V")) {
			cv.visitInsn(RETURN);
		} else if (isPrimitive(returnType)) {
			int opcode = IRETURN;
			if (returnType.equals("D")) {
				opcode = DRETURN;
			} else if (returnType.equals("F")) {
				opcode = FRETURN;
			} else if (returnType.equals("J"))  //long
			{
				opcode = LRETURN;
			}
			cv.visitInsn(opcode);
		} else {
			cv.visitTypeInsn(CHECKCAST, descriptorToClassName(returnType));
			cv.visitInsn(ARETURN);
		}
	}
	/**
	 * Generates the code to reify the arguments of the given method.
	 * For a method "int m (int i, String s)", this code is the bytecode
	 * corresponding to the "new Object[] { new bsh.Primitive(i), s }"
	 * expression.
	 *
	 * @param cv	   the code visitor to be used to generate the bytecode.
	 * @param isStatic the enclosing methods is static
	 * @author Eric Bruneton
	 * @author Pat Niemeyer
	 */
	private static void generateParameterReifierCode(String[] paramTypes, boolean isStatic, final MethodVisitor cv) {
		cv.visitIntInsn(SIPUSH, paramTypes.length);
		cv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
		int localVarIndex = isStatic ? 0 : 1;
		for (int i = 0; i < paramTypes.length; ++i) {
			String param = paramTypes[i];
			cv.visitInsn(DUP);
			cv.visitIntInsn(SIPUSH, i);
			if (isPrimitive(param)) {
				int opcode;
				if (param.equals("F")) {
					opcode = FLOAD;
				} else if (param.equals("D")) {
					opcode = DLOAD;
				} else if (param.equals("J")) {
					opcode = LLOAD;
				} else {
					opcode = ILOAD;
				}
				String type = "bsh/Primitive";
				cv.visitTypeInsn(NEW, type);
				cv.visitInsn(DUP);
				cv.visitVarInsn(opcode, localVarIndex);
				String desc = param; // ok?
				cv.visitMethodInsn(INVOKESPECIAL, type, "<init>", "(" + desc + ")V");
			} else {
				// Technically incorrect here - we need to wrap null values
				// as bsh.Primitive.NULL.  However the This.invokeMethod()
				// will do that much for us.
				// We need to generate a conditional here to test for null
				// and return Primitive.NULL
				cv.visitVarInsn(ALOAD, localVarIndex);
			}
			cv.visitInsn(AASTORE);
			localVarIndex += ((param.equals("D") || param.equals("J")) ? 2 : 1);
		}
	}
	/**
	 * Generates the code to unreify the result of the given method.  For a
	 * method "int m (int i, String s)", this code is the bytecode
	 * corresponding to the "((Integer)...).intValue()" expression.
	 *
	 * @param cv the code visitor to be used to generate the bytecode.
	 * @author Eric Bruneton
	 * @author Pat Niemeyer
	 */
	private static void generateReturnCode(String returnType, MethodVisitor cv) {
		if (returnType.equals("V")) {
			cv.visitInsn(POP);
			cv.visitInsn(RETURN);
		} else if (isPrimitive(returnType)) {
			int opcode = IRETURN;
			String type;
			String meth;
			if (returnType.equals("B")) {
				type = "java/lang/Byte";
				meth = "byteValue";
			} else if (returnType.equals("I")) {
				type = "java/lang/Integer";
				meth = "intValue";
			} else if (returnType.equals("Z")) {
				type = "java/lang/Boolean";
				meth = "booleanValue";
			} else if (returnType.equals("D")) {
				opcode = DRETURN;
				type = "java/lang/Double";
				meth = "doubleValue";
			} else if (returnType.equals("F")) {
				opcode = FRETURN;
				type = "java/lang/Float";
				meth = "floatValue";
			} else if (returnType.equals("J")) {
				opcode = LRETURN;
				type = "java/lang/Long";
				meth = "longValue";
			} else if (returnType.equals("C")) {
				type = "java/lang/Character";
				meth = "charValue";
			} else /*if (returnType.equals("S") )*/ {
				type = "java/lang/Short";
				meth = "shortValue";
			}
			String desc = returnType;
			cv.visitTypeInsn(CHECKCAST, type); // type is correct here
			cv.visitMethodInsn(INVOKEVIRTUAL, type, meth, "()" + desc);
			cv.visitInsn(opcode);
		} else {
			cv.visitTypeInsn(CHECKCAST, descriptorToClassName(returnType));
			cv.visitInsn(ARETURN);
		}
	}
	/**
	 * Evaluate the arguments (if any) for the constructor specified by
	 * the constructor index.  Return the ConstructorArgs object which
	 * contains the actual arguments to the alternate constructor and also the
	 * index of that constructor for the constructor switch.
	 *
	 * @param consArgs the arguments to the constructor.  These are necessary in
	 *                 the evaluation of the alt constructor args.  e.g. Foo(a) { super(a); }
	 * @return the ConstructorArgs object containing a constructor selector
	 *         and evaluated arguments for the alternate constructor
	 */
	public static ConstructorArgs getConstructorArgs(String superClassName, This classStaticThis, Object[] consArgs, int index) {
		DelayedEvalBshMethod[] constructors;
		try {
			constructors = (DelayedEvalBshMethod[]) classStaticThis.getNameSpace().getVariable(BSHCONSTRUCTORS);
		} catch (Exception e) {
			throw new InterpreterError("unable to get instance initializer: " + e);
		}
		if (index == DEFAULTCONSTRUCTOR) // auto-gen default constructor
		{
			return ConstructorArgs.DEFAULT;
		} // use default super constructor
		DelayedEvalBshMethod constructor = constructors[index];
		if (constructor.methodBody.jjtGetNumChildren() == 0) {
			return ConstructorArgs.DEFAULT;
		} // use default super constructor
		// Determine if the constructor calls this() or super()
		String altConstructor = null;
		BSHArguments argsNode = null;
		SimpleNode firstStatement = (SimpleNode) constructor.methodBody.jjtGetChild(0);
		if (firstStatement instanceof BSHPrimaryExpression) {
			firstStatement = (SimpleNode) firstStatement.jjtGetChild(0);
		}
		if (firstStatement instanceof BSHMethodInvocation) {
			BSHMethodInvocation methodNode = (BSHMethodInvocation) firstStatement;
			BSHAmbiguousName methodName = methodNode.getNameNode();
			if (methodName.text.equals("super") || methodName.text.equals("this")) {
				altConstructor = methodName.text;
				argsNode = methodNode.getArgsNode();
			}
		}
		if (altConstructor == null) {
			return ConstructorArgs.DEFAULT;
		} // use default super constructor
		// Make a tmp namespace to hold the original constructor args for
		// use in eval of the parameters node
		NameSpace consArgsNameSpace = new NameSpace(classStaticThis.getNameSpace(), "consArgs");
		String[] consArgNames = constructor.getParameterNames();
		Class[] consArgTypes = constructor.getParameterTypes();
		for (int i = 0; i < consArgs.length; i++) {
			try {
				consArgsNameSpace.setTypedVariable(consArgNames[i], consArgTypes[i], consArgs[i], null/*modifiers*/);
			} catch (UtilEvalError e) {
				throw new InterpreterError("err setting local cons arg:" + e);
			}
		}
		// evaluate the args
		CallStack callstack = new CallStack();
		callstack.push(consArgsNameSpace);
		Object[] args;
		Interpreter interpreter = classStaticThis.declaringInterpreter;
		try {
			args = new BshEvaluatingVisitor(callstack, interpreter).getArguments(argsNode);
		} catch (EvalError e) {
			throw new InterpreterError("Error evaluating constructor args: " + e);
		}
		Class[] argTypes = Types.getTypes(args);
		args = Primitive.unwrap(args);
		Class superClass = interpreter.getClassManager().classForName(superClassName);
		if (superClass == null) {
			throw new InterpreterError("can't find superclass: " + superClassName);
		}
		Constructor[] superCons = superClass.getDeclaredConstructors();
		// find the matching super() constructor for the args
		if (altConstructor.equals("super")) {
			int i = Reflect.findMostSpecificConstructorIndex(argTypes, superCons);
			if (i == -1) {
				throw new InterpreterError("can't find constructor for args!");
			}
			return new ConstructorArgs(i, args);
		}
		// find the matching this() constructor for the args
		Class[][] candidates = new Class[constructors.length][];
		for (int i = 0; i < candidates.length; i++) {
			candidates[i] = constructors[i].getParameterTypes();
		}
		int i = Reflect.findMostSpecificSignature(argTypes, candidates);
		if (i == -1) {
			throw new InterpreterError("can't find constructor for args 2!");
		}
		// this() constructors come after super constructors in the table
		int selector = i + superCons.length;
		int ourSelector = index + superCons.length;
		// Are we choosing ourselves recursively through a this() reference?
		if (selector == ourSelector) {
			throw new InterpreterError("Recusive constructor call.");
		}
		return new ConstructorArgs(selector, args);
	}
	private static final ThreadLocal<NameSpace> CONTEXT_NAMESPACE = new ThreadLocal<NameSpace>();
	private static final ThreadLocal<Interpreter> CONTEXT_INTERPRETER = new ThreadLocal<Interpreter>();
	/**
	 * Register actual context, used by generated class constructor, which calls
	 * {@link  #initInstance(GeneratedClass, String, Object[])}.
	 */
	public static void registerConstructorContext(CallStack callstack, Interpreter interpreter) {
		if (callstack != null) {
			CONTEXT_NAMESPACE.set(callstack.top());
		} else {
			CONTEXT_NAMESPACE.remove();
		}
		if (interpreter != null) {
			CONTEXT_INTERPRETER.set(interpreter);
		} else {
			CONTEXT_INTERPRETER.remove();
		}
	}
	/**
	 * Initialize an instance of the class.
	 * This method is called from the generated class constructor to evaluate
	 * the instance initializer and scripted constructor in the instance
	 * namespace.
	 */
	public static void initInstance(GeneratedClass instance, String className, Object[] args) {
		Class[] sig = Types.getTypes(args);
		CallStack callstack = new CallStack();
		Interpreter interpreter;
		NameSpace instanceNameSpace;
		// check to see if the instance has already been initialized
		// (the case if using a this() alternate constuctor)
		// todo PeJoBo70 write test for this
		This instanceThis = getClassInstanceThis(instance, className);
		// XXX clean up this conditional
		if (instanceThis == null) {
			// Create the instance 'This' namespace, set it on the object
			// instance and invoke the instance initializer
			// Get the static This reference from the proto-instance
			This classStaticThis = getClassStaticThis(instance.getClass(), className);
			interpreter = CONTEXT_INTERPRETER.get();
			if (interpreter == null) {
				interpreter = classStaticThis.declaringInterpreter;
			}
			// Get the instance initializer block from the static This
			BSHBlock instanceInitBlock;
			try {
				instanceInitBlock = (BSHBlock) classStaticThis.getNameSpace().getVariable(BSHINIT);
			} catch (Exception e) {
				throw new InterpreterError("unable to get instance initializer: " + e);
			}
			// Create the instance namespace
			if (CONTEXT_NAMESPACE.get() != null) {
				instanceNameSpace = classStaticThis.getNameSpace().copy();
				instanceNameSpace.setParent(CONTEXT_NAMESPACE.get());
			} else {
				instanceNameSpace = new NameSpace(classStaticThis.getNameSpace(), className); // todo: old code
			}
			instanceNameSpace.isClass = true;
			// Set the instance This reference on the instance
			instanceThis = instanceNameSpace.getThis(interpreter);
			try {
				LHS lhs = Reflect.getLHSObjectField(instance, BSHTHIS + className);
				lhs.assign(instanceThis, false/*strict*/);
			} catch (Exception e) {
				throw new InterpreterError("Error in class gen setup: " + e);
			}
			// Give the instance space its object import
			instanceNameSpace.setClassInstance(instance);
			// should use try/finally here to pop ns
			callstack.push(instanceNameSpace);
			// evaluate the instance portion of the block in it
			try { // Evaluate the initializer block
				new BshEvaluatingVisitor(callstack, interpreter).evalBlock(instanceInitBlock, true/*override*/, ClassGenerator.ClassNodeFilter.CLASSINSTANCE);
			} catch (Exception e) {
				throw new InterpreterError("Error in class initialization: " + e, e);
			}
			callstack.pop();
		} else {
			// The object instance has already been initialzed by another
			// constructor.  Fall through to invoke the constructor body below.
			interpreter = instanceThis.declaringInterpreter;
			instanceNameSpace = instanceThis.getNameSpace();
		}
		// invoke the constructor method from the instanceThis
		String constructorName = getBaseName(className);
		try {
			// Find the constructor (now in the instance namespace)
			BshMethod constructor = instanceNameSpace.getMethod(constructorName, sig, true/*declaredOnly*/);
			// if args, we must have constructor
			if (args.length > 0 && constructor == null) {
				throw new InterpreterError("Can't find constructor: " + className);
			}
			// Evaluate the constructor
			if (constructor != null) {
				constructor.invoke(args, new BshEvaluatingVisitor(callstack,  interpreter),
                        null/*callerInfo*/, false/*overrideNameSpace*/);
			}
		} catch (Throwable e) {
			if (e instanceof TargetError) {
				e = (Exception) ((TargetError) e).getTarget();
			}
			if (e instanceof InvocationTargetException) {
				e = (Exception) ((InvocationTargetException) e).getTargetException();
			}
			throw new InterpreterError("Error in class initialization: " + e);
		}
	}
	/**
	 * Get the static bsh namespace field from the class.
	 *
	 * @param className may be the name of clas itself or a superclass of clas.
	 */
	private static This getClassStaticThis(Class clas, String className) {
		try {
			return (This) Reflect.getStaticFieldValue(clas, BSHSTATIC + className);
		} catch (Exception e) {
			throw new InterpreterError("Unable to get class static space: " + e);
		}
	}
	/**
	 * Get the instance bsh namespace field from the object instance.
	 *
	 * @return the class instance This object or null if the object has not
	 *         been initialized.
	 */
	static This getClassInstanceThis(Object instance, String className) {
		try {
			Object o = Reflect.getObjectFieldValue(instance, BSHTHIS + className);
			return (This) Primitive.unwrap(o); // unwrap Primitive.Null to null
		} catch (Exception e) {
			throw new InterpreterError("Generated class: Error getting This" + e);
		}
	}
	/**
	 * Does the type descriptor string describe a primitive type?
	 */
	private static boolean isPrimitive(String typeDescriptor) {
		return typeDescriptor.length() == 1; // right?
	}
	private static String[] getTypeDescriptors(Class[] cparams) {
		String[] sa = new String[cparams.length];
		for (int i = 0; i < sa.length; i++) {
			sa[i] = BshInterpreterUtil.getTypeDescriptor(cparams[i]);
		}
		return sa;
	}
	/**
	 * If a non-array object type, remove the prefix "L" and suffix ";".
	 */
	// Can this be factored out...?
	// Should be be adding the L...; here instead?
	private static String descriptorToClassName(String s) {
		if (s.startsWith("[") || !s.startsWith("L")) {
			return s;
		}
		return s.substring(1, s.length() - 1);
	}
	private static String getBaseName(String className) {
		int i = className.indexOf("$");
		if (i == -1) {
			return className;
		}
		return className.substring(i + 1);
	}
	/**
	 * A ConstructorArgs object holds evaluated arguments for a constructor
	 * call as well as the index of a possible alternate selector to invoke.
	 * This object is used by the constructor switch.
	 *
	 * @see bsh.ClassGeneratorUtil# generateConstructor(int, String[], int, bsh.org.objectweb.asm.ClassWriter)
	 */
	public static class ConstructorArgs {
		/**
		 * A ConstructorArgs which calls the default constructor
		 */
		public static final ConstructorArgs DEFAULT = new ConstructorArgs();
		public int selector = DEFAULTCONSTRUCTOR;
		Object[] args;
		int arg;
		/**
		 * The index of the constructor to call.
		 */
		ConstructorArgs() {
		}
		ConstructorArgs(int selector, Object[] args) {
			this.selector = selector;
			this.args = args;
		}
		Object next() {
			return args[arg++];
		}
		public boolean getBoolean() {
			return (Boolean) next();
		}
		public byte getByte() {
			return (Byte) next();
		}
		public char getChar() {
			return (Character) next();
		}
		public short getShort() {
			return (Short) next();
		}
		public int getInt() {
			return (Integer) next();
		}
		public long getLong() {
			return (Long) next();
		}
		public double getDouble() {
			return (Double) next();
		}
		public float getFloat() {
			return (Float) next();
		}
		public Object getObject() {
			return next();
		}
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.*;
import java.util.Map;
import java.util.HashMap;
/**
	'This' is the type of bsh scripted objects.
	A 'This' object is a bsh scripted object context.  It holds a namespace 
	reference and implements event listeners and various other interfaces.
	This holds a reference to the declaring interpreter for callbacks from
	outside of bsh.
*/
public final class This implements java.io.Serializable, Runnable 
{
	/**
		The namespace that this This reference wraps.
	*/
	final NameSpace namespace;
	/**
		This is the interpreter running when the This ref was created.
		It's used as a default interpreter for callback through the This
		where there is no current interpreter instance 
		e.g. interface proxy or event call backs from outside of bsh.
	*/
	transient Interpreter declaringInterpreter;
	/**
		A cache of proxy interface handlers.
		Currently just one per interface.
	*/
	private Map<Integer,Object> interfaces;
	private final InvocationHandler invocationHandler = new Handler();
	/**
		getThis() is a factory for bsh.This type references.  The capabilities
		of ".this" references in bsh are version dependent up until jdk1.3.
		The version dependence was to support different default interface
		implementations.  i.e. different sets of listener interfaces which
		scripted objects were capable of implementing.  In jdk1.3 the 
		reflection proxy mechanism was introduced which allowed us to 
		implement arbitrary interfaces.  This is fantastic.
		A This object is a thin layer over a namespace, comprising a bsh object
		context.  We create it here only if needed for the namespace.
		Note: this method could be considered slow because of the way it 
		dynamically factories objects.  However I've also done tests where 
		I hard-code the factory to return JThis and see no change in the 
		rough test suite time.  This references are also cached in NameSpace.  
	*/
    static This getThis( 
		NameSpace namespace, Interpreter declaringInterpreter ) 
	{
		return new This( namespace, declaringInterpreter );
    }
	/**
		Get a version of this scripted object implementing the specified 
		interface.
	*/
	/**
		Get dynamic proxy for interface, caching those it creates.
	*/
	public Object getInterface( Class clas ) 
	{
		return getInterface( new Class[] { clas } );
	}
	/**
		Get dynamic proxy for interface, caching those it creates.
	*/
	public Object getInterface( Class [] ca ) 
	{
		if ( interfaces == null )
			interfaces = new HashMap<Integer,Object>();
		// Make a hash of the interface hashcodes in order to cache them
		int hash = 21;
		for(int i=0; i<ca.length; i++)
			hash *= ca[i].hashCode() + 3;
		Integer hashKey = new Integer(hash);
		Object interf = interfaces.get( hashKey );
		if ( interf == null ) 
		{
			ClassLoader classLoader = ca[0].getClassLoader(); // ?
			interf = Proxy.newProxyInstance( 
				classLoader, ca, invocationHandler );
			interfaces.put( hashKey, interf );
		}
		return interf;
	}
	/**
		This is the invocation handler for the dynamic proxy.
		<p>
		Notes:
		Inner class for the invocation handler seems to shield this unavailable
		interface from JDK1.2 VM...  
		
		I don't understand this.  JThis works just fine even if those
		classes aren't there (doesn't it?)  This class shouldn't be loaded
		if an XThis isn't instantiated in NameSpace.java, should it?
	*/
	class Handler implements InvocationHandler, java.io.Serializable 
	{
		public Object invoke( Object proxy, Method method, Object[] args ) 
			throws Throwable
		{
			try { 
				return invokeImpl( proxy, method, args );
			} catch ( TargetError te ) {
				// Unwrap target exception.  If the interface declares that 
				// it throws the ex it will be delivered.  If not it will be 
				// wrapped in an UndeclaredThrowable
				// This isn't simple because unwrapping this loses all context info.
				// So rewrap is better than unwrap.  - fschmidt
				Throwable t = te.getTarget();
				Class<? extends Throwable> c = t.getClass();
				String msg = t.getMessage();
				try {
					Throwable t2 = msg==null 
						? c.getConstructor().newInstance()
						: c.getConstructor(String.class).newInstance(msg)
					;
					t2.initCause(te);
					throw t2;
				} catch(NoSuchMethodException e) {
					throw t;
				}
			} catch ( EvalError ee ) {
				// Ease debugging...
				// XThis.this refers to the enclosing class instance
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( "EvalError in scripted interface: "
					+ This.this.toString() + ": "+ ee );
				throw ee;
			}
		}
		public Object invokeImpl( Object proxy, Method method, Object[] args ) 
			throws EvalError 
		{
			String methodName = method.getName();
			CallStack callstack = new CallStack( namespace );
			/*
				If equals() is not explicitly defined we must override the 
				default implemented by the This object protocol for scripted
				object.  To support XThis equals() must test for equality with 
				the generated proxy object, not the scripted bsh This object;
				otherwise callers from outside in Java will not see a the 
				proxy object as equal to itself.
			*/
			BshMethod equalsMethod = null;
			try {
				equalsMethod = namespace.getMethod( 
					"equals", new Class [] { Object.class } );
			} catch ( UtilEvalError e ) {/*leave null*/ }
			if ( methodName.equals("equals" ) && equalsMethod == null ) {
				Object obj = args[0];
				return proxy == obj;
			}
			/*
				If toString() is not explicitly defined override the default 
				to show the proxy interfaces.
			*/
			BshMethod toStringMethod = null;
			try {
				toStringMethod = 
					namespace.getMethod( "toString", new Class [] { } );
			} catch ( UtilEvalError e ) {/*leave null*/ }
			if ( methodName.equals("toString" ) && toStringMethod == null)
			{
				Class [] ints = proxy.getClass().getInterfaces();
				// XThis.this refers to the enclosing class instance
				StringBuilder sb = new StringBuilder( 
					This.this.toString() + "\nimplements:" );
				for(int i=0; i<ints.length; i++)
					sb.append( " "+ ints[i].getName() 
						+ ((ints.length > 1)?",":"") );
				return sb.toString();
			}
			Class [] paramTypes = method.getParameterTypes();
			return Primitive.unwrap( 
				invokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );
		}
	}
	This( NameSpace namespace, Interpreter declaringInterpreter ) {
		this.namespace = namespace; 
		this.declaringInterpreter = declaringInterpreter;
		//initCallStack( namespace );
	}
	public NameSpace getNameSpace() {
		return namespace;
	}
	public String toString() {
		return "'this' reference to Bsh object: " + namespace;
	}
	public void run() {
		try {
			invokeMethod( "run", new Object[0] );
		} catch( EvalError e ) {
			declaringInterpreter.error(
				"Exception in runnable:" + e );
		}
	}
	/**
		Invoke specified method as from outside java code, using the 
		declaring interpreter and current namespace.
		The call stack will indicate that the method is being invoked from
		outside of bsh in native java code.
		Note: you must still wrap/unwrap args/return values using 
		Primitive/Primitive.unwrap() for use outside of BeanShell.
		@see bsh.Primitive
	*/
	public Object invokeMethod( String name, Object [] args ) 
		throws EvalError
	{
		// null callstack, one will be created for us 
		return invokeMethod( 
			name, args, null/*declaringInterpreter*/, null, null, 
			false/*declaredOnly*/ );
	}
	/**
		Invoke a method in this namespace with the specified args,
		interpreter reference, callstack, and caller info.
		<p>
		Note: If you use this method outside of the bsh package and wish to 
		use variables with primitive values you will have to wrap them using 
		bsh.Primitive.  Consider using This getInterface() to make a true Java
		interface for invoking your scripted methods.
		<p>
		This method also implements the default object protocol of toString(), 
		hashCode() and equals() and the invoke() meta-method handling as a 
		last resort.
		<p>
		Note: The invoke() meta-method will not catch the Object protocol
		methods (toString(), hashCode()...).  If you want to override them you 
		have to script them directly.
		<p>
		@param callstack if callStack is null a new CallStack will be created and
			initialized with this namespace.
		@param declaredOnly if true then only methods declared directly in the
			namespace will be visible - no inherited or imported methods will
			be visible.
		@see bsh.Primitive
	*/
	/*
		invokeMethod() here is generally used by outside code to callback
		into the bsh interpreter. e.g. when we are acting as an interface
		for a scripted listener, etc.  In this case there is no real call stack
		so we make a default one starting with the special JAVACODE namespace
		and our namespace as the next.
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, 
		Interpreter interpreter, CallStack callstack, SimpleNode callerInfo,
		boolean declaredOnly  ) 
		throws EvalError
	{
		/*
			Wrap nulls.
			This is a bit of a cludge to address a deficiency in the class
			generator whereby it does not wrap nulls on method delegate.  See
			Class Generator.java.  If we fix that then we can remove this.
			(just have to generate the code there.)
		*/
		if ( args == null ) {
			args = new Object[0];
		} else {
			Object [] oa = new Object [args.length];
			for(int i=0; i<args.length; i++)
				oa[i] = ( args[i] == null ? Primitive.NULL : args[i] );
			args = oa;
		}
		if ( interpreter == null )
			interpreter = declaringInterpreter;
		if ( callstack == null )
			callstack = new CallStack( namespace );
		if ( callerInfo == null )
			callerInfo = SimpleNode.JAVACODE;
		// Find the bsh method
		Class [] types = Types.getTypes( args );
		BshMethod bshMethod = null;
		try {
			bshMethod = namespace.getMethod( methodName, types, declaredOnly );
		} catch ( UtilEvalError e ) {
			// leave null
		}
		if ( bshMethod != null )
			return bshMethod.invoke( args, new BshEvaluatingVisitor(callstack,  interpreter), callerInfo );
		/*
			No scripted method of that name.
			Implement the required part of the Object protocol:
				public int hashCode();
				public boolean equals(java.lang.Object);
				public java.lang.String toString();
			if these were not handled by scripted methods we must provide
			a default impl.
		*/
		// a default toString() that shows the interfaces we implement
		if ( methodName.equals("toString") && args.length==0 )
			return toString();
		// a default hashCode()
		if ( methodName.equals("hashCode") && args.length==0 )
			return new Integer(this.hashCode());
		// a default equals() testing for equality with the This reference
		if ( methodName.equals("equals") && args.length==1 ) {
			Object obj = args[0];
			return new Boolean( this == obj );
		}
		// a default clone()
		if ( methodName.equals("clone") && args.length==0 ) {
			NameSpace ns = new NameSpace(namespace,namespace.getName()+" clone");
			try {
				for( String varName : namespace.getVariableNames() ) {
					ns.setLocalVariable(varName,namespace.getVariable(varName,false),false);
				}
				for( BshMethod method : namespace.getMethods() ) {
					ns.setMethod(method);
				}
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
			}
			return ns.getThis(declaringInterpreter);
		}
		// Look for a default invoke() handler method in the namespace
		// Note: this code duplicates that in NameSpace getCommand()
		// is that ok?
		try {
			bshMethod = namespace.getMethod( 
				"invoke", new Class [] { null, null } );
		} catch ( UtilEvalError e ) { /*leave null*/ }
		// Call script "invoke( String methodName, Object [] args );
		if ( bshMethod != null )
			return bshMethod.invoke( new Object [] { methodName, args }, 
				new BshEvaluatingVisitor(callstack,  interpreter), callerInfo );
		throw new EvalError("Method " + 
			StringUtil.methodString( methodName, types ) +
			" not found in bsh scripted object: "+ namespace.getName(), 
			callerInfo, callstack );
	}
	/**
		Bind a This reference to a parent's namespace with the specified
		declaring interpreter.  Also re-init the callstack.  It's necessary 
		to bind a This reference before it can be used after deserialization.
		This is used by the bsh load() command.
		<p>
		This is a static utility method because it's used by a bsh command
		bind() and the interpreter doesn't currently allow access to direct 
		methods of This objects (small hack)
	*/
	public static void bind( 
		This ths, NameSpace namespace, Interpreter declaringInterpreter ) 
	{ 
		ths.namespace.setParent( namespace ); 
		ths.declaringInterpreter = declaringInterpreter;
	}
	/**
		Allow invocations of these method names on This type objects.
		Don't give bsh.This a chance to override their behavior.
		<p>
		If the method is passed here the invocation will actually happen on
		the bsh.This object via the regular reflective method invocation 
		mechanism.  If not, then the method is evaluated by bsh.This itself
		as a scripted method call.
	*/
	static boolean isExposedThisMethod( String name ) 
	{
		return 
			name.equals("getClass") 
			|| name.equals("invokeMethod")
			|| name.equals("getInterface")
			// These are necessary to let us test synchronization from scripts
			|| name.equals("wait") 
			|| name.equals("notify")
			|| name.equals("notifyAll");
	}
}
package bsh;
import bsh.ast.*;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.*;
import java.util.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public final class ClassGenerator {
    private static ClassGenerator cg;
	private static final String DEBUG_DIR = System.getProperty("bsh.debugClasses");
	public static ClassGenerator getClassGenerator() {
        if (cg == null) {
            cg = new ClassGenerator();
        }
        return cg;
    }
    /**
     * Parse the BSHBlock for the class definition and generate the class.
     */
    public Class generateClass(String name, Modifiers modifiers, Class[] interfaces,
                               Class superClass, BSHBlock block, boolean isInterface,
                               CallStack callstack, Interpreter interpreter) throws EvalError {
        // Delegate to the static method
        return generateClassImpl(name, modifiers, interfaces, superClass, block, isInterface,
                new BshEvaluatingVisitor(callstack, interpreter));
    }
    /**
     * Invoke a super.method() style superclass method on an object instance.
     * This is not a normal function of the Java reflection API and is
     * provided by generated class accessor methods.
     */
    public Object invokeSuperclassMethod(BshClassManager bcm, Object instance,
                                         String methodName, Object[] args) throws UtilEvalError,
            ReflectError, InvocationTargetException {
        // Delegate to the static method
        return invokeSuperclassMethodImpl(bcm, instance, methodName, args);
    }
    /**
     * Change the parent of the class instance namespace.
     * This is currently used for inner class support.
     * Note: This method will likely be removed in the future.
     */
    // This could be static
    public void setInstanceNameSpaceParent(Object instance, String className, NameSpace parent) {
        This ithis = ClassGeneratorUtil.getClassInstanceThis(instance, className);
        ithis.getNameSpace().setParent(parent);
    }
    /**
     * Parse the BSHBlock for for the class definition and generate the class
     * using ClassGenerator.
     */
    public static Class generateClassImpl(String name, Modifiers modifiers, Class[] interfaces,
            Class superClass, BSHBlock block, boolean isInterface,
            BshEvaluatingVisitor visitor) throws EvalError {
        // Scripting classes currently requires accessibility
        // This can be eliminated with a bit more work.
        try {
            Capabilities.setAccessibility(true);
        } catch (Capabilities.Unavailable e) {
            throw new EvalError("Defining classes currently requires reflective Accessibility.",
                    block, visitor.getCallstack());
        }
        NameSpace enclosingNameSpace = visitor.getCallstack().top();
        String packageName = enclosingNameSpace.getPackage();
        String className = enclosingNameSpace.isClass ? (enclosingNameSpace.getName() + "$" + name) : name;
        String fqClassName = packageName == null ? className : packageName + "." + className;
        BshClassManager bcm = visitor.getInterpreter().getClassManager();
        // Race condition here...
        bcm.definingClass(fqClassName);
        // Create the class static namespace
        NameSpace classStaticNameSpace = new NameSpace(enclosingNameSpace, className);
        classStaticNameSpace.isClass = true;
        visitor.getCallstack().push(classStaticNameSpace);
        // Evaluate any inner class class definitions in the block
        // effectively recursively call this method for contained classes first
        visitor.evalBlock(block, true/*override*/, ClassNodeFilter.CLASSCLASSES);
        // Generate the type for our class
        Variable[] variables = getDeclaredVariables(block, visitor, packageName);
        DelayedEvalBshMethod[] methods = getDeclaredMethods(block, visitor, packageName);
        ClassGeneratorUtil classGenerator = new ClassGeneratorUtil(modifiers, className, packageName, superClass, interfaces, variables, methods, classStaticNameSpace, isInterface);
        byte[] code = classGenerator.generateClass();
        // if debug, write out the class file to debugClasses directory
		if (DEBUG_DIR != null) try {
            FileOutputStream out = new FileOutputStream(DEBUG_DIR + '/' + className + ".class");
            out.write(code);
            out.close();
        } catch (IOException e) {
            throw new IllegalStateException("cannot create file " + DEBUG_DIR + '/' + className + ".class", e);
        }
        // Define the new class in the classloader
        Class genClass = bcm.defineClass(fqClassName, code);
        // import the unq name into parent
        enclosingNameSpace.importClass(fqClassName.replace('$', '.'));
        try {
            classStaticNameSpace.setLocalVariable(ClassGeneratorUtil.BSHINIT, block, false/*strictJava*/);
        } catch (UtilEvalError e) {
            throw new InterpreterError("unable to init static: " + e);
        }
        // Give the static space its class static import
        // important to do this after all classes are defined
        classStaticNameSpace.setClassStatic(genClass);
        // evaluate the static portion of the block in the static space
        visitor.evalBlock(block, true/*override*/, ClassNodeFilter.CLASSSTATIC);
        visitor.getCallstack().pop();
        if ( ! genClass.isInterface()) {
            // Set the static bsh This callback
            String bshStaticFieldName = ClassGeneratorUtil.BSHSTATIC + className;
            try {
                LHS lhs = Reflect.getLHSStaticField(genClass, bshStaticFieldName);
                lhs.assign(classStaticNameSpace.getThis(visitor.getInterpreter()), false/*strict*/);
            } catch (Exception e) {
                throw new InterpreterError("Error in class gen setup: " + e);
            }
        }
        bcm.doneDefiningClass(fqClassName);
        return genClass;
    }
    static Variable[] getDeclaredVariables(BSHBlock body, BshEvaluatingVisitor visitor, String defaultPackage) {
        List<Variable> vars = new ArrayList<Variable>();
        for (int child = 0; child < body.jjtGetNumChildren(); child++) {
            SimpleNode node = (SimpleNode) body.jjtGetChild(child);
            if (node instanceof BSHTypedVariableDeclaration) {
                BSHTypedVariableDeclaration tvd = (BSHTypedVariableDeclaration) node;
                Modifiers modifiers = tvd.modifiers;
                String type = visitor.getTypeDescriptor(tvd.getTypeNode(), defaultPackage);
                BSHVariableDeclarator[] vardec = tvd.getDeclarators();
                for (BSHVariableDeclarator aVardec : vardec) {
                    String name = aVardec.name;
                    try {
                        Variable var = new Variable(name, type, null/*value*/, modifiers);
                        vars.add(var);
                    } catch (UtilEvalError e) {
                        // value error shouldn't happen
                    }
                }
            }
        }
        return vars.toArray(new Variable[vars.size()]);
    }
    static DelayedEvalBshMethod[] getDeclaredMethods(BSHBlock body,
           BshEvaluatingVisitor visitor, String defaultPackage) throws EvalError {
        List<DelayedEvalBshMethod> methods = new ArrayList<DelayedEvalBshMethod>();
        for (int child = 0; child < body.jjtGetNumChildren(); child++) {
            SimpleNode node = (SimpleNode) body.jjtGetChild(child);
            if (node instanceof BSHMethodDeclaration) {
                BSHMethodDeclaration md = (BSHMethodDeclaration) node;
                md.insureNodesParsed();
                Modifiers modifiers = md.modifiers;
                String name = md.name;
                String returnType = visitor.getReturnTypeDescriptor(md, defaultPackage);
                BSHReturnType returnTypeNode = visitor.getReturnTypeNode(md);
                BSHFormalParameters paramTypesNode = md.paramsNode;
                String[] paramTypes = visitor.getTypeDescriptors(paramTypesNode, defaultPackage);
                DelayedEvalBshMethod bm = new DelayedEvalBshMethod(name, returnType, returnTypeNode,
                        md.paramsNode.getParamNames(), paramTypes, paramTypesNode, md.blockNode,
                        null/*declaringNameSpace*/, modifiers,
                        visitor);
                methods.add(bm);
            }
        }
        return methods.toArray(new DelayedEvalBshMethod[methods.size()]);
    }
    /**
     * A node filter that filters nodes for either a class body static
     * initializer or instance initializer.  In the static case only static
     * members are passed, etc.
     */
    static class ClassNodeFilter implements BSHBlock.NodeFilter {
        public static final int STATIC = 0, INSTANCE = 1, CLASSES = 2;
        public static ClassNodeFilter CLASSSTATIC = new ClassNodeFilter(STATIC);
        public static ClassNodeFilter CLASSINSTANCE = new ClassNodeFilter(INSTANCE);
        public static ClassNodeFilter CLASSCLASSES = new ClassNodeFilter(CLASSES);
        int context;
        private ClassNodeFilter(int context) {
            this.context = context;
        }
        public boolean isVisible(SimpleNode node) {
            if (context == CLASSES) return node instanceof BSHClassDeclaration;
            // Only show class decs in CLASSES
            if (node instanceof BSHClassDeclaration) return false;
            if (context == STATIC) return isStatic(node);
            if (context == INSTANCE) return !isStatic(node);
            // ALL
            return true;
        }
        boolean isStatic(SimpleNode node) {
            if (node instanceof BSHTypedVariableDeclaration)
                return ((BSHTypedVariableDeclaration) node).modifiers != null
                        && ((BSHTypedVariableDeclaration) node).modifiers.hasModifier("static");
            if (node instanceof BSHMethodDeclaration)
                return ((BSHMethodDeclaration) node).modifiers != null
                        && ((BSHMethodDeclaration) node).modifiers.hasModifier("static");
            // need to add static block here
            if (node instanceof BSHBlock) return false;
            return false;
        }
    }
    public static Object invokeSuperclassMethodImpl(BshClassManager bcm, Object instance,
                                                    String methodName, Object[] args)
            throws UtilEvalError, ReflectError, InvocationTargetException {
        String superName = ClassGeneratorUtil.BSHSUPER + methodName;
        // look for the specially named super delegate method
        Class clas = instance.getClass();
        Method superMethod = Reflect.resolveJavaMethod(bcm, clas, superName, Types.getTypes(args), false/*onlyStatic*/);
        if (superMethod != null) return Reflect.invokeMethod(superMethod, instance, args);
        // No super method, try to invoke regular method
        // could be a superfluous "super." which is legal.
        Class superClass = clas.getSuperclass();
        superMethod = Reflect.resolveExpectedJavaMethod(bcm, superClass, instance, methodName, args, false/*onlyStatic*/);
        return Reflect.invokeMethod(superMethod, instance, args);
    }
}
package bsh;
import bsh.ast.SimpleNode;
/**
 * An internal error in the interpreter has occurred.
 */
public class InterpreterError extends RuntimeException {
	public InterpreterError(final String s) {
		super(s);
	}
    public InterpreterError(final String s, final SimpleNode node) {
        super(s + " (at " + node.getSourceFile() + ":" + node.getLineNumber() + "\n" + node.getText());
    }
	public InterpreterError(final String s, final Throwable cause) {
		super(s, cause);
	}
}
package bsh;
import java.lang.reflect.Field;
import java.util.Hashtable;
/**
	An LHS is a wrapper for an variable, field, or property.  It ordinarily 
	holds the "left hand side" of an assignment and may be either resolved to 
	a value or assigned a value.
	<p>
	
	There is one special case here termed METHOD_EVAL where the LHS is used
	in an intermediate evaluation of a chain of suffixes and wraps a method
	invocation.  In this case it may only be resolved to a value and cannot be 
	assigned.  (You can't assign a value to the result of a method call e.g.
	"foo() = 5;").
	<p>
*/
public class LHS implements ParserConstants, java.io.Serializable
{
	NameSpace nameSpace;
	/** The assignment should be to a local variable */
	boolean localVar;
	/**
		Identifiers for the various types of LHS.
	*/
	static final int
		VARIABLE = 0,
		FIELD = 1,
		PROPERTY = 2,
		INDEX = 3,
		METHOD_EVAL = 4;
	int type;
	String varName;
	String propName;
	Field field;
	Object object;
	int index;
/**
		Variable LHS constructor.
*/
	public LHS( NameSpace nameSpace, String varName )
	{
throw new Error("namespace lhs");
/*
		type = VARIABLE;
		this.varName = varName;
		this.nameSpace = nameSpace;
*/
	}
	/**
		@param localVar if true the variable is set directly in the This
		reference's local scope.  If false recursion to look for the variable
		definition in parent's scope is allowed. (e.g. the default case for
		undefined vars going to global).
	*/
	public LHS( NameSpace nameSpace, String varName, boolean localVar )
	{
		type = VARIABLE;
		this.localVar = localVar;
		this.varName = varName;
		this.nameSpace = nameSpace;
	}
	/**
		Static field LHS Constructor.
		This simply calls Object field constructor with null object.
	*/
	public LHS( Field field )
	{
		type = FIELD;
		this.object = null;
		this.field = field;
	}
	/**
		Object field LHS Constructor.
	*/
	public LHS( Object object, Field field )
	{
		if ( object == null)
			throw new NullPointerException("constructed empty LHS");
		type = FIELD;
		this.object = object;
		this.field = field;
	}
	/**
		Object property LHS Constructor.
	*/
	public LHS( Object object, String propName )
	{
		if(object == null)
			throw new NullPointerException("constructed empty LHS");
		type = PROPERTY;
		this.object = object;
		this.propName = propName;
	}
	/**
		Array index LHS Constructor.
	*/
	public LHS( Object array, int index )
	{
		if(array == null)
			throw new NullPointerException("constructed empty LHS");
		type = INDEX;
		this.object = array;
		this.index = index;
	}
	public Object getValue() throws UtilEvalError
	{
		if ( type == VARIABLE )
			return nameSpace.getVariable( varName );
		if (type == FIELD)
			try {
				Object o = field.get( object );
				return Primitive.wrap( o, field.getType() );
			} catch(IllegalAccessException e2) {
				throw new UtilEvalError("Can't read field: " + field);
			}
		if ( type == PROPERTY )
			try {
				return Reflect.getObjectProperty(object, propName);
			}
			catch(ReflectError e) {
				Interpreter.debug(e.getMessage());
				throw new UtilEvalError("No such property: " + propName);
			}
		if ( type == INDEX )
			try {
				return Reflect.getIndex(object, index);
			}
			catch(Exception e) {
				throw new UtilEvalError("Array access: " + e);
			}
		throw new InterpreterError("LHS type");
	}
	/**
		Assign a value to the LHS.
	*/
	public Object assign( Object val, boolean strictJava ) 
		throws UtilEvalError
	{
		if ( type == VARIABLE )
		{
			// Set the variable in namespace according to localVar flag
			if ( localVar )
				nameSpace.setLocalVariable( varName, val, strictJava );
			else
				nameSpace.setVariable( varName, val, strictJava );
		} else 
		if ( type == FIELD )
		{
			try {
				Object fieldVal = val instanceof Primitive ?  
					((Primitive)val).getValue() : val;
				// This should probably be in Reflect.java
				field.setAccessible(true);
				field.set( object, fieldVal );
				return val;
			}
			catch( NullPointerException e) {   
    			throw new UtilEvalError(
					"LHS ("+field.getName()+") not a static field.",e);
			}     
   			catch( IllegalAccessException e2) {   
				throw new UtilEvalError(
					"LHS ("+field.getName()+") can't access field: "+e2,e2);
			}     
			catch( IllegalArgumentException e3) 
			{
				String type = val instanceof Primitive ?
					((Primitive)val).getType().getName()
					: val.getClass().getName();
				throw new UtilEvalError(
					"Argument type mismatch. " + (val == null ? "null" : type )
					+ " not assignable to field "+field.getName());
			}
		}
		else 
		if ( type == PROPERTY )
		{
			/*
			if ( object instanceof Hashtable )
				((Hashtable)object).put(propName, val);
			*/
			CollectionManager cm = CollectionManager.getCollectionManager();
			if ( cm.isMap( object ) )
				cm.putInMap( object/*map*/, propName, val );
			else
				try {
					Reflect.setObjectProperty(object, propName, val);
				}
				catch(ReflectError e) {
					Interpreter.debug("Assignment: " + e.getMessage());
					throw new UtilEvalError("No such property: " + propName);
				}
		} else 
		if ( type == INDEX )
			try {
				Reflect.setIndex(object, index, val);
			} catch ( UtilTargetError e1 ) { // pass along target error
				throw e1;
			} catch ( Exception e ) {
				throw new UtilEvalError("Assignment: " + e.getMessage());
			}
		else
			throw new InterpreterError("unknown lhs");
		return val;
	}
	public String toString() { 
		return "LHS: "
			+((field!=null)? "field = "+field.toString():"")
			+(varName!=null ? " varName = "+varName: "")
			+(nameSpace!=null ? " nameSpace = "+nameSpace.toString(): "");
	}
}
package bsh.interpreter;
import bsh.*;
import bsh.ast.BSHAssignment;
import bsh.ast.SimpleNode;
/**
 * This file is a part of ZOOLA - an extensible BeanShell implementation.
 * Zoola is based on original BeanShell code created by Pat Niemeyer.
 * <p/>
 * Original BeanShell code is Copyright (C) 2000 Pat Niemeyer <pat@pat.net>.
 * <p/>
 * New portions are Copyright 2012 Rafal Lewczuk <rafal.lewczuk@jitlogic.com>
 * <p/>
 * This is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Lesser General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 * <p/>
 * This software is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * <p/>
 * You should have received a copy of the GNU Lesser General Public License
 * along with ZOOLA. If not, see <http://www.gnu.org/licenses/>.
 */
public class BshInterpreterUtil {
    public static boolean evaluateCondition(
		SimpleNode condExp, BshEvaluatingVisitor visitor)
		throws EvalError
    {
        CallStack callstack = visitor.getCallstack();
        Interpreter interpreter = visitor.getInterpreter();
        Object obj = condExp.accept(visitor);
        if(obj instanceof Primitive) {
			if ( obj == Primitive.VOID )
				throw new EvalError("Condition evaluates to void type",
					condExp, callstack );
            obj = ((Primitive)obj).getValue();
		}
        if(obj instanceof Boolean)
            return ((Boolean)obj).booleanValue();
        else
            throw new EvalError(
				"Condition must evaluate to a Boolean or boolean.",
				condExp, callstack );
    }
    /**
     */
    public static int getIndexAux(
            Object obj, BshEvaluatingVisitor visitor,
            SimpleNode callerInfo )
            throws EvalError
    {
        if ( !obj.getClass().isArray() )
            throw new EvalError("Not an array", callerInfo, visitor.getCallstack() );
        int index;
        try {
            Object indexVal =
                    ((SimpleNode)callerInfo.jjtGetChild(0)).accept(visitor);
            if ( !(indexVal instanceof Primitive) )
                indexVal = Types.castObject(
                        indexVal, Integer.TYPE, Types.ASSIGNMENT);
            index = ((Primitive)indexVal).intValue();
        } catch( UtilEvalError e ) {
            Interpreter.debug("doIndex: "+e);
            throw e.toEvalError(
                    "Arrays may only be indexed by integer types.",
                    callerInfo, visitor.getCallstack() );
        }
        return index;
    }
    public static Object operation(BSHAssignment node, Object lhs, Object rhs, int kind )
            throws UtilEvalError
    {
        /*
              Implement String += value;
              According to the JLS, value may be anything.
              In BeanShell, we'll disallow VOID (undefined) values.
              (or should we map them to the empty string?)
          */
        if ( lhs instanceof String && rhs != Primitive.VOID ) {
            if ( kind != ParserConstants.PLUS )
                throw new UtilEvalError(
                        "Use of non + operator with String LHS" );
            return (String)lhs + rhs;
        }
        if ( lhs instanceof Primitive || rhs instanceof Primitive )
            if(lhs == Primitive.VOID || rhs == Primitive.VOID)
                throw new UtilEvalError(
                        "Illegal use of undefined object or 'void' literal" );
            else if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                throw new UtilEvalError(
                        "Illegal use of null object or 'null' literal" );
        if( (lhs instanceof Boolean || lhs instanceof Character ||
                lhs instanceof Number || lhs instanceof Primitive) &&
                (rhs instanceof Boolean || rhs instanceof Character ||
                        rhs instanceof Number || rhs instanceof Primitive) )
        {
            return Primitive.binaryOperation(lhs, rhs, kind);
        }
        throw new UtilEvalError("Non primitive value in operator: " +
                lhs.getClass() + " " + node.tokenImage[kind] + " " + rhs.getClass() );
    }
    public static String getTypeDescriptor( Class clas )
    {
        if ( clas == Boolean.TYPE ) return "Z";
        if ( clas == Character.TYPE ) return "C";
        if ( clas == Byte.TYPE ) return "B";
        if ( clas == Short.TYPE ) return "S";
        if ( clas == Integer.TYPE ) return "I";
        if ( clas == Long.TYPE ) return "J";
        if ( clas == Float.TYPE ) return "F";
        if ( clas == Double.TYPE ) return "D";
        if ( clas == Void.TYPE ) return "V";
        // Is getName() ok?  test with 1.1
        String name = clas.getName().replace('.','/');
        if ( name.startsWith("[") || name.endsWith(";") )
            return name;
        else
            return "L"+ name.replace('.','/') +";";
    }
}
package bsh.ast;
import bsh.*;
/*
    Note: great care (and lots of typing) were taken to insure that the
    namespace and interpreter references are passed on the stack and not
    (as they were erroneously before) installed in instance variables...
    Each of these node objects must be re-entrable to allow for recursive
    situations.
    The only data which should really be stored in instance vars here should
    be parse tree data... features of the node which should never change (e.g.
    the number of arguments, etc.)
    Exceptions would be public fields of simple classes that just publish
    data produced by the last eval()... data that is used immediately. We'll
    try to remember to mark these as transient to highlight them.
*/
public class SimpleNode implements Node
{
	public static SimpleNode JAVACODE =
		new SimpleNode( -1 ) {
			public String getSourceFile() {
				return "<Called from Java Code>";
			}
			public int getLineNumber() {
				return -1;
			}
			public String getText()  {
				return "<Compiled Java Code>";
			}
		};
	protected Node parent;
	protected Node[] children;
	protected int id;
	public Token firstToken, lastToken;
	/** the source of the text from which this was parsed */
	String sourceFile;
	public SimpleNode(int i) {
		id = i;
	}
	public void jjtOpen() { }
	public void jjtClose() { }
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	//public SimpleNode getParent() { return (SimpleNode)parent; }
	public void jjtAddChild(Node n, int i)
	{
		if (children == null)
			children = new Node[i + 1];
		else
			if (i >= children.length)
			{
				Node c[] = new Node[i + 1];
				System.arraycopy(children, 0, c, 0, children.length);
				children = c;
			}
		children[i] = n;
	}
	public Node jjtGetChild(int i) { 
		return children[i]; 
	}
	public SimpleNode getChild( int i ) {
		return (SimpleNode)jjtGetChild(i);
	}
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
    /*
         You can override these two methods in subclasses of SimpleNode to
         customize the way the node appears when the tree is dumped.  If
         your output uses more than one line you should override
         toString(String), otherwise overriding toString() is probably all
         you need to do.
     */
	public String toString() { return ParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }
	/*
		Override this method if you want to customize how the node dumps
		out its children.
	*/
	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if(children != null)
		{
			for(int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null)
				{
					n.dump(prefix + " ");
				}
			}
		}
	}
	//  ---- BeanShell specific stuff hereafter ----  //
	/**
		Detach this node from its parent.
		This is primarily useful in node serialization.
		(see BSHMethodDeclaration)
	*/
	public void prune() {
		jjtSetParent( null );
	}
	/**
		Set the name of the source file (or more generally source) of
		the text from which this node was parsed.
	*/
	public void setSourceFile( String sourceFile ) {
		this.sourceFile = sourceFile;
	}
	/**
		Get the name of the source file (or more generally source) of
		the text from which this node was parsed.
		This will recursively search up the chain of parent nodes until
		a source is found or return a string indicating that the source
		is unknown.
	*/
	public String getSourceFile() {
		if ( sourceFile == null )
			if ( parent != null )
				return ((SimpleNode)parent).getSourceFile();
			else
				return "<unknown file>";
		else
			return sourceFile;
	}
	/**
		Get the line number of the starting token
	*/
	public int getLineNumber() {
		return firstToken.beginLine;
	}
	/**
		Get the ending line number of the starting token
	public int getEndLineNumber() {
		return lastToken.endLine;
	}
	*/
	/**
		Get the text of the tokens comprising this node.
	*/
	public String getText() 
	{
		StringBuilder text = new StringBuilder();
		Token t = firstToken;
		while ( t!=null ) {
			text.append(t.image);
			if ( !t.image.equals(".") )
				text.append(" ");
			if ( t==lastToken ||
				t.image.equals("{") || t.image.equals(";") )
				break;
			t=t.next;
		}
			
		return text.toString();
	}
    public <T> T accept(BshNodeVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
package bsh;
import bsh.ast.SimpleNode;
/**
	UtilEvalError is an error corresponding to an EvalError but thrown by a 
	utility or other class that does not have the caller context (Node) 
	available to it.  A normal EvalError must supply the caller Node in order 
	for error messages to be pinned to the correct line and location in the 
	script.  UtilEvalError is a checked exception that is *not* a subtype of 
	EvalError, but instead must be caught and rethrown as an EvalError by 
	the a nearest location with context.  The method toEvalError( Node ) 
	should be used to throw the EvalError, supplying the node.
	<p>
	To summarize: Utilities throw UtilEvalError.  ASTs throw EvalError.
	ASTs catch UtilEvalError and rethrow it as EvalError using 
	toEvalError( Node ).  
	<p>
	Philosophically, EvalError and UtilEvalError corrospond to 
	RuntimeException.  However they are constrained in this way in order to 
	add the context for error reporting.
	@see UtilTargetError
*/
public class UtilEvalError extends Exception 
{
	protected UtilEvalError() {
	}
	public UtilEvalError( String s ) {
		super(s);
	}
	public UtilEvalError( String s, Throwable cause ) {
		super(s,cause);
	}
	/**
		Re-throw as an eval error, prefixing msg to the message and specifying
		the node.  If a node already exists the addNode is ignored.
		@see #setNode(bsh.ast.SimpleNode)
		<p>
		@param msg may be null for no additional message.
	*/
	public EvalError toEvalError( 
		String msg, SimpleNode node, CallStack callstack  )
	{
		if ( Interpreter.DEBUG )
			printStackTrace();
		if ( msg == null )
			msg = "";
		else
			msg = msg + ": ";
		return new EvalError( msg+getMessage(), node, callstack, this );
	}
	public EvalError toEvalError ( SimpleNode node, CallStack callstack ) 
	{
		return toEvalError( null, node, callstack );
	}
}
package bsh.interpreter;
import bsh.*;
import bsh.ast.*;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/**
 * @author RLE <rafal.lewczuk@gmail.com>
 */
public class BshEvaluatingVisitor extends BshNodeVisitor<Object> {
    private CallStack callstack;
    private Interpreter interpreter;
    public BshEvaluatingVisitor(CallStack callstack, Interpreter interpreter) {
        this.callstack = callstack;
        this.interpreter = interpreter;
    }
    public CallStack getCallstack() {
        return callstack;
    }
    public Interpreter getInterpreter() {
        return interpreter;
    }
    @Override
    public Object visit(BSHAllocationExpression node) {
        // type is either a class name or a primitive type
        SimpleNode type = (SimpleNode)node.jjtGetChild(0);
        // args is either constructor arguments or array dimensions
        SimpleNode args = (SimpleNode)node.jjtGetChild(1);
        if ( type instanceof BSHAmbiguousName)
        {
            BSHAmbiguousName name = (BSHAmbiguousName)type;
            if (args instanceof BSHArguments)
                return objectAllocation(node, name, (BSHArguments) args);
            else
                return objectArrayAllocation(node, name, (BSHArrayDimensions) args
                );
        }
        else
            return primitiveArrayAllocation(node, (BSHPrimitiveType) type,
                    (BSHArrayDimensions) args);
    }
    public Object objectAllocation(BSHAllocationExpression node,
            BSHAmbiguousName nameNode, BSHArguments argumentsNode)
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        Object[] args = getArguments(argumentsNode);
        if ( args == null)
            throw new EvalError( "Null args in new.", node, callstack );
        // Look for scripted class object
        Object obj = ambiguousNameToObject(nameNode, false/* force class*/ );
        // Try regular class
        obj = ambiguousNameToObject( nameNode, true/*force class*/ );
        Class type = null;
        if ( obj instanceof ClassIdentifier )
            type = ((ClassIdentifier)obj).getTargetClass();
        else
            throw new EvalError(
                    "Unknown class: "+nameNode.text, node, callstack );
        // Is an inner class style object allocation
        boolean hasBody = node.jjtGetNumChildren() > 2;
        if ( hasBody )
        {
            BSHBlock body = (BSHBlock)node.jjtGetChild(2);
            if ( type.isInterface() )
                return constructWithInterfaceBody(node,
                        type, args, body);
            else
                return constructWithClassBody( node,
                        type, args, body );
        } else
            return constructObject(node, type, args );
    }
    public Object constructObject(BSHAllocationExpression node, Class<?> type, Object[] args ) throws EvalError {
        final boolean isGeneratedClass = GeneratedClass.class.isAssignableFrom(type);
        if (isGeneratedClass) {
            ClassGeneratorUtil.registerConstructorContext(callstack, interpreter);
        }
        Object obj;
        try {
            obj = Reflect.constructObject( type, args );
        } catch ( ReflectError e) {
            throw new EvalError(
                    "Constructor error: " + e.getMessage(), node, callstack );
        } catch (InvocationTargetException e) {
            // No need to wrap this debug
            Interpreter.debug("The constructor threw an exception:\n\t" + e.getTargetException());
            throw new TargetError("Object constructor", e.getTargetException(), node, callstack, true);
        } finally {
            if (isGeneratedClass) {
                ClassGeneratorUtil.registerConstructorContext(null, null); // clean up, prevent memory leak
            }
        }
        String className = type.getName();
        // Is it an inner class?
        if ( className.indexOf("$") == -1 )
            return obj;
        // Temporary hack to support inner classes
        // If the obj is a non-static inner class then import the context...
        // This is not a sufficient emulation of inner classes.
        // Replace this later...
        // work through to class 'this'
        This ths = callstack.top().getThis( null );
        NameSpace instanceNameSpace =
                Name.getClassNameSpace( ths.getNameSpace() );
        // Change the parent (which was the class static) to the class instance
        // We really need to check if we're a static inner class here first...
        // but for some reason Java won't show the static modifier on our
        // fake inner classes...  could generate a flag field.
        if ( instanceNameSpace != null
                && className.startsWith( instanceNameSpace.getName() +"$")
                )
        {
            ClassGenerator.getClassGenerator().setInstanceNameSpaceParent(
                    obj, className, instanceNameSpace );
        }
        return obj;
    }
    public Object constructWithClassBody( BSHAllocationExpression node,
            Class type, Object[] args, BSHBlock block )
            throws EvalError
    {
        String name = callstack.top().getName() + "$" + (++node.innerClassCount);
        Modifiers modifiers = new Modifiers();
        modifiers.addModifier( Modifiers.CLASS, "public" );
        Class clas = ClassGenerator.getClassGenerator() .generateClass(
                name, modifiers, null/*interfaces*/, type/*superClass*/,
                block, false/*isInterface*/, callstack, interpreter );
        try {
            return Reflect.constructObject( clas, args );
        } catch ( Exception e ) {
            Throwable cause = e;
            if ( e instanceof InvocationTargetException ) {
                cause = ((InvocationTargetException) e).getTargetException();
            }
            throw new EvalError("Error constructing inner class instance: "+e, node, callstack, cause);
        }
    }
    public Object constructWithInterfaceBody( BSHAllocationExpression node,
            Class type, Object[] args, BSHBlock body )
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        NameSpace local = new NameSpace(namespace, "AnonymousBlock");
        callstack.push(local);
        evalBlock(body, true);
        callstack.pop();
        // statical import fields from the interface so that code inside
        // can refer to the fields directly (e.g. HEIGHT)
        local.importStatic( type );
        return local.getThis(interpreter).getInterface( type );
    }
    public Object objectArrayAllocation( BSHAllocationExpression node,
            BSHAmbiguousName nameNode, BSHArrayDimensions dimensionsNode )
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        Class type = ambiguousNameToClass( nameNode );
        if ( type == null )
            throw new EvalError( "Class " + nameNode.getName(namespace)
                    + " not found.", node, callstack );
        return arrayAllocation( node, dimensionsNode, type );
    }
    public Object primitiveArrayAllocation( BSHAllocationExpression node,
            BSHPrimitiveType typeNode, BSHArrayDimensions dimensionsNode
    )
            throws EvalError
    {
        Class type = typeNode.getType();
        return arrayAllocation(node, dimensionsNode, type );
    }
    public Object arrayAllocation( BSHAllocationExpression node,
            BSHArrayDimensions dimensionsNode, Class type)
            throws EvalError
    {
        /*
              dimensionsNode can return either a fully intialized array or VOID.
              when VOID the prescribed array dimensions (defined and undefined)
              are contained in the node.
          */
        Object result = evalArrayDimensions(dimensionsNode, type);
        if ( result != Primitive.VOID )
            return result;
        else
            return arrayNewInstance( node, type, dimensionsNode );
    }
    /**
     Create an array of the dimensions specified in dimensionsNode.
     dimensionsNode may contain a number of "undefined" as well as "defined"
     dimensions.
     <p>
     Background: in Java arrays are implemented in arrays-of-arrays style
     where, for example, a two dimensional array is a an array of arrays of
     some base type.  Each dimension-type has a Java class type associated
     with it... so if foo = new int[5][5] then the type of foo is
     int [][] and the type of foo[0] is int[], etc.  Arrays may also be
     specified with undefined trailing dimensions - meaning that the lower
     order arrays are not allocated as objects. e.g.
     if foo = new int [5][]; then foo[0] == null //true; and can later be
     assigned with the appropriate type, e.g. foo[0] = new int[5];
     (See Learning Java, O'Reilly & Associates more background).
     <p>
     To create an array with undefined trailing dimensions using the
     reflection API we must use an array type to represent the lower order
     (undefined) dimensions as the "base" type for the array creation...
     Java will then create the correct type by adding the dimensions of the
     base type to specified allocated dimensions yielding an array of
     dimensionality base + specified with the base dimensons unallocated.
     To create the "base" array type we simply create a prototype, zero
     length in each dimension, array and use it to get its class
     (Actually, I think there is a way we could do it with Class.forName()
     but I don't trust this).   The code is simpler than the explanation...
     see below.
     */
    public Object arrayNewInstance( BSHAllocationExpression node,
            Class type, BSHArrayDimensions dimensionsNode )
            throws EvalError
    {
        if ( dimensionsNode.numUndefinedDims > 0 )
        {
            Object proto = Array.newInstance(
                    type, new int [dimensionsNode.numUndefinedDims] ); // zeros
            type = proto.getClass();
        }
        try {
            return Array.newInstance(
                    type, dimensionsNode.definedDimensions);
        } catch( NegativeArraySizeException e1 ) {
            throw new TargetError( e1, node, callstack );
        } catch( Exception e ) {
            throw new EvalError("Can't construct primitive array: " +
                    e.getMessage(), node, callstack);
        }
    }
    @Override
    public Object visit(BSHAmbiguousName node) {
        throw new InterpreterError(
                "Don't know how to eval an ambiguous name!"
                        +"  Use toObject() if you want an object." );
    }
    public Object ambiguousNameToObject( BSHAmbiguousName node )
            throws EvalError
    {
        return ambiguousNameToObject( node, false );
    }
    public Object ambiguousNameToObject( BSHAmbiguousName node,
            boolean forceClass )
            throws EvalError
    {
        try {
            return
                    node.getName( callstack.top() ).toObject(
                            this, forceClass );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    public Class ambiguousNameToClass( BSHAmbiguousName node )
            throws EvalError
    {
        try {
            return node.getName( callstack.top() ).toClass();
        } catch ( ClassNotFoundException e ) {
            throw new EvalError( e.getMessage(), node, callstack, e );
        } catch ( UtilEvalError e2 ) {
            // ClassPathException is a type of UtilEvalError
            throw e2.toEvalError( node, callstack );
        }
    }
    public LHS ambiguousNameToLHS( BSHAmbiguousName node )
            throws EvalError
    {
        try {
            return node.getName( callstack.top() ).toLHS( this );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHArguments node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHArguments class.");
    }
    /*
         Disallowing VOIDs here was an easy way to support the throwing of a
         more descriptive error message on use of an undefined argument to a
         method call (very common).  If it ever turns out that we need to
         support that for some reason we'll have to re-evaluate how we get
         "meta-information" about the arguments in the various invoke() methods
         that take Object [].  We could either pass BSHArguments down to
         overloaded forms of the methods or throw an exception subtype
         including the argument position back up, where the error message would
         be compounded.
     */
    public Object[] getArguments( BSHArguments node )
            throws EvalError
    {
        // evaluate each child
        Object[] args = new Object[node.jjtGetNumChildren()];
        for(int i = 0; i < args.length; i++)
        {
            args[i] = ((SimpleNode)node.jjtGetChild(i)).accept(this);
            if ( args[i] == Primitive.VOID )
                throw new EvalError( "Undefined argument: " +
                        ((SimpleNode)node.jjtGetChild(i)).getText(), node, callstack );
        }
        return args;
    }
    /**
     Evaluate the structure of the array in one of two ways:
     a) an initializer exists, evaluate it and return
     the fully constructed array object, also record the dimensions
     of that array
     b) evaluate and record the lengths in each dimension and
     return void.
     The structure of the array dims is maintained in dimensions.
     */
    @Override
    public Object visit(BSHArrayDimensions node) {
        SimpleNode child = (SimpleNode)node.jjtGetChild(0);
        /*
              Child is array initializer.  Evaluate it and fill in the
              dimensions it returns.  Initialized arrays are always fully defined
              (no undefined dimensions to worry about).
              The syntax uses the undefinedDimension count.
              e.g. int [][] { 1, 2 };
          */
        if (child instanceof BSHArrayInitializer)
        {
            if ( node.baseType == null )
                throw new EvalError(
                        "Internal Array Eval err:  unknown base type",
                        node, callstack );
            Object initValue = evalArrayInitializer(((BSHArrayInitializer) child),
                    node.baseType, node.numUndefinedDims, callstack, interpreter);
            Class arrayClass = initValue.getClass();
            int actualDimensions = Reflect.getArrayDimensions(arrayClass);
            node.definedDimensions = new int[ actualDimensions ];
            // Compare with number of dimensions actually created with the
            // number specified (syntax uses the undefined ones here)
            if ( node.definedDimensions.length != node.numUndefinedDims )
                throw new EvalError(
                        "Incompatible initializer. Allocation calls for a " +
                                node.numUndefinedDims+ " dimensional array, but initializer is a " +
                                actualDimensions + " dimensional array", node, callstack );
            // fill in definedDimensions [] lengths
            Object arraySlice = initValue;
            for ( int i = 0; i < node.definedDimensions.length; i++ ) {
                node.definedDimensions[i] = Array.getLength(arraySlice);
                if ( node.definedDimensions[i] > 0 )
                    arraySlice = Array.get(arraySlice, 0);
            }
            return initValue;
        }
        else
        // Evaluate the defined dimensions of the array
        {
            node.definedDimensions = new int[ node.numDefinedDims ];
            for(int i = 0; i < node.numDefinedDims; i++)
            {
                try {
                    Object length = ((SimpleNode)node.jjtGetChild(i)).accept(this);
                    node.definedDimensions[i] = ((Primitive)length).intValue();
                }
                catch(Exception e)
                {
                    throw new EvalError(
                            "Array index: " + i +
                                    " does not evaluate to an integer", node, callstack );
                }
            }
        }
        return Primitive.VOID;
    }
    public Object evalArrayDimensions( BSHArrayDimensions node,
            Class type )
            throws EvalError
    {
        if ( Interpreter.DEBUG ) Interpreter.debug("array base type = "+type);
        node.baseType = type;
        return node.accept(this);
    }
    /**
     Construct the array from the initializer syntax.
     @param baseType the base class type of the array (no dimensionality)
     @param dimensions the top number of dimensions of the array
     e.g. 2 for a String [][];
     */
    public Object evalArrayInitializer(BSHArrayInitializer nodeA, Class baseType, int dimensions,
                        CallStack callstack, Interpreter interpreter )
            throws EvalError
    {
        int numInitializers = nodeA.jjtGetNumChildren();
        // allocate the array to store the initializers
        int [] dima = new int [dimensions]; // description of the array
        // The other dimensions default to zero and are assigned when
        // the values are set.
        dima[0] = numInitializers;
        Object initializers =  Array.newInstance( baseType, dima );
        // Evaluate the initializers
        for (int i = 0; i < numInitializers; i++)
        {
            SimpleNode childNode = (SimpleNode)nodeA.jjtGetChild(i);
            Object currentInitializer;
            if ( childNode instanceof BSHArrayInitializer ) {
                if ( dimensions < 2 )
                    throw new EvalError(
                            "Invalid Location for Intializer, position: "+i,
                            nodeA, callstack );
                currentInitializer =
                        evalArrayInitializer(((BSHArrayInitializer)childNode),
                                baseType, dimensions-1, callstack, interpreter);
            } else
                currentInitializer = childNode.accept(this);
            if ( currentInitializer == Primitive.VOID )
                throw new EvalError(
                        "Void in array initializer, position"+i, nodeA, callstack );
            // Determine if any conversion is necessary on the initializers.
            //
            // Quick test to see if conversions apply:
            // If the dimensionality of the array is 1 then the elements of
            // the initializer can be primitives or boxable types.  If it is
            // greater then the values must be array (object) types and there
            // are currently no conversions that we do on those.
            // If we have conversions on those in the future then we need to
            // get the real base type here instead of the dimensionless one.
            Object value = currentInitializer;
            if ( dimensions == 1 )
            {
                // We do a bsh cast here.  strictJava should be able to affect
                // the cast there when we tighten control
                try {
                    value = Types.castObject(
                            currentInitializer, baseType, Types.CAST );
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError(
                            "Error in array initializer", nodeA, callstack );
                }
                // unwrap any primitive, map voids to null, etc.
                value = Primitive.unwrap( value );
            }
            // store the value in the array
            try {
                Array.set(initializers, i, value);
            } catch( IllegalArgumentException e ) {
                Interpreter.debug("illegal arg"+e);
                throwTypeError( nodeA, baseType, currentInitializer, i, callstack );
            } catch( ArrayStoreException e ) { // I think this can happen
                Interpreter.debug("arraystore"+e);
                throwTypeError(nodeA, baseType, currentInitializer, i, callstack );
            }
        }
        return initializers;
    }
    private void throwTypeError( BSHArrayInitializer node,
            Class baseType, Object initializer, int argNum, CallStack callstack )
            throws EvalError
    {
        String rhsType;
        if (initializer instanceof Primitive)
            rhsType =
                    ((Primitive)initializer).getType().getName();
        else
            rhsType = Reflect.normalizeClassName(
                    initializer.getClass());
        throw new EvalError ( "Incompatible type: " + rhsType
                +" in initializer of array type: "+ baseType
                +" at position: "+argNum, node, callstack );
    }
    @Override
    public Object visit(BSHArrayInitializer node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHArrayInitializer class.");
    }
    @Override
    public Object visit(BSHAssignment node) {
        BSHPrimaryExpression lhsNode =
                (BSHPrimaryExpression)node.jjtGetChild(0);
        if ( lhsNode == null )
            throw new InterpreterError( "Error, null LHSnode" );
        boolean strictJava = interpreter.getStrictJava();
        LHS lhs = primaryExprToLHS(lhsNode);
        if ( lhs == null )
            throw new InterpreterError( "Error, null LHS" );
        // For operator-assign operations save the lhs value before evaluating
        // the rhs.  This is correct Java behavior for postfix operations
        // e.g. i=1; i+=i++; // should be 2 not 3
        Object lhsValue = null;
        if ( node.operator != ParserConstants.ASSIGN ) // assign doesn't need the pre-value
            try {
                lhsValue = lhs.getValue();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
        SimpleNode rhsNode = (SimpleNode)node.jjtGetChild(1);
        Object rhs;
        // implement "blocks" foo = { };
        // if ( rhsNode instanceof BSHBlock )
        //    rsh =
        // else
        rhs = rhsNode.accept(this);
        if ( rhs == Primitive.VOID )
            throw new EvalError("Void assignment.", node, callstack );
        try {
            switch(node.operator)
            {
                case ParserConstants.ASSIGN:
                    return lhs.assign( rhs, strictJava );
                case ParserConstants.PLUSASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.PLUS), strictJava );
                case ParserConstants.MINUSASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.MINUS), strictJava );
                case ParserConstants.STARASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.STAR), strictJava );
                case ParserConstants.SLASHASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.SLASH), strictJava );
                case ParserConstants.ANDASSIGN:
                case ParserConstants.ANDASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.BIT_AND), strictJava );
                case ParserConstants.ORASSIGN:
                case ParserConstants.ORASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.BIT_OR), strictJava );
                case ParserConstants.XORASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.XOR), strictJava );
                case ParserConstants.MODASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.MOD), strictJava );
                case ParserConstants.LSHIFTASSIGN:
                case ParserConstants.LSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.LSHIFT), strictJava );
                case ParserConstants.RSIGNEDSHIFTASSIGN:
                case ParserConstants.RSIGNEDSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.RSIGNEDSHIFT ), strictJava );
                case ParserConstants.RUNSIGNEDSHIFTASSIGN:
                case ParserConstants.RUNSIGNEDSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.RUNSIGNEDSHIFT),
                            strictJava );
                default:
                    throw new InterpreterError(
                            "unimplemented operator in assignment BSH");
            }
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHBinaryExpression node) {
        Object lhs = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        /*
              Doing instanceof?  Next node is a type.
          */
        if (node.kind == ParserConstants.INSTANCEOF)
        {
            // null object ref is not instance of any type
            if ( lhs == Primitive.NULL )
                return new Primitive(false);
            Class rhs = getType(((BSHType)node.jjtGetChild(1)));
            /*
               // primitive (number or void) cannot be tested for instanceof
               if (lhs instanceof Primitive)
                   throw new EvalError("Cannot be instance of primitive type." );
           */
            /*
                   Primitive (number or void) is not normally an instanceof
                   anything.  But for internal use we'll test true for the
                   bsh.Primitive class.
                   i.e. (5 instanceof bsh.Primitive) will be true
               */
            if ( lhs instanceof Primitive )
                if ( rhs == bsh.Primitive.class )
                    return new Primitive(true);
                else
                    return new Primitive(false);
            // General case - performe the instanceof based on assignability
            boolean ret = Types.isJavaBaseAssignable( rhs, lhs.getClass() );
            return new Primitive(ret);
        }
        // The following two boolean checks were tacked on.
        // This could probably be smoothed out.
        /*
              Look ahead and short circuit evaluation of the rhs if:
                  we're a boolean AND and the lhs is false.
          */
        if ( node.kind == ParserConstants.BOOL_AND || node.kind == ParserConstants.BOOL_ANDX ) {
            Object obj = lhs;
            if ( node.isPrimitiveValue(lhs) )
                obj = ((Primitive)lhs).getValue();
            if ( obj instanceof Boolean &&
                    ( ((Boolean)obj).booleanValue() == false ) )
                return new Primitive(false);
        }
        /*
              Look ahead and short circuit evaluation of the rhs if:
                  we're a boolean AND and the lhs is false.
          */
        if ( node.kind == ParserConstants.BOOL_OR || node.kind == ParserConstants.BOOL_ORX ) {
            Object obj = lhs;
            if ( node.isPrimitiveValue(lhs) )
                obj = ((Primitive)lhs).getValue();
            if ( obj instanceof Boolean &&
                    ( ((Boolean)obj).booleanValue() == true ) )
                return new Primitive(true);
        }
        // end stuff that was tacked on for boolean short-circuiting.
        /*
              Are both the lhs and rhs either wrappers or primitive values?
              do binary op
          */
        boolean isLhsWrapper = node.isWrapper(lhs);
        Object rhs = ((SimpleNode)node.jjtGetChild(1)).accept(this); //eval(callstack, interpreter);
        boolean isRhsWrapper = node.isWrapper(rhs);
        if (
                ( isLhsWrapper || node.isPrimitiveValue(lhs) )
                        && ( isRhsWrapper || node.isPrimitiveValue(rhs) )
                )
        {
            // Special case for EQ on two wrapper objects
            if ( (isLhsWrapper && isRhsWrapper && node.kind == ParserConstants.EQ))
            {
                /*
                        Don't auto-unwrap wrappers (preserve identity semantics)
                        FALL THROUGH TO OBJECT OPERATIONS BELOW.
                    */
            } else
                try {
                    return Primitive.binaryOperation(lhs, rhs, node.kind);
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack  );
                }
        }
        /*
      Doing the following makes it hard to use untyped vars...
      e.g. if ( arg == null ) ...what if arg is a primitive?
      The answer is that we should test only if the var is typed...?
      need to get that info here...
          else
          {
          // Do we have a mixture of primitive values and non-primitives ?
          // (primitiveValue = not null, not void)
          int primCount = 0;
          if ( isPrimitiveValue( lhs ) )
              ++primCount;
          if ( isPrimitiveValue( rhs ) )
              ++primCount;
          if ( primCount > 1 )
              // both primitive types, should have been handled above
              throw new InterpreterError("should not be here");
          else
          if ( primCount == 1 )
              // mixture of one and the other
              throw new EvalError("Operator: '" + tokenImage[kind]
                  +"' inappropriate for object / primitive combination.",
                  this, callstack );
          // else fall through to handle both non-primitive types
          // end check for primitive and non-primitive mix
          }
      */
        /*
              Treat lhs and rhs as arbitrary objects and do the operation.
              (including NULL and VOID represented by their Primitive types)
          */
        //System.out.println("binary op arbitrary obj: {"+lhs+"}, {"+rhs+"}");
        switch(node.kind)
        {
            case ParserConstants.EQ:
                return new Primitive((lhs == rhs));
            case ParserConstants.NE:
                return new Primitive((lhs != rhs));
            case ParserConstants.PLUS:
                if(lhs instanceof String || rhs instanceof String)
                    return lhs.toString() + rhs.toString();
                // FALL THROUGH TO DEFAULT CASE!!!
            default:
                if(lhs instanceof Primitive || rhs instanceof Primitive)
                    if ( lhs == Primitive.VOID || rhs == Primitive.VOID )
                        throw new EvalError(
                                "illegal use of undefined variable, class, or 'void' literal",
                                node, callstack );
                    else
                    if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                        throw new EvalError(
                                "illegal use of null value or 'null' literal", node, callstack);
                throw new EvalError("Operator: '" + ParserConstants.tokenImage[node.kind] +
                        "' inappropriate for objects", node, callstack );
        }
    }
    /**
     @param overrideNamespace if set to true the block will be executed
     in the current namespace (not a subordinate one).
     <p>
     If true *no* new BlockNamespace will be swapped onto the stack and
     the eval will happen in the current
     top namespace.  This is used by BshMethod, TryStatement, etc.
     which must intialize the block first and also for those that perform
     multiple passes in the same block.
     */
    public Object evalBlock( BSHBlock node,
            boolean overrideNamespace )
            throws EvalError
    {
        Object syncValue = null;
        if ( node.isSynchronized )
        {
            // First node is the expression on which to sync
            SimpleNode exp = ((SimpleNode)node.jjtGetChild(0));
            syncValue = exp.accept(this);
        }
        Object ret;
        if ( node.isSynchronized ) // Do the actual synchronization
            synchronized( syncValue )
            {
                ret = evalBlock(node, overrideNamespace, null/*filter*/);
            }
        else
            ret = evalBlock(node, overrideNamespace, null/*filter*/ );
        return ret;
    }
    public Object evalBlock( BSHBlock block,
            boolean overrideNamespace, BSHBlock.NodeFilter nodeFilter )
            throws EvalError
    {
        Object ret = Primitive.VOID;
        NameSpace enclosingNameSpace = null;
        if ( !overrideNamespace )
        {
            enclosingNameSpace= callstack.top();
            BlockNameSpace bodyNameSpace =
                    new BlockNameSpace( enclosingNameSpace );
            callstack.swap( bodyNameSpace );
        }
        int startChild = block.isSynchronized ? 1 : 0;
        int numChildren = block.jjtGetNumChildren();
        try {
            /*
                   Evaluate block in two passes:
                   First do class declarations then do everything else.
               */
            for(int i=startChild; i<numChildren; i++)
            {
                SimpleNode node = ((SimpleNode)block.jjtGetChild(i));
                if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
                    continue;
                if ( node instanceof BSHClassDeclaration )
                    node.accept(this);
            }
            for(int i=startChild; i<numChildren; i++)
            {
                SimpleNode node = ((SimpleNode)block.jjtGetChild(i));
                if ( node instanceof BSHClassDeclaration )
                    continue;
                // filter nodes
                if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
                    continue;
                ret = node.accept(this);
                // statement or embedded block evaluated a return statement
                if ( ret instanceof ReturnControl )
                    break;
            }
        } finally {
            // make sure we put the namespace back when we leave.
            if ( !overrideNamespace )
                callstack.swap( enclosingNameSpace );
        }
        return ret;
    }
    @Override
    public Object visit(BSHBlock node) {
        return evalBlock(node, false);
    }
    @Override
    public Object visit(BSHCastExpression node) {
        NameSpace namespace = callstack.top();
        Class toType = getType(((BSHType)node.jjtGetChild(0)));
        SimpleNode expression = (SimpleNode)node.jjtGetChild(1);
        // evaluate the expression
        Object fromValue = expression.accept(this);
        Class fromType = fromValue.getClass();
        // TODO: need to add isJavaCastable() test for strictJava
        // (as opposed to isJavaAssignable())
        try {
            return Types.castObject( fromValue, toType, Types.CAST );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack  );
        }
    }
    @Override
    public Object visit(BSHClassDeclaration node) {
        synchronized (node) {
            if (node.generatedClass == null) {
                node.generatedClass = generateClass(node);
            }
            return node.generatedClass;
        }
    }
    public Class<?> generateClass(BSHClassDeclaration node) throws EvalError {
        int child = 0;
        // resolve superclass if any
        Class superClass = null;
        if ( node.extend ) {
            BSHAmbiguousName superNode = (BSHAmbiguousName)node.jjtGetChild(child++);
            superClass = ambiguousNameToClass( superNode );
        }
        // Get interfaces
        Class [] interfaces = new Class[node.numInterfaces];
        for( int i=0; i<node.numInterfaces; i++) {
            BSHAmbiguousName node1 = (BSHAmbiguousName)node.jjtGetChild(child++);
            interfaces[i] = ambiguousNameToClass(node1);
            if ( !interfaces[i].isInterface() )
                throw new EvalError(
                        "Type: "+node1.text+" is not an interface!",
                        node, callstack );
        }
        BSHBlock block;
        // Get the class body BSHBlock
        if ( child < node.jjtGetNumChildren() )
            block = (BSHBlock) node.jjtGetChild(child);
        else
            block = new BSHBlock( ParserTreeConstants.JJTBLOCK );
        return ClassGenerator.getClassGenerator().generateClass(
                node.name, node.modifiers, interfaces, superClass, block, node.isInterface,
                callstack, interpreter );
    }
    @Override
    public Object visit(BSHEnhancedForStatement node) {
        Class elementType = null;
        SimpleNode expression, statement=null;
        NameSpace enclosingNameSpace = callstack.top();
        SimpleNode firstNode =((SimpleNode)node.jjtGetChild(0));
        int nodeCount = node.jjtGetNumChildren();
        if ( firstNode instanceof BSHType )
        {
            elementType=getType(((BSHType)firstNode));
            expression=((SimpleNode)node.jjtGetChild(1));
            if ( nodeCount>2 )
                statement=((SimpleNode)node.jjtGetChild(2));
        } else
        {
            expression=firstNode;
            if ( nodeCount>1 )
                statement=((SimpleNode)node.jjtGetChild(1));
        }
        BlockNameSpace eachNameSpace = new BlockNameSpace( enclosingNameSpace );
        callstack.swap( eachNameSpace );
        final Object iteratee = expression.accept(this);
        if ( iteratee == Primitive.NULL )
            throw new EvalError("The collection, array, map, iterator, or " +
                    "enumeration portion of a for statement cannot be null.",
                    node, callstack );
        CollectionManager cm = CollectionManager.getCollectionManager();
        if ( !cm.isBshIterable( iteratee ) )
            throw new EvalError("Can't iterate over type: "
                    +iteratee.getClass(), node, callstack );
        Iterator iterator = cm.getBshIterator( iteratee );
        Object returnControl = Primitive.VOID;
        while( iterator.hasNext() )
        {
            try {
                Object value = iterator.next();
                if ( value == null )
                    value = Primitive.NULL;
                if ( elementType != null )
                    eachNameSpace.setTypedVariable(
                            node.varName/*name*/, elementType/*type*/,
                            value, new Modifiers()/*none*/ );
                else
                    eachNameSpace.setVariable( node.varName, value, false );
            } catch ( UtilEvalError e ) {
                throw e.toEvalError(
                        "for loop iterator variable:"+ node.varName, node, callstack );
            }
            boolean breakout = false; // switch eats a multi-level break here?
            if ( statement != null ) // not empty statement
            {
                Object ret = statement.accept(this); //eval( callstack, interpreter );
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case ParserConstants.RETURN:
                            returnControl = ret;
                            breakout = true;
                            break;
                        case ParserConstants.CONTINUE:
                            break;
                        case ParserConstants.BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if (breakout)
                break;
        }
        callstack.swap(enclosingNameSpace);
        return returnControl;
    }
    @Override
    public Object visit(BSHFormalComment node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHFormalComment class.");
    }
    @Override
    public Object visit(BSHFormalParameter node) {
        if ( node.jjtGetNumChildren() > 0 )
            node.type = getType(((BSHType)node.jjtGetChild(0)));
        else
            node.type = node.UNTYPED;
        return node.type;
    }
    public String getFormalParameterTypeDescriptor( BSHFormalParameter node,
             String defaultPackage )
    {
        if ( node.jjtGetNumChildren() > 0 )
            return getTypeDescriptor(((BSHType) node.jjtGetChild(0)), defaultPackage);
        else
            // this will probably not get used
            return "Ljava/lang/Object;";  // Object type
    }
    @Override
    public Object visit(BSHFormalParameters node) {
        if ( node.paramTypes != null )
            return node.paramTypes;
        node.insureParsed();
        Class [] paramTypes = new Class[node.numArgs];
        for(int i=0; i<node.numArgs; i++)
        {
            BSHFormalParameter param = (BSHFormalParameter)node.jjtGetChild(i);
            paramTypes[i] = (Class)param.accept(this); //eval( callstack, interpreter );
        }
        node.paramTypes = paramTypes;
        return paramTypes;
    }
    public String [] getTypeDescriptors( BSHFormalParameters node, String defaultPackage )
    {
        if ( node.typeDescriptors != null )
            return node.typeDescriptors;
        node.insureParsed();
        String [] typeDesc = new String[node.numArgs];
        for(int i=0; i<node.numArgs; i++)
        {
            BSHFormalParameter param = (BSHFormalParameter)node.jjtGetChild(i);
            typeDesc[i] = getFormalParameterTypeDescriptor(param, defaultPackage );
        }
        node.typeDescriptors = typeDesc;
        return typeDesc;
    }
    @Override
    public Object visit(BSHForStatement node) {
        int i = 0;
        if(node.hasForInit)
            node.forInit = ((SimpleNode)node.jjtGetChild(i++));
        if(node.hasExpression)
            node.expression = ((SimpleNode)node.jjtGetChild(i++));
        if(node.hasForUpdate)
            node.forUpdate = ((SimpleNode)node.jjtGetChild(i++));
        if(i < node.jjtGetNumChildren()) // should normally be
            node.statement = ((SimpleNode)node.jjtGetChild(i));
        NameSpace enclosingNameSpace= callstack.top();
        BlockNameSpace forNameSpace = new BlockNameSpace( enclosingNameSpace );
        /*
              Note: some interesting things are going on here.
              1) We swap instead of push...  The primary mode of operation
              acts like we are in the enclosing namespace...  (super must be
              preserved, etc.)
              2) We do *not* call the body block eval with the namespace
              override.  Instead we allow it to create a second subordinate
              BlockNameSpace child of the forNameSpace.  Variable propogation
              still works through the chain, but the block's child cleans the
              state between iteration.
              (which is correct Java behavior... see forscope4.bsh)
          */
        // put forNameSpace it on the top of the stack
        // Note: it's important that there is only one exit point from this
        // method so that we can swap back the namespace.
        callstack.swap( forNameSpace );
        // Do the for init
        if ( node.hasForInit )
            node.forInit.accept(this);
        Object returnControl = Primitive.VOID;
        while(true)
        {
            if ( node.hasExpression )
            {
                boolean cond = BshInterpreterUtil.evaluateCondition(
                        node.expression, this);
                if ( !cond )
                    break;
            }
            boolean breakout = false; // switch eats a multi-level break here?
            if ( node.statement != null ) // not empty statement
            {
                // do *not* invoke special override for block... (see above)
                Object ret = node.statement.accept(this);
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case ParserConstants.RETURN:
                            returnControl = ret;
                            breakout = true;
                            break;
                        case ParserConstants.CONTINUE:
                            break;
                        case ParserConstants.BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if ( breakout )
                break;
            if ( node.hasForUpdate )
                node.forUpdate.accept(this);
        }
        callstack.swap( enclosingNameSpace );  // put it back
        return returnControl;
    }
    @Override
    public Object visit(BSHIfStatement node) {
        Object ret = null;
        if( BshInterpreterUtil.evaluateCondition(
                (SimpleNode) node.jjtGetChild(0), this) )
            ret = ((SimpleNode)node.jjtGetChild(1)).accept(this);
        else
        if(node.jjtGetNumChildren() > 2)
            ret = ((SimpleNode)node.jjtGetChild(2)).accept(this);
        if(ret instanceof ReturnControl)
            return ret;
        else
            return Primitive.VOID;
    }
    @Override
    public Object visit(BSHImportDeclaration node) {
        NameSpace namespace = callstack.top();
        if ( node.superImport )
            try {
                namespace.doSuperImport();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack  );
            }
        else
        {
            if ( node.staticImport )
            {
                if ( node.importPackage )
                {
                    Class clas = ambiguousNameToClass(((BSHAmbiguousName)node.jjtGetChild(0)));
                    namespace.importStatic( clas );
                } else
                    throw new EvalError(
                            "static field imports not supported yet",
                            node, callstack );
            } else
            {
                String name = ((BSHAmbiguousName)node.jjtGetChild(0)).text;
                if ( node.importPackage )
                    namespace.importPackage(name);
                else
                    namespace.importClass(name);
            }
        }
        return Primitive.VOID;
    }
    @Override
    public Object visit(BSHLiteral node) {
        if (node.value == null)
            throw new InterpreterError("Null in bsh literal: "+node.value);
        return node.value;
    }
    @Override
    public Object visit(BSHMethodDeclaration node) {
        node.returnType = evalMethodReturnType(node);
        evalNodes(node);
        // Install an *instance* of this method in the namespace.
        // See notes in BshMethod
        // This is not good...
        // need a way to update eval without re-installing...
        // so that we can re-eval params, etc. when classloader changes
        // look into this
        NameSpace namespace = callstack.top();
        BshMethod bshMethod = new BshMethod( node, namespace, node.modifiers );
        try {
            namespace.setMethod( bshMethod );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError(node,callstack);
        }
        return Primitive.VOID;
    }
    public Class evalReturnType( BSHReturnType node ) throws EvalError
    {
        if ( node.isVoid )
            return Void.TYPE;
        else
            return getType(getTypeNode(node));
    }
    public BSHType getTypeNode(BSHReturnType node) {
        return (BSHType)node.jjtGetChild(0);
    }
    public String getTypeDescriptor( BSHReturnType node,
            String defaultPackage )
    {
        if ( node.isVoid )
            return "V";
        else
            return getTypeDescriptor(getTypeNode(node),
                    defaultPackage);
    }
    public String getReturnTypeDescriptor(BSHMethodDeclaration node,
            String defaultPackage )
    {
        node.insureNodesParsed();
        if ( node.returnTypeNode == null )
            return null;
        else
            return getTypeDescriptor(node.returnTypeNode, defaultPackage );
    }
    public BSHReturnType getReturnTypeNode(BSHMethodDeclaration node) {
        node.insureNodesParsed();
        return node.returnTypeNode;
    }
    /**
     Evaluate the return type node.
     @return the type or null indicating loosely typed return
     */
    public Class evalMethodReturnType( BSHMethodDeclaration node )
            throws EvalError
    {
        node.insureNodesParsed();
        if ( node.returnTypeNode != null )
            return evalReturnType(node.returnTypeNode);
        else
            return null;
    }
    public void evalNodes(BSHMethodDeclaration node)
            throws EvalError
    {
        node.insureNodesParsed();
        // validate that the throws names are class names
        for(int i=node.firstThrowsClause; i<node.numThrows+node.firstThrowsClause; i++)
            ambiguousNameToClass(((BSHAmbiguousName)node.jjtGetChild(i)) );
        node.paramsNode.accept(this);
        // if strictJava mode, check for loose parameters and return type
        if ( interpreter.getStrictJava() )
        {
            for(int i=0; i<node.paramsNode.paramTypes.length; i++)
                if ( node.paramsNode.paramTypes[i] == null )
                    // Warning: Null callstack here.  Don't think we need
                    // a stack trace to indicate how we sourced the method.
                    throw new EvalError(
                            "(Strict Java Mode) Undeclared argument type, parameter: " +
                                    node.paramsNode.getParamNames()[i] + " in method: "
                                    + node.name, node, null );
            if ( node.returnType == null )
                // Warning: Null callstack here.  Don't think we need
                // a stack trace to indicate how we sourced the method.
                throw new EvalError(
                        "(Strict Java Mode) Undeclared return type for method: "
                                + node.name, node, null );
        }
    }
    @Override
    public Object visit(BSHMethodInvocation node) {
        NameSpace namespace = callstack.top();
        BSHAmbiguousName nameNode = node.getNameNode();
        // Do not evaluate methods this() or super() in class instance space
        // (i.e. inside a constructor)
        if ( namespace.getParent() != null && namespace.getParent().isClass
                && ( nameNode.text.equals("super") || nameNode.text.equals("this") )
                )
            return Primitive.VOID;
        Name name = nameNode.getName(namespace);
        Object[] args = getArguments(node.getArgsNode());
        // This try/catch block is replicated is BSHPrimarySuffix... need to
        // factor out common functionality...
        // Move to Reflect?
        try {
            return name.invokeMethod( this, args, node);
        } catch ( ReflectError e ) {
            throw new EvalError(
                    "Error in method invocation: " + e.getMessage(),
                    node, callstack, e );
        } catch ( InvocationTargetException e )
        {
            String msg = "Method Invocation "+name;
            Throwable te = e.getTargetException();
            /*
                   Try to squeltch the native code stack trace if the exception
                   was caused by a reflective call back into the bsh interpreter
                   (e.g. eval() or source()
               */
            boolean isNative = true;
            if ( te instanceof EvalError )
                if ( te instanceof TargetError )
                    isNative = ((TargetError)te).inNativeCode();
                else
                    isNative = false;
            throw new TargetError( msg, te, node, callstack, isNative );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHPackageDeclaration node) {
        BSHAmbiguousName name = (BSHAmbiguousName)node.jjtGetChild(0);
        NameSpace namespace = callstack.top();
        namespace.setPackage( name.text );
        // import the package we're in by default...
        namespace.importPackage( name.text );
        return Primitive.VOID;
    }
    /**
     Evaluate to a value object.
     */
    private LHS primaryExprToLHS(BSHPrimaryExpression node)
            throws EvalError
    {
        Object obj = evalPrimaryExpr(node, true);
        if ( ! (obj instanceof LHS) )
            throw new EvalError("Can't assign to:", node, callstack );
        else
            return (LHS)obj;
    }
    /*
         Our children are a prefix expression and any number of suffixes.
         <p>
         We don't eval() any nodes until the suffixes have had an
         opportunity to work through them.  This lets the suffixes decide
         how to interpret an ambiguous name (e.g. for the .class operation).
     */
    private Object evalPrimaryExpr( BSHPrimaryExpression node, boolean toLHS )
            throws EvalError
    {
        //CallStack callstack = visitor.getCallstack();
        //Interpreter interpreter = visitor.getInterpreter();
        Object obj = node.jjtGetChild(0);
        int numChildren = node.jjtGetNumChildren();
        for(int i=1; i<numChildren; i++)
            obj = doSuffix(((BSHPrimarySuffix)node.jjtGetChild(i)), obj, toLHS);
        /*
              If the result is a Node eval() it to an object or LHS
              (as determined by toLHS)
          */
        if ( obj instanceof SimpleNode )
            if ( obj instanceof BSHAmbiguousName)
                if ( toLHS )
                    obj = ambiguousNameToLHS(((BSHAmbiguousName)obj));
                else
                    obj = ambiguousNameToObject(((BSHAmbiguousName)obj));
            else
                // Some arbitrary kind of node
                if ( toLHS )
                    // is this right?
                    throw new EvalError("Can't assign to prefix.",
                            node, callstack );
                else
                    obj = ((SimpleNode)obj).accept(this);
        // return LHS or value object as determined by toLHS
        if ( obj instanceof LHS )
            if ( toLHS )
                return obj;
            else
                try {
                    return ((LHS)obj).getValue();
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack );
                }
        else
            return obj;
    }
    @Override
    public Object visit(BSHPrimaryExpression node) {
        return evalPrimaryExpr(node, false);
    }
    private Object doSuffix( BSHPrimarySuffix node,
            Object obj, boolean toLHS)
            throws EvalError
    {
        // Handle ".class" suffix operation
        // Prefix must be a BSHType
        if ( node.operation == BSHPrimarySuffix.CLASS )
            if ( obj instanceof BSHType) {
                if ( toLHS )
                    throw new EvalError("Can't assign .class",
                            node, callstack );
                NameSpace namespace = callstack.top();
                return getType(((BSHType)obj));
            } else
                throw new EvalError(
                        "Attempt to use .class suffix on non class.",
                        node, callstack );
        /*
              Evaluate our prefix if it needs evaluating first.
              If this is the first evaluation our prefix mayb be a Node
              (directly from the PrimaryPrefix) - eval() it to an object.
              If it's an LHS, resolve to a value.
              Note: The ambiguous name construct is now necessary where the node
              may be an ambiguous name.  If this becomes common we might want to
              make a static method nodeToObject() or something.  The point is
              that we can't just eval() - we need to direct the evaluation to
              the context sensitive type of result; namely object, class, etc.
          */
        if ( obj instanceof SimpleNode )
            if ( obj instanceof BSHAmbiguousName)
                obj = ambiguousNameToObject(((BSHAmbiguousName)obj));
            else
                obj = ((SimpleNode)obj).accept(this);
        else
        if ( obj instanceof LHS )
            try {
                obj = ((LHS)obj).getValue();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
        try
        {
            switch(node.operation)
            {
                case BSHPrimarySuffix.INDEX:
                    return doIndex(node, obj, toLHS );
                case BSHPrimarySuffix.NAME:
                    return doName(node, obj, toLHS );
                case BSHPrimarySuffix.PROPERTY:
                    return doProperty( node, toLHS, obj);
                default:
                    throw new InterpreterError( "Unknown suffix type" );
            }
        }
        catch(ReflectError e)
        {
            throw new EvalError("reflection error: " + e, node, callstack, e );
        }
        catch(InvocationTargetException e)
        {
            throw new TargetError( "target exception", e.getTargetException(),
                    node, callstack, true);
        }
    }
    /*
         Field access, .length on array, or a method invocation
         Must handle toLHS case for each.
     */
    private Object doName( BSHPrimarySuffix node, Object obj, boolean toLHS)
            throws EvalError, ReflectError, InvocationTargetException
    {
        try {
            // .length on array
            if ( node.field.equals("length") && obj.getClass().isArray() )
                if ( toLHS )
                    throw new EvalError(
                            "Can't assign array length", node, callstack );
                else
                    return new Primitive(Array.getLength(obj));
            // field access
            if ( node.jjtGetNumChildren() == 0 )
                if ( toLHS )
                    return Reflect.getLHSObjectField(obj, node.field);
                else
                    return Reflect.getObjectFieldValue( obj, node.field );
            // Method invocation
            // (LHS or non LHS evaluation can both encounter method calls)
            Object[] oa = getArguments(((BSHArguments)node.jjtGetChild(0)));
            // TODO:
            // Note: this try/catch block is copied from BSHMethodInvocation
            // we need to factor out this common functionality and make sure
            // we handle all cases ... (e.g. property style access, etc.)
            // maybe move this to Reflect ?
            try {
                return Reflect.invokeObjectMethod(
                        obj, node.field, oa, this, node );
            } catch ( ReflectError e ) {
                throw new EvalError(
                        "Error in method invocation: " + e.getMessage(),
                        node, callstack, e );
            } catch ( InvocationTargetException e )
            {
                String msg = "Method Invocation "+node.field;
                Throwable te = e.getTargetException();
                /*
                        Try to squeltch the native code stack trace if the exception
                        was caused by a reflective call back into the bsh interpreter
                        (e.g. eval() or source()
                    */
                boolean isNative = true;
                if ( te instanceof EvalError )
                    if ( te instanceof TargetError )
                        isNative = ((TargetError)te).inNativeCode();
                    else
                        isNative = false;
                throw new TargetError( msg, te, node, callstack, isNative );
            }
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    /**
     array index.
     Must handle toLHS case.
     */
    private Object doIndex( BSHPrimarySuffix node,
            Object obj, boolean toLHS )
            throws EvalError, ReflectError
    {
        int index = BshInterpreterUtil.getIndexAux( obj, this, node );
        if ( toLHS )
            return new LHS(obj, index);
        else
            try {
                return Reflect.getIndex(obj, index);
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
    }
    /**
     Property access.
     Must handle toLHS case.
     */
    private Object doProperty( BSHPrimarySuffix node, boolean toLHS, Object obj )
            throws EvalError
    {
        if(obj == Primitive.VOID)
            throw new EvalError(
                    "Attempt to access property on undefined variable or class name",
                    node, callstack );
        if ( obj instanceof Primitive )
            throw new EvalError("Attempt to access property on a primitive",
                    node, callstack );
        Object value = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        if ( !( value instanceof String ) )
            throw new EvalError(
                    "Property expression must be a String or identifier.",
                    node, callstack );
        if ( toLHS )
            return new LHS(obj, (String)value);
        // Property style access to Hashtable or Map
        CollectionManager cm = CollectionManager.getCollectionManager();
        if ( cm.isMap( obj ) )
        {
            Object val = cm.getFromMap( obj, value/*key*/ );
            return ( val == null ?  val = Primitive.NULL : val );
        }
        try {
            return Reflect.getObjectProperty( obj, (String)value );
        }
        catch ( UtilEvalError e)
        {
            throw e.toEvalError( "Property: "+value, node, callstack );
        }
        catch (ReflectError e)
        {
            throw new EvalError("No such property: " + value, node, callstack );
        }
    }
    @Override
    public Object visit(BSHPrimarySuffix node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimarySuffix class.", node);
    }
    @Override
    public Object visit(BSHPrimitiveType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimitiveType class.", node);
    }
    @Override
    public Object visit(BSHReturnStatement node) {
        Object value;
        if(node.jjtGetNumChildren() > 0)
            value = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        else
            value = Primitive.VOID;
        return new ReturnControl( node.kind, value, node );
    }
    @Override
    public Object visit(BSHReturnType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimarySuffix class.");
    }
    @Override
    public Object visit(BSHStatementExpressionList node) {
        int n = node.jjtGetNumChildren();
        for(int i=0; i<n; i++)
        {
            SimpleNode nn = ((SimpleNode)node.jjtGetChild(i));
            nn.accept(this);
        }
        return Primitive.VOID;
    }
    @Override
    public Object visit(BSHSwitchLabel node) {
        if ( node.isDefault )
            return null; // should probably error
        SimpleNode label = ((SimpleNode)node.jjtGetChild(0));
        return label.accept(this);
    }
    @Override
    public Object visit(BSHSwitchStatement node) {
        int numchild = node.jjtGetNumChildren();
        int child = 0;
        SimpleNode switchExp = ((SimpleNode)node.jjtGetChild(child++));
        Object switchVal = switchExp.accept(this);
        /*
              Note: this could be made clearer by adding an inner class for the
              cases and an object context for the child traversal.
          */
        // first label
        BSHSwitchLabel label;
        Object obj;
        ReturnControl returnControl=null;
        // get the first label
        if ( child >= numchild )
            throw new EvalError("Empty switch statement.", node, callstack );
        label = ((BSHSwitchLabel)node.jjtGetChild(child++));
        // while more labels or blocks and haven't hit return control
        while ( child < numchild && returnControl == null )
        {
            // if label is default or equals switchVal
            if ( label.isDefault
                    || primitiveEquals(node, switchVal, label.accept(this), switchExp) )  {
                // execute nodes, skipping labels, until a break or return
                while ( child < numchild )
                {
                    obj = node.jjtGetChild(child++);
                    if ( obj instanceof BSHSwitchLabel )
                        continue;
                    // eval it
                    Object value =
                            ((SimpleNode)obj).accept(this);
                    // should check to disallow continue here?
                    if ( value instanceof ReturnControl ) {
                        returnControl = (ReturnControl)value;
                        break;
                    }
                }
            } else
            {
                // skip nodes until next label
                while ( child < numchild )
                {
                    obj = node.jjtGetChild(child++);
                    if ( obj instanceof BSHSwitchLabel ) {
                        label = (BSHSwitchLabel)obj;
                        break;
                    }
                }
            }
        }
        if ( returnControl != null && returnControl.kind == ParserConstants.RETURN )
            return returnControl;
        else
            return Primitive.VOID;
    }
    /**
     Helper method for testing equals on two primitive or boxable objects.
     yuck: factor this out into Primitive.java
     */
    public boolean primitiveEquals( BSHSwitchStatement node,
            Object switchVal, Object targetVal,
            SimpleNode switchExp  )
            throws EvalError
    {
        if ( switchVal instanceof Primitive || targetVal instanceof Primitive )
            try {
                // binaryOperation can return Primitive or wrapper type
                Object result = Primitive.binaryOperation(
                        switchVal, targetVal, ParserConstants.EQ );
                result = Primitive.unwrap( result );
                return result.equals( Boolean.TRUE );
            } catch ( UtilEvalError e ) {
                throw e.toEvalError(
                        "Switch value: "+switchExp.getText()+": ",
                        node, callstack );
            }
        else
            return switchVal.equals( targetVal );
    }
    @Override
    public Object visit(BSHTernaryExpression node) {
        SimpleNode
                cond = (SimpleNode)node.jjtGetChild(0),
                evalTrue = (SimpleNode)node.jjtGetChild(1),
                evalFalse = (SimpleNode)node.jjtGetChild(2);
        if ( BshInterpreterUtil.evaluateCondition(cond, this) )
            return evalTrue.accept(this);
        else
            return evalFalse.accept(this);
    }
    @Override
    public Object visit(BSHThrowStatement node) {
        Object obj = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        // need to loosen this to any throwable... do we need to handle
        // that in interpreter somewhere?  check first...
        if(!(obj instanceof Exception))
            throw new EvalError("Expression in 'throw' must be Exception type",
                    node, callstack );
        // wrap the exception in a TargetException to propogate it up
        throw new TargetError( (Exception)obj, node, callstack );
    }
    @Override
    public Object visit(BSHTryStatement node) {
        BSHBlock tryBlock = ((BSHBlock)node.jjtGetChild(0));
        List<BSHFormalParameter> catchParams = new ArrayList<BSHFormalParameter>();
        List<BSHBlock> catchBlocks = new ArrayList<BSHBlock>();
        int nchild = node.jjtGetNumChildren();
        Node nodeObj = null;
        int i=1;
        while((i < nchild) && ((nodeObj = node.jjtGetChild(i++)) instanceof BSHFormalParameter))
        {
            catchParams.add((BSHFormalParameter)nodeObj);
            catchBlocks.add((BSHBlock)node.jjtGetChild(i++));
            nodeObj = null;
        }
        // finaly block
        BSHBlock finallyBlock = null;
        if(nodeObj != null)
            finallyBlock = (BSHBlock)nodeObj;
        // Why both of these?
        TargetError target = null;
        Throwable thrown = null;
        Object ret = null;
        /*
              Evaluate the contents of the try { } block and catch any resulting
              TargetErrors generated by the script.
              We save the callstack depth and if an exception is thrown we pop
              back to that depth before contiuing.  The exception short circuited
              any intervening method context pops.
              Note: we the stack info... what do we do with it?  append
              to exception message?
          */
        int callstackDepth = callstack.depth();
        try {
            ret = tryBlock.accept(this);
        }
        catch( TargetError e ) {
            target = e;
            String stackInfo = "Bsh Stack: ";
            while ( callstack.depth() > callstackDepth )
                stackInfo += "\t" + callstack.pop() +"\n";
        }
        // unwrap the target error
        if ( target != null )
            thrown = target.getTarget();
        // If we have an exception, find a catch
        if (thrown != null)
        {
            int n = catchParams.size();
            for(i=0; i<n; i++)
            {
                // Get catch block
                BSHFormalParameter fp = catchParams.get(i);
                // Should cache this subject to classloader change message
                // Evaluation of the formal parameter simply resolves its
                // type via the specified namespace.. it doesn't modify the
                // namespace.
                fp.accept(this);
                if ( fp.type == null && interpreter.getStrictJava() )
                    throw new EvalError(
                            "(Strict Java) Untyped catch block", node, callstack );
                // If the param is typed check assignability
                if ( fp.type != null )
                    try {
                        thrown = (Throwable)Types.castObject(
                                thrown/*rsh*/, fp.type/*lhsType*/, Types.ASSIGNMENT );
                    } catch( UtilEvalError e ) {
                        /*
                                  Catch the mismatch and continue to try the next
                                  Note: this is innefficient, should have an
                                  isAssignableFrom() that doesn't throw
                                  // TODO: we do now have a way to test assignment
                                  // 	in castObject(), use it?
                              */
                        continue;
                    }
                // Found match, execute catch block
                BSHBlock cb = catchBlocks.get(i);
                // Prepare to execute the block.
                // We must create a new BlockNameSpace to hold the catch
                // parameter and swap it on the stack after initializing it.
                NameSpace enclosingNameSpace = callstack.top();
                BlockNameSpace cbNameSpace =
                        new BlockNameSpace( enclosingNameSpace );
                try {
                    if ( fp.type == BSHFormalParameter.UNTYPED )
                        // set an untyped variable directly in the block
                        cbNameSpace.setBlockVariable( fp.name, thrown );
                    else
                    {
                        // set a typed variable (directly in the block)
                        Modifiers modifiers = new Modifiers();
                        cbNameSpace.setTypedVariable(
                                fp.name, fp.type, thrown, new Modifiers()/*none*/ );
                    }
                } catch ( UtilEvalError e ) {
                    throw new InterpreterError(
                            "Unable to set var in catch block namespace." );
                }
                // put cbNameSpace on the top of the stack
                callstack.swap( cbNameSpace );
                try {
                    ret = cb.accept(this);
                } finally {
                    // put it back
                    callstack.swap( enclosingNameSpace );
                }
                target = null;  // handled target
                break;
            }
        }
        // evaluate finally block
        if( finallyBlock != null ) {
            Object result = finallyBlock.accept(this);
            if( result instanceof ReturnControl )
                return result;
        }
        // exception fell through, throw it upward...
        if(target != null)
            throw target;
        if(ret instanceof ReturnControl)
            return ret;
        else
            return Primitive.VOID;
    }
    @Override
    public Object visit(BSHType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHType class.", node);
    }
    /**
     Returns a class descriptor for this type.
     If the type is an ambiguous name (object type) evaluation is
     attempted through the namespace in order to resolve imports.
     If it is not found and the name is non-compound we assume the default
     package for the name.
     */
    public String getTypeDescriptor( BSHType node, String defaultPackage )
    {
        // return cached type if available
        if ( node.descriptor != null )
            return node.descriptor;
        String descriptor;
        //  first typeNode will either be PrimitiveType or AmbiguousName
        SimpleNode typeNode = node.getTypeNode();
        if ( typeNode instanceof BSHPrimitiveType)
            descriptor = BshInterpreterUtil.getTypeDescriptor( ((BSHPrimitiveType)typeNode).type );
        else
        {
            String clasName = ((BSHAmbiguousName)typeNode).text;
            BshClassManager bcm = interpreter.getClassManager();
            // Note: incorrect here - we are using the hack in bsh class
            // manager that allows lookup by base name.  We need to eliminate
            // this limitation by working through imports.  See notes in class
            // manager.
            String definingClass = bcm.getClassBeingDefined( clasName );
            Class clas = null;
            if ( definingClass == null )
            {
                try {
                    clas = ambiguousNameToClass(((BSHAmbiguousName)typeNode) );
                } catch ( EvalError e ) {
                    //throw new InterpreterError("unable to resolve type: "+e);
                    // ignore and try default package
                    //System.out.println("BSHType: "+typeNode+" class not found");
                }
            } else
                clasName = definingClass;
            if ( clas != null )
            {
                //System.out.println("found clas: "+clas);
                descriptor = BshInterpreterUtil.getTypeDescriptor( clas );
            }else
            {
                if ( defaultPackage == null || Name.isCompound( clasName ) )
                    descriptor = "L" + clasName.replace('.','/') + ";";
                else
                    descriptor =
                            "L"+defaultPackage.replace('.','/')+"/"+clasName + ";";
            }
        }
        for(int i=0; i<node.arrayDims; i++)
            descriptor = "["+descriptor;
        node.descriptor = descriptor;
        //System.out.println("BSHType: returning descriptor: "+descriptor);
        return descriptor;
    }
    public Class getType(BSHType tnode)
            throws EvalError
    {
        // return cached type if available
        if ( tnode.type != null )
            return tnode.type;
        //  first node will either be PrimitiveType or AmbiguousName
        SimpleNode node = tnode.getTypeNode();
        if ( node instanceof BSHPrimitiveType )
            tnode.baseType = ((BSHPrimitiveType)node).getType();
        else
            tnode.baseType = ambiguousNameToClass(((BSHAmbiguousName)node));
        if ( tnode.arrayDims > 0 ) {
            try {
                // Get the type by constructing a prototype array with
                // arbitrary (zero) length in each dimension.
                int[] dims = new int[tnode.arrayDims]; // int array default zeros
                Object obj = Array.newInstance(tnode.baseType, dims);
                tnode.type = obj.getClass();
            } catch(Exception e) {
                throw new EvalError("Couldn't construct array type",
                        tnode, callstack );
            }
        } else
            tnode.type = tnode.baseType;
        // hack... sticking to first interpreter that resolves this
        // see comments on type instance variable
        interpreter.getClassManager().addListener(tnode);
        return tnode.type;
    }
    @Override
    public Object visit(BSHTypedVariableDeclaration node) {
        try {
            NameSpace namespace = callstack.top();
            BSHType typeNode = node.getTypeNode();
            Class type = getType(typeNode);
            BSHVariableDeclarator [] bvda = node.getDeclarators();
            for (int i = 0; i < bvda.length; i++)
            {
                BSHVariableDeclarator dec = bvda[i];
                // Type node is passed down the chain for array initializers
                // which need it under some circumstances
                Object value = evalVariableDeclarator(dec, typeNode);
                try {
                    namespace.setTypedVariable(
                            dec.name, type, value, node.modifiers );
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack );
                }
            }
        } catch ( EvalError e ) {
            e.reThrow( "Typed variable declaration" );
        }
        return Primitive.VOID;
    }
    public Class evalType( BSHTypedVariableDeclaration node )
            throws EvalError
    {
        BSHType typeNode = node.getTypeNode();
        return getType( typeNode );
    }
    @Override
    public Object visit(BSHUnaryExpression node) {
        SimpleNode simpleNode = (SimpleNode)node.jjtGetChild(0);
        // If this is a unary increment of decrement (either pre or postfix)
        // then we need an LHS to which to assign the result.  Otherwise
        // just do the unary operation for the value.
        try {
            if ( node.kind == ParserConstants.INCR || node.kind == ParserConstants.DECR ) {
                LHS lhs = primaryExprToLHS((BSHPrimaryExpression) simpleNode);
                return node.lhsUnaryOperation(lhs, interpreter.getStrictJava());
            } else
                return
                        node.unaryOperation(simpleNode.accept(this), node.kind);
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    /**
     Evaluate the optional initializer value.
     (The name was set at parse time.)
     A variable declarator can be evaluated with or without preceding
     type information. Currently the type info is only used by array
     initializers in the case where there is no explicitly declared type.
     @param typeNode is the BSHType node.  Its info is passed through to any
     variable intializer children for the case where the array initializer
     does not declare the type explicitly. e.g.
     int [] a = { 1, 2 };
     typeNode may be null to indicate no type information available.
     */
    private Object evalVariableDeclarator(BSHVariableDeclarator node, BSHType typeNode)
            throws EvalError
    {
        // null value means no value
        Object value = null;
        if ( node.jjtGetNumChildren() > 0 )
        {
            SimpleNode initializer = (SimpleNode)node.jjtGetChild(0);
            /*
                   If we have type info and the child is an array initializer
                   pass it along...  Else use the default eval style.
                   (This allows array initializer to handle the problem...
                   allowing for future enhancements in loosening types there).
               */
            if ( (typeNode != null)
                    && initializer instanceof BSHArrayInitializer
                    )
                value = evalArrayInitializer(((BSHArrayInitializer) initializer),
                        typeNode.getBaseType(), typeNode.getArrayDims(),
                        callstack, interpreter);
            else
                value = initializer.accept(this);
        }
        if ( value == Primitive.VOID )
            throw new EvalError("Void initializer.", node, callstack );
        return value;
    }
    @Override
    public Object visit(BSHVariableDeclarator node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHVariableDeclarator class.");
    }
    @Override
    public Object visit(BSHWhileStatement node) {
        int numChild = node.jjtGetNumChildren();
        // Order of body and condition is swapped for do / while
        final SimpleNode condExp;
        final SimpleNode body;
        if ( node.isDoStatement ) {
            condExp = (SimpleNode) node.jjtGetChild(1);
            body = (SimpleNode) node.jjtGetChild(0);
        } else {
            condExp = (SimpleNode) node.jjtGetChild(0);
            if ( numChild > 1 )	{
                body = (SimpleNode) node.jjtGetChild(1);
            } else {
                body = null;
            }
        }
        boolean doOnceFlag = node.isDoStatement;
        while (doOnceFlag || BshInterpreterUtil.evaluateCondition(condExp, this)) {
            doOnceFlag = false;
            // no body?
            if ( body == null ) {
                continue;
            }
            Object ret = body.accept(this);
            if (ret instanceof ReturnControl) {
                switch(( (ReturnControl)ret).kind ) {
                    case ParserConstants.RETURN:
                        return ret;
                    case ParserConstants.CONTINUE:
                        break;
                    case ParserConstants.BREAK:
                        return Primitive.VOID;
                }
            }
        }
        return Primitive.VOID;
    }
}
package	bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.Serializable;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Field;
/**
    A namespace	in which methods, variables, and imports (class names) live.  
	This is package public because it is used in the implementation of some 
	bsh commands.  However for normal use you should be using methods on 
	bsh.Interpreter to interact with your scripts.
	<p>
	A bsh.This object is a thin layer over a NameSpace that associates it with
	an Interpreter instance.  Together they comprise a Bsh scripted object 
	context.
	<p>
*/
/*
	Thanks to Slava Pestov (of jEdit fame) for import caching enhancements.
	Note: This class has gotten too big.  It should be broken down a bit.
*/
// not at all thread-safe - fschmidt
public class NameSpace implements Serializable, BshClassManager.Listener, NameSource, Cloneable {
	
	private static final long serialVersionUID = 5004976946651004751L;
	public static final NameSpace JAVACODE = 
		new NameSpace((BshClassManager)null, "Called from compiled Java code.");
	static {
		JAVACODE.isMethod = true;
	}
	// Begin instance data
	// Note: if we add something here we should reset it in the clear() method.
	/**
		The name of this namespace.  If the namespace is a method body
		namespace then this is the name of the method.  If it's a class or
		class instance then it's the name of the class.
	*/
	private String nsName; 
    private NameSpace parent;
    private Map<String,Variable> variables;
    private Map<String,List<BshMethod>> methods;
    protected Map<String,String> importedClasses;
    private List<String> importedPackages;
    private List<String> importedCommands;
	private List<Object> importedObjects;
	private List<Class> importedStatic;
	private String packageName;
	transient private BshClassManager classManager;
	// See notes in getThis()
    private This thisReference;
	/** Name resolver objects */
    private Map<String,Name> names;
	/** The node associated with the creation of this namespace.
		This is used support getInvocationLine() and getInvocationText(). */
	SimpleNode callerInfoNode;
	/** 
		Note that the namespace is a method body namespace.  This is used for
		printing stack traces in exceptions.  
	*/
	public boolean isMethod;
	/**
		Note that the namespace is a class body or class instance namespace.  
		This is used for controlling static/object import precedence, etc.
	*/
	/*
		Note: We will ll move this behavior out to a subclass of 
		NameSpace, but we'll start here.
	*/
	public boolean isClass;
	Class classStatic;	
	Object classInstance;
	
	void setClassStatic( Class clas ) {
		this.classStatic = clas;
		importStatic( clas );
	}
	void setClassInstance( Object instance ) {
		this.classInstance = instance;
		importObject( instance );
	}
	Object getClassInstance()
		throws UtilEvalError
	{
		if ( classInstance != null )
			return classInstance;
		if ( classStatic != null 
			//|| ( getParent()!=null && getParent().classStatic != null ) 
		)
			throw new UtilEvalError(
				"Can't refer to class instance from static context.");
		else
			throw new InterpreterError( 
				"Can't resolve class instance 'this' in: "+this);
	}
	/**
		Local class cache for classes resolved through this namespace using 
		getClass() (taking into account imports).  Only unqualified class names
		are cached here (those which might be imported).  Qualified names are 
		always absolute and are cached by BshClassManager.
	*/
    transient private Map<String,Class> classCache;
	// End instance data
	// Begin constructors
	/**
		@parent the parent namespace of this namespace.  Child namespaces
		inherit all variables and methods of their parent and can (of course)
		override / shadow them.
	*/
    public NameSpace( NameSpace parent, String name ) 
	{
		// Note: in this case parent must have a class manager.
		this( parent, null, name );
	}
    public NameSpace( BshClassManager classManager, String name ) 
	{
		this( null, classManager, name );
	}
    public NameSpace( 
		NameSpace parent, BshClassManager classManager, String name ) 
	{
		// We might want to do this here rather than explicitly in Interpreter
		// for global (see also prune())
		//if ( classManager == null && (parent == null ) )
			// create our own class manager?
		setName(name);
		setParent(parent);
		setClassManager( classManager );
		// Register for notification of classloader change
		if ( classManager != null )
			classManager.addListener(this);
    }
	// End constructors
	public void setName( String name ) {
		this.nsName = name;
	}
	/**
		The name of this namespace.  If the namespace is a method body
		namespace then this is the name of the method.  If it's a class or
		class instance then it's the name of the class.
	*/
	public String getName() {
		return this.nsName;
	}
	/**
		Set the node associated with the creation of this namespace.
		This is used in debugging and to support the getInvocationLine()
		and getInvocationText() methods.
	*/
	void setNode( SimpleNode node ) {
		callerInfoNode = node;
	}
	/**
	*/
	SimpleNode getNode() 
	{
		if ( callerInfoNode != null )
			return callerInfoNode;
		if ( parent != null )
			return parent.getNode();
		else
			return null;
	}
	/**
		Resolve name to an object through this namespace.
	*/
	public Object get( String name, Interpreter interpreter ) 
		throws UtilEvalError 
	{
		CallStack callstack = new CallStack( this );
		return getNameResolver( name ).toObject( new BshEvaluatingVisitor(callstack, interpreter) );
	}
	/**
		Set the variable through this namespace.
		This method obeys the LOCALSCOPING property to determine how variables
		are set.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		<p>
		Setting a new variable (which didn't exist before) or removing
		a variable causes a namespace change.
		@param strictJava specifies whether strict java rules are applied.
	*/
    public void	setVariable( String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		// if localscoping switch follow strictJava, else recurse
		boolean recurse = Interpreter.LOCALSCOPING ? strictJava : true;
		setVariable( name, value, strictJava, recurse );
	}
	/**
		Set a variable explicitly in the local scope.
	*/
    void setLocalVariable( 
		String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		setVariable( name, value, strictJava, false/*recurse*/ );
	}
	/**
		Set the value of a the variable 'name' through this namespace.
		The variable may be an existing or non-existing variable.
		It may live in this namespace or in a parent namespace if recurse is 
		true.
		<p>
		Note: This method is not public and does *not* know about LOCALSCOPING.
		Its caller methods must set recurse intelligently in all situations 
		(perhaps based on LOCALSCOPING).
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		<p>
		Setting a new variable (which didn't exist before) or removing
		a variable causes a namespace change.
		@param strictJava specifies whether strict java rules are applied.
		@param recurse determines whether we will search for the variable in
		  our parent's scope before assigning locally.
	*/
    void setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		ensureVariables();
		// primitives should have been wrapped
		if ( value == null )
			throw new InterpreterError("null variable value");
		// Locate the variable definition if it exists.
		Variable existing = getVariableImpl( name, recurse );
		// Found an existing variable here (or above if recurse allowed)
		if ( existing != null )
		{
			try {
				existing.setValue( value, Variable.ASSIGNMENT );
			} catch ( UtilEvalError e ) {
				throw new UtilEvalError(
					"Variable assignment: " + name + ": " + e.getMessage());
			}
		} else 
		// No previous variable definition found here (or above if recurse)
		{
			if ( strictJava )
				throw new UtilEvalError(
					"(Strict Java mode) Assignment to undeclared variable: "
					+name );
			// If recurse, set global untyped var, else set it here.	
			//NameSpace varScope = recurse ? getGlobal() : this;
			// This modification makes default allocation local
			NameSpace varScope = this;
			varScope.variables.put( 
				name, new Variable( name, value, null/*modifiers*/ ) );
			// nameSpaceChanged() on new variable addition
			nameSpaceChanged();
    	}
	}
	private void ensureVariables() {
		if ( variables == null )
			variables =	new HashMap<String,Variable>();
	}
	/**
		Remove the variable from the namespace.
	*/
	public void unsetVariable( String name )
	{
		if ( variables != null )
		{
			variables.remove( name );
			nameSpaceChanged();
		}
	}
	/**
		Get the names of variables defined in this namespace.
		(This does not show variables in parent namespaces).
	*/
	public String [] getVariableNames() {
		if ( variables == null )
			return new String [0];
		else
			return variables.keySet().toArray(new String[0]);
	}
	/**
		Get the names of methods declared in this namespace.
		(This does not include methods in parent namespaces).
	*/
	public String [] getMethodNames() 
	{
		if ( methods == null )
			return new String [0];
		else
			return methods.keySet().toArray(new String[0]);
	}
	/**
		Get the methods defined in this namespace.
		(This does not show methods in parent namespaces).
		Note: This will probably be renamed getDeclaredMethods()
	*/
	public BshMethod [] getMethods() 
	{
		if ( methods == null ) {
			return new BshMethod [0];
		} else {
			List<BshMethod> ret = new ArrayList<BshMethod>();
			for( List<BshMethod> list : methods.values() ) {
				ret.addAll(list);
			}
			return ret.toArray(new BshMethod[0]);
		}
	}
	/**
		Get the parent namespace.
		Note: this isn't quite the same as getSuper().
		getSuper() returns 'this' if we are at the root namespace.
	*/
	public NameSpace getParent() {
		return parent;
	}
	/**
		Get the parent namespace' This reference or this namespace' This
		reference if we are the top.
	*/
    public This getSuper( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getThis( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }
	/**
		Get the top level namespace or this namespace if we are the top.
		Note: this method should probably return type bsh.This to be consistent
		with getThis();
	*/
    public This getGlobal( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getGlobal( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }
	
	/**
		A This object is a thin layer over a namespace, comprising a bsh object
		context.  It handles things like the interface types the bsh object
		supports and aspects of method invocation on it.  
		<p>
		The declaringInterpreter is here to support callbacks from Java through
		generated proxies.  The scripted object "remembers" who created it for
		things like printing messages and other per-interpreter phenomenon
		when called externally from Java.
	*/
	/*
		Note: we need a singleton here so that things like 'this == this' work
		(and probably a good idea for speed).
		Caching a single instance here seems technically incorrect,
		considering the declaringInterpreter could be different under some
		circumstances.  (Case: a child interpreter running a source() / eval() 
		command ).  However the effect is just that the main interpreter that
		executes your script should be the one involved in call-backs from Java.
		I do not know if there are corner cases where a child interpreter would
		be the first to use a This reference in a namespace or if that would
		even cause any problems if it did...  We could do some experiments
		to find out... and if necessary we could cache on a per interpreter
		basis if we had weak references...  We might also look at skipping 
		over child interpreters and going to the parent for the declaring 
		interpreter, so we'd be sure to get the top interpreter.
	*/
    public This getThis( Interpreter declaringInterpreter ) 
	{
		if ( thisReference == null )
			thisReference = This.getThis( this, declaringInterpreter );
		return thisReference;
    }
	public BshClassManager getClassManager() 
	{
		if ( classManager != null )
			return classManager;
		if ( parent != null && parent != JAVACODE )
			return parent.getClassManager();
		classManager = BshClassManager.createClassManager( null/*interp*/ );
		
		//Interpreter.debug("No class manager namespace:" +this);
		return classManager;
	}
	void setClassManager( BshClassManager classManager ) {
		this.classManager = classManager;
	}
	/**
		Used for serialization
	*/
	public void prune() 
	{
		// Cut off from parent, we must have our own class manager.
		// Can't do this in the run() command (needs to resolve stuff)
		// Should we do it by default when we create a namespace will no
		// parent of class manager?
		if ( this.classManager == null )
// XXX if we keep the createClassManager in getClassManager then we can axe
// this?
			setClassManager( 
				BshClassManager.createClassManager( null/*interp*/ ) );
		setParent( null );
	}
	public void setParent( NameSpace parent ) 
	{
		this.parent = parent;
		// If we are disconnected from root we need to handle the def imports
		if ( parent == null )
			loadDefaultImports();
	}
	/**
		Get the specified variable in this namespace or a parent namespace.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to use 
		Primitive.unwrap() to get primitive values.
		@see Primitive#unwrap( Object )
		@return The variable value or Primitive.VOID if it is not defined.
	*/
    public Object getVariable( String name ) 
		throws UtilEvalError
	{
		return getVariable( name, true );
	}
	/**
		Get the specified variable in this namespace.
		@param recurse If recurse is true then we recursively search through 
		parent namespaces for the variable.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to use 
		Primitive.unwrap() to get primitive values.
		@see Primitive#unwrap( Object )
		@return The variable value or Primitive.VOID if it is not defined.
	*/
    public Object getVariable( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = getVariableImpl( name, recurse );
		return unwrapVariable( var );
    }
	/**
		Locate a variable and return the Variable object with optional 
		recursion through parent name spaces.
		<p/>
		If this namespace is static, return only static variables.
		@return the Variable value or null if it is not defined
	*/
    protected Variable getVariableImpl( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = null;
		// Change import precedence if we are a class body/instance
		// Get imported first.
		if ( var == null && isClass )
			var = getImportedVar( name );
		if ( var == null && variables != null )
			var	= (Variable)variables.get(name);
		// Change import precedence if we are a class body/instance
		if ( var == null && !isClass )
			var = getImportedVar( name );
		// try parent
		if ( recurse && (var == null) && (parent != null) )
			var	= parent.getVariableImpl( name, recurse );
		return var;
    }
	
	/*
		Get variables declared in this namespace.
	*/
	public Variable [] getDeclaredVariables() 
	{
		if ( variables == null )
			return new Variable[0];
		return variables.values().toArray(new Variable[0]);
	}
	/**
		Unwrap a variable to its value.
		@return return the variable value.  A null var is mapped to 
			Primitive.VOID
	*/
	protected Object unwrapVariable( Variable var ) 
		throws UtilEvalError
	{
		return (var == null) ? Primitive.VOID :	var.getValue();
	}
	/**
		@deprecated See #setTypedVariable( String, Class, Object, Modifiers )
	*/
    public void	setTypedVariable(
		String	name, Class type, Object value,	boolean	isFinal )
		throws UtilEvalError 
	{
		Modifiers modifiers = new Modifiers();
		if ( isFinal )
			modifiers.addModifier( Modifiers.FIELD, "final" );
		setTypedVariable( name, type, value, modifiers );
	}
    /**
		Declare a variable in the local scope and set its initial value.
		Value may be null to indicate that we would like the default value 
		for the variable type. (e.g.  0 for integer types, null for object 
		types).  An existing typed variable may only be set to the same type.
		If an untyped variable of the same name exists it will be overridden 
		with the new typed var.
		The set will perform a Types.getAssignableForm() on the value if 
		necessary.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package and wish to set variables with
		primitive values you will have to wrap them using bsh.Primitive.
		@see bsh.Primitive
		@param value If value is null, you'll get the default value for the type
		@param modifiers may be null
    */
    public void	setTypedVariable(
		String	name, Class type, Object value,	Modifiers modifiers )
		throws UtilEvalError 
	{
		//checkVariableModifiers( name, modifiers );
		ensureVariables();
		// Setting a typed variable is always a local operation.
		Variable existing = getVariableImpl( name, false/*recurse*/ );
		// Null value is just a declaration
		// Note: we might want to keep any existing value here instead of reset
	/*
	// Moved to Variable
		if ( value == null )
			value = Primitive.getDefaultValue( type );
	*/
		// does the variable already exist?
		if ( existing != null ) 
		{
			// Is it typed?
			if ( existing.getType() != null ) 
			{
				// If it had a different type throw error.
				// This allows declaring the same var again, but not with
				// a different (even if assignable) type.
				if ( existing.getType() != type )
				{
					throw new UtilEvalError( "Typed variable: "+name
						+" was previously declared with type: " 
						+ existing.getType() );
				} else 
				{
					// else set it and return
					existing.setValue( value, Variable.DECLARATION );
					return;
				}
			}
			// Careful here:
			// else fall through to override and install the new typed version
		} 
		// Add the new typed var
		variables.put( name, new Variable( name, type, value, modifiers ) );
    }
	/**
		Dissallow static vars outside of a class
		@param name is here just to allow the error message to use it
	protected void checkVariableModifiers( String name, Modifiers modifiers )
		throws UtilEvalError
	{
		if ( modifiers!=null && modifiers.hasModifier("static") )
			throw new UtilEvalError(
				"Can't declare static variable outside of class: "+name );
	}
	*/
	/**
		Note: this is primarily for internal use.
		@see Interpreter#source( String )
		@see Interpreter#eval( String )
	*/
    public void	setMethod( BshMethod method )
		throws UtilEvalError
	{
		//checkMethodModifiers( method );
		if ( methods == null )
			methods = new HashMap<String,List<BshMethod>>();
		String name = method.getName();
		List<BshMethod> list = methods.get(name);
		if ( list == null ) {
			methods.put(name, Collections.singletonList(method));
		} else {
			if( !(list instanceof ArrayList) ) {
				list = new ArrayList<BshMethod>(list);
				methods.put( name, list );
			}
			list.remove(method);
			list.add( method );
		}
    }
	/**
		see #getMethod( String, Class [], boolean )
		see #getMethod( String, Class [] )
	*/
    public BshMethod getMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		return getMethod( name, sig, false/*declaredOnly*/ );
	}
	/**
		Get the bsh method matching the specified signature declared in 
		this name space or a parent.
		<p>
		Note: this method is primarily intended for use internally.  If you use
		this method outside of the bsh package you will have to be familiar
		with BeanShell's use of the Primitive wrapper class.
		@see bsh.Primitive
		@return the BshMethod or null if not found
		@param declaredOnly if true then only methods declared directly in this
			namespace will be found and no inherited or imported methods will
			be visible.
	*/
    public BshMethod getMethod( 
		String name, Class [] sig, boolean declaredOnly ) 
		throws UtilEvalError
	{
		BshMethod method = null;
		// Change import precedence if we are a class body/instance
		// Get import first.
		if ( method == null && isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		if ( method == null && methods != null )
		{
			List<BshMethod> list = methods.get(name);
			if ( list != null ) 
			{
				// Apply most specific signature matching
				Class [][] candidates = new Class[ list.size() ][];
				for( int i=0; i< candidates.length; i++ )
					candidates[i] = list.get(i).getParameterTypes();
				int match = 
					Reflect.findMostSpecificSignature( sig, candidates );
				if ( match != -1 )
					method = list.get(match);
			}
		}
		if ( method == null && !isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		
		// try parent
		if ( !declaredOnly && (method == null) && (parent != null) )
			return parent.getMethod( name, sig );
		return method;
    }
	/**
		Import a class name.
		Subsequent imports override earlier ones
	*/
    public void	importClass(String name)
    {
		if ( importedClasses == null )
			importedClasses = new HashMap<String,String>();
		importedClasses.put( Name.suffix(name, 1), name );
		nameSpaceChanged();
    }
	/**
		subsequent imports override earlier ones
	*/
    public void	importPackage(String name)
    {
		if(importedPackages == null)
			importedPackages = new ArrayList<String>();
		// If it exists, remove it and add it at the end (avoid memory leak)
		importedPackages.remove( name );
		importedPackages.add(name);
		nameSpaceChanged();
    }
	/**
		Import scripted or compiled BeanShell commands in the following package
		in the classpath.  You may use either "/" path or "." package notation.
		e.g. importCommands("/bsh/commands") or importCommands("bsh.commands")
		are equivalent.  If a relative path style specifier is used then it is
		made into an absolute path by prepending "/".
	*/
    public void	importCommands( String name )
    {
		if ( importedCommands == null )
			importedCommands = new ArrayList<String>();
		// dots to slashes
		name = name.replace('.','/');
		// absolute
		if ( !name.startsWith("/") )
			name = "/"+name;
		// remove trailing (but preserve case of simple "/")
		if ( name.length() > 1 && name.endsWith("/") )
			name = name.substring( 0, name.length()-1 );
		// If it exists, remove it and add it at the end (avoid memory leak)
		importedCommands.remove( name );
		importedCommands.add(name);
		nameSpaceChanged();
    }
	/**
		A command is a scripted method or compiled command class implementing a 
		specified method signature.  Commands are loaded from the classpath
		and may be imported using the importCommands() method.
		<p/>
		This method searches the imported commands packages for a script or
		command object corresponding to the name of the method.  If it is a
		script the script is sourced into this namespace and the BshMethod for
		the requested signature is returned.  If it is a compiled class the
		class is returned.  (Compiled command classes implement static invoke()
		methods).
		<p/>
		The imported packages are searched in reverse order, so that later
		imports take priority.
		Currently only the first object (script or class) with the appropriate
		name is checked.  If another, overloaded form, is located in another
		package it will not currently be found.  This could be fixed.
		<p/>
		@return a BshMethod, Class, or null if no such command is found.
		@param name is the name of the desired command method
		@param argTypes is the signature of the desired command method.
		@throws UtilEvalError if loadScriptedCommand throws UtilEvalError
			i.e. on errors loading a script that was found
	*/
	public Object getCommand( 	
		String name, Class [] argTypes, Interpreter interpreter ) 
		throws UtilEvalError
	{
		if (Interpreter.DEBUG) Interpreter.debug("getCommand: "+name);
		BshClassManager bcm = interpreter.getClassManager();
		if ( importedCommands != null )
		{
			// loop backwards for precedence
			for(int i=importedCommands.size()-1; i>=0; i--)
			{
				String path = importedCommands.get(i);
				String scriptPath; 
				if ( path.equals("/") )
					scriptPath = path + name +".bsh";
				else
					scriptPath = path +"/"+ name +".bsh";
				Interpreter.debug("searching for script: "+scriptPath );
        		InputStream in = bcm.getResourceAsStream( scriptPath );
				if ( in != null )
					return loadScriptedCommand( 
						in, name, argTypes, scriptPath, interpreter );
				// Chop leading "/" and change "/" to "."
				String className;
				if ( path.equals("/") )
					className = name;
				else
					className = path.substring(1).replace('/','.') +"."+name;
				Interpreter.debug("searching for class: "+className);
        		Class clas = bcm.classForName( className );
				if ( clas != null )
					return clas;
			}
		}
		if ( parent != null )
			return parent.getCommand( name, argTypes, interpreter );
		else
			return null;
	}
	protected BshMethod getImportedMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		// Try object imports
		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.get(i);
			Class clas = object.getClass();
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, false/*onlyStatic*/ );
			if ( method != null )
				return new BshMethod( method, object );
		}
		// Try static imports
		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = importedStatic.get(i);
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, true/*onlyStatic*/ );
			if ( method != null )
				return new BshMethod( method, null/*object*/ );
		}
		return null;
	}
	protected Variable getImportedVar( String name ) 
		throws UtilEvalError
	{
		// Try object imports
		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.get(i);
			Class clas = object.getClass();
			Field field = Reflect.resolveJavaField( 
				clas, name, false/*onlyStatic*/ );
			if ( field != null )
				return new Variable( 
					name, field.getType(), new LHS( object, field ) );
		}
		// Try static imports
		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = importedStatic.get(i);
			Field field = Reflect.resolveJavaField( 
				clas, name, true/*onlyStatic*/ );
			if ( field != null )
				return new Variable( name, field.getType(), new LHS( field ) );
		}
		return null;
	}
	/**
		Load a command script from the input stream and find the BshMethod in
		the target namespace.
		@throws UtilEvalError on error in parsing the script or if the the
			method is not found after parsing the script.
	*/
	/*
		If we want to support multiple commands in the command path we need to
		change this to not throw the exception.
	*/
	private BshMethod loadScriptedCommand( 
		InputStream in, String name, Class [] argTypes, String resourcePath, 
		Interpreter interpreter )
		throws UtilEvalError
	{
		try {
			interpreter.eval( 
				new InputStreamReader(in), this, resourcePath );
		} catch ( EvalError e ) {
		/* 
			Here we catch any EvalError from the interpreter because we are
			using it as a tool to load the command, not as part of the
			execution path.
		*/
			Interpreter.debug( e.toString() );
			throw new UtilEvalError( 
				"Error loading script: "+ e.getMessage(), e);
		}
		// Look for the loaded command 
		BshMethod meth = getMethod( name, argTypes );
		/*
		if ( meth == null )
			throw new UtilEvalError("Loaded resource: " + resourcePath +
				"had an error or did not contain the correct method" );
		*/
		return meth;
	}
	/**
		Helper that caches class.
	*/
	void cacheClass( String name, Class c ) {
		if ( classCache == null ) {
			classCache = new HashMap<String,Class>();
			//cacheCount++; // debug
		}
		classCache.put(name, c);
	}
	/**
		Load a class through this namespace taking into account imports.
		The class search will proceed through the parent namespaces if
		necessary.
		@return null if not found.
	*/
    public Class getClass( String name )
		throws UtilEvalError
    {
		Class c = getClassImpl(name);
		if ( c != null )
			return c;
		else
			// implement the recursion for getClassImpl()
			if ( parent != null )
				return parent.getClass( name );
			else
				return null;
	}
	/**
		Implementation of getClass() 
		Load a class through this namespace taking into account imports.
		<p>
		Check the cache first.  If an unqualified name look for imported 
		class or package.  Else try to load absolute name.
		<p>
		This method implements caching of unqualified names (normally imports).
		Qualified names are cached by the BshClassManager.
		Unqualified absolute class names (e.g. unpackaged Foo) are cached too
		so that we don't go searching through the imports for them each time.
		@return null if not found.
	*/
    private Class getClassImpl( String name )
		throws UtilEvalError
    {
		Class c = null;
		// Check the cache
		if (classCache != null) {
			c =	classCache.get(name);
			if ( c != null )
				return c;
		}
		// Unqualified (simple, non-compound) name
		boolean unqualifiedName = !Name.isCompound(name);
		// Unqualified name check imported
		if ( unqualifiedName ) 
		{
			// Try imported class
			if ( c == null )
				c = getImportedClassImpl( name );
			// if found as imported also cache it
			if ( c != null ) {
				cacheClass( name, c );
				return c;
			}
		}
		// Try absolute
		c = classForName( name );
		if ( c != null ) {
			// Cache unqualified names to prevent import check again
			if ( unqualifiedName )
				cacheClass( name, c );
			return c;
		}
		// Not found
		if ( Interpreter.DEBUG ) 
			Interpreter.debug("getClass(): " + name	+ " not	found in "+this);
		return null;
    }
	/**
		Try to make the name into an imported class.
		This method takes into account only imports (class or package)
		found directly in this NameSpace (no parent chain).
	*/
    private Class getImportedClassImpl( String name )
		throws UtilEvalError
    {
		// Try explicitly imported class, e.g. import foo.Bar;
		String fullname = null;
		if ( importedClasses != null )
			fullname = importedClasses.get(name);
		
		// not sure if we should really recurse here for explicitly imported
		// class in parent...  
		if ( fullname != null ) 
		{
			/*
				Found the full name in imported classes.
			*/
			// Try to make the full imported name
			Class clas = classForName(fullname);
			
			if ( clas != null )
				return clas;
			// Handle imported inner class case
			// Imported full name wasn't found as an absolute class
			// If it is compound, try to resolve to an inner class.  
			// (maybe this should happen in the BshClassManager?)
			if ( Name.isCompound( fullname ) )
				try {
					clas = getNameResolver( fullname ).toClass();
				} catch ( ClassNotFoundException e ) { /* not a class */ }
			else 
				if ( Interpreter.DEBUG ) Interpreter.debug(
					"imported unpackaged name not found:" +fullname);
			// If found cache the full name in the BshClassManager
			if ( clas != null ) {
				// (should we cache info in not a class case too?)
				getClassManager().cacheClassInfo( fullname, clas );
				return clas;
			}
			// It was explicitly imported, but we don't know what it is.
			// should we throw an error here??
			return null;  
		}
		/*
			Try imported packages, e.g. "import foo.bar.*;"
			in reverse order of import...
			(give later imports precedence...)
		*/
		if ( importedPackages != null )
			for(int i=importedPackages.size()-1; i>=0; i--)
			{
				String s = importedPackages.get(i) + "." + name;
				Class c=classForName(s);
				if ( c != null )
					return c;
			}
		BshClassManager bcm = getClassManager();
		/*
			Try super import if available
			Note: we do this last to allow explicitly imported classes
			and packages to take priority.  This method will also throw an
			error indicating ambiguity if it exists...
		*/
		if ( bcm.hasSuperImport() ) 
		{
			String s = bcm.getClassNameByUnqName( name );
			if ( s != null )
				return classForName( s );
		}
		return null;
    }
	private Class classForName( String name ) 
	{
		return getClassManager().classForName( name );
	}
	/**
		Implements NameSource
		@return all variable and method names in this and all parent
		namespaces
	*/
	public String [] getAllNames() 
	{
		List<String> list = new ArrayList<String>();
		getAllNamesAux( list );
		return list.toArray(new String[0]);
	}
	/**
		Helper for implementing NameSource
	*/
	protected void getAllNamesAux( List<String> list ) 
	{
		list.addAll( variables.keySet() );
		list.addAll( methods.keySet() );
		if ( parent != null )
			parent.getAllNamesAux( list );
	}
	List<NameSource.Listener> nameSourceListeners;
	/**
		Implements NameSource
		Add a listener who is notified upon changes to names in this space.
	*/
	public void addNameSourceListener( NameSource.Listener listener ) {
		if ( nameSourceListeners == null )
			nameSourceListeners = new ArrayList<NameSource.Listener>();
		nameSourceListeners.add( listener );
	}
	
	/**
		Perform "import *;" causing the entire classpath to be mapped.
		This can take a while.
	*/
	public void doSuperImport() 
		throws UtilEvalError
	{
		getClassManager().doSuperImport();
	}
	public String toString() {
		return "NameSpace: " 
			+ ( nsName==null
				? super.toString()
				: nsName + " (" + super.toString() +")" )
			+ ( isClass ? " (isClass) " : "" )
			+ ( isMethod ? " (method) " : "" )
			+ ( classStatic != null ? " (class static) " : "" )
			+ ( classInstance != null ? " (class instance) " : "" );
	}
	/*
		For serialization.
		Don't serialize non-serializable objects.
	*/
    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException 
	{
		// clear name resolvers... don't know if this is necessary.
		names = null;
	
		s.defaultWriteObject();
	}
	/**
		Invoke a method in this namespace with the specified args and
		interpreter reference.  No caller information or call stack is
		required.  The method will appear as if called externally from Java.
		<p>
		see bsh.This.invokeMethod(
			String methodName, Object [] args, Interpreter interpreter, 
			CallStack callstack, SimpleNode callerInfo, boolean )
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter ) 
		throws EvalError
	{
		return invokeMethod( 
			methodName, args, interpreter, null, null );
	}
	/**
		This method simply delegates to This.invokeMethod();
		<p>
		see bsh.This.invokeMethod(
			String methodName, Object [] args, Interpreter interpreter, 
			CallStack callstack, SimpleNode callerInfo )
	*/
	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter, 
		CallStack callstack, SimpleNode callerInfo ) 
		throws EvalError
	{
		return getThis( interpreter ).invokeMethod( 
			methodName, args, interpreter, callstack, callerInfo,
			false/*declaredOnly*/ );
	}
	/**
		Clear all cached classes and names
	*/
	public void classLoaderChanged() {
		nameSpaceChanged();
	}
	/**
		Clear all cached classes and names
	*/
	public void nameSpaceChanged() {
		classCache = null;
		names = null;
	}
	/**
		Import standard packages.  Currently:
		<pre>
			importClass("bsh.EvalError");
			importClass("bsh.Interpreter");
			importPackage("javax.swing.event");
			importPackage("javax.swing");
			importPackage("java.awt.event");
			importPackage("java.awt");
			importPackage("java.net");
			importPackage("java.util");
			importPackage("java.io");
			importPackage("java.lang");
			importCommands("/bsh/commands");
		</pre>
	*/
    public void loadDefaultImports()
    {
		/**
			Note: the resolver looks through these in reverse order, per
			precedence rules...  so for max efficiency put the most common
			ones later.
		*/
		importClass("bsh.EvalError");
		importClass("bsh.Interpreter");
		importPackage("javax.swing.event");
		importPackage("javax.swing");
		importPackage("java.awt.event");
		importPackage("java.awt");
		importPackage("java.net");
		importPackage("java.util");
		importPackage("java.io");
		importPackage("java.lang");
		importCommands("/bsh/commands");
    }
	/**
		This is the factory for Name objects which resolve names within
		this namespace (e.g. toObject(), toClass(), toLHS()).
		<p>
		This was intended to support name resolver caching, allowing 
		Name objects to cache info about the resolution of names for 
		performance reasons.  However this not proven useful yet.  
		<p>
		We'll leave the caching as it will at least minimize Name object
		creation.
		<p>
		(This method would be called getName() if it weren't already used for 
		the simple name of the NameSpace)
		<p>
		This method was public for a time, which was a mistake.  
		Use get() instead.
	*/
	public Name getNameResolver( String ambigname )
	{
		if ( names == null )
			names = new HashMap<String,Name>();
		Name name = names.get( ambigname );
		if ( name == null ) {
			name = new Name( this, ambigname );
			names.put( ambigname, name );
		} 
		return name;
	}
	public int getInvocationLine() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getLineNumber();
		else
			return -1;
	}
	public String getInvocationText() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getText();
		else
			return "<invoked from Java code>";
	}
	/**
		This is a helper method for working inside of bsh scripts and commands.
		In that context it is impossible to see a ClassIdentifier object
		for what it is.  Attempting to access a method on a ClassIdentifier
		will look like a static method invocation.  
		
		This method is in NameSpace for convenience (you don't have to import
		bsh.ClassIdentifier to use it );
	*/
	public static Class identifierToClass( ClassIdentifier ci ) 
	{
		return ci.getTargetClass();
	}
	/**
		Clear all variables, methods, and imports from this namespace.
		If this namespace is the root, it will be reset to the default 
		imports.
		@see #loadDefaultImports()
	*/
	public void clear() 
	{
		variables = null;
		methods = null;
		importedClasses = null;
		importedPackages = null;
		importedCommands = null;
		importedObjects = null;
		if ( parent == null )
			loadDefaultImports();	
    	classCache = null;
		names = null;
	}
	/**
		Import a compiled Java object's methods and variables into this 
		namespace.  When no scripted method / command or variable is found
		locally in this namespace method / fields of the object will be
		checked.  Objects are checked in the order of import with later imports
		taking precedence.
		<p/>
	*/
	/*
		Note: this impor pattern is becoming common... could factor it out into
		an importedObject Vector class.
	*/
	public void importObject( Object obj ) 
	{
		if ( importedObjects == null )
			importedObjects = new ArrayList<Object>();
		// If it exists, remove it and add it at the end (avoid memory leak)
		importedObjects.remove( obj );
		importedObjects.add( obj );
		nameSpaceChanged();
	}
	/**
	*/
	public void importStatic( Class clas ) 
	{
		if ( importedStatic == null )
			importedStatic = new ArrayList<Class>();
		// If it exists, remove it and add it at the end (avoid memory leak)
		importedStatic.remove( clas );
		importedStatic.add( clas );
		nameSpaceChanged();
	}
	/**
		Set the package name for classes defined in this namespace.
		Subsequent sets override the package.
	*/
	public void setPackage( String packageName )
	{
		this.packageName = packageName;
	}
	String getPackage() 
	{
		if ( packageName != null )
			return packageName;
		if ( parent != null )
			return parent.getPackage();
		
		return null;
	}
	NameSpace copy() {
		try {
			final NameSpace clone = (NameSpace) clone();
			clone.thisReference = null;
			clone.variables = clone(variables);
			clone.methods = clone(methods);
			clone.importedClasses = clone(importedClasses);
			clone.importedPackages = clone(importedPackages);
			clone.importedCommands = clone(importedCommands);
			clone.importedObjects = clone(importedObjects);
			clone.importedStatic = clone(importedStatic);
			clone.names = clone(names);
			return clone;
		} catch (CloneNotSupportedException e) {
			throw new IllegalStateException(e);
		}
	}
	private <K,V> Map<K,V> clone(final Map<K,V> map) {
		if (map == null) {
			return null;
		}
		return new HashMap<K,V>(map);
	}
	private <T> List<T> clone(final List<T> list) {
		if (list == null) {
			return null;
		}
		return new ArrayList<T>(list);
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.ArrayList;
/**
 * All of the reflection API code lies here.  It is in the form of static
 * utilities.  Maybe this belongs in LHS.java or a generic object
 * wrapper class.
 */
/*
	Note: This class is messy.  The method and field resolution need to be
	rewritten.  Various methods in here catch NoSuchMethod or NoSuchField
	exceptions during their searches.  These should be rewritten to avoid
	having to catch the exceptions.  Method lookups are now cached at a high 
	level so they are less important, however the logic is messy.
*/
public final class Reflect {
	/**
	 * Invoke method on arbitrary object instance.
	 * invocation may be static (through the object instance) or dynamic.
	 * Object may be a bsh scripted object (bsh.This type).
	 *
	 * @return the result of the method call
	 */
	public static Object invokeObjectMethod(Object object, String methodName, Object[] args, BshEvaluatingVisitor visitor, SimpleNode callerInfo) throws ReflectError, EvalError, InvocationTargetException {
		// Bsh scripted object
		if (object instanceof This && !This.isExposedThisMethod(methodName)) {
			return ((This) object).invokeMethod(methodName, args, visitor.getInterpreter(), visitor.getCallstack(), callerInfo, false/*delcaredOnly*/);
		}
		// Plain Java object, find the java method
		try {
			BshClassManager bcm = visitor.getInterpreter() == null ? null : visitor.getInterpreter().getClassManager();
			Class clas = object.getClass();
			Method method = resolveExpectedJavaMethod(bcm, clas, object, methodName, args, false);
			return invokeMethod(method, object, args);
		} catch (UtilEvalError e) {
			throw e.toEvalError(callerInfo, visitor.getCallstack());
		}
	}
	/**
	 * Invoke a method known to be static.
	 * No object instance is needed and there is no possibility of the
	 * method being a bsh scripted method.
	 */
	public static Object invokeStaticMethod(BshClassManager bcm, Class clas, String methodName, Object[] args) throws ReflectError, UtilEvalError, InvocationTargetException {
		Interpreter.debug("invoke static Method");
		Method method = resolveExpectedJavaMethod(bcm, clas, null, methodName, args, true);
		return invokeMethod(method, null, args);
	}
	/**
	 * Invoke the Java method on the specified object, performing needed
	 * type mappings on arguments and return values.
	 *
	 * @param args may be null
	 */
	public static Object invokeMethod(Method method, Object object, Object[] args) throws ReflectError, InvocationTargetException {
		if (args == null) {
			args = new Object[0];
		}
		logInvokeMethod("Invoking method (entry): ", method, args);
		boolean isVarArgs = method.isVarArgs();
		// Map types to assignable forms, need to keep this fast...
		Class[] types = method.getParameterTypes();
		Object[] tmpArgs = new Object[types.length];
		int fixedArgLen = types.length;
		if (isVarArgs) {
			if (fixedArgLen == args.length && types[fixedArgLen - 1].isAssignableFrom(args[fixedArgLen - 1].getClass())) {
				isVarArgs = false;
			} else {
				fixedArgLen--;
			}
		}
		try {
			for (int i = 0; i < fixedArgLen; i++) {
				tmpArgs[i] = Types.castObject(args[i]/*rhs*/, types[i]/*lhsType*/, Types.ASSIGNMENT);
			}
			if (isVarArgs) {
				Class varType = types[fixedArgLen].getComponentType();
				Object varArgs = Array.newInstance(varType, args.length - fixedArgLen);
				for (int i = fixedArgLen, j = 0; i < args.length; i++, j++) {
					Array.set(varArgs, j, Primitive.unwrap(Types.castObject(args[i]/*rhs*/, varType/*lhsType*/, Types.ASSIGNMENT)));
				}
				tmpArgs[fixedArgLen] = varArgs;
			}
		} catch (UtilEvalError e) {
			throw new InterpreterError("illegal argument type in method invocation: " + e);
		}
		// unwrap any primitives
		tmpArgs = Primitive.unwrap(tmpArgs);
		logInvokeMethod("Invoking method (after massaging values): ", method, tmpArgs);
		try {
			Object returnValue = method.invoke(object, tmpArgs);
			if (returnValue == null) {
				returnValue = Primitive.NULL;
			}
			Class returnType = method.getReturnType();
			return Primitive.wrap(returnValue, returnType);
		} catch (IllegalAccessException e) {
			throw new ReflectError("Cannot access method " + StringUtil.methodString(method.getName(), method.getParameterTypes()) + " in '" + method.getDeclaringClass() + "' :" + e, e);
		}
	}
	public static Object getIndex(Object array, int index) throws ReflectError, UtilTargetError {
		if (Interpreter.DEBUG) {
			Interpreter.debug("getIndex: " + array + ", index=" + index);
		}
		try {
			Object val = Array.get(array, index);
			return Primitive.wrap(val, array.getClass().getComponentType());
		} catch (ArrayIndexOutOfBoundsException e1) {
			throw new UtilTargetError(e1);
		} catch (Exception e) {
			throw new ReflectError("Array access:" + e);
		}
	}
	public static void setIndex(Object array, int index, Object val) throws ReflectError, UtilTargetError {
		try {
			val = Primitive.unwrap(val);
			Array.set(array, index, val);
		} catch (ArrayStoreException e2) {
			throw new UtilTargetError(e2);
		} catch (IllegalArgumentException e1) {
			//noinspection ThrowableInstanceNeverThrown
			throw new UtilTargetError(new ArrayStoreException(e1.toString()));
		} catch (Exception e) {
			throw new ReflectError("Array access:" + e);
		}
	}
	public static Object getStaticFieldValue(Class clas, String fieldName) throws UtilEvalError, ReflectError {
		return getFieldValue(clas, null, fieldName, true/*onlystatic*/);
	}
	/**
	 */
	public static Object getObjectFieldValue(Object object, String fieldName) throws UtilEvalError, ReflectError {
		if (object instanceof This) {
			return ((This) object).namespace.getVariable(fieldName);
		} else if (object == Primitive.NULL) {
			//noinspection ThrowableInstanceNeverThrown
			throw new UtilTargetError(new NullPointerException("Attempt to access field '" + fieldName + "' on null value"));
		} else {
			try {
				return getFieldValue(object.getClass(), object, fieldName, false/*onlystatic*/);
			} catch (ReflectError e) {
				// no field, try property acces
				if (hasObjectPropertyGetter(object.getClass(), fieldName)) {
					return getObjectProperty(object, fieldName);
				} else {
					throw e;
				}
			}
		}
	}
	public static LHS getLHSStaticField(Class clas, String fieldName) throws UtilEvalError, ReflectError {
		Field f = resolveExpectedJavaField(clas, fieldName, true/*onlystatic*/);
		return new LHS(f);
	}
	/**
	 * Get an LHS reference to an object field.
	 * <p/>
	 * This method also deals with the field style property access.
	 * In the field does not exist we check for a property setter.
	 */
	public static LHS getLHSObjectField(Object object, String fieldName) throws UtilEvalError, ReflectError {
		if (object instanceof This) {
			// I guess this is when we pass it as an argument?
			// Setting locally
			boolean recurse = false;
			return new LHS(((This) object).namespace, fieldName, recurse);
		}
		try {
			Field f = resolveExpectedJavaField(object.getClass(), fieldName, false/*staticOnly*/);
			return new LHS(object, f);
		} catch (ReflectError e) {
			// not a field, try property access
			if (hasObjectPropertySetter(object.getClass(), fieldName)) {
				return new LHS(object, fieldName);
			} else {
				throw e;
			}
		}
	}
	private static Object getFieldValue(Class clas, Object object, String fieldName, boolean staticOnly) throws UtilEvalError, ReflectError {
		try {
			Field f = resolveExpectedJavaField(clas, fieldName, staticOnly);
			Object value = f.get(object);
			Class returnType = f.getType();
			return Primitive.wrap(value, returnType);
		} catch (NullPointerException e) { // shouldn't happen
			throw new ReflectError("???" + fieldName + " is not a static field.");
		} catch (IllegalAccessException e) {
			throw new ReflectError("Can't access field: " + fieldName);
		}
	}
	/*
			 Note: this method and resolveExpectedJavaField should be rewritten
			 to invert this logic so that no exceptions need to be caught
			 unecessarily.  This is just a temporary impl.
			 @return the field or null if not found
		 */
	protected static Field resolveJavaField(Class clas, String fieldName, boolean staticOnly) throws UtilEvalError {
		try {
			return resolveExpectedJavaField(clas, fieldName, staticOnly);
		} catch (ReflectError e) {
			return null;
		}
	}
	/**
	 * @throws ReflectError if the field is not found.
	 */
	/*
			 Note: this should really just throw NoSuchFieldException... need
			 to change related signatures and code.
		 */
	protected static Field resolveExpectedJavaField(Class clas, String fieldName, boolean staticOnly) throws UtilEvalError, ReflectError {
		Field field;
		try {
			if (Capabilities.haveAccessibility()) {
				field = findAccessibleField(clas, fieldName);
			} else
			// Class getField() finds only public (and in interfaces, etc.)
			{
				field = clas.getField(fieldName);
			}
		} catch (NoSuchFieldException e) {
			throw new ReflectError("No such field: " + fieldName, e);
		} catch (SecurityException e) {
			throw new UtilTargetError("Security Exception while searching fields of: " + clas, e);
		}
		if (staticOnly && !Modifier.isStatic(field.getModifiers())) {
			throw new UtilEvalError("Can't reach instance field: " + fieldName + " from static context: " + clas.getName());
		}
		return field;
	}
	/**
	 * Used when accessibility capability is available to locate an occurrance
	 * of the field in the most derived class or superclass and set its
	 * accessibility flag.
	 * Note that this method is not needed in the simple non accessible
	 * case because we don't have to hunt for fields.
	 * Note that classes may declare overlapping private fields, so the
	 * distinction about the most derived is important.  Java doesn't normally
	 * allow this kind of access (super won't show private variables) so
	 * there is no real syntax for specifying which class scope to use...
	 *
	 * @return the Field or throws NoSuchFieldException
	 * @throws NoSuchFieldException if the field is not found
	 */
	/*
			 This method should be rewritten to use getFields() and avoid catching
			 exceptions during the search.
		 */
	private static Field findAccessibleField(Class clas, String fieldName) throws UtilEvalError, NoSuchFieldException {
		Field field;
		// Quick check catches public fields include those in interfaces
		try {
			field = clas.getField(fieldName);
			field.setAccessible(true);
			return field;
		} catch (NoSuchFieldException e) {
			// fallthrough
		}
		// Now, on with the hunt...
		while (clas != null) {
			try {
				field = clas.getDeclaredField(fieldName);
				field.setAccessible(true);
				return field;
				// Not found, fall through to next class
			} catch (NoSuchFieldException e) {
				// fallthrough
			}
			clas = clas.getSuperclass();
		}
		throw new NoSuchFieldException(fieldName);
	}
	/**
	 * This method wraps resolveJavaMethod() and expects a non-null method
	 * result. If the method is not found it throws a descriptive ReflectError.
	 */
	protected static Method resolveExpectedJavaMethod(BshClassManager bcm, Class clas, Object object, String name, Object[] args, boolean staticOnly) throws ReflectError, UtilEvalError {
		if (object == Primitive.NULL) {
			//noinspection ThrowableInstanceNeverThrown
			throw new UtilTargetError(new NullPointerException("Attempt to invoke method " + name + " on null value"));
		}
		Class[] types = Types.getTypes(args);
		Method method = resolveJavaMethod(bcm, clas, name, types, staticOnly);
		if (method == null) {
			throw new ReflectError((staticOnly ? "Static method " : "Method ") + StringUtil.methodString(name, types) + " not found in class'" + clas.getName() + "'");
		}
		return method;
	}
	/**
	 * The full blown resolver method.  All other method invocation methods
	 * delegate to this.  The method may be static or dynamic unless
	 * staticOnly is set (in which case object may be null).
	 * If staticOnly is set then only static methods will be located.
	 * <p/>
	 * <p/>
	 * This method performs caching (caches discovered methods through the
	 * class manager and utilizes cached methods.)
	 * <p/>
	 * <p/>
	 * This method determines whether to attempt to use non-public methods
	 * based on Capabilities.haveAccessibility() and will set the accessibilty
	 * flag on the method as necessary.
	 * <p/>
	 * <p/>
	 * If, when directed to find a static method, this method locates a more
	 * specific matching instance method it will throw a descriptive exception
	 * analogous to the error that the Java compiler would produce.
	 * Note: as of 2.0.x this is a problem because there is no way to work
	 * around this with a cast.
	 * <p/>
	 *
	 * @param staticOnly The method located must be static, the object param may be null.
	 * @return the method or null if no matching method was found.
	 */
	protected static Method resolveJavaMethod(BshClassManager bcm, Class clas, String name, Class[] types, boolean staticOnly) throws UtilEvalError {
		if (clas == null) {
			throw new InterpreterError("null class");
		}
		// Lookup previously cached method
		Method method = null;
		if (bcm == null) {
			Interpreter.debug("resolveJavaMethod UNOPTIMIZED lookup");
		} else {
			method = bcm.getResolvedMethod(clas, name, types, staticOnly);
		}
		if (method == null) {
			boolean publicOnly = !Capabilities.haveAccessibility();
			// Searching for the method may, itself be a priviledged action
			try {
				method = findOverloadedMethod(clas, name, types, publicOnly);
			} catch (SecurityException e) {
				throw new UtilTargetError("Security Exception while searching methods of: " + clas, e);
			}
			checkFoundStaticMethod(method, staticOnly, clas);
			// This is the first time we've seen this method, set accessibility
			// Note: even if it's a public method, we may have found it in a
			// non-public class
			if (method != null && (!publicOnly || isPublic(method))) {
				method.setAccessible(true);
			}
			// If succeeded cache the resolved method.
			if (method != null && bcm != null) {
				bcm.cacheResolvedMethod(clas, types, method);
			}
		}
		return method;
	}
	/**
	 * Get the candidate methods by searching the class and interface graph
	 * of baseClass and resolve the most specific.
	 *
	 * @return the method or null for not found
	 */
	private static Method findOverloadedMethod(Class baseClass, String methodName, Class[] types, boolean publicOnly) {
		if (Interpreter.DEBUG) {
			Interpreter.debug("Searching for method: " + StringUtil.methodString(methodName, types) + " in '" + baseClass.getName() + "'");
		}
		List<Method> publicMethods = new ArrayList<Method>();
		List<Method> nonPublicMethods = publicOnly ? null : new ArrayList<Method>();
		gatherMethodsRecursive(baseClass, methodName, types.length, publicMethods, nonPublicMethods);
		if (Interpreter.DEBUG) {
			Interpreter.debug("Looking for most specific method: " + methodName);
		}
		Method method = findMostSpecificMethod(types, publicMethods);
		if (method == null && nonPublicMethods != null) {
			method = findMostSpecificMethod(types, nonPublicMethods);
		}
		return method;
	}
	/*
			 Climb the class and interface inheritence graph of the type and collect
			 all methods matching the specified name and criterion.  If publicOnly
			 is true then only public methods in *public* classes or interfaces will
			 be returned.  In the normal (non-accessible) case this addresses the
			 problem that arises when a package private class or private inner class
			 implements a public interface or derives from a public type.
			  <p/>
			 preseving old comments for deleted getCandidateMethods() - fschmidt
		 */
	/**
	 * Accumulate all methods, optionally including non-public methods,
	 * class and interface, in the inheritence tree of baseClass.
	 * <p/>
	 * This method is analogous to Class getMethods() which returns all public
	 * methods in the inheritence tree.
	 * <p/>
	 * In the normal (non-accessible) case this also addresses the problem
	 * that arises when a package private class or private inner class
	 * implements a public interface or derives from a public type.  In other
	 * words, sometimes we'll find public methods that we can't use directly
	 * and we have to find the same public method in a parent class or
	 * interface.
	 *
	 * @return the candidate methods vector
	 */
	private static void gatherMethodsRecursive(Class baseClass, String methodName, int numArgs, List<Method> publicMethods, List<Method> nonPublicMethods) {
		// Do we have a superclass? (interfaces don't, etc.)
		Class superclass = baseClass.getSuperclass();
		if (superclass != null) {
			gatherMethodsRecursive(superclass, methodName, numArgs, publicMethods, nonPublicMethods);
		}
		// Add methods of the current class to the list.
		// In public case be careful to only add methods from a public class
		// and to use getMethods() instead of getDeclaredMethods()
		// (This addresses secure environments)
		boolean isPublicClass = isPublic(baseClass);
		if (isPublicClass || nonPublicMethods != null) {
			Method[] methods = nonPublicMethods == null ? baseClass.getMethods() : baseClass.getDeclaredMethods();
			for (Method m : methods) {
				if (m.getName().equals(methodName) && (m.isVarArgs() ? m.getParameterTypes().length - 1 <= numArgs : m.getParameterTypes().length == numArgs)) {
					if (isPublicClass && isPublic(m)) {
						publicMethods.add(m);
					} else if (nonPublicMethods != null) {
						nonPublicMethods.add(m);
					}
				}
			}
		}
		// Does the class or interface implement interfaces?
		for (Class intf : baseClass.getInterfaces()) {
			gatherMethodsRecursive(intf, methodName, numArgs, publicMethods, nonPublicMethods);
		}
	}
	/**
	 * Primary object constructor
	 * This method is simpler than those that must resolve general method
	 * invocation because constructors are not inherited.
	 * <p/>
	 * This method determines whether to attempt to use non-public constructors
	 * based on Capabilities.haveAccessibility() and will set the accessibilty
	 * flag on the method as necessary.
	 * <p/>
	 */
	public static Object constructObject(Class clas, Object[] args) throws ReflectError, InvocationTargetException {
		if (clas.isInterface()) {
			throw new ReflectError("Can't create instance of an interface: " + clas);
		}
		Class[] types = Types.getTypes(args);
		// Find the constructor.
		// (there are no inherited constructors to worry about)
		Constructor[] constructors = Capabilities.haveAccessibility() ? clas.getDeclaredConstructors() : clas.getConstructors();
		if (Interpreter.DEBUG) {
			Interpreter.debug("Looking for most specific constructor: " + clas);
		}
		Constructor con = findMostSpecificConstructor(types, constructors);
		if (con == null) {
			throw cantFindConstructor(clas, types);
		}
		if (!isPublic(con)) {
			con.setAccessible(true);
		}
		args = Primitive.unwrap(args);
		try {
			return con.newInstance(args);
		} catch (InstantiationException e) {
			throw new ReflectError("The class " + clas + " is abstract ");
		} catch (IllegalAccessException e) {
			throw new ReflectError("We don't have permission to create an instance." + "Use setAccessibility(true) to enable access.");
		} catch (IllegalArgumentException e) {
			throw new ReflectError("The number of arguments was wrong");
		}
	}
	/*
			This method should parallel findMostSpecificMethod()
			The only reason it can't be combined is that Method and Constructor
			don't have a common interface for their signatures
		*/
	static Constructor findMostSpecificConstructor(Class[] idealMatch, Constructor[] constructors) {
		int match = findMostSpecificConstructorIndex(idealMatch, constructors);
		return (match == -1) ? null : constructors[match];
	}
	static int findMostSpecificConstructorIndex(Class[] idealMatch, Constructor[] constructors) {
		Class[][] candidates = new Class[constructors.length][];
		for (int i = 0; i < candidates.length; i++) {
			candidates[i] = constructors[i].getParameterTypes();
		}
		return findMostSpecificSignature(idealMatch, candidates);
	}
	/**
	 * Find the best match for signature idealMatch.
	 * It is assumed that the methods array holds only valid candidates
	 * (e.g. method name and number of args already matched).
	 * This method currently does not take into account Java 5 covariant
	 * return types... which I think will require that we find the most
	 * derived return type of otherwise identical best matches.
	 *
	 * @param methods the set of candidate method which differ only in the
	 *                types of their arguments.
	 * @see #findMostSpecificSignature(Class[], Class[][])
	 */
	private static Method findMostSpecificMethod(Class[] idealMatch, List<Method> methods) {
		// copy signatures into array for findMostSpecificMethod()
		List<Class[]> candidateSigs = new ArrayList<Class[]>();
		List<Method> methodList = new ArrayList<Method>();
		for (Method method : methods) {
			Class[] parameterTypes = method.getParameterTypes();
			methodList.add(method);
			candidateSigs.add(parameterTypes);
			if (method.isVarArgs()) {
				Class[] candidateSig = new Class[idealMatch.length];
				int j = 0;
				for (; j < parameterTypes.length - 1; j++) {
					candidateSig[j] = parameterTypes[j];
				}
				Class varType = parameterTypes[j].getComponentType();
				for (; j < idealMatch.length; j++) {
					candidateSig[j] = varType;
				}
				methodList.add(method);
				candidateSigs.add(candidateSig);
			}
		}
		int match = findMostSpecificSignature(idealMatch, candidateSigs.toArray(new Class[candidateSigs.size()][]));
		return match == -1 ? null : methodList.get(match);
	}
	/**
	 * Implement JLS 15.11.2
	 * Return the index of the most specific arguments match or -1 if no
	 * match is found.
	 * This method is used by both methods and constructors (which
	 * unfortunately don't share a common interface for signature info).
	 *
	 * @return the index of the most specific candidate
	 */
	/*
		  Note: Two methods which are equally specific should not be allowed by
		  the Java compiler.  In this case BeanShell currently chooses the first
		  one it finds.  We could add a test for this case here (I believe) by
		  adding another isSignatureAssignable() in the other direction between
		  the target and "best" match.  If the assignment works both ways then
		  neither is more specific and they are ambiguous.  I'll leave this test
		  out for now because I'm not sure how much another test would impact
		  performance.  Method selection is now cached at a high level, so a few
		  friendly extraneous tests shouldn't be a problem.
		 */
	static int findMostSpecificSignature(Class[] idealMatch, Class[][] candidates) {
		for (int round = Types.FIRST_ROUND_ASSIGNABLE; round <= Types.LAST_ROUND_ASSIGNABLE; round++) {
			Class[] bestMatch = null;
			int bestMatchIndex = -1;
			for (int i = 0; i < candidates.length; i++) {
				Class[] targetMatch = candidates[i];
				// If idealMatch fits targetMatch and this is the first match
				// or targetMatch is more specific than the best match, make it
				// the new best match.
				if (Types.isSignatureAssignable(idealMatch, targetMatch, round) && ((bestMatch == null) || Types.isSignatureAssignable(targetMatch, bestMatch, Types.JAVA_BASE_ASSIGNABLE))) {
					bestMatch = targetMatch;
					bestMatchIndex = i;
				}
			}
			if (bestMatch != null) {
				return bestMatchIndex;
			}
		}
		return -1;
	}
	private static String accessorName(String getorset, String propName) {
		return getorset + String.valueOf(Character.toUpperCase(propName.charAt(0))) + propName.substring(1);
	}
	public static boolean hasObjectPropertyGetter(Class clas, String propName) {
		if (clas == Primitive.class) {
			return false;
		}
		String getterName = accessorName("get", propName);
		try {
			clas.getMethod(getterName, new Class[0]);
			return true;
		} catch (NoSuchMethodException e) { /* fall through */ }
		getterName = accessorName("is", propName);
		try {
			Method m = clas.getMethod(getterName, new Class[0]);
			return (m.getReturnType() == Boolean.TYPE);
		} catch (NoSuchMethodException e) {
			return false;
		}
	}
	public static boolean hasObjectPropertySetter(Class clas, String propName) {
		String setterName = accessorName("set", propName);
		Method[] methods = clas.getMethods();
		// we don't know the right hand side of the assignment yet.
		// has at least one setter of the right name?
		for (Method method : methods) {
			if (method.getName().equals(setterName)) {
				return true;
			}
		}
		return false;
	}
	public static Object getObjectProperty(Object obj, String propName) throws UtilEvalError, ReflectError {
		Object[] args = new Object[]{};
		Interpreter.debug("property access: ");
		Method method = null;
		Exception e1 = null, e2 = null;
		try {
			String accessorName = accessorName("get", propName);
			method = resolveExpectedJavaMethod(null/*bcm*/, obj.getClass(), obj, accessorName, args, false);
		} catch (Exception e) {
			e1 = e;
		}
		if (method == null) {
			try {
				String accessorName = accessorName("is", propName);
				method = resolveExpectedJavaMethod(null/*bcm*/, obj.getClass(), obj, accessorName, args, false);
				if (method.getReturnType() != Boolean.TYPE) {
					method = null;
				}
			} catch (Exception e) {
				e2 = e;
			}
		}
		if (method == null) {
			throw new ReflectError("Error in property getter: " + e1 + (e2 != null ? " : " + e2 : ""));
		}
		try {
			return invokeMethod(method, obj, args);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Property accessor threw exception: " + e.getTargetException());
		}
	}
	public static void setObjectProperty(Object obj, String propName, Object value) throws ReflectError, UtilEvalError {
		String accessorName = accessorName("set", propName);
		Object[] args = new Object[]{value};
		Interpreter.debug("property access: ");
		try {
			Method method = resolveExpectedJavaMethod(null/*bcm*/, obj.getClass(), obj, accessorName, args, false);
			invokeMethod(method, obj, args);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Property accessor threw exception: " + e.getTargetException());
		}
	}
	/**
	 * Return a more human readable version of the type name.
	 * Specifically, array types are returned with postfix "[]" dimensions.
	 * e.g. return "int []" for integer array instead of "class [I" as
	 * would be returned by Class getName() in that case.
	 */
	public static String normalizeClassName(Class type) {
		if (!type.isArray()) {
			return type.getName();
		}
		StringBuilder className = new StringBuilder();
		try {
			className.append(getArrayBaseType(type).getName()).append(' ');
			for (int i = 0; i < getArrayDimensions(type); i++) {
				className.append("[]");
			}
		} catch (ReflectError e) {
			/*shouldn't happen*/
		}
		return className.toString();
	}
	/**
	 * returns the dimensionality of the Class
	 * returns 0 if the Class is not an array class
	 */
	public static int getArrayDimensions(Class arrayClass) {
		if (!arrayClass.isArray()) {
			return 0;
		}
		return arrayClass.getName().lastIndexOf('[') + 1;  // why so cute?
	}
	/**
	 * Returns the base type of an array Class.
	 * throws ReflectError if the Class is not an array class.
	 */
	public static Class getArrayBaseType(Class arrayClass) throws ReflectError {
		if (!arrayClass.isArray()) {
			throw new ReflectError("The class is not an array.");
		}
		return arrayClass.getComponentType();
	}
	/**
	 * A command may be implemented as a compiled Java class containing one or
	 * more static invoke() methods of the correct signature.  The invoke()
	 * methods must accept two additional leading arguments of the interpreter
	 * and callstack, respectively. e.g. invoke(interpreter, callstack, ... )
	 * This method adds the arguments and invokes the static method, returning
	 * the result.
	 */
	public static Object invokeCompiledCommand(Class commandClass, Object[] args, BshEvaluatingVisitor visitor) throws UtilEvalError {
		// add interpereter and namespace to args list
		Object[] invokeArgs = new Object[args.length + 2];
		invokeArgs[0] = visitor.getInterpreter();
		invokeArgs[1] = visitor.getCallstack();
		System.arraycopy(args, 0, invokeArgs, 2, args.length);
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		try {
			return Reflect.invokeStaticMethod(bcm, commandClass, "invoke", invokeArgs);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Error in compiled command: " + e.getTargetException(), e);
		} catch (ReflectError e) {
			throw new UtilEvalError("Error invoking compiled command: " + e, e);
		}
	}
	private static void logInvokeMethod(String msg, Method method, Object[] args) {
		if (Interpreter.DEBUG) {
			Interpreter.debug(msg + method + " with args:");
			for (int i = 0; i < args.length; i++) {
				final Object arg = args[i];
				Interpreter.debug("args[" + i + "] = " + arg + " type = " + (arg == null ? "<unkown>" : arg.getClass()));
			}
		}
	}
	private static void checkFoundStaticMethod(Method method, boolean staticOnly, Class clas) throws UtilEvalError {
		// We're looking for a static method but found an instance method
		if (method != null && staticOnly && !isStatic(method)) {
			throw new UtilEvalError("Cannot reach instance method: " + StringUtil.methodString(method.getName(), method.getParameterTypes()) + " from static context: " + clas.getName());
		}
	}
	private static ReflectError cantFindConstructor(Class clas, Class[] types) {
		if (types.length == 0) {
			return new ReflectError("Can't find default constructor for: " + clas);
		} else {
			return new ReflectError("Can't find constructor: " + StringUtil.methodString(clas.getName(), types) + " in class: " + clas.getName());
		}
	}
	private static boolean isPublic(Class c) {
		return Modifier.isPublic(c.getModifiers());
	}
	private static boolean isPublic(Method m) {
		return Modifier.isPublic(m.getModifiers());
	}
	private static boolean isPublic(Constructor c) {
		return Modifier.isPublic(c.getModifiers());
	}
	private static boolean isStatic(Method m) {
		return Modifier.isStatic(m.getModifiers());
	}
}
package bsh;
import bsh.ast.SimpleNode;
import java.lang.reflect.InvocationTargetException;
import java.io.PrintStream;
/**
	TargetError is an EvalError that wraps an exception thrown by the script	
	(or by code called from the script).  TargetErrors indicate exceptions 
	which can be caught within the script itself, whereas a general EvalError 
	indicates that the script cannot be evaluated further for some reason.
	
	If the exception is caught within the script it is automatically unwrapped,
	so the code looks like normal Java code.  If the TargetError is thrown
	from the eval() or interpreter.eval() method it may be caught and unwrapped
	to determine what exception was thrown.
*/
public final class TargetError extends EvalError 
{
	private final boolean inNativeCode;
	public TargetError(
		String msg, Throwable t, SimpleNode node, CallStack callstack,
		boolean inNativeCode )
	{
		super( msg, node, callstack, t );
		this.inNativeCode = inNativeCode;
	}
	public TargetError( Throwable t, SimpleNode node, CallStack callstack )
	{
		this("TargetError", t, node, callstack, false);
	}
	public Throwable getTarget()
	{
		// check for easy mistake
		Throwable target = getCause();
		if(target instanceof InvocationTargetException)
			return((InvocationTargetException)target).getTargetException();
		else
			return target;
	}
	public String getMessage() 
	{
		return super.getMessage() 
			+ "\nTarget exception: " + 
			printTargetError( getCause() );
	}
    public void printStackTrace( boolean debug, PrintStream out ) {
		if ( debug ) {
			super.printStackTrace( out );
			out.println("--- Target Stack Trace ---");
		}
		getCause().printStackTrace( out );
	}
	/**
		Generate a printable string showing the wrapped target exception.
		If the proxy mechanism is available, allow the extended print to
		check for UndeclaredThrowableException and print that embedded error.
	*/
	private String printTargetError( Throwable t ) 
	{
		return getCause().toString() + "\n" + xPrintTargetError( t );
	}
	/**
		Extended form of print target error.
		This indirection is used to print UndeclaredThrowableExceptions 
		which are possible when the proxy mechanism is available.
		We are shielded from compile problems by using a bsh script.
		This is acceptable here because we're not in a critical path...
		Otherwise we'd need yet another dynamically loaded module just for this.
	*/
	private String xPrintTargetError( Throwable t ) 
	{
		String getTarget =
			"import java.lang.reflect.UndeclaredThrowableException;"+
			"String result=\"\";"+
			"while ( target instanceof UndeclaredThrowableException ) {"+
			"	target=target.getUndeclaredThrowable(); " +
			"	result+=\"Nested: \"+target.toString();" +
			"}"+
			"return result;";
		Interpreter i = new Interpreter();
		try {
			i.set("target", t);
			return (String)i.eval( getTarget );
		} catch ( EvalError e ) {
			throw new InterpreterError("xprintarget: "+e.toString() );
		}
	}
	/**
		Return true if the TargetError was generated from native code.
		e.g. if the script called into a compiled java class which threw
		the excpetion.  We distinguish so that we can print the stack trace
		for the native code case... the stack trace would not be useful if
		the exception was generated by the script.  e.g. if the script
		explicitly threw an exception... (the stack trace would simply point
		to the bsh internals which generated the exception).
	*/
	public boolean inNativeCode() { 
		return inNativeCode; 
	}
}
package bsh;
import java.io.ObjectStreamException;
import java.util.HashMap;
import java.util.Map;
/**
    Wrapper for primitive types in Bsh.  This is package public because it 
	is used in the implementation of some bsh commands.
    See the note in LHS.java about wrapping objects.
*/
/*
	Note: this class is final because we may test == Primitive.class in places.
	If we need to change that search for those tests.
*/
public final class Primitive implements ParserConstants, java.io.Serializable
{
	/*
	static Hashtable primitiveToWrapper = new Hashtable();
	static Hashtable wrapperToPrimitive = new Hashtable();
	static {
		primitiveToWrapper.put( Boolean.TYPE, Boolean.class );
		primitiveToWrapper.put( Byte.TYPE, Byte.class );
		primitiveToWrapper.put( Short.TYPE, Short.class );
		primitiveToWrapper.put( Character.TYPE, Character.class );
		primitiveToWrapper.put( Integer.TYPE, Integer.class );
		primitiveToWrapper.put( Long.TYPE, Long.class );
		primitiveToWrapper.put( Float.TYPE, Float.class );
		primitiveToWrapper.put( Double.TYPE, Double.class );
		wrapperToPrimitive.put( Boolean.class, Boolean.TYPE );
		wrapperToPrimitive.put( Byte.class, Byte.TYPE );
		wrapperToPrimitive.put( Short.class, Short.TYPE );
		wrapperToPrimitive.put( Character.class, Character.TYPE );
		wrapperToPrimitive.put( Integer.class, Integer.TYPE );
		wrapperToPrimitive.put( Long.class, Long.TYPE );
		wrapperToPrimitive.put( Float.class, Float.TYPE );
		wrapperToPrimitive.put( Double.class, Double.TYPE );
	}
	*/
	static final Map<Class,Class> wrapperMap = new HashMap<Class,Class>();
	static {
		wrapperMap.put( Boolean.TYPE, Boolean.class );
		wrapperMap.put( Byte.TYPE, Byte.class );
		wrapperMap.put( Short.TYPE, Short.class );
		wrapperMap.put( Character.TYPE, Character.class );
		wrapperMap.put( Integer.TYPE, Integer.class );
		wrapperMap.put( Long.TYPE, Long.class );
		wrapperMap.put( Float.TYPE, Float.class );
		wrapperMap.put( Double.TYPE, Double.class );
		wrapperMap.put( Boolean.class, Boolean.TYPE );
		wrapperMap.put( Byte.class, Byte.TYPE );
		wrapperMap.put( Short.class, Short.TYPE );
		wrapperMap.put( Character.class, Character.TYPE );
		wrapperMap.put( Integer.class, Integer.TYPE );
		wrapperMap.put( Long.class, Long.TYPE );
		wrapperMap.put( Float.class, Float.TYPE );
		wrapperMap.put( Double.class, Double.TYPE );
	}
    /** The primitive value stored in its java.lang wrapper class */
    private Object value;
    private static class Special implements java.io.Serializable
    {
        private Special() { }
        public static final Special NULL_VALUE = new Special()
        {
            private Object readResolve() throws ObjectStreamException
            {
                return Special.NULL_VALUE;
            }
        };
        public static final Special VOID_TYPE = new Special()
        {
            private Object readResolve() throws ObjectStreamException
            {
                return Special.VOID_TYPE;
            }
        };
    }
    /*
        NULL means "no value".
        This ia a placeholder for primitive null value.
    */
    public static final Primitive NULL = new Primitive(Special.NULL_VALUE);
    /**
        VOID means "no type".
        Strictly speaking, this makes no sense here.  But for practical
        reasons we'll consider the lack of a type to be a special value.
    */
    public static final Primitive VOID = new Primitive(Special.VOID_TYPE);
    
    private Object readResolve() throws ObjectStreamException
    {
        if (value == Special.NULL_VALUE)
        {
            return Primitive.NULL;
        }
        else if (value == Special.VOID_TYPE)
        {
            return Primitive.VOID;
        }
        else
        {
            return this;
        }
    }
    // private to prevent invocation with param that isn't a primitive-wrapper
    public Primitive( Object value )
    {
        if ( value == null )
            throw new InterpreterError(
				"Use Primitve.NULL instead of Primitive(null)");
		if ( value != Special.NULL_VALUE 
			&& value != Special.VOID_TYPE &&
			!isWrapperType( value.getClass() ) 
		)
            throw new InterpreterError( "Not a wrapper type: "+value);
        this.value = value;
    }
    public Primitive(boolean value) { this(new Boolean(value)); }
    public Primitive(byte value) { this(new Byte(value)); }
    public Primitive(short value) { this(new Short(value)); }
    public Primitive(char value) { this(new Character(value)); }
    public Primitive(int value) { this(new Integer(value)); }
    public Primitive(long value) { this(new Long(value)); }
    public Primitive(float value) { this(new Float(value)); }
    public Primitive(double value) { this(new Double(value)); }
	/**
    	Return the primitive value stored in its java.lang wrapper class
	*/
    public Object getValue()
    {
        if ( value == Special.NULL_VALUE )
            return null;
        else 
		if ( value == Special.VOID_TYPE )
                throw new InterpreterError("attempt to unwrap void type");
        else
            return value;
    }
    public String toString()
    {
        if(value == Special.NULL_VALUE)
            return "null";
        else if(value == Special.VOID_TYPE)
            return "void";
        else
            return value.toString();
    }
	/**
		Get the corresponding Java primitive TYPE class for this Primitive.
		@return the primitive TYPE class type of the value or Void.TYPE for
		Primitive.VOID or null value for type of Primitive.NULL
	*/
    public Class getType()
    {
		if ( this == Primitive.VOID )
			return Void.TYPE;
		// NULL return null as type... we currently use null type to indicate 
		// loose typing throughout bsh.
		if ( this == Primitive.NULL )
			return null;
		return unboxType( value.getClass() );
    }
	/**
		Perform a binary operation on two Primitives or wrapper types.
		If both original args were Primitives return a Primitive result
		else it was mixed (wrapper/primitive) return the wrapper type.
		The exception is for boolean operations where we will return the 
		primitive type either way.
	*/
    public static Object binaryOperation(
		Object obj1, Object obj2, int kind)
        throws UtilEvalError
    {
		// special primitive types
        if ( obj1 == NULL || obj2 == NULL )
            throw new UtilEvalError(
				"Null value or 'null' literal in binary operation");
        if ( obj1 == VOID || obj2 == VOID )
            throw new UtilEvalError(
			"Undefined variable, class, or 'void' literal in binary operation");
		// keep track of the original types
		Class lhsOrgType = obj1.getClass();
		Class rhsOrgType = obj2.getClass();
		// Unwrap primitives
        if ( obj1 instanceof Primitive )
            obj1 = ((Primitive)obj1).getValue();
        if ( obj2 instanceof Primitive )
            obj2 = ((Primitive)obj2).getValue();
        Object[] operands = promotePrimitives(obj1, obj2);
        Object lhs = operands[0];
        Object rhs = operands[1];
        if(lhs.getClass() != rhs.getClass())
            throw new UtilEvalError("Type mismatch in operator.  " 
			+ lhs.getClass() + " cannot be used with " + rhs.getClass() );
		Object result;
		try {
			result = binaryOperationImpl( lhs, rhs, kind );
		} catch ( ArithmeticException e ) {
			throw new UtilTargetError( "Arithemetic Exception in binary op", e);
		}
		// If both original args were Primitives return a Primitive result
		// else it was mixed (wrapper/primitive) return the wrapper type
		// Exception is for boolean result, return the primitive
		if ( (lhsOrgType == Primitive.class && rhsOrgType == Primitive.class)
			|| result instanceof Boolean
		)
			return new Primitive( result );
		else
			return result;
    }
    public static Object binaryOperationImpl( Object lhs, Object rhs, int kind )
        throws UtilEvalError
	{
        if(lhs instanceof Boolean)
            return booleanBinaryOperation((Boolean)lhs, (Boolean)rhs, kind);
        else if(lhs instanceof Integer)
            return intBinaryOperation( (Integer)lhs, (Integer)rhs, kind );
        else if(lhs instanceof Long)
            return longBinaryOperation((Long)lhs, (Long)rhs, kind);
        else if(lhs instanceof Float)
            return floatBinaryOperation((Float)lhs, (Float)rhs, kind);
        else if(lhs instanceof Double)
            return doubleBinaryOperation( (Double)lhs, (Double)rhs, kind);
        else
            throw new UtilEvalError("Invalid types in binary operator" );
	}
    public static Boolean booleanBinaryOperation(Boolean B1, Boolean B2, int kind)
    {
        boolean lhs = B1.booleanValue();
        boolean rhs = B2.booleanValue();
        switch(kind)
        {
            case EQ:
                return new Boolean(lhs == rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case BOOL_OR:
            case BOOL_ORX:
            case BIT_OR:
                return new Boolean( lhs || rhs );
            case BOOL_AND:
            case BOOL_ANDX:
            case BIT_AND:
                return new Boolean( lhs && rhs );
	    
            case XOR:
                return new Boolean( lhs ^ rhs );
            default:
                throw new InterpreterError("unimplemented binary operator");
        }
    }
    // returns Object covering both Long and Boolean return types
    public static Object longBinaryOperation(Long L1, Long L2, int kind)
    {
        long lhs = L1.longValue();
        long rhs = L2.longValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Long(lhs + rhs);
            case MINUS:
                return new Long(lhs - rhs);
            case STAR:
                return new Long(lhs * rhs);
            case SLASH:
                return new Long(lhs / rhs);
            case MOD:
                return new Long(lhs % rhs);
            // bitwise
            case LSHIFT:
            case LSHIFTX:
                return new Long(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Long(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Long(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Long(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Long(lhs | rhs);
            case XOR:
                return new Long(lhs ^ rhs);
            default:
                throw new InterpreterError(
					"Unimplemented binary long operator");
        }
    }
    // returns Object covering both Integer and Boolean return types
    public static Object intBinaryOperation(Integer I1, Integer I2, int kind)
    {
        int lhs = I1.intValue();
        int rhs = I2.intValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Integer(lhs + rhs);
            case MINUS:
                return new Integer(lhs - rhs);
            case STAR:
                return new Integer(lhs * rhs);
            case SLASH:
                return new Integer(lhs / rhs);
            case MOD:
                return new Integer(lhs % rhs);
            // bitwise
            case LSHIFT:
            case LSHIFTX:
                return new Integer(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Integer(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Integer(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Integer(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Integer(lhs | rhs);
            case XOR:
                return new Integer(lhs ^ rhs);
            default:
                throw new InterpreterError(
					"Unimplemented binary integer operator");
        }
    }
    // returns Object covering both Double and Boolean return types
    public static Object doubleBinaryOperation(Double D1, Double D2, int kind)
        throws UtilEvalError
    {
        double lhs = D1.doubleValue();
        double rhs = D2.doubleValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Double(lhs + rhs);
            case MINUS:
                return new Double(lhs - rhs);
            case STAR:
                return new Double(lhs * rhs);
            case SLASH:
                return new Double(lhs / rhs);
            case MOD:
                return new Double(lhs % rhs);
            // can't shift floating-point values
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError("Can't shift doubles");
            default:
                throw new InterpreterError(
					"Unimplemented binary double operator");
        }
    }
    // returns Object covering both Long and Boolean return types
    public static Object floatBinaryOperation(Float F1, Float F2, int kind)
        throws UtilEvalError
    {
        float lhs = F1.floatValue();
        float rhs = F2.floatValue();
        switch(kind)
        {
            // boolean
            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);
            // arithmetic
            case PLUS:
                return new Float(lhs + rhs);
            case MINUS:
                return new Float(lhs - rhs);
            case STAR:
                return new Float(lhs * rhs);
            case SLASH:
                return new Float(lhs / rhs);
            case MOD:
                return new Float(lhs % rhs);
            // can't shift floats
            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError("Can't shift floats ");
            default:
                throw new InterpreterError(
					"Unimplemented binary float operator");
        }
    }
	/**
		Promote primitive wrapper type to to Integer wrapper type
	*/
    public static Object promoteToInteger(Object wrapper )
    {
        if(wrapper instanceof Character)
            return new Integer(((Character)wrapper).charValue());
        else if((wrapper instanceof Byte) || (wrapper instanceof Short))
            return new Integer(((Number)wrapper).intValue());
        return wrapper;
    }
	/**
		Promote the pair of primitives to the maximum type of the two.
		e.g. [int,long]->[long,long]
	*/
    public static Object[] promotePrimitives(Object lhs, Object rhs)
    {
        lhs = promoteToInteger(lhs);
        rhs = promoteToInteger(rhs);
        if((lhs instanceof Number) && (rhs instanceof Number))
        {
            Number lnum = (Number)lhs;
            Number rnum = (Number)rhs;
            boolean b;
            if((b = (lnum instanceof Double)) || (rnum instanceof Double))
            {
                if(b)
                    rhs = new Double(rnum.doubleValue());
                else
                    lhs = new Double(lnum.doubleValue());
            }
            else if((b = (lnum instanceof Float)) || (rnum instanceof Float))
            {
                if(b)
                    rhs = new Float(rnum.floatValue());
                else
                    lhs = new Float(lnum.floatValue());
            }
            else if((b = (lnum instanceof Long)) || (rnum instanceof Long))
            {
                if(b)
                    rhs = new Long(rnum.longValue());
                else
                    lhs = new Long(lnum.longValue());
            }
        }
        return new Object[] { lhs, rhs };
    }
    public static Primitive unaryOperation(Primitive val, int kind)
        throws UtilEvalError
    {
        if (val == NULL)
            throw new UtilEvalError(
				"illegal use of null object or 'null' literal");
        if (val == VOID)
            throw new UtilEvalError(
				"illegal use of undefined object or 'void' literal");
        Class operandType = val.getType();
        Object operand = promoteToInteger(val.getValue());
        if ( operand instanceof Boolean )
            return new Primitive(booleanUnaryOperation((Boolean)operand, kind));
        else if(operand instanceof Integer)
        {
            int result = intUnaryOperation((Integer)operand, kind);
            // ++ and -- must be cast back the original type
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Primitive((byte)result);
                if(operandType == Short.TYPE)
                    return new Primitive((short)result);
                if(operandType == Character.TYPE)
                    return new Primitive((char)result);
            }
            return new Primitive(result);
        }
        else if(operand instanceof Long)
            return new Primitive(longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Primitive(floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Primitive(doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(
				"An error occurred.  Please call technical support.");
    }
    public static boolean booleanUnaryOperation(Boolean B, int kind)
		throws UtilEvalError
    {
        boolean operand = B.booleanValue();
        switch(kind)
        {
            case BANG:
                return !operand;
            default:
                throw new UtilEvalError("Operator inappropriate for boolean");
        }
    }
    public static int intUnaryOperation(Integer I, int kind)
    {
        int operand = I.intValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError("bad integer unaryOperation");
        }
    }
    public static long longUnaryOperation(Long L, int kind)
    {
        long operand = L.longValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError("bad long unaryOperation");
        }
    }
    public static float floatUnaryOperation(Float F, int kind)
    {
        float operand = F.floatValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError("bad float unaryOperation");
        }
    }
    public static double doubleUnaryOperation(Double D, int kind)
    {
        double operand = D.doubleValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError("bad double unaryOperation");
        }
    }
    public int intValue() throws UtilEvalError
    {
        if(value instanceof Number)
            return((Number)value).intValue();
        else
            throw new UtilEvalError("Primitive not a number");
    }
    public boolean booleanValue() throws UtilEvalError
    {
        if(value instanceof Boolean)
            return((Boolean)value).booleanValue();
        else
            throw new UtilEvalError("Primitive not a boolean");
    }
	/**
		Determine if this primitive is a numeric type.
		i.e. not boolean, null, or void (but including char)
	*/
	public boolean isNumber() {
		return ( !(value instanceof Boolean) 
			&& !(this == NULL) && !(this == VOID) );
	}
    public Number numberValue() throws UtilEvalError
    {
		Object value = this.value;
		// Promote character to Number type for these purposes
		if (value instanceof Character)
			value = new Integer(((Character)value).charValue());
        if (value instanceof Number)
            return (Number)value;
        else
            throw new UtilEvalError("Primitive not a number");
    }
	/**
		Primitives compare equal with other Primitives containing an equal
		wrapped value.
	*/
	public boolean equals( Object obj ) 
	{
		if ( obj instanceof Primitive )
			return ((Primitive)obj).value.equals( this.value );
		else
			return false;
	}
	/**
		The hash of the Primitive is tied to the hash of the wrapped value but
		shifted so that they are not the same.
	*/
	public int hashCode() 
	{
		return this.value.hashCode() * 21; // arbitrary
	}
	/**
		Unwrap primitive values and map voids to nulls.
		Non Primitive types remain unchanged.
		@param obj object type which may be bsh.Primitive
		@return corresponding "normal" Java type, "unwrapping" 
			any bsh.Primitive types to their wrapper types.
	*/
	public static Object unwrap( Object obj ) 
	{
        // map voids to nulls for the outside world
        if (obj == Primitive.VOID)
            return null;
        // unwrap primitives
        if (obj instanceof Primitive)
            return((Primitive)obj).getValue();
        else
            return obj;
	}
    /*
        Unwrap Primitive wrappers to their java.lang wrapper values.
		e.g. Primitive(42) becomes Integer(42)
		@see #unwrap( Object )
    */
    public static Object [] unwrap( Object[] args )
    {
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = unwrap( args[i] );
		return oa;
    }
    /*
    */
    public static Object [] wrap( Object[] args, Class [] paramTypes )
    {
		if ( args == null )
			return null;
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = wrap( args[i], paramTypes[i] );
		return oa;
    }
	/**
		Wrap primitive values (as indicated by type param) and nulls in the 
		Primitive class.  Values not primitive or null are left unchanged.
		Primitive values are represented by their wrapped values in param value.
		<p/>
		The value null is mapped to Primitive.NULL.
		Any value specified with type Void.TYPE is mapped to Primitive.VOID.
	*/
    public static Object wrap(
		Object value, Class type )
    {
        if ( type == Void.TYPE )
            return Primitive.VOID;
        if ( value == null )
            return Primitive.NULL;
		if ( type.isPrimitive() )
			return new Primitive( value );
		return value;
    }
	/**
		Get the appropriate default value per JLS 4.5.4
	*/
	public static Primitive getDefaultValue( Class type )
	{
		if ( type == null || !type.isPrimitive() )
			return Primitive.NULL;
		if ( type == Boolean.TYPE )
			return new Primitive( false );
		// non boolean primitive, get appropriate flavor of zero
		try {
			return new Primitive((int)0).castToType( type, Types.CAST );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError( "bad cast" );
		}
	}
	/**
		Get the corresponding java.lang wrapper class for the primitive TYPE
		class.
		e.g.  Integer.TYPE -> Integer.class
	*/
	public static Class boxType( Class primitiveType )
	{
		Class c = wrapperMap.get( primitiveType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			"Not a primitive type: "+ primitiveType );
	}
	/**
		Get the corresponding primitive TYPE class for the java.lang wrapper
		class type.
		e.g.  Integer.class -> Integer.TYPE
	*/
	public static Class unboxType( Class wrapperType )
	{
		Class c = wrapperMap.get( wrapperType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			"Not a primitive wrapper type: "+wrapperType );
	}
	/**
		Cast this bsh.Primitive value to a new bsh.Primitive value
		This is usually a numeric type cast.  Other cases include:
			A boolean can be cast to boolen
			null can be cast to any object type and remains null
			Attempting to cast a void causes an exception
		@param toType is the java object or primitive TYPE class
	*/
	public Primitive castToType( Class toType, int operation ) 
		throws UtilEvalError
	{
		return castPrimitive( 
			toType, getType()/*fromType*/, this/*fromValue*/, 
			false/*checkOnly*/, operation );
	}
	/*
		Cast or check a cast of a primitive type to another type.
		Normally both types are primitive (e.g. numeric), but a null value
		(no type) may be cast to any type.
		<p/>
		@param toType is the target type of the cast.  It is normally a
		java primitive TYPE, but in the case of a null cast can be any object
		type.
		@param fromType is the java primitive TYPE type of the primitive to be
		cast or null, to indicate that the fromValue was null or void.
		@param fromValue is, optionally, the value to be converted.  If
		checkOnly is true fromValue must be null.  If checkOnly is false,
		fromValue must be non-null (Primitive.NULL is of course valid).
	*/
	static Primitive castPrimitive( 
		Class toType, Class fromType, Primitive fromValue, 
		boolean checkOnly, int operation ) 
		throws UtilEvalError
	{
		/*
			Lots of preconditions checked here...
			Once things are running smoothly we might comment these out
			(That's what assertions are for).
		*/
		if ( checkOnly && fromValue != null )
			throw new InterpreterError("bad cast param 1");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError("bad cast param 2");
		if ( fromType != null && !fromType.isPrimitive() )
			throw new InterpreterError("bad fromType:" +fromType);
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError("inconsistent args 1");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError("inconsistent args 2");
		// can't cast void to anything
		if ( fromType == Void.TYPE )
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( Reflect.normalizeClassName(toType), 
					"void value", operation );
		// unwrap Primitive fromValue to its wrapper value, etc.
		Object value = null; 
		if ( fromValue != null )
			value = fromValue.getValue();
		if ( toType.isPrimitive() )
		{
			// Trying to cast null to primitive type?
			if ( fromType == null )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError(
						"primitive type:" + toType, "Null value", operation );
			// fall through
		} else
		{
			// Trying to cast primitive to an object type
			// Primitive.NULL can be cast to any object type
			if ( fromType == null )
				return checkOnly ? Types.VALID_CAST : 
					Primitive.NULL;
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError(
						"object type:" + toType, "primitive value", operation);
		}
		// can only cast boolean to boolean
		if ( fromType == Boolean.TYPE )
		{
			if ( toType != Boolean.TYPE )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError( toType, fromType, operation );
			return checkOnly ? Types.VALID_CAST :
				fromValue;
		}
		// Do numeric cast
		// Only allow legal Java assignment unless we're a CAST operation
		if ( operation == Types.ASSIGNMENT 
			&& !Types.isJavaAssignable( toType, fromType ) 
		) {
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( toType, fromType, operation );
		}
		return checkOnly ? Types.VALID_CAST :
			new Primitive( castWrapper(toType, value) );
	}
	public static boolean isWrapperType( Class type )
	{
		return wrapperMap.get( type ) != null && !type.isPrimitive();
	}
	/**
		Cast a primitive value represented by its java.lang wrapper type to the
		specified java.lang wrapper type.  e.g.  Byte(5) to Integer(5) or
		Integer(5) to Byte(5) 
		@param toType is the java TYPE type
		@param value is the value in java.lang wrapper.
		value may not be null.
	*/
	static Object castWrapper( 
		Class toType, Object value ) 
	{
		if ( !toType.isPrimitive() )
			throw new InterpreterError("invalid type in castWrapper: "+toType);
		if ( value == null )
			throw new InterpreterError("null value in castWrapper, guard");
		if ( value instanceof Boolean )
		{
			if ( toType != Boolean.TYPE )
				throw new InterpreterError("bad wrapper cast of boolean");
			else
				return value;
		}
		// first promote char to Number type to avoid duplicating code
		if ( value instanceof Character )
			value = new Integer(((Character)value).charValue());
		if ( !(value instanceof Number) )
			throw new InterpreterError("bad type in cast");
		Number number = (Number)value;
		if (toType == Byte.TYPE)
			return new Byte(number.byteValue());
		if (toType == Short.TYPE)
			return new Short(number.shortValue());
		if (toType == Character.TYPE)
			return new Character((char)number.intValue());
		if (toType == Integer.TYPE)
			return new Integer(number.intValue());
		if (toType == Long.TYPE)
			return new Long(number.longValue());
		if (toType == Float.TYPE)
			return new Float(number.floatValue());
		if (toType == Double.TYPE)
			return new Double(number.doubleValue());
		throw new InterpreterError("error in wrapper cast");
	}
}
package bsh;
import bsh.ast.SimpleNode;
/**
	EvalError indicates that we cannot continue evaluating the script
	or the script has thrown an exception.
	EvalError may be thrown for a script syntax error, an evaluation 
	error such as referring to an undefined variable, an internal error.
	<p>
	
	@see TargetError
*/
public class EvalError extends Error
{
	private SimpleNode node;
	// Note: no way to mutate the Throwable message, must maintain our own
	private String message;
	private final CallStack callstack;
	public EvalError( String s, SimpleNode node, CallStack callstack, Throwable cause ) {
		this(s,node,callstack);
		initCause(cause);
	}
	public EvalError( String s, SimpleNode node, CallStack callstack ) {
		this.message = s;
		this.node = node;
		// freeze the callstack for the stack trace.
		this.callstack = callstack==null ? null : callstack.copy();
	}
	/**
		Print the error with line number and stack trace.
	*/
	public String getMessage() 
	{
		String trace;
		if ( node != null )
			trace = " : at Line: "+ node.getLineNumber() 
				+ " : in file: "+ node.getSourceFile()
				+ " : "+node.getText();
		else
			// Users should not normally see this.
			trace = ": <at unknown location>";
		if ( callstack != null )
			trace = trace +"\n" + getScriptStackTrace();
		return getRawMessage() + trace;
	}
	/**
		Re-throw the error, prepending the specified message.
	*/
	public void reThrow( String msg ) 
		throws EvalError 
	{
		prependMessage( msg );
		throw this;
	}
	/**
		The error has trace info associated with it. 
		i.e. It has an AST node that can print its location and source text.
	*/
	SimpleNode getNode() {
		return node;
	}
	void setNode( SimpleNode node ) {
		this.node = node;
	}
	public String getErrorText() { 
		if ( node != null )
			return node.getText() ;
		else
			return "<unknown error>";
	}
	public int getErrorLineNumber() { 
		if ( node != null )
			return node.getLineNumber() ;
		else
			return -1;
	}
	public String getErrorSourceFile() {
		if ( node != null )
			return node.getSourceFile() ;
		else
			return "<unknown file>";
	}
	public String getScriptStackTrace() 
	{
		if ( callstack == null )
			return "<Unknown>";
		String trace = "";
		CallStack stack = callstack.copy();
		while ( stack.depth() > 0 ) 
		{
			NameSpace ns = stack.pop();
			SimpleNode node = ns.getNode();
			if ( ns.isMethod )
			{
				trace = trace + "\nCalled from method: " + ns.getName();
				if ( node != null )
					trace += " : at Line: "+ node.getLineNumber() 
						+ " : in file: "+ node.getSourceFile()
						+ " : "+node.getText();
			}
		}
		return trace;
	}
	public String getRawMessage() { return message; }
	/**
		Prepend the message if it is non-null.
	*/
	private void prependMessage( String s ) 
	{ 
		if ( s == null )
			return;
		if ( message == null )
			message = s;
		else
			message = s + " : "+ message;
	}
}
package bsh;
import java.io.Serializable;
import java.util.Stack;
import java.util.EmptyStackException;
/**
	A stack of NameSpaces representing the call path.
	Each method invocation, for example, pushes a new NameSpace onto the stack.
	The top of the stack is always the current namespace of evaluation.
	<p>
	This is used to support the this.caller magic reference and to print
	script "stack traces" when evaluation errors occur.
	<p>
	Note: How can this be thread safe, you might ask?  Wouldn't a thread 
	executing various beanshell methods be mutating the callstack?  Don't we 
	need one CallStack per Thread in the interpreter?  The answer is that we do.
	Any java.lang.Thread enters our script via an external (hard) Java 
	reference via a This type interface, e.g.  the Runnable interface 
	implemented by This or an arbitrary interface implemented by XThis.  
	In that case the This invokeMethod() method (called by any interface that 
	it exposes) creates a new CallStack for each external call.
	<p>
*/
public final class CallStack implements Serializable {
	private static final long serialVersionUID = 0L;
	private final Stack<NameSpace> stack = new Stack<NameSpace>();
	public CallStack() { }
	public CallStack( NameSpace namespace ) { 
		push( namespace );
	}
	public void clear() {
		stack.removeAllElements();
	}
	public void push( NameSpace ns ) {
		stack.push( ns );
	}
	public NameSpace top() {
		return stack.peek();
	}
	/**
		zero based.
	*/
	public NameSpace get(int depth) {
		int size = stack.size();
		if ( depth >= size )
			return NameSpace.JAVACODE;
		else
			return stack.get(size-1-depth);
	}
	
	/**
		This is kind of crazy, but used by the setNameSpace command.
		zero based.
	*/
	public void set(int depth, NameSpace ns) {
		stack.set( stack.size()-1-depth, ns );
	}
	public NameSpace pop() {
		try {
			return stack.pop();
		} catch(EmptyStackException e) {
			throw new InterpreterError("pop on empty CallStack");
		}
	}
	/**
		Swap in the value as the new top of the stack and return the old
		value.
	*/
	public NameSpace swap( NameSpace newTop ) {
		int last = stack.size() - 1;
		NameSpace oldTop = stack.get(last);
		stack.set( last, newTop );
		return oldTop;
	}
	public int depth() {
		return stack.size();
	}
/*
	public NameSpace [] toArray() {
		NameSpace [] nsa = new NameSpace [ depth() ];
		stack.copyInto( nsa );
		return nsa;
	}
*/
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("CallStack:\n");
		for( int i=stack.size()-1; i>=0; i-- )
			sb.append("\t"+stack.get(i)+"\n");
		return sb.toString();
	}
	/**
		Occasionally we need to freeze the callstack for error reporting
		purposes, etc.
	*/
	public CallStack copy() {
		CallStack cs = new CallStack();
		cs.stack.addAll(this.stack);
		return cs;
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
/**
	The BeanShell script interpreter.
	An instance of Interpreter can be used to source scripts and evaluate 
	statements or expressions.  
	<p>
	Here are some examples:
	<p><blockquote><pre>
		Interpeter bsh = new Interpreter();
		// Evaluate statements and expressions
		bsh.eval("foo=Math.sin(0.5)");
		bsh.eval("bar=foo*5; bar=Math.cos(bar);");
		bsh.eval("for(i=0; i<10; i++) { print(\"hello\"); }");
		// same as above using java syntax and apis only
		bsh.eval("for(int i=0; i<10; i++) { System.out.println(\"hello\"); }");
		// Source from files or streams
		bsh.source("myscript.bsh");  // or bsh.eval("source(\"myscript.bsh\")");
		// Use set() and get() to pass objects in and out of variables
		bsh.set( "date", new Date() );
		Date date = (Date)bsh.get( "date" );
		// This would also work:
		Date date = (Date)bsh.eval( "date" );
		bsh.eval("year = date.getYear()");
		Integer year = (Integer)bsh.get("year");  // primitives use wrappers
		// With Java1.3+ scripts can implement arbitrary interfaces...
		// Script an awt event handler (or source it from a file, more likely)
		bsh.eval( "actionPerformed( e ) { print( e ); }");
		// Get a reference to the script object (implementing the interface)
		ActionListener scriptedHandler = 
			(ActionListener)bsh.eval("return (ActionListener)this");
		// Use the scripted event handler normally...
		new JButton.addActionListener( script );
	</pre></blockquote>
	<p>
	In the above examples we showed a single interpreter instance, however 
	you may wish to use many instances, depending on the application and how
	you structure your scripts.  Interpreter instances are very light weight
	to create, however if you are going to execute the same script repeatedly
	and require maximum performance you should consider scripting the code as 
	a method and invoking the scripted method each time on the same interpreter
	instance (using eval()). 
	<p>
	See the BeanShell User's Manual for more information.
*/
public class Interpreter 
	implements Runnable, ConsoleInterface,Serializable
{
	/* --- Begin static members --- */
	public static final String VERSION = "2.2b0";
	/*
		Debug utils are static so that they are reachable by code that doesn't
		necessarily have an interpreter reference (e.g. tracing in utils).
		In the future we may want to allow debug/trace to be turned on on
		a per interpreter basis, in which case we'll need to use the parent 
		reference in some way to determine the scope of the command that 
		turns it on or off.
	*/
	public static boolean DEBUG, TRACE, LOCALSCOPING;
	// This should be per instance
	transient static PrintStream debug;
	static String systemLineSeparator = "\n"; // default
	private static final This SYSTEM_OBJECT = This.getThis(new NameSpace(null, null, "bsh.system"), null);
	static {
		staticInit();
	}
	/** 
		Strict Java mode 
		@see #setStrictJava( boolean )
	*/
	private boolean strictJava = false;
	/* --- End static members --- */
	/* --- Instance data --- */
	transient Parser parser;
	NameSpace globalNameSpace;
	transient Reader in;
	transient PrintStream out;
	transient PrintStream err;
	ConsoleInterface console; 
	/** If this interpeter is a child of another, the parent */
	Interpreter parent;
	/** The name of the file or other source that this interpreter is reading */
	String sourceFileInfo;
	/** by default in interactive mode System.exit() on EOF */
	private boolean exitOnEOF = true;
	protected boolean 
		evalOnly, 		// Interpreter has no input stream, use eval() only
		interactive;	// Interpreter has a user, print prompts, etc.
	/** Control the verbose printing of results for the show() command. */
	private boolean showResults;
	/* --- End instance data --- */
	/**
		The main constructor.
		All constructors should now pass through here.
		@param namespace If namespace is non-null then this interpreter's 
		root namespace will be set to the one provided.  If it is null a new 
		one will be created for it.
		@param parent The parent interpreter if this interpreter is a child 
			of another.  May be null.  Children share a BshClassManager with
			their parent instance.
		@param sourceFileInfo An informative string holding the filename 
		or other description of the source from which this interpreter is
		reading... used for debugging.  May be null.
	*/
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace,
		Interpreter parent, String sourceFileInfo )
	{
		//System.out.println("New Interpreter: "+this +", sourcefile = "+sourceFileInfo );
		parser = new Parser( in );
		long t1 = 0;
		if (Interpreter.DEBUG) {
			t1=System.currentTimeMillis();
		}
		this.in = in;
		this.out = out;
		this.err = err;
		this.interactive = interactive;
		debug = err;
		this.parent = parent;
		if ( parent != null )
			setStrictJava( parent.getStrictJava() );
		this.sourceFileInfo = sourceFileInfo;
		BshClassManager bcm = BshClassManager.createClassManager( this );
		if ( namespace == null ) {
			globalNameSpace = new NameSpace( bcm, "global");
			initRootSystemObject();
		} else {
			globalNameSpace = namespace;
			try {
				if ( ! (globalNameSpace.getVariable("bsh") instanceof This)) {
					initRootSystemObject();
				}
			} catch (final UtilEvalError e) {
				throw new IllegalStateException(e);
			}
		}
		// now done in NameSpace automatically when root
		// The classes which are imported by default
		//globalNameSpace.loadDefaultImports();
		if ( interactive ) {
			loadRCFiles();
		}
		if ( Interpreter.DEBUG ) {
			long t2=System.currentTimeMillis();
			Interpreter.debug("Time to initialize interpreter: "+(t2-t1));
		}
	}
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace)
	{
		this( in, out, err, interactive, namespace, null, null );
	}
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, boolean interactive)
	{
		this(in, out, err, interactive, null);
	}
	/**
		Construct a new interactive interpreter attached to the specified 
		console using the specified parent namespace.
	*/
	public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {
		this( console.getIn(), console.getOut(), console.getErr(), 
			true, globalNameSpace );
		setConsole( console );
	}
	/**
		Construct a new interactive interpreter attached to the specified 
		console.
	*/
	public Interpreter(ConsoleInterface console) {
		this(console, null);
	}
	/**
		Create an interpreter for evaluation only.
	*/
	public Interpreter()
	{
		this( new StringReader(""), 
			System.out, System.err, false, null );
		evalOnly = true;
		setu( "bsh.evalOnly", new Primitive(true) );
	}
	// End constructors
	/**
		Attach a console
		Note: this method is incomplete.
	*/
	public void setConsole( ConsoleInterface console ) {
		this.console = console;
		setu( "bsh.console", console );
		// redundant with constructor
		setOut( console.getOut() );
		setErr( console.getErr() );
		// need to set the input stream - reinit the parser?
	}
	private void initRootSystemObject() 
	{
		BshClassManager bcm = getClassManager();
		// bsh
		setu("bsh", new NameSpace( bcm, "Bsh Object" ).getThis( this ) );
		setu( "bsh.system", SYSTEM_OBJECT);
		setu( "bsh.shared", SYSTEM_OBJECT); // alias
		// bsh.help
		This helpText = new NameSpace(bcm, "Bsh Command Help Text" ).getThis( this );
		setu( "bsh.help", helpText );
		// bsh.cwd
		try {
			setu( "bsh.cwd", System.getProperty("user.dir") );
		} catch ( SecurityException e ) { 
			// applets can't see sys props
			setu( "bsh.cwd", "." );
		}
		// bsh.interactive
		setu( "bsh.interactive", new Primitive(interactive) );
		// bsh.evalOnly
		setu( "bsh.evalOnly", new Primitive(evalOnly) );
	}
	/**
		Set the global namespace for this interpreter.
		<p>
		Note: This is here for completeness.  If you're using this a lot 
		it may be an indication that you are doing more work than you have 
		to.  For example, caching the interpreter instance rather than the 
		namespace should not add a significant overhead.  No state other 
		than the debug status is stored in the interpreter.
		<p>
		All features of the namespace can also be accessed using the 
		interpreter via eval() and the script variable 'this.namespace'
		(or global.namespace as necessary).
	*/
	public void setNameSpace( NameSpace globalNameSpace ) {
		this.globalNameSpace = globalNameSpace;
	}
	/**
		Get the global namespace of this interpreter.
		<p>
		Note: This is here for completeness.  If you're using this a lot 
		it may be an indication that you are doing more work than you have 
		to.  For example, caching the interpreter instance rather than the 
		namespace should not add a significant overhead.  No state other than 
		the debug status is stored in the interpreter.  
		<p>
		All features of the namespace can also be accessed using the 
		interpreter via eval() and the script variable 'this.namespace'
		(or global.namespace as necessary).
	*/
	public NameSpace getNameSpace() {
		return globalNameSpace;
	}
	/**
		Run the text only interpreter on the command line or specify a file.
	*/
	public static void main( String [] args ) 
	{
		if ( args.length > 0 ) {
			String filename = args[0];
			String [] bshArgs;
			if ( args.length > 1 ) {
				bshArgs = new String [ args.length -1 ];
				System.arraycopy( args, 1, bshArgs, 0, args.length-1 );
			} else
				bshArgs = new String [0];
			Interpreter interpreter = new Interpreter();
			//System.out.println("run i = "+interpreter);
			interpreter.setu( "bsh.args", bshArgs );
			try {
				Object result = 
					interpreter.source( filename, interpreter.globalNameSpace );
				if ( result instanceof Class )
					try {
						invokeMain( (Class)result, bshArgs );
					} catch ( Exception e ) 
					{
						Object o = e;
						if ( e instanceof InvocationTargetException )
							o = ((InvocationTargetException)e)
								.getTargetException();
						System.err.println(
							"Class: "+result+" main method threw exception:"+o);
					}
			} catch ( FileNotFoundException e ) {
				System.err.println("File not found: "+e);
			} catch ( TargetError e ) {
				System.err.println("Script threw exception: "+e);
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, System.err );
			} catch ( EvalError e ) {
				System.err.println("Evaluation Error: "+e);
			} catch ( IOException e ) {
				System.err.println("I/O Error: "+e);
			}
		} else 
		{
			// Workaround for JDK bug 4071281, where system.in.available() 
			// returns too large a value. This bug has been fixed in JDK 1.2.
			InputStream src;
			if ( System.getProperty("os.name").startsWith("Windows") 
				&& System.getProperty("java.version").startsWith("1.1."))
			{
				src = new FilterInputStream(System.in) {
					public int available() throws IOException {
						return 0;
					}
				};
			}
			else
				src = System.in;
			Reader in = new CommandLineReader( new InputStreamReader(src));
			Interpreter interpreter = 
				new Interpreter( in, System.out, System.err, true );
			interpreter.run();
		}
	}
	public static void invokeMain( Class clas, String [] args ) 
		throws Exception
	{
		Method main = Reflect.resolveJavaMethod(
			null/*BshClassManager*/, clas, "main", 
			new Class [] { String [].class }, true/*onlyStatic*/ );
		if ( main != null )
			main.invoke( null, new Object [] { args } );
	}
	/**
		Run interactively.  (printing prompts, etc.)
	*/
	public void run() 
	{
		if(evalOnly)
			throw new RuntimeException("bsh Interpreter: No stream");
		/*
		  We'll print our banner using eval(String) in order to
		  exercise the parser and get the basic expression classes loaded...
		  This ameliorates the delay after typing the first statement.
		*/
		if ( interactive )
			try { 
				eval("printBanner();"); 
			} catch ( EvalError e ) {
				println(
					"BeanShell2 " + VERSION + " - http://code.google.com/p/beanshell2");
			}
		// init the callstack.  
		CallStack callstack = new CallStack( globalNameSpace );
        BshEvaluatingVisitor evaluator = new BshEvaluatingVisitor(callstack, this);
		SimpleNode node = null;
		boolean eof = false;
		while( !eof )
		{
			try
			{
				// try to sync up the console
				System.out.flush();
				System.err.flush();
				Thread.yield();  // this helps a little
				if ( interactive )
					print( getBshPrompt() );
				eof = Line();
				if( get_jjtree().nodeArity() > 0 )  // number of child nodes 
				{
					if( node != null )
						node.lastToken.next = null;  // prevent OutOfMemoryError
					node = (SimpleNode)(get_jjtree().rootNode());
					if(DEBUG)
						node.dump(">");
                    Object ret = node.accept(evaluator);
					node.lastToken.next = null;  // prevent OutOfMemoryError
				
					// sanity check during development
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							"Callstack growing: "+callstack);
					if(ret instanceof ReturnControl)
						ret = ((ReturnControl)ret).value;
					if( ret != Primitive.VOID )
					{
						setu("$_", ret);
						if ( showResults )
							println("<" + ret + ">");
					}
				}
			}
			catch(ParseException e)
			{
				error("Parser Error: " + e.getMessage());
				if ( DEBUG )
					e.printStackTrace();
				if(!interactive)
					eof = true;
				parser.reInitInput(in);
			}
			catch(InterpreterError e)
			{
				error("Internal Error: " + e.getMessage());
				e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(TargetError e)
			{
				error("// Uncaught Exception: " + e );
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, err );
				if(!interactive)
					eof = true;
				setu("$_e", e.getTarget());
			}
			catch (EvalError e)
			{
				if ( interactive )
					error( "EvalError: "+e.getMessage() );
				else
					error( "EvalError: "+e.getRawMessage() );
				if(DEBUG)
					e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(Exception e)
			{
				error("Unknown error: " + e);
				if ( DEBUG )
					e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(TokenMgrError e)
			{
				error("Error parsing input: " + e);
				/*
					We get stuck in infinite loops here when unicode escapes
					fail.  Must re-init the char stream reader 
					(ASCII_UCodeESC_CharStream.java)
				*/
				parser.reInitTokenInput( in );
				if(!interactive)
					eof = true;
			}
			finally
			{
				get_jjtree().reset();
				// reinit the callstack
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( globalNameSpace );
				}
			}
		}
		if ( interactive && exitOnEOF )
			System.exit(0);
	}
	// begin source and eval
	/**
		Read text from fileName and eval it.
	*/
	public Object source( String filename, NameSpace nameSpace ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		File file = pathToFile( filename );
		if ( Interpreter.DEBUG ) debug("Sourcing file: "+file);
		Reader sourceIn = new BufferedReader( new FileReader(file) );
		try {
			return eval( sourceIn, nameSpace, filename );
		} finally {
			sourceIn.close();
		}
	}
	/**
		Read text from fileName and eval it.
		Convenience method.  Use the global namespace.
	*/
	public Object source( String filename ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		return source( filename, globalNameSpace );
	}
	/**
		Spawn a non-interactive local interpreter to evaluate text in the 
		specified namespace.  
		Return value is the evaluated object (or corresponding primitive 
		wrapper).
		@param sourceFileInfo is for information purposes only.  It is used to
		display error messages (and in the future may be made available to
		the script).
		@throws EvalError on script problems
		@throws TargetError on unhandled exceptions from the script
	*/
	/*
		Note: we need a form of eval that passes the callstack through...
	*/
	/*
	Can't this be combined with run() ?
	run seems to have stuff in it for interactive vs. non-interactive...
	compare them side by side and see what they do differently, aside from the
	exception handling.
	*/
	public Object eval( 
		Reader in, NameSpace nameSpace, String sourceFileInfo
			/*, CallStack callstack */ ) 
		throws EvalError 
	{
		Object retVal = null;
		if ( Interpreter.DEBUG ) debug("eval: nameSpace = "+nameSpace);
		/* 
			Create non-interactive local interpreter for this namespace
			with source from the input stream and out/err same as 
			this interpreter.
		*/
		Interpreter localInterpreter = 
			new Interpreter( 
				in, out, err, false, nameSpace, this, sourceFileInfo  );
		CallStack callstack = new CallStack( nameSpace );
        BshEvaluatingVisitor evaluator = new BshEvaluatingVisitor(callstack, localInterpreter);
        SimpleNode node = null;
		boolean eof = false;
		while(!eof)
		{
			try
			{
				eof = localInterpreter.Line();
				if (localInterpreter.get_jjtree().nodeArity() > 0)
				{
					if( node != null )
						node.lastToken.next = null;  // prevent OutOfMemoryError
					node = (SimpleNode)localInterpreter.get_jjtree().rootNode();
					// nodes remember from where they were sourced
					node.setSourceFile( sourceFileInfo );
					if ( TRACE )
						println( "// " +node.getText() );
                    retVal = node.accept(evaluator);
					// sanity check during development
					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							"Callstack growing: "+callstack);
					if ( retVal instanceof ReturnControl ) {
						retVal = ((ReturnControl)retVal).value;
						break; // non-interactive, return control now
					}
					if ( localInterpreter.showResults 
						&& retVal != Primitive.VOID )
						println("<" + retVal + ">");
				}
			} catch(ParseException e) {
				/*
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" parser Error: " 
					+ e.getMessage( DEBUG ), node, callstack );
				*/
				if ( DEBUG )
					// show extra "expecting..." info
					error( e.getMessage() );
				// add the source file info and throw again
				//e.setErrorSourceFile( sourceFileInfo );
				throw new EvalError("Error:", node, callstack, e);
			} catch ( InterpreterError e ) {
				e.printStackTrace();
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" internal Error: " 
					+ e.getMessage(), node, callstack);
			} catch ( TargetError e ) {
				// failsafe, set the Line as the origin of the error.
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow("Sourced file: "+sourceFileInfo);
			} catch ( EvalError e) {
				if ( DEBUG)
					e.printStackTrace();
				// failsafe, set the Line as the origin of the error.
				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow( "Sourced file: "+sourceFileInfo );
			} catch ( Exception e) {
				if ( DEBUG)
					e.printStackTrace();
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" unknown error: " 
					+ e.getMessage(), node, callstack, e);
			} catch(TokenMgrError e) {
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" Token Parsing Error: " 
					+ e.getMessage(), node, callstack, e );
			} finally {
				localInterpreter.get_jjtree().reset();
				// reinit the callstack
				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( nameSpace );
				}
			}
		}
		return Primitive.unwrap( retVal );
	}
	/**
		Evaluate the inputstream in this interpreter's global namespace.
	*/
	public Object eval( Reader in ) throws EvalError 
	{
		return eval( in, globalNameSpace, "eval stream" );
	}
	/**
		Evaluate the string in this interpreter's global namespace.
	*/
	public Object eval( String statements ) throws EvalError {
		if ( Interpreter.DEBUG ) debug("eval(String): "+statements);
		return eval(statements, globalNameSpace);
	}
	/**
		Evaluate the string in the specified namespace.
	*/
	public Object eval( String statements, NameSpace nameSpace ) 
		throws EvalError 
	{
		String s = ( statements.endsWith(";") ? statements : statements+";" );
		return eval( 
			new StringReader(s), nameSpace, 
			"inline evaluation of: ``"+ showEvalString(s)+"''" );
	}
	private String showEvalString( String s ) {
		s = s.replace('\n', ' ');
		s = s.replace('\r', ' ');
		if ( s.length() > 80 )
			s = s.substring( 0, 80 ) + " . . . ";
		return s;
	}
	// end source and eval
	/**
		Print an error message in a standard format on the output stream
		associated with this interpreter. On the GUI console this will appear 
		in red, etc.
	*/
	public final void error( Object o ) {
		if ( console != null )
				console.error( "// Error: " + o +"\n" );
		else {
			err.println("// Error: " + o );
			err.flush();
		}
	}
	// ConsoleInterface
	// The interpreter reflexively implements the console interface that it 
	// uses.  Should clean this up by using an inner class to implement the
	// console for us.
	/** 
		Get the input stream associated with this interpreter.
		This may be be stdin or the GUI console.
	*/
	public Reader getIn() { return in; }
	/** 
		Get the outptut stream associated with this interpreter.
		This may be be stdout or the GUI console.
	*/
	public PrintStream getOut() { return out; }
	/** 
		Get the error output stream associated with this interpreter.
		This may be be stderr or the GUI console.
	*/
	public PrintStream getErr() { return err; }
	public final void println( Object o )
	{
		print( String.valueOf(o) + systemLineSeparator );
	}
	public final void print( Object o )
	{
		if (console != null) {
			console.print(o);
		} else {
			out.print(o);
			out.flush();
		}
	}
	// End ConsoleInterface
	/**
		Print a debug message on debug stream associated with this interpreter
		only if debugging is turned on.
	*/
	public final static void debug(String s)
	{
		if ( DEBUG )
			debug.println("// Debug: " + s);
	}
	/* 
		Primary interpreter set and get variable methods
		Note: These are squeltching errors... should they?
	*/
	/**
		Get the value of the name.
		name may be any value. e.g. a variable or field
	*/
	public Object get( String name ) throws EvalError {
		try {
			Object ret = globalNameSpace.get( name, this );
			return Primitive.unwrap( ret );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() ); 
		}
	}
	/**
		Unchecked get for internal use
	*/
	Object getu( String name ) {
		try { 
			return get( name );
		} catch ( EvalError e ) { 
			throw new InterpreterError("set: "+e);
		}
	}
	/**
		Assign the value to the name.	
		name may evaluate to anything assignable. e.g. a variable or field.
	*/
	public void set( String name, Object value )
		throws EvalError 
	{
		// map null to Primtive.NULL coming in...
		if ( value == null )
			value = Primitive.NULL;
		CallStack callstack = new CallStack();
		try {
			if ( Name.isCompound( name ) ) 
			{
				LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( new BshEvaluatingVisitor(callstack,  this)	);
				lhs.assign( value, false );
			} else // optimization for common case
				globalNameSpace.setVariable( name, value, false );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
		}
	}
	/**
		Unchecked set for internal use
	*/
	void setu(String name, Object value) {
		try { 
			set(name, value);
		} catch ( EvalError e ) { 
			throw new InterpreterError("set: "+e);
		}
	}
	public void set(String name, long value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, int value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, double value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, float value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, boolean value) throws EvalError {
		set(name, new Primitive(value));
	}
	/**
		Unassign the variable name.	
		Name should evaluate to a variable.
	*/
	public void unset( String name ) 
		throws EvalError 
	{
		/*
			We jump through some hoops here to handle arbitrary cases like
			unset("bsh.foo");
		*/
		CallStack callstack = new CallStack();
		try {
			LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( 
				new BshEvaluatingVisitor(callstack, this) );
			if ( lhs.type != LHS.VARIABLE )
				throw new EvalError("Can't unset, not a variable: "+name, 
					SimpleNode.JAVACODE, new CallStack() );
			//lhs.assign( null, false );
			lhs.nameSpace.unsetVariable( name );
		} catch ( UtilEvalError e ) {
			throw new EvalError( e.getMessage(), 
				SimpleNode.JAVACODE, new CallStack() );
		}
	}
	// end primary set and get methods
	/**
		Get a reference to the interpreter (global namespace), cast 
		to the specified interface type.  Assuming the appropriate 
		methods of the interface are defined in the interpreter, then you may 
		use this interface from Java, just like any other Java object.
		<p>
		For example:
		<pre>
			Interpreter interpreter = new Interpreter();
			// define a method called run()
			interpreter.eval("run() { ... }");
		
			// Fetch a reference to the interpreter as a Runnable
			Runnable runnable = 
				(Runnable)interpreter.getInterface( Runnable.class );
		</pre>
		<p>
		Note that the interpreter does *not* require that any or all of the
		methods of the interface be defined at the time the interface is
		generated.  However if you attempt to invoke one that is not defined
		you will get a runtime exception.
		<p>
		Note also that this convenience method has exactly the same effect as 
		evaluating the script:
		<pre>
			(Type)this;
		</pre>
		<p>
		For example, the following is identical to the previous example:
		<p>
		<pre>
			// Fetch a reference to the interpreter as a Runnable
			Runnable runnable = 
				(Runnable)interpreter.eval( "(Runnable)this" );
		</pre>
		<p>
		<em>Version requirement</em> Although standard Java interface types 
		are always available, to be used with arbitrary interfaces this 
		feature requires that you are using Java 1.3 or greater.
		<p>
		@throws EvalError if the interface cannot be generated because the
		version of Java does not support the proxy mechanism. 
	*/
	public Object getInterface( Class interf ) throws EvalError
	{
		return globalNameSpace.getThis( this ).getInterface( interf );
	}
	/*	Methods for interacting with Parser */
	private JJTParserState get_jjtree() {
		return parser.jjtree;
	}
	private JavaCharStream get_jj_input_stream() {
		return parser.jj_input_stream;
	}
	private boolean Line() throws ParseException {
		return parser.Line();
	}
	/*	End methods for interacting with Parser */
	void loadRCFiles() {
		try {
			String rcfile = 
				// Default is c:\windows under win98, $HOME under Unix
				System.getProperty("user.home") + File.separator + ".bshrc";
			source( rcfile, globalNameSpace );
		} catch ( Exception e ) { 
			// squeltch security exception, filenotfoundexception
			if ( Interpreter.DEBUG ) debug("Could not find rc file: "+e);
		}
	}
	/**
		Localize a path to the file name based on the bsh.cwd interpreter 
		working directory.
	*/
	public File pathToFile( String fileName ) 
		throws IOException
	{
		File file = new File( fileName );
		// if relative, fix up to bsh.cwd
		if ( !file.isAbsolute() ) {
			String cwd = (String)getu("bsh.cwd");
			file = new File( cwd + File.separator + fileName );
		}
		// The canonical file name is also absolute.
		// No need for getAbsolutePath() here...
		return new File( file.getCanonicalPath() );
	}
	public static void redirectOutputToFile( String filename ) 
	{
		try {
			PrintStream pout = new PrintStream( 
				new FileOutputStream( filename ) );
			System.setOut( pout );
			System.setErr( pout );
		} catch ( IOException e ) {
			System.err.println("Can't redirect output to file: "+filename );
		}
	}
	/**
		Set an external class loader to be used as the base classloader
		for BeanShell.  The base classloader is used for all classloading 
		unless/until the addClasspath()/setClasspath()/reloadClasses()  
		commands are called to modify the interpreter's classpath.  At that 
		time the new paths /updated paths are added on top of the base 
		classloader.
		<p>
		BeanShell will use this at the same point it would otherwise use the 
		plain Class.forName().
		i.e. if no explicit classpath management is done from the script
		(addClassPath(), setClassPath(), reloadClasses()) then BeanShell will
		only use the supplied classloader.  If additional classpath management
		is done then BeanShell will perform that in addition to the supplied
		external classloader.  
		However BeanShell is not currently able to reload
		classes supplied through the external classloader.
		<p>
		@see BshClassManager#setClassLoader( ClassLoader )
	*/
	public void setClassLoader( ClassLoader externalCL ) {
		getClassManager().setClassLoader( externalCL );
	}
	/**
		Get the class manager associated with this interpreter
		(the BshClassManager of this interpreter's global namespace).
		This is primarily a convenience method.
	*/
	public BshClassManager getClassManager() 
	{
		return getNameSpace().getClassManager();
	}
	
	/**
		Set strict Java mode on or off.  
		This mode attempts to make BeanShell syntax behave as Java
		syntax, eliminating conveniences like loose variables, etc.
		When enabled, variables are required to be declared or initialized 
		before use and method arguments are reqired to have types. 
		<p>
		This mode will become more strict in a future release when 
		classes are interpreted and there is an alternative to scripting
		objects as method closures.
	*/
	public void setStrictJava( boolean b ) { 
		this.strictJava = b; 
	}
	/**
		@see #setStrictJava( boolean )
	*/
	public boolean getStrictJava() { 
		return this.strictJava;
	}
	static void staticInit() 
	{
	/* 
		Apparently in some environments you can't catch the security exception
		at all...  e.g. as an applet in IE  ... will probably have to work 
		around 
	*/
		try {
			systemLineSeparator = System.getProperty("line.separator");
			debug = System.err;
			DEBUG = Boolean.getBoolean("debug");
			TRACE = Boolean.getBoolean("trace");
			LOCALSCOPING = Boolean.getBoolean("localscoping");
			String outfilename = System.getProperty("outfile");
			if ( outfilename != null )
				redirectOutputToFile( outfilename );
		} catch ( SecurityException e ) { 
			System.err.println("Could not init static:"+e);
		} catch ( Exception e ) {
			System.err.println("Could not init static(2):"+e);
		} catch ( Throwable e ) { 
			System.err.println("Could not init static(3):"+e);
		}
	}
	/**
		Specify the source of the text from which this interpreter is reading.
		Note: there is a difference between what file the interrpeter is 
		sourcing and from what file a method was originally parsed.  One
		file may call a method sourced from another file.  See SimpleNode
		for origination file info.
		@see bsh.ast.SimpleNode#getSourceFile()
	*/
	public String getSourceFileInfo() { 
		if ( sourceFileInfo != null )
			return sourceFileInfo;
		else
			return "<unknown source>";
	}
	/**
		Get the parent Interpreter of this interpreter, if any.
		Currently this relationship implies the following:
			1) Parent and child share a BshClassManager
			2) Children indicate the parent's source file information in error
			reporting.
		When created as part of a source() / eval() the child also shares
		the parent's namespace.  But that is not necessary in general.
	*/
	public Interpreter getParent() {
		return parent;
	}
	public void setOut( PrintStream out ) {
		this.out = out;
	}
	public void setErr( PrintStream err ) {
		this.err = err;
	}
	/**
		De-serialization setup.
		Default out and err streams to stdout, stderr if they are null.
	*/
	private void readObject(ObjectInputStream stream) 
		throws java.io.IOException, ClassNotFoundException
	{
		stream.defaultReadObject();
		// set transient fields
		if ( console != null ) {
			setOut( console.getOut() );
			setErr( console.getErr() );
		} else {
			setOut( System.out );
			setErr( System.err );
		}
	}
	/**
		Get the prompt string defined by the getBshPrompt() method in the
		global namespace.  This may be from the getBshPrompt() command or may
		be defined by the user as with any other method.
		Defaults to "bsh % " if the method is not defined or there is an error.
	*/
	private String getBshPrompt() 
	{
		try {
			return (String)eval("getBshPrompt()");
		} catch ( Exception e ) {
			return "bsh % ";
		}
	}
	/**
		Specify whether, in interactive mode, the interpreter exits Java upon
		end of input.  If true, when in interactive mode the interpreter will
		issue a System.exit(0) upon eof.  If false the interpreter no
		System.exit() will be done.
		<p/>
		Note: if you wish to cause an EOF externally you can try closing the
		input stream.  This is not guaranteed to work in older versions of Java
		due to Java limitations, but should work in newer JDK/JREs.  (That was
		the motivation for the Java NIO package).
	*/
	public void setExitOnEOF( boolean value ) {
		exitOnEOF = value; // ug
	}
	/**
		Turn on/off the verbose printing of results as for the show()
		 command.
		If this interpreter has a parent the call is delegated.
		See the BeanShell show() command.
	*/
	public void setShowResults( boolean showResults ) {
		this.showResults = showResults;
	}
	/**
	 Show on/off verbose printing status for the show() command.
	 See the BeanShell show() command.
	 If this interpreter has a parent the call is delegated.
	 */
	public boolean getShowResults()  {
		return showResults;
	}
	public static void setShutdownOnExit(final boolean value) {
		try {
			SYSTEM_OBJECT.getNameSpace().setVariable("shutdownOnExit", Boolean.valueOf(value), false);
		} catch (final UtilEvalError utilEvalError) {
			throw new IllegalStateException(utilEvalError);
		}
	}
}
package bsh.ast;
import bsh.*;
public class BSHUnaryExpression extends SimpleNode implements ParserConstants
{
    public int kind;
	public boolean postfix = false;
    public BSHUnaryExpression(int id) { super(id); }
    public Object lhsUnaryOperation( LHS lhs, boolean strictJava )
		throws UtilEvalError
    {
        if ( Interpreter.DEBUG ) Interpreter.debug("lhsUnaryOperation");
        Object prevalue, postvalue;
        prevalue = lhs.getValue();
        postvalue = unaryOperation(prevalue, kind);
		Object retVal;
		if ( postfix )
			retVal = prevalue;
		else
			retVal = postvalue;
		lhs.assign( postvalue, strictJava );
		return retVal;
    }
    public Object unaryOperation( Object op, int kind ) throws UtilEvalError
    {
        if (op instanceof Boolean || op instanceof Character 
			|| op instanceof Number)
            return primitiveWrapperUnaryOperation( op, kind );
        if ( !(op instanceof Primitive) )
            throw new UtilEvalError( "Unary operation " + tokenImage[kind]
                + " inappropriate for object" );
		
        return Primitive.unaryOperation((Primitive)op, kind);
    }
    private Object primitiveWrapperUnaryOperation(Object val, int kind)
        throws UtilEvalError
    {
        Class operandType = val.getClass();
        Object operand = Primitive.promoteToInteger(val);
        if ( operand instanceof Boolean )
			return new Boolean(
				Primitive.booleanUnaryOperation((Boolean)operand, kind));
        else 
		if ( operand instanceof Integer )
        {
            int result = Primitive.intUnaryOperation((Integer)operand, kind);
            // ++ and -- must be cast back the original type
            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Byte((byte)result);
                if(operandType == Short.TYPE)
                    return new Short((short)result);
                if(operandType == Character.TYPE)
                    return new Character((char)result);
            }
            return new Integer(result);
        }
        else if(operand instanceof Long)
            return new Long(Primitive.longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Float(Primitive.floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Double(Primitive.doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError("An error occurred.  Please call technical support.");
    }
    public <T> T accept(BshNodeVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
/**
	What's in a name?  I'll tell you...
	Name() is a somewhat ambiguous thing in the grammar and so is this.
	<p>
	
	This class is a name resolver.  It holds a possibly ambiguous dot 
	separated name and reference to a namespace in which it allegedly lives.  
	It provides methods that attempt to resolve the name to various types of 
	entities: e.g. an Object, a Class, a declared scripted BeanShell method.
	<p>
	Name objects are created by the factory method NameSpace getNameResolver(), 
	which caches them subject to a class namespace change.  This means that 
	we can cache information about various types of resolution here.
	Currently very little if any information is cached.  However with a future
	"optimize" setting that defeats certain dynamic behavior we might be able
	to cache quite a bit.
*/
/*
	<strong>Implementation notes</strong>
	<pre>
	Thread safety: all of the work methods in this class must be synchronized
	because they share the internal intermediate evaluation state.
	Note about invokeMethod():  We could simply use resolveMethod and return
	the MethodInvoker (BshMethod or JavaMethod) however there is no easy way
	for the AST (BSHMehodInvocation) to use this as it doesn't have type
	information about the target to resolve overloaded methods.
	(In Java, overloaded methods are resolved at compile time... here they
	are, of necessity, dynamic).  So it would have to do what we do here
	and cache by signature.  We now do that for the client in Reflect.java.
	Note on this.caller resolution:
	Although references like these do work:
		this.caller.caller.caller...   // works
	the equivalent using successive calls:
		// does *not* work
		for( caller=this.caller; caller != null; caller = caller.caller );
	is prohibited by the restriction that you can only call .caller on a 
	literal	this or caller reference.  The effect is that magic caller 
	reference only works through the current 'this' reference.
	The real explanation is that This referernces do not really know anything
	about their depth on the call stack.  It might even be hard to define
	such a thing...
	For those purposes we provide :
		this.callstack
	</pre>
*/
public class Name implements java.io.Serializable
{
	// These do not change during evaluation
	public NameSpace namespace;
	String value = null;
	
	// ---------------------------------------------------------
	// The following instance variables mutate during evaluation and should
	// be reset by the reset() method where necessary
	// For evaluation
	/** Remaining text to evaluate */
	private String evalName;
	/** 
		The last part of the name evaluated.  This is really only used for
	 	this, caller, and super resolution.
	*/
	private String lastEvalName;
	private static String FINISHED = null; // null evalname and we're finished
	private Object evalBaseObject;	// base object for current eval
	private int callstackDepth;		// number of times eval hit 'this.caller'
	//  
	//  End mutable instance variables.
	// ---------------------------------------------------------
	// Begin Cached result structures
	// These are optimizations 
	// Note: it's ok to cache class resolution here because when the class
	// space changes the namespace will discard cached names.
	/** 
		The result is a class 
	*/
	Class asClass;
	/** 
		The result is a static method call on the following class 
	*/
	Class classOfStaticMethod;
	// End Cached result structures
	private void reset() {
		evalName = value;
		evalBaseObject = null;
		callstackDepth = 0;
	}
	/**
		This constructor should *not* be used in general. 
		Use NameSpace getNameResolver() which supports caching.
		@see NameSpace getNameResolver().
	*/
	// I wish I could make this "friendly" to only NameSpace
	Name( NameSpace namespace, String s )
	{
		this.namespace = namespace;
		value = s;
	}
	/**
		Resolve possibly complex name to an object value.
		Throws EvalError on various failures.
		A null object value is indicated by a Primitive.NULL.
		A return type of Primitive.VOID comes from attempting to access
		an undefined variable.
		Some cases:
			myVariable
			myVariable.foo
			myVariable.foo.bar
			java.awt.GridBagConstraints.BOTH
			my.package.stuff.MyClass.someField.someField...
		Interpreter reference is necessary to allow resolution of 
		"this.interpreter" magic field.
		CallStack reference is necessary to allow resolution of 
		"this.caller" magic field.
		"this.callstack" magic field.
	*/
	public Object toObject( BshEvaluatingVisitor visitor )
		throws UtilEvalError
	{
		return toObject( visitor, false );
	}
	/**
		see #toObject(CallStack, Interpreter)
		@param forceClass if true then resolution will only produce a class.
		This is necessary to disambiguate in cases where the grammar knows
		that we want a class; where in general the var path may be taken.
	*/
	synchronized public Object toObject( 
		BshEvaluatingVisitor visitor, boolean forceClass )
		throws UtilEvalError
	{
		reset();
		Object obj = null;
		while( evalName != null )
			obj = consumeNextObjectField(visitor, forceClass, false/*autoalloc*/  );
		if ( obj == null )
			throw new InterpreterError("null value in toObject()");
		return obj;
	}
	private Object completeRound( 
		String lastEvalName, String nextEvalName, Object returnObject )
	{
		if ( returnObject == null )
			throw new InterpreterError("lastEvalName = "+lastEvalName);
		this.lastEvalName = lastEvalName;
		this.evalName = nextEvalName;
		this.evalBaseObject = returnObject;
		return returnObject;
	}
	/**
		Get the next object by consuming one or more components of evalName.  
		Often this consumes just one component, but if the name is a classname 
		it will consume all of the components necessary to make the class 
		identifier.
	*/
	private Object consumeNextObjectField( 	
		BshEvaluatingVisitor visitor,
		boolean forceClass, boolean autoAllocateThis ) 
		throws UtilEvalError
	{
		/*
			Is it a simple variable name?
			Doing this first gives the correct Java precedence for vars 
			vs. imported class names (at least in the simple case - see
			tests/precedence1.bsh).  It should also speed things up a bit.
		*/
		if ( (evalBaseObject == null && !isCompound(evalName) )
			&& !forceClass ) 
		{
			Object obj = resolveThisFieldReference( visitor,
				namespace, evalName, false );
			if ( obj != Primitive.VOID )
				return completeRound( evalName, FINISHED, obj );
		}
		/*
			Is it a bsh script variable reference?
			If we're just starting the eval of name (no base object)
			or we're evaluating relative to a This type reference check.
		*/
		String varName = prefix(evalName, 1);
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug("trying to resolve variable: " + varName);
			Object obj;
			// switch namespace and special var visibility
			if ( evalBaseObject == null ) {
				obj = resolveThisFieldReference(visitor, namespace, varName, false );
			} else {
				obj = resolveThisFieldReference(visitor,
					((This)evalBaseObject).namespace,
					varName, true );
			}
			if ( obj != Primitive.VOID ) 
			{
				// Resolved the variable
				if ( Interpreter.DEBUG ) 
					Interpreter.debug( "resolved variable: " + varName + 
					" in namespace: "+namespace);
				return completeRound( varName, suffix(evalName), obj );
			}
		}
		/*
			Is it a class name?
			If we're just starting eval of name try to make it, else fail.
		*/
		if ( evalBaseObject == null ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( "trying class: " + evalName);
			
			/*
				Keep adding parts until we have a class 
			*/
			Class clas = null;
			int i = 1;
			String className = null;
			for(; i <= countParts(evalName); i++)
			{
				className = prefix(evalName, i);
				if ( (clas = namespace.getClass(className)) != null )
					break;
			}
		
			if ( clas != null )  {
				return completeRound(
					className,
					suffix( evalName, countParts(evalName)-i ),
					new ClassIdentifier(clas) 
				);
			}
			// not a class (or variable per above)
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( "not a class, trying var prefix "+evalName );
		}
		// No variable or class found in 'this' type ref.
		// if autoAllocateThis then create one; a child 'this'.
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass && autoAllocateThis )
		{
			NameSpace targetNameSpace = 
				( evalBaseObject == null ) ?  
					namespace : ((This)evalBaseObject).namespace;
			Object obj = new NameSpace( 
				targetNameSpace, "auto: "+varName ).getThis( visitor.getInterpreter() );
			targetNameSpace.setVariable( varName, obj, false );
			return completeRound( varName, suffix(evalName), obj );
		}
		/*
			If we didn't find a class or variable name (or prefix) above
			there are two possibilities:
			- If we are a simple name then we can pass as a void variable 
			reference.
			- If we are compound then we must fail at this point.
		*/
		if ( evalBaseObject == null ) {
			if ( !isCompound(evalName) ) {
				return completeRound( evalName, FINISHED, Primitive.VOID );
			} else
				throw new UtilEvalError(
					"Class or variable not found: " + evalName);
		}
		/*
			--------------------------------------------------------
			After this point we're definitely evaluating relative to
			a base object.
			--------------------------------------------------------
		*/
		/*
			Do some basic validity checks.
		*/
		if ( evalBaseObject == Primitive.NULL) // previous round produced null
			throw new UtilTargetError( new NullPointerException( 
				"Null Pointer while evaluating: " +value ) );
		if ( evalBaseObject == Primitive.VOID) // previous round produced void
			throw new UtilEvalError(
				"Undefined variable or class name while evaluating: "+value);
		if ( evalBaseObject instanceof Primitive)
			throw new UtilEvalError("Can't treat primitive like an object. "+
			"Error while evaluating: "+value);
		/* 
			Resolve relative to a class type
			static field, inner class, ?
		*/
		if ( evalBaseObject instanceof ClassIdentifier ) 
		{
			Class clas = ((ClassIdentifier)evalBaseObject).getTargetClass();
			String field = prefix(evalName, 1);
			// Class qualified 'this' reference from inner class.
			// e.g. 'MyOuterClass.this'
			if ( field.equals("this") )
			{
				// find the enclosing class instance space of the class name
				NameSpace ns = namespace;
				while ( ns != null )
				{
					// getClassInstance() throws exception if not there
					if ( ns.classInstance != null 
						&& ns.classInstance.getClass() == clas 
					)
						return completeRound( 
							field, suffix(evalName), ns.classInstance );
					ns=ns.getParent();
				}
				throw new UtilEvalError(
					"Can't find enclosing 'this' instance of class: "+clas);
			}
			Object obj = null;
			// static field?
			try {
				if ( Interpreter.DEBUG ) 
					Interpreter.debug("Name call to getStaticFieldValue, class: "
						+clas+", field:"+field);
				obj = Reflect.getStaticFieldValue(clas, field);
			} catch( ReflectError e ) { 
				if ( Interpreter.DEBUG ) 
					Interpreter.debug("field reflect error: "+e);
			}
			// inner class?
			if ( obj == null ) {
				String iclass = clas.getName()+"$"+field;
				Class c = namespace.getClass( iclass );
				if ( c != null )
					obj = new ClassIdentifier(c);
			}
			if ( obj == null )
				throw new UtilEvalError(
					"No static field or inner class: " 
					+ field + " of " + clas );
			return completeRound( field, suffix(evalName), obj );
		}
		/*
			If we've fallen through here we are no longer resolving to
			a class type.
		*/
		if ( forceClass )
			throw new UtilEvalError( 
				value +" does not resolve to a class name." );
		/* 
			Some kind of field access?
		*/
		String field = prefix(evalName, 1);
		// length access on array? 
		if ( field.equals("length") && evalBaseObject.getClass().isArray() )
		{
			Object obj = new Primitive(Array.getLength(evalBaseObject));
			return completeRound( field, suffix(evalName), obj );
		}
		// Check for field on object 
		// Note: could eliminate throwing the exception somehow
		try {
			Object obj = Reflect.getObjectFieldValue(evalBaseObject, field);
			return completeRound( field, suffix(evalName), obj );
		} catch(ReflectError e) { /* not a field */ }
	
		// if we get here we have failed
		throw new UtilEvalError(
			"Cannot access field: " + field + ", on object: " + evalBaseObject);
	}
	/**
		Resolve a variable relative to a This reference.
		This is the general variable resolution method, accomodating special
		fields from the This context.  Together the namespace and interpreter
		comprise the This context.  The callstack, if available allows for the
		this.caller construct.  
		Optionally interpret special "magic" field names: e.g. interpreter.
		<p/>
		@param visitor may be null, but this is only legitimate in special
		cases where we are sure resolution will not involve this.caller.
		@param thisNameSpace the namespace of the this reference (should be the
		same as the top of the stack?
	*/
	Object resolveThisFieldReference( BshEvaluatingVisitor visitor,
		NameSpace thisNameSpace,
		String varName, boolean specialFieldsVisible ) 
		throws UtilEvalError
	{
		if ( varName.equals("this") ) 
		{
			/*
				Somewhat of a hack.  If the special fields are visible (we're
				operating relative to a 'this' type already) dissallow further
				.this references to prevent user from skipping to things like
				super.this.caller
			*/
			if ( specialFieldsVisible )
				throw new UtilEvalError("Redundant to call .this on This type");
			// Allow getThis() to work through BlockNameSpace to the method
			// namespace
	// XXX re-eval this... do we need it?
			This ths = thisNameSpace.getThis( visitor.getInterpreter() );
			thisNameSpace= ths.getNameSpace();
			Object result = ths;
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				if ( isCompound( evalName ) )
					result = classNameSpace.getThis( visitor.getInterpreter() );
				else
					result = classNameSpace.getClassInstance();
			}
			return result;
		}
		/*
			Some duplication for "super".  See notes for "this" above
			If we're in an enclsing class instance and have a superclass
			instance our super is the superclass instance.
		*/
		if ( varName.equals("super") ) 
		{
			//if ( specialFieldsVisible )
			//throw new UtilEvalError("Redundant to call .this on This type");
			// Allow getSuper() to through BlockNameSpace to the method's super
			This ths = thisNameSpace.getSuper( visitor.getInterpreter() );
			thisNameSpace = ths.getNameSpace();
			// super is now the closure's super or class instance
	// XXXX re-evaluate this
	// can getSuper work by itself now?
			// If we're a class instance and the parent is also a class instance
			// then super means our parent.
			if ( 
				thisNameSpace.getParent() != null 
				&& thisNameSpace.getParent().isClass
			)
				ths = thisNameSpace.getParent().getThis( visitor.getInterpreter() );
			return ths;
		}
		Object obj = null;
		if ( varName.equals("global") )
			obj = thisNameSpace.getGlobal( visitor.getInterpreter() );
		if ( obj == null && specialFieldsVisible ) 
		{
			if (varName.equals("namespace"))
				obj = thisNameSpace;
			else if (varName.equals("variables"))
				obj = thisNameSpace.getVariableNames();
			else if (varName.equals("methods"))
				obj = thisNameSpace.getMethodNames();
			else if ( varName.equals("interpreter") )
				if ( lastEvalName.equals("this") )
					obj = visitor.getInterpreter();
				else
					throw new UtilEvalError(
						"Can only call .interpreter on literal 'this'");
		}
		if ( obj == null && specialFieldsVisible && varName.equals("caller") )
		{
			if ( lastEvalName.equals("this") || lastEvalName.equals("caller") ) 
			{
				// get the previous context (see notes for this class)
				if ( visitor.getInterpreter() == null )
					throw new InterpreterError("no callstack");
				obj = visitor.getCallstack().get( ++callstackDepth ).getThis(
					visitor.getInterpreter() );
			}
			else
				throw new UtilEvalError(
				"Can only call .caller on literal 'this' or literal '.caller'");
			// early return
			return obj;
		}
		if ( obj == null && specialFieldsVisible 
			&& varName.equals("callstack") )
		{
			if ( lastEvalName.equals("this") ) 
			{
				// get the previous context (see notes for this class)
				if ( visitor.getCallstack() == null )
					throw new InterpreterError("no callstack");
				obj = visitor.getCallstack();
			}
			else
				throw new UtilEvalError(
				"Can only call .callstack on literal 'this'");
		}
		if ( obj == null )
			obj = thisNameSpace.getVariable(varName);
		if ( obj == null )
			throw new InterpreterError("null this field ref:"+varName);
		return obj;
	}
	/**
		@return the enclosing class body namespace or null if not in a class.
	*/
	public static NameSpace getClassNameSpace( NameSpace thisNameSpace )
	{
		// is a class instance
		//if ( thisNameSpace.classInstance != null )
		if ( thisNameSpace.isClass )
			return thisNameSpace;
		if ( thisNameSpace.isMethod 
			&& thisNameSpace.getParent() != null 
			//&& thisNameSpace.getParent().classInstance != null
			&& thisNameSpace.getParent().isClass
		)
			return thisNameSpace.getParent();
		return null;
	}
	/**
		Check the cache, else use toObject() to try to resolve to a class
		identifier.  
		@throws ClassNotFoundException on class not found.
		@throws ClassPathException (type of EvalError) on special case of 
		ambiguous unqualified name after super import. 
	*/
	synchronized public Class toClass() 
		throws ClassNotFoundException, UtilEvalError
	{
		if ( asClass != null )
			return asClass;
		reset();
		// "var" means untyped, return null class
		if ( evalName.equals("var") )
			return asClass = null;
		/* Try straightforward class name first */
		Class clas = namespace.getClass( evalName );
		if ( clas == null ) 
		{
			/* 
				Try toObject() which knows how to work through inner classes
				and see what we end up with 
			*/
			Object obj = null;
			try {
				// Null interpreter and callstack references.
				// class only resolution should not require them.
				obj = toObject( new BshEvaluatingVisitor(null, null), true );
			} catch ( UtilEvalError  e ) { }; // couldn't resolve it
		
			if ( obj instanceof ClassIdentifier )
				clas = ((ClassIdentifier)obj).getTargetClass();
		}
		if ( clas == null )
			throw new ClassNotFoundException(
				"Class: " + value+ " not found in namespace");
		asClass = clas;
		return asClass;
	}
	/*
	*/
	synchronized public LHS toLHS( 
		BshEvaluatingVisitor visitor )
		throws UtilEvalError
	{
		// Should clean this up to a single return statement
		reset();
		LHS lhs;
		// Simple (non-compound) variable assignment e.g. x=5;
		if ( !isCompound(evalName) ) 
		{
			if ( evalName.equals("this") )
				throw new UtilEvalError("Can't assign to 'this'." );
			// Interpreter.debug("Simple var LHS...");
			lhs = new LHS( namespace, evalName, false/*bubble up if allowed*/);
			return lhs;
		}
		// Field e.g. foo.bar=5;
		Object obj = null;
		try {
			while( evalName != null && isCompound( evalName ) )
			{
				obj = consumeNextObjectField( visitor,
					false/*forcclass*/, true/*autoallocthis*/ );
			}
		} 
		catch( UtilEvalError e ) {
			throw new UtilEvalError( "LHS evaluation: " + e.getMessage() );
		}
		// Finished eval and its a class.
		if ( evalName == null && obj instanceof ClassIdentifier )
			throw new UtilEvalError("Can't assign to class: " + value );
		if ( obj == null )
			throw new UtilEvalError("Error in LHS: " + value );
		// e.g. this.x=5;  or someThisType.x=5;
		if ( obj instanceof This )
		{
			// dissallow assignment to magic fields
			if ( 
				evalName.equals("namespace")
				|| evalName.equals("variables")
				|| evalName.equals("methods")
				|| evalName.equals("caller")
			)
				throw new UtilEvalError(
					"Can't assign to special variable: "+evalName );
			Interpreter.debug("found This reference evaluating LHS");
			/*
				If this was a literal "super" reference then we allow recursion
				in setting the variable to get the normal effect of finding the
				nearest definition starting at the super scope.  On any other
				resolution qualified by a 'this' type reference we want to set
				the variable directly in that scope. e.g. this.x=5;  or 
				someThisType.x=5;
				
				In the old scoping rules super didn't do this.
			*/
			boolean localVar = !lastEvalName.equals("super");
			return new LHS( ((This)obj).namespace, evalName, localVar );
		}
		if ( evalName != null )
		{
			try {
				if ( obj instanceof ClassIdentifier ) 
				{
					Class clas = ((ClassIdentifier)obj).getTargetClass();
					lhs = Reflect.getLHSStaticField(clas, evalName);
					return lhs;
				} else {
					lhs = Reflect.getLHSObjectField(obj, evalName);
					return lhs;
				}
			} catch(ReflectError e) {
				throw new UtilEvalError("Field access: "+e);
			}
		}
		throw new InterpreterError("Internal error in lhs...");
	}
	
    /**
		Invoke the method identified by this name.
		Performs caching of method resolution using SignatureKey.
		<p>
        Name contains a wholely unqualfied messy name; resolve it to 
		( object | static prefix ) + method name and invoke.
		<p>
        The interpreter is necessary to support 'this.interpreter' references
		in the called code. (e.g. debug());
		<p>
		<pre>
        Some cases:
            // dynamic
            local();
            myVariable.foo();
            myVariable.bar.blah.foo();
            // static
            java.lang.Integer.getInteger("foo");
		</pre>
    */
    public Object invokeMethod( BshEvaluatingVisitor visitor,
		Object[] args,
		SimpleNode callerInfo
	)
        throws UtilEvalError, EvalError, ReflectError, InvocationTargetException
    {
        String methodName = Name.suffix(value, 1);
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		NameSpace namespace = visitor.getCallstack().top();
		// Optimization - If classOfStaticMethod is set then we have already 
		// been here and determined that this is a static method invocation.
		// Note: maybe factor this out with path below... clean up.
        if ( classOfStaticMethod != null )
		{
			return Reflect.invokeStaticMethod( 
				bcm, classOfStaticMethod, methodName, args );
		}
		if ( !Name.isCompound(value) )
			return invokeLocalMethod( visitor,
				args, callerInfo );
		// Note: if we want methods declared inside blocks to be accessible via
		// this.methodname() inside the block we could handle it here as a
		// special case.  See also resolveThisFieldReference() special handling
		// for BlockNameSpace case.  They currently work via the direct name
		// e.g. methodName().
        String prefix = Name.prefix(value);
		// Superclass method invocation? (e.g. super.foo())
		if ( prefix.equals("super") && Name.countParts(value) == 2 )
		{
			// Allow getThis() to work through block namespaces first
			This ths = namespace.getThis( visitor.getInterpreter() );
			NameSpace thisNameSpace = ths.getNameSpace();
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				Object instance = classNameSpace.getClassInstance();
				return ClassGenerator.getClassGenerator()
					.invokeSuperclassMethod( bcm, instance, methodName, args );
			}
		}
        // Find target object or class identifier
        Name targetName = namespace.getNameResolver( prefix );
        Object obj = targetName.toObject( visitor );
		if ( obj == Primitive.VOID ) 
			throw new UtilEvalError( "Attempt to resolve method: "+methodName
					+"() on undefined variable or class name: "+targetName);
        // if we've got an object, resolve the method
        if ( !(obj instanceof ClassIdentifier) ) {
            if (obj instanceof Primitive) {
                if (obj == Primitive.NULL)
                    throw new UtilTargetError( new NullPointerException( 
						"Null Pointer in Method Invocation of " +methodName
							+"() on variable: "+targetName) );
                // some other primitive
                // should avoid calling methods on primitive, as we do
                // in Name (can't treat primitive like an object message)
                // but the hole is useful right now.
				if ( Interpreter.DEBUG )
                	visitor.getInterpreter().debug(
					"Attempt to access method on primitive..." 
					+ " allowing bsh.Primitive to peek through for debugging");
            }
            // found an object and it's not an undefined variable
            return Reflect.invokeObjectMethod(obj, methodName, args, visitor, callerInfo );
        }
		// It's a class
        // try static method
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug("invokeMethod: trying static - " + targetName);
        Class clas = ((ClassIdentifier)obj).getTargetClass();
		// cache the fact that this is a static method invocation on this class
		classOfStaticMethod = clas;
		
        if ( clas != null )
			return Reflect.invokeStaticMethod( bcm, clas, methodName, args );
        // return null; ???
		throw new UtilEvalError("invokeMethod: unknown target: " + targetName);
    }
	/**
		Invoke a locally declared method or a bsh command.
		If the method is not already declared in the namespace then try
		to load it as a resource from the imported command path (e.g.
		/bsh/commands)
	*/
	/*
		Note: the bsh command code should probably not be here...  we need to
		scope it by the namespace that imported the command... so it probably
		needs to be integrated into NameSpace.
	*/
    private Object invokeLocalMethod( BshEvaluatingVisitor visitor,
		Object[] args,
		SimpleNode callerInfo
	)
        throws EvalError/*, ReflectError, InvocationTargetException*/
    {
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug( "invokeLocalMethod: " + value );
		if ( visitor.getInterpreter() == null )
			throw new InterpreterError(
				"invokeLocalMethod: interpreter = null");
		String commandName = value;
		Class [] argTypes = Types.getTypes( args );
        // Check for existing method
        BshMethod meth = null;
		try {
			meth = namespace.getMethod( commandName, argTypes );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(
				"Local method invocation", callerInfo, visitor.getCallstack() );
		}
		// If defined, invoke it
        if ( meth != null )
			return meth.invoke( args, visitor, callerInfo );
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		// Look for a BeanShell command
		Object commandObject;
		try {
			commandObject = namespace.getCommand( 
				commandName, argTypes, visitor.getInterpreter() );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError("Error loading command: ", 
				callerInfo, visitor.getCallstack() );
		}
		// should try to print usage here if nothing found
		if ( commandObject == null )
		{
			// Look for a default invoke() handler method in the namespace
			// Note: this code duplicates that in This.java... should it?
			// Call on 'This' can never be a command
			BshMethod invokeMethod = null;
			try {
				invokeMethod = namespace.getMethod( 
					"invoke", new Class [] { null, null } );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					"Local method invocation", callerInfo, visitor.getCallstack() );
			}
			if ( invokeMethod != null )
				return invokeMethod.invoke( 
					new Object [] { commandName, args },
                        visitor,
					callerInfo );
            throw new EvalError( "Command not found: " 
				+StringUtil.methodString( commandName, argTypes ), 
				callerInfo, visitor.getCallstack() );
		}
		if ( commandObject instanceof BshMethod )
			return ((BshMethod)commandObject).invoke( 
				args, visitor, callerInfo );
		if ( commandObject instanceof Class )
			try {
				return Reflect.invokeCompiledCommand( 
					((Class)commandObject), args, visitor );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError("Error invoking compiled command: ",
				callerInfo, visitor.getCallstack() );
			}
		throw new InterpreterError("invalid command type");
    }
/*
	private String getHelp( String name )
		throws UtilEvalError
	{
		try {
			// should check for null namespace here
			return get( "bsh.help."+name, null/interpreter/ );
		} catch ( Exception e ) {
			return "usage: "+name;
		}
	}
	private String getHelp( Class commandClass )
		throws UtilEvalError
	{
        try {
            return (String)Reflect.invokeStaticMethod(
				null/bcm/, commandClass, "usage", null );
        } catch( Exception e )
			return "usage: "+name;
		}
	}
*/
	// Static methods that operate on compound ('.' separated) names
	// I guess we could move these to StringUtil someday
	public static boolean isCompound(String value)
	{
		return value.indexOf('.') != -1 ;
		//return countParts(value) > 1;
	}
	static int countParts(String value)
	{
		if(value == null)
			return 0;
		int count = 0;
		int index = -1;
		while((index = value.indexOf('.', index + 1)) != -1)
			count++;
		return count + 1;
	}
	static String prefix(String value)
	{
		if(!isCompound(value))
			return null;
		return prefix(value, countParts(value) - 1);
	}
	static String prefix(String value, int parts)
	{
		if (parts < 1 )
			return null;
		int count = 0;
		int index = -1;
		while( ((index = value.indexOf('.', index + 1)) != -1) 
			&& (++count < parts) )
		{ ; }
		return (index == -1) ? value : value.substring(0, index);
	}
	static String suffix(String name)
	{
		if(!isCompound(name))
			return null;
		return suffix(name, countParts(name) - 1);
	}
	public static String suffix(String value, int parts)
	{
		if (parts < 1)
			return null;
		int count = 0;
		int index = value.length() + 1;
		while ( ((index = value.lastIndexOf('.', index - 1)) != -1) 
			&& (++count < parts) );
		return (index == -1) ? value : value.substring(index + 1);
	}
	// end compound name routines
	public String toString() { return value; }
}
package bsh;
import bsh.ast.SimpleNode;
/**
	Represents a Return, Break, or Continue statement
*/
public class ReturnControl implements ParserConstants {
	public int kind;
	public Object value;
	/** The node where we returned... for printing error messages correctly */
	public SimpleNode returnPoint;
	public ReturnControl( int kind, Object value, SimpleNode returnPoint ) {
		this.kind = kind;
		this.value = value;
		this.returnPoint = returnPoint;
	}
}
package bsh;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.Collections;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;
/**
	BshClassManager manages all classloading in BeanShell.
	It also supports a dynamically loaded extension (bsh.classpath package)
	which allows classpath extension and class file reloading.
	Currently the extension relies on 1.2 for BshClassLoader and weak 
	references.  
	See http://www.beanshell.org/manual/classloading.html for details
	on the bsh classloader architecture.
	<p>
	Bsh has a multi-tiered class loading architecture.  No class loader is
	used unless/until the classpath is modified or a class is reloaded.
	<p>
*/
/*
	Implementation notes:
	Note: we may need some synchronization in here
	Note on version dependency:  This base class is JDK 1.1 compatible,
	however we are forced to use weak references in the full featured
	implementation (the optional bsh.classpath package) to accomodate all of
	the fleeting namespace listeners as they fall out of scope.  (NameSpaces
	must be informed if the class space changes so that they can un-cache
	names).  
	<p>
	Perhaps a simpler idea would be to have entities that reference cached
	types always perform a light weight check with a counter / reference
	value and use that to detect changes in the namespace.  This puts the 
	burden on the consumer to check at appropriate times, but could eliminate
	the need for the listener system in many places and the necessity of weak 
	references in this package.
	<p>
*/
public class BshClassManager
{
	/** 
		The interpreter which created the class manager 
		This is used to load scripted classes from source files.
	*/
	private Interpreter declaringInterpreter;
	
	/**
		An external classloader supplied by the setClassLoader() command.
	*/
	protected ClassLoader externalClassLoader;
	/**
		Global cache for things we know are classes.
		Note: these should probably be re-implemented with Soft references.
		(as opposed to strong or Weak)
	*/
    protected transient Map<String,Class> absoluteClassCache = new Hashtable<String,Class>();
	/**
		Global cache for things we know are *not* classes.
		Note: these should probably be re-implemented with Soft references.
		(as opposed to strong or Weak)
	*/
    protected transient Set<String> absoluteNonClasses = Collections.synchronizedSet(new HashSet<String>());
	/**
		Caches for resolved object and static methods.
		We keep these maps separate to support fast lookup in the general case
		where the method may be either.
	*/
	protected transient volatile Map<SignatureKey,Method> resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
	protected transient volatile Map<SignatureKey,Method> resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
	private transient Set<String> definingClasses = Collections.synchronizedSet(new HashSet<String>());
	protected transient Map<String,String> definingClassesBaseNames = new Hashtable<String,String>();
	private static final Map<BshClassManager,Object> classManagers = Collections.synchronizedMap(new WeakHashMap<BshClassManager,Object>());
	static void clearResolveCache() {
		BshClassManager[] managers = (BshClassManager[])classManagers.keySet().toArray(new BshClassManager[0]);
		for( BshClassManager m : managers ) {
			m.resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
			m.resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
		}
	}
	/**
		Create a new instance of the class manager.  
		Class manager instnaces are now associated with the interpreter.
		@see bsh.Interpreter.getClassManager()
		@see bsh.Interpreter.setClassLoader( ClassLoader )
	*/
	public static BshClassManager createClassManager( Interpreter interpreter ) 
	{
		BshClassManager manager;
		// Do we have the optional package?
		if ( Capabilities.classExists("bsh.classpath.ClassManagerImpl") ) 
			try {
				// Try to load the module
				// don't refer to it directly here or we're dependent upon it
				Class clazz = Class.forName( "bsh.classpath.ClassManagerImpl" );
				manager = (BshClassManager) clazz.newInstance();
			} catch ( Exception e ) {
				throw new InterpreterError("Error loading classmanager", e);
			}
		else
			manager = new BshClassManager();
		if ( interpreter == null )
			interpreter = new Interpreter();
		manager.declaringInterpreter = interpreter;
		classManagers.put(manager,null);
		return manager;
	}
	public boolean classExists( String name ) {
		return ( classForName( name ) != null );
	}
	/**
		Load the specified class by name, taking into account added classpath
		and reloaded classes, etc.
		Note: Again, this is just a trivial implementation. 
		See bsh.classpath.ClassManagerImpl for the fully functional class
		management package.
		@return the class or null
	*/
	public Class classForName( String name ) 
	{
		if ( isClassBeingDefined( name ) )
			throw new InterpreterError(
				"Attempting to load class in the process of being defined: "
				+name );
		Class clas = null;
		try {
			clas = plainClassForName( name );
		} catch ( ClassNotFoundException e ) { /*ignore*/ }
		return clas;
	}
	/**
		Perform a plain Class.forName() or call the externally provided
		classloader.
		If a BshClassManager implementation is loaded the call will be 
		delegated to it, to allow for additional hooks.
		<p/>
		This simply wraps that bottom level class lookup call and provides a 
		central point for monitoring and handling certain Java version 
		dependent bugs, etc.
		@see #classForName( String )
		@return the class
	*/
	public Class plainClassForName( String name ) 
		throws ClassNotFoundException
	{
		Class c = null;
		if ( externalClassLoader != null )
			c = externalClassLoader.loadClass( name );
		else
			c = Class.forName( name );
		cacheClassInfo( name, c );
		return c;
	}
	/**
		Get a resource URL using the BeanShell classpath
		@param path should be an absolute path
	*/
	public URL getResource( String path ) 
	{
		URL url = null;
		if ( externalClassLoader != null )
		{
			// classloader wants no leading slash
			url = externalClassLoader.getResource( path.substring(1) );
		} 
		if ( url == null )
			url = Interpreter.class.getResource( path );
		return url;
	}
	/**
		Get a resource stream using the BeanShell classpath
		@param path should be an absolute path
	*/
	public InputStream getResourceAsStream( String path ) 
	{
		InputStream in = null;
		if ( externalClassLoader != null )
		{
			// classloader wants no leading slash
			in = externalClassLoader.getResourceAsStream( path.substring(1) );
		} 
		if ( in == null )
			in = Interpreter.class.getResourceAsStream( path );
		return in;
	}
	/**
		Cache info about whether name is a class or not.
		@param value 
			if value is non-null, cache the class
			if value is null, set the flag that it is *not* a class to
			speed later resolution
	*/
	public void cacheClassInfo( String name, Class value ) {
		if ( value != null )
			absoluteClassCache.put( name, value );
		else
			absoluteNonClasses.add( name );
	}
	/**
		Cache a resolved (possibly overloaded) method based on the 
		argument types used to invoke it, subject to classloader change.
		Static and Object methods are cached separately to support fast lookup
		in the general case where either will do.
	*/
	public void cacheResolvedMethod( 
		Class clas, Class [] types, Method method ) 
	{
		if ( Interpreter.DEBUG )
			Interpreter.debug(
				"cacheResolvedMethod putting: " + clas +" "+ method );
		
		SignatureKey sk = new SignatureKey( clas, method.getName(), types );
		if ( Modifier.isStatic( method.getModifiers() ) )
			resolvedStaticMethods.put( sk, method );
		else
			resolvedObjectMethods.put( sk, method );
	}
	/**
		Return a previously cached resolved method.
		@param onlyStatic specifies that only a static method may be returned.
		@return the Method or null
	*/
	protected Method getResolvedMethod( 
		Class clas, String methodName, Class [] types, boolean onlyStatic  ) 
	{
		SignatureKey sk = new SignatureKey( clas, methodName, types );
		// Try static and then object, if allowed
		// Note that the Java compiler should not allow both.
		Method method = resolvedStaticMethods.get( sk );
		if ( method == null && !onlyStatic)
			method = resolvedObjectMethods.get( sk );
		if ( Interpreter.DEBUG )
		{
			if ( method == null )
				Interpreter.debug(
					"getResolvedMethod cache MISS: " + clas +" - "+methodName );
			else
				Interpreter.debug(
					"getResolvedMethod cache HIT: " + clas +" - " +method );
		}
		return method;
	}
	/**
		Clear the caches in BshClassManager
		@see public void #reset() for external usage
	*/
	protected void clearCaches() 
	{
		absoluteNonClasses = Collections.synchronizedSet(new HashSet<String>());
		absoluteClassCache = new Hashtable<String,Class>();
		resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
		resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
	}
	/**
		Set an external class loader.  BeanShell will use this at the same 
		point it would otherwise use the plain Class.forName().
		i.e. if no explicit classpath management is done from the script
		(addClassPath(), setClassPath(), reloadClasses()) then BeanShell will
		only use the supplied classloader.  If additional classpath management
		is done then BeanShell will perform that in addition to the supplied
		external classloader.
		However BeanShell is not currently able to reload
		classes supplied through the external classloader.
	*/
	public void setClassLoader( ClassLoader externalCL ) 
	{
		externalClassLoader = externalCL;
		classLoaderChanged();
	}
	public void addClassPath( URL path )
		throws IOException {
	}
	/**
		Clear all loaders and start over.  No class loading.
	*/
	public void reset() { 
		clearCaches();
	}
	/**
		Set a new base classpath and create a new base classloader.
		This means all types change. 
	*/
	public void setClassPath( URL [] cp ) 
		throws UtilEvalError
	{
		throw cmUnavailable();
	}
	/**
		Overlay the entire path with a new class loader.
		Set the base path to the user path + base path.
		No point in including the boot class path (can't reload thos).
	*/
	public void reloadAllClasses() throws UtilEvalError {
		throw cmUnavailable();
	}
	/**
		Reloading classes means creating a new classloader and using it
		whenever we are asked for classes in the appropriate space.
		For this we use a DiscreteFilesClassLoader
	*/
	public void reloadClasses( String [] classNames )
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	/**
		Reload all classes in the specified package: e.g. "com.sun.tools"
		The special package name "<unpackaged>" can be used to refer 
		to unpackaged classes.
	*/
	public void reloadPackage( String pack ) 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	/**
		This has been removed from the interface to shield the core from the
		rest of the classpath package. If you need the classpath you will have
		to cast the classmanager to its impl.
		public BshClassPath getClassPath() throws ClassPathException;
	*/
	/**
		Support for "import *;"
		Hide details in here as opposed to NameSpace.
	*/
	protected void doSuperImport() 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	/**
		A "super import" ("import *") operation has been performed.
	*/
	protected boolean hasSuperImport() 
	{
		return false;
	}
	/**
		Return the name or null if none is found,
		Throw an ClassPathException containing detail if name is ambigous.
	*/
	protected String getClassNameByUnqName( String name ) 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	public void addListener( Listener l ) { }
	public void removeListener( Listener l ) { }
	public void dump( PrintWriter pw ) { 
		pw.println("BshClassManager: no class manager."); 
	}
	/**
		Flag the class name as being in the process of being defined.
		The class manager will not attempt to load it.
	*/
	/*
		Note: this implementation is temporary. We currently keep a flat
		namespace of the base name of classes.  i.e. BeanShell cannot be in the
		process of defining two classes in different packages with the same
		base name.  To remove this limitation requires that we work through
		namespace imports in an analogous (or using the same path) as regular
		class import resolution.  This workaround should handle most cases 
		so we'll try it for now.
	*/
	protected void definingClass( String className ) {
		String baseName = Name.suffix(className,1);
		int i = baseName.indexOf("$");
		if ( i != -1 )
			baseName = baseName.substring(i+1);
		String cur = definingClassesBaseNames.get( baseName );
		if ( cur != null )
			throw new InterpreterError("Defining class problem: "+className 
				+": BeanShell cannot yet simultaneously define two or more "
				+"dependant classes of the same name.  Attempt to define: "
				+ className +" while defining: "+cur 
			);
		definingClasses.add( className );
		definingClassesBaseNames.put( baseName, className );
	}
	protected boolean isClassBeingDefined( String className ) {
		return definingClasses.contains( className );
	}
	/**
		This method is a temporary workaround used with definingClass.
		It is to be removed at some point.
	*/
	public String getClassBeingDefined( String className ) {
		String baseName = Name.suffix(className,1);
		return definingClassesBaseNames.get( baseName );
	}
	/**
		Indicate that the specified class name has been defined and may be
		loaded normally.
	*/
	protected void doneDefiningClass( String className ) {
		String baseName = Name.suffix(className,1);
		definingClasses.remove( className );
		definingClassesBaseNames.remove( baseName );
	}
	/*
		The real implementation in the classpath.ClassManagerImpl handles
		reloading of the generated classes.
	*/
	public Class defineClass( String name, byte [] code ) 
	{
		throw new InterpreterError("Can't create class ("+name
			+") without class manager package.");
	/*
		Old implementation injected classes into the parent classloader.
		This was incorrect behavior for several reasons.  The biggest problem
		is that classes could therefore only be defined once across all
		executions of the script...  
		ClassLoader cl = this.getClass().getClassLoader();
		Class clas;
		try {
			clas = (Class)Reflect.invokeObjectMethod( 
				cl, "defineClass", 
				new Object [] { 
					name, code, 
					new Primitive( (int)0 )/offset/, 
					new Primitive( code.length )/len/ 
				}, 
				(Interpreter)null, (CallStack)null, (SimpleNode)null 
			);
		} catch ( Exception e ) {
			e.printStackTrace();
			throw new InterpreterError("Unable to define class: "+ e );
		}
		absoluteNonClasses.remove( name ); // may have been axed previously
		return clas;
	*/
	}
	protected void classLoaderChanged() { }
	protected static UtilEvalError cmUnavailable() {
		return new Capabilities.Unavailable(
			"ClassLoading features unavailable.");
	}
	public static interface Listener 
	{
		public void classLoaderChanged();
	}
	/**
		SignatureKey serves as a hash of a method signature on a class 
		for fast lookup of overloaded and general resolved Java methods. 
		<p>
	*/
	/*
		Note: is using SignatureKey in this way dangerous?  In the pathological
		case a user could eat up memory caching every possible combination of
		argument types to an untyped method.  Maybe we could be smarter about
		it by ignoring the types of untyped parameter positions?  The method
		resolver could return a set of "hints" for the signature key caching?
		There is also the overhead of creating one of these for every method
		dispatched.  What is the alternative?
	*/
	static class SignatureKey
	{
		Class clas;
		Class [] types;
		String methodName;
		int hashCode = 0;
		SignatureKey( Class clas, String methodName, Class [] types ) {
			this.clas = clas;
			this.methodName = methodName;
			this.types = types;
		}
		public int hashCode() 
		{ 
			if ( hashCode == 0 ) 
			{
				hashCode = clas.hashCode() * methodName.hashCode();
				if ( types == null ) // no args method
					return hashCode; 
				for( int i =0; i < types.length; i++ ) {
					int hc = types[i] == null ? 21 : types[i].hashCode();
					hashCode = hashCode*(i+1) + hc;
				}
			}
			return hashCode;
		}
		public boolean equals( Object o ) { 
			SignatureKey target = (SignatureKey)o;
			if ( types == null )
				return target.types == null;
			if ( clas != target.clas )
				return false;
			if ( !methodName.equals( target.methodName ) )
				return false;
			if ( types.length != target.types.length )
				return false;
			for( int i =0; i< types.length; i++ )
			{
				if ( types[i]==null ) 
				{
					if ( !(target.types[i]==null) )
						return false;
				} else 
					if ( !types[i].equals( target.types[i] ) )
						return false;
			}
			return true;
		}
	}
}
package bsh.classpath;
import java.net.*;
import java.util.*;
import java.io.*;
import bsh.BshClassManager;
/**
	One of the things BshClassLoader does is to address a deficiency in
	URLClassLoader that prevents us from specifying individual classes
	via URLs.
*/
public class BshClassLoader extends URLClassLoader 
{
	BshClassManager classManager;
	/**
		@param bases URLs JARClassLoader seems to require absolute paths 
	*/
	public BshClassLoader( BshClassManager classManager, URL [] bases ) {
		super( bases );
		this.classManager = classManager;
	}
	/**
		@param bases URLs JARClassLoader seems to require absolute paths 
	*/
	public BshClassLoader( BshClassManager classManager, BshClassPath bcp ) {
		this( classManager, bcp.getPathComponents() );
	}
	/**
		For use by children
		@param bases URLs JARClassLoader seems to require absolute paths 
	*/
	protected BshClassLoader( BshClassManager classManager ) { 
		this( classManager, new URL [] { } );
	}
	// public version of addURL
	public void addURL( URL url ) {
		super.addURL( url );
	}
	/**
		This modification allows us to reload classes which are in the 
		Java VM user classpath.  We search first rather than delegate to
		the parent classloader (or bootstrap path) first.
		An exception is for BeanShell core classes which are always loaded from
		the same classloader as the interpreter.
	*/
	// todo pejobo70 this could be one of the root causes for issue#34
	public Class loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
		if (name.startsWith("java.")) {
			return super.loadClass(name, resolve); // prevent SecurityException
		}
		/*
			Check first for classes loaded through this loader.
			The VM will not allow a class to be loaded twice.
		*/
		Class c = findLoadedClass(name);
		if ( c != null ) {
			return c;
		}
		// This is copied from ClassManagerImpl
		// We should refactor this somehow if it sticks around
		if ( name.startsWith( ClassManagerImpl.BSH_PACKAGE ) ) {
			try {
				return bsh.Interpreter.class.getClassLoader().loadClass( name );
			} catch ( ClassNotFoundException e ) {
				// ignore
			}
		}
		/*
			Try to find the class using our classloading mechanism.
		*/
		c = findClass( name );
		if ( resolve ) {
			resolveClass( c );
		}
		return c;
	}
	/**
		Find the correct source for the class...
		Try designated loader if any
		Try our URLClassLoader paths if any
		Try base loader if any
		Try system ???
	*/
	// add some caching for not found classes?
	protected Class findClass( String name ) 
		throws ClassNotFoundException 
	{
		// Deal with this cast somehow... maybe have this class use 
		// ClassManagerImpl type directly.
		// Don't add the method to BshClassManager... it's really an impl thing
		ClassManagerImpl bcm = (ClassManagerImpl)getClassManager();
		// Should we try to load the class ourselves or delegate?
		// look for overlay loader
		// Deal with this cast somehow... maybe have this class use 
		// ClassManagerImpl type directly.
		// Don't add the method to BshClassManager... it's really an impl thing
		ClassLoader cl = bcm.getLoaderForClass( name );
		Class c;
		// If there is a designated loader and it's not us delegate to it
		if ( cl != null && cl != this )
			try {
				return cl.loadClass( name );
			} catch ( ClassNotFoundException e ) {
				throw new ClassNotFoundException(
					"Designated loader could not find class: "+e );
			}
		// Let URLClassLoader try any paths it may have
		if ( getURLs().length > 0 )
			try {
				return super.findClass(name);
			} catch ( ClassNotFoundException e ) { 
				//System.out.println(
				//	"base loader here caught class not found: "+name );
			}
		// If there is a baseLoader and it's not us delegate to it
		cl = bcm.getBaseLoader();
		if ( cl != null && cl != this )
			try {
				return cl.loadClass( name );
			} catch ( ClassNotFoundException e ) { }
		// Try system loader
		return bcm.plainClassForName( name );
	}
	/*
		The superclass does something like this
        c = findLoadedClass(name);
        if null
            try
                if parent not null
                    c = parent.loadClass(name, false);
                else
                    c = findBootstrapClass(name);
            catch ClassNotFoundException 
                c = findClass(name);
	*/
	BshClassManager getClassManager() { return classManager; }
}
package	bsh;
public class BlockNameSpace extends NameSpace
{
    public BlockNameSpace( NameSpace parent ) 
		throws EvalError
	{
		super( parent, parent.getName()+ "/BlockNameSpace" );
    }
	/**
		Override the standard namespace behavior to make assignments
		happen in our parent (enclosing) namespace, unless the variable has
		already been assigned here via a typed declaration or through
		the special setBlockVariable() (used for untyped args in try/catch).
		<p>
		i.e. only allow typed var declaration to happen in this namespace.
		Typed vars are handled in the ordinary way local scope.  All untyped
		assignments are delegated to the enclosing context.
	*/
	/*
		Note: it may see like with the new 1.3 scoping this test could be
		removed, but it cannot.  When recurse is false we still need to set the
		variable in our parent, not here.
	*/
    public void	setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		if ( weHaveVar( name ) ) 
			// set the var here in the block namespace
			super.setVariable( name, value, strictJava, false );
		else
			// set the var in the enclosing (parent) namespace
			getParent().setVariable( name, value, strictJava, recurse );
    }
	/**
		Set an untyped variable in the block namespace.
		The BlockNameSpace would normally delegate this set to the parent.
		Typed variables are naturally set locally.
		This is used in try/catch block argument. 
	*/
    public void	setBlockVariable( String name, Object value ) 
		throws UtilEvalError 
	{
		super.setVariable( name, value, false/*strict?*/, false );
	}
	/**
		We have the variable: either it was declared here with a type, giving
		it block local scope or an untyped var was explicitly set here via
		setBlockVariable().
	*/
	private boolean weHaveVar( String name ) 
	{
		// super.variables.containsKey( name ) not any faster, I checked
		try {
			return super.getVariableImpl( name, false ) != null;
		} catch ( UtilEvalError e ) { return false; }
	}
/**
		Get the actual BlockNameSpace 'this' reference.
		<p/>
		Normally a 'this' reference to a BlockNameSpace (e.g. if () { } )
		resolves to the parent namespace (e.g. the namespace containing the
		"if" statement).  However when code inside the BlockNameSpace needs to
		resolve things relative to 'this' we must use the actual block's 'this'
		reference.  Name.java is smart enough to handle this using
		getBlockThis().
		@see #getThis( Interpreter )
    This getBlockThis( Interpreter declaringInterpreter ) 
	{
		return super.getThis( declaringInterpreter );
	}
*/
	//
	// Begin methods which simply delegate to our parent (enclosing scope) 
	//
	/**
		This method recurses to find the nearest non-BlockNameSpace parent.
	public NameSpace getParent() 
	{
		NameSpace parent = super.getParent();
		if ( parent instanceof BlockNameSpace )
			return parent.getParent();
		else
			return parent;
	}
*/
	/** do we need this? */
	private NameSpace getNonBlockParent() 
	{
		NameSpace parent = super.getParent();
		if ( parent instanceof BlockNameSpace )
			return ((BlockNameSpace)parent).getNonBlockParent();
		else
			return parent;
	}
	/**
		Get a 'this' reference is our parent's 'this' for the object closure.
		e.g. Normally a 'this' reference to a BlockNameSpace (e.g. if () { } )
		resolves to the parent namespace (e.g. the namespace containing the
		"if" statement). 
		@see #getBlockThis( Interpreter )
	*/
    public This getThis( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getThis( declaringInterpreter );
	}
	/**
		super is our parent's super
	*/
    public This getSuper( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getSuper( declaringInterpreter );
	}
	/**
		delegate import to our parent
	*/
    public void	importClass(String name) {
		getParent().importClass( name );
	}
	/**
		delegate import to our parent
	*/
    public void	importPackage(String name) {
		getParent().importPackage( name );
	}
    public void	setMethod(BshMethod method) 
		throws UtilEvalError
	{
		getParent().setMethod( method );
	}
}
package bsh.classpath;
import java.net.*;
import java.util.*;
import java.lang.ref.*;
import java.io.IOException;
import java.io.*;
import bsh.classpath.BshClassPath.ClassSource;
import bsh.classpath.BshClassPath.JarClassSource;
import bsh.classpath.BshClassPath.GeneratedClassSource;
import bsh.BshClassManager;
import bsh.ClassPathException;
import bsh.Interpreter;  // for debug()
import bsh.UtilEvalError; 
/**
	<pre>
	Manage all classloading in BeanShell.
	Allows classpath extension and class file reloading.
	This class holds the implementation of the BshClassManager so that it
	can be separated from the core package.
	This class currently relies on 1.2 for BshClassLoader and weak references.
	Is there a workaround for weak refs?  If so we could make this work
	with 1.1 by supplying our own classloader code...
	See "http://www.beanshell.org/manual/classloading.html" for details
	on the bsh classloader architecture.
	Bsh has a multi-tiered class loading architecture.  No class loader is
	created unless/until a class is generated, the classpath is modified, 
	or a class is reloaded.
	Note: we may need some synchronization in here
	Note on jdk1.2 dependency:
	We are forced to use weak references here to accomodate all of the 
	fleeting namespace listeners.  (NameSpaces must be informed if the class 
	space changes so that they can un-cache names).  I had the interesting 
	thought that a way around this would be to implement BeanShell's own 
	garbage collector...  Then I came to my senses and said - screw it, 
	class re-loading will require 1.2.
	---------------------
	Classloading precedence:
	in-script evaluated class (scripted class)
	in-script added / modified classpath
	optionally, external classloader
	optionally, thread context classloader
	plain Class.forName()
	source class (.java file in classpath)
	</pre>
*/
public class ClassManagerImpl extends BshClassManager
{
	static final String BSH_PACKAGE = "bsh";
	/**
		The classpath of the base loader.  Initially and upon reset() this is
		an empty instance of BshClassPath.  It grows as paths are added or is
		reset when the classpath is explicitly set.  This could also be called
		the "extension" class path, but is not strictly confined to added path
		(could be set arbitrarily by setClassPath())
	*/
	private BshClassPath baseClassPath;
	private boolean superImport;
	/**
		This is the full blown classpath including baseClassPath (extensions),
		user path, and java bootstrap path (rt.jar)
		This is lazily constructed and further (and more importantly) lazily
		intialized in components because mapping the full path could be
		expensive.
		The full class path is a composite of:
			baseClassPath (user extension) : userClassPath : bootClassPath
		in that order.
	*/
	private BshClassPath fullClassPath;
	// ClassPath Change listeners
	private Vector listeners = new Vector();
	private ReferenceQueue refQueue = new ReferenceQueue();
	/**
		This handles extension / modification of the base classpath
		The loader to use where no mapping of reloaded classes exists.
		The baseLoader is initially null meaning no class loader is used.
	*/
	private BshClassLoader baseLoader;
	/**
		Map by classname of loaders to use for reloaded classes
	*/
	private Map loaderMap;
	/**
		Used by BshClassManager singleton constructor
	*/
	public ClassManagerImpl() {
		reset();
	}
	/**
		@return the class or null
	*/
	@Override
	public Class classForName( String name )
	{
		// check positive cache
		Class c = (Class)absoluteClassCache.get(name);
		if (c != null )
			return c;
		// check negative cache
		if ( absoluteNonClasses.contains(name) ) {
			if ( Interpreter.DEBUG ) Interpreter.debug("absoluteNonClass list hit: "+name);
			return null;
		}
		if ( Interpreter.DEBUG ) Interpreter.debug("Trying to load class: "+name);
		// Check explicitly mapped (reloaded) class...
		final ClassLoader overlayLoader = getLoaderForClass( name );
		if ( overlayLoader != null ) {
			try {
				c = overlayLoader.loadClass(name);
			} catch ( Exception e ) {
				if ( Interpreter.DEBUG ) Interpreter.debug("overlay loader failed for '" + name + "' - " + e);
			}
			// Should be there since it was explicitly mapped
			// throw an error if c == null)?
		}
		// insure that core classes are loaded from the same loader
		if ((c == null) && name.startsWith(BSH_PACKAGE)) {
			final ClassLoader myClassLoader = Interpreter.class.getClassLoader(); // is null if located in bootclasspath
			if (myClassLoader != null) {
				try {
					c = myClassLoader.loadClass(name);
				} catch (ClassNotFoundException e) {
					// fall through
				} catch (NoClassDefFoundError e) {
					// fall through
				}
			} else {
				try {
					c = Class.forName( name );
				} catch ( ClassNotFoundException e ) {
					// fall through
				} catch ( NoClassDefFoundError e ) {
					// fall through
				}
			}
		}
		// Check classpath extension / reloaded classes
		if ((c == null) && (baseLoader != null)) {
			try {
				c = baseLoader.loadClass(name);
			} catch (ClassNotFoundException e) {
				// fall through
			}
		}
		// Optionally try external classloader
		if ((c == null) && (externalClassLoader != null)) {
			try {
				c = externalClassLoader.loadClass(name);
			} catch (ClassNotFoundException e) {
				// fall through					
			}
		}
		// Optionally try context classloader
		// Note that this might be a security violation
		// is catching the SecurityException sufficient for all environments?
		// or do we need a way to turn this off completely?
		if ( c ==  null ) {
			try {
				final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
				if ( contextClassLoader != null ) {
					c = Class.forName( name, true, contextClassLoader );
				}
			} catch ( ClassNotFoundException e ) { 
				// fall through
			} catch ( NoClassDefFoundError e ) { 
				// fall through
			} catch ( SecurityException e ) { 
				// fall through
			} 
		}
		// try plain class forName()
		if ( c == null )
			try {
				c = Class.forName( name );
			} catch ( ClassNotFoundException e ) {
				// fall through
/* I disagree with letting this fall through  -fschmidt
			} catch ( NoClassDefFoundError e ) {
				// fall through
*/
			}
		// Cache result (or null for not found)
		cacheClassInfo( name, c );
		return c;
	}
	/**
		Get a resource URL using the BeanShell classpath
		@param path should be an absolute path
	*/
	@Override
	public URL getResource( String path )
	{
		URL url = null;
		if ( baseLoader != null )
			// classloader wants no leading slash
			url = baseLoader.getResource( path.substring(1) );
		if ( url == null )
			url = super.getResource( path );
		return url;
	}
	/**
		Get a resource stream using the BeanShell classpath
		@param path should be an absolute path
	*/
	@Override
	public InputStream getResourceAsStream( String path )
	{
		InputStream in = null;
		if ( baseLoader != null )
		{
			// classloader wants no leading slash
			in = baseLoader.getResourceAsStream( path.substring(1) );
		}
		if ( in == null )
		{
			in = super.getResourceAsStream( path );
		}
		return in;
	}
	ClassLoader getLoaderForClass( String name ) {
		return (ClassLoader)loaderMap.get( name );
	}
	// Classpath mutators
	/**
	*/
	@Override
	public void addClassPath( URL path )
		throws IOException 
	{
		if ( baseLoader == null )
			setClassPath( new URL [] { path } );
		else {
			// opportunity here for listener in classpath
			baseLoader.addURL( path );
			baseClassPath.add( path );
			classLoaderChanged();
		}
	}
	/**
		Clear all classloading behavior and class caches and reset to 
		initial state.
	*/
	@Override
	public void reset()
	{
		baseClassPath = new BshClassPath("baseClassPath");
		baseLoader = null;
		loaderMap = new HashMap();
		classLoaderChanged(); // calls clearCaches() for us.
	}
	/**
		Set a new base classpath and create a new base classloader.
		This means all types change. 
	*/
	@Override
	public void setClassPath( URL [] cp ) {
		baseClassPath.setPath( cp );
		initBaseLoader();
		loaderMap = new HashMap();
		classLoaderChanged();
	}
	/**
		Overlay the entire path with a new class loader.
		Set the base path to the user path + base path.
		No point in including the boot class path (can't reload thos).
	*/
	@Override
	public void reloadAllClasses() throws ClassPathException
	{
		BshClassPath bcp = new BshClassPath("temp");
		bcp.addComponent( baseClassPath );
		bcp.addComponent( BshClassPath.getUserClassPath() );
		setClassPath( bcp.getPathComponents() );
	}
	/**
		init the baseLoader from the baseClassPath
	*/
	private void initBaseLoader() {
		baseLoader = new BshClassLoader( this, baseClassPath );
	}
	// class reloading
	/**
		Reloading classes means creating a new classloader and using it
		whenever we are asked for classes in the appropriate space.
		For this we use a DiscreteFilesClassLoader
	*/
	@Override
	public void reloadClasses( String [] classNames )
		throws ClassPathException
	{
		// validate that it is a class here?
		// init base class loader if there is none...
		if ( baseLoader == null )
			initBaseLoader();
		DiscreteFilesClassLoader.ClassSourceMap map = 
			new DiscreteFilesClassLoader.ClassSourceMap();
		for (int i=0; i< classNames.length; i++) {
			String name = classNames[i];
			// look in baseLoader class path 
			ClassSource classSource = baseClassPath.getClassSource( name );
			// look in user class path 
			if ( classSource == null ) {
				BshClassPath.getUserClassPath().insureInitialized();
				classSource = BshClassPath.getUserClassPath().getClassSource( 
					name );
			}
			// No point in checking boot class path, can't reload those.
			// else we could have used fullClassPath above.
				
			if ( classSource == null )
				throw new ClassPathException("Nothing known about class: "
					+name );
			// JarClassSource is not working... just need to implement it's
			// getCode() method or, if we decide to, allow the BshClassManager
			// to handle it... since it is a URLClassLoader and can handle JARs
			if ( classSource instanceof JarClassSource )
				throw new ClassPathException("Cannot reload class: "+name+
					" from source: "+ classSource );
			map.put( name, classSource );
		}
		// Create classloader for the set of classes
		ClassLoader cl = new DiscreteFilesClassLoader( this, map );
		// map those classes the loader in the overlay map
		Iterator it = map.keySet().iterator();
		while ( it.hasNext() )
			loaderMap.put( (String)it.next(), cl );
		classLoaderChanged();
	}
	/**
		Reload all classes in the specified package: e.g. "com.sun.tools"
		The special package name "<unpackaged>" can be used to refer 
		to unpackaged classes.
	*/
	@Override
	public void reloadPackage( String pack )
		throws ClassPathException 
	{
		Collection classes = 
			baseClassPath.getClassesForPackage( pack );
		if ( classes == null )
			classes = 
				BshClassPath.getUserClassPath().getClassesForPackage( pack );
		// no point in checking boot class path, can't reload those
		if ( classes == null )
			throw new ClassPathException("No classes found for package: "+pack);
		reloadClasses( (String[])classes.toArray( new String[0] ) );
	}
	/**
		Unimplemented
		For this we'd have to store a map by location as well as name...
	public void reloadPathComponent( URL pc ) throws ClassPathException {
		throw new ClassPathException("Unimplemented!");
	}
	*/
	// end reloading
	/**
		Get the full blown classpath.
	*/
	public BshClassPath getClassPath() throws ClassPathException
	{
		if ( fullClassPath != null )
			return fullClassPath;
	
		fullClassPath = new BshClassPath("BeanShell Full Class Path");
		fullClassPath.addComponent( BshClassPath.getUserClassPath() );
		try {
			fullClassPath.addComponent( BshClassPath.getBootClassPath() );
		} catch ( ClassPathException e ) { 
			System.err.println("Warning: can't get boot class path");
		}
		fullClassPath.addComponent( baseClassPath );
		return fullClassPath;
	}
	/**
		Support for "import *;"
		Hide details in here as opposed to NameSpace.
	*/
	@Override
	public void doSuperImport()
		throws UtilEvalError
	{
		// Should we prevent it from happening twice?
		try {
			getClassPath().insureInitialized();
			// prime the lookup table
			getClassNameByUnqName( "" ) ;
			// always true now
			//getClassPath().setNameCompletionIncludeUnqNames(true);
		} catch ( ClassPathException e ) {
			throw new UtilEvalError("Error importing classpath "+ e );
		}
		superImport = true;
	}
	@Override
	protected boolean hasSuperImport() { return superImport; }
	/**
		Return the name or null if none is found,
		Throw an ClassPathException containing detail if name is ambigous.
	*/
	@Override
	public String getClassNameByUnqName( String name )
		throws ClassPathException
	{
		return getClassPath().getClassNameByUnqName( name );
	}
	@Override
	public void addListener( Listener l ) {
		listeners.addElement( new WeakReference( l, refQueue) );
		// clean up old listeners
		Reference deadref;
		while ( (deadref = refQueue.poll()) != null ) {
			boolean ok = listeners.removeElement( deadref );
			if ( ok ) {
				//System.err.println("cleaned up weak ref: "+deadref);
			} else {
				if ( Interpreter.DEBUG ) Interpreter.debug(
					"tried to remove non-existent weak ref: "+deadref);
			}
		}
	}
	@Override
	public void removeListener( Listener l ) {
		throw new Error("unimplemented");
	}
	public ClassLoader getBaseLoader() {
		return baseLoader;
	}
	/**
		Get the BeanShell classloader.
	public ClassLoader getClassLoader() {
	}
	*/
	/*
		Impl Notes:
		We add the bytecode source and the "reload" the class, which causes the
		BshClassLoader to be initialized and create a DiscreteFilesClassLoader
		for the bytecode.
		@exception ClassPathException can be thrown by reloadClasses
	*/
	@Override
	public Class defineClass( String name, byte [] code )
	{
		baseClassPath.setClassSource( name, new GeneratedClassSource( code ) );
		try {
			reloadClasses( new String [] { name } );
		} catch ( ClassPathException e ) {
			throw new bsh.InterpreterError("defineClass: "+e);
		}
		return classForName( name );
	}
	/**
		Clear global class cache and notify namespaces to clear their 
		class caches.
		The listener list is implemented with weak references so that we 
		will not keep every namespace in existence forever.
	*/
	@Override
	protected void classLoaderChanged()
	{
		// clear the static caches in BshClassManager
		clearCaches();
		Vector toRemove = new Vector(); // safely remove
		for ( Enumeration e = listeners.elements(); e.hasMoreElements(); ) 
		{
			WeakReference wr = (WeakReference)e.nextElement();
			Listener l = (Listener)wr.get();
			if ( l == null )  // garbage collected
			  toRemove.add( wr );
			else
			  l.classLoaderChanged();
		}
		for( Enumeration e = toRemove.elements(); e.hasMoreElements(); ) 
			listeners.removeElement( e.nextElement() );
	}
	@Override
	public void dump( PrintWriter i )
	{
		i.println("Bsh Class Manager Dump: ");
		i.println("----------------------- ");
		i.println("baseLoader = "+baseLoader);
		i.println("loaderMap= "+loaderMap);
		i.println("----------------------- ");
		i.println("baseClassPath = "+baseClassPath);
	}
}
package bsh;
import bsh.ast.Node;
class JJTParserState {
  private java.util.Stack nodes;
  private java.util.Stack marks;
  private int sp;		// number of nodes on stack
  private int mk;		// current mark
  private boolean node_created;
  JJTParserState() {
    nodes = new java.util.Stack();
    marks = new java.util.Stack();
    sp = 0;
    mk = 0;
  }
  /* Determines whether the current node was actually closed and
     pushed.  This should only be called in the final user action of a
     node scope.  */
  boolean nodeCreated() {
    return node_created;
  }
  /* Call this to reinitialize the node stack.  It is called
     automatically by the parser's ReInit() method. */
  void reset() {
    nodes.removeAllElements();
    marks.removeAllElements();
    sp = 0;
    mk = 0;
  }
  /* Returns the root node of the AST.  It only makes sense to call
     this after a successful parse. */
  Node rootNode() {
    return (Node)nodes.elementAt(0);
  }
  /* Pushes a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
    ++sp;
  }
  /* Returns the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    if (--sp < mk) {
      mk = ((Integer)marks.pop()).intValue();
    }
    return (Node)nodes.pop();
  }
  /* Returns the node currently on the top of the stack. */
  Node peekNode() {
    return (Node)nodes.peek();
  }
  /* Returns the number of children on the stack in the current node
     scope. */
  int nodeArity() {
    return sp - mk;
  }
  void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = ((Integer)marks.pop()).intValue();
  }
  void openNodeScope(Node n) {
    marks.push(new Integer(mk));
    mk = sp;
    n.jjtOpen();
  }
  /* A definite node is constructed from a specified number of
     children.  That number of nodes are popped from the stack and
     made the children of the definite node.  Then the definite node
     is pushed on to the stack. */
  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }
  /* A conditional node is constructed if its condition is true.  All
     the nodes that have been pushed since the node was opened are
     made children of the the conditional node, which is then pushed
     on to the stack.  If the condition is false the node is not
     constructed and they are left on the stack. */
  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }
}
import java.io.*;
import java.util.Vector;
import bsh.ast.*;
/**
	This is the BeanShell parser.  It is used internally by the Interpreter
	class (which is probably what you are looking for).  The parser knows
	only how to parse the structure of the language, it does not understand
	names, commands, etc.
	<p>
	You can use the Parser from the command line to do basic structural 
	validation of BeanShell files without actually executing them. e.g.
	<code><pre>
		java bsh.Parser [ -p ] file [ file ] [ ... ]
	</pre></code>
	<p>
	The -p option causes the abstract syntax to be printed.
	<p>
	From code you'd use the Parser like this:
	<p
	<code><pre>
		Parser parser = new Parser(in);
		while( !(eof=parser.Line()) ) {
			SimpleNode node = parser.popNode();
			// use the node, etc. (See bsh.BSH* classes)
		}
	</pre></code>
*/
public class Parser/*@bgen(jjtree)*/implements ParserTreeConstants, ParserConstants {/*@bgen(jjtree)*/
  protected JJTParserState jjtree = new JJTParserState();boolean retainComments = false;
        public void setRetainComments( boolean b ) {
                retainComments = b;
        }
        void jjtreeOpenNodeScope(Node n) {
                ((SimpleNode)n).firstToken = getToken(1);
        }
        void jjtreeCloseNodeScope(Node n) {
                ((SimpleNode)n).lastToken = getToken(0);
        }
        /**
		Re-initialize the input stream and token source.
	*/
        void reInitInput( Reader in ) {
                ReInit(in);
        }
        public SimpleNode popNode()
        {
                if ( jjtree.nodeArity() > 0)  // number of child nodes 
                        return (SimpleNode)jjtree.popNode();
                else
                        return null;
        }
        /**
		Explicitly re-initialize just the token reader.
		This seems to be necessary to avoid certain looping errors when
		reading bogus input.  See Interpreter.
	*/
        void reInitTokenInput( Reader in ) {
                jj_input_stream.ReInit( in,
                        jj_input_stream.getEndLine(),
                        jj_input_stream.getEndColumn() );
        }
        public static void main( String [] args )
                throws IOException, ParseException
        {
                boolean print = false;
                int i=0;
                if ( args[0].equals("-p") ) {
                        i++;
                        print=true;
                }
                for(; i< args.length; i++) {
                        Reader in = new FileReader(args[i]);
                        Parser parser = new Parser(in);
                        parser.setRetainComments(true);
                        while( !parser.Line()/*eof*/ )
                                if ( print )
                                        System.out.println( parser.popNode() );
                }
        }
        /**
		Lookahead for the enhanced for statement.  
		Expect "for" "(" and then see whether we hit ":" or a ";" first.
	*/
        boolean isRegularForStatement()
        {
                int curTok = 1;
                Token tok;
                tok = getToken(curTok++);
                if ( tok.kind != FOR ) return false;
                tok = getToken(curTok++);
                if ( tok.kind != LPAREN ) return false;
                while (true)
                {
                        tok = getToken(curTok++);
                        switch (tok.kind) {
                                case COLON:
                                        return false;
                                case SEMICOLON:
                                        return true;
                                case EOF:
                                        return false;
                        }
                }
        }
        /**
		Generate a ParseException with the specified message, pointing to the
		current token.
		The auto-generated Parser.generateParseException() method does not
		provide line number info, therefore we do this.
	*/
        ParseException createParseException( String message, Exception e )
        {
                Token errortok = token;
                int line = errortok.beginLine, column = errortok.beginColumn;
                String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
                return new ParseException( "Parse error at line " + line
                        + ", column " + column + " : " + message + "\u005cn" +  e );
        }
        int parseInt(String s) throws NumberFormatException {
                int radix;
                int i;
                if( s.startsWith("0x") || s.startsWith("0X") ) {
                        radix = 16;
                        i = 2;
                } else if( s.startsWith("0") && s.length() > 1 ) {
                        radix = 8;
                        i = 1;
                } else {
                        radix = 10;
                        i = 0;
                }
                int result = 0;
                int len = s.length();
                for( ; i<len; i++ ) {
                        if( result < 0 )
                                throw new NumberFormatException("Number too big for integer type: "+s);
                        result *= radix;
                        int digit = Character.digit(s.charAt(i),radix);
                        if( digit < 0 )
                                throw new NumberFormatException("Invalid integer type: "+s);
                        result += digit;
                }
                return result;
        }
        long parseLong(String s) throws NumberFormatException {
                int radix;
                int i;
                if( s.startsWith("0x") || s.startsWith("0X") ) {
                        radix = 16;
                        i = 2;
                } else if( s.startsWith("0") && s.length() > 1 ) {
                        radix = 8;
                        i = 1;
                } else {
                        radix = 10;
                        i = 0;
                }
                long result = 0;
                int len = s.length();
                for( ; i<len; i++ ) {
                        if( result < 0L )
                                throw new NumberFormatException("Number too big for long type: "+s);
                        result *= radix;
                        int digit = Character.digit(s.charAt(i),radix);
                        if( digit < 0 )
                                throw new NumberFormatException("Invalid long type: "+s);
                        result += digit;
                }
                return result;
        }
/*
	Thanks to Sreenivasa Viswanadha for suggesting how to get rid of expensive
	lookahead here.
*/
  final public boolean Line() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
        Interpreter.debug("End of File!");
        {if (true) return true;}
      break;
    default:
      if (jj_2_1(1)) {
        BlockStatement();
        {if (true) return false;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }
/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/
/*
	Gather modifiers for a class, method, or field.
	I lookahead is true then we are being called as part of a lookahead and we
	should not enforce any rules.  Otherwise we validate based on context
	(field, method, class)
*/
  final public Modifiers Modifiers(int context, boolean lookahead) throws ParseException {
        Modifiers mods = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
        ;
        break;
      default:
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
        jj_consume_token(PRIVATE);
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        break;
      case SYNCHRONIZED:
        jj_consume_token(SYNCHRONIZED);
        break;
      case FINAL:
        jj_consume_token(FINAL);
        break;
      case NATIVE:
        jj_consume_token(NATIVE);
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
        break;
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
        break;
      case STATIC:
        jj_consume_token(STATIC);
        break;
      case STRICTFP:
        jj_consume_token(STRICTFP);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                if ( !lookahead )
                        try {
                                if ( mods == null ) mods = new Modifiers();
                                mods.addModifier( context, getToken(0).image );
                        } catch ( IllegalStateException e ) {
                                {if (true) throw createParseException( e.getMessage(), e );}
                        }
    }
        {if (true) return mods;}
    throw new Error("Missing return statement in function");
  }
/**
*/
  final public void ClassDeclaration() throws ParseException {
 /*@bgen(jjtree) ClassDeclaration */
        BSHClassDeclaration jjtn000 = new BSHClassDeclaration(JJTCLASSDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Modifiers mods;
        Token name;
        int numInterfaces;
    try {
      mods = Modifiers(Modifiers.CLASS, false);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        jj_consume_token(CLASS);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
                                  jjtn000.isInterface=true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      name = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        jj_consume_token(EXTENDS);
        AmbiguousName();
                                      jjtn000.extend = true;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLEMENTS:
        jj_consume_token(IMPLEMENTS);
        numInterfaces = NameList();
                  jjtn000.numInterfaces=numInterfaces;
        break;
      default:
        ;
      }
      Block();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.modifiers = mods;
                jjtn000.name = name.image;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void MethodDeclaration() throws ParseException {
 /*@bgen(jjtree) MethodDeclaration */
        BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
        Modifiers mods;
        int count;
    try {
      mods = Modifiers(Modifiers.METHOD, false);
                                                      jjtn000.modifiers = mods;
      if (jj_2_2(2147483647)) {
        t = jj_consume_token(IDENTIFIER);
                           jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case VOID:
        case IDENTIFIER:
          ReturnType();
          t = jj_consume_token(IDENTIFIER);
                           jjtn000.name = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      FormalParameters();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        count = NameList();
                                      jjtn000.numThrows=count;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void PackageDeclaration() throws ParseException {
 /*@bgen(jjtree) PackageDeclaration */
  BSHPackageDeclaration jjtn000 = new BSHPackageDeclaration(JJTPACKAGEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(PACKAGE);
      AmbiguousName();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void ImportDeclaration() throws ParseException {
 /*@bgen(jjtree) ImportDeclaration */
    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token s = null;
        Token t = null;
    try {
      if (jj_2_3(3)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STATIC:
          s = jj_consume_token(STATIC);
          break;
        default:
          ;
        }
        jj_consume_token(IMPORT);
        AmbiguousName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          t = jj_consume_token(DOT);
          jj_consume_token(STAR);
          break;
        default:
          ;
        }
        jj_consume_token(SEMICOLON);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
                if ( s != null ) jjtn000.staticImport = true;
                if ( t != null ) jjtn000.importPackage = true;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORT:
          jj_consume_token(IMPORT);
          jj_consume_token(STAR);
          jj_consume_token(SEMICOLON);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtreeCloseNodeScope(jjtn000);
                jjtn000.superImport = true;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void VariableDeclarator() throws ParseException {
 /*@bgen(jjtree) VariableDeclarator */
        BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        VariableInitializer();
        break;
      default:
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.name = t.image;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
/*
this originally handled postfix array dimensions...
void VariableDeclaratorId() #VariableDeclaratorId :
{ Token t; }
{
  t=<IDENTIFIER> { jjtThis.name = t.image; }
  ( "[" "]" { jjtThis.addUndefinedDimension(); } )*
}
*/
  final public void VariableInitializer() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ArrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LONG_STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      Expression();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }
  final public void ArrayInitializer() throws ParseException {
 /*@bgen(jjtree) ArrayInitializer */
  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        VariableInitializer();
        label_2:
        while (true) {
          if (jj_2_4(2)) {
            ;
          } else {
            break label_2;
          }
          jj_consume_token(COMMA);
          VariableInitializer();
        }
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        ;
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void FormalParameters() throws ParseException {
 /*@bgen(jjtree) FormalParameters */
  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        FormalParameter();
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            break label_3;
          }
          jj_consume_token(COMMA);
          FormalParameter();
        }
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void FormalParameter() throws ParseException {
 /*@bgen(jjtree) FormalParameter */
  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      if (jj_2_5(2)) {
        Type();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          TypeArguments();
          break;
        default:
          ;
        }
        t = jj_consume_token(IDENTIFIER);
                                                           jjtree.closeNodeScope(jjtn000, true);
                                                           jjtc000 = false;
                                                           jjtreeCloseNodeScope(jjtn000);
                                                           jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtreeCloseNodeScope(jjtn000);
                   jjtn000.name = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Type, name and expression syntax follows.
*/
  final public void Type() throws ParseException {
 /*@bgen(jjtree) Type */
  BSHType jjtn000 = new BSHType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        PrimitiveType();
        break;
      case IDENTIFIER:
        AmbiguousName();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_4:
      while (true) {
        if (jj_2_6(2)) {
          ;
        } else {
          break label_4;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                                 jjtn000.addArrayDimension();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Originally called ResultType in the grammar
*/
  final public void ReturnType() throws ParseException {
 /*@bgen(jjtree) ReturnType */
  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        jj_consume_token(VOID);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.isVoid = true;
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        Type();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          TypeArguments();
          break;
        default:
          ;
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void PrimitiveType() throws ParseException {
 /*@bgen(jjtree) PrimitiveType */
  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              jjtreeCloseNodeScope(jjtn000);
              jjtn000.type = Boolean.TYPE;
        break;
      case CHAR:
        jj_consume_token(CHAR);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Character.TYPE;
        break;
      case BYTE:
        jj_consume_token(BYTE);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Byte.TYPE;
        break;
      case SHORT:
        jj_consume_token(SHORT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Short.TYPE;
        break;
      case INT:
        jj_consume_token(INT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.type =  Integer.TYPE;
        break;
      case LONG:
        jj_consume_token(LONG);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Long.TYPE;
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Float.TYPE;
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.type =  Double.TYPE;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void AmbiguousName() throws ParseException {
 /*@bgen(jjtree) AmbiguousName */
    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t;
    StringBuilder s;
    try {
      t = jj_consume_token(IDENTIFIER);
        s = new StringBuilder(t.image);
      label_5:
      while (true) {
        if (jj_2_7(2)) {
          ;
        } else {
          break label_5;
        }
        jj_consume_token(DOT);
        t = jj_consume_token(IDENTIFIER);
                                        s.append("."+t.image);
      }
                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                      jjtc000 = false;
                                                                      jjtreeCloseNodeScope(jjtn000);
        jjtn000.text = s.toString();
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public int NameList() throws ParseException {
  int count = 0;
    AmbiguousName();
                    ++count;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_6;
      }
      jj_consume_token(COMMA);
      AmbiguousName();
                                                       ++count;
    }
    {if (true) return count;}
    throw new Error("Missing return statement in function");
  }
/*
 * Expression syntax follows.
 */
  final public void Expression() throws ParseException {
    if (jj_2_8(2147483647)) {
      Assignment();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ConditionalExpression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void Assignment() throws ParseException {
 /*@bgen(jjtree) Assignment */
  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);int op ;
    try {
      PrimaryExpression();
      op = AssignmentOperator();
                                    jjtn000.operator = op;
      Expression();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public int AssignmentOperator() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      break;
    case STARASSIGN:
      jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      jj_consume_token(SLASHASSIGN);
      break;
    case MODASSIGN:
      jj_consume_token(MODASSIGN);
      break;
    case PLUSASSIGN:
      jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      jj_consume_token(MINUSASSIGN);
      break;
    case ANDASSIGN:
      jj_consume_token(ANDASSIGN);
      break;
    case XORASSIGN:
      jj_consume_token(XORASSIGN);
      break;
    case ORASSIGN:
      jj_consume_token(ORASSIGN);
      break;
    case LSHIFTASSIGN:
      jj_consume_token(LSHIFTASSIGN);
      break;
    case LSHIFTASSIGNX:
      jj_consume_token(LSHIFTASSIGNX);
      break;
    case RSIGNEDSHIFTASSIGN:
      jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGNX:
      jj_consume_token(RSIGNEDSHIFTASSIGNX);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGNX:
      jj_consume_token(RUNSIGNEDSHIFTASSIGNX);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        t = getToken(0);
        {if (true) return t.kind;}
    throw new Error("Missing return statement in function");
  }
  final public void ConditionalExpression() throws ParseException {
    ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      jj_consume_token(HOOK);
      Expression();
      jj_consume_token(COLON);
                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
        ConditionalExpression();
      } catch (Throwable jjte001) {
                                                     if (jjtc001) {
                                                       jjtree.clearNodeScope(jjtn001);
                                                       jjtc001 = false;
                                                     } else {
                                                       jjtree.popNode();
                                                     }
                                                     if (jjte001 instanceof RuntimeException) {
                                                       {if (true) throw (RuntimeException)jjte001;}
                                                     }
                                                     if (jjte001 instanceof ParseException) {
                                                       {if (true) throw (ParseException)jjte001;}
                                                     }
                                                     {if (true) throw (Error)jjte001;}
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  3);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
      break;
    default:
      ;
    }
  }
  final public void ConditionalOrExpression() throws ParseException {
  Token t=null;
    ConditionalAndExpression();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
      case BOOL_ORX:
        ;
        break;
      default:
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
        t = jj_consume_token(BOOL_OR);
        break;
      case BOOL_ORX:
        t = jj_consume_token(BOOL_ORX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ConditionalAndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void ConditionalAndExpression() throws ParseException {
  Token t=null;
    InclusiveOrExpression();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
      case BOOL_ANDX:
        ;
        break;
      default:
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
        t = jj_consume_token(BOOL_AND);
        break;
      case BOOL_ANDX:
        t = jj_consume_token(BOOL_ANDX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      InclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void InclusiveOrExpression() throws ParseException {
  Token t=null;
    ExclusiveOrExpression();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
      case BIT_ORX:
        ;
        break;
      default:
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_ORX:
        t = jj_consume_token(BIT_ORX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ExclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void ExclusiveOrExpression() throws ParseException {
  Token t=null;
    AndExpression();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        break label_10;
      }
      t = jj_consume_token(XOR);
      AndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void AndExpression() throws ParseException {
  Token t=null;
    EqualityExpression();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
      case BIT_ANDX:
        ;
        break;
      default:
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        t = jj_consume_token(BIT_AND);
        break;
      case BIT_ANDX:
        t = jj_consume_token(BIT_ANDX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      EqualityExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void EqualityExpression() throws ParseException {
  Token t = null;
    InstanceOfExpression();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NE:
        t = jj_consume_token(NE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      InstanceOfExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void InstanceOfExpression() throws ParseException {
  Token t = null;
    RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      t = jj_consume_token(INSTANCEOF);
      Type();
                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                              jjtreeOpenNodeScope(jjtn001);
      try {
                              jjtree.closeNodeScope(jjtn001,  2);
                              jjtc001 = false;
                              jjtreeCloseNodeScope(jjtn001);
                              jjtn001.kind = t.kind;
      } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                                jjtreeCloseNodeScope(jjtn001);
                              }
      }
      break;
    default:
      ;
    }
  }
  final public void RelationalExpression() throws ParseException {
  Token t = null;
    ShiftExpression();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case GTX:
      case LT:
      case LTX:
      case LE:
      case LEX:
      case GE:
      case GEX:
        ;
        break;
      default:
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        t = jj_consume_token(LT);
        break;
      case LTX:
        t = jj_consume_token(LTX);
        break;
      case GT:
        t = jj_consume_token(GT);
        break;
      case GTX:
        t = jj_consume_token(GTX);
        break;
      case LE:
        t = jj_consume_token(LE);
        break;
      case LEX:
        t = jj_consume_token(LEX);
        break;
      case GE:
        t = jj_consume_token(GE);
        break;
      case GEX:
        t = jj_consume_token(GEX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ShiftExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }
  final public void ShiftExpression() throws ParseException {
  Token t = null;
    AdditiveExpression();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
      case LSHIFTX:
      case RSIGNEDSHIFT:
      case RSIGNEDSHIFTX:
      case RUNSIGNEDSHIFT:
      case RUNSIGNEDSHIFTX:
        ;
        break;
      default:
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        t = jj_consume_token(LSHIFT);
        break;
      case LSHIFTX:
        t = jj_consume_token(LSHIFTX);
        break;
      case RSIGNEDSHIFT:
        t = jj_consume_token(RSIGNEDSHIFT);
        break;
      case RSIGNEDSHIFTX:
        t = jj_consume_token(RSIGNEDSHIFTX);
        break;
      case RUNSIGNEDSHIFT:
        t = jj_consume_token(RUNSIGNEDSHIFT);
        break;
      case RUNSIGNEDSHIFTX:
        t = jj_consume_token(RUNSIGNEDSHIFTX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      AdditiveExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }
  final public void AdditiveExpression() throws ParseException {
  Token t = null;
    MultiplicativeExpression();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        break label_15;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      MultiplicativeExpression();
                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
                                                     jjtree.closeNodeScope(jjtn001,  2);
                                                     jjtc001 = false;
                                                     jjtreeCloseNodeScope(jjtn001);
                                                     jjtn001.kind = t.kind;
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  2);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
    }
  }
  final public void MultiplicativeExpression() throws ParseException {
  Token t = null;
    UnaryExpression();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case MOD:
        ;
        break;
      default:
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        t = jj_consume_token(STAR);
        break;
      case SLASH:
        t = jj_consume_token(SLASH);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                      jjtreeOpenNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  2);
                      jjtc001 = false;
                      jjtreeCloseNodeScope(jjtn001);
                      jjtn001.kind = t.kind;
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                        jjtreeCloseNodeScope(jjtn001);
                      }
      }
    }
  }
  final public void UnaryExpression() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    case INCR:
      PreIncrementExpression();
      break;
    case DECR:
      PreDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LONG_STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
      UnaryExpressionNotPlusMinus();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }
  final public void PreIncrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(INCR);
    PrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }
  final public void PreDecrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(DECR);
    PrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }
  final public void UnaryExpressionNotPlusMinus() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        t = jj_consume_token(TILDE);
        break;
      case BANG:
        t = jj_consume_token(BANG);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    default:
      if (jj_2_9(2147483647)) {
        CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LONG_STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
          PostfixExpression();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
// This production is to determine lookahead only.
  final public void CastLookahead() throws ParseException {
    if (jj_2_10(2)) {
      jj_consume_token(LPAREN);
      PrimitiveType();
    } else if (jj_2_11(2147483647)) {
      jj_consume_token(LPAREN);
      AmbiguousName();
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        AmbiguousName();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          jj_consume_token(TILDE);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        case FALSE:
        case NULL:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LONG_STRING_LITERAL:
          Literal();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void PostfixExpression() throws ParseException {
  Token t = null;
    if (jj_2_12(2147483647)) {
      PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        t = jj_consume_token(INCR);
        break;
      case DECR:
        t = jj_consume_token(DECR);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                                BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                                jjtreeOpenNodeScope(jjtn001);
      try {
                                jjtree.closeNodeScope(jjtn001,  1);
                                jjtc001 = false;
                                jjtreeCloseNodeScope(jjtn001);
                jjtn001.kind = t.kind; jjtn001.postfix = true;
      } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001,  1);
                                  jjtreeCloseNodeScope(jjtn001);
                                }
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
        PrimaryExpression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void CastExpression() throws ParseException {
 /*@bgen(jjtree) CastExpression */
  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_13(2147483647)) {
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(RPAREN);
        UnaryExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          Type();
          jj_consume_token(RPAREN);
          UnaryExpressionNotPlusMinus();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void PrimaryExpression() throws ParseException {
                                               /*@bgen(jjtree) PrimaryExpression */
  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      PrimaryPrefix();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case LBRACKET:
        case DOT:
          ;
          break;
        default:
          break label_17;
        }
        PrimarySuffix();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void MethodInvocation() throws ParseException {
                                             /*@bgen(jjtree) MethodInvocation */
  BSHMethodInvocation jjtn000 = new BSHMethodInvocation(JJTMETHODINVOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      AmbiguousName();
      Arguments();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }
  final public void PrimaryPrefix() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LONG_STRING_LITERAL:
      Literal();
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      break;
    case NEW:
      AllocationExpression();
      break;
    default:
      if (jj_2_14(2147483647)) {
        MethodInvocation();
      } else if (jj_2_15(2147483647)) {
        Type();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          AmbiguousName();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
  final public void PrimarySuffix() throws ParseException {
 /*@bgen(jjtree) PrimarySuffix */
    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_16(2)) {
        jj_consume_token(DOT);
        jj_consume_token(CLASS);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.CLASS;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.INDEX;
          break;
        case DOT:
          jj_consume_token(DOT);
          t = jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            Arguments();
            break;
          default:
            ;
          }
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.NAME;
        jjtn000.field = t.image;
          break;
        case LBRACE:
          jj_consume_token(LBRACE);
          Expression();
          jj_consume_token(RBRACE);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.PROPERTY;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void Literal() throws ParseException {
 /*@bgen(jjtree) Literal */
    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token x;
    boolean b;
    String literal;
    char ch;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        x = jj_consume_token(INTEGER_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'l' || ch == 'L')
    {
        literal = literal.substring(0,literal.length()-1);
                try {
                jjtn000.value = new Primitive( parseLong(literal) );
                } catch ( NumberFormatException e ) {
                        {if (true) throw createParseException( e.getMessage(), e );}
                }
    }
    else
                try {
                jjtn000.value = new Primitive( parseInt(literal) );
                } catch ( NumberFormatException e ) {
                        {if (true) throw createParseException( e.getMessage(), e );}
                }
        break;
      case FLOATING_POINT_LITERAL:
        x = jj_consume_token(FLOATING_POINT_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'f' || ch == 'F')
    {
        literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Float( literal ).floatValue() );
    }
    else
    {
        if(ch == 'd' || ch == 'D')
            literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Double( literal ).doubleValue() );
    }
        break;
      case CHARACTER_LITERAL:
        x = jj_consume_token(CHARACTER_LITERAL);
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtreeCloseNodeScope(jjtn000);
                try {
                jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw createParseException("Error parsing character: "+x.image, e);}
                }
        break;
      case STRING_LITERAL:
        x = jj_consume_token(STRING_LITERAL);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                try {
                        jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw createParseException("Error parsing string: "+x.image, e);}
                }
        break;
      case LONG_STRING_LITERAL:
        x = jj_consume_token(LONG_STRING_LITERAL);
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                              jjtreeCloseNodeScope(jjtn000);
                try {
                        jjtn000.value = x.image.substring(3, x.image.length() - 3);
                } catch ( Exception e ) {
                        {if (true) throw createParseException("Error parsing long string: "+x.image, e);}
                }
        break;
      case FALSE:
      case TRUE:
        b = BooleanLiteral();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = new Primitive( b );
        break;
      case NULL:
        NullLiteral();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.NULL;
        break;
      case VOID:
        VoidLiteral();
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.VOID;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public boolean BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
           {if (true) return true;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
            {if (true) return false;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }
  final public void NullLiteral() throws ParseException {
    jj_consume_token(NULL);
  }
  final public void VoidLiteral() throws ParseException {
    jj_consume_token(VOID);
  }
  final public void Arguments() throws ParseException {
 /*@bgen(jjtree) Arguments */
  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ArgumentList();
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
// leave these on the stack for Arguments() to handle
  final public void ArgumentList() throws ParseException {
    Expression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_18;
      }
      jj_consume_token(COMMA);
      Expression();
    }
  }
  final public void TypeArguments() throws ParseException {
    jj_consume_token(LT);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(GT);
  }
  final public void AllocationExpression() throws ParseException {
 /*@bgen(jjtree) AllocationExpression */
  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_18(2)) {
        jj_consume_token(NEW);
        PrimitiveType();
        ArrayDimensions();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
          jj_consume_token(NEW);
          AmbiguousName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LT:
            TypeArguments();
            break;
          default:
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ArrayDimensions();
            break;
          case LPAREN:
            Arguments();
            if (jj_2_17(2)) {
              Block();
            } else {
              ;
            }
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ArrayDimensions() throws ParseException {
 /*@bgen(jjtree) ArrayDimensions */
  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_21(2)) {
        label_19:
        while (true) {
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                                        jjtn000.addDefinedDimension();
          if (jj_2_19(2)) {
            ;
          } else {
            break label_19;
          }
        }
        label_20:
        while (true) {
          if (jj_2_20(2)) {
            ;
          } else {
            break label_20;
          }
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
                           jjtn000.addUndefinedDimension();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          label_21:
          while (true) {
            jj_consume_token(LBRACKET);
            jj_consume_token(RBRACKET);
              jjtn000.addUndefinedDimension();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LBRACKET:
              ;
              break;
            default:
              break label_21;
            }
          }
          ArrayInitializer();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
 * Statement syntax follows.
 */
  final public void Statement() throws ParseException {
    if (jj_2_22(2)) {
      LabeledStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        EmptyStatement();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        StatementExpression();
        jj_consume_token(SEMICOLON);
        break;
      case SWITCH:
        SwitchStatement();
        break;
      case IF:
        IfStatement();
        break;
      case WHILE:
        WhileStatement();
        break;
      case DO:
        DoStatement();
        break;
      default:
        if (isRegularForStatement()) {
          ForStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FOR:
            EnhancedForStatement();
            break;
          case BREAK:
            BreakStatement();
            break;
          case CONTINUE:
            ContinueStatement();
            break;
          case RETURN:
            ReturnStatement();
            break;
          case SYNCHRONIZED:
            SynchronizedStatement();
            break;
          case THROW:
            ThrowStatement();
            break;
          case TRY:
            TryStatement();
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }
  final public void LabeledStatement() throws ParseException {
    jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    Statement();
  }
  final public void Block() throws ParseException {
 /*@bgen(jjtree) Block */
  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      label_22:
      while (true) {
        if (jj_2_23(1)) {
          ;
        } else {
          break label_22;
        }
        BlockStatement();
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void BlockStatement() throws ParseException {
    if (jj_2_24(2147483647)) {
      ClassDeclaration();
    } else if (jj_2_25(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_26(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_27(2147483647)) {
      TypedVariableDeclaration();
      jj_consume_token(SEMICOLON);
    } else if (jj_2_28(1)) {
      Statement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
      case STATIC:
        ImportDeclaration();
        break;
      case PACKAGE:
        PackageDeclaration();
        break;
      case FORMAL_COMMENT:
        FormalComment();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void FormalComment() throws ParseException {
 /*@bgen(jjtree) #FormalComment( retainComments) */
        BSHFormalComment jjtn000 = new BSHFormalComment(JJTFORMALCOMMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FORMAL_COMMENT);
                              jjtree.closeNodeScope(jjtn000,  retainComments);
                              jjtc000 = false;
                              jjtreeCloseNodeScope(jjtn000);
                jjtn000.text=t.image;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  retainComments);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void EmptyStatement() throws ParseException {
    jj_consume_token(SEMICOLON);
  }
  final public void StatementExpression() throws ParseException {
    Expression();
  }
  final public void SwitchStatement() throws ParseException {
 /*@bgen(jjtree) SwitchStatement */
  BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SWITCH);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(LBRACE);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
        case _DEFAULT:
          ;
          break;
        default:
          break label_23;
        }
        SwitchLabel();
        label_24:
        while (true) {
          if (jj_2_29(1)) {
            ;
          } else {
            break label_24;
          }
          BlockStatement();
        }
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void SwitchLabel() throws ParseException {
 /*@bgen(jjtree) SwitchLabel */
  BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
        jj_consume_token(CASE);
        Expression();
        jj_consume_token(COLON);
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
        jj_consume_token(COLON);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.isDefault = true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void IfStatement() throws ParseException {
 /*@bgen(jjtree) IfStatement */
  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IF);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        Statement();
        break;
      default:
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void WhileStatement() throws ParseException {
 /*@bgen(jjtree) WhileStatement */
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	Do statement is just a While statement with a special hook to execute
	at least once.
*/
  final public void DoStatement() throws ParseException {
 /*@bgen(jjtree) WhileStatement */
  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DO);
      Statement();
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.isDoStatement=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForStatement() throws ParseException {
 /*@bgen(jjtree) ForStatement */
  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      jj_consume_token(FOR);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case NEW:
      case NULL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case TRUE:
      case VOID:
      case VOLATILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ForInit();
                          jjtn000.hasForInit=true;
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
                         jjtn000.hasExpression=true;
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ForUpdate();
                        jjtn000.hasForUpdate=true;
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
/*
	The new JDK1.5 enhanced for statement.
	e.g. for( int a : arrayOfInts ) { }
	We also support loose typing of the iterator var for BeanShell
	e.g. for( a : arrayOfInts ) { }
*/
  final public void EnhancedForStatement() throws ParseException {
 /*@bgen(jjtree) EnhancedForStatement */
  BSHEnhancedForStatement jjtn000 = new BSHEnhancedForStatement(JJTENHANCEDFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_30(4)) {
        jj_consume_token(FOR);
        jj_consume_token(LPAREN);
        t = jj_consume_token(IDENTIFIER);
        jj_consume_token(COLON);
        Expression();
        jj_consume_token(RPAREN);
        Statement();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.varName = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FOR:
          jj_consume_token(FOR);
          jj_consume_token(LPAREN);
          Type();
          t = jj_consume_token(IDENTIFIER);
          jj_consume_token(COLON);
          Expression();
          jj_consume_token(RPAREN);
          Statement();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.varName = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForInit() throws ParseException {
  Token t = null;
    if (jj_2_31(2147483647)) {
      TypedVariableDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        StatementExpressionList();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
/**
	Declared a typed variable.
	Untyped variables are not declared per-se but are handled by the part
	of the grammar that deals with assignments.
*/
  final public void TypedVariableDeclaration() throws ParseException {
 /*@bgen(jjtree) TypedVariableDeclaration */
        BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
        Modifiers mods;
    try {
      mods = Modifiers(Modifiers.FIELD, false);
      Type();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        TypeArguments();
        break;
      default:
        ;
      }
      VariableDeclarator();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_25;
        }
        jj_consume_token(COMMA);
        VariableDeclarator();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        jjtn000.modifiers = mods;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void StatementExpressionList() throws ParseException {
 /*@bgen(jjtree) StatementExpressionList */
  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      StatementExpression();
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_26;
        }
        jj_consume_token(COMMA);
        StatementExpression();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForUpdate() throws ParseException {
    StatementExpressionList();
  }
  final public void BreakStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(BREAK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                                 jjtreeCloseNodeScope(jjtn000);
                                 jjtn000.kind = BREAK;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ContinueStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(CONTINUE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                    jjtreeCloseNodeScope(jjtn000);
                                    jjtn000.kind = CONTINUE;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ReturnStatement() throws ParseException {
 /*@bgen(jjtree) ReturnStatement */
  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  jjtreeCloseNodeScope(jjtn000);
                                  jjtn000.kind = RETURN;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void SynchronizedStatement() throws ParseException {
 /*@bgen(jjtree) Block */
  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SYNCHRONIZED);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Block();
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                                jjtreeCloseNodeScope(jjtn000);
                jjtn000.isSynchronized=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ThrowStatement() throws ParseException {
 /*@bgen(jjtree) ThrowStatement */
  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(THROW);
      Expression();
      jj_consume_token(SEMICOLON);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void TryStatement() throws ParseException {
 /*@bgen(jjtree) TryStatement */
  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);boolean closed = false;
    try {
      jj_consume_token(TRY);
      Block();
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CATCH:
          ;
          break;
        default:
          break label_27;
        }
        jj_consume_token(CATCH);
        jj_consume_token(LPAREN);
        FormalParameter();
        jj_consume_token(RPAREN);
        Block();
                                                      closed = true;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINALLY:
        jj_consume_token(FINALLY);
        Block();
                              closed = true;
        break;
      default:
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if ( !closed ) {if (true) throw generateParseException();}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_3R_115() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3_8() {
    if (jj_3R_34()) return true;
    if (jj_3R_35()) return true;
    return false;
  }
  private boolean jj_3R_110() {
    if (jj_3R_34()) return true;
    if (jj_3R_35()) return true;
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_150() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_29()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) return true;
    }
    return false;
  }
  private boolean jj_3R_59() {
    if (jj_scan_token(LT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }
  private boolean jj_3_18() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_37()) return true;
    if (jj_3R_155()) return true;
    return false;
  }
  private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) return true;
    }
    return false;
  }
  private boolean jj_3R_74() {
    if (jj_3R_111()) return true;
    return false;
  }
  private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    return false;
  }
  private boolean jj_3R_73() {
    if (jj_3R_110()) return true;
    return false;
  }
  private boolean jj_3R_152() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_138() {
    if (jj_3R_40()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_152()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_109() {
    if (jj_3R_138()) return true;
    return false;
  }
  private boolean jj_3R_79() {
    if (jj_3R_29()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_115()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_72() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_109()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  private boolean jj_3_7() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_29() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_161() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }
  private boolean jj_3R_160() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }
  private boolean jj_3R_154() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) return true;
    }
    return false;
  }
  private boolean jj_3R_71() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }
  private boolean jj_3R_70() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }
  private boolean jj_3R_69() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }
  private boolean jj_3R_68() {
    if (jj_scan_token(INT)) return true;
    return false;
  }
  private boolean jj_3R_112() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_67() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }
  private boolean jj_3R_58() {
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3R_149() {
    if (jj_scan_token(57)) return true;
    return false;
  }
  private boolean jj_3R_66() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }
  private boolean jj_3R_65() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }
  private boolean jj_3R_64() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }
  private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_148() {
    if (jj_scan_token(41)) return true;
    return false;
  }
  private boolean jj_3R_147() {
    if (jj_3R_154()) return true;
    return false;
  }
  private boolean jj_3R_77() {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_112()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    }
    return false;
  }
  private boolean jj_3R_76() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }
  private boolean jj_3_6() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_146() {
    if (jj_scan_token(LONG_STRING_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_33() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_57() {
    if (jj_3R_37()) return true;
    return false;
  }
  private boolean jj_3R_114() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_113()) return true;
    return false;
  }
  private boolean jj_3R_197() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_196() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_113()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_145() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_6()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_128() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_196()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_197()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_144() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_184() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_183()) return true;
    return false;
  }
  private boolean jj_3_4() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_31()) return true;
    return false;
  }
  private boolean jj_3R_140() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3_5() {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_78() {
    if (jj_3R_113()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_114()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_113() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) return true;
    }
    return false;
  }
  private boolean jj_3R_127() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_44() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_78()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  private boolean jj_3R_195() {
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_169() {
    if (jj_3R_31()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_143() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_126() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_100() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_169()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  private boolean jj_3R_30() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }
  private boolean jj_3R_217() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_116()) return true;
    return false;
  }
  private boolean jj_3R_187() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_31()) return true;
    return false;
  }
  private boolean jj_3R_125() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_195()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_56() {
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_55() {
    if (jj_3R_100()) return true;
    return false;
  }
  private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    }
    return false;
  }
  private boolean jj_3R_124() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_123() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_142() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_133() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_151() {
    if (jj_3R_72()) return true;
    return false;
  }
  private boolean jj_3R_183() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_187()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_202() {
    if (jj_3R_212()) return true;
    return false;
  }
  private boolean jj_3R_182() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_108() {
    if (jj_3R_133()) return true;
    return false;
  }
  private boolean jj_3R_212() {
    if (jj_3R_116()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_217()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_96() {
    if (jj_3R_42()) return true;
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_182()) jj_scanpos = xsp;
    if (jj_3R_183()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_184()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_132() {
    if (jj_scan_token(IMPORT)) return true;
    if (jj_scan_token(STAR)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_137() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  private boolean jj_3R_136() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_151()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3_31() {
    if (jj_3R_42()) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) jj_scanpos = xsp;
    if (jj_scan_token(IMPORT)) return true;
    if (jj_3R_29()) return true;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) return true;
    }
    return false;
  }
  private boolean jj_3R_135() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_98() {
    if (jj_scan_token(PACKAGE)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3_2() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }
  private boolean jj_3R_211() {
    if (jj_3R_212()) return true;
    return false;
  }
  private boolean jj_3R_181() {
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3_16() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }
  private boolean jj_3R_107() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) return true;
    }
    }
    }
    return false;
  }
  private boolean jj_3R_180() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_79()) return true;
    return false;
  }
  private boolean jj_3R_210() {
    if (jj_3R_96()) return true;
    return false;
  }
  private boolean jj_3R_201() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) return true;
    }
    return false;
  }
  private boolean jj_3_15() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }
  private boolean jj_3_14() {
    if (jj_3R_38()) return true;
    return false;
  }
  private boolean jj_3R_130() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_141() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_131() {
    if (jj_3R_43()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_95() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    }
    if (jj_3R_44()) return true;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) return true;
    }
    return false;
  }
  private boolean jj_3R_191() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_106() {
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3_30() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_122() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) return true;
    }
    return false;
  }
  private boolean jj_3R_105() {
    if (jj_3R_32()) return true;
    return false;
  }
  private boolean jj_3R_192() {
    if (jj_3R_201()) return true;
    return false;
  }
  private boolean jj_3R_61() {
    if (jj_3R_107()) return true;
    return false;
  }
  private boolean jj_3R_129() {
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }
  private boolean jj_3R_104() {
    if (jj_3R_38()) return true;
    return false;
  }
  private boolean jj_3R_194() {
    if (jj_3R_202()) return true;
    return false;
  }
  private boolean jj_3R_193() {
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_103() {
    if (jj_3R_134()) return true;
    return false;
  }
  private boolean jj_3R_102() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  private boolean jj_3R_179() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_79()) return true;
    return false;
  }
  private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) return true;
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_101() {
    if (jj_3R_133()) return true;
    return false;
  }
  private boolean jj_3R_178() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3R_38() {
    if (jj_3R_29()) return true;
    if (jj_3R_72()) return true;
    return false;
  }
  private boolean jj_3R_121() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_193()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_194()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_94() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_3R_129()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_178()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_179()) jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3_13() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_37()) return true;
    return false;
  }
  private boolean jj_3R_34() {
    if (jj_3R_60()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_61()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_120() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_47()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_224() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_215()) return true;
    return false;
  }
  private boolean jj_3R_223() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_198()) return true;
    return false;
  }
  private boolean jj_3R_221() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    return false;
  }
  private boolean jj_3_12() {
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    return false;
  }
  private boolean jj_3R_119() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_226() {
    if (jj_3R_34()) return true;
    return false;
  }
  private boolean jj_3_11() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }
  private boolean jj_3_29() {
    if (jj_3R_28()) return true;
    return false;
  }
  private boolean jj_3R_118() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_191()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_225() {
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    return false;
  }
  private boolean jj_3R_222() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_225()) {
    jj_scanpos = xsp;
    if (jj_3R_226()) return true;
    }
    return false;
  }
  private boolean jj_3R_75() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_63() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_209() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }
  private boolean jj_3R_62() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3_9() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_208() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }
  private boolean jj_3R_200() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) return true;
    }
    return false;
  }
  private boolean jj_3R_42() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_75()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    }
    }
    return false;
  }
  private boolean jj_3_10() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_37()) return true;
    return false;
  }
  private boolean jj_3R_190() {
    if (jj_3R_200()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_29()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_220() {
    if (jj_3R_222()) return true;
    return false;
  }
  private boolean jj_3R_117() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_190()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  private boolean jj_3R_219() {
    if (jj_3R_221()) return true;
    return false;
  }
  private boolean jj_3R_218() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) return true;
    }
    if (jj_3R_198()) return true;
    return false;
  }
  private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) return true;
    }
    }
    return false;
  }
  private boolean jj_3R_46() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_214() {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_34()) return true;
    return false;
  }
  private boolean jj_3_1() {
    if (jj_3R_28()) return true;
    return false;
  }
  private boolean jj_3R_216() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) return true;
    }
    }
    if (jj_3R_198()) return true;
    return false;
  }
  private boolean jj_3R_213() {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_34()) return true;
    return false;
  }
  private boolean jj_3R_45() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_79()) return true;
    return false;
  }
  private boolean jj_3R_116() {
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_206() {
    if (jj_3R_215()) return true;
    return false;
  }
  private boolean jj_3R_205() {
    if (jj_3R_214()) return true;
    return false;
  }
  private boolean jj_3R_204() {
    if (jj_3R_213()) return true;
    return false;
  }
  private boolean jj_3R_203() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) return true;
    }
    if (jj_3R_198()) return true;
    return false;
  }
  private boolean jj_3R_198() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) return true;
    }
    }
    }
    return false;
  }
  private boolean jj_3R_99() {
    if (jj_scan_token(FORMAL_COMMENT)) return true;
    return false;
  }
  private boolean jj_3R_188() {
    if (jj_3R_198()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_216()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_207() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) return true;
    }
    if (jj_3R_188()) return true;
    return false;
  }
  private boolean jj_3R_185() {
    if (jj_3R_188()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_207()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_54() {
    if (jj_3R_99()) return true;
    return false;
  }
  private boolean jj_3_27() {
    if (jj_3R_42()) return true;
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_53() {
    if (jj_3R_98()) return true;
    return false;
  }
  private boolean jj_3R_199() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) return true;
    }
    }
    }
    }
    }
    if (jj_3R_185()) return true;
    return false;
  }
  private boolean jj_3R_52() {
    if (jj_3R_97()) return true;
    return false;
  }
  private boolean jj_3_26() {
    if (jj_3R_42()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_44()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }
  private boolean jj_3R_177() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) return true;
    }
    if (jj_3R_172()) return true;
    return false;
  }
  private boolean jj_3R_176() {
    if (jj_3R_185()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_199()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3_28() {
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3_25() {
    if (jj_3R_42()) return true;
    if (jj_3R_43()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }
  private boolean jj_3R_51() {
    if (jj_3R_96()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_189() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_176()) return true;
    return false;
  }
  private boolean jj_3_24() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) return true;
    }
    return false;
  }
  private boolean jj_3R_174() {
    if (jj_3R_176()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_189()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_50() {
    if (jj_3R_95()) return true;
    return false;
  }
  private boolean jj_3R_186() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_32()) return true;
    return false;
  }
  private boolean jj_3R_49() {
    if (jj_3R_95()) return true;
    return false;
  }
  private boolean jj_3R_172() {
    if (jj_3R_174()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_48() {
    if (jj_3R_94()) return true;
    return false;
  }
  private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3_23() {
    if (jj_3R_28()) return true;
    return false;
  }
  private boolean jj_3R_173() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_167()) return true;
    return false;
  }
  private boolean jj_3R_170() {
    if (jj_3R_172()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_177()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_39() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) return true;
    }
    if (jj_3R_170()) return true;
    return false;
  }
  private boolean jj_3R_41() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_167() {
    if (jj_3R_170()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_175()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_93() {
    if (jj_3R_128()) return true;
    return false;
  }
  private boolean jj_3R_92() {
    if (jj_3R_127()) return true;
    return false;
  }
  private boolean jj_3R_164() {
    if (jj_3R_167()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_173()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_91() {
    if (jj_3R_126()) return true;
    return false;
  }
  private boolean jj_3R_90() {
    if (jj_3R_125()) return true;
    return false;
  }
  private boolean jj_3R_162() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_111()) return true;
    return false;
  }
  private boolean jj_3R_89() {
    if (jj_3R_124()) return true;
    return false;
  }
  private boolean jj_3R_171() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) return true;
    }
    if (jj_3R_164()) return true;
    return false;
  }
  private boolean jj_3R_88() {
    if (jj_3R_123()) return true;
    return false;
  }
  private boolean jj_3R_159() {
    if (jj_3R_164()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_171()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_87() {
    if (jj_3R_122()) return true;
    return false;
  }
  private boolean jj_3R_86() {
    if (jj_3R_121()) return true;
    return false;
  }
  private boolean jj_3R_85() {
    if (jj_3R_120()) return true;
    return false;
  }
  private boolean jj_3R_168() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) return true;
    }
    if (jj_3R_159()) return true;
    return false;
  }
  private boolean jj_3R_84() {
    if (jj_3R_119()) return true;
    return false;
  }
  private boolean jj_3R_153() {
    if (jj_3R_159()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_168()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_83() {
    if (jj_3R_118()) return true;
    return false;
  }
  private boolean jj_3R_82() {
    if (jj_3R_117()) return true;
    return false;
  }
  private boolean jj_3R_81() {
    if (jj_3R_116()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_165() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) return true;
    }
    if (jj_3R_153()) return true;
    return false;
  }
  private boolean jj_3_17() {
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_80() {
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_139() {
    if (jj_3R_153()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_165()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = isRegularForStatement();
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3_22() {
    if (jj_3R_41()) return true;
    return false;
  }
  private boolean jj_3R_156() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_111() {
    if (jj_3R_139()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_162()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_166() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_158() {
    if (jj_3R_72()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_163() {
    Token xsp;
    if (jj_3R_166()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_166()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_100()) return true;
    return false;
  }
  private boolean jj_3_20() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_157() {
    if (jj_3R_155()) return true;
    return false;
  }
  private boolean jj_3_19() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(133)) {
    jj_scanpos = xsp;
    if (jj_scan_token(134)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3_21() {
    Token xsp;
    if (jj_3_19()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_20()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_155() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) return true;
    }
    return false;
  }
  /** Generated Token Manager. */
  public ParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }
  /** Constructor. */
  public Parser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }
  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }
  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }
  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }
  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }
/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }
/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }
  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }
  /** Generate ParseException. */
  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }
  /** Enable tracing. */
  final public void enable_tracing() {
  }
  /** Disable tracing. */
  final public void disable_tracing() {
  }
}
package bsh;
public class ParseException extends Exception {
  /**
   * The version identifier for this Serializable class.
   * Increment only if the <i>serialized</i> form of the
   * class changes.
   */
  private static final long serialVersionUID = 1L;
  /**
   * This constructor is used by the method "generateParseException"
   * in the generated parser.  Calling this constructor generates
   * a new object of this type with the fields "currentToken",
   * "expectedTokenSequences", and "tokenImage" set.
   */
  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }
  /**
   * The following constructors are for use by you for whatever
   * purpose you can think of.  Constructing the exception in this
   * manner makes the exception behave in the normal way - i.e., as
   * documented in the class "Throwable".  The fields "errorToken",
   * "expectedTokenSequences", and "tokenImage" do not contain
   * relevant information.  The JavaCC generated code does not use
   * these constructors.
   */
  public ParseException() {
    super();
  }
  /** Constructor with message. */
  public ParseException(String message) {
    super(message);
  }
  /**
   * This is the last token that has been consumed successfully.  If
   * this object has been created due to a parse error, the token
   * followng this token will (therefore) be the first error token.
   */
  public Token currentToken;
  /**
   * Each entry in this array is an array of integers.  Each array
   * of integers represents a sequence of tokens (by their ordinal
   * values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;
  /**
   * This is a reference to the "tokenImage" array of the generated
   * parser within which the parse error occurred.  This array is
   * defined in the generated ...Constants interface.
   */
  public String[] tokenImage;
  /**
   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
   * error message and returns it.  If this object has been created
   * due to a parse error, and you do not catch it (it gets thrown
   * from the parser) the correct error message
   * gets displayed.
   */
  private static String initialise(Token currentToken,
                           int[][] expectedTokenSequences,
                           String[] tokenImage) {
    String eol = System.getProperty("line.separator", "\n");
    StringBuffer expected = new StringBuffer();
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected.append("...");
      }
      expected.append(eol).append("    ");
    }
    String retval = "Encountered \"";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += " ";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += " " + tokenImage[tok.kind];
      retval += " \"";
      retval += add_escapes(tok.image);
      retval += " \"";
      tok = tok.next;
    }
    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
    retval += "." + eol;
    if (expectedTokenSequences.length == 1) {
      retval += "Was expecting:" + eol + "    ";
    } else {
      retval += "Was expecting one of:" + eol + "    ";
    }
    retval += expected.toString();
    return retval;
  }
  /**
   * The end of line string for this machine.
   */
  protected String eol = System.getProperty("line.separator", "\n");
  /**
   * Used to convert raw characters to their escaped version
   * when these raw version cannot be used as part of an ASCII
   * string literal.
   */
  static String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
}
package bsh;
import javax.script.ScriptEngine;
import java.util.List;
import java.util.Arrays;
// 	Adopted from http://ikayzo.org/svn/beanshell/BeanShell/engine/src/bsh/engine/BshScriptEngineFactory.java
public class BshScriptEngineFactory implements javax.script.ScriptEngineFactory {
	// Begin impl ScriptEnginInfo
	final List<String> extensions = Arrays.asList("bsh", "java");
	final List<String> mimeTypes = Arrays.asList("application/x-beanshell", "application/x-bsh", "application/x-java-source");
	final List<String> names = Arrays.asList("beanshell", "bsh", "java");
	public String getEngineName() {
		return "BeanShell Engine";
	}
	public String getEngineVersion() {
		return Interpreter.VERSION;
	}
	public List<String> getExtensions() {
		return extensions;
	}
	public List<String> getMimeTypes() {
		return mimeTypes;
	}
	public List<String> getNames() {
		return names;
	}
	public String getLanguageName() {
		return "BeanShell";
	}
	public String getLanguageVersion() {
		return bsh.Interpreter.VERSION + "";
	}
	public Object getParameter(String param) {
		if (param.equals(ScriptEngine.ENGINE)) {
			return getEngineName();
		}
		if (param.equals(ScriptEngine.ENGINE_VERSION)) {
			return getEngineVersion();
		}
		if (param.equals(ScriptEngine.NAME)) {
			return getEngineName();
		}
		if (param.equals(ScriptEngine.LANGUAGE)) {
			return getLanguageName();
		}
		if (param.equals(ScriptEngine.LANGUAGE_VERSION)) {
			return getLanguageVersion();
		}
		if (param.equals("THREADING")) {
			return "MULTITHREADED";
		}
		return null;
	}
	public String getMethodCallSyntax(String objectName, String methodName, String... args) {
		// Note: this is very close to the bsh.StringUtil.methodString()
		// method, which constructs a method signature from arg *types*.  Maybe
		// combine these later.
		StringBuffer sb = new StringBuffer();
		if (objectName != null) {
			sb.append(objectName).append('.');
		}
		sb.append(methodName).append('(');
		if (args.length > 0) {
			sb.append(' ');
		}
		for (int i = 0; i < args.length; i++) {
			sb.append((args[i] == null) ? "null" : args[i]).append(i < (args.length - 1) ? ", " : " ");
		}
		sb.append(")");
		return sb.toString();
	}
	public String getOutputStatement(String message) {
		return "print( \"" + message + "\" );";
	}
	public String getProgram(String... statements) {
		StringBuffer sb = new StringBuffer();
		for (final String statement : statements) {
			sb.append(statement);
			if ( ! statement.endsWith(";")) {
				sb.append(";");
			}
			sb.append("\n");
		}
		return sb.toString();
	}
	// End impl ScriptEngineInfo
	// Begin impl ScriptEngineFactory
	public ScriptEngine getScriptEngine() {
		return new BshScriptEngine();
	}
	// End impl ScriptEngineFactory
}
package bsh;
import javax.script.AbstractScriptEngine;
import javax.script.Bindings;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.Invocable;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineFactory;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
/*
	Adopted from http://ikayzo.org/svn/beanshell/BeanShell/engine/src/bsh/engine/BshScriptEngine.java
	Notes
	This engine supports open-ended pluggable scriptcontexts
*/
public class BshScriptEngine extends AbstractScriptEngine implements Compilable, Invocable {
	// The BeanShell global namespace for the interpreter is stored in the
	// engine scope map under this key.
	static final String engineNameSpaceKey = "org_beanshell_engine_namespace";
	private BshScriptEngineFactory factory;
	private bsh.Interpreter interpreter;
	public BshScriptEngine() {
		this(null);
	}
	public BshScriptEngine(BshScriptEngineFactory factory) {
		this.factory = factory;
		getInterpreter(); // go ahead and prime the interpreter now
	}
	protected Interpreter getInterpreter() {
		if (interpreter == null) {
			this.interpreter = new bsh.Interpreter();
			interpreter.setNameSpace(null); // should always be set by context
		}
		return interpreter;
	}
	public Object eval(String script, ScriptContext scriptContext) throws ScriptException {
		return evalSource(script, scriptContext);
	}
	public Object eval(Reader reader, ScriptContext scriptContext) throws ScriptException {
		return evalSource(reader, scriptContext);
	}
	/*
		This is the primary implementation method.
		We respect the String/Reader difference here in BeanShell because
		BeanShell will do a few extra things in the string case... e.g.
		tack on a trailing ";" semicolon if necessary.
	*/
	private Object evalSource(Object source, ScriptContext scriptContext) throws ScriptException {
		bsh.NameSpace contextNameSpace = getEngineNameSpace(scriptContext);
		Interpreter bsh = getInterpreter();
		bsh.setNameSpace(contextNameSpace);
		bsh.setOut(toPrintStream(scriptContext.getWriter()));
		bsh.setErr(toPrintStream(scriptContext.getErrorWriter()));
		try {
			if (source instanceof Reader) {
				return bsh.eval((Reader) source);
			} else {
				return bsh.eval((String) source);
			}
		//} catch (ParseException e) {
			// explicit parsing error  TODO how to handle parse exception ?
			//throw new ScriptException(e.toString());
                    //e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (TargetError e) {
			// The script threw an application level exception
			// set it as the cause ?
			ScriptException se = new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
			se.initCause(e.getTarget());
			throw se;
		} catch (EvalError e) {
			// The script couldn't be evaluated properly
			throw new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (InterpreterError e) {
			// The interpreter had a fatal problem
			throw new ScriptException(e.toString());
		}
	}
	private PrintStream toPrintStream(final Writer writer) {
		// This is a big hack, convert writer to PrintStream
		return new PrintStream(new WriterOutputStream(writer));
	}
	/*
		Check the context for an existing global namespace embedded
		in the script context engine scope.  If none exists, ininitialize the
		context with one.
	*/
	private static NameSpace getEngineNameSpace(ScriptContext scriptContext) {
		NameSpace ns = (NameSpace) scriptContext.getAttribute(engineNameSpaceKey, ScriptContext.ENGINE_SCOPE);
		if (ns == null) {
			// Create a global namespace for the interpreter
			Map<String, Object> engineView = new ScriptContextEngineView(scriptContext);
			ns = new ExternalNameSpace(null/*parent*/, "javax_script_context", engineView);
			scriptContext.setAttribute(engineNameSpaceKey, ns, ScriptContext.ENGINE_SCOPE);
		}
		return ns;
	}
	public Bindings createBindings() {
		return new SimpleBindings();
	}
	public ScriptEngineFactory getFactory() {
		if (factory == null) {
			factory = new BshScriptEngineFactory();
		}
		return factory;
	}
	/**
	 * Compiles the script (source represented as a {@code String}) for later
	 * execution.
	 *
	 * @param script The source of the script, represented as a {@code String}.
	 * @return An subclass of {@code CompiledScript} to be executed later
	 *         using one of the {@code eval} methods of {@code CompiledScript}.
	 * @throws ScriptException	  if compilation fails.
	 * @throws NullPointerException if the argument is null.
	 */
	public CompiledScript compile(String script) throws ScriptException {
		try {
			final PreparsedScript preparsed = new PreparsedScript(script);
			return new CompiledScript() {
				@Override
				public Object eval(ScriptContext context) throws ScriptException {
					final HashMap<String, Object> map = new HashMap<String, Object>();
					final List<Integer> scopes = new ArrayList<Integer>(context.getScopes());
					Collections.sort(scopes); // lowest scope at first pos
					Collections.reverse(scopes); // highest scope at first pos
					for (final Integer scope : scopes) {
						map.putAll(context.getBindings(scope));
					}
					preparsed.setOut(toPrintStream(context.getWriter()));
					preparsed.setErr(toPrintStream(context.getErrorWriter()));
					try {
						return preparsed.invoke(map);
					} catch (final EvalError e) {
						throw constructScriptException(e);
					}
				}
				@Override
				public ScriptEngine getEngine() {
					return BshScriptEngine.this;
				}
			};
		} catch (final EvalError e) {
			throw constructScriptException(e);
		}
	}
	private ScriptException constructScriptException(final EvalError e) {
		return new ScriptException(e.getMessage(), e.getErrorSourceFile(), e.getErrorLineNumber());
	}
	private static String convertToString(Reader reader) throws IOException {
		final StringBuffer buffer = new StringBuffer(64);
		char[] cb = new char[64];
		int len;
		while ((len = reader.read(cb)) != -1) {
			buffer.append(cb, 0, len);
		}
		return buffer.toString();
	}
	
	/**
	 * Compiles the script (source read from {@code Reader}) for later
	 * execution.  Functionality is identical to {@code compile(String)} other
	 * than the way in which the source is passed.
	 *
	 * @param script The reader from which the script source is obtained.
	 * @return An implementation of {@code CompiledScript} to be executed
	 *         later using one of its {@code eval} methods of
	 *         {@code CompiledScript}.
	 * @throws ScriptException	  if compilation fails.
	 * @throws NullPointerException if argument is null.
	 */
	public CompiledScript compile(Reader script) throws ScriptException {
		try {
			return compile(convertToString(script));
		} catch (IOException e) {
			throw new ScriptException(e);
		}
	}
	/**
	 * Calls a procedure compiled during a previous script execution, which is
	 * retained in the state of the {@code ScriptEngine{@code .
	 *
	 * @param name The name of the procedure to be called.
	 * @param thiz If the procedure is a member  of a class defined in the script
	 *             and thiz is an instance of that class returned by a previous execution or
	 *             invocation, the named method is called through that instance. If classes are
	 *             not supported in the scripting language or if the procedure is not a member
	 *             function of any class, the argument must be {@code null}.
	 * @param args Arguments to pass to the procedure.  The rules for converting
	 *             the arguments to scripting variables are implementation-specific.
	 * @return The value returned by the procedure.  The rules for converting the
	 *         scripting variable returned by the procedure to a Java Object are
	 *         implementation-specific.
	 * @throws javax.script.ScriptException if an error occurrs during invocation
	 *                                      of the method.
	 * @throws NoSuchMethodException		if method with given name or matching argument
	 *                                      types cannot be found.
	 * @throws NullPointerException		 if method name is null.
	 */
	public Object invokeMethod(Object thiz, String name, Object... args) throws ScriptException, NoSuchMethodException {
		if (!(thiz instanceof bsh.This)) {
			throw new ScriptException("Illegal objec type: " + thiz.getClass());
		}
		bsh.This bshObject = (bsh.This) thiz;
		try {
			return bshObject.invokeMethod(name, args);
		//} catch (ParseException e) {
			// explicit parsing error
		//	throw new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (TargetError e) {
			// The script threw an application level exception
			// set it as the cause ?
			ScriptException se = new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
			se.initCause(e.getTarget());
			throw se;
		} catch (EvalError e) {
			// The script couldn't be evaluated properly
			throw new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (InterpreterError e) {
			// The interpreter had a fatal problem
			throw new ScriptException(e.toString());
		}
	}
	/**
	 * Same as invoke(Object, String, Object...) with {@code null} as the
	 * first argument.  Used to call top-level procedures defined in scripts.
	 *
	 * @param args Arguments to pass to the procedure
	 * @return The value returned by the procedure
	 * @throws javax.script.ScriptException if an error occurrs during invocation
	 *                                      of the method.
	 * @throws NoSuchMethodException		if method with given name or matching
	 *                                      argument types cannot be found.
	 * @throws NullPointerException		 if method name is null.
	 */
	public Object invokeFunction(String name, Object... args) throws ScriptException, NoSuchMethodException {
		return invokeMethod(getGlobal(), name, args);
	}
	/**
	 * Returns an implementation of an interface using procedures compiled in the
	 * interpreter. The methods of the interface may be implemented using the
	 * {@code invoke} method.
	 *
	 * @param clasz The {@code Class} object of the interface to return.
	 * @return An instance of requested interface - null if the requested interface
	 *         is unavailable, i. e. if compiled methods in the
	 *         {@code ScriptEngine} cannot be found matching the ones in the
	 *         requested interface.
	 * @throws IllegalArgumentException if the specified {@code Class} object
	 *                                  does not exist or is not an interface.
	 */
	public <T> T getInterface(Class<T> clasz) {
		return clasz.cast(getGlobal().getInterface(clasz));
	}
	/**
	 * Returns an implementation of an interface using member functions of a
	 * scripting object compiled in the interpreter. The methods of the interface
	 * may be implemented using invoke(Object, String, Object...) method.
	 *
	 * @param thiz  The scripting object whose member functions are used to
	 *              implement the methods of the interface.
	 * @param clasz The {@code Class} object of the interface to return.
	 * @return An instance of requested interface - null if the requested
	 *         interface is unavailable, i. e. if compiled methods in the
	 *         {@code ScriptEngine} cannot be found matching the ones in the
	 *         requested interface.
	 * @throws IllegalArgumentException if the specified {@code Class} object
	 *                                  does not exist or is not an interface, or if the specified Object is null
	 *                                  or does not represent a scripting object.
	 */
	public <T> T getInterface(Object thiz, Class<T> clasz) {
		if (!(thiz instanceof bsh.This)) {
			throw new IllegalArgumentException("invalid object type: " + thiz.getClass());
		}
		bsh.This bshThis = (bsh.This) thiz;
		return clasz.cast(bshThis.getInterface(clasz));
	}
	private bsh.This getGlobal() {
		// requires 2.0b5 to make getThis() public
		return getEngineNameSpace(getContext()).getThis(getInterpreter());
	}
	/*
		This is a total hack.  We need to introduce a writer to the
		Interpreter.
	*/
	class WriterOutputStream extends OutputStream {
		Writer writer;
		WriterOutputStream(Writer writer) {
			this.writer = writer;
		}
		public void write(int b) throws IOException {
			writer.write(b);
		}
		public void flush() throws IOException {
			writer.flush();
		}
		public void close() throws IOException {
			writer.close();
		}
	}
}
package bsh;
import bsh.classpath.ClassManagerImpl;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.*;
import java.util.Map;
/**
 * With this class the script source is only parsed once and the resulting AST is used for
 * {@link #invoke(java.util.Map) every invocation}. This class is designed to be thread-safe.  
 */
public class PreparsedScript {
	private final BshMethod _method;
	private final Interpreter _interpreter;
	public PreparsedScript(final String source) throws EvalError {
		this(source, getDefaultClassLoader());
	}
	private static ClassLoader getDefaultClassLoader() {
		ClassLoader cl = null;
		try {
			cl = Thread.currentThread().getContextClassLoader();
		} catch (final SecurityException e) {
			// ignore
		}
		if (cl == null) {
			cl = PreparsedScript.class.getClassLoader();
		}
		if (cl != null) {
			return cl;
		}
		return ClassLoader.getSystemClassLoader();
	}
	public PreparsedScript(final String source, final ClassLoader classLoader) throws EvalError {
		final ClassManagerImpl classManager = new ClassManagerImpl();
		classManager.setClassLoader(classLoader);
		final NameSpace nameSpace = new NameSpace(classManager, "global");
		_interpreter = new Interpreter(new StringReader(""), System.out, System.err, false, nameSpace, null, null);
		try {
			final This callable = (This) _interpreter.eval("__execute() { " + source + "\n" + "}\n" + "return this;");
			_method = callable.getNameSpace().getMethod("__execute", new Class[0], false);
		} catch (final UtilEvalError e) {
			throw new IllegalStateException(e);
		}
	}
	public Object invoke(final Map<String, ?> context) throws EvalError {
		final NameSpace nameSpace = new NameSpace(_interpreter.getClassManager(), "BeanshellExecutable");
		nameSpace.setParent(_interpreter.getNameSpace());
		final BshMethod method = new BshMethod(_method.getName(), _method.getReturnType(), _method.getParameterNames(), _method.getParameterTypes(), _method.methodBody, nameSpace, _method.getModifiers());
		for (final Map.Entry<String, ?> entry : context.entrySet()) {
			try {
				nameSpace.setVariable(entry.getKey(), entry.getValue(), false);
			} catch (final UtilEvalError e) {
				throw new EvalError("cannot set variable '" + entry.getKey() + '\'', null, null, e);
			}
		}
		final Object result = method.invoke(new Object[0], new BshEvaluatingVisitor(null, _interpreter));
		if (result instanceof Primitive) {
			if (( (Primitive) result).getType() == Void.TYPE) {
				return null;
			}
			return ( (Primitive) result).getValue();
		}
		return result;
	}
	public void setOut(final PrintStream value) {
		_interpreter.setOut(value);
	}
	public void setErr(final PrintStream value) {
		_interpreter.setErr(value);
	}
}
package com.jitlogic.zorka.core;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import com.jitlogic.zorka.common.ZorkaAgent;
import com.jitlogic.zorka.common.ZorkaService;
import com.jitlogic.zorka.common.stats.AgentDiagnostics;
import com.jitlogic.zorka.core.util.ObjectDumper;
import com.jitlogic.zorka.common.util.ZorkaUtil;
import bsh.EvalError;
import bsh.Interpreter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static com.jitlogic.zorka.core.AgentConfigProps.SCRIPTS_DIR_PROP;
import static com.jitlogic.zorka.core.AgentConfigProps.SCRIPTS_PROP;
/**
 * This is central part of Zorka agent - it processes actual queries and executes BSH scripts.
 *
 * @author rafal.lewczuk@jitlogic.com
 */
public class ZorkaBshAgent implements ZorkaAgent, ZorkaService {
    /**
     * Logger
     */
    private final Logger log = LoggerFactory.getLogger(this.getClass());
    /**
     * Beanshell interpreter
     */
    private Interpreter interpreter;
    /**
     * Executor for asynchronous processing queries
     */
    private Executor connExecutor;
    private ExecutorService mainExecutor;
    private AgentConfig config;
    private long timeout;
    private boolean initialized;
    private Set<String> loadedScripts = new HashSet<String>();
    private Map<String,String> probeMap = new ConcurrentHashMap<String, String>();
    /**
     * Standard constructor.
     *
     * @param connExecutor connExecutor for asynchronous processing queries
     */
    public ZorkaBshAgent(Executor connExecutor, ExecutorService mainExecutor,
                         long timeout, AgentConfig config) {
        this.interpreter = new Interpreter();
        this.connExecutor = connExecutor;
        this.mainExecutor = mainExecutor;
        this.timeout = timeout;
        this.config = config;
        probeSetup();
    }
    /**
     * Installs object in beanshell namespace. Typically used to install
     * objects as function libraries.
     *
     * @param name name in beanshell namespace
     * @param obj  object
     */
    public void put(String name, Object obj) {
        try {
            interpreter.set(name, obj);
        } catch (EvalError e) {
            log.error("Error adding module '{}' to global namespace", name, e);
        }
    }
    public Object get(String name) {
        try {
            return interpreter.get(name);
        } catch (EvalError e) {
            return null;
        }
    }
    /**
     * Evaluates BSH query. If error occurs, it returns exception text with stack dump.
     *
     * @param expr query string
     * @return response string
     */
    @Override
    public String query(String expr) {
        try {
            return "" + interpreter.eval(expr); // TODO proper object-to-string conversion
        } catch (EvalError e) {
            log.error("Error evaluating '{}': ", expr, e);
            return ObjectDumper.errorDump(e);
        }
    }
    /**
     * Evaluates BSH query. If evaluation error occurs, it is thrown out as EvalError.
     *
     * @param expr query string
     * @return evaluation result
     * @throws EvalError
     */
    public Object eval(String expr) throws EvalError {
        return interpreter.eval(expr);
    }
    /**
     * Executes query asynchronously. Result is returned via callback object.
     *
     * @param expr     BSH expression
     * @param callback callback object
     */
    public void exec(String expr, ZorkaCallback callback) {
        log.debug("Processing request BSH expression: {}", expr);
        ZorkaBshWorker worker = new ZorkaBshWorker(mainExecutor, timeout, this, expr, callback);
        connExecutor.execute(worker);
    }
    /**
     * Loads and executes beanshell script.
     *
     * @param script path to script
     */
    public synchronized String loadScript(String script) {
        String path = ZorkaUtil.path(config.stringCfg(SCRIPTS_DIR_PROP, null), script);
        Reader rdr = null;
        try {
            if (new File(path).canRead()) {
                log.info("Executing script: {}", path);
                interpreter.source(path);
                loadedScripts.add(script);
            } else {
                InputStream is = getClass().getResourceAsStream(
                        "/com/jitlogic/zorka/scripts"+(script.startsWith("/") ? "" : "/")+script);
                if (is != null) {
                    log.info("Executing internal script: {}", script);
                    rdr = new InputStreamReader(is);
                    interpreter.eval(rdr, interpreter.getNameSpace(), script);
                    loadedScripts.add(script);
                } else {
                    log.error("Cannot find script: {}", script);
                }
            }
            return "OK";
        } catch (Exception e) {
            log.error("Error loading script {}", script, e);
            AgentDiagnostics.inc(AgentDiagnostics.CONFIG_ERRORS);
            return "Error: " + e.getMessage();
        } catch (EvalError e) {
            log.error("Error executing script {}", script, e);
            AgentDiagnostics.inc(AgentDiagnostics.CONFIG_ERRORS);
            return "Error: " + e.getMessage();
        } finally {
            if (rdr != null) {
                try {
                    rdr.close();
                } catch (IOException e) {
                    log.error("Error closing script {}", script, e);
                }
            }
        }
    }
    public synchronized String require(String script) {
        if (!loadedScripts.contains(script)) {
            return loadScript(script);
        } else {
            if (log.isDebugEnabled()) {
                log.debug("Skipping already loaded script: {}", script);
            }
            return "Already loaded.";
        }
    }
    public Set<String> getLoadedScripts() {
        return loadedScripts;
    }
    public Map<String,String> getProbeMap() {
        return probeMap;
    }
    public void probeSetup() {
        Properties props = config.getProperties();
        for (String s : props.stringPropertyNames()) {
            if (s.startsWith("auto.")) {
                probeMap.put(s.substring(5), config.get(s));
            }
        }
    }
    public synchronized void probe(String className) {
        int nhits = 0;
        for (Map.Entry<String,String> e : probeMap.entrySet()) {
            if (className.startsWith(e.getKey())) {
                require(e.getValue().trim());
                nhits++;
            }
        }
        if (nhits > 0) {
            Iterator<Map.Entry<String, String>> iter = probeMap.entrySet().iterator();
            while (iter.hasNext()) {
                if (loadedScripts.contains(iter.next().getValue())) {
                    iter.remove();
                }
            }
        }
    }
    /**
     * Loads and executes all script in script directory.
     */
    public void loadScripts() {
        String scriptsDir = config.stringCfg(SCRIPTS_DIR_PROP, null);
        if (scriptsDir == null) {
            log.error("Scripts directory not set. Internal error ?!?");
            return;
        }
        List<String> scripts = config.listCfg(SCRIPTS_PROP);
        if (scripts != null) {
            for (String script : scripts) {
                require(script);
            }
        }
    }
    public synchronized void reloadScripts() {
        loadedScripts.clear();
        AgentDiagnostics.clear(AgentDiagnostics.CONFIG_ERRORS);
        loadScripts();
    }
    public void initialize() {
        loadScripts();
        initialized = true;
    }
    public boolean isInitialized() {
        return initialized;
    }
    public void restart() {
        interpreter = new Interpreter();
        put("PROP", AgentConfigProps.PROPS);
    }
    @Override
    public void shutdown() {
    }
}
package bsh;
/**
	Console startup class.
*/
public class Console  
{
	public static void main( String args[] ) {
		if ( !Capabilities.classExists( "bsh.util.Util" ) )
			System.out.println("Can't find the BeanShell utilities...");
		if ( Capabilities.haveSwing() ) 
		{
			//bsh.util.Util.startSplashScreen();
			try {
				new Interpreter().eval("desktop()");
			} catch ( EvalError e ) {
				System.err.println("Couldn't start desktop: "+e);
			}
		} else {
			System.err.println(
				"Can't find javax.swing package: "
			+" An AWT based Console is available but not built by default.");
			//AWTConsole.main( args );
		}
	}
}