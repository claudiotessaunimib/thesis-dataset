package bsh;
import bsh.ast.*;
import bsh.interpreter.BshEvaluatingVisitor;
import bsh.interpreter.BshInterpreterUtil;
import org.objectweb.asm.*;
import org.objectweb.asm.Type;
import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;

public class ClassGeneratorUtil implements Opcodes {

	static final String BSHSTATIC = "_bshStatic";

	private static final String BSHTHIS = "_bshThis";

	static final String BSHSUPER = "_bshSuper";

	static final String BSHINIT = "_bshInstanceInitializer";

	private static final String BSHCONSTRUCTORS = "_bshConstructors";

	private static final int DEFAULTCONSTRUCTOR = -1;
	private static final String OBJECT = "Ljava/lang/Object;";
	private final String className;

	private final String fqClassName;
	private final Class superClass;
	private final String superClassName;
	private final Class[] interfaces;
	private final Variable[] vars;
	private final Constructor[] superConstructors;
	private final DelayedEvalBshMethod[] constructors;
	private final DelayedEvalBshMethod[] methods;
	private final NameSpace classStaticNameSpace;
	private final Modifiers classModifiers;
	private boolean isInterface;

	public ClassGeneratorUtil(Modifiers classModifiers, String className, String packageName, Class superClass, Class[] interfaces, Variable[] vars, DelayedEvalBshMethod[] bshmethods, NameSpace classStaticNameSpace, boolean isInterface) {
		this.classModifiers = classModifiers;
		this.className = className;
		if (packageName != null) {
			this.fqClassName = packageName.replace('.', '/') + "/" + className;
		} else {
			this.fqClassName = className;
		}
		if (superClass == null) {
			superClass = Object.class;
		}
		this.superClass = superClass;
		this.superClassName = Type.getInternalName(superClass);
		if (interfaces == null) {
			interfaces = new Class[0];
		}
		this.interfaces = interfaces;
		this.vars = vars;
		this.classStaticNameSpace = classStaticNameSpace;
		this.superConstructors = superClass.getDeclaredConstructors();

		List consl = new ArrayList();
		List methodsl = new ArrayList();
		String classBaseName = getBaseName(className); 
		for (DelayedEvalBshMethod bshmethod : bshmethods) {
			if (bshmethod.getName().equals(classBaseName)) {
				consl.add(bshmethod);
			} else {
				methodsl.add(bshmethod);
			}
		}
		this.constructors = (DelayedEvalBshMethod[]) consl.toArray(new DelayedEvalBshMethod[consl.size()]);
		this.methods = (DelayedEvalBshMethod[]) methodsl.toArray(new DelayedEvalBshMethod[methodsl.size()]);
		try {
			classStaticNameSpace.setLocalVariable(BSHCONSTRUCTORS, constructors, false);
		} catch (UtilEvalError e) {
			throw new InterpreterError("can't set cons var");
		}
		this.isInterface = isInterface;
	}

	public byte[] generateClass() {

		int classMods = getASMModifiers(classModifiers) | ACC_PUBLIC;
		if (isInterface) {
			classMods |= (ACC_INTERFACE|ACC_ABSTRACT);
		}
		String[] interfaceNames = new String[interfaces.length + (isInterface ? 0 : 1)]; 
		for (int i = 0; i < interfaces.length; i++) {
			interfaceNames[i] = Type.getInternalName(interfaces[i]);
		}
		if ( ! isInterface) {
			interfaceNames[interfaces.length] = Type.getInternalName(GeneratedClass.class);
		}
		String sourceFile = "BeanShell Generated via ASM (www.objectweb.org)";
		ClassWriter cw = new ClassWriter(0);
		cw.visit(Opcodes.V1_6, classMods, fqClassName, null, superClassName, interfaceNames);
		if ( ! isInterface) {

			generateField(BSHTHIS + className, "Lbsh/This;", ACC_PUBLIC, cw);

			generateField(BSHSTATIC + className, "Lbsh/This;", ACC_PUBLIC + ACC_STATIC, cw);
		}

		for (Variable var : vars) {
			String type = var.getTypeDescriptor();

			if (var.hasModifier("private") || type == null) {
				continue;
			}
			int modifiers;
			if (isInterface) {
				modifiers = ACC_PUBLIC | ACC_STATIC | ACC_FINAL;
			} else {
				modifiers = getASMModifiers(var.getModifiers());
			}
			generateField(var.getName(), type, modifiers, cw);
		}

		boolean hasConstructor = false;
		for (int i = 0; i < constructors.length; i++) {

			if (constructors[i].hasModifier("private")) {
				continue;
			}
			int modifiers = getASMModifiers(constructors[i].getModifiers());
			generateConstructor(i, constructors[i].getParamTypeDescriptors(), modifiers, cw);
			hasConstructor = true;
		}

		if ( ! isInterface &&  ! hasConstructor) {
			generateConstructor(DEFAULTCONSTRUCTOR, new String[0], ACC_PUBLIC, cw);
		}

		for (DelayedEvalBshMethod method : methods) {
			String returnType = method.getReturnTypeDescriptor();

			if (method.hasModifier("private") ) {
				continue;
			}
			int modifiers = getASMModifiers(method.getModifiers());
			if (isInterface) {
				modifiers |= (ACC_PUBLIC | ACC_ABSTRACT);
			}
			generateMethod(className, fqClassName, method.getName(), returnType, method.getParamTypeDescriptors(), modifiers, cw);
			boolean isStatic = (modifiers & ACC_STATIC) > 0;
			boolean overridden = classContainsMethod(superClass, method.getName(), method.getParamTypeDescriptors());
			if (!isStatic && overridden) {
				generateSuperDelegateMethod(superClassName, method.getName(), returnType, method.getParamTypeDescriptors(), modifiers, cw);
			}
		}
		return cw.toByteArray();
	}

	private static int getASMModifiers(Modifiers modifiers) {
		int mods = 0;
		if (modifiers == null) {
			return mods;
		}
		if (modifiers.hasModifier("public")) {
			mods += ACC_PUBLIC;
		}
		if (modifiers.hasModifier("protected")) {
			mods += ACC_PROTECTED;
		}
		if (modifiers.hasModifier("static")) {
			mods += ACC_STATIC;
		}
		if (modifiers.hasModifier("synchronized")) {
			mods += ACC_SYNCHRONIZED;
		}
		if (modifiers.hasModifier("abstract")) {
			mods += ACC_ABSTRACT;
		}
		return mods;
	}

	private static void generateField(String fieldName, String type, int modifiers, ClassWriter cw) {
		cw.visitField(modifiers, fieldName, type, null, null);
	}

	private static void generateMethod(String className, String fqClassName, String methodName, String returnType, String[] paramTypes, int modifiers, ClassWriter cw) {
		String[] exceptions = null;
		boolean isStatic = (modifiers & ACC_STATIC) != 0;
		if (returnType == null) 
		{
			returnType = OBJECT;
		}
		String methodDescriptor = getMethodDescriptor(returnType, paramTypes);

		MethodVisitor cv = cw.visitMethod(modifiers, methodName, methodDescriptor, null, exceptions);
		if ((modifiers & ACC_ABSTRACT) != 0) {
			return;
		}

		if (isStatic) {
			cv.visitFieldInsn(GETSTATIC, fqClassName, BSHSTATIC + className, "Lbsh/This;");
		} else {

			cv.visitVarInsn(ALOAD, 0);

			cv.visitFieldInsn(GETFIELD, fqClassName, BSHTHIS + className, "Lbsh/This;");
		}

		cv.visitLdcInsn(methodName);

		generateParameterReifierCode(paramTypes, isStatic, cv);

		cv.visitInsn(ACONST_NULL); 
		cv.visitInsn(ACONST_NULL); 
		cv.visitInsn(ACONST_NULL); 

		cv.visitInsn(ICONST_1);

		cv.visitMethodInsn(INVOKEVIRTUAL, "bsh/This", "invokeMethod", Type.getMethodDescriptor(Type.getType(Object.class),
                new Type[]{Type.getType(String.class), Type.getType(Object[].class), Type.getType(Interpreter.class),
                        Type.getType(CallStack.class), Type.getType(SimpleNode.class), Type.getType(Boolean.TYPE)}));

		cv.visitMethodInsn(INVOKESTATIC, "bsh/Primitive", "unwrap", "(Ljava/lang/Object;)Ljava/lang/Object;");

		generateReturnCode(returnType, cv);

	    cv.visitMaxs(20, 20);
	}

	public void generateConstructor(int index, String[] paramTypes, int modifiers, ClassWriter cw) {

		final int argsVar = paramTypes.length + 1;

		final int consArgsVar = paramTypes.length + 2;
		String[] exceptions = null;
		String methodDescriptor = getMethodDescriptor("V", paramTypes);

		MethodVisitor cv = cw.visitMethod(modifiers, "<init>", methodDescriptor, null, exceptions);

		generateParameterReifierCode(paramTypes, false, cv);
		cv.visitVarInsn(ASTORE, argsVar);

		generateConstructorSwitch(index, argsVar, consArgsVar, cv);

		cv.visitVarInsn(ALOAD, 0);

		cv.visitLdcInsn(className);

		cv.visitVarInsn(ALOAD, argsVar);

		cv.visitMethodInsn(INVOKESTATIC, "bsh/ClassGeneratorUtil", "initInstance", "(L" + GeneratedClass.class.getName().replace('.', '/') + ";Ljava/lang/String;[Ljava/lang/Object;)V");
		cv.visitInsn(RETURN);

		cv.visitMaxs(20, 20);
	}

	void generateConstructorSwitch(int consIndex, int argsVar, int consArgsVar, MethodVisitor cv) {
		Label defaultLabel = new Label();
		Label endLabel = new Label();
		int cases = superConstructors.length + constructors.length;
		Label[] labels = new Label[cases];
		for (int i = 0; i < cases; i++) {
			labels[i] = new Label();
		}

		cv.visitLdcInsn(superClass.getName()); 

		cv.visitFieldInsn(GETSTATIC, fqClassName, BSHSTATIC + className, "Lbsh/This;");

		cv.visitVarInsn(ALOAD, argsVar);

		cv.visitIntInsn(BIPUSH, consIndex);

		cv.visitMethodInsn(INVOKESTATIC, "bsh/ClassGeneratorUtil", "getConstructorArgs", "(Ljava/lang/String;Lbsh/This;[Ljava/lang/Object;I)" + "Lbsh/ClassGeneratorUtil$ConstructorArgs;");

		cv.visitVarInsn(ASTORE, consArgsVar);

		cv.visitVarInsn(ALOAD, consArgsVar);
		cv.visitFieldInsn(GETFIELD, "bsh/ClassGeneratorUtil$ConstructorArgs", "selector", "I");

		cv.visitTableSwitchInsn(0, cases - 1, defaultLabel, labels);

		int index = 0;
		for (int i = 0; i < superConstructors.length; i++, index++) {
			doSwitchBranch(index, superClassName, getTypeDescriptors(superConstructors[i].getParameterTypes()), endLabel, labels, consArgsVar, cv);
		}
		for (int i = 0; i < constructors.length; i++, index++) {
			doSwitchBranch(index, fqClassName, constructors[i].getParamTypeDescriptors(), endLabel, labels, consArgsVar, cv);
		}

		cv.visitLabel(defaultLabel);

		cv.visitVarInsn(ALOAD, 0); 
		cv.visitMethodInsn(INVOKESPECIAL, superClassName, "<init>", "()V");

		cv.visitLabel(endLabel);
	}

	private static void doSwitchBranch(int index, String targetClassName, String[] paramTypes, Label endLabel, Label[] labels, int consArgsVar, MethodVisitor cv) {
		cv.visitLabel(labels[index]);

		cv.visitVarInsn(ALOAD, 0); 

		for (String type : paramTypes) {
			final String method;
			if (type.equals("Z")) {
				method = "getBoolean";
			} else if (type.equals("B")) {
				method = "getByte";
			} else if (type.equals("C")) {
				method = "getChar";
			} else if (type.equals("S")) {
				method = "getShort";
			} else if (type.equals("I")) {
				method = "getInt";
			} else if (type.equals("J")) {
				method = "getLong";
			} else if (type.equals("D")) {
				method = "getDouble";
			} else if (type.equals("F")) {
				method = "getFloat";
			} else {
				method = "getObject";
			}

			cv.visitVarInsn(ALOAD, consArgsVar); 
			String className = "bsh/ClassGeneratorUtil$ConstructorArgs";
			String retType;
			if (method.equals("getObject")) {
				retType = OBJECT;
			} else {
				retType = type;
			}
			cv.visitMethodInsn(INVOKEVIRTUAL, className, method, "()" + retType);

			if (method.equals("getObject")) {
				cv.visitTypeInsn(CHECKCAST, descriptorToClassName(type));
			}
		}

		String descriptor = getMethodDescriptor("V", paramTypes);
		cv.visitMethodInsn(INVOKESPECIAL, targetClassName, "<init>", descriptor);
		cv.visitJumpInsn(GOTO, endLabel);
	}
	private static String getMethodDescriptor(String returnType, String[] paramTypes) {
		StringBuilder sb = new StringBuilder("(");
		for (String paramType : paramTypes) {
			sb.append(paramType);
		}
		sb.append(')').append(returnType);
		return sb.toString();
	}

	private static void generateSuperDelegateMethod(String superClassName, String methodName, String returnType, String[] paramTypes, int modifiers, ClassWriter cw) {
		String[] exceptions = null;
		if (returnType == null) 
		{
			returnType = OBJECT;
		}
		String methodDescriptor = getMethodDescriptor(returnType, paramTypes);

		MethodVisitor cv = cw.visitMethod(modifiers, "_bshSuper" + methodName, methodDescriptor, null, exceptions);
		cv.visitVarInsn(ALOAD, 0);

		int localVarIndex = 1;
		for (String paramType : paramTypes) {
			if (isPrimitive(paramType)) {
				cv.visitVarInsn(ILOAD, localVarIndex);
			} else {
				cv.visitVarInsn(ALOAD, localVarIndex);
			}
			localVarIndex += ((paramType.equals("D") || paramType.equals("J")) ? 2 : 1);
		}
		cv.visitMethodInsn(INVOKESPECIAL, superClassName, methodName, methodDescriptor);
		generatePlainReturnCode(returnType, cv);

		cv.visitMaxs(20, 20);
	}
	boolean classContainsMethod(Class clas, String methodName, String[] paramTypes) {
		while (clas != null) {
			Method[] methods = clas.getDeclaredMethods();
			for (Method method : methods) {
				if (method.getName().equals(methodName)) {
					String[] methodParamTypes = getTypeDescriptors(method.getParameterTypes());
					boolean found = true;
					for (int j = 0; j < methodParamTypes.length; j++) {
						if (!paramTypes[j].equals(methodParamTypes[j])) {
							found = false;
							break;
						}
					}
					if (found) {
						return true;
					}
				}
			}
			clas = clas.getSuperclass();
		}
		return false;
	}

	private static void generatePlainReturnCode(String returnType, MethodVisitor cv) {
		if (returnType.equals("V")) {
			cv.visitInsn(RETURN);
		} else if (isPrimitive(returnType)) {
			int opcode = IRETURN;
			if (returnType.equals("D")) {
				opcode = DRETURN;
			} else if (returnType.equals("F")) {
				opcode = FRETURN;
			} else if (returnType.equals("J"))  
			{
				opcode = LRETURN;
			}
			cv.visitInsn(opcode);
		} else {
			cv.visitTypeInsn(CHECKCAST, descriptorToClassName(returnType));
			cv.visitInsn(ARETURN);
		}
	}

	private static void generateParameterReifierCode(String[] paramTypes, boolean isStatic, final MethodVisitor cv) {
		cv.visitIntInsn(SIPUSH, paramTypes.length);
		cv.visitTypeInsn(ANEWARRAY, "java/lang/Object");
		int localVarIndex = isStatic ? 0 : 1;
		for (int i = 0; i < paramTypes.length; ++i) {
			String param = paramTypes[i];
			cv.visitInsn(DUP);
			cv.visitIntInsn(SIPUSH, i);
			if (isPrimitive(param)) {
				int opcode;
				if (param.equals("F")) {
					opcode = FLOAD;
				} else if (param.equals("D")) {
					opcode = DLOAD;
				} else if (param.equals("J")) {
					opcode = LLOAD;
				} else {
					opcode = ILOAD;
				}
				String type = "bsh/Primitive";
				cv.visitTypeInsn(NEW, type);
				cv.visitInsn(DUP);
				cv.visitVarInsn(opcode, localVarIndex);
				String desc = param; 
				cv.visitMethodInsn(INVOKESPECIAL, type, "<init>", "(" + desc + ")V");
			} else {

				cv.visitVarInsn(ALOAD, localVarIndex);
			}
			cv.visitInsn(AASTORE);
			localVarIndex += ((param.equals("D") || param.equals("J")) ? 2 : 1);
		}
	}

	private static void generateReturnCode(String returnType, MethodVisitor cv) {
		if (returnType.equals("V")) {
			cv.visitInsn(POP);
			cv.visitInsn(RETURN);
		} else if (isPrimitive(returnType)) {
			int opcode = IRETURN;
			String type;
			String meth;
			if (returnType.equals("B")) {
				type = "java/lang/Byte";
				meth = "byteValue";
			} else if (returnType.equals("I")) {
				type = "java/lang/Integer";
				meth = "intValue";
			} else if (returnType.equals("Z")) {
				type = "java/lang/Boolean";
				meth = "booleanValue";
			} else if (returnType.equals("D")) {
				opcode = DRETURN;
				type = "java/lang/Double";
				meth = "doubleValue";
			} else if (returnType.equals("F")) {
				opcode = FRETURN;
				type = "java/lang/Float";
				meth = "floatValue";
			} else if (returnType.equals("J")) {
				opcode = LRETURN;
				type = "java/lang/Long";
				meth = "longValue";
			} else if (returnType.equals("C")) {
				type = "java/lang/Character";
				meth = "charValue";
			} else  {
				type = "java/lang/Short";
				meth = "shortValue";
			}
			String desc = returnType;
			cv.visitTypeInsn(CHECKCAST, type); 
			cv.visitMethodInsn(INVOKEVIRTUAL, type, meth, "()" + desc);
			cv.visitInsn(opcode);
		} else {
			cv.visitTypeInsn(CHECKCAST, descriptorToClassName(returnType));
			cv.visitInsn(ARETURN);
		}
	}

	public static ConstructorArgs getConstructorArgs(String superClassName, This classStaticThis, Object[] consArgs, int index) {
		DelayedEvalBshMethod[] constructors;
		try {
			constructors = (DelayedEvalBshMethod[]) classStaticThis.getNameSpace().getVariable(BSHCONSTRUCTORS);
		} catch (Exception e) {
			throw new InterpreterError("unable to get instance initializer: " + e);
		}
		if (index == DEFAULTCONSTRUCTOR) 
		{
			return ConstructorArgs.DEFAULT;
		} 
		DelayedEvalBshMethod constructor = constructors[index];
		if (constructor.methodBody.jjtGetNumChildren() == 0) {
			return ConstructorArgs.DEFAULT;
		} 

		String altConstructor = null;
		BSHArguments argsNode = null;
		SimpleNode firstStatement = (SimpleNode) constructor.methodBody.jjtGetChild(0);
		if (firstStatement instanceof BSHPrimaryExpression) {
			firstStatement = (SimpleNode) firstStatement.jjtGetChild(0);
		}
		if (firstStatement instanceof BSHMethodInvocation) {
			BSHMethodInvocation methodNode = (BSHMethodInvocation) firstStatement;
			BSHAmbiguousName methodName = methodNode.getNameNode();
			if (methodName.text.equals("super") || methodName.text.equals("this")) {
				altConstructor = methodName.text;
				argsNode = methodNode.getArgsNode();
			}
		}
		if (altConstructor == null) {
			return ConstructorArgs.DEFAULT;
		} 

		NameSpace consArgsNameSpace = new NameSpace(classStaticThis.getNameSpace(), "consArgs");
		String[] consArgNames = constructor.getParameterNames();
		Class[] consArgTypes = constructor.getParameterTypes();
		for (int i = 0; i < consArgs.length; i++) {
			try {
				consArgsNameSpace.setTypedVariable(consArgNames[i], consArgTypes[i], consArgs[i], null);
			} catch (UtilEvalError e) {
				throw new InterpreterError("err setting local cons arg:" + e);
			}
		}

		CallStack callstack = new CallStack();
		callstack.push(consArgsNameSpace);
		Object[] args;
		Interpreter interpreter = classStaticThis.declaringInterpreter;
		try {
			args = new BshEvaluatingVisitor(callstack, interpreter).getArguments(argsNode);
		} catch (EvalError e) {
			throw new InterpreterError("Error evaluating constructor args: " + e);
		}
		Class[] argTypes = Types.getTypes(args);
		args = Primitive.unwrap(args);
		Class superClass = interpreter.getClassManager().classForName(superClassName);
		if (superClass == null) {
			throw new InterpreterError("can't find superclass: " + superClassName);
		}
		Constructor[] superCons = superClass.getDeclaredConstructors();

		if (altConstructor.equals("super")) {
			int i = Reflect.findMostSpecificConstructorIndex(argTypes, superCons);
			if (i == -1) {
				throw new InterpreterError("can't find constructor for args!");
			}
			return new ConstructorArgs(i, args);
		}

		Class[][] candidates = new Class[constructors.length][];
		for (int i = 0; i < candidates.length; i++) {
			candidates[i] = constructors[i].getParameterTypes();
		}
		int i = Reflect.findMostSpecificSignature(argTypes, candidates);
		if (i == -1) {
			throw new InterpreterError("can't find constructor for args 2!");
		}

		int selector = i + superCons.length;
		int ourSelector = index + superCons.length;

		if (selector == ourSelector) {
			throw new InterpreterError("Recusive constructor call.");
		}
		return new ConstructorArgs(selector, args);
	}
	private static final ThreadLocal<NameSpace> CONTEXT_NAMESPACE = new ThreadLocal<NameSpace>();
	private static final ThreadLocal<Interpreter> CONTEXT_INTERPRETER = new ThreadLocal<Interpreter>();

	public static void registerConstructorContext(CallStack callstack, Interpreter interpreter) {
		if (callstack != null) {
			CONTEXT_NAMESPACE.set(callstack.top());
		} else {
			CONTEXT_NAMESPACE.remove();
		}
		if (interpreter != null) {
			CONTEXT_INTERPRETER.set(interpreter);
		} else {
			CONTEXT_INTERPRETER.remove();
		}
	}

	public static void initInstance(GeneratedClass instance, String className, Object[] args) {
		Class[] sig = Types.getTypes(args);
		CallStack callstack = new CallStack();
		Interpreter interpreter;
		NameSpace instanceNameSpace;

		This instanceThis = getClassInstanceThis(instance, className);

		if (instanceThis == null) {

			This classStaticThis = getClassStaticThis(instance.getClass(), className);
			interpreter = CONTEXT_INTERPRETER.get();
			if (interpreter == null) {
				interpreter = classStaticThis.declaringInterpreter;
			}

			BSHBlock instanceInitBlock;
			try {
				instanceInitBlock = (BSHBlock) classStaticThis.getNameSpace().getVariable(BSHINIT);
			} catch (Exception e) {
				throw new InterpreterError("unable to get instance initializer: " + e);
			}

			if (CONTEXT_NAMESPACE.get() != null) {
				instanceNameSpace = classStaticThis.getNameSpace().copy();
				instanceNameSpace.setParent(CONTEXT_NAMESPACE.get());
			} else {
				instanceNameSpace = new NameSpace(classStaticThis.getNameSpace(), className); 
			}
			instanceNameSpace.isClass = true;

			instanceThis = instanceNameSpace.getThis(interpreter);
			try {
				LHS lhs = Reflect.getLHSObjectField(instance, BSHTHIS + className);
				lhs.assign(instanceThis, false);
			} catch (Exception e) {
				throw new InterpreterError("Error in class gen setup: " + e);
			}

			instanceNameSpace.setClassInstance(instance);

			callstack.push(instanceNameSpace);

			try { 
				new BshEvaluatingVisitor(callstack, interpreter).evalBlock(instanceInitBlock, true, ClassGenerator.ClassNodeFilter.CLASSINSTANCE);
			} catch (Exception e) {
				throw new InterpreterError("Error in class initialization: " + e, e);
			}
			callstack.pop();
		} else {

			interpreter = instanceThis.declaringInterpreter;
			instanceNameSpace = instanceThis.getNameSpace();
		}

		String constructorName = getBaseName(className);
		try {

			BshMethod constructor = instanceNameSpace.getMethod(constructorName, sig, true);

			if (args.length > 0 && constructor == null) {
				throw new InterpreterError("Can't find constructor: " + className);
			}

			if (constructor != null) {
				constructor.invoke(args, new BshEvaluatingVisitor(callstack,  interpreter),
                        null, false);
			}
		} catch (Throwable e) {
			if (e instanceof TargetError) {
				e = (Exception) ((TargetError) e).getTarget();
			}
			if (e instanceof InvocationTargetException) {
				e = (Exception) ((InvocationTargetException) e).getTargetException();
			}
			throw new InterpreterError("Error in class initialization: " + e);
		}
	}

	private static This getClassStaticThis(Class clas, String className) {
		try {
			return (This) Reflect.getStaticFieldValue(clas, BSHSTATIC + className);
		} catch (Exception e) {
			throw new InterpreterError("Unable to get class static space: " + e);
		}
	}

	static This getClassInstanceThis(Object instance, String className) {
		try {
			Object o = Reflect.getObjectFieldValue(instance, BSHTHIS + className);
			return (This) Primitive.unwrap(o); 
		} catch (Exception e) {
			throw new InterpreterError("Generated class: Error getting This" + e);
		}
	}

	private static boolean isPrimitive(String typeDescriptor) {
		return typeDescriptor.length() == 1; 
	}
	private static String[] getTypeDescriptors(Class[] cparams) {
		String[] sa = new String[cparams.length];
		for (int i = 0; i < sa.length; i++) {
			sa[i] = BshInterpreterUtil.getTypeDescriptor(cparams[i]);
		}
		return sa;
	}

	private static String descriptorToClassName(String s) {
		if (s.startsWith("[") || !s.startsWith("L")) {
			return s;
		}
		return s.substring(1, s.length() - 1);
	}
	private static String getBaseName(String className) {
		int i = className.indexOf("$");
		if (i == -1) {
			return className;
		}
		return className.substring(i + 1);
	}

	public static class ConstructorArgs {

		public static final ConstructorArgs DEFAULT = new ConstructorArgs();
		public int selector = DEFAULTCONSTRUCTOR;
		Object[] args;
		int arg;

		ConstructorArgs() {
		}
		ConstructorArgs(int selector, Object[] args) {
			this.selector = selector;
			this.args = args;
		}
		Object next() {
			return args[arg++];
		}
		public boolean getBoolean() {
			return (Boolean) next();
		}
		public byte getByte() {
			return (Byte) next();
		}
		public char getChar() {
			return (Character) next();
		}
		public short getShort() {
			return (Short) next();
		}
		public int getInt() {
			return (Integer) next();
		}
		public long getLong() {
			return (Long) next();
		}
		public double getDouble() {
			return (Double) next();
		}
		public float getFloat() {
			return (Float) next();
		}
		public Object getObject() {
			return next();
		}
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.*;
import java.util.Map;
import java.util.HashMap;

public final class This implements java.io.Serializable, Runnable 
{

	final NameSpace namespace;

	transient Interpreter declaringInterpreter;

	private Map<Integer,Object> interfaces;
	private final InvocationHandler invocationHandler = new Handler();

    static This getThis( 
		NameSpace namespace, Interpreter declaringInterpreter ) 
	{
		return new This( namespace, declaringInterpreter );
    }

	public Object getInterface( Class clas ) 
	{
		return getInterface( new Class[] { clas } );
	}

	public Object getInterface( Class [] ca ) 
	{
		if ( interfaces == null )
			interfaces = new HashMap<Integer,Object>();

		int hash = 21;
		for(int i=0; i<ca.length; i++)
			hash *= ca[i].hashCode() + 3;
		Integer hashKey = new Integer(hash);
		Object interf = interfaces.get( hashKey );
		if ( interf == null ) 
		{
			ClassLoader classLoader = ca[0].getClassLoader(); 
			interf = Proxy.newProxyInstance( 
				classLoader, ca, invocationHandler );
			interfaces.put( hashKey, interf );
		}
		return interf;
	}

	class Handler implements InvocationHandler, java.io.Serializable 
	{
		public Object invoke( Object proxy, Method method, Object[] args ) 
			throws Throwable
		{
			try { 
				return invokeImpl( proxy, method, args );
			} catch ( TargetError te ) {

				Throwable t = te.getTarget();
				Class<? extends Throwable> c = t.getClass();
				String msg = t.getMessage();
				try {
					Throwable t2 = msg==null 
						? c.getConstructor().newInstance()
						: c.getConstructor(String.class).newInstance(msg)
					;
					t2.initCause(te);
					throw t2;
				} catch(NoSuchMethodException e) {
					throw t;
				}
			} catch ( EvalError ee ) {

				if ( Interpreter.DEBUG ) 
					Interpreter.debug( "EvalError in scripted interface: "
					+ This.this.toString() + ": "+ ee );
				throw ee;
			}
		}
		public Object invokeImpl( Object proxy, Method method, Object[] args ) 
			throws EvalError 
		{
			String methodName = method.getName();
			CallStack callstack = new CallStack( namespace );

			BshMethod equalsMethod = null;
			try {
				equalsMethod = namespace.getMethod( 
					"equals", new Class [] { Object.class } );
			} catch ( UtilEvalError e ) { }
			if ( methodName.equals("equals" ) && equalsMethod == null ) {
				Object obj = args[0];
				return proxy == obj;
			}

			BshMethod toStringMethod = null;
			try {
				toStringMethod = 
					namespace.getMethod( "toString", new Class [] { } );
			} catch ( UtilEvalError e ) { }
			if ( methodName.equals("toString" ) && toStringMethod == null)
			{
				Class [] ints = proxy.getClass().getInterfaces();

				StringBuilder sb = new StringBuilder( 
					This.this.toString() + "\nimplements:" );
				for(int i=0; i<ints.length; i++)
					sb.append( " "+ ints[i].getName() 
						+ ((ints.length > 1)?",":"") );
				return sb.toString();
			}
			Class [] paramTypes = method.getParameterTypes();
			return Primitive.unwrap( 
				invokeMethod( methodName, Primitive.wrap(args, paramTypes) ) );
		}
	}
	This( NameSpace namespace, Interpreter declaringInterpreter ) {
		this.namespace = namespace; 
		this.declaringInterpreter = declaringInterpreter;

	}
	public NameSpace getNameSpace() {
		return namespace;
	}
	public String toString() {
		return "'this' reference to Bsh object: " + namespace;
	}
	public void run() {
		try {
			invokeMethod( "run", new Object[0] );
		} catch( EvalError e ) {
			declaringInterpreter.error(
				"Exception in runnable:" + e );
		}
	}

	public Object invokeMethod( String name, Object [] args ) 
		throws EvalError
	{

		return invokeMethod( 
			name, args, null, null, null, 
			false );
	}

	public Object invokeMethod( 
		String methodName, Object [] args, 
		Interpreter interpreter, CallStack callstack, SimpleNode callerInfo,
		boolean declaredOnly  ) 
		throws EvalError
	{

		if ( args == null ) {
			args = new Object[0];
		} else {
			Object [] oa = new Object [args.length];
			for(int i=0; i<args.length; i++)
				oa[i] = ( args[i] == null ? Primitive.NULL : args[i] );
			args = oa;
		}
		if ( interpreter == null )
			interpreter = declaringInterpreter;
		if ( callstack == null )
			callstack = new CallStack( namespace );
		if ( callerInfo == null )
			callerInfo = SimpleNode.JAVACODE;

		Class [] types = Types.getTypes( args );
		BshMethod bshMethod = null;
		try {
			bshMethod = namespace.getMethod( methodName, types, declaredOnly );
		} catch ( UtilEvalError e ) {

		}
		if ( bshMethod != null )
			return bshMethod.invoke( args, new BshEvaluatingVisitor(callstack,  interpreter), callerInfo );

		if ( methodName.equals("toString") && args.length==0 )
			return toString();

		if ( methodName.equals("hashCode") && args.length==0 )
			return new Integer(this.hashCode());

		if ( methodName.equals("equals") && args.length==1 ) {
			Object obj = args[0];
			return new Boolean( this == obj );
		}

		if ( methodName.equals("clone") && args.length==0 ) {
			NameSpace ns = new NameSpace(namespace,namespace.getName()+" clone");
			try {
				for( String varName : namespace.getVariableNames() ) {
					ns.setLocalVariable(varName,namespace.getVariable(varName,false),false);
				}
				for( BshMethod method : namespace.getMethods() ) {
					ns.setMethod(method);
				}
			} catch ( UtilEvalError e ) {
				throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
			}
			return ns.getThis(declaringInterpreter);
		}

		try {
			bshMethod = namespace.getMethod( 
				"invoke", new Class [] { null, null } );
		} catch ( UtilEvalError e ) {  }

		if ( bshMethod != null )
			return bshMethod.invoke( new Object [] { methodName, args }, 
				new BshEvaluatingVisitor(callstack,  interpreter), callerInfo );
		throw new EvalError("Method " + 
			StringUtil.methodString( methodName, types ) +
			" not found in bsh scripted object: "+ namespace.getName(), 
			callerInfo, callstack );
	}

	public static void bind( 
		This ths, NameSpace namespace, Interpreter declaringInterpreter ) 
	{ 
		ths.namespace.setParent( namespace ); 
		ths.declaringInterpreter = declaringInterpreter;
	}

	static boolean isExposedThisMethod( String name ) 
	{
		return 
			name.equals("getClass") 
			|| name.equals("invokeMethod")
			|| name.equals("getInterface")

			|| name.equals("wait") 
			|| name.equals("notify")
			|| name.equals("notifyAll");
	}
}
package bsh;
import bsh.ast.*;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.*;
import java.util.*;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
public final class ClassGenerator {
    private static ClassGenerator cg;
	private static final String DEBUG_DIR = System.getProperty("bsh.debugClasses");
	public static ClassGenerator getClassGenerator() {
        if (cg == null) {
            cg = new ClassGenerator();
        }
        return cg;
    }

    public Class generateClass(String name, Modifiers modifiers, Class[] interfaces,
                               Class superClass, BSHBlock block, boolean isInterface,
                               CallStack callstack, Interpreter interpreter) throws EvalError {

        return generateClassImpl(name, modifiers, interfaces, superClass, block, isInterface,
                new BshEvaluatingVisitor(callstack, interpreter));
    }

    public Object invokeSuperclassMethod(BshClassManager bcm, Object instance,
                                         String methodName, Object[] args) throws UtilEvalError,
            ReflectError, InvocationTargetException {

        return invokeSuperclassMethodImpl(bcm, instance, methodName, args);
    }

    public void setInstanceNameSpaceParent(Object instance, String className, NameSpace parent) {
        This ithis = ClassGeneratorUtil.getClassInstanceThis(instance, className);
        ithis.getNameSpace().setParent(parent);
    }

    public static Class generateClassImpl(String name, Modifiers modifiers, Class[] interfaces,
            Class superClass, BSHBlock block, boolean isInterface,
            BshEvaluatingVisitor visitor) throws EvalError {

        try {
            Capabilities.setAccessibility(true);
        } catch (Capabilities.Unavailable e) {
            throw new EvalError("Defining classes currently requires reflective Accessibility.",
                    block, visitor.getCallstack());
        }
        NameSpace enclosingNameSpace = visitor.getCallstack().top();
        String packageName = enclosingNameSpace.getPackage();
        String className = enclosingNameSpace.isClass ? (enclosingNameSpace.getName() + "$" + name) : name;
        String fqClassName = packageName == null ? className : packageName + "." + className;
        BshClassManager bcm = visitor.getInterpreter().getClassManager();

        bcm.definingClass(fqClassName);

        NameSpace classStaticNameSpace = new NameSpace(enclosingNameSpace, className);
        classStaticNameSpace.isClass = true;
        visitor.getCallstack().push(classStaticNameSpace);

        visitor.evalBlock(block, true, ClassNodeFilter.CLASSCLASSES);

        Variable[] variables = getDeclaredVariables(block, visitor, packageName);
        DelayedEvalBshMethod[] methods = getDeclaredMethods(block, visitor, packageName);
        ClassGeneratorUtil classGenerator = new ClassGeneratorUtil(modifiers, className, packageName, superClass, interfaces, variables, methods, classStaticNameSpace, isInterface);
        byte[] code = classGenerator.generateClass();

		if (DEBUG_DIR != null) try {
            FileOutputStream out = new FileOutputStream(DEBUG_DIR + '/' + className + ".class");
            out.write(code);
            out.close();
        } catch (IOException e) {
            throw new IllegalStateException("cannot create file " + DEBUG_DIR + '/' + className + ".class", e);
        }

        Class genClass = bcm.defineClass(fqClassName, code);

        enclosingNameSpace.importClass(fqClassName.replace('$', '.'));
        try {
            classStaticNameSpace.setLocalVariable(ClassGeneratorUtil.BSHINIT, block, false);
        } catch (UtilEvalError e) {
            throw new InterpreterError("unable to init static: " + e);
        }

        classStaticNameSpace.setClassStatic(genClass);

        visitor.evalBlock(block, true, ClassNodeFilter.CLASSSTATIC);
        visitor.getCallstack().pop();
        if ( ! genClass.isInterface()) {

            String bshStaticFieldName = ClassGeneratorUtil.BSHSTATIC + className;
            try {
                LHS lhs = Reflect.getLHSStaticField(genClass, bshStaticFieldName);
                lhs.assign(classStaticNameSpace.getThis(visitor.getInterpreter()), false);
            } catch (Exception e) {
                throw new InterpreterError("Error in class gen setup: " + e);
            }
        }
        bcm.doneDefiningClass(fqClassName);
        return genClass;
    }
    static Variable[] getDeclaredVariables(BSHBlock body, BshEvaluatingVisitor visitor, String defaultPackage) {
        List<Variable> vars = new ArrayList<Variable>();
        for (int child = 0; child < body.jjtGetNumChildren(); child++) {
            SimpleNode node = (SimpleNode) body.jjtGetChild(child);
            if (node instanceof BSHTypedVariableDeclaration) {
                BSHTypedVariableDeclaration tvd = (BSHTypedVariableDeclaration) node;
                Modifiers modifiers = tvd.modifiers;
                String type = visitor.getTypeDescriptor(tvd.getTypeNode(), defaultPackage);
                BSHVariableDeclarator[] vardec = tvd.getDeclarators();
                for (BSHVariableDeclarator aVardec : vardec) {
                    String name = aVardec.name;
                    try {
                        Variable var = new Variable(name, type, null, modifiers);
                        vars.add(var);
                    } catch (UtilEvalError e) {

                    }
                }
            }
        }
        return vars.toArray(new Variable[vars.size()]);
    }
    static DelayedEvalBshMethod[] getDeclaredMethods(BSHBlock body,
           BshEvaluatingVisitor visitor, String defaultPackage) throws EvalError {
        List<DelayedEvalBshMethod> methods = new ArrayList<DelayedEvalBshMethod>();
        for (int child = 0; child < body.jjtGetNumChildren(); child++) {
            SimpleNode node = (SimpleNode) body.jjtGetChild(child);
            if (node instanceof BSHMethodDeclaration) {
                BSHMethodDeclaration md = (BSHMethodDeclaration) node;
                md.insureNodesParsed();
                Modifiers modifiers = md.modifiers;
                String name = md.name;
                String returnType = visitor.getReturnTypeDescriptor(md, defaultPackage);
                BSHReturnType returnTypeNode = visitor.getReturnTypeNode(md);
                BSHFormalParameters paramTypesNode = md.paramsNode;
                String[] paramTypes = visitor.getTypeDescriptors(paramTypesNode, defaultPackage);
                DelayedEvalBshMethod bm = new DelayedEvalBshMethod(name, returnType, returnTypeNode,
                        md.paramsNode.getParamNames(), paramTypes, paramTypesNode, md.blockNode,
                        null, modifiers,
                        visitor);
                methods.add(bm);
            }
        }
        return methods.toArray(new DelayedEvalBshMethod[methods.size()]);
    }

    static class ClassNodeFilter implements BSHBlock.NodeFilter {
        public static final int STATIC = 0, INSTANCE = 1, CLASSES = 2;
        public static ClassNodeFilter CLASSSTATIC = new ClassNodeFilter(STATIC);
        public static ClassNodeFilter CLASSINSTANCE = new ClassNodeFilter(INSTANCE);
        public static ClassNodeFilter CLASSCLASSES = new ClassNodeFilter(CLASSES);
        int context;
        private ClassNodeFilter(int context) {
            this.context = context;
        }
        public boolean isVisible(SimpleNode node) {
            if (context == CLASSES) return node instanceof BSHClassDeclaration;

            if (node instanceof BSHClassDeclaration) return false;
            if (context == STATIC) return isStatic(node);
            if (context == INSTANCE) return !isStatic(node);

            return true;
        }
        boolean isStatic(SimpleNode node) {
            if (node instanceof BSHTypedVariableDeclaration)
                return ((BSHTypedVariableDeclaration) node).modifiers != null
                        && ((BSHTypedVariableDeclaration) node).modifiers.hasModifier("static");
            if (node instanceof BSHMethodDeclaration)
                return ((BSHMethodDeclaration) node).modifiers != null
                        && ((BSHMethodDeclaration) node).modifiers.hasModifier("static");

            if (node instanceof BSHBlock) return false;
            return false;
        }
    }
    public static Object invokeSuperclassMethodImpl(BshClassManager bcm, Object instance,
                                                    String methodName, Object[] args)
            throws UtilEvalError, ReflectError, InvocationTargetException {
        String superName = ClassGeneratorUtil.BSHSUPER + methodName;

        Class clas = instance.getClass();
        Method superMethod = Reflect.resolveJavaMethod(bcm, clas, superName, Types.getTypes(args), false);
        if (superMethod != null) return Reflect.invokeMethod(superMethod, instance, args);

        Class superClass = clas.getSuperclass();
        superMethod = Reflect.resolveExpectedJavaMethod(bcm, superClass, instance, methodName, args, false);
        return Reflect.invokeMethod(superMethod, instance, args);
    }
}
package bsh;
import bsh.ast.SimpleNode;

public class InterpreterError extends RuntimeException {
	public InterpreterError(final String s) {
		super(s);
	}
    public InterpreterError(final String s, final SimpleNode node) {
        super(s + " (at " + node.getSourceFile() + ":" + node.getLineNumber() + "\n" + node.getText());
    }
	public InterpreterError(final String s, final Throwable cause) {
		super(s, cause);
	}
}
package bsh;
import java.lang.reflect.Field;
import java.util.Hashtable;

public class LHS implements ParserConstants, java.io.Serializable
{
	NameSpace nameSpace;

	boolean localVar;

	static final int
		VARIABLE = 0,
		FIELD = 1,
		PROPERTY = 2,
		INDEX = 3,
		METHOD_EVAL = 4;
	int type;
	String varName;
	String propName;
	Field field;
	Object object;
	int index;

	public LHS( NameSpace nameSpace, String varName )
	{
throw new Error("namespace lhs");

	}

	public LHS( NameSpace nameSpace, String varName, boolean localVar )
	{
		type = VARIABLE;
		this.localVar = localVar;
		this.varName = varName;
		this.nameSpace = nameSpace;
	}

	public LHS( Field field )
	{
		type = FIELD;
		this.object = null;
		this.field = field;
	}

	public LHS( Object object, Field field )
	{
		if ( object == null)
			throw new NullPointerException("constructed empty LHS");
		type = FIELD;
		this.object = object;
		this.field = field;
	}

	public LHS( Object object, String propName )
	{
		if(object == null)
			throw new NullPointerException("constructed empty LHS");
		type = PROPERTY;
		this.object = object;
		this.propName = propName;
	}

	public LHS( Object array, int index )
	{
		if(array == null)
			throw new NullPointerException("constructed empty LHS");
		type = INDEX;
		this.object = array;
		this.index = index;
	}
	public Object getValue() throws UtilEvalError
	{
		if ( type == VARIABLE )
			return nameSpace.getVariable( varName );
		if (type == FIELD)
			try {
				Object o = field.get( object );
				return Primitive.wrap( o, field.getType() );
			} catch(IllegalAccessException e2) {
				throw new UtilEvalError("Can't read field: " + field);
			}
		if ( type == PROPERTY )
			try {
				return Reflect.getObjectProperty(object, propName);
			}
			catch(ReflectError e) {
				Interpreter.debug(e.getMessage());
				throw new UtilEvalError("No such property: " + propName);
			}
		if ( type == INDEX )
			try {
				return Reflect.getIndex(object, index);
			}
			catch(Exception e) {
				throw new UtilEvalError("Array access: " + e);
			}
		throw new InterpreterError("LHS type");
	}

	public Object assign( Object val, boolean strictJava ) 
		throws UtilEvalError
	{
		if ( type == VARIABLE )
		{

			if ( localVar )
				nameSpace.setLocalVariable( varName, val, strictJava );
			else
				nameSpace.setVariable( varName, val, strictJava );
		} else 
		if ( type == FIELD )
		{
			try {
				Object fieldVal = val instanceof Primitive ?  
					((Primitive)val).getValue() : val;

				field.setAccessible(true);
				field.set( object, fieldVal );
				return val;
			}
			catch( NullPointerException e) {   
    			throw new UtilEvalError(
					"LHS ("+field.getName()+") not a static field.",e);
			}     
   			catch( IllegalAccessException e2) {   
				throw new UtilEvalError(
					"LHS ("+field.getName()+") can't access field: "+e2,e2);
			}     
			catch( IllegalArgumentException e3) 
			{
				String type = val instanceof Primitive ?
					((Primitive)val).getType().getName()
					: val.getClass().getName();
				throw new UtilEvalError(
					"Argument type mismatch. " + (val == null ? "null" : type )
					+ " not assignable to field "+field.getName());
			}
		}
		else 
		if ( type == PROPERTY )
		{

			CollectionManager cm = CollectionManager.getCollectionManager();
			if ( cm.isMap( object ) )
				cm.putInMap( object, propName, val );
			else
				try {
					Reflect.setObjectProperty(object, propName, val);
				}
				catch(ReflectError e) {
					Interpreter.debug("Assignment: " + e.getMessage());
					throw new UtilEvalError("No such property: " + propName);
				}
		} else 
		if ( type == INDEX )
			try {
				Reflect.setIndex(object, index, val);
			} catch ( UtilTargetError e1 ) { 
				throw e1;
			} catch ( Exception e ) {
				throw new UtilEvalError("Assignment: " + e.getMessage());
			}
		else
			throw new InterpreterError("unknown lhs");
		return val;
	}
	public String toString() { 
		return "LHS: "
			+((field!=null)? "field = "+field.toString():"")
			+(varName!=null ? " varName = "+varName: "")
			+(nameSpace!=null ? " nameSpace = "+nameSpace.toString(): "");
	}
}
package bsh.interpreter;
import bsh.*;
import bsh.ast.BSHAssignment;
import bsh.ast.SimpleNode;

public class BshInterpreterUtil {
    public static boolean evaluateCondition(
		SimpleNode condExp, BshEvaluatingVisitor visitor)
		throws EvalError
    {
        CallStack callstack = visitor.getCallstack();
        Interpreter interpreter = visitor.getInterpreter();
        Object obj = condExp.accept(visitor);
        if(obj instanceof Primitive) {
			if ( obj == Primitive.VOID )
				throw new EvalError("Condition evaluates to void type",
					condExp, callstack );
            obj = ((Primitive)obj).getValue();
		}
        if(obj instanceof Boolean)
            return ((Boolean)obj).booleanValue();
        else
            throw new EvalError(
				"Condition must evaluate to a Boolean or boolean.",
				condExp, callstack );
    }

    public static int getIndexAux(
            Object obj, BshEvaluatingVisitor visitor,
            SimpleNode callerInfo )
            throws EvalError
    {
        if ( !obj.getClass().isArray() )
            throw new EvalError("Not an array", callerInfo, visitor.getCallstack() );
        int index;
        try {
            Object indexVal =
                    ((SimpleNode)callerInfo.jjtGetChild(0)).accept(visitor);
            if ( !(indexVal instanceof Primitive) )
                indexVal = Types.castObject(
                        indexVal, Integer.TYPE, Types.ASSIGNMENT);
            index = ((Primitive)indexVal).intValue();
        } catch( UtilEvalError e ) {
            Interpreter.debug("doIndex: "+e);
            throw e.toEvalError(
                    "Arrays may only be indexed by integer types.",
                    callerInfo, visitor.getCallstack() );
        }
        return index;
    }
    public static Object operation(BSHAssignment node, Object lhs, Object rhs, int kind )
            throws UtilEvalError
    {

        if ( lhs instanceof String && rhs != Primitive.VOID ) {
            if ( kind != ParserConstants.PLUS )
                throw new UtilEvalError(
                        "Use of non + operator with String LHS" );
            return (String)lhs + rhs;
        }
        if ( lhs instanceof Primitive || rhs instanceof Primitive )
            if(lhs == Primitive.VOID || rhs == Primitive.VOID)
                throw new UtilEvalError(
                        "Illegal use of undefined object or 'void' literal" );
            else if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                throw new UtilEvalError(
                        "Illegal use of null object or 'null' literal" );
        if( (lhs instanceof Boolean || lhs instanceof Character ||
                lhs instanceof Number || lhs instanceof Primitive) &&
                (rhs instanceof Boolean || rhs instanceof Character ||
                        rhs instanceof Number || rhs instanceof Primitive) )
        {
            return Primitive.binaryOperation(lhs, rhs, kind);
        }
        throw new UtilEvalError("Non primitive value in operator: " +
                lhs.getClass() + " " + node.tokenImage[kind] + " " + rhs.getClass() );
    }
    public static String getTypeDescriptor( Class clas )
    {
        if ( clas == Boolean.TYPE ) return "Z";
        if ( clas == Character.TYPE ) return "C";
        if ( clas == Byte.TYPE ) return "B";
        if ( clas == Short.TYPE ) return "S";
        if ( clas == Integer.TYPE ) return "I";
        if ( clas == Long.TYPE ) return "J";
        if ( clas == Float.TYPE ) return "F";
        if ( clas == Double.TYPE ) return "D";
        if ( clas == Void.TYPE ) return "V";

        String name = clas.getName().replace('.','/');
        if ( name.startsWith("[") || name.endsWith(";") )
            return name;
        else
            return "L"+ name.replace('.','/') +";";
    }
}
package bsh.ast;
import bsh.*;

public class SimpleNode implements Node
{
	public static SimpleNode JAVACODE =
		new SimpleNode( -1 ) {
			public String getSourceFile() {
				return "<Called from Java Code>";
			}
			public int getLineNumber() {
				return -1;
			}
			public String getText()  {
				return "<Compiled Java Code>";
			}
		};
	protected Node parent;
	protected Node[] children;
	protected int id;
	public Token firstToken, lastToken;

	String sourceFile;
	public SimpleNode(int i) {
		id = i;
	}
	public void jjtOpen() { }
	public void jjtClose() { }
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }

	public void jjtAddChild(Node n, int i)
	{
		if (children == null)
			children = new Node[i + 1];
		else
			if (i >= children.length)
			{
				Node c[] = new Node[i + 1];
				System.arraycopy(children, 0, c, 0, children.length);
				children = c;
			}
		children[i] = n;
	}
	public Node jjtGetChild(int i) { 
		return children[i]; 
	}
	public SimpleNode getChild( int i ) {
		return (SimpleNode)jjtGetChild(i);
	}
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}

	public String toString() { return ParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }

	public void dump(String prefix)
	{
		System.out.println(toString(prefix));
		if(children != null)
		{
			for(int i = 0; i < children.length; ++i)
			{
				SimpleNode n = (SimpleNode)children[i];
				if (n != null)
				{
					n.dump(prefix + " ");
				}
			}
		}
	}

	public void prune() {
		jjtSetParent( null );
	}

	public void setSourceFile( String sourceFile ) {
		this.sourceFile = sourceFile;
	}

	public String getSourceFile() {
		if ( sourceFile == null )
			if ( parent != null )
				return ((SimpleNode)parent).getSourceFile();
			else
				return "<unknown file>";
		else
			return sourceFile;
	}

	public int getLineNumber() {
		return firstToken.beginLine;
	}

	public String getText() 
	{
		StringBuilder text = new StringBuilder();
		Token t = firstToken;
		while ( t!=null ) {
			text.append(t.image);
			if ( !t.image.equals(".") )
				text.append(" ");
			if ( t==lastToken ||
				t.image.equals("{") || t.image.equals(";") )
				break;
			t=t.next;
		}

		return text.toString();
	}
    public <T> T accept(BshNodeVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
package bsh;
import bsh.ast.SimpleNode;

public class UtilEvalError extends Exception 
{
	protected UtilEvalError() {
	}
	public UtilEvalError( String s ) {
		super(s);
	}
	public UtilEvalError( String s, Throwable cause ) {
		super(s,cause);
	}

	public EvalError toEvalError( 
		String msg, SimpleNode node, CallStack callstack  )
	{
		if ( Interpreter.DEBUG )
			printStackTrace();
		if ( msg == null )
			msg = "";
		else
			msg = msg + ": ";
		return new EvalError( msg+getMessage(), node, callstack, this );
	}
	public EvalError toEvalError ( SimpleNode node, CallStack callstack ) 
	{
		return toEvalError( null, node, callstack );
	}
}
package bsh.interpreter;
import bsh.*;
import bsh.ast.*;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class BshEvaluatingVisitor extends BshNodeVisitor<Object> {
    private CallStack callstack;
    private Interpreter interpreter;
    public BshEvaluatingVisitor(CallStack callstack, Interpreter interpreter) {
        this.callstack = callstack;
        this.interpreter = interpreter;
    }
    public CallStack getCallstack() {
        return callstack;
    }
    public Interpreter getInterpreter() {
        return interpreter;
    }
    @Override
    public Object visit(BSHAllocationExpression node) {

        SimpleNode type = (SimpleNode)node.jjtGetChild(0);

        SimpleNode args = (SimpleNode)node.jjtGetChild(1);
        if ( type instanceof BSHAmbiguousName)
        {
            BSHAmbiguousName name = (BSHAmbiguousName)type;
            if (args instanceof BSHArguments)
                return objectAllocation(node, name, (BSHArguments) args);
            else
                return objectArrayAllocation(node, name, (BSHArrayDimensions) args
                );
        }
        else
            return primitiveArrayAllocation(node, (BSHPrimitiveType) type,
                    (BSHArrayDimensions) args);
    }
    public Object objectAllocation(BSHAllocationExpression node,
            BSHAmbiguousName nameNode, BSHArguments argumentsNode)
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        Object[] args = getArguments(argumentsNode);
        if ( args == null)
            throw new EvalError( "Null args in new.", node, callstack );

        Object obj = ambiguousNameToObject(nameNode, false );

        obj = ambiguousNameToObject( nameNode, true );
        Class type = null;
        if ( obj instanceof ClassIdentifier )
            type = ((ClassIdentifier)obj).getTargetClass();
        else
            throw new EvalError(
                    "Unknown class: "+nameNode.text, node, callstack );

        boolean hasBody = node.jjtGetNumChildren() > 2;
        if ( hasBody )
        {
            BSHBlock body = (BSHBlock)node.jjtGetChild(2);
            if ( type.isInterface() )
                return constructWithInterfaceBody(node,
                        type, args, body);
            else
                return constructWithClassBody( node,
                        type, args, body );
        } else
            return constructObject(node, type, args );
    }
    public Object constructObject(BSHAllocationExpression node, Class<?> type, Object[] args ) throws EvalError {
        final boolean isGeneratedClass = GeneratedClass.class.isAssignableFrom(type);
        if (isGeneratedClass) {
            ClassGeneratorUtil.registerConstructorContext(callstack, interpreter);
        }
        Object obj;
        try {
            obj = Reflect.constructObject( type, args );
        } catch ( ReflectError e) {
            throw new EvalError(
                    "Constructor error: " + e.getMessage(), node, callstack );
        } catch (InvocationTargetException e) {

            Interpreter.debug("The constructor threw an exception:\n\t" + e.getTargetException());
            throw new TargetError("Object constructor", e.getTargetException(), node, callstack, true);
        } finally {
            if (isGeneratedClass) {
                ClassGeneratorUtil.registerConstructorContext(null, null); 
            }
        }
        String className = type.getName();

        if ( className.indexOf("$") == -1 )
            return obj;

        This ths = callstack.top().getThis( null );
        NameSpace instanceNameSpace =
                Name.getClassNameSpace( ths.getNameSpace() );

        if ( instanceNameSpace != null
                && className.startsWith( instanceNameSpace.getName() +"$")
                )
        {
            ClassGenerator.getClassGenerator().setInstanceNameSpaceParent(
                    obj, className, instanceNameSpace );
        }
        return obj;
    }
    public Object constructWithClassBody( BSHAllocationExpression node,
            Class type, Object[] args, BSHBlock block )
            throws EvalError
    {
        String name = callstack.top().getName() + "$" + (++node.innerClassCount);
        Modifiers modifiers = new Modifiers();
        modifiers.addModifier( Modifiers.CLASS, "public" );
        Class clas = ClassGenerator.getClassGenerator() .generateClass(
                name, modifiers, null, type,
                block, false, callstack, interpreter );
        try {
            return Reflect.constructObject( clas, args );
        } catch ( Exception e ) {
            Throwable cause = e;
            if ( e instanceof InvocationTargetException ) {
                cause = ((InvocationTargetException) e).getTargetException();
            }
            throw new EvalError("Error constructing inner class instance: "+e, node, callstack, cause);
        }
    }
    public Object constructWithInterfaceBody( BSHAllocationExpression node,
            Class type, Object[] args, BSHBlock body )
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        NameSpace local = new NameSpace(namespace, "AnonymousBlock");
        callstack.push(local);
        evalBlock(body, true);
        callstack.pop();

        local.importStatic( type );
        return local.getThis(interpreter).getInterface( type );
    }
    public Object objectArrayAllocation( BSHAllocationExpression node,
            BSHAmbiguousName nameNode, BSHArrayDimensions dimensionsNode )
            throws EvalError
    {
        NameSpace namespace = callstack.top();
        Class type = ambiguousNameToClass( nameNode );
        if ( type == null )
            throw new EvalError( "Class " + nameNode.getName(namespace)
                    + " not found.", node, callstack );
        return arrayAllocation( node, dimensionsNode, type );
    }
    public Object primitiveArrayAllocation( BSHAllocationExpression node,
            BSHPrimitiveType typeNode, BSHArrayDimensions dimensionsNode
    )
            throws EvalError
    {
        Class type = typeNode.getType();
        return arrayAllocation(node, dimensionsNode, type );
    }
    public Object arrayAllocation( BSHAllocationExpression node,
            BSHArrayDimensions dimensionsNode, Class type)
            throws EvalError
    {

        Object result = evalArrayDimensions(dimensionsNode, type);
        if ( result != Primitive.VOID )
            return result;
        else
            return arrayNewInstance( node, type, dimensionsNode );
    }

    public Object arrayNewInstance( BSHAllocationExpression node,
            Class type, BSHArrayDimensions dimensionsNode )
            throws EvalError
    {
        if ( dimensionsNode.numUndefinedDims > 0 )
        {
            Object proto = Array.newInstance(
                    type, new int [dimensionsNode.numUndefinedDims] ); 
            type = proto.getClass();
        }
        try {
            return Array.newInstance(
                    type, dimensionsNode.definedDimensions);
        } catch( NegativeArraySizeException e1 ) {
            throw new TargetError( e1, node, callstack );
        } catch( Exception e ) {
            throw new EvalError("Can't construct primitive array: " +
                    e.getMessage(), node, callstack);
        }
    }
    @Override
    public Object visit(BSHAmbiguousName node) {
        throw new InterpreterError(
                "Don't know how to eval an ambiguous name!"
                        +"  Use toObject() if you want an object." );
    }
    public Object ambiguousNameToObject( BSHAmbiguousName node )
            throws EvalError
    {
        return ambiguousNameToObject( node, false );
    }
    public Object ambiguousNameToObject( BSHAmbiguousName node,
            boolean forceClass )
            throws EvalError
    {
        try {
            return
                    node.getName( callstack.top() ).toObject(
                            this, forceClass );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    public Class ambiguousNameToClass( BSHAmbiguousName node )
            throws EvalError
    {
        try {
            return node.getName( callstack.top() ).toClass();
        } catch ( ClassNotFoundException e ) {
            throw new EvalError( e.getMessage(), node, callstack, e );
        } catch ( UtilEvalError e2 ) {

            throw e2.toEvalError( node, callstack );
        }
    }
    public LHS ambiguousNameToLHS( BSHAmbiguousName node )
            throws EvalError
    {
        try {
            return node.getName( callstack.top() ).toLHS( this );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHArguments node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHArguments class.");
    }

    public Object[] getArguments( BSHArguments node )
            throws EvalError
    {

        Object[] args = new Object[node.jjtGetNumChildren()];
        for(int i = 0; i < args.length; i++)
        {
            args[i] = ((SimpleNode)node.jjtGetChild(i)).accept(this);
            if ( args[i] == Primitive.VOID )
                throw new EvalError( "Undefined argument: " +
                        ((SimpleNode)node.jjtGetChild(i)).getText(), node, callstack );
        }
        return args;
    }

    @Override
    public Object visit(BSHArrayDimensions node) {
        SimpleNode child = (SimpleNode)node.jjtGetChild(0);

        if (child instanceof BSHArrayInitializer)
        {
            if ( node.baseType == null )
                throw new EvalError(
                        "Internal Array Eval err:  unknown base type",
                        node, callstack );
            Object initValue = evalArrayInitializer(((BSHArrayInitializer) child),
                    node.baseType, node.numUndefinedDims, callstack, interpreter);
            Class arrayClass = initValue.getClass();
            int actualDimensions = Reflect.getArrayDimensions(arrayClass);
            node.definedDimensions = new int[ actualDimensions ];

            if ( node.definedDimensions.length != node.numUndefinedDims )
                throw new EvalError(
                        "Incompatible initializer. Allocation calls for a " +
                                node.numUndefinedDims+ " dimensional array, but initializer is a " +
                                actualDimensions + " dimensional array", node, callstack );

            Object arraySlice = initValue;
            for ( int i = 0; i < node.definedDimensions.length; i++ ) {
                node.definedDimensions[i] = Array.getLength(arraySlice);
                if ( node.definedDimensions[i] > 0 )
                    arraySlice = Array.get(arraySlice, 0);
            }
            return initValue;
        }
        else

        {
            node.definedDimensions = new int[ node.numDefinedDims ];
            for(int i = 0; i < node.numDefinedDims; i++)
            {
                try {
                    Object length = ((SimpleNode)node.jjtGetChild(i)).accept(this);
                    node.definedDimensions[i] = ((Primitive)length).intValue();
                }
                catch(Exception e)
                {
                    throw new EvalError(
                            "Array index: " + i +
                                    " does not evaluate to an integer", node, callstack );
                }
            }
        }
        return Primitive.VOID;
    }
    public Object evalArrayDimensions( BSHArrayDimensions node,
            Class type )
            throws EvalError
    {
        if ( Interpreter.DEBUG ) Interpreter.debug("array base type = "+type);
        node.baseType = type;
        return node.accept(this);
    }

    public Object evalArrayInitializer(BSHArrayInitializer nodeA, Class baseType, int dimensions,
                        CallStack callstack, Interpreter interpreter )
            throws EvalError
    {
        int numInitializers = nodeA.jjtGetNumChildren();

        int [] dima = new int [dimensions]; 

        dima[0] = numInitializers;
        Object initializers =  Array.newInstance( baseType, dima );

        for (int i = 0; i < numInitializers; i++)
        {
            SimpleNode childNode = (SimpleNode)nodeA.jjtGetChild(i);
            Object currentInitializer;
            if ( childNode instanceof BSHArrayInitializer ) {
                if ( dimensions < 2 )
                    throw new EvalError(
                            "Invalid Location for Intializer, position: "+i,
                            nodeA, callstack );
                currentInitializer =
                        evalArrayInitializer(((BSHArrayInitializer)childNode),
                                baseType, dimensions-1, callstack, interpreter);
            } else
                currentInitializer = childNode.accept(this);
            if ( currentInitializer == Primitive.VOID )
                throw new EvalError(
                        "Void in array initializer, position"+i, nodeA, callstack );

            Object value = currentInitializer;
            if ( dimensions == 1 )
            {

                try {
                    value = Types.castObject(
                            currentInitializer, baseType, Types.CAST );
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError(
                            "Error in array initializer", nodeA, callstack );
                }

                value = Primitive.unwrap( value );
            }

            try {
                Array.set(initializers, i, value);
            } catch( IllegalArgumentException e ) {
                Interpreter.debug("illegal arg"+e);
                throwTypeError( nodeA, baseType, currentInitializer, i, callstack );
            } catch( ArrayStoreException e ) { 
                Interpreter.debug("arraystore"+e);
                throwTypeError(nodeA, baseType, currentInitializer, i, callstack );
            }
        }
        return initializers;
    }
    private void throwTypeError( BSHArrayInitializer node,
            Class baseType, Object initializer, int argNum, CallStack callstack )
            throws EvalError
    {
        String rhsType;
        if (initializer instanceof Primitive)
            rhsType =
                    ((Primitive)initializer).getType().getName();
        else
            rhsType = Reflect.normalizeClassName(
                    initializer.getClass());
        throw new EvalError ( "Incompatible type: " + rhsType
                +" in initializer of array type: "+ baseType
                +" at position: "+argNum, node, callstack );
    }
    @Override
    public Object visit(BSHArrayInitializer node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHArrayInitializer class.");
    }
    @Override
    public Object visit(BSHAssignment node) {
        BSHPrimaryExpression lhsNode =
                (BSHPrimaryExpression)node.jjtGetChild(0);
        if ( lhsNode == null )
            throw new InterpreterError( "Error, null LHSnode" );
        boolean strictJava = interpreter.getStrictJava();
        LHS lhs = primaryExprToLHS(lhsNode);
        if ( lhs == null )
            throw new InterpreterError( "Error, null LHS" );

        Object lhsValue = null;
        if ( node.operator != ParserConstants.ASSIGN ) 
            try {
                lhsValue = lhs.getValue();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
        SimpleNode rhsNode = (SimpleNode)node.jjtGetChild(1);
        Object rhs;

        rhs = rhsNode.accept(this);
        if ( rhs == Primitive.VOID )
            throw new EvalError("Void assignment.", node, callstack );
        try {
            switch(node.operator)
            {
                case ParserConstants.ASSIGN:
                    return lhs.assign( rhs, strictJava );
                case ParserConstants.PLUSASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.PLUS), strictJava );
                case ParserConstants.MINUSASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.MINUS), strictJava );
                case ParserConstants.STARASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.STAR), strictJava );
                case ParserConstants.SLASHASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.SLASH), strictJava );
                case ParserConstants.ANDASSIGN:
                case ParserConstants.ANDASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.BIT_AND), strictJava );
                case ParserConstants.ORASSIGN:
                case ParserConstants.ORASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.BIT_OR), strictJava );
                case ParserConstants.XORASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.XOR), strictJava );
                case ParserConstants.MODASSIGN:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.MOD), strictJava );
                case ParserConstants.LSHIFTASSIGN:
                case ParserConstants.LSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.LSHIFT), strictJava );
                case ParserConstants.RSIGNEDSHIFTASSIGN:
                case ParserConstants.RSIGNEDSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.RSIGNEDSHIFT ), strictJava );
                case ParserConstants.RUNSIGNEDSHIFTASSIGN:
                case ParserConstants.RUNSIGNEDSHIFTASSIGNX:
                    return lhs.assign(
                            BshInterpreterUtil.operation(node, lhsValue, rhs, ParserConstants.RUNSIGNEDSHIFT),
                            strictJava );
                default:
                    throw new InterpreterError(
                            "unimplemented operator in assignment BSH");
            }
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHBinaryExpression node) {
        Object lhs = ((SimpleNode)node.jjtGetChild(0)).accept(this);

        if (node.kind == ParserConstants.INSTANCEOF)
        {

            if ( lhs == Primitive.NULL )
                return new Primitive(false);
            Class rhs = getType(((BSHType)node.jjtGetChild(1)));

            if ( lhs instanceof Primitive )
                if ( rhs == bsh.Primitive.class )
                    return new Primitive(true);
                else
                    return new Primitive(false);

            boolean ret = Types.isJavaBaseAssignable( rhs, lhs.getClass() );
            return new Primitive(ret);
        }

        if ( node.kind == ParserConstants.BOOL_AND || node.kind == ParserConstants.BOOL_ANDX ) {
            Object obj = lhs;
            if ( node.isPrimitiveValue(lhs) )
                obj = ((Primitive)lhs).getValue();
            if ( obj instanceof Boolean &&
                    ( ((Boolean)obj).booleanValue() == false ) )
                return new Primitive(false);
        }

        if ( node.kind == ParserConstants.BOOL_OR || node.kind == ParserConstants.BOOL_ORX ) {
            Object obj = lhs;
            if ( node.isPrimitiveValue(lhs) )
                obj = ((Primitive)lhs).getValue();
            if ( obj instanceof Boolean &&
                    ( ((Boolean)obj).booleanValue() == true ) )
                return new Primitive(true);
        }

        boolean isLhsWrapper = node.isWrapper(lhs);
        Object rhs = ((SimpleNode)node.jjtGetChild(1)).accept(this); 
        boolean isRhsWrapper = node.isWrapper(rhs);
        if (
                ( isLhsWrapper || node.isPrimitiveValue(lhs) )
                        && ( isRhsWrapper || node.isPrimitiveValue(rhs) )
                )
        {

            if ( (isLhsWrapper && isRhsWrapper && node.kind == ParserConstants.EQ))
            {

            } else
                try {
                    return Primitive.binaryOperation(lhs, rhs, node.kind);
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack  );
                }
        }

        switch(node.kind)
        {
            case ParserConstants.EQ:
                return new Primitive((lhs == rhs));
            case ParserConstants.NE:
                return new Primitive((lhs != rhs));
            case ParserConstants.PLUS:
                if(lhs instanceof String || rhs instanceof String)
                    return lhs.toString() + rhs.toString();

            default:
                if(lhs instanceof Primitive || rhs instanceof Primitive)
                    if ( lhs == Primitive.VOID || rhs == Primitive.VOID )
                        throw new EvalError(
                                "illegal use of undefined variable, class, or 'void' literal",
                                node, callstack );
                    else
                    if ( lhs == Primitive.NULL || rhs == Primitive.NULL )
                        throw new EvalError(
                                "illegal use of null value or 'null' literal", node, callstack);
                throw new EvalError("Operator: '" + ParserConstants.tokenImage[node.kind] +
                        "' inappropriate for objects", node, callstack );
        }
    }

    public Object evalBlock( BSHBlock node,
            boolean overrideNamespace )
            throws EvalError
    {
        Object syncValue = null;
        if ( node.isSynchronized )
        {

            SimpleNode exp = ((SimpleNode)node.jjtGetChild(0));
            syncValue = exp.accept(this);
        }
        Object ret;
        if ( node.isSynchronized ) 
            synchronized( syncValue )
            {
                ret = evalBlock(node, overrideNamespace, null);
            }
        else
            ret = evalBlock(node, overrideNamespace, null );
        return ret;
    }
    public Object evalBlock( BSHBlock block,
            boolean overrideNamespace, BSHBlock.NodeFilter nodeFilter )
            throws EvalError
    {
        Object ret = Primitive.VOID;
        NameSpace enclosingNameSpace = null;
        if ( !overrideNamespace )
        {
            enclosingNameSpace= callstack.top();
            BlockNameSpace bodyNameSpace =
                    new BlockNameSpace( enclosingNameSpace );
            callstack.swap( bodyNameSpace );
        }
        int startChild = block.isSynchronized ? 1 : 0;
        int numChildren = block.jjtGetNumChildren();
        try {

            for(int i=startChild; i<numChildren; i++)
            {
                SimpleNode node = ((SimpleNode)block.jjtGetChild(i));
                if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
                    continue;
                if ( node instanceof BSHClassDeclaration )
                    node.accept(this);
            }
            for(int i=startChild; i<numChildren; i++)
            {
                SimpleNode node = ((SimpleNode)block.jjtGetChild(i));
                if ( node instanceof BSHClassDeclaration )
                    continue;

                if ( nodeFilter != null && !nodeFilter.isVisible( node ) )
                    continue;
                ret = node.accept(this);

                if ( ret instanceof ReturnControl )
                    break;
            }
        } finally {

            if ( !overrideNamespace )
                callstack.swap( enclosingNameSpace );
        }
        return ret;
    }
    @Override
    public Object visit(BSHBlock node) {
        return evalBlock(node, false);
    }
    @Override
    public Object visit(BSHCastExpression node) {
        NameSpace namespace = callstack.top();
        Class toType = getType(((BSHType)node.jjtGetChild(0)));
        SimpleNode expression = (SimpleNode)node.jjtGetChild(1);

        Object fromValue = expression.accept(this);
        Class fromType = fromValue.getClass();

        try {
            return Types.castObject( fromValue, toType, Types.CAST );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack  );
        }
    }
    @Override
    public Object visit(BSHClassDeclaration node) {
        synchronized (node) {
            if (node.generatedClass == null) {
                node.generatedClass = generateClass(node);
            }
            return node.generatedClass;
        }
    }
    public Class<?> generateClass(BSHClassDeclaration node) throws EvalError {
        int child = 0;

        Class superClass = null;
        if ( node.extend ) {
            BSHAmbiguousName superNode = (BSHAmbiguousName)node.jjtGetChild(child++);
            superClass = ambiguousNameToClass( superNode );
        }

        Class [] interfaces = new Class[node.numInterfaces];
        for( int i=0; i<node.numInterfaces; i++) {
            BSHAmbiguousName node1 = (BSHAmbiguousName)node.jjtGetChild(child++);
            interfaces[i] = ambiguousNameToClass(node1);
            if ( !interfaces[i].isInterface() )
                throw new EvalError(
                        "Type: "+node1.text+" is not an interface!",
                        node, callstack );
        }
        BSHBlock block;

        if ( child < node.jjtGetNumChildren() )
            block = (BSHBlock) node.jjtGetChild(child);
        else
            block = new BSHBlock( ParserTreeConstants.JJTBLOCK );
        return ClassGenerator.getClassGenerator().generateClass(
                node.name, node.modifiers, interfaces, superClass, block, node.isInterface,
                callstack, interpreter );
    }
    @Override
    public Object visit(BSHEnhancedForStatement node) {
        Class elementType = null;
        SimpleNode expression, statement=null;
        NameSpace enclosingNameSpace = callstack.top();
        SimpleNode firstNode =((SimpleNode)node.jjtGetChild(0));
        int nodeCount = node.jjtGetNumChildren();
        if ( firstNode instanceof BSHType )
        {
            elementType=getType(((BSHType)firstNode));
            expression=((SimpleNode)node.jjtGetChild(1));
            if ( nodeCount>2 )
                statement=((SimpleNode)node.jjtGetChild(2));
        } else
        {
            expression=firstNode;
            if ( nodeCount>1 )
                statement=((SimpleNode)node.jjtGetChild(1));
        }
        BlockNameSpace eachNameSpace = new BlockNameSpace( enclosingNameSpace );
        callstack.swap( eachNameSpace );
        final Object iteratee = expression.accept(this);
        if ( iteratee == Primitive.NULL )
            throw new EvalError("The collection, array, map, iterator, or " +
                    "enumeration portion of a for statement cannot be null.",
                    node, callstack );
        CollectionManager cm = CollectionManager.getCollectionManager();
        if ( !cm.isBshIterable( iteratee ) )
            throw new EvalError("Can't iterate over type: "
                    +iteratee.getClass(), node, callstack );
        Iterator iterator = cm.getBshIterator( iteratee );
        Object returnControl = Primitive.VOID;
        while( iterator.hasNext() )
        {
            try {
                Object value = iterator.next();
                if ( value == null )
                    value = Primitive.NULL;
                if ( elementType != null )
                    eachNameSpace.setTypedVariable(
                            node.varName, elementType,
                            value, new Modifiers() );
                else
                    eachNameSpace.setVariable( node.varName, value, false );
            } catch ( UtilEvalError e ) {
                throw e.toEvalError(
                        "for loop iterator variable:"+ node.varName, node, callstack );
            }
            boolean breakout = false; 
            if ( statement != null ) 
            {
                Object ret = statement.accept(this); 
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case ParserConstants.RETURN:
                            returnControl = ret;
                            breakout = true;
                            break;
                        case ParserConstants.CONTINUE:
                            break;
                        case ParserConstants.BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if (breakout)
                break;
        }
        callstack.swap(enclosingNameSpace);
        return returnControl;
    }
    @Override
    public Object visit(BSHFormalComment node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHFormalComment class.");
    }
    @Override
    public Object visit(BSHFormalParameter node) {
        if ( node.jjtGetNumChildren() > 0 )
            node.type = getType(((BSHType)node.jjtGetChild(0)));
        else
            node.type = node.UNTYPED;
        return node.type;
    }
    public String getFormalParameterTypeDescriptor( BSHFormalParameter node,
             String defaultPackage )
    {
        if ( node.jjtGetNumChildren() > 0 )
            return getTypeDescriptor(((BSHType) node.jjtGetChild(0)), defaultPackage);
        else

            return "Ljava/lang/Object;";  
    }
    @Override
    public Object visit(BSHFormalParameters node) {
        if ( node.paramTypes != null )
            return node.paramTypes;
        node.insureParsed();
        Class [] paramTypes = new Class[node.numArgs];
        for(int i=0; i<node.numArgs; i++)
        {
            BSHFormalParameter param = (BSHFormalParameter)node.jjtGetChild(i);
            paramTypes[i] = (Class)param.accept(this); 
        }
        node.paramTypes = paramTypes;
        return paramTypes;
    }
    public String [] getTypeDescriptors( BSHFormalParameters node, String defaultPackage )
    {
        if ( node.typeDescriptors != null )
            return node.typeDescriptors;
        node.insureParsed();
        String [] typeDesc = new String[node.numArgs];
        for(int i=0; i<node.numArgs; i++)
        {
            BSHFormalParameter param = (BSHFormalParameter)node.jjtGetChild(i);
            typeDesc[i] = getFormalParameterTypeDescriptor(param, defaultPackage );
        }
        node.typeDescriptors = typeDesc;
        return typeDesc;
    }
    @Override
    public Object visit(BSHForStatement node) {
        int i = 0;
        if(node.hasForInit)
            node.forInit = ((SimpleNode)node.jjtGetChild(i++));
        if(node.hasExpression)
            node.expression = ((SimpleNode)node.jjtGetChild(i++));
        if(node.hasForUpdate)
            node.forUpdate = ((SimpleNode)node.jjtGetChild(i++));
        if(i < node.jjtGetNumChildren()) 
            node.statement = ((SimpleNode)node.jjtGetChild(i));
        NameSpace enclosingNameSpace= callstack.top();
        BlockNameSpace forNameSpace = new BlockNameSpace( enclosingNameSpace );

        callstack.swap( forNameSpace );

        if ( node.hasForInit )
            node.forInit.accept(this);
        Object returnControl = Primitive.VOID;
        while(true)
        {
            if ( node.hasExpression )
            {
                boolean cond = BshInterpreterUtil.evaluateCondition(
                        node.expression, this);
                if ( !cond )
                    break;
            }
            boolean breakout = false; 
            if ( node.statement != null ) 
            {

                Object ret = node.statement.accept(this);
                if (ret instanceof ReturnControl)
                {
                    switch(((ReturnControl)ret).kind)
                    {
                        case ParserConstants.RETURN:
                            returnControl = ret;
                            breakout = true;
                            break;
                        case ParserConstants.CONTINUE:
                            break;
                        case ParserConstants.BREAK:
                            breakout = true;
                            break;
                    }
                }
            }
            if ( breakout )
                break;
            if ( node.hasForUpdate )
                node.forUpdate.accept(this);
        }
        callstack.swap( enclosingNameSpace );  
        return returnControl;
    }
    @Override
    public Object visit(BSHIfStatement node) {
        Object ret = null;
        if( BshInterpreterUtil.evaluateCondition(
                (SimpleNode) node.jjtGetChild(0), this) )
            ret = ((SimpleNode)node.jjtGetChild(1)).accept(this);
        else
        if(node.jjtGetNumChildren() > 2)
            ret = ((SimpleNode)node.jjtGetChild(2)).accept(this);
        if(ret instanceof ReturnControl)
            return ret;
        else
            return Primitive.VOID;
    }
    @Override
    public Object visit(BSHImportDeclaration node) {
        NameSpace namespace = callstack.top();
        if ( node.superImport )
            try {
                namespace.doSuperImport();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack  );
            }
        else
        {
            if ( node.staticImport )
            {
                if ( node.importPackage )
                {
                    Class clas = ambiguousNameToClass(((BSHAmbiguousName)node.jjtGetChild(0)));
                    namespace.importStatic( clas );
                } else
                    throw new EvalError(
                            "static field imports not supported yet",
                            node, callstack );
            } else
            {
                String name = ((BSHAmbiguousName)node.jjtGetChild(0)).text;
                if ( node.importPackage )
                    namespace.importPackage(name);
                else
                    namespace.importClass(name);
            }
        }
        return Primitive.VOID;
    }
    @Override
    public Object visit(BSHLiteral node) {
        if (node.value == null)
            throw new InterpreterError("Null in bsh literal: "+node.value);
        return node.value;
    }
    @Override
    public Object visit(BSHMethodDeclaration node) {
        node.returnType = evalMethodReturnType(node);
        evalNodes(node);

        NameSpace namespace = callstack.top();
        BshMethod bshMethod = new BshMethod( node, namespace, node.modifiers );
        try {
            namespace.setMethod( bshMethod );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError(node,callstack);
        }
        return Primitive.VOID;
    }
    public Class evalReturnType( BSHReturnType node ) throws EvalError
    {
        if ( node.isVoid )
            return Void.TYPE;
        else
            return getType(getTypeNode(node));
    }
    public BSHType getTypeNode(BSHReturnType node) {
        return (BSHType)node.jjtGetChild(0);
    }
    public String getTypeDescriptor( BSHReturnType node,
            String defaultPackage )
    {
        if ( node.isVoid )
            return "V";
        else
            return getTypeDescriptor(getTypeNode(node),
                    defaultPackage);
    }
    public String getReturnTypeDescriptor(BSHMethodDeclaration node,
            String defaultPackage )
    {
        node.insureNodesParsed();
        if ( node.returnTypeNode == null )
            return null;
        else
            return getTypeDescriptor(node.returnTypeNode, defaultPackage );
    }
    public BSHReturnType getReturnTypeNode(BSHMethodDeclaration node) {
        node.insureNodesParsed();
        return node.returnTypeNode;
    }

    public Class evalMethodReturnType( BSHMethodDeclaration node )
            throws EvalError
    {
        node.insureNodesParsed();
        if ( node.returnTypeNode != null )
            return evalReturnType(node.returnTypeNode);
        else
            return null;
    }
    public void evalNodes(BSHMethodDeclaration node)
            throws EvalError
    {
        node.insureNodesParsed();

        for(int i=node.firstThrowsClause; i<node.numThrows+node.firstThrowsClause; i++)
            ambiguousNameToClass(((BSHAmbiguousName)node.jjtGetChild(i)) );
        node.paramsNode.accept(this);

        if ( interpreter.getStrictJava() )
        {
            for(int i=0; i<node.paramsNode.paramTypes.length; i++)
                if ( node.paramsNode.paramTypes[i] == null )

                    throw new EvalError(
                            "(Strict Java Mode) Undeclared argument type, parameter: " +
                                    node.paramsNode.getParamNames()[i] + " in method: "
                                    + node.name, node, null );
            if ( node.returnType == null )

                throw new EvalError(
                        "(Strict Java Mode) Undeclared return type for method: "
                                + node.name, node, null );
        }
    }
    @Override
    public Object visit(BSHMethodInvocation node) {
        NameSpace namespace = callstack.top();
        BSHAmbiguousName nameNode = node.getNameNode();

        if ( namespace.getParent() != null && namespace.getParent().isClass
                && ( nameNode.text.equals("super") || nameNode.text.equals("this") )
                )
            return Primitive.VOID;
        Name name = nameNode.getName(namespace);
        Object[] args = getArguments(node.getArgsNode());

        try {
            return name.invokeMethod( this, args, node);
        } catch ( ReflectError e ) {
            throw new EvalError(
                    "Error in method invocation: " + e.getMessage(),
                    node, callstack, e );
        } catch ( InvocationTargetException e )
        {
            String msg = "Method Invocation "+name;
            Throwable te = e.getTargetException();

            boolean isNative = true;
            if ( te instanceof EvalError )
                if ( te instanceof TargetError )
                    isNative = ((TargetError)te).inNativeCode();
                else
                    isNative = false;
            throw new TargetError( msg, te, node, callstack, isNative );
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }
    @Override
    public Object visit(BSHPackageDeclaration node) {
        BSHAmbiguousName name = (BSHAmbiguousName)node.jjtGetChild(0);
        NameSpace namespace = callstack.top();
        namespace.setPackage( name.text );

        namespace.importPackage( name.text );
        return Primitive.VOID;
    }

    private LHS primaryExprToLHS(BSHPrimaryExpression node)
            throws EvalError
    {
        Object obj = evalPrimaryExpr(node, true);
        if ( ! (obj instanceof LHS) )
            throw new EvalError("Can't assign to:", node, callstack );
        else
            return (LHS)obj;
    }

    private Object evalPrimaryExpr( BSHPrimaryExpression node, boolean toLHS )
            throws EvalError
    {

        Object obj = node.jjtGetChild(0);
        int numChildren = node.jjtGetNumChildren();
        for(int i=1; i<numChildren; i++)
            obj = doSuffix(((BSHPrimarySuffix)node.jjtGetChild(i)), obj, toLHS);

        if ( obj instanceof SimpleNode )
            if ( obj instanceof BSHAmbiguousName)
                if ( toLHS )
                    obj = ambiguousNameToLHS(((BSHAmbiguousName)obj));
                else
                    obj = ambiguousNameToObject(((BSHAmbiguousName)obj));
            else

                if ( toLHS )

                    throw new EvalError("Can't assign to prefix.",
                            node, callstack );
                else
                    obj = ((SimpleNode)obj).accept(this);

        if ( obj instanceof LHS )
            if ( toLHS )
                return obj;
            else
                try {
                    return ((LHS)obj).getValue();
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack );
                }
        else
            return obj;
    }
    @Override
    public Object visit(BSHPrimaryExpression node) {
        return evalPrimaryExpr(node, false);
    }
    private Object doSuffix( BSHPrimarySuffix node,
            Object obj, boolean toLHS)
            throws EvalError
    {

        if ( node.operation == BSHPrimarySuffix.CLASS )
            if ( obj instanceof BSHType) {
                if ( toLHS )
                    throw new EvalError("Can't assign .class",
                            node, callstack );
                NameSpace namespace = callstack.top();
                return getType(((BSHType)obj));
            } else
                throw new EvalError(
                        "Attempt to use .class suffix on non class.",
                        node, callstack );

        if ( obj instanceof SimpleNode )
            if ( obj instanceof BSHAmbiguousName)
                obj = ambiguousNameToObject(((BSHAmbiguousName)obj));
            else
                obj = ((SimpleNode)obj).accept(this);
        else
        if ( obj instanceof LHS )
            try {
                obj = ((LHS)obj).getValue();
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
        try
        {
            switch(node.operation)
            {
                case BSHPrimarySuffix.INDEX:
                    return doIndex(node, obj, toLHS );
                case BSHPrimarySuffix.NAME:
                    return doName(node, obj, toLHS );
                case BSHPrimarySuffix.PROPERTY:
                    return doProperty( node, toLHS, obj);
                default:
                    throw new InterpreterError( "Unknown suffix type" );
            }
        }
        catch(ReflectError e)
        {
            throw new EvalError("reflection error: " + e, node, callstack, e );
        }
        catch(InvocationTargetException e)
        {
            throw new TargetError( "target exception", e.getTargetException(),
                    node, callstack, true);
        }
    }

    private Object doName( BSHPrimarySuffix node, Object obj, boolean toLHS)
            throws EvalError, ReflectError, InvocationTargetException
    {
        try {

            if ( node.field.equals("length") && obj.getClass().isArray() )
                if ( toLHS )
                    throw new EvalError(
                            "Can't assign array length", node, callstack );
                else
                    return new Primitive(Array.getLength(obj));

            if ( node.jjtGetNumChildren() == 0 )
                if ( toLHS )
                    return Reflect.getLHSObjectField(obj, node.field);
                else
                    return Reflect.getObjectFieldValue( obj, node.field );

            Object[] oa = getArguments(((BSHArguments)node.jjtGetChild(0)));

            try {
                return Reflect.invokeObjectMethod(
                        obj, node.field, oa, this, node );
            } catch ( ReflectError e ) {
                throw new EvalError(
                        "Error in method invocation: " + e.getMessage(),
                        node, callstack, e );
            } catch ( InvocationTargetException e )
            {
                String msg = "Method Invocation "+node.field;
                Throwable te = e.getTargetException();

                boolean isNative = true;
                if ( te instanceof EvalError )
                    if ( te instanceof TargetError )
                        isNative = ((TargetError)te).inNativeCode();
                    else
                        isNative = false;
                throw new TargetError( msg, te, node, callstack, isNative );
            }
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }

    private Object doIndex( BSHPrimarySuffix node,
            Object obj, boolean toLHS )
            throws EvalError, ReflectError
    {
        int index = BshInterpreterUtil.getIndexAux( obj, this, node );
        if ( toLHS )
            return new LHS(obj, index);
        else
            try {
                return Reflect.getIndex(obj, index);
            } catch ( UtilEvalError e ) {
                throw e.toEvalError( node, callstack );
            }
    }

    private Object doProperty( BSHPrimarySuffix node, boolean toLHS, Object obj )
            throws EvalError
    {
        if(obj == Primitive.VOID)
            throw new EvalError(
                    "Attempt to access property on undefined variable or class name",
                    node, callstack );
        if ( obj instanceof Primitive )
            throw new EvalError("Attempt to access property on a primitive",
                    node, callstack );
        Object value = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        if ( !( value instanceof String ) )
            throw new EvalError(
                    "Property expression must be a String or identifier.",
                    node, callstack );
        if ( toLHS )
            return new LHS(obj, (String)value);

        CollectionManager cm = CollectionManager.getCollectionManager();
        if ( cm.isMap( obj ) )
        {
            Object val = cm.getFromMap( obj, value );
            return ( val == null ?  val = Primitive.NULL : val );
        }
        try {
            return Reflect.getObjectProperty( obj, (String)value );
        }
        catch ( UtilEvalError e)
        {
            throw e.toEvalError( "Property: "+value, node, callstack );
        }
        catch (ReflectError e)
        {
            throw new EvalError("No such property: " + value, node, callstack );
        }
    }
    @Override
    public Object visit(BSHPrimarySuffix node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimarySuffix class.", node);
    }
    @Override
    public Object visit(BSHPrimitiveType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimitiveType class.", node);
    }
    @Override
    public Object visit(BSHReturnStatement node) {
        Object value;
        if(node.jjtGetNumChildren() > 0)
            value = ((SimpleNode)node.jjtGetChild(0)).accept(this);
        else
            value = Primitive.VOID;
        return new ReturnControl( node.kind, value, node );
    }
    @Override
    public Object visit(BSHReturnType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHPrimarySuffix class.");
    }
    @Override
    public Object visit(BSHStatementExpressionList node) {
        int n = node.jjtGetNumChildren();
        for(int i=0; i<n; i++)
        {
            SimpleNode nn = ((SimpleNode)node.jjtGetChild(i));
            nn.accept(this);
        }
        return Primitive.VOID;
    }
    @Override
    public Object visit(BSHSwitchLabel node) {
        if ( node.isDefault )
            return null; 
        SimpleNode label = ((SimpleNode)node.jjtGetChild(0));
        return label.accept(this);
    }
    @Override
    public Object visit(BSHSwitchStatement node) {
        int numchild = node.jjtGetNumChildren();
        int child = 0;
        SimpleNode switchExp = ((SimpleNode)node.jjtGetChild(child++));
        Object switchVal = switchExp.accept(this);

        BSHSwitchLabel label;
        Object obj;
        ReturnControl returnControl=null;

        if ( child >= numchild )
            throw new EvalError("Empty switch statement.", node, callstack );
        label = ((BSHSwitchLabel)node.jjtGetChild(child++));

        while ( child < numchild && returnControl == null )
        {

            if ( label.isDefault
                    || primitiveEquals(node, switchVal, label.accept(this), switchExp) )  {

                while ( child < numchild )
                {
                    obj = node.jjtGetChild(child++);
                    if ( obj instanceof BSHSwitchLabel )
                        continue;

                    Object value =
                            ((SimpleNode)obj).accept(this);

                    if ( value instanceof ReturnControl ) {
                        returnControl = (ReturnControl)value;
                        break;
                    }
                }
            } else
            {

                while ( child < numchild )
                {
                    obj = node.jjtGetChild(child++);
                    if ( obj instanceof BSHSwitchLabel ) {
                        label = (BSHSwitchLabel)obj;
                        break;
                    }
                }
            }
        }
        if ( returnControl != null && returnControl.kind == ParserConstants.RETURN )
            return returnControl;
        else
            return Primitive.VOID;
    }

    public boolean primitiveEquals( BSHSwitchStatement node,
            Object switchVal, Object targetVal,
            SimpleNode switchExp  )
            throws EvalError
    {
        if ( switchVal instanceof Primitive || targetVal instanceof Primitive )
            try {

                Object result = Primitive.binaryOperation(
                        switchVal, targetVal, ParserConstants.EQ );
                result = Primitive.unwrap( result );
                return result.equals( Boolean.TRUE );
            } catch ( UtilEvalError e ) {
                throw e.toEvalError(
                        "Switch value: "+switchExp.getText()+": ",
                        node, callstack );
            }
        else
            return switchVal.equals( targetVal );
    }
    @Override
    public Object visit(BSHTernaryExpression node) {
        SimpleNode
                cond = (SimpleNode)node.jjtGetChild(0),
                evalTrue = (SimpleNode)node.jjtGetChild(1),
                evalFalse = (SimpleNode)node.jjtGetChild(2);
        if ( BshInterpreterUtil.evaluateCondition(cond, this) )
            return evalTrue.accept(this);
        else
            return evalFalse.accept(this);
    }
    @Override
    public Object visit(BSHThrowStatement node) {
        Object obj = ((SimpleNode)node.jjtGetChild(0)).accept(this);

        if(!(obj instanceof Exception))
            throw new EvalError("Expression in 'throw' must be Exception type",
                    node, callstack );

        throw new TargetError( (Exception)obj, node, callstack );
    }
    @Override
    public Object visit(BSHTryStatement node) {
        BSHBlock tryBlock = ((BSHBlock)node.jjtGetChild(0));
        List<BSHFormalParameter> catchParams = new ArrayList<BSHFormalParameter>();
        List<BSHBlock> catchBlocks = new ArrayList<BSHBlock>();
        int nchild = node.jjtGetNumChildren();
        Node nodeObj = null;
        int i=1;
        while((i < nchild) && ((nodeObj = node.jjtGetChild(i++)) instanceof BSHFormalParameter))
        {
            catchParams.add((BSHFormalParameter)nodeObj);
            catchBlocks.add((BSHBlock)node.jjtGetChild(i++));
            nodeObj = null;
        }

        BSHBlock finallyBlock = null;
        if(nodeObj != null)
            finallyBlock = (BSHBlock)nodeObj;

        TargetError target = null;
        Throwable thrown = null;
        Object ret = null;

        int callstackDepth = callstack.depth();
        try {
            ret = tryBlock.accept(this);
        }
        catch( TargetError e ) {
            target = e;
            String stackInfo = "Bsh Stack: ";
            while ( callstack.depth() > callstackDepth )
                stackInfo += "\t" + callstack.pop() +"\n";
        }

        if ( target != null )
            thrown = target.getTarget();

        if (thrown != null)
        {
            int n = catchParams.size();
            for(i=0; i<n; i++)
            {

                BSHFormalParameter fp = catchParams.get(i);

                fp.accept(this);
                if ( fp.type == null && interpreter.getStrictJava() )
                    throw new EvalError(
                            "(Strict Java) Untyped catch block", node, callstack );

                if ( fp.type != null )
                    try {
                        thrown = (Throwable)Types.castObject(
                                thrown, fp.type, Types.ASSIGNMENT );
                    } catch( UtilEvalError e ) {

                        continue;
                    }

                BSHBlock cb = catchBlocks.get(i);

                NameSpace enclosingNameSpace = callstack.top();
                BlockNameSpace cbNameSpace =
                        new BlockNameSpace( enclosingNameSpace );
                try {
                    if ( fp.type == BSHFormalParameter.UNTYPED )

                        cbNameSpace.setBlockVariable( fp.name, thrown );
                    else
                    {

                        Modifiers modifiers = new Modifiers();
                        cbNameSpace.setTypedVariable(
                                fp.name, fp.type, thrown, new Modifiers() );
                    }
                } catch ( UtilEvalError e ) {
                    throw new InterpreterError(
                            "Unable to set var in catch block namespace." );
                }

                callstack.swap( cbNameSpace );
                try {
                    ret = cb.accept(this);
                } finally {

                    callstack.swap( enclosingNameSpace );
                }
                target = null;  
                break;
            }
        }

        if( finallyBlock != null ) {
            Object result = finallyBlock.accept(this);
            if( result instanceof ReturnControl )
                return result;
        }

        if(target != null)
            throw target;
        if(ret instanceof ReturnControl)
            return ret;
        else
            return Primitive.VOID;
    }
    @Override
    public Object visit(BSHType node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHType class.", node);
    }

    public String getTypeDescriptor( BSHType node, String defaultPackage )
    {

        if ( node.descriptor != null )
            return node.descriptor;
        String descriptor;

        SimpleNode typeNode = node.getTypeNode();
        if ( typeNode instanceof BSHPrimitiveType)
            descriptor = BshInterpreterUtil.getTypeDescriptor( ((BSHPrimitiveType)typeNode).type );
        else
        {
            String clasName = ((BSHAmbiguousName)typeNode).text;
            BshClassManager bcm = interpreter.getClassManager();

            String definingClass = bcm.getClassBeingDefined( clasName );
            Class clas = null;
            if ( definingClass == null )
            {
                try {
                    clas = ambiguousNameToClass(((BSHAmbiguousName)typeNode) );
                } catch ( EvalError e ) {

                }
            } else
                clasName = definingClass;
            if ( clas != null )
            {

                descriptor = BshInterpreterUtil.getTypeDescriptor( clas );
            }else
            {
                if ( defaultPackage == null || Name.isCompound( clasName ) )
                    descriptor = "L" + clasName.replace('.','/') + ";";
                else
                    descriptor =
                            "L"+defaultPackage.replace('.','/')+"/"+clasName + ";";
            }
        }
        for(int i=0; i<node.arrayDims; i++)
            descriptor = "["+descriptor;
        node.descriptor = descriptor;

        return descriptor;
    }
    public Class getType(BSHType tnode)
            throws EvalError
    {

        if ( tnode.type != null )
            return tnode.type;

        SimpleNode node = tnode.getTypeNode();
        if ( node instanceof BSHPrimitiveType )
            tnode.baseType = ((BSHPrimitiveType)node).getType();
        else
            tnode.baseType = ambiguousNameToClass(((BSHAmbiguousName)node));
        if ( tnode.arrayDims > 0 ) {
            try {

                int[] dims = new int[tnode.arrayDims]; 
                Object obj = Array.newInstance(tnode.baseType, dims);
                tnode.type = obj.getClass();
            } catch(Exception e) {
                throw new EvalError("Couldn't construct array type",
                        tnode, callstack );
            }
        } else
            tnode.type = tnode.baseType;

        interpreter.getClassManager().addListener(tnode);
        return tnode.type;
    }
    @Override
    public Object visit(BSHTypedVariableDeclaration node) {
        try {
            NameSpace namespace = callstack.top();
            BSHType typeNode = node.getTypeNode();
            Class type = getType(typeNode);
            BSHVariableDeclarator [] bvda = node.getDeclarators();
            for (int i = 0; i < bvda.length; i++)
            {
                BSHVariableDeclarator dec = bvda[i];

                Object value = evalVariableDeclarator(dec, typeNode);
                try {
                    namespace.setTypedVariable(
                            dec.name, type, value, node.modifiers );
                } catch ( UtilEvalError e ) {
                    throw e.toEvalError( node, callstack );
                }
            }
        } catch ( EvalError e ) {
            e.reThrow( "Typed variable declaration" );
        }
        return Primitive.VOID;
    }
    public Class evalType( BSHTypedVariableDeclaration node )
            throws EvalError
    {
        BSHType typeNode = node.getTypeNode();
        return getType( typeNode );
    }
    @Override
    public Object visit(BSHUnaryExpression node) {
        SimpleNode simpleNode = (SimpleNode)node.jjtGetChild(0);

        try {
            if ( node.kind == ParserConstants.INCR || node.kind == ParserConstants.DECR ) {
                LHS lhs = primaryExprToLHS((BSHPrimaryExpression) simpleNode);
                return node.lhsUnaryOperation(lhs, interpreter.getStrictJava());
            } else
                return
                        node.unaryOperation(simpleNode.accept(this), node.kind);
        } catch ( UtilEvalError e ) {
            throw e.toEvalError( node, callstack );
        }
    }

    private Object evalVariableDeclarator(BSHVariableDeclarator node, BSHType typeNode)
            throws EvalError
    {

        Object value = null;
        if ( node.jjtGetNumChildren() > 0 )
        {
            SimpleNode initializer = (SimpleNode)node.jjtGetChild(0);

            if ( (typeNode != null)
                    && initializer instanceof BSHArrayInitializer
                    )
                value = evalArrayInitializer(((BSHArrayInitializer) initializer),
                        typeNode.getBaseType(), typeNode.getArrayDims(),
                        callstack, interpreter);
            else
                value = initializer.accept(this);
        }
        if ( value == Primitive.VOID )
            throw new EvalError("Void initializer.", node, callstack );
        return value;
    }
    @Override
    public Object visit(BSHVariableDeclarator node) {
        throw new InterpreterError(
                "Unimplemented or inappropriate for BSHVariableDeclarator class.");
    }
    @Override
    public Object visit(BSHWhileStatement node) {
        int numChild = node.jjtGetNumChildren();

        final SimpleNode condExp;
        final SimpleNode body;
        if ( node.isDoStatement ) {
            condExp = (SimpleNode) node.jjtGetChild(1);
            body = (SimpleNode) node.jjtGetChild(0);
        } else {
            condExp = (SimpleNode) node.jjtGetChild(0);
            if ( numChild > 1 )	{
                body = (SimpleNode) node.jjtGetChild(1);
            } else {
                body = null;
            }
        }
        boolean doOnceFlag = node.isDoStatement;
        while (doOnceFlag || BshInterpreterUtil.evaluateCondition(condExp, this)) {
            doOnceFlag = false;

            if ( body == null ) {
                continue;
            }
            Object ret = body.accept(this);
            if (ret instanceof ReturnControl) {
                switch(( (ReturnControl)ret).kind ) {
                    case ParserConstants.RETURN:
                        return ret;
                    case ParserConstants.CONTINUE:
                        break;
                    case ParserConstants.BREAK:
                        return Primitive.VOID;
                }
            }
        }
        return Primitive.VOID;
    }
}
package	bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.Serializable;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.lang.reflect.Method;
import java.lang.reflect.Field;

public class NameSpace implements Serializable, BshClassManager.Listener, NameSource, Cloneable {

	private static final long serialVersionUID = 5004976946651004751L;
	public static final NameSpace JAVACODE = 
		new NameSpace((BshClassManager)null, "Called from compiled Java code.");
	static {
		JAVACODE.isMethod = true;
	}

	private String nsName; 
    private NameSpace parent;
    private Map<String,Variable> variables;
    private Map<String,List<BshMethod>> methods;
    protected Map<String,String> importedClasses;
    private List<String> importedPackages;
    private List<String> importedCommands;
	private List<Object> importedObjects;
	private List<Class> importedStatic;
	private String packageName;
	transient private BshClassManager classManager;

    private This thisReference;

    private Map<String,Name> names;

	SimpleNode callerInfoNode;

	public boolean isMethod;

	public boolean isClass;
	Class classStatic;	
	Object classInstance;

	void setClassStatic( Class clas ) {
		this.classStatic = clas;
		importStatic( clas );
	}
	void setClassInstance( Object instance ) {
		this.classInstance = instance;
		importObject( instance );
	}
	Object getClassInstance()
		throws UtilEvalError
	{
		if ( classInstance != null )
			return classInstance;
		if ( classStatic != null 

		)
			throw new UtilEvalError(
				"Can't refer to class instance from static context.");
		else
			throw new InterpreterError( 
				"Can't resolve class instance 'this' in: "+this);
	}

    transient private Map<String,Class> classCache;

    public NameSpace( NameSpace parent, String name ) 
	{

		this( parent, null, name );
	}
    public NameSpace( BshClassManager classManager, String name ) 
	{
		this( null, classManager, name );
	}
    public NameSpace( 
		NameSpace parent, BshClassManager classManager, String name ) 
	{

		setName(name);
		setParent(parent);
		setClassManager( classManager );

		if ( classManager != null )
			classManager.addListener(this);
    }

	public void setName( String name ) {
		this.nsName = name;
	}

	public String getName() {
		return this.nsName;
	}

	void setNode( SimpleNode node ) {
		callerInfoNode = node;
	}

	SimpleNode getNode() 
	{
		if ( callerInfoNode != null )
			return callerInfoNode;
		if ( parent != null )
			return parent.getNode();
		else
			return null;
	}

	public Object get( String name, Interpreter interpreter ) 
		throws UtilEvalError 
	{
		CallStack callstack = new CallStack( this );
		return getNameResolver( name ).toObject( new BshEvaluatingVisitor(callstack, interpreter) );
	}

    public void	setVariable( String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{

		boolean recurse = Interpreter.LOCALSCOPING ? strictJava : true;
		setVariable( name, value, strictJava, recurse );
	}

    void setLocalVariable( 
		String name, Object value, boolean strictJava ) 
		throws UtilEvalError 
	{
		setVariable( name, value, strictJava, false );
	}

    void setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		ensureVariables();

		if ( value == null )
			throw new InterpreterError("null variable value");

		Variable existing = getVariableImpl( name, recurse );

		if ( existing != null )
		{
			try {
				existing.setValue( value, Variable.ASSIGNMENT );
			} catch ( UtilEvalError e ) {
				throw new UtilEvalError(
					"Variable assignment: " + name + ": " + e.getMessage());
			}
		} else 

		{
			if ( strictJava )
				throw new UtilEvalError(
					"(Strict Java mode) Assignment to undeclared variable: "
					+name );

			NameSpace varScope = this;
			varScope.variables.put( 
				name, new Variable( name, value, null ) );

			nameSpaceChanged();
    	}
	}
	private void ensureVariables() {
		if ( variables == null )
			variables =	new HashMap<String,Variable>();
	}

	public void unsetVariable( String name )
	{
		if ( variables != null )
		{
			variables.remove( name );
			nameSpaceChanged();
		}
	}

	public String [] getVariableNames() {
		if ( variables == null )
			return new String [0];
		else
			return variables.keySet().toArray(new String[0]);
	}

	public String [] getMethodNames() 
	{
		if ( methods == null )
			return new String [0];
		else
			return methods.keySet().toArray(new String[0]);
	}

	public BshMethod [] getMethods() 
	{
		if ( methods == null ) {
			return new BshMethod [0];
		} else {
			List<BshMethod> ret = new ArrayList<BshMethod>();
			for( List<BshMethod> list : methods.values() ) {
				ret.addAll(list);
			}
			return ret.toArray(new BshMethod[0]);
		}
	}

	public NameSpace getParent() {
		return parent;
	}

    public This getSuper( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getThis( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }

    public This getGlobal( Interpreter declaringInterpreter )
    {
		if ( parent != null )
			return parent.getGlobal( declaringInterpreter );
		else
			return getThis( declaringInterpreter );
    }

    public This getThis( Interpreter declaringInterpreter ) 
	{
		if ( thisReference == null )
			thisReference = This.getThis( this, declaringInterpreter );
		return thisReference;
    }
	public BshClassManager getClassManager() 
	{
		if ( classManager != null )
			return classManager;
		if ( parent != null && parent != JAVACODE )
			return parent.getClassManager();
		classManager = BshClassManager.createClassManager( null );

		return classManager;
	}
	void setClassManager( BshClassManager classManager ) {
		this.classManager = classManager;
	}

	public void prune() 
	{

		if ( this.classManager == null )

			setClassManager( 
				BshClassManager.createClassManager( null ) );
		setParent( null );
	}
	public void setParent( NameSpace parent ) 
	{
		this.parent = parent;

		if ( parent == null )
			loadDefaultImports();
	}

    public Object getVariable( String name ) 
		throws UtilEvalError
	{
		return getVariable( name, true );
	}

    public Object getVariable( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = getVariableImpl( name, recurse );
		return unwrapVariable( var );
    }

    protected Variable getVariableImpl( String name, boolean recurse ) 
		throws UtilEvalError
	{
		Variable var = null;

		if ( var == null && isClass )
			var = getImportedVar( name );
		if ( var == null && variables != null )
			var	= (Variable)variables.get(name);

		if ( var == null && !isClass )
			var = getImportedVar( name );

		if ( recurse && (var == null) && (parent != null) )
			var	= parent.getVariableImpl( name, recurse );
		return var;
    }

	public Variable [] getDeclaredVariables() 
	{
		if ( variables == null )
			return new Variable[0];
		return variables.values().toArray(new Variable[0]);
	}

	protected Object unwrapVariable( Variable var ) 
		throws UtilEvalError
	{
		return (var == null) ? Primitive.VOID :	var.getValue();
	}

    public void	setTypedVariable(
		String	name, Class type, Object value,	boolean	isFinal )
		throws UtilEvalError 
	{
		Modifiers modifiers = new Modifiers();
		if ( isFinal )
			modifiers.addModifier( Modifiers.FIELD, "final" );
		setTypedVariable( name, type, value, modifiers );
	}

    public void	setTypedVariable(
		String	name, Class type, Object value,	Modifiers modifiers )
		throws UtilEvalError 
	{

		ensureVariables();

		Variable existing = getVariableImpl( name, false );

		if ( existing != null ) 
		{

			if ( existing.getType() != null ) 
			{

				if ( existing.getType() != type )
				{
					throw new UtilEvalError( "Typed variable: "+name
						+" was previously declared with type: " 
						+ existing.getType() );
				} else 
				{

					existing.setValue( value, Variable.DECLARATION );
					return;
				}
			}

		} 

		variables.put( name, new Variable( name, type, value, modifiers ) );
    }

    public void	setMethod( BshMethod method )
		throws UtilEvalError
	{

		if ( methods == null )
			methods = new HashMap<String,List<BshMethod>>();
		String name = method.getName();
		List<BshMethod> list = methods.get(name);
		if ( list == null ) {
			methods.put(name, Collections.singletonList(method));
		} else {
			if( !(list instanceof ArrayList) ) {
				list = new ArrayList<BshMethod>(list);
				methods.put( name, list );
			}
			list.remove(method);
			list.add( method );
		}
    }

    public BshMethod getMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{
		return getMethod( name, sig, false );
	}

    public BshMethod getMethod( 
		String name, Class [] sig, boolean declaredOnly ) 
		throws UtilEvalError
	{
		BshMethod method = null;

		if ( method == null && isClass && !declaredOnly )
			method = getImportedMethod( name, sig );
		if ( method == null && methods != null )
		{
			List<BshMethod> list = methods.get(name);
			if ( list != null ) 
			{

				Class [][] candidates = new Class[ list.size() ][];
				for( int i=0; i< candidates.length; i++ )
					candidates[i] = list.get(i).getParameterTypes();
				int match = 
					Reflect.findMostSpecificSignature( sig, candidates );
				if ( match != -1 )
					method = list.get(match);
			}
		}
		if ( method == null && !isClass && !declaredOnly )
			method = getImportedMethod( name, sig );

		if ( !declaredOnly && (method == null) && (parent != null) )
			return parent.getMethod( name, sig );
		return method;
    }

    public void	importClass(String name)
    {
		if ( importedClasses == null )
			importedClasses = new HashMap<String,String>();
		importedClasses.put( Name.suffix(name, 1), name );
		nameSpaceChanged();
    }

    public void	importPackage(String name)
    {
		if(importedPackages == null)
			importedPackages = new ArrayList<String>();

		importedPackages.remove( name );
		importedPackages.add(name);
		nameSpaceChanged();
    }

    public void	importCommands( String name )
    {
		if ( importedCommands == null )
			importedCommands = new ArrayList<String>();

		name = name.replace('.','/');

		if ( !name.startsWith("/") )
			name = "/"+name;

		if ( name.length() > 1 && name.endsWith("/") )
			name = name.substring( 0, name.length()-1 );

		importedCommands.remove( name );
		importedCommands.add(name);
		nameSpaceChanged();
    }

	public Object getCommand( 	
		String name, Class [] argTypes, Interpreter interpreter ) 
		throws UtilEvalError
	{
		if (Interpreter.DEBUG) Interpreter.debug("getCommand: "+name);
		BshClassManager bcm = interpreter.getClassManager();
		if ( importedCommands != null )
		{

			for(int i=importedCommands.size()-1; i>=0; i--)
			{
				String path = importedCommands.get(i);
				String scriptPath; 
				if ( path.equals("/") )
					scriptPath = path + name +".bsh";
				else
					scriptPath = path +"/"+ name +".bsh";
				Interpreter.debug("searching for script: "+scriptPath );
        		InputStream in = bcm.getResourceAsStream( scriptPath );
				if ( in != null )
					return loadScriptedCommand( 
						in, name, argTypes, scriptPath, interpreter );

				String className;
				if ( path.equals("/") )
					className = name;
				else
					className = path.substring(1).replace('/','.') +"."+name;
				Interpreter.debug("searching for class: "+className);
        		Class clas = bcm.classForName( className );
				if ( clas != null )
					return clas;
			}
		}
		if ( parent != null )
			return parent.getCommand( name, argTypes, interpreter );
		else
			return null;
	}
	protected BshMethod getImportedMethod( String name, Class [] sig ) 
		throws UtilEvalError
	{

		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.get(i);
			Class clas = object.getClass();
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, false );
			if ( method != null )
				return new BshMethod( method, object );
		}

		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = importedStatic.get(i);
			Method method = Reflect.resolveJavaMethod( 
				getClassManager(), clas, name, sig, true );
			if ( method != null )
				return new BshMethod( method, null );
		}
		return null;
	}
	protected Variable getImportedVar( String name ) 
		throws UtilEvalError
	{

		if ( importedObjects != null )
		for(int i=0; i<importedObjects.size(); i++)
		{
			Object object = importedObjects.get(i);
			Class clas = object.getClass();
			Field field = Reflect.resolveJavaField( 
				clas, name, false );
			if ( field != null )
				return new Variable( 
					name, field.getType(), new LHS( object, field ) );
		}

		if ( importedStatic!= null )
		for(int i=0; i<importedStatic.size(); i++)
		{
			Class clas = importedStatic.get(i);
			Field field = Reflect.resolveJavaField( 
				clas, name, true );
			if ( field != null )
				return new Variable( name, field.getType(), new LHS( field ) );
		}
		return null;
	}

	private BshMethod loadScriptedCommand( 
		InputStream in, String name, Class [] argTypes, String resourcePath, 
		Interpreter interpreter )
		throws UtilEvalError
	{
		try {
			interpreter.eval( 
				new InputStreamReader(in), this, resourcePath );
		} catch ( EvalError e ) {

			Interpreter.debug( e.toString() );
			throw new UtilEvalError( 
				"Error loading script: "+ e.getMessage(), e);
		}

		BshMethod meth = getMethod( name, argTypes );

		return meth;
	}

	void cacheClass( String name, Class c ) {
		if ( classCache == null ) {
			classCache = new HashMap<String,Class>();

		}
		classCache.put(name, c);
	}

    public Class getClass( String name )
		throws UtilEvalError
    {
		Class c = getClassImpl(name);
		if ( c != null )
			return c;
		else

			if ( parent != null )
				return parent.getClass( name );
			else
				return null;
	}

    private Class getClassImpl( String name )
		throws UtilEvalError
    {
		Class c = null;

		if (classCache != null) {
			c =	classCache.get(name);
			if ( c != null )
				return c;
		}

		boolean unqualifiedName = !Name.isCompound(name);

		if ( unqualifiedName ) 
		{

			if ( c == null )
				c = getImportedClassImpl( name );

			if ( c != null ) {
				cacheClass( name, c );
				return c;
			}
		}

		c = classForName( name );
		if ( c != null ) {

			if ( unqualifiedName )
				cacheClass( name, c );
			return c;
		}

		if ( Interpreter.DEBUG ) 
			Interpreter.debug("getClass(): " + name	+ " not	found in "+this);
		return null;
    }

    private Class getImportedClassImpl( String name )
		throws UtilEvalError
    {

		String fullname = null;
		if ( importedClasses != null )
			fullname = importedClasses.get(name);

		if ( fullname != null ) 
		{

			Class clas = classForName(fullname);

			if ( clas != null )
				return clas;

			if ( Name.isCompound( fullname ) )
				try {
					clas = getNameResolver( fullname ).toClass();
				} catch ( ClassNotFoundException e ) {  }
			else 
				if ( Interpreter.DEBUG ) Interpreter.debug(
					"imported unpackaged name not found:" +fullname);

			if ( clas != null ) {

				getClassManager().cacheClassInfo( fullname, clas );
				return clas;
			}

			return null;  
		}

		if ( importedPackages != null )
			for(int i=importedPackages.size()-1; i>=0; i--)
			{
				String s = importedPackages.get(i) + "." + name;
				Class c=classForName(s);
				if ( c != null )
					return c;
			}
		BshClassManager bcm = getClassManager();

		if ( bcm.hasSuperImport() ) 
		{
			String s = bcm.getClassNameByUnqName( name );
			if ( s != null )
				return classForName( s );
		}
		return null;
    }
	private Class classForName( String name ) 
	{
		return getClassManager().classForName( name );
	}

	public String [] getAllNames() 
	{
		List<String> list = new ArrayList<String>();
		getAllNamesAux( list );
		return list.toArray(new String[0]);
	}

	protected void getAllNamesAux( List<String> list ) 
	{
		list.addAll( variables.keySet() );
		list.addAll( methods.keySet() );
		if ( parent != null )
			parent.getAllNamesAux( list );
	}
	List<NameSource.Listener> nameSourceListeners;

	public void addNameSourceListener( NameSource.Listener listener ) {
		if ( nameSourceListeners == null )
			nameSourceListeners = new ArrayList<NameSource.Listener>();
		nameSourceListeners.add( listener );
	}

	public void doSuperImport() 
		throws UtilEvalError
	{
		getClassManager().doSuperImport();
	}
	public String toString() {
		return "NameSpace: " 
			+ ( nsName==null
				? super.toString()
				: nsName + " (" + super.toString() +")" )
			+ ( isClass ? " (isClass) " : "" )
			+ ( isMethod ? " (method) " : "" )
			+ ( classStatic != null ? " (class static) " : "" )
			+ ( classInstance != null ? " (class instance) " : "" );
	}

    private synchronized void writeObject(java.io.ObjectOutputStream s)
        throws IOException 
	{

		names = null;

		s.defaultWriteObject();
	}

	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter ) 
		throws EvalError
	{
		return invokeMethod( 
			methodName, args, interpreter, null, null );
	}

	public Object invokeMethod( 
		String methodName, Object [] args, Interpreter interpreter, 
		CallStack callstack, SimpleNode callerInfo ) 
		throws EvalError
	{
		return getThis( interpreter ).invokeMethod( 
			methodName, args, interpreter, callstack, callerInfo,
			false );
	}

	public void classLoaderChanged() {
		nameSpaceChanged();
	}

	public void nameSpaceChanged() {
		classCache = null;
		names = null;
	}

    public void loadDefaultImports()
    {

		importClass("bsh.EvalError");
		importClass("bsh.Interpreter");
		importPackage("javax.swing.event");
		importPackage("javax.swing");
		importPackage("java.awt.event");
		importPackage("java.awt");
		importPackage("java.net");
		importPackage("java.util");
		importPackage("java.io");
		importPackage("java.lang");
		importCommands("/bsh/commands");
    }

	public Name getNameResolver( String ambigname )
	{
		if ( names == null )
			names = new HashMap<String,Name>();
		Name name = names.get( ambigname );
		if ( name == null ) {
			name = new Name( this, ambigname );
			names.put( ambigname, name );
		} 
		return name;
	}
	public int getInvocationLine() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getLineNumber();
		else
			return -1;
	}
	public String getInvocationText() {
		SimpleNode node = getNode();
		if ( node != null )
			return node.getText();
		else
			return "<invoked from Java code>";
	}

	public static Class identifierToClass( ClassIdentifier ci ) 
	{
		return ci.getTargetClass();
	}

	public void clear() 
	{
		variables = null;
		methods = null;
		importedClasses = null;
		importedPackages = null;
		importedCommands = null;
		importedObjects = null;
		if ( parent == null )
			loadDefaultImports();	
    	classCache = null;
		names = null;
	}

	public void importObject( Object obj ) 
	{
		if ( importedObjects == null )
			importedObjects = new ArrayList<Object>();

		importedObjects.remove( obj );
		importedObjects.add( obj );
		nameSpaceChanged();
	}

	public void importStatic( Class clas ) 
	{
		if ( importedStatic == null )
			importedStatic = new ArrayList<Class>();

		importedStatic.remove( clas );
		importedStatic.add( clas );
		nameSpaceChanged();
	}

	public void setPackage( String packageName )
	{
		this.packageName = packageName;
	}
	String getPackage() 
	{
		if ( packageName != null )
			return packageName;
		if ( parent != null )
			return parent.getPackage();

		return null;
	}
	NameSpace copy() {
		try {
			final NameSpace clone = (NameSpace) clone();
			clone.thisReference = null;
			clone.variables = clone(variables);
			clone.methods = clone(methods);
			clone.importedClasses = clone(importedClasses);
			clone.importedPackages = clone(importedPackages);
			clone.importedCommands = clone(importedCommands);
			clone.importedObjects = clone(importedObjects);
			clone.importedStatic = clone(importedStatic);
			clone.names = clone(names);
			return clone;
		} catch (CloneNotSupportedException e) {
			throw new IllegalStateException(e);
		}
	}
	private <K,V> Map<K,V> clone(final Map<K,V> map) {
		if (map == null) {
			return null;
		}
		return new HashMap<K,V>(map);
	}
	private <T> List<T> clone(final List<T> list) {
		if (list == null) {
			return null;
		}
		return new ArrayList<T>(list);
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.ArrayList;

public final class Reflect {

	public static Object invokeObjectMethod(Object object, String methodName, Object[] args, BshEvaluatingVisitor visitor, SimpleNode callerInfo) throws ReflectError, EvalError, InvocationTargetException {

		if (object instanceof This && !This.isExposedThisMethod(methodName)) {
			return ((This) object).invokeMethod(methodName, args, visitor.getInterpreter(), visitor.getCallstack(), callerInfo, false);
		}

		try {
			BshClassManager bcm = visitor.getInterpreter() == null ? null : visitor.getInterpreter().getClassManager();
			Class clas = object.getClass();
			Method method = resolveExpectedJavaMethod(bcm, clas, object, methodName, args, false);
			return invokeMethod(method, object, args);
		} catch (UtilEvalError e) {
			throw e.toEvalError(callerInfo, visitor.getCallstack());
		}
	}

	public static Object invokeStaticMethod(BshClassManager bcm, Class clas, String methodName, Object[] args) throws ReflectError, UtilEvalError, InvocationTargetException {
		Interpreter.debug("invoke static Method");
		Method method = resolveExpectedJavaMethod(bcm, clas, null, methodName, args, true);
		return invokeMethod(method, null, args);
	}

	public static Object invokeMethod(Method method, Object object, Object[] args) throws ReflectError, InvocationTargetException {
		if (args == null) {
			args = new Object[0];
		}
		logInvokeMethod("Invoking method (entry): ", method, args);
		boolean isVarArgs = method.isVarArgs();

		Class[] types = method.getParameterTypes();
		Object[] tmpArgs = new Object[types.length];
		int fixedArgLen = types.length;
		if (isVarArgs) {
			if (fixedArgLen == args.length && types[fixedArgLen - 1].isAssignableFrom(args[fixedArgLen - 1].getClass())) {
				isVarArgs = false;
			} else {
				fixedArgLen--;
			}
		}
		try {
			for (int i = 0; i < fixedArgLen; i++) {
				tmpArgs[i] = Types.castObject(args[i], types[i], Types.ASSIGNMENT);
			}
			if (isVarArgs) {
				Class varType = types[fixedArgLen].getComponentType();
				Object varArgs = Array.newInstance(varType, args.length - fixedArgLen);
				for (int i = fixedArgLen, j = 0; i < args.length; i++, j++) {
					Array.set(varArgs, j, Primitive.unwrap(Types.castObject(args[i], varType, Types.ASSIGNMENT)));
				}
				tmpArgs[fixedArgLen] = varArgs;
			}
		} catch (UtilEvalError e) {
			throw new InterpreterError("illegal argument type in method invocation: " + e);
		}

		tmpArgs = Primitive.unwrap(tmpArgs);
		logInvokeMethod("Invoking method (after massaging values): ", method, tmpArgs);
		try {
			Object returnValue = method.invoke(object, tmpArgs);
			if (returnValue == null) {
				returnValue = Primitive.NULL;
			}
			Class returnType = method.getReturnType();
			return Primitive.wrap(returnValue, returnType);
		} catch (IllegalAccessException e) {
			throw new ReflectError("Cannot access method " + StringUtil.methodString(method.getName(), method.getParameterTypes()) + " in '" + method.getDeclaringClass() + "' :" + e, e);
		}
	}
	public static Object getIndex(Object array, int index) throws ReflectError, UtilTargetError {
		if (Interpreter.DEBUG) {
			Interpreter.debug("getIndex: " + array + ", index=" + index);
		}
		try {
			Object val = Array.get(array, index);
			return Primitive.wrap(val, array.getClass().getComponentType());
		} catch (ArrayIndexOutOfBoundsException e1) {
			throw new UtilTargetError(e1);
		} catch (Exception e) {
			throw new ReflectError("Array access:" + e);
		}
	}
	public static void setIndex(Object array, int index, Object val) throws ReflectError, UtilTargetError {
		try {
			val = Primitive.unwrap(val);
			Array.set(array, index, val);
		} catch (ArrayStoreException e2) {
			throw new UtilTargetError(e2);
		} catch (IllegalArgumentException e1) {

			throw new UtilTargetError(new ArrayStoreException(e1.toString()));
		} catch (Exception e) {
			throw new ReflectError("Array access:" + e);
		}
	}
	public static Object getStaticFieldValue(Class clas, String fieldName) throws UtilEvalError, ReflectError {
		return getFieldValue(clas, null, fieldName, true);
	}

	public static Object getObjectFieldValue(Object object, String fieldName) throws UtilEvalError, ReflectError {
		if (object instanceof This) {
			return ((This) object).namespace.getVariable(fieldName);
		} else if (object == Primitive.NULL) {

			throw new UtilTargetError(new NullPointerException("Attempt to access field '" + fieldName + "' on null value"));
		} else {
			try {
				return getFieldValue(object.getClass(), object, fieldName, false);
			} catch (ReflectError e) {

				if (hasObjectPropertyGetter(object.getClass(), fieldName)) {
					return getObjectProperty(object, fieldName);
				} else {
					throw e;
				}
			}
		}
	}
	public static LHS getLHSStaticField(Class clas, String fieldName) throws UtilEvalError, ReflectError {
		Field f = resolveExpectedJavaField(clas, fieldName, true);
		return new LHS(f);
	}

	public static LHS getLHSObjectField(Object object, String fieldName) throws UtilEvalError, ReflectError {
		if (object instanceof This) {

			boolean recurse = false;
			return new LHS(((This) object).namespace, fieldName, recurse);
		}
		try {
			Field f = resolveExpectedJavaField(object.getClass(), fieldName, false);
			return new LHS(object, f);
		} catch (ReflectError e) {

			if (hasObjectPropertySetter(object.getClass(), fieldName)) {
				return new LHS(object, fieldName);
			} else {
				throw e;
			}
		}
	}
	private static Object getFieldValue(Class clas, Object object, String fieldName, boolean staticOnly) throws UtilEvalError, ReflectError {
		try {
			Field f = resolveExpectedJavaField(clas, fieldName, staticOnly);
			Object value = f.get(object);
			Class returnType = f.getType();
			return Primitive.wrap(value, returnType);
		} catch (NullPointerException e) { 
			throw new ReflectError("???" + fieldName + " is not a static field.");
		} catch (IllegalAccessException e) {
			throw new ReflectError("Can't access field: " + fieldName);
		}
	}

	protected static Field resolveJavaField(Class clas, String fieldName, boolean staticOnly) throws UtilEvalError {
		try {
			return resolveExpectedJavaField(clas, fieldName, staticOnly);
		} catch (ReflectError e) {
			return null;
		}
	}

	protected static Field resolveExpectedJavaField(Class clas, String fieldName, boolean staticOnly) throws UtilEvalError, ReflectError {
		Field field;
		try {
			if (Capabilities.haveAccessibility()) {
				field = findAccessibleField(clas, fieldName);
			} else

			{
				field = clas.getField(fieldName);
			}
		} catch (NoSuchFieldException e) {
			throw new ReflectError("No such field: " + fieldName, e);
		} catch (SecurityException e) {
			throw new UtilTargetError("Security Exception while searching fields of: " + clas, e);
		}
		if (staticOnly && !Modifier.isStatic(field.getModifiers())) {
			throw new UtilEvalError("Can't reach instance field: " + fieldName + " from static context: " + clas.getName());
		}
		return field;
	}

	private static Field findAccessibleField(Class clas, String fieldName) throws UtilEvalError, NoSuchFieldException {
		Field field;

		try {
			field = clas.getField(fieldName);
			field.setAccessible(true);
			return field;
		} catch (NoSuchFieldException e) {

		}

		while (clas != null) {
			try {
				field = clas.getDeclaredField(fieldName);
				field.setAccessible(true);
				return field;

			} catch (NoSuchFieldException e) {

			}
			clas = clas.getSuperclass();
		}
		throw new NoSuchFieldException(fieldName);
	}

	protected static Method resolveExpectedJavaMethod(BshClassManager bcm, Class clas, Object object, String name, Object[] args, boolean staticOnly) throws ReflectError, UtilEvalError {
		if (object == Primitive.NULL) {

			throw new UtilTargetError(new NullPointerException("Attempt to invoke method " + name + " on null value"));
		}
		Class[] types = Types.getTypes(args);
		Method method = resolveJavaMethod(bcm, clas, name, types, staticOnly);
		if (method == null) {
			throw new ReflectError((staticOnly ? "Static method " : "Method ") + StringUtil.methodString(name, types) + " not found in class'" + clas.getName() + "'");
		}
		return method;
	}

	protected static Method resolveJavaMethod(BshClassManager bcm, Class clas, String name, Class[] types, boolean staticOnly) throws UtilEvalError {
		if (clas == null) {
			throw new InterpreterError("null class");
		}

		Method method = null;
		if (bcm == null) {
			Interpreter.debug("resolveJavaMethod UNOPTIMIZED lookup");
		} else {
			method = bcm.getResolvedMethod(clas, name, types, staticOnly);
		}
		if (method == null) {
			boolean publicOnly = !Capabilities.haveAccessibility();

			try {
				method = findOverloadedMethod(clas, name, types, publicOnly);
			} catch (SecurityException e) {
				throw new UtilTargetError("Security Exception while searching methods of: " + clas, e);
			}
			checkFoundStaticMethod(method, staticOnly, clas);

			if (method != null && (!publicOnly || isPublic(method))) {
				method.setAccessible(true);
			}

			if (method != null && bcm != null) {
				bcm.cacheResolvedMethod(clas, types, method);
			}
		}
		return method;
	}

	private static Method findOverloadedMethod(Class baseClass, String methodName, Class[] types, boolean publicOnly) {
		if (Interpreter.DEBUG) {
			Interpreter.debug("Searching for method: " + StringUtil.methodString(methodName, types) + " in '" + baseClass.getName() + "'");
		}
		List<Method> publicMethods = new ArrayList<Method>();
		List<Method> nonPublicMethods = publicOnly ? null : new ArrayList<Method>();
		gatherMethodsRecursive(baseClass, methodName, types.length, publicMethods, nonPublicMethods);
		if (Interpreter.DEBUG) {
			Interpreter.debug("Looking for most specific method: " + methodName);
		}
		Method method = findMostSpecificMethod(types, publicMethods);
		if (method == null && nonPublicMethods != null) {
			method = findMostSpecificMethod(types, nonPublicMethods);
		}
		return method;
	}

	private static void gatherMethodsRecursive(Class baseClass, String methodName, int numArgs, List<Method> publicMethods, List<Method> nonPublicMethods) {

		Class superclass = baseClass.getSuperclass();
		if (superclass != null) {
			gatherMethodsRecursive(superclass, methodName, numArgs, publicMethods, nonPublicMethods);
		}

		boolean isPublicClass = isPublic(baseClass);
		if (isPublicClass || nonPublicMethods != null) {
			Method[] methods = nonPublicMethods == null ? baseClass.getMethods() : baseClass.getDeclaredMethods();
			for (Method m : methods) {
				if (m.getName().equals(methodName) && (m.isVarArgs() ? m.getParameterTypes().length - 1 <= numArgs : m.getParameterTypes().length == numArgs)) {
					if (isPublicClass && isPublic(m)) {
						publicMethods.add(m);
					} else if (nonPublicMethods != null) {
						nonPublicMethods.add(m);
					}
				}
			}
		}

		for (Class intf : baseClass.getInterfaces()) {
			gatherMethodsRecursive(intf, methodName, numArgs, publicMethods, nonPublicMethods);
		}
	}

	public static Object constructObject(Class clas, Object[] args) throws ReflectError, InvocationTargetException {
		if (clas.isInterface()) {
			throw new ReflectError("Can't create instance of an interface: " + clas);
		}
		Class[] types = Types.getTypes(args);

		Constructor[] constructors = Capabilities.haveAccessibility() ? clas.getDeclaredConstructors() : clas.getConstructors();
		if (Interpreter.DEBUG) {
			Interpreter.debug("Looking for most specific constructor: " + clas);
		}
		Constructor con = findMostSpecificConstructor(types, constructors);
		if (con == null) {
			throw cantFindConstructor(clas, types);
		}
		if (!isPublic(con)) {
			con.setAccessible(true);
		}
		args = Primitive.unwrap(args);
		try {
			return con.newInstance(args);
		} catch (InstantiationException e) {
			throw new ReflectError("The class " + clas + " is abstract ");
		} catch (IllegalAccessException e) {
			throw new ReflectError("We don't have permission to create an instance." + "Use setAccessibility(true) to enable access.");
		} catch (IllegalArgumentException e) {
			throw new ReflectError("The number of arguments was wrong");
		}
	}

	static Constructor findMostSpecificConstructor(Class[] idealMatch, Constructor[] constructors) {
		int match = findMostSpecificConstructorIndex(idealMatch, constructors);
		return (match == -1) ? null : constructors[match];
	}
	static int findMostSpecificConstructorIndex(Class[] idealMatch, Constructor[] constructors) {
		Class[][] candidates = new Class[constructors.length][];
		for (int i = 0; i < candidates.length; i++) {
			candidates[i] = constructors[i].getParameterTypes();
		}
		return findMostSpecificSignature(idealMatch, candidates);
	}

	private static Method findMostSpecificMethod(Class[] idealMatch, List<Method> methods) {

		List<Class[]> candidateSigs = new ArrayList<Class[]>();
		List<Method> methodList = new ArrayList<Method>();
		for (Method method : methods) {
			Class[] parameterTypes = method.getParameterTypes();
			methodList.add(method);
			candidateSigs.add(parameterTypes);
			if (method.isVarArgs()) {
				Class[] candidateSig = new Class[idealMatch.length];
				int j = 0;
				for (; j < parameterTypes.length - 1; j++) {
					candidateSig[j] = parameterTypes[j];
				}
				Class varType = parameterTypes[j].getComponentType();
				for (; j < idealMatch.length; j++) {
					candidateSig[j] = varType;
				}
				methodList.add(method);
				candidateSigs.add(candidateSig);
			}
		}
		int match = findMostSpecificSignature(idealMatch, candidateSigs.toArray(new Class[candidateSigs.size()][]));
		return match == -1 ? null : methodList.get(match);
	}

	static int findMostSpecificSignature(Class[] idealMatch, Class[][] candidates) {
		for (int round = Types.FIRST_ROUND_ASSIGNABLE; round <= Types.LAST_ROUND_ASSIGNABLE; round++) {
			Class[] bestMatch = null;
			int bestMatchIndex = -1;
			for (int i = 0; i < candidates.length; i++) {
				Class[] targetMatch = candidates[i];

				if (Types.isSignatureAssignable(idealMatch, targetMatch, round) && ((bestMatch == null) || Types.isSignatureAssignable(targetMatch, bestMatch, Types.JAVA_BASE_ASSIGNABLE))) {
					bestMatch = targetMatch;
					bestMatchIndex = i;
				}
			}
			if (bestMatch != null) {
				return bestMatchIndex;
			}
		}
		return -1;
	}
	private static String accessorName(String getorset, String propName) {
		return getorset + String.valueOf(Character.toUpperCase(propName.charAt(0))) + propName.substring(1);
	}
	public static boolean hasObjectPropertyGetter(Class clas, String propName) {
		if (clas == Primitive.class) {
			return false;
		}
		String getterName = accessorName("get", propName);
		try {
			clas.getMethod(getterName, new Class[0]);
			return true;
		} catch (NoSuchMethodException e) {  }
		getterName = accessorName("is", propName);
		try {
			Method m = clas.getMethod(getterName, new Class[0]);
			return (m.getReturnType() == Boolean.TYPE);
		} catch (NoSuchMethodException e) {
			return false;
		}
	}
	public static boolean hasObjectPropertySetter(Class clas, String propName) {
		String setterName = accessorName("set", propName);
		Method[] methods = clas.getMethods();

		for (Method method : methods) {
			if (method.getName().equals(setterName)) {
				return true;
			}
		}
		return false;
	}
	public static Object getObjectProperty(Object obj, String propName) throws UtilEvalError, ReflectError {
		Object[] args = new Object[]{};
		Interpreter.debug("property access: ");
		Method method = null;
		Exception e1 = null, e2 = null;
		try {
			String accessorName = accessorName("get", propName);
			method = resolveExpectedJavaMethod(null, obj.getClass(), obj, accessorName, args, false);
		} catch (Exception e) {
			e1 = e;
		}
		if (method == null) {
			try {
				String accessorName = accessorName("is", propName);
				method = resolveExpectedJavaMethod(null, obj.getClass(), obj, accessorName, args, false);
				if (method.getReturnType() != Boolean.TYPE) {
					method = null;
				}
			} catch (Exception e) {
				e2 = e;
			}
		}
		if (method == null) {
			throw new ReflectError("Error in property getter: " + e1 + (e2 != null ? " : " + e2 : ""));
		}
		try {
			return invokeMethod(method, obj, args);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Property accessor threw exception: " + e.getTargetException());
		}
	}
	public static void setObjectProperty(Object obj, String propName, Object value) throws ReflectError, UtilEvalError {
		String accessorName = accessorName("set", propName);
		Object[] args = new Object[]{value};
		Interpreter.debug("property access: ");
		try {
			Method method = resolveExpectedJavaMethod(null, obj.getClass(), obj, accessorName, args, false);
			invokeMethod(method, obj, args);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Property accessor threw exception: " + e.getTargetException());
		}
	}

	public static String normalizeClassName(Class type) {
		if (!type.isArray()) {
			return type.getName();
		}
		StringBuilder className = new StringBuilder();
		try {
			className.append(getArrayBaseType(type).getName()).append(' ');
			for (int i = 0; i < getArrayDimensions(type); i++) {
				className.append("[]");
			}
		} catch (ReflectError e) {

		}
		return className.toString();
	}

	public static int getArrayDimensions(Class arrayClass) {
		if (!arrayClass.isArray()) {
			return 0;
		}
		return arrayClass.getName().lastIndexOf('[') + 1;  
	}

	public static Class getArrayBaseType(Class arrayClass) throws ReflectError {
		if (!arrayClass.isArray()) {
			throw new ReflectError("The class is not an array.");
		}
		return arrayClass.getComponentType();
	}

	public static Object invokeCompiledCommand(Class commandClass, Object[] args, BshEvaluatingVisitor visitor) throws UtilEvalError {

		Object[] invokeArgs = new Object[args.length + 2];
		invokeArgs[0] = visitor.getInterpreter();
		invokeArgs[1] = visitor.getCallstack();
		System.arraycopy(args, 0, invokeArgs, 2, args.length);
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		try {
			return Reflect.invokeStaticMethod(bcm, commandClass, "invoke", invokeArgs);
		} catch (InvocationTargetException e) {
			throw new UtilEvalError("Error in compiled command: " + e.getTargetException(), e);
		} catch (ReflectError e) {
			throw new UtilEvalError("Error invoking compiled command: " + e, e);
		}
	}
	private static void logInvokeMethod(String msg, Method method, Object[] args) {
		if (Interpreter.DEBUG) {
			Interpreter.debug(msg + method + " with args:");
			for (int i = 0; i < args.length; i++) {
				final Object arg = args[i];
				Interpreter.debug("args[" + i + "] = " + arg + " type = " + (arg == null ? "<unkown>" : arg.getClass()));
			}
		}
	}
	private static void checkFoundStaticMethod(Method method, boolean staticOnly, Class clas) throws UtilEvalError {

		if (method != null && staticOnly && !isStatic(method)) {
			throw new UtilEvalError("Cannot reach instance method: " + StringUtil.methodString(method.getName(), method.getParameterTypes()) + " from static context: " + clas.getName());
		}
	}
	private static ReflectError cantFindConstructor(Class clas, Class[] types) {
		if (types.length == 0) {
			return new ReflectError("Can't find default constructor for: " + clas);
		} else {
			return new ReflectError("Can't find constructor: " + StringUtil.methodString(clas.getName(), types) + " in class: " + clas.getName());
		}
	}
	private static boolean isPublic(Class c) {
		return Modifier.isPublic(c.getModifiers());
	}
	private static boolean isPublic(Method m) {
		return Modifier.isPublic(m.getModifiers());
	}
	private static boolean isPublic(Constructor c) {
		return Modifier.isPublic(c.getModifiers());
	}
	private static boolean isStatic(Method m) {
		return Modifier.isStatic(m.getModifiers());
	}
}
package bsh;
import bsh.ast.SimpleNode;
import java.lang.reflect.InvocationTargetException;
import java.io.PrintStream;

public final class TargetError extends EvalError 
{
	private final boolean inNativeCode;
	public TargetError(
		String msg, Throwable t, SimpleNode node, CallStack callstack,
		boolean inNativeCode )
	{
		super( msg, node, callstack, t );
		this.inNativeCode = inNativeCode;
	}
	public TargetError( Throwable t, SimpleNode node, CallStack callstack )
	{
		this("TargetError", t, node, callstack, false);
	}
	public Throwable getTarget()
	{

		Throwable target = getCause();
		if(target instanceof InvocationTargetException)
			return((InvocationTargetException)target).getTargetException();
		else
			return target;
	}
	public String getMessage() 
	{
		return super.getMessage() 
			+ "\nTarget exception: " + 
			printTargetError( getCause() );
	}
    public void printStackTrace( boolean debug, PrintStream out ) {
		if ( debug ) {
			super.printStackTrace( out );
			out.println("--- Target Stack Trace ---");
		}
		getCause().printStackTrace( out );
	}

	private String printTargetError( Throwable t ) 
	{
		return getCause().toString() + "\n" + xPrintTargetError( t );
	}

	private String xPrintTargetError( Throwable t ) 
	{
		String getTarget =
			"import java.lang.reflect.UndeclaredThrowableException;"+
			"String result=\"\";"+
			"while ( target instanceof UndeclaredThrowableException ) {"+
			"	target=target.getUndeclaredThrowable(); " +
			"	result+=\"Nested: \"+target.toString();" +
			"}"+
			"return result;";
		Interpreter i = new Interpreter();
		try {
			i.set("target", t);
			return (String)i.eval( getTarget );
		} catch ( EvalError e ) {
			throw new InterpreterError("xprintarget: "+e.toString() );
		}
	}

	public boolean inNativeCode() { 
		return inNativeCode; 
	}
}
package bsh;
import java.io.ObjectStreamException;
import java.util.HashMap;
import java.util.Map;

public final class Primitive implements ParserConstants, java.io.Serializable
{

	static final Map<Class,Class> wrapperMap = new HashMap<Class,Class>();
	static {
		wrapperMap.put( Boolean.TYPE, Boolean.class );
		wrapperMap.put( Byte.TYPE, Byte.class );
		wrapperMap.put( Short.TYPE, Short.class );
		wrapperMap.put( Character.TYPE, Character.class );
		wrapperMap.put( Integer.TYPE, Integer.class );
		wrapperMap.put( Long.TYPE, Long.class );
		wrapperMap.put( Float.TYPE, Float.class );
		wrapperMap.put( Double.TYPE, Double.class );
		wrapperMap.put( Boolean.class, Boolean.TYPE );
		wrapperMap.put( Byte.class, Byte.TYPE );
		wrapperMap.put( Short.class, Short.TYPE );
		wrapperMap.put( Character.class, Character.TYPE );
		wrapperMap.put( Integer.class, Integer.TYPE );
		wrapperMap.put( Long.class, Long.TYPE );
		wrapperMap.put( Float.class, Float.TYPE );
		wrapperMap.put( Double.class, Double.TYPE );
	}

    private Object value;
    private static class Special implements java.io.Serializable
    {
        private Special() { }
        public static final Special NULL_VALUE = new Special()
        {
            private Object readResolve() throws ObjectStreamException
            {
                return Special.NULL_VALUE;
            }
        };
        public static final Special VOID_TYPE = new Special()
        {
            private Object readResolve() throws ObjectStreamException
            {
                return Special.VOID_TYPE;
            }
        };
    }

    public static final Primitive NULL = new Primitive(Special.NULL_VALUE);

    public static final Primitive VOID = new Primitive(Special.VOID_TYPE);

    private Object readResolve() throws ObjectStreamException
    {
        if (value == Special.NULL_VALUE)
        {
            return Primitive.NULL;
        }
        else if (value == Special.VOID_TYPE)
        {
            return Primitive.VOID;
        }
        else
        {
            return this;
        }
    }

    public Primitive( Object value )
    {
        if ( value == null )
            throw new InterpreterError(
				"Use Primitve.NULL instead of Primitive(null)");
		if ( value != Special.NULL_VALUE 
			&& value != Special.VOID_TYPE &&
			!isWrapperType( value.getClass() ) 
		)
            throw new InterpreterError( "Not a wrapper type: "+value);
        this.value = value;
    }
    public Primitive(boolean value) { this(new Boolean(value)); }
    public Primitive(byte value) { this(new Byte(value)); }
    public Primitive(short value) { this(new Short(value)); }
    public Primitive(char value) { this(new Character(value)); }
    public Primitive(int value) { this(new Integer(value)); }
    public Primitive(long value) { this(new Long(value)); }
    public Primitive(float value) { this(new Float(value)); }
    public Primitive(double value) { this(new Double(value)); }

    public Object getValue()
    {
        if ( value == Special.NULL_VALUE )
            return null;
        else 
		if ( value == Special.VOID_TYPE )
                throw new InterpreterError("attempt to unwrap void type");
        else
            return value;
    }
    public String toString()
    {
        if(value == Special.NULL_VALUE)
            return "null";
        else if(value == Special.VOID_TYPE)
            return "void";
        else
            return value.toString();
    }

    public Class getType()
    {
		if ( this == Primitive.VOID )
			return Void.TYPE;

		if ( this == Primitive.NULL )
			return null;
		return unboxType( value.getClass() );
    }

    public static Object binaryOperation(
		Object obj1, Object obj2, int kind)
        throws UtilEvalError
    {

        if ( obj1 == NULL || obj2 == NULL )
            throw new UtilEvalError(
				"Null value or 'null' literal in binary operation");
        if ( obj1 == VOID || obj2 == VOID )
            throw new UtilEvalError(
			"Undefined variable, class, or 'void' literal in binary operation");

		Class lhsOrgType = obj1.getClass();
		Class rhsOrgType = obj2.getClass();

        if ( obj1 instanceof Primitive )
            obj1 = ((Primitive)obj1).getValue();
        if ( obj2 instanceof Primitive )
            obj2 = ((Primitive)obj2).getValue();
        Object[] operands = promotePrimitives(obj1, obj2);
        Object lhs = operands[0];
        Object rhs = operands[1];
        if(lhs.getClass() != rhs.getClass())
            throw new UtilEvalError("Type mismatch in operator.  " 
			+ lhs.getClass() + " cannot be used with " + rhs.getClass() );
		Object result;
		try {
			result = binaryOperationImpl( lhs, rhs, kind );
		} catch ( ArithmeticException e ) {
			throw new UtilTargetError( "Arithemetic Exception in binary op", e);
		}

		if ( (lhsOrgType == Primitive.class && rhsOrgType == Primitive.class)
			|| result instanceof Boolean
		)
			return new Primitive( result );
		else
			return result;
    }
    public static Object binaryOperationImpl( Object lhs, Object rhs, int kind )
        throws UtilEvalError
	{
        if(lhs instanceof Boolean)
            return booleanBinaryOperation((Boolean)lhs, (Boolean)rhs, kind);
        else if(lhs instanceof Integer)
            return intBinaryOperation( (Integer)lhs, (Integer)rhs, kind );
        else if(lhs instanceof Long)
            return longBinaryOperation((Long)lhs, (Long)rhs, kind);
        else if(lhs instanceof Float)
            return floatBinaryOperation((Float)lhs, (Float)rhs, kind);
        else if(lhs instanceof Double)
            return doubleBinaryOperation( (Double)lhs, (Double)rhs, kind);
        else
            throw new UtilEvalError("Invalid types in binary operator" );
	}
    public static Boolean booleanBinaryOperation(Boolean B1, Boolean B2, int kind)
    {
        boolean lhs = B1.booleanValue();
        boolean rhs = B2.booleanValue();
        switch(kind)
        {
            case EQ:
                return new Boolean(lhs == rhs);
            case NE:
                return new Boolean(lhs != rhs);
            case BOOL_OR:
            case BOOL_ORX:
            case BIT_OR:
                return new Boolean( lhs || rhs );
            case BOOL_AND:
            case BOOL_ANDX:
            case BIT_AND:
                return new Boolean( lhs && rhs );

            case XOR:
                return new Boolean( lhs ^ rhs );
            default:
                throw new InterpreterError("unimplemented binary operator");
        }
    }

    public static Object longBinaryOperation(Long L1, Long L2, int kind)
    {
        long lhs = L1.longValue();
        long rhs = L2.longValue();
        switch(kind)
        {

            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);

            case PLUS:
                return new Long(lhs + rhs);
            case MINUS:
                return new Long(lhs - rhs);
            case STAR:
                return new Long(lhs * rhs);
            case SLASH:
                return new Long(lhs / rhs);
            case MOD:
                return new Long(lhs % rhs);

            case LSHIFT:
            case LSHIFTX:
                return new Long(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Long(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Long(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Long(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Long(lhs | rhs);
            case XOR:
                return new Long(lhs ^ rhs);
            default:
                throw new InterpreterError(
					"Unimplemented binary long operator");
        }
    }

    public static Object intBinaryOperation(Integer I1, Integer I2, int kind)
    {
        int lhs = I1.intValue();
        int rhs = I2.intValue();
        switch(kind)
        {

            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);

            case PLUS:
                return new Integer(lhs + rhs);
            case MINUS:
                return new Integer(lhs - rhs);
            case STAR:
                return new Integer(lhs * rhs);
            case SLASH:
                return new Integer(lhs / rhs);
            case MOD:
                return new Integer(lhs % rhs);

            case LSHIFT:
            case LSHIFTX:
                return new Integer(lhs << rhs);
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
                return new Integer(lhs >> rhs);
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                return new Integer(lhs >>> rhs);
            case BIT_AND:
            case BIT_ANDX:
                return new Integer(lhs & rhs);
            case BIT_OR:
            case BIT_ORX:
                return new Integer(lhs | rhs);
            case XOR:
                return new Integer(lhs ^ rhs);
            default:
                throw new InterpreterError(
					"Unimplemented binary integer operator");
        }
    }

    public static Object doubleBinaryOperation(Double D1, Double D2, int kind)
        throws UtilEvalError
    {
        double lhs = D1.doubleValue();
        double rhs = D2.doubleValue();
        switch(kind)
        {

            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);

            case PLUS:
                return new Double(lhs + rhs);
            case MINUS:
                return new Double(lhs - rhs);
            case STAR:
                return new Double(lhs * rhs);
            case SLASH:
                return new Double(lhs / rhs);
            case MOD:
                return new Double(lhs % rhs);

            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError("Can't shift doubles");
            default:
                throw new InterpreterError(
					"Unimplemented binary double operator");
        }
    }

    public static Object floatBinaryOperation(Float F1, Float F2, int kind)
        throws UtilEvalError
    {
        float lhs = F1.floatValue();
        float rhs = F2.floatValue();
        switch(kind)
        {

            case LT:
            case LTX:
                return new Boolean(lhs < rhs);
            case GT:
            case GTX:
                return new Boolean(lhs > rhs);
            case EQ:
                return new Boolean(lhs == rhs);
            case LE:
            case LEX:
                return new Boolean(lhs <= rhs);
            case GE:
            case GEX:
                return new Boolean(lhs >= rhs);
            case NE:
                return new Boolean(lhs != rhs);

            case PLUS:
                return new Float(lhs + rhs);
            case MINUS:
                return new Float(lhs - rhs);
            case STAR:
                return new Float(lhs * rhs);
            case SLASH:
                return new Float(lhs / rhs);
            case MOD:
                return new Float(lhs % rhs);

            case LSHIFT:
            case LSHIFTX:
            case RSIGNEDSHIFT:
            case RSIGNEDSHIFTX:
            case RUNSIGNEDSHIFT:
            case RUNSIGNEDSHIFTX:
                throw new UtilEvalError("Can't shift floats ");
            default:
                throw new InterpreterError(
					"Unimplemented binary float operator");
        }
    }

    public static Object promoteToInteger(Object wrapper )
    {
        if(wrapper instanceof Character)
            return new Integer(((Character)wrapper).charValue());
        else if((wrapper instanceof Byte) || (wrapper instanceof Short))
            return new Integer(((Number)wrapper).intValue());
        return wrapper;
    }

    public static Object[] promotePrimitives(Object lhs, Object rhs)
    {
        lhs = promoteToInteger(lhs);
        rhs = promoteToInteger(rhs);
        if((lhs instanceof Number) && (rhs instanceof Number))
        {
            Number lnum = (Number)lhs;
            Number rnum = (Number)rhs;
            boolean b;
            if((b = (lnum instanceof Double)) || (rnum instanceof Double))
            {
                if(b)
                    rhs = new Double(rnum.doubleValue());
                else
                    lhs = new Double(lnum.doubleValue());
            }
            else if((b = (lnum instanceof Float)) || (rnum instanceof Float))
            {
                if(b)
                    rhs = new Float(rnum.floatValue());
                else
                    lhs = new Float(lnum.floatValue());
            }
            else if((b = (lnum instanceof Long)) || (rnum instanceof Long))
            {
                if(b)
                    rhs = new Long(rnum.longValue());
                else
                    lhs = new Long(lnum.longValue());
            }
        }
        return new Object[] { lhs, rhs };
    }
    public static Primitive unaryOperation(Primitive val, int kind)
        throws UtilEvalError
    {
        if (val == NULL)
            throw new UtilEvalError(
				"illegal use of null object or 'null' literal");
        if (val == VOID)
            throw new UtilEvalError(
				"illegal use of undefined object or 'void' literal");
        Class operandType = val.getType();
        Object operand = promoteToInteger(val.getValue());
        if ( operand instanceof Boolean )
            return new Primitive(booleanUnaryOperation((Boolean)operand, kind));
        else if(operand instanceof Integer)
        {
            int result = intUnaryOperation((Integer)operand, kind);

            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Primitive((byte)result);
                if(operandType == Short.TYPE)
                    return new Primitive((short)result);
                if(operandType == Character.TYPE)
                    return new Primitive((char)result);
            }
            return new Primitive(result);
        }
        else if(operand instanceof Long)
            return new Primitive(longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Primitive(floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Primitive(doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError(
				"An error occurred.  Please call technical support.");
    }
    public static boolean booleanUnaryOperation(Boolean B, int kind)
		throws UtilEvalError
    {
        boolean operand = B.booleanValue();
        switch(kind)
        {
            case BANG:
                return !operand;
            default:
                throw new UtilEvalError("Operator inappropriate for boolean");
        }
    }
    public static int intUnaryOperation(Integer I, int kind)
    {
        int operand = I.intValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError("bad integer unaryOperation");
        }
    }
    public static long longUnaryOperation(Long L, int kind)
    {
        long operand = L.longValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            case TILDE:
                return ~operand;
            case INCR:
                return operand + 1;
            case DECR:
                return operand - 1;
            default:
                throw new InterpreterError("bad long unaryOperation");
        }
    }
    public static float floatUnaryOperation(Float F, int kind)
    {
        float operand = F.floatValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError("bad float unaryOperation");
        }
    }
    public static double doubleUnaryOperation(Double D, int kind)
    {
        double operand = D.doubleValue();
        switch(kind)
        {
            case PLUS:
                return operand;
            case MINUS:
                return -operand;
            default:
                throw new InterpreterError("bad double unaryOperation");
        }
    }
    public int intValue() throws UtilEvalError
    {
        if(value instanceof Number)
            return((Number)value).intValue();
        else
            throw new UtilEvalError("Primitive not a number");
    }
    public boolean booleanValue() throws UtilEvalError
    {
        if(value instanceof Boolean)
            return((Boolean)value).booleanValue();
        else
            throw new UtilEvalError("Primitive not a boolean");
    }

	public boolean isNumber() {
		return ( !(value instanceof Boolean) 
			&& !(this == NULL) && !(this == VOID) );
	}
    public Number numberValue() throws UtilEvalError
    {
		Object value = this.value;

		if (value instanceof Character)
			value = new Integer(((Character)value).charValue());
        if (value instanceof Number)
            return (Number)value;
        else
            throw new UtilEvalError("Primitive not a number");
    }

	public boolean equals( Object obj ) 
	{
		if ( obj instanceof Primitive )
			return ((Primitive)obj).value.equals( this.value );
		else
			return false;
	}

	public int hashCode() 
	{
		return this.value.hashCode() * 21; 
	}

	public static Object unwrap( Object obj ) 
	{

        if (obj == Primitive.VOID)
            return null;

        if (obj instanceof Primitive)
            return((Primitive)obj).getValue();
        else
            return obj;
	}

    public static Object [] unwrap( Object[] args )
    {
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = unwrap( args[i] );
		return oa;
    }

    public static Object [] wrap( Object[] args, Class [] paramTypes )
    {
		if ( args == null )
			return null;
		Object [] oa = new Object[ args.length ];
        for(int i=0; i<args.length; i++)
            oa[i] = wrap( args[i], paramTypes[i] );
		return oa;
    }

    public static Object wrap(
		Object value, Class type )
    {
        if ( type == Void.TYPE )
            return Primitive.VOID;
        if ( value == null )
            return Primitive.NULL;
		if ( type.isPrimitive() )
			return new Primitive( value );
		return value;
    }

	public static Primitive getDefaultValue( Class type )
	{
		if ( type == null || !type.isPrimitive() )
			return Primitive.NULL;
		if ( type == Boolean.TYPE )
			return new Primitive( false );

		try {
			return new Primitive((int)0).castToType( type, Types.CAST );
		} catch ( UtilEvalError e ) {
			throw new InterpreterError( "bad cast" );
		}
	}

	public static Class boxType( Class primitiveType )
	{
		Class c = wrapperMap.get( primitiveType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			"Not a primitive type: "+ primitiveType );
	}

	public static Class unboxType( Class wrapperType )
	{
		Class c = wrapperMap.get( wrapperType );
		if ( c != null )
			return c;
		throw new InterpreterError( 
			"Not a primitive wrapper type: "+wrapperType );
	}

	public Primitive castToType( Class toType, int operation ) 
		throws UtilEvalError
	{
		return castPrimitive( 
			toType, getType(), this, 
			false, operation );
	}

	static Primitive castPrimitive( 
		Class toType, Class fromType, Primitive fromValue, 
		boolean checkOnly, int operation ) 
		throws UtilEvalError
	{

		if ( checkOnly && fromValue != null )
			throw new InterpreterError("bad cast param 1");
		if ( !checkOnly && fromValue == null )
			throw new InterpreterError("bad cast param 2");
		if ( fromType != null && !fromType.isPrimitive() )
			throw new InterpreterError("bad fromType:" +fromType);
		if ( fromValue == Primitive.NULL && fromType != null )
			throw new InterpreterError("inconsistent args 1");
		if ( fromValue == Primitive.VOID && fromType != Void.TYPE )
			throw new InterpreterError("inconsistent args 2");

		if ( fromType == Void.TYPE )
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( Reflect.normalizeClassName(toType), 
					"void value", operation );

		Object value = null; 
		if ( fromValue != null )
			value = fromValue.getValue();
		if ( toType.isPrimitive() )
		{

			if ( fromType == null )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError(
						"primitive type:" + toType, "Null value", operation );

		} else
		{

			if ( fromType == null )
				return checkOnly ? Types.VALID_CAST : 
					Primitive.NULL;
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError(
						"object type:" + toType, "primitive value", operation);
		}

		if ( fromType == Boolean.TYPE )
		{
			if ( toType != Boolean.TYPE )
				if ( checkOnly )
					return Types.INVALID_CAST;
				else
					throw Types.castError( toType, fromType, operation );
			return checkOnly ? Types.VALID_CAST :
				fromValue;
		}

		if ( operation == Types.ASSIGNMENT 
			&& !Types.isJavaAssignable( toType, fromType ) 
		) {
			if ( checkOnly )
				return Types.INVALID_CAST;
			else
				throw Types.castError( toType, fromType, operation );
		}
		return checkOnly ? Types.VALID_CAST :
			new Primitive( castWrapper(toType, value) );
	}
	public static boolean isWrapperType( Class type )
	{
		return wrapperMap.get( type ) != null && !type.isPrimitive();
	}

	static Object castWrapper( 
		Class toType, Object value ) 
	{
		if ( !toType.isPrimitive() )
			throw new InterpreterError("invalid type in castWrapper: "+toType);
		if ( value == null )
			throw new InterpreterError("null value in castWrapper, guard");
		if ( value instanceof Boolean )
		{
			if ( toType != Boolean.TYPE )
				throw new InterpreterError("bad wrapper cast of boolean");
			else
				return value;
		}

		if ( value instanceof Character )
			value = new Integer(((Character)value).charValue());
		if ( !(value instanceof Number) )
			throw new InterpreterError("bad type in cast");
		Number number = (Number)value;
		if (toType == Byte.TYPE)
			return new Byte(number.byteValue());
		if (toType == Short.TYPE)
			return new Short(number.shortValue());
		if (toType == Character.TYPE)
			return new Character((char)number.intValue());
		if (toType == Integer.TYPE)
			return new Integer(number.intValue());
		if (toType == Long.TYPE)
			return new Long(number.longValue());
		if (toType == Float.TYPE)
			return new Float(number.floatValue());
		if (toType == Double.TYPE)
			return new Double(number.doubleValue());
		throw new InterpreterError("error in wrapper cast");
	}
}
package bsh;
import bsh.ast.SimpleNode;

public class EvalError extends Error
{
	private SimpleNode node;

	private String message;
	private final CallStack callstack;
	public EvalError( String s, SimpleNode node, CallStack callstack, Throwable cause ) {
		this(s,node,callstack);
		initCause(cause);
	}
	public EvalError( String s, SimpleNode node, CallStack callstack ) {
		this.message = s;
		this.node = node;

		this.callstack = callstack==null ? null : callstack.copy();
	}

	public String getMessage() 
	{
		String trace;
		if ( node != null )
			trace = " : at Line: "+ node.getLineNumber() 
				+ " : in file: "+ node.getSourceFile()
				+ " : "+node.getText();
		else

			trace = ": <at unknown location>";
		if ( callstack != null )
			trace = trace +"\n" + getScriptStackTrace();
		return getRawMessage() + trace;
	}

	public void reThrow( String msg ) 
		throws EvalError 
	{
		prependMessage( msg );
		throw this;
	}

	SimpleNode getNode() {
		return node;
	}
	void setNode( SimpleNode node ) {
		this.node = node;
	}
	public String getErrorText() { 
		if ( node != null )
			return node.getText() ;
		else
			return "<unknown error>";
	}
	public int getErrorLineNumber() { 
		if ( node != null )
			return node.getLineNumber() ;
		else
			return -1;
	}
	public String getErrorSourceFile() {
		if ( node != null )
			return node.getSourceFile() ;
		else
			return "<unknown file>";
	}
	public String getScriptStackTrace() 
	{
		if ( callstack == null )
			return "<Unknown>";
		String trace = "";
		CallStack stack = callstack.copy();
		while ( stack.depth() > 0 ) 
		{
			NameSpace ns = stack.pop();
			SimpleNode node = ns.getNode();
			if ( ns.isMethod )
			{
				trace = trace + "\nCalled from method: " + ns.getName();
				if ( node != null )
					trace += " : at Line: "+ node.getLineNumber() 
						+ " : in file: "+ node.getSourceFile()
						+ " : "+node.getText();
			}
		}
		return trace;
	}
	public String getRawMessage() { return message; }

	private void prependMessage( String s ) 
	{ 
		if ( s == null )
			return;
		if ( message == null )
			message = s;
		else
			message = s + " : "+ message;
	}
}
package bsh;
import java.io.Serializable;
import java.util.Stack;
import java.util.EmptyStackException;

public final class CallStack implements Serializable {
	private static final long serialVersionUID = 0L;
	private final Stack<NameSpace> stack = new Stack<NameSpace>();
	public CallStack() { }
	public CallStack( NameSpace namespace ) { 
		push( namespace );
	}
	public void clear() {
		stack.removeAllElements();
	}
	public void push( NameSpace ns ) {
		stack.push( ns );
	}
	public NameSpace top() {
		return stack.peek();
	}

	public NameSpace get(int depth) {
		int size = stack.size();
		if ( depth >= size )
			return NameSpace.JAVACODE;
		else
			return stack.get(size-1-depth);
	}

	public void set(int depth, NameSpace ns) {
		stack.set( stack.size()-1-depth, ns );
	}
	public NameSpace pop() {
		try {
			return stack.pop();
		} catch(EmptyStackException e) {
			throw new InterpreterError("pop on empty CallStack");
		}
	}

	public NameSpace swap( NameSpace newTop ) {
		int last = stack.size() - 1;
		NameSpace oldTop = stack.get(last);
		stack.set( last, newTop );
		return oldTop;
	}
	public int depth() {
		return stack.size();
	}

	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("CallStack:\n");
		for( int i=stack.size()-1; i>=0; i-- )
			sb.append("\t"+stack.get(i)+"\n");
		return sb.toString();
	}

	public CallStack copy() {
		CallStack cs = new CallStack();
		cs.stack.addAll(this.stack);
		return cs;
	}
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

public class Interpreter 
	implements Runnable, ConsoleInterface,Serializable
{

	public static final String VERSION = "2.2b0";

	public static boolean DEBUG, TRACE, LOCALSCOPING;

	transient static PrintStream debug;
	static String systemLineSeparator = "\n"; 
	private static final This SYSTEM_OBJECT = This.getThis(new NameSpace(null, null, "bsh.system"), null);
	static {
		staticInit();
	}

	private boolean strictJava = false;

	transient Parser parser;
	NameSpace globalNameSpace;
	transient Reader in;
	transient PrintStream out;
	transient PrintStream err;
	ConsoleInterface console; 

	Interpreter parent;

	String sourceFileInfo;

	private boolean exitOnEOF = true;
	protected boolean 
		evalOnly, 		
		interactive;	

	private boolean showResults;

	public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace,
		Interpreter parent, String sourceFileInfo )
	{

		parser = new Parser( in );
		long t1 = 0;
		if (Interpreter.DEBUG) {
			t1=System.currentTimeMillis();
		}
		this.in = in;
		this.out = out;
		this.err = err;
		this.interactive = interactive;
		debug = err;
		this.parent = parent;
		if ( parent != null )
			setStrictJava( parent.getStrictJava() );
		this.sourceFileInfo = sourceFileInfo;
		BshClassManager bcm = BshClassManager.createClassManager( this );
		if ( namespace == null ) {
			globalNameSpace = new NameSpace( bcm, "global");
			initRootSystemObject();
		} else {
			globalNameSpace = namespace;
			try {
				if ( ! (globalNameSpace.getVariable("bsh") instanceof This)) {
					initRootSystemObject();
				}
			} catch (final UtilEvalError e) {
				throw new IllegalStateException(e);
			}
		}

		if ( interactive ) {
			loadRCFiles();
		}
		if ( Interpreter.DEBUG ) {
			long t2=System.currentTimeMillis();
			Interpreter.debug("Time to initialize interpreter: "+(t2-t1));
		}
	}
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, 
		boolean interactive, NameSpace namespace)
	{
		this( in, out, err, interactive, namespace, null, null );
	}
	public Interpreter(
		Reader in, PrintStream out, PrintStream err, boolean interactive)
	{
		this(in, out, err, interactive, null);
	}

	public Interpreter(ConsoleInterface console, NameSpace globalNameSpace) {
		this( console.getIn(), console.getOut(), console.getErr(), 
			true, globalNameSpace );
		setConsole( console );
	}

	public Interpreter(ConsoleInterface console) {
		this(console, null);
	}

	public Interpreter()
	{
		this( new StringReader(""), 
			System.out, System.err, false, null );
		evalOnly = true;
		setu( "bsh.evalOnly", new Primitive(true) );
	}

	public void setConsole( ConsoleInterface console ) {
		this.console = console;
		setu( "bsh.console", console );

		setOut( console.getOut() );
		setErr( console.getErr() );

	}
	private void initRootSystemObject() 
	{
		BshClassManager bcm = getClassManager();

		setu("bsh", new NameSpace( bcm, "Bsh Object" ).getThis( this ) );
		setu( "bsh.system", SYSTEM_OBJECT);
		setu( "bsh.shared", SYSTEM_OBJECT); 

		This helpText = new NameSpace(bcm, "Bsh Command Help Text" ).getThis( this );
		setu( "bsh.help", helpText );

		try {
			setu( "bsh.cwd", System.getProperty("user.dir") );
		} catch ( SecurityException e ) { 

			setu( "bsh.cwd", "." );
		}

		setu( "bsh.interactive", new Primitive(interactive) );

		setu( "bsh.evalOnly", new Primitive(evalOnly) );
	}

	public void setNameSpace( NameSpace globalNameSpace ) {
		this.globalNameSpace = globalNameSpace;
	}

	public NameSpace getNameSpace() {
		return globalNameSpace;
	}

	public static void main( String [] args ) 
	{
		if ( args.length > 0 ) {
			String filename = args[0];
			String [] bshArgs;
			if ( args.length > 1 ) {
				bshArgs = new String [ args.length -1 ];
				System.arraycopy( args, 1, bshArgs, 0, args.length-1 );
			} else
				bshArgs = new String [0];
			Interpreter interpreter = new Interpreter();

			interpreter.setu( "bsh.args", bshArgs );
			try {
				Object result = 
					interpreter.source( filename, interpreter.globalNameSpace );
				if ( result instanceof Class )
					try {
						invokeMain( (Class)result, bshArgs );
					} catch ( Exception e ) 
					{
						Object o = e;
						if ( e instanceof InvocationTargetException )
							o = ((InvocationTargetException)e)
								.getTargetException();
						System.err.println(
							"Class: "+result+" main method threw exception:"+o);
					}
			} catch ( FileNotFoundException e ) {
				System.err.println("File not found: "+e);
			} catch ( TargetError e ) {
				System.err.println("Script threw exception: "+e);
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, System.err );
			} catch ( EvalError e ) {
				System.err.println("Evaluation Error: "+e);
			} catch ( IOException e ) {
				System.err.println("I/O Error: "+e);
			}
		} else 
		{

			InputStream src;
			if ( System.getProperty("os.name").startsWith("Windows") 
				&& System.getProperty("java.version").startsWith("1.1."))
			{
				src = new FilterInputStream(System.in) {
					public int available() throws IOException {
						return 0;
					}
				};
			}
			else
				src = System.in;
			Reader in = new CommandLineReader( new InputStreamReader(src));
			Interpreter interpreter = 
				new Interpreter( in, System.out, System.err, true );
			interpreter.run();
		}
	}
	public static void invokeMain( Class clas, String [] args ) 
		throws Exception
	{
		Method main = Reflect.resolveJavaMethod(
			null, clas, "main", 
			new Class [] { String [].class }, true );
		if ( main != null )
			main.invoke( null, new Object [] { args } );
	}

	public void run() 
	{
		if(evalOnly)
			throw new RuntimeException("bsh Interpreter: No stream");

		if ( interactive )
			try { 
				eval("printBanner();"); 
			} catch ( EvalError e ) {
				println(
					"BeanShell2 " + VERSION + " - http://code.google.com/p/beanshell2");
			}

		CallStack callstack = new CallStack( globalNameSpace );
        BshEvaluatingVisitor evaluator = new BshEvaluatingVisitor(callstack, this);
		SimpleNode node = null;
		boolean eof = false;
		while( !eof )
		{
			try
			{

				System.out.flush();
				System.err.flush();
				Thread.yield();  
				if ( interactive )
					print( getBshPrompt() );
				eof = Line();
				if( get_jjtree().nodeArity() > 0 )  
				{
					if( node != null )
						node.lastToken.next = null;  
					node = (SimpleNode)(get_jjtree().rootNode());
					if(DEBUG)
						node.dump(">");
                    Object ret = node.accept(evaluator);
					node.lastToken.next = null;  

					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							"Callstack growing: "+callstack);
					if(ret instanceof ReturnControl)
						ret = ((ReturnControl)ret).value;
					if( ret != Primitive.VOID )
					{
						setu("$_", ret);
						if ( showResults )
							println("<" + ret + ">");
					}
				}
			}
			catch(ParseException e)
			{
				error("Parser Error: " + e.getMessage());
				if ( DEBUG )
					e.printStackTrace();
				if(!interactive)
					eof = true;
				parser.reInitInput(in);
			}
			catch(InterpreterError e)
			{
				error("Internal Error: " + e.getMessage());
				e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(TargetError e)
			{
				error("// Uncaught Exception: " + e );
				if ( e.inNativeCode() )
					e.printStackTrace( DEBUG, err );
				if(!interactive)
					eof = true;
				setu("$_e", e.getTarget());
			}
			catch (EvalError e)
			{
				if ( interactive )
					error( "EvalError: "+e.getMessage() );
				else
					error( "EvalError: "+e.getRawMessage() );
				if(DEBUG)
					e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(Exception e)
			{
				error("Unknown error: " + e);
				if ( DEBUG )
					e.printStackTrace();
				if(!interactive)
					eof = true;
			}
			catch(TokenMgrError e)
			{
				error("Error parsing input: " + e);

				parser.reInitTokenInput( in );
				if(!interactive)
					eof = true;
			}
			finally
			{
				get_jjtree().reset();

				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( globalNameSpace );
				}
			}
		}
		if ( interactive && exitOnEOF )
			System.exit(0);
	}

	public Object source( String filename, NameSpace nameSpace ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		File file = pathToFile( filename );
		if ( Interpreter.DEBUG ) debug("Sourcing file: "+file);
		Reader sourceIn = new BufferedReader( new FileReader(file) );
		try {
			return eval( sourceIn, nameSpace, filename );
		} finally {
			sourceIn.close();
		}
	}

	public Object source( String filename ) 
		throws FileNotFoundException, IOException, EvalError 
	{
		return source( filename, globalNameSpace );
	}

	public Object eval( 
		Reader in, NameSpace nameSpace, String sourceFileInfo
			 ) 
		throws EvalError 
	{
		Object retVal = null;
		if ( Interpreter.DEBUG ) debug("eval: nameSpace = "+nameSpace);

		Interpreter localInterpreter = 
			new Interpreter( 
				in, out, err, false, nameSpace, this, sourceFileInfo  );
		CallStack callstack = new CallStack( nameSpace );
        BshEvaluatingVisitor evaluator = new BshEvaluatingVisitor(callstack, localInterpreter);
        SimpleNode node = null;
		boolean eof = false;
		while(!eof)
		{
			try
			{
				eof = localInterpreter.Line();
				if (localInterpreter.get_jjtree().nodeArity() > 0)
				{
					if( node != null )
						node.lastToken.next = null;  
					node = (SimpleNode)localInterpreter.get_jjtree().rootNode();

					node.setSourceFile( sourceFileInfo );
					if ( TRACE )
						println( "// " +node.getText() );
                    retVal = node.accept(evaluator);

					if ( callstack.depth() > 1 )
						throw new InterpreterError(
							"Callstack growing: "+callstack);
					if ( retVal instanceof ReturnControl ) {
						retVal = ((ReturnControl)retVal).value;
						break; 
					}
					if ( localInterpreter.showResults 
						&& retVal != Primitive.VOID )
						println("<" + retVal + ">");
				}
			} catch(ParseException e) {

				if ( DEBUG )

					error( e.getMessage() );

				throw new EvalError("Error:", node, callstack, e);
			} catch ( InterpreterError e ) {
				e.printStackTrace();
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" internal Error: " 
					+ e.getMessage(), node, callstack);
			} catch ( TargetError e ) {

				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow("Sourced file: "+sourceFileInfo);
			} catch ( EvalError e) {
				if ( DEBUG)
					e.printStackTrace();

				if ( e.getNode()==null )
					e.setNode( node );
				e.reThrow( "Sourced file: "+sourceFileInfo );
			} catch ( Exception e) {
				if ( DEBUG)
					e.printStackTrace();
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" unknown error: " 
					+ e.getMessage(), node, callstack, e);
			} catch(TokenMgrError e) {
				throw new EvalError(
					"Sourced file: "+sourceFileInfo+" Token Parsing Error: " 
					+ e.getMessage(), node, callstack, e );
			} finally {
				localInterpreter.get_jjtree().reset();

				if ( callstack.depth() > 1 ) {
					callstack.clear();
					callstack.push( nameSpace );
				}
			}
		}
		return Primitive.unwrap( retVal );
	}

	public Object eval( Reader in ) throws EvalError 
	{
		return eval( in, globalNameSpace, "eval stream" );
	}

	public Object eval( String statements ) throws EvalError {
		if ( Interpreter.DEBUG ) debug("eval(String): "+statements);
		return eval(statements, globalNameSpace);
	}

	public Object eval( String statements, NameSpace nameSpace ) 
		throws EvalError 
	{
		String s = ( statements.endsWith(";") ? statements : statements+";" );
		return eval( 
			new StringReader(s), nameSpace, 
			"inline evaluation of: ``"+ showEvalString(s)+"''" );
	}
	private String showEvalString( String s ) {
		s = s.replace('\n', ' ');
		s = s.replace('\r', ' ');
		if ( s.length() > 80 )
			s = s.substring( 0, 80 ) + " . . . ";
		return s;
	}

	public final void error( Object o ) {
		if ( console != null )
				console.error( "// Error: " + o +"\n" );
		else {
			err.println("// Error: " + o );
			err.flush();
		}
	}

	public Reader getIn() { return in; }

	public PrintStream getOut() { return out; }

	public PrintStream getErr() { return err; }
	public final void println( Object o )
	{
		print( String.valueOf(o) + systemLineSeparator );
	}
	public final void print( Object o )
	{
		if (console != null) {
			console.print(o);
		} else {
			out.print(o);
			out.flush();
		}
	}

	public final static void debug(String s)
	{
		if ( DEBUG )
			debug.println("// Debug: " + s);
	}

	public Object get( String name ) throws EvalError {
		try {
			Object ret = globalNameSpace.get( name, this );
			return Primitive.unwrap( ret );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, new CallStack() ); 
		}
	}

	Object getu( String name ) {
		try { 
			return get( name );
		} catch ( EvalError e ) { 
			throw new InterpreterError("set: "+e);
		}
	}

	public void set( String name, Object value )
		throws EvalError 
	{

		if ( value == null )
			value = Primitive.NULL;
		CallStack callstack = new CallStack();
		try {
			if ( Name.isCompound( name ) ) 
			{
				LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( new BshEvaluatingVisitor(callstack,  this)	);
				lhs.assign( value, false );
			} else 
				globalNameSpace.setVariable( name, value, false );
		} catch ( UtilEvalError e ) { 
			throw e.toEvalError( SimpleNode.JAVACODE, callstack ); 
		}
	}

	void setu(String name, Object value) {
		try { 
			set(name, value);
		} catch ( EvalError e ) { 
			throw new InterpreterError("set: "+e);
		}
	}
	public void set(String name, long value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, int value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, double value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, float value) throws EvalError {
		set(name, new Primitive(value));
	}
	public void set(String name, boolean value) throws EvalError {
		set(name, new Primitive(value));
	}

	public void unset( String name ) 
		throws EvalError 
	{

		CallStack callstack = new CallStack();
		try {
			LHS lhs = globalNameSpace.getNameResolver( name ).toLHS( 
				new BshEvaluatingVisitor(callstack, this) );
			if ( lhs.type != LHS.VARIABLE )
				throw new EvalError("Can't unset, not a variable: "+name, 
					SimpleNode.JAVACODE, new CallStack() );

			lhs.nameSpace.unsetVariable( name );
		} catch ( UtilEvalError e ) {
			throw new EvalError( e.getMessage(), 
				SimpleNode.JAVACODE, new CallStack() );
		}
	}

	public Object getInterface( Class interf ) throws EvalError
	{
		return globalNameSpace.getThis( this ).getInterface( interf );
	}

	private JJTParserState get_jjtree() {
		return parser.jjtree;
	}
	private JavaCharStream get_jj_input_stream() {
		return parser.jj_input_stream;
	}
	private boolean Line() throws ParseException {
		return parser.Line();
	}

	void loadRCFiles() {
		try {
			String rcfile = 

				System.getProperty("user.home") + File.separator + ".bshrc";
			source( rcfile, globalNameSpace );
		} catch ( Exception e ) { 

			if ( Interpreter.DEBUG ) debug("Could not find rc file: "+e);
		}
	}

	public File pathToFile( String fileName ) 
		throws IOException
	{
		File file = new File( fileName );

		if ( !file.isAbsolute() ) {
			String cwd = (String)getu("bsh.cwd");
			file = new File( cwd + File.separator + fileName );
		}

		return new File( file.getCanonicalPath() );
	}
	public static void redirectOutputToFile( String filename ) 
	{
		try {
			PrintStream pout = new PrintStream( 
				new FileOutputStream( filename ) );
			System.setOut( pout );
			System.setErr( pout );
		} catch ( IOException e ) {
			System.err.println("Can't redirect output to file: "+filename );
		}
	}

	public void setClassLoader( ClassLoader externalCL ) {
		getClassManager().setClassLoader( externalCL );
	}

	public BshClassManager getClassManager() 
	{
		return getNameSpace().getClassManager();
	}

	public void setStrictJava( boolean b ) { 
		this.strictJava = b; 
	}

	public boolean getStrictJava() { 
		return this.strictJava;
	}
	static void staticInit() 
	{

		try {
			systemLineSeparator = System.getProperty("line.separator");
			debug = System.err;
			DEBUG = Boolean.getBoolean("debug");
			TRACE = Boolean.getBoolean("trace");
			LOCALSCOPING = Boolean.getBoolean("localscoping");
			String outfilename = System.getProperty("outfile");
			if ( outfilename != null )
				redirectOutputToFile( outfilename );
		} catch ( SecurityException e ) { 
			System.err.println("Could not init static:"+e);
		} catch ( Exception e ) {
			System.err.println("Could not init static(2):"+e);
		} catch ( Throwable e ) { 
			System.err.println("Could not init static(3):"+e);
		}
	}

	public String getSourceFileInfo() { 
		if ( sourceFileInfo != null )
			return sourceFileInfo;
		else
			return "<unknown source>";
	}

	public Interpreter getParent() {
		return parent;
	}
	public void setOut( PrintStream out ) {
		this.out = out;
	}
	public void setErr( PrintStream err ) {
		this.err = err;
	}

	private void readObject(ObjectInputStream stream) 
		throws java.io.IOException, ClassNotFoundException
	{
		stream.defaultReadObject();

		if ( console != null ) {
			setOut( console.getOut() );
			setErr( console.getErr() );
		} else {
			setOut( System.out );
			setErr( System.err );
		}
	}

	private String getBshPrompt() 
	{
		try {
			return (String)eval("getBshPrompt()");
		} catch ( Exception e ) {
			return "bsh % ";
		}
	}

	public void setExitOnEOF( boolean value ) {
		exitOnEOF = value; 
	}

	public void setShowResults( boolean showResults ) {
		this.showResults = showResults;
	}

	public boolean getShowResults()  {
		return showResults;
	}
	public static void setShutdownOnExit(final boolean value) {
		try {
			SYSTEM_OBJECT.getNameSpace().setVariable("shutdownOnExit", Boolean.valueOf(value), false);
		} catch (final UtilEvalError utilEvalError) {
			throw new IllegalStateException(utilEvalError);
		}
	}
}
package bsh.ast;
import bsh.*;
public class BSHUnaryExpression extends SimpleNode implements ParserConstants
{
    public int kind;
	public boolean postfix = false;
    public BSHUnaryExpression(int id) { super(id); }
    public Object lhsUnaryOperation( LHS lhs, boolean strictJava )
		throws UtilEvalError
    {
        if ( Interpreter.DEBUG ) Interpreter.debug("lhsUnaryOperation");
        Object prevalue, postvalue;
        prevalue = lhs.getValue();
        postvalue = unaryOperation(prevalue, kind);
		Object retVal;
		if ( postfix )
			retVal = prevalue;
		else
			retVal = postvalue;
		lhs.assign( postvalue, strictJava );
		return retVal;
    }
    public Object unaryOperation( Object op, int kind ) throws UtilEvalError
    {
        if (op instanceof Boolean || op instanceof Character 
			|| op instanceof Number)
            return primitiveWrapperUnaryOperation( op, kind );
        if ( !(op instanceof Primitive) )
            throw new UtilEvalError( "Unary operation " + tokenImage[kind]
                + " inappropriate for object" );

        return Primitive.unaryOperation((Primitive)op, kind);
    }
    private Object primitiveWrapperUnaryOperation(Object val, int kind)
        throws UtilEvalError
    {
        Class operandType = val.getClass();
        Object operand = Primitive.promoteToInteger(val);
        if ( operand instanceof Boolean )
			return new Boolean(
				Primitive.booleanUnaryOperation((Boolean)operand, kind));
        else 
		if ( operand instanceof Integer )
        {
            int result = Primitive.intUnaryOperation((Integer)operand, kind);

            if(kind == INCR || kind == DECR)
            {
                if(operandType == Byte.TYPE)
                    return new Byte((byte)result);
                if(operandType == Short.TYPE)
                    return new Short((short)result);
                if(operandType == Character.TYPE)
                    return new Character((char)result);
            }
            return new Integer(result);
        }
        else if(operand instanceof Long)
            return new Long(Primitive.longUnaryOperation((Long)operand, kind));
        else if(operand instanceof Float)
            return new Float(Primitive.floatUnaryOperation((Float)operand, kind));
        else if(operand instanceof Double)
            return new Double(Primitive.doubleUnaryOperation((Double)operand, kind));
        else
            throw new InterpreterError("An error occurred.  Please call technical support.");
    }
    public <T> T accept(BshNodeVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
package bsh;
import bsh.ast.SimpleNode;
import bsh.interpreter.BshEvaluatingVisitor;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;

public class Name implements java.io.Serializable
{

	public NameSpace namespace;
	String value = null;

	private String evalName;

	private String lastEvalName;
	private static String FINISHED = null; 
	private Object evalBaseObject;	
	private int callstackDepth;		

	Class asClass;

	Class classOfStaticMethod;

	private void reset() {
		evalName = value;
		evalBaseObject = null;
		callstackDepth = 0;
	}

	Name( NameSpace namespace, String s )
	{
		this.namespace = namespace;
		value = s;
	}

	public Object toObject( BshEvaluatingVisitor visitor )
		throws UtilEvalError
	{
		return toObject( visitor, false );
	}

	synchronized public Object toObject( 
		BshEvaluatingVisitor visitor, boolean forceClass )
		throws UtilEvalError
	{
		reset();
		Object obj = null;
		while( evalName != null )
			obj = consumeNextObjectField(visitor, forceClass, false  );
		if ( obj == null )
			throw new InterpreterError("null value in toObject()");
		return obj;
	}
	private Object completeRound( 
		String lastEvalName, String nextEvalName, Object returnObject )
	{
		if ( returnObject == null )
			throw new InterpreterError("lastEvalName = "+lastEvalName);
		this.lastEvalName = lastEvalName;
		this.evalName = nextEvalName;
		this.evalBaseObject = returnObject;
		return returnObject;
	}

	private Object consumeNextObjectField( 	
		BshEvaluatingVisitor visitor,
		boolean forceClass, boolean autoAllocateThis ) 
		throws UtilEvalError
	{

		if ( (evalBaseObject == null && !isCompound(evalName) )
			&& !forceClass ) 
		{
			Object obj = resolveThisFieldReference( visitor,
				namespace, evalName, false );
			if ( obj != Primitive.VOID )
				return completeRound( evalName, FINISHED, obj );
		}

		String varName = prefix(evalName, 1);
		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug("trying to resolve variable: " + varName);
			Object obj;

			if ( evalBaseObject == null ) {
				obj = resolveThisFieldReference(visitor, namespace, varName, false );
			} else {
				obj = resolveThisFieldReference(visitor,
					((This)evalBaseObject).namespace,
					varName, true );
			}
			if ( obj != Primitive.VOID ) 
			{

				if ( Interpreter.DEBUG ) 
					Interpreter.debug( "resolved variable: " + varName + 
					" in namespace: "+namespace);
				return completeRound( varName, suffix(evalName), obj );
			}
		}

		if ( evalBaseObject == null ) 
		{
			if ( Interpreter.DEBUG ) 
				Interpreter.debug( "trying class: " + evalName);

			Class clas = null;
			int i = 1;
			String className = null;
			for(; i <= countParts(evalName); i++)
			{
				className = prefix(evalName, i);
				if ( (clas = namespace.getClass(className)) != null )
					break;
			}

			if ( clas != null )  {
				return completeRound(
					className,
					suffix( evalName, countParts(evalName)-i ),
					new ClassIdentifier(clas) 
				);
			}

			if ( Interpreter.DEBUG ) 
				Interpreter.debug( "not a class, trying var prefix "+evalName );
		}

		if ( ( evalBaseObject == null || evalBaseObject instanceof This  )
			&& !forceClass && autoAllocateThis )
		{
			NameSpace targetNameSpace = 
				( evalBaseObject == null ) ?  
					namespace : ((This)evalBaseObject).namespace;
			Object obj = new NameSpace( 
				targetNameSpace, "auto: "+varName ).getThis( visitor.getInterpreter() );
			targetNameSpace.setVariable( varName, obj, false );
			return completeRound( varName, suffix(evalName), obj );
		}

		if ( evalBaseObject == null ) {
			if ( !isCompound(evalName) ) {
				return completeRound( evalName, FINISHED, Primitive.VOID );
			} else
				throw new UtilEvalError(
					"Class or variable not found: " + evalName);
		}

		if ( evalBaseObject == Primitive.NULL) 
			throw new UtilTargetError( new NullPointerException( 
				"Null Pointer while evaluating: " +value ) );
		if ( evalBaseObject == Primitive.VOID) 
			throw new UtilEvalError(
				"Undefined variable or class name while evaluating: "+value);
		if ( evalBaseObject instanceof Primitive)
			throw new UtilEvalError("Can't treat primitive like an object. "+
			"Error while evaluating: "+value);

		if ( evalBaseObject instanceof ClassIdentifier ) 
		{
			Class clas = ((ClassIdentifier)evalBaseObject).getTargetClass();
			String field = prefix(evalName, 1);

			if ( field.equals("this") )
			{

				NameSpace ns = namespace;
				while ( ns != null )
				{

					if ( ns.classInstance != null 
						&& ns.classInstance.getClass() == clas 
					)
						return completeRound( 
							field, suffix(evalName), ns.classInstance );
					ns=ns.getParent();
				}
				throw new UtilEvalError(
					"Can't find enclosing 'this' instance of class: "+clas);
			}
			Object obj = null;

			try {
				if ( Interpreter.DEBUG ) 
					Interpreter.debug("Name call to getStaticFieldValue, class: "
						+clas+", field:"+field);
				obj = Reflect.getStaticFieldValue(clas, field);
			} catch( ReflectError e ) { 
				if ( Interpreter.DEBUG ) 
					Interpreter.debug("field reflect error: "+e);
			}

			if ( obj == null ) {
				String iclass = clas.getName()+"$"+field;
				Class c = namespace.getClass( iclass );
				if ( c != null )
					obj = new ClassIdentifier(c);
			}
			if ( obj == null )
				throw new UtilEvalError(
					"No static field or inner class: " 
					+ field + " of " + clas );
			return completeRound( field, suffix(evalName), obj );
		}

		if ( forceClass )
			throw new UtilEvalError( 
				value +" does not resolve to a class name." );

		String field = prefix(evalName, 1);

		if ( field.equals("length") && evalBaseObject.getClass().isArray() )
		{
			Object obj = new Primitive(Array.getLength(evalBaseObject));
			return completeRound( field, suffix(evalName), obj );
		}

		try {
			Object obj = Reflect.getObjectFieldValue(evalBaseObject, field);
			return completeRound( field, suffix(evalName), obj );
		} catch(ReflectError e) {  }

		throw new UtilEvalError(
			"Cannot access field: " + field + ", on object: " + evalBaseObject);
	}

	Object resolveThisFieldReference( BshEvaluatingVisitor visitor,
		NameSpace thisNameSpace,
		String varName, boolean specialFieldsVisible ) 
		throws UtilEvalError
	{
		if ( varName.equals("this") ) 
		{

			if ( specialFieldsVisible )
				throw new UtilEvalError("Redundant to call .this on This type");

			This ths = thisNameSpace.getThis( visitor.getInterpreter() );
			thisNameSpace= ths.getNameSpace();
			Object result = ths;
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				if ( isCompound( evalName ) )
					result = classNameSpace.getThis( visitor.getInterpreter() );
				else
					result = classNameSpace.getClassInstance();
			}
			return result;
		}

		if ( varName.equals("super") ) 
		{

			This ths = thisNameSpace.getSuper( visitor.getInterpreter() );
			thisNameSpace = ths.getNameSpace();

			if ( 
				thisNameSpace.getParent() != null 
				&& thisNameSpace.getParent().isClass
			)
				ths = thisNameSpace.getParent().getThis( visitor.getInterpreter() );
			return ths;
		}
		Object obj = null;
		if ( varName.equals("global") )
			obj = thisNameSpace.getGlobal( visitor.getInterpreter() );
		if ( obj == null && specialFieldsVisible ) 
		{
			if (varName.equals("namespace"))
				obj = thisNameSpace;
			else if (varName.equals("variables"))
				obj = thisNameSpace.getVariableNames();
			else if (varName.equals("methods"))
				obj = thisNameSpace.getMethodNames();
			else if ( varName.equals("interpreter") )
				if ( lastEvalName.equals("this") )
					obj = visitor.getInterpreter();
				else
					throw new UtilEvalError(
						"Can only call .interpreter on literal 'this'");
		}
		if ( obj == null && specialFieldsVisible && varName.equals("caller") )
		{
			if ( lastEvalName.equals("this") || lastEvalName.equals("caller") ) 
			{

				if ( visitor.getInterpreter() == null )
					throw new InterpreterError("no callstack");
				obj = visitor.getCallstack().get( ++callstackDepth ).getThis(
					visitor.getInterpreter() );
			}
			else
				throw new UtilEvalError(
				"Can only call .caller on literal 'this' or literal '.caller'");

			return obj;
		}
		if ( obj == null && specialFieldsVisible 
			&& varName.equals("callstack") )
		{
			if ( lastEvalName.equals("this") ) 
			{

				if ( visitor.getCallstack() == null )
					throw new InterpreterError("no callstack");
				obj = visitor.getCallstack();
			}
			else
				throw new UtilEvalError(
				"Can only call .callstack on literal 'this'");
		}
		if ( obj == null )
			obj = thisNameSpace.getVariable(varName);
		if ( obj == null )
			throw new InterpreterError("null this field ref:"+varName);
		return obj;
	}

	public static NameSpace getClassNameSpace( NameSpace thisNameSpace )
	{

		if ( thisNameSpace.isClass )
			return thisNameSpace;
		if ( thisNameSpace.isMethod 
			&& thisNameSpace.getParent() != null 

			&& thisNameSpace.getParent().isClass
		)
			return thisNameSpace.getParent();
		return null;
	}

	synchronized public Class toClass() 
		throws ClassNotFoundException, UtilEvalError
	{
		if ( asClass != null )
			return asClass;
		reset();

		if ( evalName.equals("var") )
			return asClass = null;

		Class clas = namespace.getClass( evalName );
		if ( clas == null ) 
		{

			Object obj = null;
			try {

				obj = toObject( new BshEvaluatingVisitor(null, null), true );
			} catch ( UtilEvalError  e ) { }; 

			if ( obj instanceof ClassIdentifier )
				clas = ((ClassIdentifier)obj).getTargetClass();
		}
		if ( clas == null )
			throw new ClassNotFoundException(
				"Class: " + value+ " not found in namespace");
		asClass = clas;
		return asClass;
	}

	synchronized public LHS toLHS( 
		BshEvaluatingVisitor visitor )
		throws UtilEvalError
	{

		reset();
		LHS lhs;

		if ( !isCompound(evalName) ) 
		{
			if ( evalName.equals("this") )
				throw new UtilEvalError("Can't assign to 'this'." );

			lhs = new LHS( namespace, evalName, false);
			return lhs;
		}

		Object obj = null;
		try {
			while( evalName != null && isCompound( evalName ) )
			{
				obj = consumeNextObjectField( visitor,
					false, true );
			}
		} 
		catch( UtilEvalError e ) {
			throw new UtilEvalError( "LHS evaluation: " + e.getMessage() );
		}

		if ( evalName == null && obj instanceof ClassIdentifier )
			throw new UtilEvalError("Can't assign to class: " + value );
		if ( obj == null )
			throw new UtilEvalError("Error in LHS: " + value );

		if ( obj instanceof This )
		{

			if ( 
				evalName.equals("namespace")
				|| evalName.equals("variables")
				|| evalName.equals("methods")
				|| evalName.equals("caller")
			)
				throw new UtilEvalError(
					"Can't assign to special variable: "+evalName );
			Interpreter.debug("found This reference evaluating LHS");

			boolean localVar = !lastEvalName.equals("super");
			return new LHS( ((This)obj).namespace, evalName, localVar );
		}
		if ( evalName != null )
		{
			try {
				if ( obj instanceof ClassIdentifier ) 
				{
					Class clas = ((ClassIdentifier)obj).getTargetClass();
					lhs = Reflect.getLHSStaticField(clas, evalName);
					return lhs;
				} else {
					lhs = Reflect.getLHSObjectField(obj, evalName);
					return lhs;
				}
			} catch(ReflectError e) {
				throw new UtilEvalError("Field access: "+e);
			}
		}
		throw new InterpreterError("Internal error in lhs...");
	}

    public Object invokeMethod( BshEvaluatingVisitor visitor,
		Object[] args,
		SimpleNode callerInfo
	)
        throws UtilEvalError, EvalError, ReflectError, InvocationTargetException
    {
        String methodName = Name.suffix(value, 1);
		BshClassManager bcm = visitor.getInterpreter().getClassManager();
		NameSpace namespace = visitor.getCallstack().top();

        if ( classOfStaticMethod != null )
		{
			return Reflect.invokeStaticMethod( 
				bcm, classOfStaticMethod, methodName, args );
		}
		if ( !Name.isCompound(value) )
			return invokeLocalMethod( visitor,
				args, callerInfo );

        String prefix = Name.prefix(value);

		if ( prefix.equals("super") && Name.countParts(value) == 2 )
		{

			This ths = namespace.getThis( visitor.getInterpreter() );
			NameSpace thisNameSpace = ths.getNameSpace();
			NameSpace classNameSpace = getClassNameSpace( thisNameSpace );
			if ( classNameSpace != null )
			{
				Object instance = classNameSpace.getClassInstance();
				return ClassGenerator.getClassGenerator()
					.invokeSuperclassMethod( bcm, instance, methodName, args );
			}
		}

        Name targetName = namespace.getNameResolver( prefix );
        Object obj = targetName.toObject( visitor );
		if ( obj == Primitive.VOID ) 
			throw new UtilEvalError( "Attempt to resolve method: "+methodName
					+"() on undefined variable or class name: "+targetName);

        if ( !(obj instanceof ClassIdentifier) ) {
            if (obj instanceof Primitive) {
                if (obj == Primitive.NULL)
                    throw new UtilTargetError( new NullPointerException( 
						"Null Pointer in Method Invocation of " +methodName
							+"() on variable: "+targetName) );

				if ( Interpreter.DEBUG )
                	visitor.getInterpreter().debug(
					"Attempt to access method on primitive..." 
					+ " allowing bsh.Primitive to peek through for debugging");
            }

            return Reflect.invokeObjectMethod(obj, methodName, args, visitor, callerInfo );
        }

        if ( Interpreter.DEBUG ) 
        	Interpreter.debug("invokeMethod: trying static - " + targetName);
        Class clas = ((ClassIdentifier)obj).getTargetClass();

		classOfStaticMethod = clas;

        if ( clas != null )
			return Reflect.invokeStaticMethod( bcm, clas, methodName, args );

		throw new UtilEvalError("invokeMethod: unknown target: " + targetName);
    }

    private Object invokeLocalMethod( BshEvaluatingVisitor visitor,
		Object[] args,
		SimpleNode callerInfo
	)
        throws EvalError
    {
        if ( Interpreter.DEBUG ) 
        	Interpreter.debug( "invokeLocalMethod: " + value );
		if ( visitor.getInterpreter() == null )
			throw new InterpreterError(
				"invokeLocalMethod: interpreter = null");
		String commandName = value;
		Class [] argTypes = Types.getTypes( args );

        BshMethod meth = null;
		try {
			meth = namespace.getMethod( commandName, argTypes );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError(
				"Local method invocation", callerInfo, visitor.getCallstack() );
		}

        if ( meth != null )
			return meth.invoke( args, visitor, callerInfo );
		BshClassManager bcm = visitor.getInterpreter().getClassManager();

		Object commandObject;
		try {
			commandObject = namespace.getCommand( 
				commandName, argTypes, visitor.getInterpreter() );
		} catch ( UtilEvalError e ) {
			throw e.toEvalError("Error loading command: ", 
				callerInfo, visitor.getCallstack() );
		}

		if ( commandObject == null )
		{

			BshMethod invokeMethod = null;
			try {
				invokeMethod = namespace.getMethod( 
					"invoke", new Class [] { null, null } );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError(
					"Local method invocation", callerInfo, visitor.getCallstack() );
			}
			if ( invokeMethod != null )
				return invokeMethod.invoke( 
					new Object [] { commandName, args },
                        visitor,
					callerInfo );
            throw new EvalError( "Command not found: " 
				+StringUtil.methodString( commandName, argTypes ), 
				callerInfo, visitor.getCallstack() );
		}
		if ( commandObject instanceof BshMethod )
			return ((BshMethod)commandObject).invoke( 
				args, visitor, callerInfo );
		if ( commandObject instanceof Class )
			try {
				return Reflect.invokeCompiledCommand( 
					((Class)commandObject), args, visitor );
			} catch ( UtilEvalError e ) {
				throw e.toEvalError("Error invoking compiled command: ",
				callerInfo, visitor.getCallstack() );
			}
		throw new InterpreterError("invalid command type");
    }

	public static boolean isCompound(String value)
	{
		return value.indexOf('.') != -1 ;

	}
	static int countParts(String value)
	{
		if(value == null)
			return 0;
		int count = 0;
		int index = -1;
		while((index = value.indexOf('.', index + 1)) != -1)
			count++;
		return count + 1;
	}
	static String prefix(String value)
	{
		if(!isCompound(value))
			return null;
		return prefix(value, countParts(value) - 1);
	}
	static String prefix(String value, int parts)
	{
		if (parts < 1 )
			return null;
		int count = 0;
		int index = -1;
		while( ((index = value.indexOf('.', index + 1)) != -1) 
			&& (++count < parts) )
		{ ; }
		return (index == -1) ? value : value.substring(0, index);
	}
	static String suffix(String name)
	{
		if(!isCompound(name))
			return null;
		return suffix(name, countParts(name) - 1);
	}
	public static String suffix(String value, int parts)
	{
		if (parts < 1)
			return null;
		int count = 0;
		int index = value.length() + 1;
		while ( ((index = value.lastIndexOf('.', index - 1)) != -1) 
			&& (++count < parts) );
		return (index == -1) ? value : value.substring(index + 1);
	}

	public String toString() { return value; }
}
package bsh;
import bsh.ast.SimpleNode;

public class ReturnControl implements ParserConstants {
	public int kind;
	public Object value;

	public SimpleNode returnPoint;
	public ReturnControl( int kind, Object value, SimpleNode returnPoint ) {
		this.kind = kind;
		this.value = value;
		this.returnPoint = returnPoint;
	}
}
package bsh;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.net.URL;
import java.util.Collections;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Map;
import java.util.Set;
import java.util.WeakHashMap;

public class BshClassManager
{

	private Interpreter declaringInterpreter;

	protected ClassLoader externalClassLoader;

    protected transient Map<String,Class> absoluteClassCache = new Hashtable<String,Class>();

    protected transient Set<String> absoluteNonClasses = Collections.synchronizedSet(new HashSet<String>());

	protected transient volatile Map<SignatureKey,Method> resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
	protected transient volatile Map<SignatureKey,Method> resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
	private transient Set<String> definingClasses = Collections.synchronizedSet(new HashSet<String>());
	protected transient Map<String,String> definingClassesBaseNames = new Hashtable<String,String>();
	private static final Map<BshClassManager,Object> classManagers = Collections.synchronizedMap(new WeakHashMap<BshClassManager,Object>());
	static void clearResolveCache() {
		BshClassManager[] managers = (BshClassManager[])classManagers.keySet().toArray(new BshClassManager[0]);
		for( BshClassManager m : managers ) {
			m.resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
			m.resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
		}
	}

	public static BshClassManager createClassManager( Interpreter interpreter ) 
	{
		BshClassManager manager;

		if ( Capabilities.classExists("bsh.classpath.ClassManagerImpl") ) 
			try {

				Class clazz = Class.forName( "bsh.classpath.ClassManagerImpl" );
				manager = (BshClassManager) clazz.newInstance();
			} catch ( Exception e ) {
				throw new InterpreterError("Error loading classmanager", e);
			}
		else
			manager = new BshClassManager();
		if ( interpreter == null )
			interpreter = new Interpreter();
		manager.declaringInterpreter = interpreter;
		classManagers.put(manager,null);
		return manager;
	}
	public boolean classExists( String name ) {
		return ( classForName( name ) != null );
	}

	public Class classForName( String name ) 
	{
		if ( isClassBeingDefined( name ) )
			throw new InterpreterError(
				"Attempting to load class in the process of being defined: "
				+name );
		Class clas = null;
		try {
			clas = plainClassForName( name );
		} catch ( ClassNotFoundException e ) {  }
		return clas;
	}

	public Class plainClassForName( String name ) 
		throws ClassNotFoundException
	{
		Class c = null;
		if ( externalClassLoader != null )
			c = externalClassLoader.loadClass( name );
		else
			c = Class.forName( name );
		cacheClassInfo( name, c );
		return c;
	}

	public URL getResource( String path ) 
	{
		URL url = null;
		if ( externalClassLoader != null )
		{

			url = externalClassLoader.getResource( path.substring(1) );
		} 
		if ( url == null )
			url = Interpreter.class.getResource( path );
		return url;
	}

	public InputStream getResourceAsStream( String path ) 
	{
		InputStream in = null;
		if ( externalClassLoader != null )
		{

			in = externalClassLoader.getResourceAsStream( path.substring(1) );
		} 
		if ( in == null )
			in = Interpreter.class.getResourceAsStream( path );
		return in;
	}

	public void cacheClassInfo( String name, Class value ) {
		if ( value != null )
			absoluteClassCache.put( name, value );
		else
			absoluteNonClasses.add( name );
	}

	public void cacheResolvedMethod( 
		Class clas, Class [] types, Method method ) 
	{
		if ( Interpreter.DEBUG )
			Interpreter.debug(
				"cacheResolvedMethod putting: " + clas +" "+ method );

		SignatureKey sk = new SignatureKey( clas, method.getName(), types );
		if ( Modifier.isStatic( method.getModifiers() ) )
			resolvedStaticMethods.put( sk, method );
		else
			resolvedObjectMethods.put( sk, method );
	}

	protected Method getResolvedMethod( 
		Class clas, String methodName, Class [] types, boolean onlyStatic  ) 
	{
		SignatureKey sk = new SignatureKey( clas, methodName, types );

		Method method = resolvedStaticMethods.get( sk );
		if ( method == null && !onlyStatic)
			method = resolvedObjectMethods.get( sk );
		if ( Interpreter.DEBUG )
		{
			if ( method == null )
				Interpreter.debug(
					"getResolvedMethod cache MISS: " + clas +" - "+methodName );
			else
				Interpreter.debug(
					"getResolvedMethod cache HIT: " + clas +" - " +method );
		}
		return method;
	}

	protected void clearCaches() 
	{
		absoluteNonClasses = Collections.synchronizedSet(new HashSet<String>());
		absoluteClassCache = new Hashtable<String,Class>();
		resolvedObjectMethods = new Hashtable<SignatureKey,Method>();
		resolvedStaticMethods = new Hashtable<SignatureKey,Method>();
	}

	public void setClassLoader( ClassLoader externalCL ) 
	{
		externalClassLoader = externalCL;
		classLoaderChanged();
	}
	public void addClassPath( URL path )
		throws IOException {
	}

	public void reset() { 
		clearCaches();
	}

	public void setClassPath( URL [] cp ) 
		throws UtilEvalError
	{
		throw cmUnavailable();
	}

	public void reloadAllClasses() throws UtilEvalError {
		throw cmUnavailable();
	}

	public void reloadClasses( String [] classNames )
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}

	public void reloadPackage( String pack ) 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}

	protected void doSuperImport() 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}

	protected boolean hasSuperImport() 
	{
		return false;
	}

	protected String getClassNameByUnqName( String name ) 
		throws UtilEvalError 
	{
		throw cmUnavailable();
	}
	public void addListener( Listener l ) { }
	public void removeListener( Listener l ) { }
	public void dump( PrintWriter pw ) { 
		pw.println("BshClassManager: no class manager."); 
	}

	protected void definingClass( String className ) {
		String baseName = Name.suffix(className,1);
		int i = baseName.indexOf("$");
		if ( i != -1 )
			baseName = baseName.substring(i+1);
		String cur = definingClassesBaseNames.get( baseName );
		if ( cur != null )
			throw new InterpreterError("Defining class problem: "+className 
				+": BeanShell cannot yet simultaneously define two or more "
				+"dependant classes of the same name.  Attempt to define: "
				+ className +" while defining: "+cur 
			);
		definingClasses.add( className );
		definingClassesBaseNames.put( baseName, className );
	}
	protected boolean isClassBeingDefined( String className ) {
		return definingClasses.contains( className );
	}

	public String getClassBeingDefined( String className ) {
		String baseName = Name.suffix(className,1);
		return definingClassesBaseNames.get( baseName );
	}

	protected void doneDefiningClass( String className ) {
		String baseName = Name.suffix(className,1);
		definingClasses.remove( className );
		definingClassesBaseNames.remove( baseName );
	}

	public Class defineClass( String name, byte [] code ) 
	{
		throw new InterpreterError("Can't create class ("+name
			+") without class manager package.");

	}
	protected void classLoaderChanged() { }
	protected static UtilEvalError cmUnavailable() {
		return new Capabilities.Unavailable(
			"ClassLoading features unavailable.");
	}
	public static interface Listener 
	{
		public void classLoaderChanged();
	}

	static class SignatureKey
	{
		Class clas;
		Class [] types;
		String methodName;
		int hashCode = 0;
		SignatureKey( Class clas, String methodName, Class [] types ) {
			this.clas = clas;
			this.methodName = methodName;
			this.types = types;
		}
		public int hashCode() 
		{ 
			if ( hashCode == 0 ) 
			{
				hashCode = clas.hashCode() * methodName.hashCode();
				if ( types == null ) 
					return hashCode; 
				for( int i =0; i < types.length; i++ ) {
					int hc = types[i] == null ? 21 : types[i].hashCode();
					hashCode = hashCode*(i+1) + hc;
				}
			}
			return hashCode;
		}
		public boolean equals( Object o ) { 
			SignatureKey target = (SignatureKey)o;
			if ( types == null )
				return target.types == null;
			if ( clas != target.clas )
				return false;
			if ( !methodName.equals( target.methodName ) )
				return false;
			if ( types.length != target.types.length )
				return false;
			for( int i =0; i< types.length; i++ )
			{
				if ( types[i]==null ) 
				{
					if ( !(target.types[i]==null) )
						return false;
				} else 
					if ( !types[i].equals( target.types[i] ) )
						return false;
			}
			return true;
		}
	}
}
package bsh.classpath;
import java.net.*;
import java.util.*;
import java.io.*;
import bsh.BshClassManager;

public class BshClassLoader extends URLClassLoader 
{
	BshClassManager classManager;

	public BshClassLoader( BshClassManager classManager, URL [] bases ) {
		super( bases );
		this.classManager = classManager;
	}

	public BshClassLoader( BshClassManager classManager, BshClassPath bcp ) {
		this( classManager, bcp.getPathComponents() );
	}

	protected BshClassLoader( BshClassManager classManager ) { 
		this( classManager, new URL [] { } );
	}

	public void addURL( URL url ) {
		super.addURL( url );
	}

	public Class loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
		if (name.startsWith("java.")) {
			return super.loadClass(name, resolve); 
		}

		Class c = findLoadedClass(name);
		if ( c != null ) {
			return c;
		}

		if ( name.startsWith( ClassManagerImpl.BSH_PACKAGE ) ) {
			try {
				return bsh.Interpreter.class.getClassLoader().loadClass( name );
			} catch ( ClassNotFoundException e ) {

			}
		}

		c = findClass( name );
		if ( resolve ) {
			resolveClass( c );
		}
		return c;
	}

	protected Class findClass( String name ) 
		throws ClassNotFoundException 
	{

		ClassManagerImpl bcm = (ClassManagerImpl)getClassManager();

		ClassLoader cl = bcm.getLoaderForClass( name );
		Class c;

		if ( cl != null && cl != this )
			try {
				return cl.loadClass( name );
			} catch ( ClassNotFoundException e ) {
				throw new ClassNotFoundException(
					"Designated loader could not find class: "+e );
			}

		if ( getURLs().length > 0 )
			try {
				return super.findClass(name);
			} catch ( ClassNotFoundException e ) { 

			}

		cl = bcm.getBaseLoader();
		if ( cl != null && cl != this )
			try {
				return cl.loadClass( name );
			} catch ( ClassNotFoundException e ) { }

		return bcm.plainClassForName( name );
	}

	BshClassManager getClassManager() { return classManager; }
}
package	bsh;
public class BlockNameSpace extends NameSpace
{
    public BlockNameSpace( NameSpace parent ) 
		throws EvalError
	{
		super( parent, parent.getName()+ "/BlockNameSpace" );
    }

    public void	setVariable( 
		String name, Object value, boolean strictJava, boolean recurse ) 
		throws UtilEvalError 
	{
		if ( weHaveVar( name ) ) 

			super.setVariable( name, value, strictJava, false );
		else

			getParent().setVariable( name, value, strictJava, recurse );
    }

    public void	setBlockVariable( String name, Object value ) 
		throws UtilEvalError 
	{
		super.setVariable( name, value, false, false );
	}

	private boolean weHaveVar( String name ) 
	{

		try {
			return super.getVariableImpl( name, false ) != null;
		} catch ( UtilEvalError e ) { return false; }
	}

	private NameSpace getNonBlockParent() 
	{
		NameSpace parent = super.getParent();
		if ( parent instanceof BlockNameSpace )
			return ((BlockNameSpace)parent).getNonBlockParent();
		else
			return parent;
	}

    public This getThis( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getThis( declaringInterpreter );
	}

    public This getSuper( Interpreter declaringInterpreter ) {
		return getNonBlockParent().getSuper( declaringInterpreter );
	}

    public void	importClass(String name) {
		getParent().importClass( name );
	}

    public void	importPackage(String name) {
		getParent().importPackage( name );
	}
    public void	setMethod(BshMethod method) 
		throws UtilEvalError
	{
		getParent().setMethod( method );
	}
}
package bsh.classpath;
import java.net.*;
import java.util.*;
import java.lang.ref.*;
import java.io.IOException;
import java.io.*;
import bsh.classpath.BshClassPath.ClassSource;
import bsh.classpath.BshClassPath.JarClassSource;
import bsh.classpath.BshClassPath.GeneratedClassSource;
import bsh.BshClassManager;
import bsh.ClassPathException;
import bsh.Interpreter;  
import bsh.UtilEvalError; 

public class ClassManagerImpl extends BshClassManager
{
	static final String BSH_PACKAGE = "bsh";

	private BshClassPath baseClassPath;
	private boolean superImport;

	private BshClassPath fullClassPath;

	private Vector listeners = new Vector();
	private ReferenceQueue refQueue = new ReferenceQueue();

	private BshClassLoader baseLoader;

	private Map loaderMap;

	public ClassManagerImpl() {
		reset();
	}

	@Override
	public Class classForName( String name )
	{

		Class c = (Class)absoluteClassCache.get(name);
		if (c != null )
			return c;

		if ( absoluteNonClasses.contains(name) ) {
			if ( Interpreter.DEBUG ) Interpreter.debug("absoluteNonClass list hit: "+name);
			return null;
		}
		if ( Interpreter.DEBUG ) Interpreter.debug("Trying to load class: "+name);

		final ClassLoader overlayLoader = getLoaderForClass( name );
		if ( overlayLoader != null ) {
			try {
				c = overlayLoader.loadClass(name);
			} catch ( Exception e ) {
				if ( Interpreter.DEBUG ) Interpreter.debug("overlay loader failed for '" + name + "' - " + e);
			}

		}

		if ((c == null) && name.startsWith(BSH_PACKAGE)) {
			final ClassLoader myClassLoader = Interpreter.class.getClassLoader(); 
			if (myClassLoader != null) {
				try {
					c = myClassLoader.loadClass(name);
				} catch (ClassNotFoundException e) {

				} catch (NoClassDefFoundError e) {

				}
			} else {
				try {
					c = Class.forName( name );
				} catch ( ClassNotFoundException e ) {

				} catch ( NoClassDefFoundError e ) {

				}
			}
		}

		if ((c == null) && (baseLoader != null)) {
			try {
				c = baseLoader.loadClass(name);
			} catch (ClassNotFoundException e) {

			}
		}

		if ((c == null) && (externalClassLoader != null)) {
			try {
				c = externalClassLoader.loadClass(name);
			} catch (ClassNotFoundException e) {

			}
		}

		if ( c ==  null ) {
			try {
				final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
				if ( contextClassLoader != null ) {
					c = Class.forName( name, true, contextClassLoader );
				}
			} catch ( ClassNotFoundException e ) { 

			} catch ( NoClassDefFoundError e ) { 

			} catch ( SecurityException e ) { 

			} 
		}

		if ( c == null )
			try {
				c = Class.forName( name );
			} catch ( ClassNotFoundException e ) {

			}

		cacheClassInfo( name, c );
		return c;
	}

	@Override
	public URL getResource( String path )
	{
		URL url = null;
		if ( baseLoader != null )

			url = baseLoader.getResource( path.substring(1) );
		if ( url == null )
			url = super.getResource( path );
		return url;
	}

	@Override
	public InputStream getResourceAsStream( String path )
	{
		InputStream in = null;
		if ( baseLoader != null )
		{

			in = baseLoader.getResourceAsStream( path.substring(1) );
		}
		if ( in == null )
		{
			in = super.getResourceAsStream( path );
		}
		return in;
	}
	ClassLoader getLoaderForClass( String name ) {
		return (ClassLoader)loaderMap.get( name );
	}

	@Override
	public void addClassPath( URL path )
		throws IOException 
	{
		if ( baseLoader == null )
			setClassPath( new URL [] { path } );
		else {

			baseLoader.addURL( path );
			baseClassPath.add( path );
			classLoaderChanged();
		}
	}

	@Override
	public void reset()
	{
		baseClassPath = new BshClassPath("baseClassPath");
		baseLoader = null;
		loaderMap = new HashMap();
		classLoaderChanged(); 
	}

	@Override
	public void setClassPath( URL [] cp ) {
		baseClassPath.setPath( cp );
		initBaseLoader();
		loaderMap = new HashMap();
		classLoaderChanged();
	}

	@Override
	public void reloadAllClasses() throws ClassPathException
	{
		BshClassPath bcp = new BshClassPath("temp");
		bcp.addComponent( baseClassPath );
		bcp.addComponent( BshClassPath.getUserClassPath() );
		setClassPath( bcp.getPathComponents() );
	}

	private void initBaseLoader() {
		baseLoader = new BshClassLoader( this, baseClassPath );
	}

	@Override
	public void reloadClasses( String [] classNames )
		throws ClassPathException
	{

		if ( baseLoader == null )
			initBaseLoader();
		DiscreteFilesClassLoader.ClassSourceMap map = 
			new DiscreteFilesClassLoader.ClassSourceMap();
		for (int i=0; i< classNames.length; i++) {
			String name = classNames[i];

			ClassSource classSource = baseClassPath.getClassSource( name );

			if ( classSource == null ) {
				BshClassPath.getUserClassPath().insureInitialized();
				classSource = BshClassPath.getUserClassPath().getClassSource( 
					name );
			}

			if ( classSource == null )
				throw new ClassPathException("Nothing known about class: "
					+name );

			if ( classSource instanceof JarClassSource )
				throw new ClassPathException("Cannot reload class: "+name+
					" from source: "+ classSource );
			map.put( name, classSource );
		}

		ClassLoader cl = new DiscreteFilesClassLoader( this, map );

		Iterator it = map.keySet().iterator();
		while ( it.hasNext() )
			loaderMap.put( (String)it.next(), cl );
		classLoaderChanged();
	}

	@Override
	public void reloadPackage( String pack )
		throws ClassPathException 
	{
		Collection classes = 
			baseClassPath.getClassesForPackage( pack );
		if ( classes == null )
			classes = 
				BshClassPath.getUserClassPath().getClassesForPackage( pack );

		if ( classes == null )
			throw new ClassPathException("No classes found for package: "+pack);
		reloadClasses( (String[])classes.toArray( new String[0] ) );
	}

	public BshClassPath getClassPath() throws ClassPathException
	{
		if ( fullClassPath != null )
			return fullClassPath;

		fullClassPath = new BshClassPath("BeanShell Full Class Path");
		fullClassPath.addComponent( BshClassPath.getUserClassPath() );
		try {
			fullClassPath.addComponent( BshClassPath.getBootClassPath() );
		} catch ( ClassPathException e ) { 
			System.err.println("Warning: can't get boot class path");
		}
		fullClassPath.addComponent( baseClassPath );
		return fullClassPath;
	}

	@Override
	public void doSuperImport()
		throws UtilEvalError
	{

		try {
			getClassPath().insureInitialized();

			getClassNameByUnqName( "" ) ;

		} catch ( ClassPathException e ) {
			throw new UtilEvalError("Error importing classpath "+ e );
		}
		superImport = true;
	}
	@Override
	protected boolean hasSuperImport() { return superImport; }

	@Override
	public String getClassNameByUnqName( String name )
		throws ClassPathException
	{
		return getClassPath().getClassNameByUnqName( name );
	}
	@Override
	public void addListener( Listener l ) {
		listeners.addElement( new WeakReference( l, refQueue) );

		Reference deadref;
		while ( (deadref = refQueue.poll()) != null ) {
			boolean ok = listeners.removeElement( deadref );
			if ( ok ) {

			} else {
				if ( Interpreter.DEBUG ) Interpreter.debug(
					"tried to remove non-existent weak ref: "+deadref);
			}
		}
	}
	@Override
	public void removeListener( Listener l ) {
		throw new Error("unimplemented");
	}
	public ClassLoader getBaseLoader() {
		return baseLoader;
	}

	@Override
	public Class defineClass( String name, byte [] code )
	{
		baseClassPath.setClassSource( name, new GeneratedClassSource( code ) );
		try {
			reloadClasses( new String [] { name } );
		} catch ( ClassPathException e ) {
			throw new bsh.InterpreterError("defineClass: "+e);
		}
		return classForName( name );
	}

	@Override
	protected void classLoaderChanged()
	{

		clearCaches();
		Vector toRemove = new Vector(); 
		for ( Enumeration e = listeners.elements(); e.hasMoreElements(); ) 
		{
			WeakReference wr = (WeakReference)e.nextElement();
			Listener l = (Listener)wr.get();
			if ( l == null )  
			  toRemove.add( wr );
			else
			  l.classLoaderChanged();
		}
		for( Enumeration e = toRemove.elements(); e.hasMoreElements(); ) 
			listeners.removeElement( e.nextElement() );
	}
	@Override
	public void dump( PrintWriter i )
	{
		i.println("Bsh Class Manager Dump: ");
		i.println("----------------------- ");
		i.println("baseLoader = "+baseLoader);
		i.println("loaderMap= "+loaderMap);
		i.println("----------------------- ");
		i.println("baseClassPath = "+baseClassPath);
	}
}
package bsh;
import bsh.ast.Node;
class JJTParserState {
  private java.util.Stack nodes;
  private java.util.Stack marks;
  private int sp;		
  private int mk;		
  private boolean node_created;
  JJTParserState() {
    nodes = new java.util.Stack();
    marks = new java.util.Stack();
    sp = 0;
    mk = 0;
  }

  boolean nodeCreated() {
    return node_created;
  }

  void reset() {
    nodes.removeAllElements();
    marks.removeAllElements();
    sp = 0;
    mk = 0;
  }

  Node rootNode() {
    return (Node)nodes.elementAt(0);
  }

  void pushNode(Node n) {
    nodes.push(n);
    ++sp;
  }

  Node popNode() {
    if (--sp < mk) {
      mk = ((Integer)marks.pop()).intValue();
    }
    return (Node)nodes.pop();
  }

  Node peekNode() {
    return (Node)nodes.peek();
  }

  int nodeArity() {
    return sp - mk;
  }
  void clearNodeScope(Node n) {
    while (sp > mk) {
      popNode();
    }
    mk = ((Integer)marks.pop()).intValue();
  }
  void openNodeScope(Node n) {
    marks.push(new Integer(mk));
    mk = sp;
    n.jjtOpen();
  }

  void closeNodeScope(Node n, int num) {
    mk = ((Integer)marks.pop()).intValue();
    while (num-- > 0) {
      Node c = popNode();
      c.jjtSetParent(n);
      n.jjtAddChild(c, num);
    }
    n.jjtClose();
    pushNode(n);
    node_created = true;
  }

  void closeNodeScope(Node n, boolean condition) {
    if (condition) {
      int a = nodeArity();
      mk = ((Integer)marks.pop()).intValue();
      while (a-- > 0) {
	Node c = popNode();
	c.jjtSetParent(n);
	n.jjtAddChild(c, a);
      }
      n.jjtClose();
      pushNode(n);
      node_created = true;
    } else {
      mk = ((Integer)marks.pop()).intValue();
      node_created = false;
    }
  }
}
import java.io.*;
import java.util.Vector;
import bsh.ast.*;

public class Parserimplements ParserTreeConstants, ParserConstants {
  protected JJTParserState jjtree = new JJTParserState();boolean retainComments = false;
        public void setRetainComments( boolean b ) {
                retainComments = b;
        }
        void jjtreeOpenNodeScope(Node n) {
                ((SimpleNode)n).firstToken = getToken(1);
        }
        void jjtreeCloseNodeScope(Node n) {
                ((SimpleNode)n).lastToken = getToken(0);
        }

        void reInitInput( Reader in ) {
                ReInit(in);
        }
        public SimpleNode popNode()
        {
                if ( jjtree.nodeArity() > 0)  
                        return (SimpleNode)jjtree.popNode();
                else
                        return null;
        }

        void reInitTokenInput( Reader in ) {
                jj_input_stream.ReInit( in,
                        jj_input_stream.getEndLine(),
                        jj_input_stream.getEndColumn() );
        }
        public static void main( String [] args )
                throws IOException, ParseException
        {
                boolean print = false;
                int i=0;
                if ( args[0].equals("-p") ) {
                        i++;
                        print=true;
                }
                for(; i< args.length; i++) {
                        Reader in = new FileReader(args[i]);
                        Parser parser = new Parser(in);
                        parser.setRetainComments(true);
                        while( !parser.Line() )
                                if ( print )
                                        System.out.println( parser.popNode() );
                }
        }

        boolean isRegularForStatement()
        {
                int curTok = 1;
                Token tok;
                tok = getToken(curTok++);
                if ( tok.kind != FOR ) return false;
                tok = getToken(curTok++);
                if ( tok.kind != LPAREN ) return false;
                while (true)
                {
                        tok = getToken(curTok++);
                        switch (tok.kind) {
                                case COLON:
                                        return false;
                                case SEMICOLON:
                                        return true;
                                case EOF:
                                        return false;
                        }
                }
        }

        ParseException createParseException( String message, Exception e )
        {
                Token errortok = token;
                int line = errortok.beginLine, column = errortok.beginColumn;
                String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
                return new ParseException( "Parse error at line " + line
                        + ", column " + column + " : " + message + "\u005cn" +  e );
        }
        int parseInt(String s) throws NumberFormatException {
                int radix;
                int i;
                if( s.startsWith("0x") || s.startsWith("0X") ) {
                        radix = 16;
                        i = 2;
                } else if( s.startsWith("0") && s.length() > 1 ) {
                        radix = 8;
                        i = 1;
                } else {
                        radix = 10;
                        i = 0;
                }
                int result = 0;
                int len = s.length();
                for( ; i<len; i++ ) {
                        if( result < 0 )
                                throw new NumberFormatException("Number too big for integer type: "+s);
                        result *= radix;
                        int digit = Character.digit(s.charAt(i),radix);
                        if( digit < 0 )
                                throw new NumberFormatException("Invalid integer type: "+s);
                        result += digit;
                }
                return result;
        }
        long parseLong(String s) throws NumberFormatException {
                int radix;
                int i;
                if( s.startsWith("0x") || s.startsWith("0X") ) {
                        radix = 16;
                        i = 2;
                } else if( s.startsWith("0") && s.length() > 1 ) {
                        radix = 8;
                        i = 1;
                } else {
                        radix = 10;
                        i = 0;
                }
                long result = 0;
                int len = s.length();
                for( ; i<len; i++ ) {
                        if( result < 0L )
                                throw new NumberFormatException("Number too big for long type: "+s);
                        result *= radix;
                        int digit = Character.digit(s.charAt(i),radix);
                        if( digit < 0 )
                                throw new NumberFormatException("Invalid long type: "+s);
                        result += digit;
                }
                return result;
        }

  final public boolean Line() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 0:
      jj_consume_token(0);
        Interpreter.debug("End of File!");
        {if (true) return true;}
      break;
    default:
      if (jj_2_1(1)) {
        BlockStatement();
        {if (true) return false;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public Modifiers Modifiers(int context, boolean lookahead) throws ParseException {
        Modifiers mods = null;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case FINAL:
      case NATIVE:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case VOLATILE:
        ;
        break;
      default:
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PRIVATE:
        jj_consume_token(PRIVATE);
        break;
      case PROTECTED:
        jj_consume_token(PROTECTED);
        break;
      case PUBLIC:
        jj_consume_token(PUBLIC);
        break;
      case SYNCHRONIZED:
        jj_consume_token(SYNCHRONIZED);
        break;
      case FINAL:
        jj_consume_token(FINAL);
        break;
      case NATIVE:
        jj_consume_token(NATIVE);
        break;
      case TRANSIENT:
        jj_consume_token(TRANSIENT);
        break;
      case VOLATILE:
        jj_consume_token(VOLATILE);
        break;
      case ABSTRACT:
        jj_consume_token(ABSTRACT);
        break;
      case STATIC:
        jj_consume_token(STATIC);
        break;
      case STRICTFP:
        jj_consume_token(STRICTFP);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                if ( !lookahead )
                        try {
                                if ( mods == null ) mods = new Modifiers();
                                mods.addModifier( context, getToken(0).image );
                        } catch ( IllegalStateException e ) {
                                {if (true) throw createParseException( e.getMessage(), e );}
                        }
    }
        {if (true) return mods;}
    throw new Error("Missing return statement in function");
  }

  final public void ClassDeclaration() throws ParseException {

        BSHClassDeclaration jjtn000 = new BSHClassDeclaration(JJTCLASSDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Modifiers mods;
        Token name;
        int numInterfaces;
    try {
      mods = Modifiers(Modifiers.CLASS, false);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLASS:
        jj_consume_token(CLASS);
        break;
      case INTERFACE:
        jj_consume_token(INTERFACE);
                                  jjtn000.isInterface=true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      name = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXTENDS:
        jj_consume_token(EXTENDS);
        AmbiguousName();
                                      jjtn000.extend = true;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPLEMENTS:
        jj_consume_token(IMPLEMENTS);
        numInterfaces = NameList();
                  jjtn000.numInterfaces=numInterfaces;
        break;
      default:
        ;
      }
      Block();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.modifiers = mods;
                jjtn000.name = name.image;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void MethodDeclaration() throws ParseException {

        BSHMethodDeclaration jjtn000 = new BSHMethodDeclaration(JJTMETHODDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
        Modifiers mods;
        int count;
    try {
      mods = Modifiers(Modifiers.METHOD, false);
                                                      jjtn000.modifiers = mods;
      if (jj_2_2(2147483647)) {
        t = jj_consume_token(IDENTIFIER);
                           jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FLOAT:
        case INT:
        case LONG:
        case SHORT:
        case VOID:
        case IDENTIFIER:
          ReturnType();
          t = jj_consume_token(IDENTIFIER);
                           jjtn000.name = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      FormalParameters();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THROWS:
        jj_consume_token(THROWS);
        count = NameList();
                                      jjtn000.numThrows=count;
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        jj_consume_token(SEMICOLON);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void PackageDeclaration() throws ParseException {

  BSHPackageDeclaration jjtn000 = new BSHPackageDeclaration(JJTPACKAGEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(PACKAGE);
      AmbiguousName();
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void ImportDeclaration() throws ParseException {

    BSHImportDeclaration jjtn000 = new BSHImportDeclaration(JJTIMPORTDECLARATION);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token s = null;
        Token t = null;
    try {
      if (jj_2_3(3)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STATIC:
          s = jj_consume_token(STATIC);
          break;
        default:
          ;
        }
        jj_consume_token(IMPORT);
        AmbiguousName();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DOT:
          t = jj_consume_token(DOT);
          jj_consume_token(STAR);
          break;
        default:
          ;
        }
        jj_consume_token(SEMICOLON);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
                if ( s != null ) jjtn000.staticImport = true;
                if ( t != null ) jjtn000.importPackage = true;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IMPORT:
          jj_consume_token(IMPORT);
          jj_consume_token(STAR);
          jj_consume_token(SEMICOLON);
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtreeCloseNodeScope(jjtn000);
                jjtn000.superImport = true;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void VariableDeclarator() throws ParseException {

        BSHVariableDeclarator jjtn000 = new BSHVariableDeclarator(JJTVARIABLEDECLARATOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        VariableInitializer();
        break;
      default:
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                jjtn000.name = t.image;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }

  final public void VariableInitializer() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      ArrayInitializer();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LONG_STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case INCR:
    case DECR:
    case PLUS:
    case MINUS:
      Expression();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }
  final public void ArrayInitializer() throws ParseException {

  BSHArrayInitializer jjtn000 = new BSHArrayInitializer(JJTARRAYINITIALIZER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case LBRACE:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        VariableInitializer();
        label_2:
        while (true) {
          if (jj_2_4(2)) {
            ;
          } else {
            break label_2;
          }
          jj_consume_token(COMMA);
          VariableInitializer();
        }
        break;
      default:
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        ;
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void FormalParameters() throws ParseException {

  BSHFormalParameters jjtn000 = new BSHFormalParameters(JJTFORMALPARAMETERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        FormalParameter();
        label_3:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            break label_3;
          }
          jj_consume_token(COMMA);
          FormalParameter();
        }
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void FormalParameter() throws ParseException {

  BSHFormalParameter jjtn000 = new BSHFormalParameter(JJTFORMALPARAMETER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      if (jj_2_5(2)) {
        Type();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          TypeArguments();
          break;
        default:
          ;
        }
        t = jj_consume_token(IDENTIFIER);
                                                           jjtree.closeNodeScope(jjtn000, true);
                                                           jjtc000 = false;
                                                           jjtreeCloseNodeScope(jjtn000);
                                                           jjtn000.name = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                   jjtreeCloseNodeScope(jjtn000);
                   jjtn000.name = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void Type() throws ParseException {

  BSHType jjtn000 = new BSHType(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
        PrimitiveType();
        break;
      case IDENTIFIER:
        AmbiguousName();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      label_4:
      while (true) {
        if (jj_2_6(2)) {
          ;
        } else {
          break label_4;
        }
        jj_consume_token(LBRACKET);
        jj_consume_token(RBRACKET);
                                 jjtn000.addArrayDimension();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ReturnType() throws ParseException {

  BSHReturnType jjtn000 = new BSHReturnType(JJTRETURNTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        jj_consume_token(VOID);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.isVoid = true;
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FLOAT:
      case INT:
      case LONG:
      case SHORT:
      case IDENTIFIER:
        Type();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          TypeArguments();
          break;
        default:
          ;
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void PrimitiveType() throws ParseException {

  BSHPrimitiveType jjtn000 = new BSHPrimitiveType(JJTPRIMITIVETYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
        jj_consume_token(BOOLEAN);
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              jjtreeCloseNodeScope(jjtn000);
              jjtn000.type = Boolean.TYPE;
        break;
      case CHAR:
        jj_consume_token(CHAR);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Character.TYPE;
        break;
      case BYTE:
        jj_consume_token(BYTE);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Byte.TYPE;
        break;
      case SHORT:
        jj_consume_token(SHORT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Short.TYPE;
        break;
      case INT:
        jj_consume_token(INT);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.type =  Integer.TYPE;
        break;
      case LONG:
        jj_consume_token(LONG);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtreeCloseNodeScope(jjtn000);
           jjtn000.type =  Long.TYPE;
        break;
      case FLOAT:
        jj_consume_token(FLOAT);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtreeCloseNodeScope(jjtn000);
            jjtn000.type =  Float.TYPE;
        break;
      case DOUBLE:
        jj_consume_token(DOUBLE);
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
             jjtreeCloseNodeScope(jjtn000);
             jjtn000.type =  Double.TYPE;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void AmbiguousName() throws ParseException {

    BSHAmbiguousName jjtn000 = new BSHAmbiguousName(JJTAMBIGUOUSNAME);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t;
    StringBuilder s;
    try {
      t = jj_consume_token(IDENTIFIER);
        s = new StringBuilder(t.image);
      label_5:
      while (true) {
        if (jj_2_7(2)) {
          ;
        } else {
          break label_5;
        }
        jj_consume_token(DOT);
        t = jj_consume_token(IDENTIFIER);
                                        s.append("."+t.image);
      }
                                                                      jjtree.closeNodeScope(jjtn000, true);
                                                                      jjtc000 = false;
                                                                      jjtreeCloseNodeScope(jjtn000);
        jjtn000.text = s.toString();
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public int NameList() throws ParseException {
  int count = 0;
    AmbiguousName();
                    ++count;
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_6;
      }
      jj_consume_token(COMMA);
      AmbiguousName();
                                                       ++count;
    }
    {if (true) return count;}
    throw new Error("Missing return statement in function");
  }

  final public void Expression() throws ParseException {
    if (jj_2_8(2147483647)) {
      Assignment();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ConditionalExpression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void Assignment() throws ParseException {

  BSHAssignment jjtn000 = new BSHAssignment(JJTASSIGNMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);int op ;
    try {
      PrimaryExpression();
      op = AssignmentOperator();
                                    jjtn000.operator = op;
      Expression();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public int AssignmentOperator() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      break;
    case STARASSIGN:
      jj_consume_token(STARASSIGN);
      break;
    case SLASHASSIGN:
      jj_consume_token(SLASHASSIGN);
      break;
    case MODASSIGN:
      jj_consume_token(MODASSIGN);
      break;
    case PLUSASSIGN:
      jj_consume_token(PLUSASSIGN);
      break;
    case MINUSASSIGN:
      jj_consume_token(MINUSASSIGN);
      break;
    case ANDASSIGN:
      jj_consume_token(ANDASSIGN);
      break;
    case XORASSIGN:
      jj_consume_token(XORASSIGN);
      break;
    case ORASSIGN:
      jj_consume_token(ORASSIGN);
      break;
    case LSHIFTASSIGN:
      jj_consume_token(LSHIFTASSIGN);
      break;
    case LSHIFTASSIGNX:
      jj_consume_token(LSHIFTASSIGNX);
      break;
    case RSIGNEDSHIFTASSIGN:
      jj_consume_token(RSIGNEDSHIFTASSIGN);
      break;
    case RSIGNEDSHIFTASSIGNX:
      jj_consume_token(RSIGNEDSHIFTASSIGNX);
      break;
    case RUNSIGNEDSHIFTASSIGN:
      jj_consume_token(RUNSIGNEDSHIFTASSIGN);
      break;
    case RUNSIGNEDSHIFTASSIGNX:
      jj_consume_token(RUNSIGNEDSHIFTASSIGNX);
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
        t = getToken(0);
        {if (true) return t.kind;}
    throw new Error("Missing return statement in function");
  }
  final public void ConditionalExpression() throws ParseException {
    ConditionalOrExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case HOOK:
      jj_consume_token(HOOK);
      Expression();
      jj_consume_token(COLON);
                                                     BSHTernaryExpression jjtn001 = new BSHTernaryExpression(JJTTERNARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
        ConditionalExpression();
      } catch (Throwable jjte001) {
                                                     if (jjtc001) {
                                                       jjtree.clearNodeScope(jjtn001);
                                                       jjtc001 = false;
                                                     } else {
                                                       jjtree.popNode();
                                                     }
                                                     if (jjte001 instanceof RuntimeException) {
                                                       {if (true) throw (RuntimeException)jjte001;}
                                                     }
                                                     if (jjte001 instanceof ParseException) {
                                                       {if (true) throw (ParseException)jjte001;}
                                                     }
                                                     {if (true) throw (Error)jjte001;}
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  3);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
      break;
    default:
      ;
    }
  }
  final public void ConditionalOrExpression() throws ParseException {
  Token t=null;
    ConditionalAndExpression();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
      case BOOL_ORX:
        ;
        break;
      default:
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_OR:
        t = jj_consume_token(BOOL_OR);
        break;
      case BOOL_ORX:
        t = jj_consume_token(BOOL_ORX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ConditionalAndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void ConditionalAndExpression() throws ParseException {
  Token t=null;
    InclusiveOrExpression();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
      case BOOL_ANDX:
        ;
        break;
      default:
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOL_AND:
        t = jj_consume_token(BOOL_AND);
        break;
      case BOOL_ANDX:
        t = jj_consume_token(BOOL_ANDX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      InclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void InclusiveOrExpression() throws ParseException {
  Token t=null;
    ExclusiveOrExpression();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
      case BIT_ORX:
        ;
        break;
      default:
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        t = jj_consume_token(BIT_OR);
        break;
      case BIT_ORX:
        t = jj_consume_token(BIT_ORX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ExclusiveOrExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void ExclusiveOrExpression() throws ParseException {
  Token t=null;
    AndExpression();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case XOR:
        ;
        break;
      default:
        break label_10;
      }
      t = jj_consume_token(XOR);
      AndExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void AndExpression() throws ParseException {
  Token t=null;
    EqualityExpression();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
      case BIT_ANDX:
        ;
        break;
      default:
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        t = jj_consume_token(BIT_AND);
        break;
      case BIT_ANDX:
        t = jj_consume_token(BIT_ANDX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      EqualityExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void EqualityExpression() throws ParseException {
  Token t = null;
    InstanceOfExpression();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
      case NE:
        ;
        break;
      default:
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        t = jj_consume_token(EQ);
        break;
      case NE:
        t = jj_consume_token(NE);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      InstanceOfExpression();
      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  2);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
    }
  }
  final public void InstanceOfExpression() throws ParseException {
  Token t = null;
    RelationalExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INSTANCEOF:
      t = jj_consume_token(INSTANCEOF);
      Type();
                              BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                              boolean jjtc001 = true;
                              jjtree.openNodeScope(jjtn001);
                              jjtreeOpenNodeScope(jjtn001);
      try {
                              jjtree.closeNodeScope(jjtn001,  2);
                              jjtc001 = false;
                              jjtreeCloseNodeScope(jjtn001);
                              jjtn001.kind = t.kind;
      } finally {
                              if (jjtc001) {
                                jjtree.closeNodeScope(jjtn001,  2);
                                jjtreeCloseNodeScope(jjtn001);
                              }
      }
      break;
    default:
      ;
    }
  }
  final public void RelationalExpression() throws ParseException {
  Token t = null;
    ShiftExpression();
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GT:
      case GTX:
      case LT:
      case LTX:
      case LE:
      case LEX:
      case GE:
      case GEX:
        ;
        break;
      default:
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        t = jj_consume_token(LT);
        break;
      case LTX:
        t = jj_consume_token(LTX);
        break;
      case GT:
        t = jj_consume_token(GT);
        break;
      case GTX:
        t = jj_consume_token(GTX);
        break;
      case LE:
        t = jj_consume_token(LE);
        break;
      case LEX:
        t = jj_consume_token(LEX);
        break;
      case GE:
        t = jj_consume_token(GE);
        break;
      case GEX:
        t = jj_consume_token(GEX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      ShiftExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }
  final public void ShiftExpression() throws ParseException {
  Token t = null;
    AdditiveExpression();
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
      case LSHIFTX:
      case RSIGNEDSHIFT:
      case RSIGNEDSHIFTX:
      case RUNSIGNEDSHIFT:
      case RUNSIGNEDSHIFTX:
        ;
        break;
      default:
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        t = jj_consume_token(LSHIFT);
        break;
      case LSHIFTX:
        t = jj_consume_token(LSHIFTX);
        break;
      case RSIGNEDSHIFT:
        t = jj_consume_token(RSIGNEDSHIFT);
        break;
      case RSIGNEDSHIFTX:
        t = jj_consume_token(RSIGNEDSHIFTX);
        break;
      case RUNSIGNEDSHIFT:
        t = jj_consume_token(RUNSIGNEDSHIFT);
        break;
      case RUNSIGNEDSHIFTX:
        t = jj_consume_token(RUNSIGNEDSHIFTX);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      AdditiveExpression();
    BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
      try {
    jjtree.closeNodeScope(jjtn001,  2);
    jjtc001 = false;
    jjtreeCloseNodeScope(jjtn001);
    jjtn001.kind = t.kind;
      } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001,  2);
      jjtreeCloseNodeScope(jjtn001);
    }
      }
    }
  }
  final public void AdditiveExpression() throws ParseException {
  Token t = null;
    MultiplicativeExpression();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        break label_15;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      MultiplicativeExpression();
                                                     BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                                                     boolean jjtc001 = true;
                                                     jjtree.openNodeScope(jjtn001);
                                                     jjtreeOpenNodeScope(jjtn001);
      try {
                                                     jjtree.closeNodeScope(jjtn001,  2);
                                                     jjtc001 = false;
                                                     jjtreeCloseNodeScope(jjtn001);
                                                     jjtn001.kind = t.kind;
      } finally {
                                                     if (jjtc001) {
                                                       jjtree.closeNodeScope(jjtn001,  2);
                                                       jjtreeCloseNodeScope(jjtn001);
                                                     }
      }
    }
  }
  final public void MultiplicativeExpression() throws ParseException {
  Token t = null;
    UnaryExpression();
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
      case SLASH:
      case MOD:
        ;
        break;
      default:
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        t = jj_consume_token(STAR);
        break;
      case SLASH:
        t = jj_consume_token(SLASH);
        break;
      case MOD:
        t = jj_consume_token(MOD);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
                      BSHBinaryExpression jjtn001 = new BSHBinaryExpression(JJTBINARYEXPRESSION);
                      boolean jjtc001 = true;
                      jjtree.openNodeScope(jjtn001);
                      jjtreeOpenNodeScope(jjtn001);
      try {
                      jjtree.closeNodeScope(jjtn001,  2);
                      jjtc001 = false;
                      jjtreeCloseNodeScope(jjtn001);
                      jjtn001.kind = t.kind;
      } finally {
                      if (jjtc001) {
                        jjtree.closeNodeScope(jjtn001,  2);
                        jjtreeCloseNodeScope(jjtn001);
                      }
      }
    }
  }
  final public void UnaryExpression() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        t = jj_consume_token(PLUS);
        break;
      case MINUS:
        t = jj_consume_token(MINUS);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    case INCR:
      PreIncrementExpression();
      break;
    case DECR:
      PreDecrementExpression();
      break;
    case BOOLEAN:
    case BYTE:
    case CHAR:
    case DOUBLE:
    case FALSE:
    case FLOAT:
    case INT:
    case LONG:
    case NEW:
    case NULL:
    case SHORT:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LONG_STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
      UnaryExpressionNotPlusMinus();
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
  }
  final public void PreIncrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(INCR);
    PrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }
  final public void PreDecrementExpression() throws ParseException {
  Token t = null;
    t = jj_consume_token(DECR);
    PrimaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
  }
  final public void UnaryExpressionNotPlusMinus() throws ParseException {
  Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TILDE:
        t = jj_consume_token(TILDE);
        break;
      case BANG:
        t = jj_consume_token(BANG);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
      UnaryExpression();
      BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
      try {
      jjtree.closeNodeScope(jjtn001,  1);
      jjtc001 = false;
      jjtreeCloseNodeScope(jjtn001);
      jjtn001.kind = t.kind;
      } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  1);
        jjtreeCloseNodeScope(jjtn001);
      }
      }
      break;
    default:
      if (jj_2_9(2147483647)) {
        CastExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BOOLEAN:
        case BYTE:
        case CHAR:
        case DOUBLE:
        case FALSE:
        case FLOAT:
        case INT:
        case LONG:
        case NEW:
        case NULL:
        case SHORT:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LONG_STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
          PostfixExpression();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void CastLookahead() throws ParseException {
    if (jj_2_10(2)) {
      jj_consume_token(LPAREN);
      PrimitiveType();
    } else if (jj_2_11(2147483647)) {
      jj_consume_token(LPAREN);
      AmbiguousName();
      jj_consume_token(LBRACKET);
      jj_consume_token(RBRACKET);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        AmbiguousName();
        jj_consume_token(RPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TILDE:
          jj_consume_token(TILDE);
          break;
        case BANG:
          jj_consume_token(BANG);
          break;
        case LPAREN:
          jj_consume_token(LPAREN);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case NEW:
          jj_consume_token(NEW);
          break;
        case FALSE:
        case NULL:
        case TRUE:
        case VOID:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case LONG_STRING_LITERAL:
          Literal();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void PostfixExpression() throws ParseException {
  Token t = null;
    if (jj_2_12(2147483647)) {
      PrimaryExpression();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCR:
        t = jj_consume_token(INCR);
        break;
      case DECR:
        t = jj_consume_token(DECR);
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
                                BSHUnaryExpression jjtn001 = new BSHUnaryExpression(JJTUNARYEXPRESSION);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
                                jjtreeOpenNodeScope(jjtn001);
      try {
                                jjtree.closeNodeScope(jjtn001,  1);
                                jjtc001 = false;
                                jjtreeCloseNodeScope(jjtn001);
                jjtn001.kind = t.kind; jjtn001.postfix = true;
      } finally {
                                if (jjtc001) {
                                  jjtree.closeNodeScope(jjtn001,  1);
                                  jjtreeCloseNodeScope(jjtn001);
                                }
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
        PrimaryExpression();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void CastExpression() throws ParseException {

  BSHCastExpression jjtn000 = new BSHCastExpression(JJTCASTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_13(2147483647)) {
        jj_consume_token(LPAREN);
        Type();
        jj_consume_token(RPAREN);
        UnaryExpression();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LPAREN:
          jj_consume_token(LPAREN);
          Type();
          jj_consume_token(RPAREN);
          UnaryExpressionNotPlusMinus();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void PrimaryExpression() throws ParseException {

  BSHPrimaryExpression jjtn000 = new BSHPrimaryExpression(JJTPRIMARYEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      PrimaryPrefix();
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case LBRACKET:
        case DOT:
          ;
          break;
        default:
          break label_17;
        }
        PrimarySuffix();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void MethodInvocation() throws ParseException {

  BSHMethodInvocation jjtn000 = new BSHMethodInvocation(JJTMETHODINVOCATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      AmbiguousName();
      Arguments();
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
    }
  }
  final public void PrimaryPrefix() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FALSE:
    case NULL:
    case TRUE:
    case VOID:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case LONG_STRING_LITERAL:
      Literal();
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      break;
    case NEW:
      AllocationExpression();
      break;
    default:
      if (jj_2_14(2147483647)) {
        MethodInvocation();
      } else if (jj_2_15(2147483647)) {
        Type();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          AmbiguousName();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }
  final public void PrimarySuffix() throws ParseException {

    BSHPrimarySuffix jjtn000 = new BSHPrimarySuffix(JJTPRIMARYSUFFIX);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_16(2)) {
        jj_consume_token(DOT);
        jj_consume_token(CLASS);
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
                jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.CLASS;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.INDEX;
          break;
        case DOT:
          jj_consume_token(DOT);
          t = jj_consume_token(IDENTIFIER);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            Arguments();
            break;
          default:
            ;
          }
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.NAME;
        jjtn000.field = t.image;
          break;
        case LBRACE:
          jj_consume_token(LBRACE);
          Expression();
          jj_consume_token(RBRACE);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
        jjtn000.operation = BSHPrimarySuffix.PROPERTY;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void Literal() throws ParseException {

    BSHLiteral jjtn000 = new BSHLiteral(JJTLITERAL);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);Token x;
    boolean b;
    String literal;
    char ch;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        x = jj_consume_token(INTEGER_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'l' || ch == 'L')
    {
        literal = literal.substring(0,literal.length()-1);
                try {
                jjtn000.value = new Primitive( parseLong(literal) );
                } catch ( NumberFormatException e ) {
                        {if (true) throw createParseException( e.getMessage(), e );}
                }
    }
    else
                try {
                jjtn000.value = new Primitive( parseInt(literal) );
                } catch ( NumberFormatException e ) {
                        {if (true) throw createParseException( e.getMessage(), e );}
                }
        break;
      case FLOATING_POINT_LITERAL:
        x = jj_consume_token(FLOATING_POINT_LITERAL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
    literal = x.image;
    ch = literal.charAt(literal.length()-1);
    if(ch == 'f' || ch == 'F')
    {
        literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Float( literal ).floatValue() );
    }
    else
    {
        if(ch == 'd' || ch == 'D')
            literal = literal.substring(0,literal.length()-1);
        jjtn000.value = new Primitive( new Double( literal ).doubleValue() );
    }
        break;
      case CHARACTER_LITERAL:
        x = jj_consume_token(CHARACTER_LITERAL);
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                            jjtreeCloseNodeScope(jjtn000);
                try {
                jjtn000.charSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw createParseException("Error parsing character: "+x.image, e);}
                }
        break;
      case STRING_LITERAL:
        x = jj_consume_token(STRING_LITERAL);
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                         jjtreeCloseNodeScope(jjtn000);
                try {
                        jjtn000.stringSetup( x.image.substring(1, x.image.length() - 1) );
                } catch ( Exception e ) {
                        {if (true) throw createParseException("Error parsing string: "+x.image, e);}
                }
        break;
      case LONG_STRING_LITERAL:
        x = jj_consume_token(LONG_STRING_LITERAL);
                              jjtree.closeNodeScope(jjtn000, true);
                              jjtc000 = false;
                              jjtreeCloseNodeScope(jjtn000);
                try {
                        jjtn000.value = x.image.substring(3, x.image.length() - 3);
                } catch ( Exception e ) {
                        {if (true) throw createParseException("Error parsing long string: "+x.image, e);}
                }
        break;
      case FALSE:
      case TRUE:
        b = BooleanLiteral();
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                          jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = new Primitive( b );
        break;
      case NULL:
        NullLiteral();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.NULL;
        break;
      case VOID:
        VoidLiteral();
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtreeCloseNodeScope(jjtn000);
    jjtn000.value = Primitive.VOID;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public boolean BooleanLiteral() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRUE:
      jj_consume_token(TRUE);
           {if (true) return true;}
      break;
    case FALSE:
      jj_consume_token(FALSE);
            {if (true) return false;}
      break;
    default:
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }
  final public void NullLiteral() throws ParseException {
    jj_consume_token(NULL);
  }
  final public void VoidLiteral() throws ParseException {
    jj_consume_token(VOID);
  }
  final public void Arguments() throws ParseException {

  BSHArguments jjtn000 = new BSHArguments(JJTARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ArgumentList();
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void ArgumentList() throws ParseException {
    Expression();
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        break label_18;
      }
      jj_consume_token(COMMA);
      Expression();
    }
  }
  final public void TypeArguments() throws ParseException {
    jj_consume_token(LT);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(GT);
  }
  final public void AllocationExpression() throws ParseException {

  BSHAllocationExpression jjtn000 = new BSHAllocationExpression(JJTALLOCATIONEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_18(2)) {
        jj_consume_token(NEW);
        PrimitiveType();
        ArrayDimensions();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NEW:
          jj_consume_token(NEW);
          AmbiguousName();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LT:
            TypeArguments();
            break;
          default:
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LBRACKET:
            ArrayDimensions();
            break;
          case LPAREN:
            Arguments();
            if (jj_2_17(2)) {
              Block();
            } else {
              ;
            }
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ArrayDimensions() throws ParseException {

  BSHArrayDimensions jjtn000 = new BSHArrayDimensions(JJTARRAYDIMENSIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      if (jj_2_21(2)) {
        label_19:
        while (true) {
          jj_consume_token(LBRACKET);
          Expression();
          jj_consume_token(RBRACKET);
                                        jjtn000.addDefinedDimension();
          if (jj_2_19(2)) {
            ;
          } else {
            break label_19;
          }
        }
        label_20:
        while (true) {
          if (jj_2_20(2)) {
            ;
          } else {
            break label_20;
          }
          jj_consume_token(LBRACKET);
          jj_consume_token(RBRACKET);
                           jjtn000.addUndefinedDimension();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          label_21:
          while (true) {
            jj_consume_token(LBRACKET);
            jj_consume_token(RBRACKET);
              jjtn000.addUndefinedDimension();
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LBRACKET:
              ;
              break;
            default:
              break label_21;
            }
          }
          ArrayInitializer();
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void Statement() throws ParseException {
    if (jj_2_22(2)) {
      LabeledStatement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
        Block();
        break;
      case SEMICOLON:
        EmptyStatement();
        break;
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        StatementExpression();
        jj_consume_token(SEMICOLON);
        break;
      case SWITCH:
        SwitchStatement();
        break;
      case IF:
        IfStatement();
        break;
      case WHILE:
        WhileStatement();
        break;
      case DO:
        DoStatement();
        break;
      default:
        if (isRegularForStatement()) {
          ForStatement();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FOR:
            EnhancedForStatement();
            break;
          case BREAK:
            BreakStatement();
            break;
          case CONTINUE:
            ContinueStatement();
            break;
          case RETURN:
            ReturnStatement();
            break;
          case SYNCHRONIZED:
            SynchronizedStatement();
            break;
          case THROW:
            ThrowStatement();
            break;
          case TRY:
            TryStatement();
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }
  final public void LabeledStatement() throws ParseException {
    jj_consume_token(IDENTIFIER);
    jj_consume_token(COLON);
    Statement();
  }
  final public void Block() throws ParseException {

  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(LBRACE);
      label_22:
      while (true) {
        if (jj_2_23(1)) {
          ;
        } else {
          break label_22;
        }
        BlockStatement();
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void BlockStatement() throws ParseException {
    if (jj_2_24(2147483647)) {
      ClassDeclaration();
    } else if (jj_2_25(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_26(2147483647)) {
      MethodDeclaration();
    } else if (jj_2_27(2147483647)) {
      TypedVariableDeclaration();
      jj_consume_token(SEMICOLON);
    } else if (jj_2_28(1)) {
      Statement();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IMPORT:
      case STATIC:
        ImportDeclaration();
        break;
      case PACKAGE:
        PackageDeclaration();
        break;
      case FORMAL_COMMENT:
        FormalComment();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }
  final public void FormalComment() throws ParseException {

        BSHFormalComment jjtn000 = new BSHFormalComment(JJTFORMALCOMMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(FORMAL_COMMENT);
                              jjtree.closeNodeScope(jjtn000,  retainComments);
                              jjtc000 = false;
                              jjtreeCloseNodeScope(jjtn000);
                jjtn000.text=t.image;
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000,  retainComments);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void EmptyStatement() throws ParseException {
    jj_consume_token(SEMICOLON);
  }
  final public void StatementExpression() throws ParseException {
    Expression();
  }
  final public void SwitchStatement() throws ParseException {

  BSHSwitchStatement jjtn000 = new BSHSwitchStatement(JJTSWITCHSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SWITCH);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(LBRACE);
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CASE:
        case _DEFAULT:
          ;
          break;
        default:
          break label_23;
        }
        SwitchLabel();
        label_24:
        while (true) {
          if (jj_2_29(1)) {
            ;
          } else {
            break label_24;
          }
          BlockStatement();
        }
      }
      jj_consume_token(RBRACE);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void SwitchLabel() throws ParseException {

  BSHSwitchLabel jjtn000 = new BSHSwitchLabel(JJTSWITCHLABEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CASE:
        jj_consume_token(CASE);
        Expression();
        jj_consume_token(COLON);
        break;
      case _DEFAULT:
        jj_consume_token(_DEFAULT);
        jj_consume_token(COLON);
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.isDefault = true;
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void IfStatement() throws ParseException {

  BSHIfStatement jjtn000 = new BSHIfStatement(JJTIFSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(IF);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        Statement();
        break;
      default:
        ;
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void WhileStatement() throws ParseException {

  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void DoStatement() throws ParseException {

  BSHWhileStatement jjtn000 = new BSHWhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(DO);
      Statement();
      jj_consume_token(WHILE);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      jj_consume_token(SEMICOLON);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
          jjtn000.isDoStatement=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForStatement() throws ParseException {

  BSHForStatement jjtn000 = new BSHForStatement(JJTFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      jj_consume_token(FOR);
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ABSTRACT:
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FINAL:
      case FLOAT:
      case INT:
      case LONG:
      case NATIVE:
      case NEW:
      case NULL:
      case PRIVATE:
      case PROTECTED:
      case PUBLIC:
      case SHORT:
      case STATIC:
      case STRICTFP:
      case SYNCHRONIZED:
      case TRANSIENT:
      case TRUE:
      case VOID:
      case VOLATILE:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ForInit();
                          jjtn000.hasForInit=true;
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
                         jjtn000.hasExpression=true;
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        ForUpdate();
                        jjtn000.hasForUpdate=true;
        break;
      default:
        ;
      }
      jj_consume_token(RPAREN);
      Statement();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }

  final public void EnhancedForStatement() throws ParseException {

  BSHEnhancedForStatement jjtn000 = new BSHEnhancedForStatement(JJTENHANCEDFORSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);Token t = null;
    try {
      if (jj_2_30(4)) {
        jj_consume_token(FOR);
        jj_consume_token(LPAREN);
        t = jj_consume_token(IDENTIFIER);
        jj_consume_token(COLON);
        Expression();
        jj_consume_token(RPAREN);
        Statement();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.varName = t.image;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FOR:
          jj_consume_token(FOR);
          jj_consume_token(LPAREN);
          Type();
          t = jj_consume_token(IDENTIFIER);
          jj_consume_token(COLON);
          Expression();
          jj_consume_token(RPAREN);
          Statement();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                  jjtreeCloseNodeScope(jjtn000);
                  jjtn000.varName = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForInit() throws ParseException {
  Token t = null;
    if (jj_2_31(2147483647)) {
      TypedVariableDeclaration();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        StatementExpressionList();
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void TypedVariableDeclaration() throws ParseException {

        BSHTypedVariableDeclaration jjtn000 = new BSHTypedVariableDeclaration(JJTTYPEDVARIABLEDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);Token t = null;
        Modifiers mods;
    try {
      mods = Modifiers(Modifiers.FIELD, false);
      Type();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        TypeArguments();
        break;
      default:
        ;
      }
      VariableDeclarator();
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_25;
        }
        jj_consume_token(COMMA);
        VariableDeclarator();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        jjtn000.modifiers = mods;
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  final public void StatementExpressionList() throws ParseException {

  BSHStatementExpressionList jjtn000 = new BSHStatementExpressionList(JJTSTATEMENTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      StatementExpression();
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          break label_26;
        }
        jj_consume_token(COMMA);
        StatementExpression();
      }
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ForUpdate() throws ParseException {
    StatementExpressionList();
  }
  final public void BreakStatement() throws ParseException {

  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(BREAK);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                                 jjtreeCloseNodeScope(jjtn000);
                                 jjtn000.kind = BREAK;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ContinueStatement() throws ParseException {

  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(CONTINUE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                    jjtree.closeNodeScope(jjtn000, true);
                                    jjtc000 = false;
                                    jjtreeCloseNodeScope(jjtn000);
                                    jjtn000.kind = CONTINUE;
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ReturnStatement() throws ParseException {

  BSHReturnStatement jjtn000 = new BSHReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(RETURN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case BYTE:
      case CHAR:
      case DOUBLE:
      case FALSE:
      case FLOAT:
      case INT:
      case LONG:
      case NEW:
      case NULL:
      case SHORT:
      case TRUE:
      case VOID:
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
      case LONG_STRING_LITERAL:
      case IDENTIFIER:
      case LPAREN:
      case BANG:
      case TILDE:
      case INCR:
      case DECR:
      case PLUS:
      case MINUS:
        Expression();
        break;
      default:
        ;
      }
      jj_consume_token(SEMICOLON);
                                  jjtree.closeNodeScope(jjtn000, true);
                                  jjtc000 = false;
                                  jjtreeCloseNodeScope(jjtn000);
                                  jjtn000.kind = RETURN;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void SynchronizedStatement() throws ParseException {

  BSHBlock jjtn000 = new BSHBlock(JJTBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(SYNCHRONIZED);
      jj_consume_token(LPAREN);
      Expression();
      jj_consume_token(RPAREN);
      Block();
                                                jjtree.closeNodeScope(jjtn000, true);
                                                jjtc000 = false;
                                                jjtreeCloseNodeScope(jjtn000);
                jjtn000.isSynchronized=true;
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void ThrowStatement() throws ParseException {

  BSHThrowStatement jjtn000 = new BSHThrowStatement(JJTTHROWSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
    try {
      jj_consume_token(THROW);
      Expression();
      jj_consume_token(SEMICOLON);
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
    }
  }
  final public void TryStatement() throws ParseException {

  BSHTryStatement jjtn000 = new BSHTryStatement(JJTTRYSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);boolean closed = false;
    try {
      jj_consume_token(TRY);
      Block();
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CATCH:
          ;
          break;
        default:
          break label_27;
        }
        jj_consume_token(CATCH);
        jj_consume_token(LPAREN);
        FormalParameter();
        jj_consume_token(RPAREN);
        Block();
                                                      closed = true;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FINALLY:
        jj_consume_token(FINALLY);
        Block();
                              closed = true;
        break;
      default:
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
                if ( !closed ) {if (true) throw generateParseException();}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
    }
  }
  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
  }
  private boolean jj_3R_115() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3_8() {
    if (jj_3R_34()) return true;
    if (jj_3R_35()) return true;
    return false;
  }
  private boolean jj_3R_110() {
    if (jj_3R_34()) return true;
    if (jj_3R_35()) return true;
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_150() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_29()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) return true;
    }
    return false;
  }
  private boolean jj_3R_59() {
    if (jj_scan_token(LT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(GT)) return true;
    return false;
  }
  private boolean jj_3_18() {
    if (jj_scan_token(NEW)) return true;
    if (jj_3R_37()) return true;
    if (jj_3R_155()) return true;
    return false;
  }
  private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) return true;
    }
    return false;
  }
  private boolean jj_3R_74() {
    if (jj_3R_111()) return true;
    return false;
  }
  private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    return false;
  }
  private boolean jj_3R_73() {
    if (jj_3R_110()) return true;
    return false;
  }
  private boolean jj_3R_152() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_138() {
    if (jj_3R_40()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_152()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_109() {
    if (jj_3R_138()) return true;
    return false;
  }
  private boolean jj_3R_79() {
    if (jj_3R_29()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_115()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_72() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_109()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  private boolean jj_3_7() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_29() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_161() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }
  private boolean jj_3R_160() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }
  private boolean jj_3R_154() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) return true;
    }
    return false;
  }
  private boolean jj_3R_71() {
    if (jj_scan_token(DOUBLE)) return true;
    return false;
  }
  private boolean jj_3R_70() {
    if (jj_scan_token(FLOAT)) return true;
    return false;
  }
  private boolean jj_3R_69() {
    if (jj_scan_token(LONG)) return true;
    return false;
  }
  private boolean jj_3R_68() {
    if (jj_scan_token(INT)) return true;
    return false;
  }
  private boolean jj_3R_112() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_67() {
    if (jj_scan_token(SHORT)) return true;
    return false;
  }
  private boolean jj_3R_58() {
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3R_149() {
    if (jj_scan_token(57)) return true;
    return false;
  }
  private boolean jj_3R_66() {
    if (jj_scan_token(BYTE)) return true;
    return false;
  }
  private boolean jj_3R_65() {
    if (jj_scan_token(CHAR)) return true;
    return false;
  }
  private boolean jj_3R_64() {
    if (jj_scan_token(BOOLEAN)) return true;
    return false;
  }
  private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_148() {
    if (jj_scan_token(41)) return true;
    return false;
  }
  private boolean jj_3R_147() {
    if (jj_3R_154()) return true;
    return false;
  }
  private boolean jj_3R_77() {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_112()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    }
    return false;
  }
  private boolean jj_3R_76() {
    if (jj_scan_token(VOID)) return true;
    return false;
  }
  private boolean jj_3_6() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_146() {
    if (jj_scan_token(LONG_STRING_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_33() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_57() {
    if (jj_3R_37()) return true;
    return false;
  }
  private boolean jj_3R_114() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_113()) return true;
    return false;
  }
  private boolean jj_3R_197() {
    if (jj_scan_token(FINALLY)) return true;
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_196() {
    if (jj_scan_token(CATCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_113()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_145() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_6()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_128() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_39()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_196()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_197()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_144() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_184() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_183()) return true;
    return false;
  }
  private boolean jj_3_4() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_31()) return true;
    return false;
  }
  private boolean jj_3R_140() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3_5() {
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_78() {
    if (jj_3R_113()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_114()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_113() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) return true;
    }
    return false;
  }
  private boolean jj_3R_127() {
    if (jj_scan_token(THROW)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_44() {
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_78()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  private boolean jj_3R_195() {
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_169() {
    if (jj_3R_31()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_143() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_126() {
    if (jj_scan_token(SYNCHRONIZED)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_100() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_169()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(80)) jj_scanpos = xsp;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  private boolean jj_3R_30() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(STAR)) return true;
    return false;
  }
  private boolean jj_3R_217() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_116()) return true;
    return false;
  }
  private boolean jj_3R_187() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_31()) return true;
    return false;
  }
  private boolean jj_3R_125() {
    if (jj_scan_token(RETURN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_195()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_56() {
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_55() {
    if (jj_3R_100()) return true;
    return false;
  }
  private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) return true;
    }
    return false;
  }
  private boolean jj_3R_124() {
    if (jj_scan_token(CONTINUE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_123() {
    if (jj_scan_token(BREAK)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(70)) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_142() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }
  private boolean jj_3R_133() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_151() {
    if (jj_3R_72()) return true;
    return false;
  }
  private boolean jj_3R_183() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_187()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_202() {
    if (jj_3R_212()) return true;
    return false;
  }
  private boolean jj_3R_182() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_108() {
    if (jj_3R_133()) return true;
    return false;
  }
  private boolean jj_3R_212() {
    if (jj_3R_116()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_217()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_96() {
    if (jj_3R_42()) return true;
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_182()) jj_scanpos = xsp;
    if (jj_3R_183()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_184()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_132() {
    if (jj_scan_token(IMPORT)) return true;
    if (jj_scan_token(STAR)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_137() {
    if (jj_scan_token(LBRACE)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  private boolean jj_3R_136() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_151()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3_31() {
    if (jj_3R_42()) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3_3() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(48)) jj_scanpos = xsp;
    if (jj_scan_token(IMPORT)) return true;
    if (jj_3R_29()) return true;
    xsp = jj_scanpos;
    if (jj_3R_30()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_97() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) return true;
    }
    return false;
  }
  private boolean jj_3R_135() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_98() {
    if (jj_scan_token(PACKAGE)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3_2() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }
  private boolean jj_3R_211() {
    if (jj_3R_212()) return true;
    return false;
  }
  private boolean jj_3R_181() {
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3_16() {
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }
  private boolean jj_3R_107() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) return true;
    }
    }
    }
    return false;
  }
  private boolean jj_3R_180() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_79()) return true;
    return false;
  }
  private boolean jj_3R_210() {
    if (jj_3R_96()) return true;
    return false;
  }
  private boolean jj_3R_201() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_210()) {
    jj_scanpos = xsp;
    if (jj_3R_211()) return true;
    }
    return false;
  }
  private boolean jj_3_15() {
    if (jj_3R_32()) return true;
    if (jj_scan_token(DOT)) return true;
    if (jj_scan_token(CLASS)) return true;
    return false;
  }
  private boolean jj_3_14() {
    if (jj_3R_38()) return true;
    return false;
  }
  private boolean jj_3R_130() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_141() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_131() {
    if (jj_3R_43()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_95() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    }
    if (jj_3R_44()) return true;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) return true;
    }
    return false;
  }
  private boolean jj_3R_191() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_106() {
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3_30() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_122() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) return true;
    }
    return false;
  }
  private boolean jj_3R_105() {
    if (jj_3R_32()) return true;
    return false;
  }
  private boolean jj_3R_192() {
    if (jj_3R_201()) return true;
    return false;
  }
  private boolean jj_3R_61() {
    if (jj_3R_107()) return true;
    return false;
  }
  private boolean jj_3R_129() {
    if (jj_scan_token(INTERFACE)) return true;
    return false;
  }
  private boolean jj_3R_104() {
    if (jj_3R_38()) return true;
    return false;
  }
  private boolean jj_3R_194() {
    if (jj_3R_202()) return true;
    return false;
  }
  private boolean jj_3R_193() {
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_103() {
    if (jj_3R_134()) return true;
    return false;
  }
  private boolean jj_3R_102() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }
  private boolean jj_3R_179() {
    if (jj_scan_token(IMPLEMENTS)) return true;
    if (jj_3R_79()) return true;
    return false;
  }
  private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) return true;
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_101() {
    if (jj_3R_133()) return true;
    return false;
  }
  private boolean jj_3R_178() {
    if (jj_scan_token(EXTENDS)) return true;
    if (jj_3R_29()) return true;
    return false;
  }
  private boolean jj_3R_38() {
    if (jj_3R_29()) return true;
    if (jj_3R_72()) return true;
    return false;
  }
  private boolean jj_3R_121() {
    if (jj_scan_token(FOR)) return true;
    if (jj_scan_token(LPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_193()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    xsp = jj_scanpos;
    if (jj_3R_194()) jj_scanpos = xsp;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_94() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_3R_129()) return true;
    }
    if (jj_scan_token(IDENTIFIER)) return true;
    xsp = jj_scanpos;
    if (jj_3R_178()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_179()) jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3_13() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_37()) return true;
    return false;
  }
  private boolean jj_3R_34() {
    if (jj_3R_60()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_61()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_120() {
    if (jj_scan_token(DO)) return true;
    if (jj_3R_47()) return true;
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_224() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_215()) return true;
    return false;
  }
  private boolean jj_3R_223() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_198()) return true;
    return false;
  }
  private boolean jj_3R_221() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) return true;
    }
    return false;
  }
  private boolean jj_3_12() {
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    return false;
  }
  private boolean jj_3R_119() {
    if (jj_scan_token(WHILE)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_226() {
    if (jj_3R_34()) return true;
    return false;
  }
  private boolean jj_3_11() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }
  private boolean jj_3_29() {
    if (jj_3R_28()) return true;
    return false;
  }
  private boolean jj_3R_118() {
    if (jj_scan_token(IF)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_3R_47()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_191()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_225() {
    if (jj_3R_34()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_scan_token(102)) return true;
    }
    return false;
  }
  private boolean jj_3R_222() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_225()) {
    jj_scanpos = xsp;
    if (jj_3R_226()) return true;
    }
    return false;
  }
  private boolean jj_3R_75() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_63() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(RPAREN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(73)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3R_209() {
    if (jj_scan_token(_DEFAULT)) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }
  private boolean jj_3R_62() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_29()) return true;
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3_9() {
    if (jj_3R_36()) return true;
    return false;
  }
  private boolean jj_3R_208() {
    if (jj_scan_token(CASE)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }
  private boolean jj_3R_200() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) return true;
    }
    return false;
  }
  private boolean jj_3R_42() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_75()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    }
    }
    return false;
  }
  private boolean jj_3_10() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_37()) return true;
    return false;
  }
  private boolean jj_3R_190() {
    if (jj_3R_200()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_29()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_220() {
    if (jj_3R_222()) return true;
    return false;
  }
  private boolean jj_3R_117() {
    if (jj_scan_token(SWITCH)) return true;
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RPAREN)) return true;
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_190()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  private boolean jj_3R_219() {
    if (jj_3R_221()) return true;
    return false;
  }
  private boolean jj_3R_218() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) return true;
    }
    if (jj_3R_198()) return true;
    return false;
  }
  private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) return true;
    }
    }
    return false;
  }
  private boolean jj_3R_46() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_214() {
    if (jj_scan_token(DECR)) return true;
    if (jj_3R_34()) return true;
    return false;
  }
  private boolean jj_3_1() {
    if (jj_3R_28()) return true;
    return false;
  }
  private boolean jj_3R_216() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(105)) {
    jj_scanpos = xsp;
    if (jj_scan_token(106)) {
    jj_scanpos = xsp;
    if (jj_scan_token(112)) return true;
    }
    }
    if (jj_3R_198()) return true;
    return false;
  }
  private boolean jj_3R_213() {
    if (jj_scan_token(INCR)) return true;
    if (jj_3R_34()) return true;
    return false;
  }
  private boolean jj_3R_45() {
    if (jj_scan_token(THROWS)) return true;
    if (jj_3R_79()) return true;
    return false;
  }
  private boolean jj_3R_116() {
    if (jj_3R_40()) return true;
    return false;
  }
  private boolean jj_3R_206() {
    if (jj_3R_215()) return true;
    return false;
  }
  private boolean jj_3R_205() {
    if (jj_3R_214()) return true;
    return false;
  }
  private boolean jj_3R_204() {
    if (jj_3R_213()) return true;
    return false;
  }
  private boolean jj_3R_203() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) return true;
    }
    if (jj_3R_198()) return true;
    return false;
  }
  private boolean jj_3R_198() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) {
    jj_scanpos = xsp;
    if (jj_3R_206()) return true;
    }
    }
    }
    return false;
  }
  private boolean jj_3R_99() {
    if (jj_scan_token(FORMAL_COMMENT)) return true;
    return false;
  }
  private boolean jj_3R_188() {
    if (jj_3R_198()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_216()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_207() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(103)) {
    jj_scanpos = xsp;
    if (jj_scan_token(104)) return true;
    }
    if (jj_3R_188()) return true;
    return false;
  }
  private boolean jj_3R_185() {
    if (jj_3R_188()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_207()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_54() {
    if (jj_3R_99()) return true;
    return false;
  }
  private boolean jj_3_27() {
    if (jj_3R_42()) return true;
    if (jj_3R_32()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) jj_scanpos = xsp;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }
  private boolean jj_3R_53() {
    if (jj_3R_98()) return true;
    return false;
  }
  private boolean jj_3R_199() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(113)) {
    jj_scanpos = xsp;
    if (jj_scan_token(114)) {
    jj_scanpos = xsp;
    if (jj_scan_token(115)) {
    jj_scanpos = xsp;
    if (jj_scan_token(116)) {
    jj_scanpos = xsp;
    if (jj_scan_token(117)) {
    jj_scanpos = xsp;
    if (jj_scan_token(118)) return true;
    }
    }
    }
    }
    }
    if (jj_3R_185()) return true;
    return false;
  }
  private boolean jj_3R_52() {
    if (jj_3R_97()) return true;
    return false;
  }
  private boolean jj_3_26() {
    if (jj_3R_42()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_3R_44()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_45()) jj_scanpos = xsp;
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }
  private boolean jj_3R_177() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) return true;
    }
    if (jj_3R_172()) return true;
    return false;
  }
  private boolean jj_3R_176() {
    if (jj_3R_185()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_199()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3_28() {
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3_25() {
    if (jj_3R_42()) return true;
    if (jj_3R_43()) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(LPAREN)) return true;
    return false;
  }
  private boolean jj_3R_51() {
    if (jj_3R_96()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_189() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) {
    jj_scanpos = xsp;
    if (jj_scan_token(83)) {
    jj_scanpos = xsp;
    if (jj_scan_token(84)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) {
    jj_scanpos = xsp;
    if (jj_scan_token(93)) {
    jj_scanpos = xsp;
    if (jj_scan_token(94)) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    }
    }
    }
    }
    }
    }
    if (jj_3R_176()) return true;
    return false;
  }
  private boolean jj_3_24() {
    if (jj_3R_42()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) return true;
    }
    return false;
  }
  private boolean jj_3R_174() {
    if (jj_3R_176()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_189()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_50() {
    if (jj_3R_95()) return true;
    return false;
  }
  private boolean jj_3R_186() {
    if (jj_scan_token(INSTANCEOF)) return true;
    if (jj_3R_32()) return true;
    return false;
  }
  private boolean jj_3R_49() {
    if (jj_3R_95()) return true;
    return false;
  }
  private boolean jj_3R_172() {
    if (jj_3R_174()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_48() {
    if (jj_3R_94()) return true;
    return false;
  }
  private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) {
    jj_scanpos = xsp;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3_23() {
    if (jj_3R_28()) return true;
    return false;
  }
  private boolean jj_3R_173() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_167()) return true;
    return false;
  }
  private boolean jj_3R_170() {
    if (jj_3R_172()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_177()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_39() {
    if (jj_scan_token(LBRACE)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACE)) return true;
    return false;
  }
  private boolean jj_3R_175() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(107)) {
    jj_scanpos = xsp;
    if (jj_scan_token(108)) return true;
    }
    if (jj_3R_170()) return true;
    return false;
  }
  private boolean jj_3R_41() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_47()) return true;
    return false;
  }
  private boolean jj_3R_167() {
    if (jj_3R_170()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_175()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_93() {
    if (jj_3R_128()) return true;
    return false;
  }
  private boolean jj_3R_92() {
    if (jj_3R_127()) return true;
    return false;
  }
  private boolean jj_3R_164() {
    if (jj_3R_167()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_173()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_91() {
    if (jj_3R_126()) return true;
    return false;
  }
  private boolean jj_3R_90() {
    if (jj_3R_125()) return true;
    return false;
  }
  private boolean jj_3R_162() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_111()) return true;
    return false;
  }
  private boolean jj_3R_89() {
    if (jj_3R_124()) return true;
    return false;
  }
  private boolean jj_3R_171() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(109)) {
    jj_scanpos = xsp;
    if (jj_scan_token(110)) return true;
    }
    if (jj_3R_164()) return true;
    return false;
  }
  private boolean jj_3R_88() {
    if (jj_3R_123()) return true;
    return false;
  }
  private boolean jj_3R_159() {
    if (jj_3R_164()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_171()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_87() {
    if (jj_3R_122()) return true;
    return false;
  }
  private boolean jj_3R_86() {
    if (jj_3R_121()) return true;
    return false;
  }
  private boolean jj_3R_85() {
    if (jj_3R_120()) return true;
    return false;
  }
  private boolean jj_3R_168() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(99)) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) return true;
    }
    if (jj_3R_159()) return true;
    return false;
  }
  private boolean jj_3R_84() {
    if (jj_3R_119()) return true;
    return false;
  }
  private boolean jj_3R_153() {
    if (jj_3R_159()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_168()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_83() {
    if (jj_3R_118()) return true;
    return false;
  }
  private boolean jj_3R_82() {
    if (jj_3R_117()) return true;
    return false;
  }
  private boolean jj_3R_81() {
    if (jj_3R_116()) return true;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }
  private boolean jj_3R_165() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(97)) {
    jj_scanpos = xsp;
    if (jj_scan_token(98)) return true;
    }
    if (jj_3R_153()) return true;
    return false;
  }
  private boolean jj_3_17() {
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_80() {
    if (jj_3R_39()) return true;
    return false;
  }
  private boolean jj_3R_139() {
    if (jj_3R_153()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_165()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_47() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_81()) {
    jj_scanpos = xsp;
    if (jj_3R_82()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    jj_lookingAhead = true;
    jj_semLA = isRegularForStatement();
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3_22() {
    if (jj_3R_41()) return true;
    return false;
  }
  private boolean jj_3R_156() {
    if (jj_3R_59()) return true;
    return false;
  }
  private boolean jj_3R_111() {
    if (jj_3R_139()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_162()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_166() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_158() {
    if (jj_3R_72()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) jj_scanpos = xsp;
    return false;
  }
  private boolean jj_3R_163() {
    Token xsp;
    if (jj_3R_166()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_166()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_100()) return true;
    return false;
  }
  private boolean jj_3_20() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_157() {
    if (jj_3R_155()) return true;
    return false;
  }
  private boolean jj_3_19() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_40()) return true;
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }
  private boolean jj_3R_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(82)) {
    jj_scanpos = xsp;
    if (jj_scan_token(121)) {
    jj_scanpos = xsp;
    if (jj_scan_token(122)) {
    jj_scanpos = xsp;
    if (jj_scan_token(128)) {
    jj_scanpos = xsp;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(120)) {
    jj_scanpos = xsp;
    if (jj_scan_token(123)) {
    jj_scanpos = xsp;
    if (jj_scan_token(127)) {
    jj_scanpos = xsp;
    if (jj_scan_token(125)) {
    jj_scanpos = xsp;
    if (jj_scan_token(129)) {
    jj_scanpos = xsp;
    if (jj_scan_token(130)) {
    jj_scanpos = xsp;
    if (jj_scan_token(131)) {
    jj_scanpos = xsp;
    if (jj_scan_token(132)) {
    jj_scanpos = xsp;
    if (jj_scan_token(133)) {
    jj_scanpos = xsp;
    if (jj_scan_token(134)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }
  private boolean jj_3_21() {
    Token xsp;
    if (jj_3_19()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_20()) { jj_scanpos = xsp; break; }
    }
    return false;
  }
  private boolean jj_3R_155() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) return true;
    }
    return false;
  }

  public ParserTokenManager token_source;
  JavaCharStream jj_input_stream;

  public Token token;

  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;

  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;

  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }

  public Parser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }

  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  public Parser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  public Parser(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }
  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }
  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }
  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }
}
package bsh;
public class ParseException extends Exception {

  private static final long serialVersionUID = 1L;

  public ParseException(Token currentTokenVal,
                        int[][] expectedTokenSequencesVal,
                        String[] tokenImageVal
                       )
  {
    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
  }

  public ParseException() {
    super();
  }

  public ParseException(String message) {
    super(message);
  }

  public Token currentToken;

  public int[][] expectedTokenSequences;

  public String[] tokenImage;

  private static String initialise(Token currentToken,
                           int[][] expectedTokenSequences,
                           String[] tokenImage) {
    String eol = System.getProperty("line.separator", "\n");
    StringBuffer expected = new StringBuffer();
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
        expected.append("...");
      }
      expected.append(eol).append("    ");
    }
    String retval = "Encountered \"";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0) retval += " ";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += " " + tokenImage[tok.kind];
      retval += " \"";
      retval += add_escapes(tok.image);
      retval += " \"";
      tok = tok.next;
    }
    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
    retval += "." + eol;
    if (expectedTokenSequences.length == 1) {
      retval += "Was expecting:" + eol + "    ";
    } else {
      retval += "Was expecting one of:" + eol + "    ";
    }
    retval += expected.toString();
    return retval;
  }

  protected String eol = System.getProperty("line.separator", "\n");

  static String add_escapes(String str) {
      StringBuffer retval = new StringBuffer();
      char ch;
      for (int i = 0; i < str.length(); i++) {
        switch (str.charAt(i))
        {
           case 0 :
              continue;
           case '\b':
              retval.append("\\b");
              continue;
           case '\t':
              retval.append("\\t");
              continue;
           case '\n':
              retval.append("\\n");
              continue;
           case '\f':
              retval.append("\\f");
              continue;
           case '\r':
              retval.append("\\r");
              continue;
           case '\"':
              retval.append("\\\"");
              continue;
           case '\'':
              retval.append("\\\'");
              continue;
           case '\\':
              retval.append("\\\\");
              continue;
           default:
              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                 String s = "0000" + Integer.toString(ch, 16);
                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
              } else {
                 retval.append(ch);
              }
              continue;
        }
      }
      return retval.toString();
   }
}
package bsh;
import javax.script.ScriptEngine;
import java.util.List;
import java.util.Arrays;

public class BshScriptEngineFactory implements javax.script.ScriptEngineFactory {

	final List<String> extensions = Arrays.asList("bsh", "java");
	final List<String> mimeTypes = Arrays.asList("application/x-beanshell", "application/x-bsh", "application/x-java-source");
	final List<String> names = Arrays.asList("beanshell", "bsh", "java");
	public String getEngineName() {
		return "BeanShell Engine";
	}
	public String getEngineVersion() {
		return Interpreter.VERSION;
	}
	public List<String> getExtensions() {
		return extensions;
	}
	public List<String> getMimeTypes() {
		return mimeTypes;
	}
	public List<String> getNames() {
		return names;
	}
	public String getLanguageName() {
		return "BeanShell";
	}
	public String getLanguageVersion() {
		return bsh.Interpreter.VERSION + "";
	}
	public Object getParameter(String param) {
		if (param.equals(ScriptEngine.ENGINE)) {
			return getEngineName();
		}
		if (param.equals(ScriptEngine.ENGINE_VERSION)) {
			return getEngineVersion();
		}
		if (param.equals(ScriptEngine.NAME)) {
			return getEngineName();
		}
		if (param.equals(ScriptEngine.LANGUAGE)) {
			return getLanguageName();
		}
		if (param.equals(ScriptEngine.LANGUAGE_VERSION)) {
			return getLanguageVersion();
		}
		if (param.equals("THREADING")) {
			return "MULTITHREADED";
		}
		return null;
	}
	public String getMethodCallSyntax(String objectName, String methodName, String... args) {

		StringBuffer sb = new StringBuffer();
		if (objectName != null) {
			sb.append(objectName).append('.');
		}
		sb.append(methodName).append('(');
		if (args.length > 0) {
			sb.append(' ');
		}
		for (int i = 0; i < args.length; i++) {
			sb.append((args[i] == null) ? "null" : args[i]).append(i < (args.length - 1) ? ", " : " ");
		}
		sb.append(")");
		return sb.toString();
	}
	public String getOutputStatement(String message) {
		return "print( \"" + message + "\" );";
	}
	public String getProgram(String... statements) {
		StringBuffer sb = new StringBuffer();
		for (final String statement : statements) {
			sb.append(statement);
			if ( ! statement.endsWith(";")) {
				sb.append(";");
			}
			sb.append("\n");
		}
		return sb.toString();
	}

	public ScriptEngine getScriptEngine() {
		return new BshScriptEngine();
	}

}
package bsh;
import javax.script.AbstractScriptEngine;
import javax.script.Bindings;
import javax.script.Compilable;
import javax.script.CompiledScript;
import javax.script.Invocable;
import javax.script.ScriptContext;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineFactory;
import javax.script.ScriptException;
import javax.script.SimpleBindings;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BshScriptEngine extends AbstractScriptEngine implements Compilable, Invocable {

	static final String engineNameSpaceKey = "org_beanshell_engine_namespace";
	private BshScriptEngineFactory factory;
	private bsh.Interpreter interpreter;
	public BshScriptEngine() {
		this(null);
	}
	public BshScriptEngine(BshScriptEngineFactory factory) {
		this.factory = factory;
		getInterpreter(); 
	}
	protected Interpreter getInterpreter() {
		if (interpreter == null) {
			this.interpreter = new bsh.Interpreter();
			interpreter.setNameSpace(null); 
		}
		return interpreter;
	}
	public Object eval(String script, ScriptContext scriptContext) throws ScriptException {
		return evalSource(script, scriptContext);
	}
	public Object eval(Reader reader, ScriptContext scriptContext) throws ScriptException {
		return evalSource(reader, scriptContext);
	}

	private Object evalSource(Object source, ScriptContext scriptContext) throws ScriptException {
		bsh.NameSpace contextNameSpace = getEngineNameSpace(scriptContext);
		Interpreter bsh = getInterpreter();
		bsh.setNameSpace(contextNameSpace);
		bsh.setOut(toPrintStream(scriptContext.getWriter()));
		bsh.setErr(toPrintStream(scriptContext.getErrorWriter()));
		try {
			if (source instanceof Reader) {
				return bsh.eval((Reader) source);
			} else {
				return bsh.eval((String) source);
			}

		} catch (TargetError e) {

			ScriptException se = new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
			se.initCause(e.getTarget());
			throw se;
		} catch (EvalError e) {

			throw new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (InterpreterError e) {

			throw new ScriptException(e.toString());
		}
	}
	private PrintStream toPrintStream(final Writer writer) {

		return new PrintStream(new WriterOutputStream(writer));
	}

	private static NameSpace getEngineNameSpace(ScriptContext scriptContext) {
		NameSpace ns = (NameSpace) scriptContext.getAttribute(engineNameSpaceKey, ScriptContext.ENGINE_SCOPE);
		if (ns == null) {

			Map<String, Object> engineView = new ScriptContextEngineView(scriptContext);
			ns = new ExternalNameSpace(null, "javax_script_context", engineView);
			scriptContext.setAttribute(engineNameSpaceKey, ns, ScriptContext.ENGINE_SCOPE);
		}
		return ns;
	}
	public Bindings createBindings() {
		return new SimpleBindings();
	}
	public ScriptEngineFactory getFactory() {
		if (factory == null) {
			factory = new BshScriptEngineFactory();
		}
		return factory;
	}

	public CompiledScript compile(String script) throws ScriptException {
		try {
			final PreparsedScript preparsed = new PreparsedScript(script);
			return new CompiledScript() {
				@Override
				public Object eval(ScriptContext context) throws ScriptException {
					final HashMap<String, Object> map = new HashMap<String, Object>();
					final List<Integer> scopes = new ArrayList<Integer>(context.getScopes());
					Collections.sort(scopes); 
					Collections.reverse(scopes); 
					for (final Integer scope : scopes) {
						map.putAll(context.getBindings(scope));
					}
					preparsed.setOut(toPrintStream(context.getWriter()));
					preparsed.setErr(toPrintStream(context.getErrorWriter()));
					try {
						return preparsed.invoke(map);
					} catch (final EvalError e) {
						throw constructScriptException(e);
					}
				}
				@Override
				public ScriptEngine getEngine() {
					return BshScriptEngine.this;
				}
			};
		} catch (final EvalError e) {
			throw constructScriptException(e);
		}
	}
	private ScriptException constructScriptException(final EvalError e) {
		return new ScriptException(e.getMessage(), e.getErrorSourceFile(), e.getErrorLineNumber());
	}
	private static String convertToString(Reader reader) throws IOException {
		final StringBuffer buffer = new StringBuffer(64);
		char[] cb = new char[64];
		int len;
		while ((len = reader.read(cb)) != -1) {
			buffer.append(cb, 0, len);
		}
		return buffer.toString();
	}

	public CompiledScript compile(Reader script) throws ScriptException {
		try {
			return compile(convertToString(script));
		} catch (IOException e) {
			throw new ScriptException(e);
		}
	}

	public Object invokeMethod(Object thiz, String name, Object... args) throws ScriptException, NoSuchMethodException {
		if (!(thiz instanceof bsh.This)) {
			throw new ScriptException("Illegal objec type: " + thiz.getClass());
		}
		bsh.This bshObject = (bsh.This) thiz;
		try {
			return bshObject.invokeMethod(name, args);

		} catch (TargetError e) {

			ScriptException se = new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
			se.initCause(e.getTarget());
			throw se;
		} catch (EvalError e) {

			throw new ScriptException(e.toString(), e.getErrorSourceFile(), e.getErrorLineNumber());
		} catch (InterpreterError e) {

			throw new ScriptException(e.toString());
		}
	}

	public Object invokeFunction(String name, Object... args) throws ScriptException, NoSuchMethodException {
		return invokeMethod(getGlobal(), name, args);
	}

	public <T> T getInterface(Class<T> clasz) {
		return clasz.cast(getGlobal().getInterface(clasz));
	}

	public <T> T getInterface(Object thiz, Class<T> clasz) {
		if (!(thiz instanceof bsh.This)) {
			throw new IllegalArgumentException("invalid object type: " + thiz.getClass());
		}
		bsh.This bshThis = (bsh.This) thiz;
		return clasz.cast(bshThis.getInterface(clasz));
	}
	private bsh.This getGlobal() {

		return getEngineNameSpace(getContext()).getThis(getInterpreter());
	}

	class WriterOutputStream extends OutputStream {
		Writer writer;
		WriterOutputStream(Writer writer) {
			this.writer = writer;
		}
		public void write(int b) throws IOException {
			writer.write(b);
		}
		public void flush() throws IOException {
			writer.flush();
		}
		public void close() throws IOException {
			writer.close();
		}
	}
}
package bsh;
import bsh.classpath.ClassManagerImpl;
import bsh.interpreter.BshEvaluatingVisitor;
import java.io.*;
import java.util.Map;

public class PreparsedScript {
	private final BshMethod _method;
	private final Interpreter _interpreter;
	public PreparsedScript(final String source) throws EvalError {
		this(source, getDefaultClassLoader());
	}
	private static ClassLoader getDefaultClassLoader() {
		ClassLoader cl = null;
		try {
			cl = Thread.currentThread().getContextClassLoader();
		} catch (final SecurityException e) {

		}
		if (cl == null) {
			cl = PreparsedScript.class.getClassLoader();
		}
		if (cl != null) {
			return cl;
		}
		return ClassLoader.getSystemClassLoader();
	}
	public PreparsedScript(final String source, final ClassLoader classLoader) throws EvalError {
		final ClassManagerImpl classManager = new ClassManagerImpl();
		classManager.setClassLoader(classLoader);
		final NameSpace nameSpace = new NameSpace(classManager, "global");
		_interpreter = new Interpreter(new StringReader(""), System.out, System.err, false, nameSpace, null, null);
		try {
			final This callable = (This) _interpreter.eval("__execute() { " + source + "\n" + "}\n" + "return this;");
			_method = callable.getNameSpace().getMethod("__execute", new Class[0], false);
		} catch (final UtilEvalError e) {
			throw new IllegalStateException(e);
		}
	}
	public Object invoke(final Map<String, ?> context) throws EvalError {
		final NameSpace nameSpace = new NameSpace(_interpreter.getClassManager(), "BeanshellExecutable");
		nameSpace.setParent(_interpreter.getNameSpace());
		final BshMethod method = new BshMethod(_method.getName(), _method.getReturnType(), _method.getParameterNames(), _method.getParameterTypes(), _method.methodBody, nameSpace, _method.getModifiers());
		for (final Map.Entry<String, ?> entry : context.entrySet()) {
			try {
				nameSpace.setVariable(entry.getKey(), entry.getValue(), false);
			} catch (final UtilEvalError e) {
				throw new EvalError("cannot set variable '" + entry.getKey() + '\'', null, null, e);
			}
		}
		final Object result = method.invoke(new Object[0], new BshEvaluatingVisitor(null, _interpreter));
		if (result instanceof Primitive) {
			if (( (Primitive) result).getType() == Void.TYPE) {
				return null;
			}
			return ( (Primitive) result).getValue();
		}
		return result;
	}
	public void setOut(final PrintStream value) {
		_interpreter.setOut(value);
	}
	public void setErr(final PrintStream value) {
		_interpreter.setErr(value);
	}
}
package com.jitlogic.zorka.core;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import com.jitlogic.zorka.common.ZorkaAgent;
import com.jitlogic.zorka.common.ZorkaService;
import com.jitlogic.zorka.common.stats.AgentDiagnostics;
import com.jitlogic.zorka.core.util.ObjectDumper;
import com.jitlogic.zorka.common.util.ZorkaUtil;
import bsh.EvalError;
import bsh.Interpreter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import static com.jitlogic.zorka.core.AgentConfigProps.SCRIPTS_DIR_PROP;
import static com.jitlogic.zorka.core.AgentConfigProps.SCRIPTS_PROP;

public class ZorkaBshAgent implements ZorkaAgent, ZorkaService {

    private final Logger log = LoggerFactory.getLogger(this.getClass());

    private Interpreter interpreter;

    private Executor connExecutor;
    private ExecutorService mainExecutor;
    private AgentConfig config;
    private long timeout;
    private boolean initialized;
    private Set<String> loadedScripts = new HashSet<String>();
    private Map<String,String> probeMap = new ConcurrentHashMap<String, String>();

    public ZorkaBshAgent(Executor connExecutor, ExecutorService mainExecutor,
                         long timeout, AgentConfig config) {
        this.interpreter = new Interpreter();
        this.connExecutor = connExecutor;
        this.mainExecutor = mainExecutor;
        this.timeout = timeout;
        this.config = config;
        probeSetup();
    }

    public void put(String name, Object obj) {
        try {
            interpreter.set(name, obj);
        } catch (EvalError e) {
            log.error("Error adding module '{}' to global namespace", name, e);
        }
    }
    public Object get(String name) {
        try {
            return interpreter.get(name);
        } catch (EvalError e) {
            return null;
        }
    }

    @Override
    public String query(String expr) {
        try {
            return "" + interpreter.eval(expr); 
        } catch (EvalError e) {
            log.error("Error evaluating '{}': ", expr, e);
            return ObjectDumper.errorDump(e);
        }
    }

    public Object eval(String expr) throws EvalError {
        return interpreter.eval(expr);
    }

    public void exec(String expr, ZorkaCallback callback) {
        log.debug("Processing request BSH expression: {}", expr);
        ZorkaBshWorker worker = new ZorkaBshWorker(mainExecutor, timeout, this, expr, callback);
        connExecutor.execute(worker);
    }

    public synchronized String loadScript(String script) {
        String path = ZorkaUtil.path(config.stringCfg(SCRIPTS_DIR_PROP, null), script);
        Reader rdr = null;
        try {
            if (new File(path).canRead()) {
                log.info("Executing script: {}", path);
                interpreter.source(path);
                loadedScripts.add(script);
            } else {
                InputStream is = getClass().getResourceAsStream(
                        "/com/jitlogic/zorka/scripts"+(script.startsWith("/") ? "" : "/")+script);
                if (is != null) {
                    log.info("Executing internal script: {}", script);
                    rdr = new InputStreamReader(is);
                    interpreter.eval(rdr, interpreter.getNameSpace(), script);
                    loadedScripts.add(script);
                } else {
                    log.error("Cannot find script: {}", script);
                }
            }
            return "OK";
        } catch (Exception e) {
            log.error("Error loading script {}", script, e);
            AgentDiagnostics.inc(AgentDiagnostics.CONFIG_ERRORS);
            return "Error: " + e.getMessage();
        } catch (EvalError e) {
            log.error("Error executing script {}", script, e);
            AgentDiagnostics.inc(AgentDiagnostics.CONFIG_ERRORS);
            return "Error: " + e.getMessage();
        } finally {
            if (rdr != null) {
                try {
                    rdr.close();
                } catch (IOException e) {
                    log.error("Error closing script {}", script, e);
                }
            }
        }
    }
    public synchronized String require(String script) {
        if (!loadedScripts.contains(script)) {
            return loadScript(script);
        } else {
            if (log.isDebugEnabled()) {
                log.debug("Skipping already loaded script: {}", script);
            }
            return "Already loaded.";
        }
    }
    public Set<String> getLoadedScripts() {
        return loadedScripts;
    }
    public Map<String,String> getProbeMap() {
        return probeMap;
    }
    public void probeSetup() {
        Properties props = config.getProperties();
        for (String s : props.stringPropertyNames()) {
            if (s.startsWith("auto.")) {
                probeMap.put(s.substring(5), config.get(s));
            }
        }
    }
    public synchronized void probe(String className) {
        int nhits = 0;
        for (Map.Entry<String,String> e : probeMap.entrySet()) {
            if (className.startsWith(e.getKey())) {
                require(e.getValue().trim());
                nhits++;
            }
        }
        if (nhits > 0) {
            Iterator<Map.Entry<String, String>> iter = probeMap.entrySet().iterator();
            while (iter.hasNext()) {
                if (loadedScripts.contains(iter.next().getValue())) {
                    iter.remove();
                }
            }
        }
    }

    public void loadScripts() {
        String scriptsDir = config.stringCfg(SCRIPTS_DIR_PROP, null);
        if (scriptsDir == null) {
            log.error("Scripts directory not set. Internal error ?!?");
            return;
        }
        List<String> scripts = config.listCfg(SCRIPTS_PROP);
        if (scripts != null) {
            for (String script : scripts) {
                require(script);
            }
        }
    }
    public synchronized void reloadScripts() {
        loadedScripts.clear();
        AgentDiagnostics.clear(AgentDiagnostics.CONFIG_ERRORS);
        loadScripts();
    }
    public void initialize() {
        loadScripts();
        initialized = true;
    }
    public boolean isInitialized() {
        return initialized;
    }
    public void restart() {
        interpreter = new Interpreter();
        put("PROP", AgentConfigProps.PROPS);
    }
    @Override
    public void shutdown() {
    }
}
package bsh;

public class Console  
{
	public static void main( String args[] ) {
		if ( !Capabilities.classExists( "bsh.util.Util" ) )
			System.out.println("Can't find the BeanShell utilities...");
		if ( Capabilities.haveSwing() ) 
		{

			try {
				new Interpreter().eval("desktop()");
			} catch ( EvalError e ) {
				System.err.println("Couldn't start desktop: "+e);
			}
		} else {
			System.err.println(
				"Can't find javax.swing package: "
			+" An AWT based Console is available but not built by default.");

		}
	}
}