package it.feio.android.omninotes;
import static it.feio.android.omninotes.helpers.AppVersionHelper.isAppUpdated;
import static it.feio.android.omninotes.helpers.AppVersionHelper.updateAppVersionInPreferences;
import static it.feio.android.omninotes.helpers.BuildHelper.isDebugBuild;
import static it.feio.android.omninotes.helpers.ChangelogHelper.showChangelog;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_NOTIFICATION_CLICK;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_RESTART_APP;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SEND_AND_EXIT;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_START_APP;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_GOOGLE_NOW;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_KEY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.view.MenuItem;
import android.view.View;
import android.widget.Toast;
import androidx.annotation.Nullable;
import androidx.appcompat.app.ActionBarDrawerToggle;
import androidx.appcompat.widget.Toolbar;
import androidx.core.view.GravityCompat;
import androidx.drawerlayout.widget.DrawerLayout;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Crouton;
import de.keyboardsurfer.android.widget.crouton.Style;
import it.feio.android.omninotes.async.UpdateWidgetsTask;
import it.feio.android.omninotes.async.bus.NotificationsGrantedEvent;
import it.feio.android.omninotes.async.bus.PasswordRemovedEvent;
import it.feio.android.omninotes.async.bus.SwitchFragmentEvent;
import it.feio.android.omninotes.async.notes.NoteProcessorDelete;
import it.feio.android.omninotes.databinding.ActivityMainBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.NotesHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.intro.IntroActivity;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.utils.FileProviderHelper;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.SystemHelper;
import it.feio.android.pixlui.links.UrlCompleter;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import lombok.Getter;
import lombok.Setter;
public class MainActivity extends BaseActivity implements
    SharedPreferences.OnSharedPreferenceChangeListener {
  private boolean isPasswordAccepted = false;
  public static final String FRAGMENT_DRAWER_TAG = "fragment_drawer";
  public static final String FRAGMENT_LIST_TAG = "fragment_list";
  public static final String FRAGMENT_DETAIL_TAG = "fragment_detail";
  public static final String FRAGMENT_SKETCH_TAG = "fragment_sketch";
  @Getter @Setter
  private Uri sketchUri;
  boolean prefsChanged = false;
  private FragmentManager mFragmentManager;
  ActivityMainBinding binding;
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setTheme(R.style.OmniNotesTheme_ApiSpec);
    binding = ActivityMainBinding.inflate(getLayoutInflater());
    View view = binding.getRoot();
    setContentView(view);
    EventBus.getDefault().register(this);
    Prefs.getPreferences().registerOnSharedPreferenceChangeListener(this);
    new NotificationsHelper(this).askToEnableNotifications(this);
    initUI();
  }
  @Override
  protected void onPostCreate(@Nullable Bundle savedInstanceState) {
    super.onPostCreate(savedInstanceState);
    if (!launchIntroIfRequired() && isAppUpdated(getApplicationContext()) && !isDebugBuild()) {
      showChangelogAndUpdateCurrentVersion();
    }
  }
  private void showChangelogAndUpdateCurrentVersion() {
    showChangelog(this);
    updateAppVersionInPreferences(getApplicationContext());
  }
  private boolean launchIntroIfRequired() {
    if (IntroActivity.mustRun()) {
      startActivity(new Intent(getApplicationContext(), IntroActivity.class));
      return true;
    }
    return false;
  }
  @Override
  protected void onResume() {
    super.onResume();
    if (isPasswordAccepted) {
      init();
    } else {
      checkPassword();
    }
  }
  @Override
  protected void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
  }
  private void initUI() {
    setSupportActionBar(binding.toolbar.toolbar);
    getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    getSupportActionBar().setHomeButtonEnabled(true);
  }
  private void checkPassword() {
    if (Prefs.getString(PREF_PASSWORD, null) != null
        && Prefs.getBoolean("settings_password_access", false)) {
      PasswordHelper.requestPassword(this, passwordConfirmed -> {
        switch (passwordConfirmed) {
          case SUCCEED:
            init();
            break;
          case FAIL:
            finish();
            break;
          case RESTORE:
            PasswordHelper.resetPassword(this);
        }
      });
    } else {
      init();
    }
  }
  public void onEvent(PasswordRemovedEvent passwordRemovedEvent) {
    showMessage(R.string.password_successfully_removed, ONStyle.ALERT);
    init();
  }
  public void onEvent(NotificationsGrantedEvent notificationsGrantedEvent) {
    if (!notificationsGrantedEvent.granted) {
      showToast(getString(R.string.denied_notifications_permission), Toast.LENGTH_LONG);
    }
  }
  private void init() {
    isPasswordAccepted = true;
    getFragmentManagerInstance();
    NavigationDrawerFragment mNavigationDrawerFragment = (NavigationDrawerFragment) getFragmentManagerInstance()
        .findFragmentById(R.id.navigation_drawer);
    if (mNavigationDrawerFragment == null) {
      FragmentTransaction fragmentTransaction = getFragmentManagerInstance().beginTransaction();
      fragmentTransaction.replace(R.id.navigation_drawer, new NavigationDrawerFragment(),
          FRAGMENT_DRAWER_TAG).commit();
    }
    if (getFragmentManagerInstance().findFragmentByTag(FRAGMENT_LIST_TAG) == null) {
      FragmentTransaction fragmentTransaction = getFragmentManagerInstance().beginTransaction();
      fragmentTransaction.add(R.id.fragment_container, new ListFragment(), FRAGMENT_LIST_TAG)
          .commit();
    }
    handleIntents();
  }
  private FragmentManager getFragmentManagerInstance() {
    if (mFragmentManager == null) {
      mFragmentManager = getSupportFragmentManager();
    }
    return mFragmentManager;
  }
  @Override
  protected void onNewIntent(Intent intent) {
    if (intent.getAction() == null) {
      intent.setAction(ACTION_START_APP);
    }
    super.onNewIntent(intent);
    setIntent(intent);
    handleIntents();
    LogDelegate.d("onNewIntent");
  }
  public MenuItem getSearchMenuItem() {
    Fragment f = checkFragmentInstance(R.id.fragment_container, ListFragment.class);
    if (f != null) {
      return ((ListFragment) f).getSearchMenuItem();
    } else {
      return null;
    }
  }
  public void editTag(Category tag) {
    Fragment f = checkFragmentInstance(R.id.fragment_container, ListFragment.class);
    if (f != null) {
      ((ListFragment) f).editCategory(tag);
    }
  }
  public void initNotesList(Intent intent) {
    if (intent != null) {
      Fragment searchTagFragment = startSearchView();
      new Handler(getMainLooper()).post(() -> ((ListFragment) searchTagFragment).initNotesList(intent));
    }
  }
  public Fragment startSearchView() {
    FragmentTransaction transaction = getFragmentManagerInstance().beginTransaction();
    animateTransition(transaction, TRANSITION_HORIZONTAL);
    ListFragment mListFragment = new ListFragment();
    transaction.replace(R.id.fragment_container, mListFragment, FRAGMENT_LIST_TAG).addToBackStack
        (FRAGMENT_DETAIL_TAG).commit();
    Bundle args = new Bundle();
    args.putBoolean("setSearchFocus", true);
    mListFragment.setArguments(args);
    return mListFragment;
  }
  public void commitPending() {
    Fragment f = checkFragmentInstance(R.id.fragment_container, ListFragment.class);
    if (f != null) {
      ((ListFragment) f).commitPending();
    }
  }
  private Fragment checkFragmentInstance(int id, Object instanceClass) {
    Fragment result = null;
    Fragment fragment = getFragmentManagerInstance().findFragmentById(id);
    if (fragment != null && instanceClass.equals(fragment.getClass())) {
      result = fragment;
    }
    return result;
  }
  @Override
  public void onBackPressed() {
    Fragment f = checkFragmentInstance(R.id.fragment_container, SketchFragment.class);
    if (f != null) {
      ((SketchFragment) f).save();
      setRequestedOrientation(
          ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
      getFragmentManagerInstance().popBackStack();
      return;
    }
    f = checkFragmentInstance(R.id.fragment_container, DetailFragment.class);
    if (f != null) {
      var detailDragment = (DetailFragment) f;
      detailDragment.goBack = true;
      detailDragment.saveAndExit();
      return;
    }
    f = checkFragmentInstance(R.id.fragment_container, ListFragment.class);
    if (f != null) {
      if (Prefs.getBoolean("settings_navdrawer_on_exit", false) && getDrawerLayout() != null &&
          !getDrawerLayout().isDrawerOpen(GravityCompat.START)) {
        getDrawerLayout().openDrawer(GravityCompat.START);
      } else if (!Prefs.getBoolean("settings_navdrawer_on_exit", false) && getDrawerLayout() != null
          &&
          getDrawerLayout().isDrawerOpen(GravityCompat.START)) {
        getDrawerLayout().closeDrawer(GravityCompat.START);
      } else {
        if (!((ListFragment) f).closeFab()) {
          isPasswordAccepted = false;
          super.onBackPressed();
        }
      }
      return;
    }
    super.onBackPressed();
  }
  @Override
  public void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putString("navigationTmp", navigationTmp);
  }
  @Override
  protected void onPause() {
    super.onPause();
    Crouton.cancelAllCroutons();
  }
  public DrawerLayout getDrawerLayout() {
    return binding.drawerLayout;
  }
  public ActionBarDrawerToggle getDrawerToggle() {
    if (getFragmentManagerInstance().findFragmentById(R.id.navigation_drawer) != null) {
      return ((NavigationDrawerFragment) getFragmentManagerInstance().findFragmentById(
          R.id.navigation_drawer)).mDrawerToggle;
    } else {
      return null;
    }
  }
  public void finishActionMode() {
    ListFragment fragment = (ListFragment) getFragmentManagerInstance()
        .findFragmentByTag(FRAGMENT_LIST_TAG);
    if (fragment != null) {
      fragment.finishActionMode();
    }
  }
  Toolbar getToolbar() {
    return binding.toolbar.toolbar;
  }
  private void handleIntents() {
    Intent i = getIntent();
    if (i.getAction() == null) {
      return;
    }
    if (ACTION_RESTART_APP.equals(i.getAction())) {
      SystemHelper.restartApp();
    }
    if (receivedIntent(i)) {
      Note note = i.getParcelableExtra(INTENT_NOTE);
      if (note == null) {
        note = DbHelper.getInstance().getNote(i.getIntExtra(INTENT_KEY, 0));
      }
      if (note != null && noteAlreadyOpened(note)) {
        return;
      }
      if (note == null) {
        note = new Note();
      }
      switchToDetail(note);
      return;
    }
    if (ACTION_SEND_AND_EXIT.equals(i.getAction())) {
      saveAndExit(i);
      return;
    }
    if (Intent.ACTION_VIEW.equals(i.getAction()) && i.getDataString()
        .startsWith(UrlCompleter.HASHTAG_SCHEME)) {
      switchToList();
      return;
    }
    if (Intent.ACTION_VIEW.equals(i.getAction()) && i.getData() != null) {
      Long id = Long.valueOf(Uri.parse(i.getDataString()).getQueryParameter("id"));
      Note note = DbHelper.getInstance().getNote(id);
      if (note == null) {
        showMessage(R.string.note_doesnt_exist, ONStyle.ALERT);
        return;
      }
      switchToDetail(note);
      return;
    }
    if (ACTION_SHORTCUT_WIDGET.equals(i.getAction())) {
      switchToDetail(new Note());
      return;
    }
  }
  private void saveAndExit(Intent i) {
    Note note = new Note();
    note.setTitle(i.getStringExtra(Intent.EXTRA_SUBJECT));
    note.setContent(i.getStringExtra(Intent.EXTRA_TEXT));
    DbHelper.getInstance().updateNote(note, true);
    showToast(getString(R.string.note_updated), Toast.LENGTH_SHORT);
    finish();
  }
  private boolean receivedIntent(Intent i) {
    return ACTION_SHORTCUT.equals(i.getAction())
        || ACTION_NOTIFICATION_CLICK.equals(i.getAction())
        || ACTION_WIDGET.equals(i.getAction())
        || ACTION_WIDGET_TAKE_PHOTO.equals(i.getAction())
        || ((Intent.ACTION_SEND.equals(i.getAction())
        || Intent.ACTION_SEND_MULTIPLE.equals(i.getAction())
        || INTENT_GOOGLE_NOW.equals(i.getAction())
        || Intent.ACTION_PROCESS_TEXT.equals(i.getAction()))
        && i.getType() != null)
        || i.getAction().contains(ACTION_NOTIFICATION_CLICK);
  }
  private boolean noteAlreadyOpened(Note note) {
    DetailFragment detailFragment = (DetailFragment) getFragmentManagerInstance().findFragmentByTag(
        FRAGMENT_DETAIL_TAG);
    return detailFragment != null && NotesHelper.haveSameId(note, detailFragment.getCurrentNote());
  }
  public void switchToList() {
    FragmentTransaction transaction = getFragmentManagerInstance().beginTransaction();
    animateTransition(transaction, TRANSITION_HORIZONTAL);
    ListFragment mListFragment = new ListFragment();
    transaction.replace(R.id.fragment_container, mListFragment, FRAGMENT_LIST_TAG).addToBackStack
        (FRAGMENT_DETAIL_TAG).commitAllowingStateLoss();
    if (getDrawerToggle() != null) {
      getDrawerToggle().setDrawerIndicatorEnabled(false);
    }
    getFragmentManagerInstance().getFragments();
    EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.PARENT));
  }
  public void switchToDetail(Note note) {
    FragmentTransaction transaction = getFragmentManagerInstance().beginTransaction();
    animateTransition(transaction, TRANSITION_HORIZONTAL);
    DetailFragment mDetailFragment = new DetailFragment();
    Bundle b = new Bundle();
    b.putParcelable(INTENT_NOTE, note);
    mDetailFragment.setArguments(b);
    if (getFragmentManagerInstance().findFragmentByTag(FRAGMENT_DETAIL_TAG) == null) {
      transaction.replace(R.id.fragment_container, mDetailFragment, FRAGMENT_DETAIL_TAG)
          .addToBackStack(FRAGMENT_LIST_TAG)
          .commitAllowingStateLoss();
    } else {
      getFragmentManagerInstance().popBackStackImmediate();
      transaction.replace(R.id.fragment_container, mDetailFragment, FRAGMENT_DETAIL_TAG)
          .addToBackStack(FRAGMENT_DETAIL_TAG)
          .commitAllowingStateLoss();
    }
  }
  public void shareNote(Note note) {
    Intent shareIntent = new Intent();
    if (note.getAttachmentsList().isEmpty()) {
      shareIntent.setAction(Intent.ACTION_SEND);
      shareIntent.setType("text/plain");
    } else if (note.getAttachmentsList().size() == 1) {
      Attachment attachment = note.getAttachmentsList().get(0);
      Uri shareableAttachmentUri = getShareableAttachmentUri(attachment);
      if (shareableAttachmentUri != null) {
        shareIntent.setAction(Intent.ACTION_SEND);
        shareIntent.setType(attachment.getMime_type());
        shareIntent.putExtra(Intent.EXTRA_STREAM, shareableAttachmentUri);
      }
    } else if (note.getAttachmentsList().size() > 1) {
      shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);
      ArrayList<Uri> uris = new ArrayList<>();
      HashMap<String, Boolean> mimeTypes = new HashMap<>();
      for (Attachment attachment : note.getAttachmentsList()) {
        Uri shareableAttachmentUri = getShareableAttachmentUri(attachment);
        if (shareableAttachmentUri != null) {
          uris.add(shareableAttachmentUri);
          mimeTypes.put(attachment.getMime_type(), true);
        }
      }
      if (mimeTypes.size() > 1) {
        shareIntent.setType("*
  public void deleteNote(Note note) {
    new NoteProcessorDelete(Collections.singletonList(note)).process();
    BaseActivity.notifyAppWidgets(this);
    LogDelegate.d("Deleted permanently note with ID '" + note.get_id() + "'");
  }
  public void updateWidgets() {
    new UpdateWidgetsTask(getApplicationContext())
        .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
  public void showMessage(int messageId, Style style) {
    showMessage(getString(messageId), style);
  }
  public void showMessage(String message, Style style) {
    runOnUiThread(
        () -> Crouton.makeText(this, message, style, binding.croutonHandle.croutonHandle).show());
  }
  @Override
  public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
    prefsChanged = true;
  }
}
package it.feio.android.omninotes.async.bus;
import it.feio.android.omninotes.helpers.LogDelegate;
public class PasswordRemovedEvent {
  public PasswordRemovedEvent() {
    LogDelegate.d(this.getClass().getName());
  }
}
package it.feio.android.omninotes.models;
import android.os.Parcel;
import android.os.Parcelable;
import it.feio.android.omninotes.commons.models.BaseAttachment;
import it.feio.android.omninotes.commons.models.BaseCategory;
import it.feio.android.omninotes.commons.models.BaseNote;
import java.util.ArrayList;
import java.util.List;
public class Note extends BaseNote implements Parcelable {
  public static final Parcelable.Creator<Note> CREATOR = new Parcelable.Creator<>() {
    public Note createFromParcel(Parcel in) {
      return new Note(in);
    }
    public Note[] newArray(int size) {
      return new Note[size];
    }
  };
  private boolean passwordChecked = false;
  public Note() {
    super();
  }
  public Note(Long creation, Long lastModification, String title, String content, Integer archived,
      Integer trashed, String alarm, String recurrenceRule, Integer reminderFired, String latitude,
      String longitude,
      Category
          category, Integer locked, Integer checklist) {
    super(creation, lastModification, title, content, archived, trashed, alarm, reminderFired,
        recurrenceRule,
        latitude,
        longitude, category, locked, checklist);
  }
  public Note(Note note) {
    super(note);
    setPasswordChecked(note.isPasswordChecked());
  }
  private Note(Parcel in) {
    setCreation(in.readString());
    setLastModification(in.readString());
    setTitle(in.readString());
    setContent(in.readString());
    setArchived(in.readInt());
    setTrashed(in.readInt());
    setAlarm(in.readString());
    setReminderFired(in.readInt());
    setRecurrenceRule(in.readString());
    setLatitude(in.readString());
    setLongitude(in.readString());
    setAddress(in.readString());
    super.setCategory(in.readParcelable(Category.class.getClassLoader()));
    setLocked(in.readInt());
    setChecklist(in.readInt());
    in.readList(getAttachmentsList(), Attachment.class.getClassLoader());
  }
  public List<Attachment> getAttachmentsList() {
    return (List<Attachment>) super.getAttachmentsList();
  }
  public void setAttachmentsList(ArrayList<Attachment> attachmentsList) {
    super.setAttachmentsList(attachmentsList);
  }
  public void addAttachment(Attachment attachment) {
    List<Attachment> attachmentsList = ((List<Attachment>) super.getAttachmentsList());
    attachmentsList.add(attachment);
    setAttachmentsList(attachmentsList);
  }
  public void removeAttachment(Attachment attachment) {
    List<Attachment> attachmentsList = ((List<Attachment>) super.getAttachmentsList());
    attachmentsList.remove(attachment);
    setAttachmentsList(attachmentsList);
  }
  public List<Attachment> getAttachmentsListOld() {
    return (List<Attachment>) super.getAttachmentsListOld();
  }
  public void setAttachmentsListOld(ArrayList<Attachment> attachmentsListOld) {
    super.setAttachmentsListOld(attachmentsListOld);
  }
  public boolean isPasswordChecked() {
    return passwordChecked;
  }
  public void setPasswordChecked(boolean passwordChecked) {
    this.passwordChecked = passwordChecked;
  }
  @Override
  public Category getCategory() {
    try {
      return (Category) super.getCategory();
    } catch (ClassCastException e) {
      return new Category(super.getCategory());
    }
  }
  public void setCategory(Category category) {
    if (category != null && category.getClass().equals(BaseCategory.class)) {
      setCategory(new Category(category));
    }
    super.setCategory(category);
  }
  @Override
  public void buildFromJson(String jsonNote) {
    super.buildFromJson(jsonNote);
    List<Attachment> attachments = new ArrayList<>();
    for (BaseAttachment attachment : getAttachmentsList()) {
      attachments.add(new Attachment(attachment));
    }
    setAttachmentsList(attachments);
  }
  @Override
  public int describeContents() {
    return 0;
  }
  @Override
  public void writeToParcel(Parcel parcel, int flags) {
    parcel.writeString(String.valueOf(getCreation()));
    parcel.writeString(String.valueOf(getLastModification()));
    parcel.writeString(getTitle());
    parcel.writeString(getContent());
    parcel.writeInt(isArchived() ? 1 : 0);
    parcel.writeInt(isTrashed() ? 1 : 0);
    parcel.writeString(getAlarm());
    parcel.writeInt(isReminderFired() ? 1 : 0);
    parcel.writeString(getRecurrenceRule());
    parcel.writeString(String.valueOf(getLatitude()));
    parcel.writeString(String.valueOf(getLongitude()));
    parcel.writeString(getAddress());
    parcel.writeParcelable(getCategory(), 0);
    parcel.writeInt(isLocked() ? 1 : 0);
    parcel.writeInt(isChecklist() ? 1 : 0);
    parcel.writeList(getAttachmentsList());
  }
}
package it.feio.android.omninotes.utils;
import static android.content.Context.CLIPBOARD_SERVICE;
import android.app.Activity;
import android.content.Context;
import it.feio.android.omninotes.helpers.LogDelegate;
import java.io.Closeable;
import java.io.IOException;
import lombok.experimental.UtilityClass;
@UtilityClass
public class SystemHelper {
  public static void restartApp() {
    System.exit(0);
  }
  public static void closeCloseable(Closeable... closeables) {
    for (Closeable closeable : closeables) {
      if (closeable != null) {
        try {
          closeable.close();
        } catch (IOException e) {
          LogDelegate.w("Can't close " + closeable, e);
        }
      }
    }
  }
  public static void copyToClipboard(Context context, String text) {
    android.content.ClipboardManager clipboard = (android.content.ClipboardManager) context
        .getSystemService(CLIPBOARD_SERVICE);
    android.content.ClipData clip = android.content.ClipData.newPlainText("text label", text);
    clipboard.setPrimaryClip(clip);
  }
}
package it.feio.android.omninotes;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_UPDATE_DASHCLOCK;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.appwidget.AppWidgetManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.Typeface;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuInflater;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import androidx.fragment.app.FragmentTransaction;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.helpers.LanguageHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.PasswordValidator;
import it.feio.android.omninotes.utils.Navigation;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.widget.ListWidgetProvider;
import java.util.Arrays;
import java.util.List;
@SuppressLint("Registered")
public class BaseActivity extends AppCompatActivity {
  protected static final int TRANSITION_VERTICAL = 0;
  protected static final int TRANSITION_HORIZONTAL = 1;
  protected String navigation;
  protected String navigationTmp; 
  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.menu_list, menu);
    return super.onCreateOptionsMenu(menu);
  }
  @Override
  protected void attachBaseContext(Context newBase) {
    Context context = LanguageHelper.updateLanguage(newBase, null);
    super.attachBaseContext(context);
  }
  @Override
  protected void onResume() {
    super.onResume();
    String navNotes = getResources().getStringArray(R.array.navigation_list_codes)[0];
    navigation = Prefs.getString(PREF_NAVIGATION, navNotes);
    LogDelegate.d(Prefs.getAll().toString());
  }
  protected void showToast(int resourceId, int duration) {
    showToast(getResources().getString(resourceId), duration);
  }
  protected void showToast(CharSequence text, int duration) {
    if (Prefs.getBoolean("settings_enable_info", true)) {
      Toast.makeText(getApplicationContext(), text, duration).show();
    }
  }
  public void requestPassword(final Activity mActivity, List<Note> notes,
      final PasswordValidator mPasswordValidator) {
    if (Prefs.getBoolean("settings_password_access", false)) {
      mPasswordValidator.onPasswordValidated(PasswordValidator.Result.SUCCEED);
      return;
    }
    boolean askForPassword = false;
    for (Note note : notes) {
      if (Boolean.TRUE.equals(note.isLocked())) {
        askForPassword = true;
        break;
      }
    }
    if (askForPassword) {
      PasswordHelper.requestPassword(mActivity, mPasswordValidator);
    } else {
      mPasswordValidator.onPasswordValidated(PasswordValidator.Result.SUCCEED);
    }
  }
  public boolean updateNavigation(String nav) {
    if (nav.equals(navigationTmp) || (navigationTmp == null && Navigation.getNavigationText()
        .equals(nav))) {
      return false;
    }
    Prefs.edit().putString(PREF_NAVIGATION, nav).apply();
    navigation = nav;
    navigationTmp = null;
    return true;
  }
  public static void notifyAppWidgets(Context context) {
    AppWidgetManager mgr = AppWidgetManager.getInstance(context);
    int[] ids = mgr.getAppWidgetIds(new ComponentName(context, ListWidgetProvider.class));
    LogDelegate.d("Notifies AppWidget data changed for widgets " + Arrays.toString(ids));
    mgr.notifyAppWidgetViewDataChanged(ids, R.id.widget_list);
    LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(INTENT_UPDATE_DASHCLOCK));
  }
  @SuppressLint("InlinedApi")
  protected void animateTransition(FragmentTransaction transaction, int direction) {
    if (direction == TRANSITION_HORIZONTAL) {
      transaction.setCustomAnimations(R.anim.fade_in_support, R.anim.fade_out_support,
          R.anim.fade_in_support, R.anim.fade_out_support);
    }
    if (direction == TRANSITION_VERTICAL) {
      transaction.setCustomAnimations(
          R.anim.anim_in, R.anim.anim_out, R.anim.anim_in_pop, R.anim.anim_out_pop);
    }
  }
  protected void setActionBarTitle(String title) {
    int actionBarTitle = Resources.getSystem().getIdentifier("action_bar_title", "ID", "android");
    android.widget.TextView actionBarTitleView = getWindow().findViewById(actionBarTitle);
    Typeface font = Typeface.createFromAsset(getAssets(), "fonts/Roboto-Regular.ttf");
    if (actionBarTitleView != null) {
      actionBarTitleView.setTypeface(font);
    }
    if (getSupportActionBar() != null) {
      getSupportActionBar().setTitle(title);
    }
  }
  public String getNavigationTmp() {
    return navigationTmp;
  }
  @Override
  public boolean onKeyDown(int keyCode, KeyEvent event) {
    return keyCode == KeyEvent.KEYCODE_MENU || super.onKeyDown(keyCode, event);
  }
}
package it.feio.android.omninotes;
import static android.Manifest.permission.CAMERA;
import static android.content.Context.CLIPBOARD_SERVICE;
import static android.content.Context.LAYOUT_INFLATER_SERVICE;
import static android.content.pm.PackageManager.FEATURE_CAMERA;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;
import static android.widget.Toast.LENGTH_SHORT;
import static androidx.core.view.ViewCompat.animate;
import static it.feio.android.omninotes.BaseActivity.TRANSITION_HORIZONTAL;
import static it.feio.android.omninotes.BaseActivity.TRANSITION_VERTICAL;
import static it.feio.android.omninotes.MainActivity.FRAGMENT_DETAIL_TAG;
import static it.feio.android.omninotes.MainActivity.FRAGMENT_SKETCH_TAG;
import static it.feio.android.omninotes.OmniNotes.getAppContext;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_DISMISS;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_FAB_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_MERGE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_NOTIFICATION_CLICK;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_PINNED;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_SHOW_LIST;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_CLICKED_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_IMAGES;
import static it.feio.android.omninotes.utils.ConstantsBase.GALLERY_TITLE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_GOOGLE_NOW;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_KEY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_FILES;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_SKETCH;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_SKETCH_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO_EXT;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_ATTACHMENTS_ON_BOTTOM;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_AUTO_LOCATION;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_COLORS_APP_DEFAULT;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_KEEP_CHECKED;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_KEEP_CHECKMARKS;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PRETTIFIED_DATES;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_WIDGET_PREFIX;
import static it.feio.android.omninotes.utils.ConstantsBase.SWIPE_MARGIN;
import static it.feio.android.omninotes.utils.ConstantsBase.SWIPE_OFFSET;
import static it.feio.android.omninotes.utils.ConstantsBase.THUMBNAIL_SIZE;
import static java.lang.Integer.parseInt;
import static java.lang.Long.parseLong;
import android.Manifest;
import android.Manifest.permission;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.graphics.Point;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.location.Location;
import android.media.MediaPlayer;
import android.media.MediaRecorder;
import android.media.ThumbnailUtils;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.provider.MediaStore;
import android.text.Editable;
import android.text.Selection;
import android.text.Spanned;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.view.animation.Animation;
import android.view.animation.Animation.AnimationListener;
import android.view.animation.AnimationUtils;
import android.widget.AutoCompleteTextView;
import android.widget.CheckBox;
import android.widget.ImageView;
import android.widget.Toast;
import androidx.activity.result.ActivityResultCallback;
import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.core.content.ContextCompat;
import androidx.core.util.Pair;
import androidx.drawerlayout.widget.DrawerLayout;
import androidx.fragment.app.FragmentTransaction;
import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.neopixl.pixlui.components.edittext.EditText;
import com.pixplicity.easyprefs.library.Prefs;
import com.pushbullet.android.extension.MessagingExtension;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Style;
import it.feio.android.checklistview.exceptions.ViewNotSupportedException;
import it.feio.android.checklistview.interfaces.CheckListChangedListener;
import it.feio.android.checklistview.models.CheckListView;
import it.feio.android.checklistview.models.CheckListViewItem;
import it.feio.android.checklistview.models.ChecklistManager;
import it.feio.android.omninotes.async.AttachmentTask;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import it.feio.android.omninotes.async.bus.PushbulletReplyEvent;
import it.feio.android.omninotes.async.bus.SwitchFragmentEvent;
import it.feio.android.omninotes.async.notes.NoteProcessorDelete;
import it.feio.android.omninotes.async.notes.SaveNoteTask;
import it.feio.android.omninotes.databinding.FragmentDetailBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.exceptions.checked.ContentSecurityException;
import it.feio.android.omninotes.exceptions.checked.UnhandledIntentException;
import it.feio.android.omninotes.helpers.AttachmentsHelper;
import it.feio.android.omninotes.helpers.BuildHelper;
import it.feio.android.omninotes.helpers.IntentHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.PermissionsHelper;
import it.feio.android.omninotes.helpers.TagOpenerHelper;
import it.feio.android.omninotes.helpers.date.DateHelper;
import it.feio.android.omninotes.helpers.date.RecurrenceHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationChannels.NotificationChannelNames;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.PasswordValidator.Result;
import it.feio.android.omninotes.models.Tag;
import it.feio.android.omninotes.models.adapters.AttachmentAdapter;
import it.feio.android.omninotes.models.adapters.CategoryRecyclerViewAdapter;
import it.feio.android.omninotes.models.adapters.PlacesAutoCompleteAdapter;
import it.feio.android.omninotes.models.listeners.OnAttachingFileListener;
import it.feio.android.omninotes.models.listeners.OnGeoUtilResultListener;
import it.feio.android.omninotes.models.listeners.OnReminderPickedListener;
import it.feio.android.omninotes.models.listeners.RecyclerViewItemClickSupport;
import it.feio.android.omninotes.models.views.ExpandableHeightGridView;
import it.feio.android.omninotes.utils.AlphaManager;
import it.feio.android.omninotes.utils.BitmapHelper;
import it.feio.android.omninotes.utils.Display;
import it.feio.android.omninotes.utils.FileHelper;
import it.feio.android.omninotes.utils.FileProviderHelper;
import it.feio.android.omninotes.utils.GeocodeHelper;
import it.feio.android.omninotes.utils.IntentChecker;
import it.feio.android.omninotes.utils.KeyboardUtils;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.Security;
import it.feio.android.omninotes.utils.ShortcutHelper;
import it.feio.android.omninotes.utils.StorageHelper;
import it.feio.android.omninotes.utils.TagsHelper;
import it.feio.android.omninotes.utils.TextHelper;
import it.feio.android.omninotes.utils.date.DateUtils;
import it.feio.android.omninotes.utils.date.ReminderPickers;
import it.feio.android.pixlui.links.TextLinkClickListener;
import java.io.File;
import java.io.IOException;
import java.lang.ref.WeakReference;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;
import org.apache.commons.collections4.CollectionUtils;
public class DetailFragment extends BaseFragment implements OnReminderPickedListener,
    OnTouchListener,
    OnAttachingFileListener, TextWatcher, CheckListChangedListener,
    OnGeoUtilResultListener {
  private static final int TAKE_PHOTO = 1;
  private static final int TAKE_VIDEO = 2;
  private static final int SET_PASSWORD = 3;
  private static final int SKETCH = 4;
  private static final int CATEGORY = 5;
  private static final int DETAIL = 6;
  private static final int FILES = 7;
  private FragmentDetailBinding binding;
  boolean goBack = false;
  private ExpandableHeightGridView mGridView;
  private View toggleChecklistView;
  private Uri attachmentUri;
  private AttachmentAdapter mAttachmentAdapter;
  private MaterialDialog attachmentDialog;
  private Note note;
  private Note noteTmp;
  private Note noteOriginal;
  private String recordName;
  private MediaRecorder mRecorder = null;
  private MediaPlayer mPlayer = null;
  private boolean isRecording = false;
  private View isPlayingView = null;
  private Bitmap recordingBitmap;
  private ChecklistManager mChecklistManager;
  private String exitMessage;
  private Style exitCroutonStyle = ONStyle.CONFIRM;
  private boolean afterSavedReturnsToList = true;
  private boolean showKeyboard = false;
  private boolean swiping;
  private int startSwipeX;
  private boolean orientationChanged;
  private long audioRecordingTimeStart;
  private long audioRecordingTime;
  private DetailFragment mFragment;
  private Attachment sketchEdited;
  private int contentLineCounter = 1;
  private int contentCursorPosition;
  private ArrayList<String> mergedNotesIds;
  private MainActivity mainActivity;
  private boolean activityPausing;
  TextLinkClickListener textLinkClickListener = (view, clickedString, url) -> {
      new MaterialDialog.Builder(mainActivity)
          .content(clickedString)
          .negativeColorRes(R.color.colorPrimary)
          .positiveText(R.string.open)
          .negativeText(R.string.copy)
          .onPositive((dialog, which) -> {
            try {
              Intent intent = TagOpenerHelper.openOrGetIntent(getContext(), url);
              if (intent != null) {
                mainActivity.initNotesList(intent);
              }
            } catch (UnhandledIntentException e) {
              mainActivity.showMessage(R.string.no_application_can_perform_this_action,
                  ONStyle.ALERT);
            }
          })
          .onNegative((dialog, which) -> {
            android.content.ClipboardManager clipboard = (android.content.ClipboardManager)
                mainActivity.getSystemService(CLIPBOARD_SERVICE);
            android.content.ClipData clip = android.content.ClipData.newPlainText("text label",
                clickedString);
            clipboard.setPrimaryClip(clip);
          }).build().show();
      View clickedView =
          Boolean.TRUE.equals(noteTmp.isChecklist()) ? toggleChecklistView : binding.contentWrapper;
      clickedView.clearFocus();
      KeyboardUtils.hideKeyboard(clickedView);
      new Handler().post(() -> {
        View clickedView1 = Boolean.TRUE.equals(noteTmp.isChecklist()) ? toggleChecklistView : binding.contentWrapper;
        KeyboardUtils.hideKeyboard(clickedView1);
      });
  };
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mFragment = this;
  }
  @Override
  public void onAttach(Context context) {
    super.onAttach(context);
    EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.CHILDREN));
  }
  @Override
  public void onStop() {
    super.onStop();
    GeocodeHelper.stop();
  }
  @Override
  public void onResume() {
    super.onResume();
    activityPausing = false;
    EventBus.getDefault().register(this);
  }
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    binding = FragmentDetailBinding.inflate(inflater, container, false);
    return binding.getRoot();
  }
  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    mainActivity = (MainActivity) getActivity();
    mainActivity.getSupportActionBar().setDisplayShowTitleEnabled(false);
    mainActivity.getToolbar().setNavigationOnClickListener(v -> navigateUp());
    if (NavigationDrawerFragment.isDoublePanelActive()) {
      mainActivity.getDrawerLayout().setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_OPEN);
    } else {
      mainActivity.getDrawerLayout().setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED);
    }
    restoreTempNoteAfterOrientationChange(savedInstanceState);
    addSketchedImageIfPresent();
    EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.CHILDREN));
    init();
    setHasOptionsMenu(true);
    setRetainInstance(false);
  }
  private void addSketchedImageIfPresent() {
    if (mainActivity.getSketchUri() != null) {
      Attachment mAttachment = new Attachment(mainActivity.getSketchUri(), MIME_TYPE_SKETCH);
      addAttachment(mAttachment);
      mainActivity.setSketchUri(null);
      if (sketchEdited != null) {
        noteTmp.getAttachmentsList().remove(sketchEdited);
        sketchEdited = null;
      }
    }
  }
  private void restoreTempNoteAfterOrientationChange(Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      noteTmp = savedInstanceState.getParcelable("noteTmp");
      note = savedInstanceState.getParcelable("note");
      noteOriginal = savedInstanceState.getParcelable("noteOriginal");
      attachmentUri = savedInstanceState.getParcelable("attachmentUri");
      orientationChanged = savedInstanceState.getBoolean("orientationChanged");
    }
  }
  @Override
  public void onSaveInstanceState(Bundle outState) {
    if (noteTmp != null) {
      noteTmp.setTitle(getNoteTitle());
      noteTmp.setContent(getNoteContent());
      outState.putParcelable("noteTmp", noteTmp);
      outState.putParcelable("note", note);
      outState.putParcelable("noteOriginal", noteOriginal);
      outState.putParcelable("attachmentUri", attachmentUri);
      outState.putBoolean("orientationChanged", orientationChanged);
    }
    super.onSaveInstanceState(outState);
  }
  @Override
  public void onPause() {
    super.onPause();
    EventBus.getDefault().unregister(this);
    activityPausing = true;
    if (!goBack) {
      saveNote();
    }
    if (toggleChecklistView != null) {
      KeyboardUtils.hideKeyboard(toggleChecklistView);
      binding.contentWrapper.clearFocus();
    }
  }
  @Override
  public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    if (getResources().getConfiguration().orientation != newConfig.orientation) {
      orientationChanged = true;
    }
  }
  private void init() {
    handleIntents();
    if (noteOriginal == null) {
      noteOriginal = getArguments().getParcelable(INTENT_NOTE);
    }
    if (note == null) {
      note = new Note(noteOriginal);
    }
    if (noteTmp == null) {
      noteTmp = new Note(note);
    }
    if (Boolean.TRUE.equals(noteTmp.isLocked()) && !noteTmp.isPasswordChecked()) {
      checkNoteLock(noteTmp);
      return;
    }
    initViews();
  }
  private void checkNoteLock(Note note) {
    if (Boolean.TRUE.equals(note.isLocked()
        && Prefs.getString(PREF_PASSWORD, null) != null)
        && !Prefs.getBoolean("settings_password_access", false)) {
      PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
        switch (passwordConfirmed) {
          case SUCCEED:
            noteTmp.setPasswordChecked(true);
            init();
            break;
          case FAIL:
            goBack = true;
            goHome();
            break;
          case RESTORE:
            goBack = true;
            goHome();
            PasswordHelper.resetPassword(mainActivity);
            break;
        }
      });
    } else {
      noteTmp.setPasswordChecked(true);
      init();
    }
  }
  private void handleIntents() {
    Intent i = mainActivity.getIntent();
    if (IntentChecker.checkAction(i, ACTION_MERGE)) {
      noteOriginal = new Note();
      note = new Note(noteOriginal);
      noteTmp = getArguments().getParcelable(INTENT_NOTE);
      if (i.getStringArrayListExtra("merged_notes") != null) {
        mergedNotesIds = i.getStringArrayListExtra("merged_notes");
      }
    }
    if (IntentChecker.checkAction(i, ACTION_SHORTCUT, ACTION_NOTIFICATION_CLICK)) {
      afterSavedReturnsToList = false;
      noteOriginal = DbHelper.getInstance().getNote(i.getLongExtra(INTENT_KEY, 0));
      try {
        note = new Note(noteOriginal);
        noteTmp = new Note(noteOriginal);
      } catch (NullPointerException e) {
        mainActivity.showToast(getText(R.string.shortcut_note_deleted), Toast.LENGTH_LONG);
        mainActivity.finish();
      }
    }
    if (IntentChecker.checkAction(i, ACTION_WIDGET, ACTION_WIDGET_TAKE_PHOTO)) {
      afterSavedReturnsToList = false;
      showKeyboard = true;
      if (i.hasExtra(INTENT_WIDGET)) {
        String widgetId = i.getExtras().get(INTENT_WIDGET).toString();
        String sqlCondition = Prefs.getString(PREF_WIDGET_PREFIX + widgetId, "");
        String categoryId = TextHelper.checkIntentCategory(sqlCondition);
        if (categoryId != null) {
          Category category;
          try {
            category = DbHelper.getInstance().getCategory(parseLong(categoryId));
            noteTmp = new Note();
            noteTmp.setCategory(category);
          } catch (NumberFormatException e) {
            LogDelegate.e("Category with not-numeric value!", e);
          }
        }
      }
      if (IntentChecker.checkAction(i, ACTION_WIDGET_TAKE_PHOTO)) {
        takePhoto();
      }
    }
    if (IntentChecker.checkAction(i, ACTION_FAB_TAKE_PHOTO)) {
      takePhoto();
    }
    if (IntentChecker
        .checkAction(i, Intent.ACTION_SEND, Intent.ACTION_SEND_MULTIPLE, Intent.ACTION_PROCESS_TEXT, INTENT_GOOGLE_NOW)
        && i.getType() != null) {
      afterSavedReturnsToList = false;
      if (noteTmp == null) {
        noteTmp = new Note();
      }
      String title = i.getStringExtra(Intent.EXTRA_SUBJECT);
      if (title != null) {
        noteTmp.setTitle(title);
      }
      String content = null;
      if (Intent.ACTION_PROCESS_TEXT.equals(i.getAction())){
        content = i.getStringExtra(Intent.EXTRA_PROCESS_TEXT).toString();
      } else {
        content = i.getStringExtra(Intent.EXTRA_TEXT);
      }
      if (content != null) {
        noteTmp.setContent(content);
      }
      importAttachments(i);
    }
    if (IntentChecker
        .checkAction(i, Intent.ACTION_MAIN, ACTION_WIDGET_SHOW_LIST, ACTION_SHORTCUT_WIDGET,
            ACTION_WIDGET)) {
      showKeyboard = true;
    }
    i.setAction(null);
  }
  private void importAttachments(Intent i) {
    if (!i.hasExtra(Intent.EXTRA_STREAM)) {
      return;
    }
    if (i.getExtras().get(Intent.EXTRA_STREAM) instanceof Uri) {
      Uri uri = i.getParcelableExtra(Intent.EXTRA_STREAM);
      if (validatePath(uri.getPath()) && !INTENT_GOOGLE_NOW.equals(i.getAction())) {
        String name = FileHelper.getNameFromUri(mainActivity, uri);
        new AttachmentTask(this, uri, name, this).execute();
      }
    } else {
      ArrayList<Uri> uris = i.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
      for (Uri uriSingle : uris) {
        if (validatePath(uriSingle.getPath())) {
          String name = FileHelper.getNameFromUri(mainActivity, uriSingle);
          new AttachmentTask(this, uriSingle, name, this).execute();
        }
      }
    }
  }
  private boolean validatePath(String path) {
    try {
      Security.validatePath(path);
      return true;
    } catch (ContentSecurityException e) {
      mainActivity.showMessage(R.string.insecure_content_found, ONStyle.WARN);
      return false;
    }
  }
  @SuppressLint("NewApi")
  private void initViews() {
    binding.detailRoot.setOnTouchListener(this);
    setTagMarkerColor(noteTmp.getCategory());
    initViewTitle();
    initViewContent();
    initViewLocation();
    initViewAttachments();
    initViewReminder();
    initViewFooter();
  }
  private void initViewFooter() {
    String creation = DateHelper
        .getFormattedDate(noteTmp.getCreation(), Prefs.getBoolean(PREF_PRETTIFIED_DATES, true));
    binding.creation
        .append(creation.length() > 0 ? getString(R.string.creation) + " " + creation : "");
    if (binding.creation.getText().length() == 0) {
      binding.creation.setVisibility(View.GONE);
    }
    String lastModification = DateHelper
        .getFormattedDate(noteTmp.getLastModification(), Prefs.getBoolean(
            PREF_PRETTIFIED_DATES, true));
    binding.lastModification
        .append(lastModification.length() > 0 ? getString(R.string.last_update) + " " +
            lastModification : "");
    if (binding.lastModification.getText().length() == 0) {
      binding.lastModification.setVisibility(View.GONE);
    }
  }
  private void initViewReminder() {
    binding.fragmentDetailContent.reminderLayout.setOnClickListener(v -> {
      ReminderPickers reminderPicker = new ReminderPickers(mainActivity, mFragment);
      reminderPicker.pick(DateUtils.getPresetReminder(noteTmp.getAlarm()), noteTmp
          .getRecurrenceRule());
    });
    binding.fragmentDetailContent.reminderLayout.setOnLongClickListener(v -> {
      MaterialDialog dialog = new MaterialDialog.Builder(mainActivity)
          .content(R.string.remove_reminder)
          .positiveText(R.string.ok)
          .onPositive((dialog1, which) -> {
            ReminderHelper.removeReminder(getAppContext(), noteTmp);
            noteTmp.setAlarm(null);
            binding.fragmentDetailContent.reminderIcon
                .setImageResource(R.drawable.ic_alarm_black_18dp);
            binding.fragmentDetailContent.datetime.setText("");
          }).build();
      dialog.show();
      return true;
    });
    String reminderString = initReminder(noteTmp);
    if (!TextUtils.isEmpty(reminderString)) {
      binding.fragmentDetailContent.reminderIcon
          .setImageResource(R.drawable.ic_alarm_add_black_18dp);
      binding.fragmentDetailContent.datetime.setText(reminderString);
    }
  }
  private void initViewLocation() {
    DetailFragment detailFragment = this;
    if (isNoteLocationValid()) {
      if (TextUtils.isEmpty(noteTmp.getAddress())) {
        GeocodeHelper.getAddressFromCoordinates(new Location("sasd"), detailFragment);
      } else {
        binding.fragmentDetailContent.location.setText(noteTmp.getAddress());
        binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
      }
    }
    if (Prefs.getBoolean(PREF_AUTO_LOCATION, false) && noteTmp.get_id() == null) {
      getLocation(detailFragment);
    }
    binding.fragmentDetailContent.location.setOnClickListener(v -> {
      String uriString = "geo:" + noteTmp.getLatitude() + ',' + noteTmp.getLongitude()
          + "?q=" + noteTmp.getLatitude() + ',' + noteTmp.getLongitude();
      Intent locationIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(uriString));
      if (!IntentChecker.isAvailable(mainActivity, locationIntent, null)) {
        uriString = "http:
            .getLongitude();
        locationIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(uriString));
      }
      startActivity(locationIntent);
    });
    binding.fragmentDetailContent.location.setOnLongClickListener(v -> {
      MaterialDialog.Builder builder = new MaterialDialog.Builder(mainActivity);
      builder.content(R.string.remove_location);
      builder.positiveText(R.string.ok);
      builder.onPositive((dialog, which) -> {
        noteTmp.setLatitude("");
        noteTmp.setLongitude("");
        fade(binding.fragmentDetailContent.location, false);
      });
      MaterialDialog dialog = builder.build();
      dialog.show();
      return true;
    });
  }
  private void getLocation(OnGeoUtilResultListener onGeoUtilResultListener) {
    PermissionsHelper
        .requestPermission(this, Manifest.permission.ACCESS_FINE_LOCATION, R.string
                .permission_coarse_location, binding.snackbarPlaceholder,
            () -> GeocodeHelper.getLocation(onGeoUtilResultListener));
  }
  private void initViewAttachments() {
    if (Prefs.getBoolean(PREF_ATTACHMENTS_ON_BOTTOM, false)) {
      binding.detailAttachmentsBelow.inflate();
    } else {
      binding.detailAttachmentsAbove.inflate();
    }
    mGridView = binding.detailRoot.findViewById(R.id.gridview);
    mAttachmentAdapter = new AttachmentAdapter(mainActivity, noteTmp.getAttachmentsList());
    mGridView.setAdapter(mAttachmentAdapter);
    mGridView.autoresize();
    mGridView.setOnItemClickListener((parent, v, position, id) -> {
      Attachment attachment = (Attachment) parent.getAdapter().getItem(position);
      Uri shareableAttachmentUri = mainActivity.getShareableAttachmentUri(attachment);
      if (shareableAttachmentUri == null) {
        return;
      }
      Intent attachmentIntent;
      if (MIME_TYPE_FILES.equals(attachment.getMime_type())) {
        attachmentIntent = new Intent(Intent.ACTION_VIEW);
        attachmentIntent.setDataAndType(shareableAttachmentUri, StorageHelper.getMimeType(mainActivity,
            shareableAttachmentUri));
        attachmentIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent
            .FLAG_GRANT_WRITE_URI_PERMISSION);
        if (IntentChecker
            .isAvailable(mainActivity.getApplicationContext(), attachmentIntent, null)) {
          startActivity(attachmentIntent);
        } else {
          mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.WARN);
        }
      } else if (MIME_TYPE_IMAGE.equals(attachment.getMime_type())
          || MIME_TYPE_SKETCH.equals(attachment.getMime_type())
          || MIME_TYPE_VIDEO.equals(attachment.getMime_type())) {
        noteTmp.setTitle(getNoteTitle());
        noteTmp.setContent(getNoteContent());
        String title1 = TextHelper.parseTitleAndContent(mainActivity,
            noteTmp)[0].toString();
        int clickedImage = 0;
        ArrayList<Attachment> images = new ArrayList<>();
        for (Attachment mAttachment : noteTmp.getAttachmentsList()) {
          if (MIME_TYPE_IMAGE.equals(mAttachment.getMime_type())
              || MIME_TYPE_SKETCH.equals(mAttachment.getMime_type())
              || MIME_TYPE_VIDEO.equals(mAttachment.getMime_type())) {
            images.add(mAttachment);
            if (mAttachment.equals(attachment)) {
              clickedImage = images.size() - 1;
            }
          }
        }
        attachmentIntent = new Intent(mainActivity, GalleryActivity.class);
        attachmentIntent.putExtra(GALLERY_TITLE, title1);
        attachmentIntent.putParcelableArrayListExtra(GALLERY_IMAGES, images);
        attachmentIntent.putExtra(GALLERY_CLICKED_IMAGE, clickedImage);
        startActivity(attachmentIntent);
      } else if (MIME_TYPE_AUDIO.equals(attachment.getMime_type())) {
        playback(v, attachment.getUri());
      }
    });
    mGridView.setOnItemLongClickListener((parent, v, position, id) -> {
      if (mPlayer != null) {
        return false;
      }
      List<String> items = Arrays
          .asList(getResources().getStringArray(R.array.attachments_actions));
      if (!MIME_TYPE_SKETCH.equals(mAttachmentAdapter.getItem(position).getMime_type())) {
        items = items.subList(0, items.size() - 1);
      }
      Attachment attachment = mAttachmentAdapter.getItem(position);
      new MaterialDialog.Builder(mainActivity)
          .title(attachment.getName() + " (" + AttachmentsHelper.getSize(attachment) + ")")
          .items(items.toArray(new String[items.size()]))
          .itemsCallback((materialDialog, view, i, charSequence) ->
              performAttachmentAction(position, i))
          .build()
          .show();
      return true;
    });
  }
  private void performAttachmentAction(int attachmentPosition, int i) {
    switch (getResources().getStringArray(R.array.attachments_actions_values)[i]) {
      case "share":
        Intent shareIntent = new Intent(Intent.ACTION_SEND);
        Attachment attachment = mAttachmentAdapter.getItem(attachmentPosition);
        Uri shareableAttachmentUri = mainActivity.getShareableAttachmentUri(attachment);
        if (shareableAttachmentUri == null) {
          Toast.makeText(getActivity(), R.string.error_saving_attachments, LENGTH_SHORT).show();
          break;
        }
        shareIntent.setType(StorageHelper.getMimeType(getAppContext(), attachment.getUri()));
        shareIntent.putExtra(Intent.EXTRA_STREAM, shareableAttachmentUri);
        if (IntentChecker.isAvailable(getAppContext(), shareIntent, null)) {
          startActivity(shareIntent);
        } else {
          mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.WARN);
        }
        break;
      case "delete":
        removeAttachment(attachmentPosition);
        mAttachmentAdapter.notifyDataSetChanged();
        mGridView.autoresize();
        break;
      case "delete all":
        new MaterialDialog.Builder(mainActivity)
            .title(R.string.delete_all_attachments)
            .positiveText(R.string.confirm)
            .onPositive((materialDialog, dialogAction) -> removeAllAttachments())
            .build()
            .show();
        break;
      case "edit":
        takeSketch(mAttachmentAdapter.getItem(attachmentPosition));
        break;
      default:
        LogDelegate.w("No action available");
    }
  }
  private void initViewTitle() {
    binding.detailTitle.setText(noteTmp.getTitle());
    binding.detailTitle.gatherLinksForText();
    binding.detailTitle.setOnTextLinkClickListener(textLinkClickListener);
    binding.detailTitle.setOnDragListener((v, event) -> true);
    binding.detailTitle.setOnEditorActionListener((v, actionId, event) -> {
      binding.fragmentDetailContent.detailContent.requestFocus();
      binding.fragmentDetailContent.detailContent
          .setSelection(binding.fragmentDetailContent.detailContent.getText().length());
      return false;
    });
    requestFocus(binding.detailTitle);
  }
  private void initViewContent() {
    binding.fragmentDetailContent.detailContent.setText(noteTmp.getContent());
    binding.fragmentDetailContent.detailContent.gatherLinksForText();
    binding.fragmentDetailContent.detailContent.setOnTextLinkClickListener(textLinkClickListener);
    binding.fragmentDetailContent.detailContent.addTextChangedListener(this);
    toggleChecklistView = binding.fragmentDetailContent.detailContent;
    if (noteTmp.isChecklist()) {
      noteTmp.setChecklist(false);
      AlphaManager.setAlpha(toggleChecklistView, 0);
      toggleChecklist2();
    }
  }
  @SuppressWarnings("JavadocReference")
  private void requestFocus(final EditText view) {
    if (note.get_id() == null && !noteTmp.isChanged(note) && showKeyboard) {
      KeyboardUtils.showKeyboard(view);
    }
  }
  private void setTagMarkerColor(Category tag) {
    String colorsPref = Prefs.getString("settings_colors_app", PREF_COLORS_APP_DEFAULT);
    if (!"disabled".equals(colorsPref)) {
      ArrayList<View> target = new ArrayList<>();
      if ("complete".equals(colorsPref)) {
        target.add(binding.titleWrapper);
        target.add(binding.contentWrapper);
      } else {
        target.add(binding.tagMarker);
      }
      if (tag != null && tag.getColor() != null) {
        for (View view : target) {
          view.setBackgroundColor(parseInt(tag.getColor()));
        }
      } else {
        for (View view : target) {
          view.setBackgroundColor(Color.parseColor("#00000000"));
        }
      }
    }
  }
  private void displayLocationDialog() {
    getLocation(new OnGeoUtilResultListenerImpl(mainActivity, mFragment, noteTmp));
  }
  @Override
  public void onLocationRetrieved(Location location) {
    if (location == null) {
      mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
    }
    if (location != null) {
      noteTmp.setLatitude(location.getLatitude());
      noteTmp.setLongitude(location.getLongitude());
      if (!TextUtils.isEmpty(noteTmp.getAddress())) {
        binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
        binding.fragmentDetailContent.location.setText(noteTmp.getAddress());
      } else {
        GeocodeHelper.getAddressFromCoordinates(location, mFragment);
      }
    }
  }
  @Override
  public void onLocationUnavailable() {
    mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
  }
  public void onLocationNotEnabled(){
    mainActivity.showMessage(R.string.location_not_enabled, ONStyle.ALERT);
  }
  @Override
  public void onAddressResolved(String address) {
    if (TextUtils.isEmpty(address)) {
      if (!isNoteLocationValid()) {
        mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
        return;
      }
      address = noteTmp.getLatitude() + ", " + noteTmp.getLongitude();
    }
    if (!GeocodeHelper.areCoordinates(address)) {
      noteTmp.setAddress(address);
    }
    binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
    binding.fragmentDetailContent.location.setText(address);
    fade(binding.fragmentDetailContent.location, true);
  }
  @Override
  public void onCoordinatesResolved(Location location, String address) {
    if (location != null) {
      noteTmp.setLatitude(location.getLatitude());
      noteTmp.setLongitude(location.getLongitude());
      noteTmp.setAddress(address);
      binding.fragmentDetailContent.location.setVisibility(View.VISIBLE);
      binding.fragmentDetailContent.location.setText(address);
      fade(binding.fragmentDetailContent.location, true);
    } else {
      mainActivity.showMessage(R.string.location_not_found, ONStyle.ALERT);
    }
  }
  @Override
  public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
    inflater.inflate(R.menu.menu_detail, menu);
    super.onCreateOptionsMenu(menu, inflater);
  }
  @Override
  public void onPrepareOptionsMenu(Menu menu) {
    MenuItem searchMenuItem = menu.findItem(R.id.menu_search);
    if (searchMenuItem != null) {
      searchMenuItem.collapseActionView();
    }
    boolean newNote = noteTmp.get_id() == null;
    menu.findItem(R.id.menu_checklist_on).setVisible(!noteTmp.isChecklist());
    menu.findItem(R.id.menu_checklist_off).setVisible(noteTmp.isChecklist());
    menu.findItem(R.id.menu_checklist_moveToBottom)
        .setVisible(noteTmp.isChecklist() && mChecklistManager.getCheckedCount() > 0);
    menu.findItem(R.id.menu_lock).setVisible(!noteTmp.isLocked());
    menu.findItem(R.id.menu_unlock).setVisible(noteTmp.isLocked());
    if (noteTmp.isTrashed()) {
      menu.findItem(R.id.menu_untrash).setVisible(true);
      menu.findItem(R.id.menu_delete).setVisible(true);
    } else {
      menu.findItem(R.id.menu_add_shortcut).setVisible(!newNote);
      menu.findItem(R.id.menu_pin_note).setVisible(!newNote);
      menu.findItem(R.id.menu_archive).setVisible(!newNote && !noteTmp.isArchived());
      menu.findItem(R.id.menu_unarchive).setVisible(!newNote && noteTmp.isArchived());
      menu.findItem(R.id.menu_trash).setVisible(!newNote);
    }
  }
  @SuppressLint("NewApi")
  private boolean goHome() {
    stopPlaying();
    if (!afterSavedReturnsToList) {
      if (!TextUtils.isEmpty(exitMessage)) {
        mainActivity.showToast(exitMessage, LENGTH_SHORT);
      }
      mainActivity.finish();
    } else {
      if (!TextUtils.isEmpty(exitMessage) && exitCroutonStyle != null) {
        mainActivity.showMessage(exitMessage, exitCroutonStyle);
      }
      if (mainActivity != null) {
        mainActivity.getSupportFragmentManager();
        mainActivity.getSupportFragmentManager().popBackStack();
        if (mainActivity.getSupportFragmentManager().getBackStackEntryCount() == 1) {
          mainActivity.getSupportActionBar().setDisplayShowTitleEnabled(true);
          if (mainActivity.getDrawerToggle() != null) {
            mainActivity.getDrawerToggle().setDrawerIndicatorEnabled(true);
          }
          EventBus.getDefault().post(new SwitchFragmentEvent(SwitchFragmentEvent.Direction.PARENT));
        }
      }
    }
    return true;
  }
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
    if (isOptionsItemFastClick()) {
      return true;
    }
    switch (item.getItemId()) {
      case R.id.menu_attachment:
        showAttachmentsPopup();
        break;
      case R.id.menu_tag:
        addTags();
        break;
      case R.id.menu_category:
        categorizeNote();
        break;
      case R.id.menu_share:
        shareNote();
        break;
      case R.id.menu_checklist_on:
      case R.id.menu_checklist_off:
        toggleChecklist();
        break;
      case R.id.menu_checklist_moveToBottom:
        moveCheckedItemsToBottom();
        break;
      case R.id.menu_lock:
      case R.id.menu_unlock:
        lockNote();
        break;
      case R.id.menu_pin_note:
        pinNote();
        break;
      case R.id.menu_add_shortcut:
        addShortcut();
        break;
      case R.id.menu_archive:
        archiveNote(true);
        break;
      case R.id.menu_unarchive:
        archiveNote(false);
        break;
      case R.id.menu_trash:
        trashNote(true);
        break;
      case R.id.menu_untrash:
        trashNote(false);
        break;
      case R.id.menu_discard_changes:
        discard();
        break;
      case R.id.menu_delete:
        deleteNote();
        break;
      case R.id.menu_note_info:
        showNoteInfo();
        break;
      default:
        LogDelegate.w("Invalid menu option selected");
    }
    return super.onOptionsItemSelected(item);
  }
  private void showNoteInfo() {
    noteTmp.setTitle(getNoteTitle());
    noteTmp.setContent(getNoteContent());
    Intent intent = new Intent(getContext(), NoteInfosActivity.class);
    intent.putExtra(INTENT_NOTE, (android.os.Parcelable) noteTmp);
    startActivity(intent);
  }
  private void navigateUp() {
    afterSavedReturnsToList = true;
    saveAndExit();
  }
  private void toggleChecklist() {
    if (Boolean.FALSE.equals(noteTmp.isChecklist())) {
      toggleChecklist2();
      return;
    }
    if (mChecklistManager.getCheckedCount() == 0) {
      toggleChecklist2(true, false);
      return;
    }
    LayoutInflater inflater = (LayoutInflater) mainActivity
        .getSystemService(LAYOUT_INFLATER_SERVICE);
    final View layout = inflater.inflate(R.layout.dialog_remove_checklist_layout,
        getView().findViewById(R.id.layout_root));
    final CheckBox keepChecked = layout.findViewById(R.id.checklist_keep_checked);
    final CheckBox keepCheckmarks = layout.findViewById(R.id.checklist_keep_checkmarks);
    keepChecked.setChecked(Prefs.getBoolean(PREF_KEEP_CHECKED, true));
    keepCheckmarks.setChecked(Prefs.getBoolean(PREF_KEEP_CHECKMARKS, true));
    new MaterialDialog.Builder(mainActivity)
        .customView(layout, false)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          Prefs.edit()
              .putBoolean(PREF_KEEP_CHECKED, keepChecked.isChecked())
              .putBoolean(PREF_KEEP_CHECKMARKS, keepCheckmarks.isChecked())
              .apply();
          toggleChecklist2();
        }).build().show();
  }
  private void toggleChecklist2() {
    boolean keepChecked = Prefs.getBoolean(PREF_KEEP_CHECKED, true);
    boolean showChecks = Prefs.getBoolean(PREF_KEEP_CHECKMARKS, true);
    toggleChecklist2(keepChecked, showChecks);
  }
  private void toggleChecklist2(final boolean keepChecked, final boolean showChecks) {
    mChecklistManager = mChecklistManager == null ? new ChecklistManager(mainActivity) : mChecklistManager;
    int checkedItemsBehavior = Integer
        .parseInt(Prefs.getString("settings_checked_items_behavior", String.valueOf
            (it.feio.android.checklistview.Settings.CHECKED_HOLD)));
    mChecklistManager
        .showCheckMarks(showChecks)
        .newEntryHint(getString(R.string.checklist_item_hint))
        .keepChecked(keepChecked)
        .undoBarContainerView(binding.contentWrapper)
        .moveCheckedOnBottom(checkedItemsBehavior);
    mChecklistManager.setOnTextLinkClickListener(textLinkClickListener);
    mChecklistManager.addTextChangedListener(mFragment);
    mChecklistManager.setCheckListChangedListener(mFragment);
    View newView = null;
    try {
      newView = mChecklistManager.convert(toggleChecklistView);
    } catch (ViewNotSupportedException e) {
      LogDelegate.e("Error switching checklist view", e);
    }
    if (newView != null) {
      mChecklistManager.replaceViews(toggleChecklistView, newView);
      toggleChecklistView = newView;
      animate(toggleChecklistView).alpha(1).scaleXBy(0).scaleX(1).scaleYBy(0).scaleY(1);
      noteTmp.setChecklist(!noteTmp.isChecklist());
    }
  }
  private void moveCheckedItemsToBottom() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      mChecklistManager.moveCheckedToBottom();
    }
  }
  private void categorizeNote() {
    var currentCategory = noteTmp.getCategory() != null ? String.valueOf(noteTmp.getCategory().getId()) : null;
    var  originalCategory = noteOriginal.getCategory() != null ? String.valueOf(noteOriginal.getCategory().getId()) : null;
    final var categories = DbHelper.getInstance().getCategories().stream()
        .map(category -> {
          if (String.valueOf(category.getId()).equals(currentCategory) && currentCategory != originalCategory) {
            category.setCount(category.getCount() + 1);
          }
          if (String.valueOf(category.getId()).equals(originalCategory) && currentCategory != originalCategory) {
            category.setCount(category.getCount() - 1);
          }
          return category;
        }).collect(Collectors.toList());
    var dialogBuilder = new MaterialDialog.Builder(mainActivity)
        .title(R.string.categorize_as)
        .positiveText(R.string.add_category)
        .positiveColorRes(R.color.colorPrimary)
        .negativeText(R.string.remove_category)
        .negativeColorRes(R.color.colorAccent)
        .onPositive((dialog1, which) -> {
          Intent intent = new Intent(mainActivity, CategoryActivity.class);
          intent.putExtra("noHome", true);
          startActivityForResult(intent, CATEGORY);
        })
        .onNegative((dialog12, which) -> {
          noteTmp.setCategory(null);
          setTagMarkerColor(null);
        });
    if (CollectionUtils.isNotEmpty(categories)) {
      dialogBuilder.adapter(new CategoryRecyclerViewAdapter(mainActivity, categories), null);
    }
    final var dialog = dialogBuilder.build();
    if (CollectionUtils.isNotEmpty(categories)) {
      RecyclerViewItemClickSupport.addTo(dialog.getRecyclerView())
          .setOnItemClickListener((recyclerView, position, v) -> {
            noteTmp.setCategory(categories.get(position));
            setTagMarkerColor(categories.get(position));
            dialog.dismiss();
          });
    }
    dialog.show();
  }
  private void showAttachmentsPopup() {
    LayoutInflater inflater = mainActivity.getLayoutInflater();
    final View layout = inflater.inflate(R.layout.attachment_dialog, null);
    attachmentDialog = new MaterialDialog.Builder(mainActivity)
        .autoDismiss(false)
        .customView(layout, false)
        .build();
    attachmentDialog.show();
    android.widget.TextView cameraSelection = layout.findViewById(R.id.camera);
    cameraSelection.setOnClickListener(new AttachmentOnClickListener());
    android.widget.TextView recordingSelection = layout.findViewById(R.id.recording);
    toggleAudioRecordingStop(recordingSelection);
    recordingSelection.setOnClickListener(new AttachmentOnClickListener());
    android.widget.TextView videoSelection = layout.findViewById(R.id.video);
    videoSelection.setOnClickListener(new AttachmentOnClickListener());
    android.widget.TextView filesSelection = layout.findViewById(R.id.files);
    filesSelection.setOnClickListener(new AttachmentOnClickListener());
    android.widget.TextView sketchSelection = layout.findViewById(R.id.sketch);
    sketchSelection.setOnClickListener(new AttachmentOnClickListener());
    android.widget.TextView locationSelection = layout.findViewById(R.id.location);
    locationSelection.setOnClickListener(new AttachmentOnClickListener());
    android.widget.TextView timeStampSelection = layout.findViewById(R.id.timestamp);
    timeStampSelection.setOnClickListener(new AttachmentOnClickListener());
    android.widget.TextView pushbulletSelection = layout.findViewById(R.id.pushbullet);
    pushbulletSelection.setVisibility(View.VISIBLE);
    pushbulletSelection.setOnClickListener(new AttachmentOnClickListener());
  }
  private void takePhoto() {
    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    if (!IntentChecker.isAvailable(mainActivity, intent, new String[]{FEATURE_CAMERA})) {
      mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.ALERT);
      return;
    }
    PermissionsHelper.requestPermission(this, CAMERA,
        R.string.permission_camera, binding.snackbarPlaceholder, () -> {
          File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_IMAGE_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          attachmentUri = Uri.fromFile(f);
          intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
          intent.putExtra(MediaStore.EXTRA_OUTPUT, FileProviderHelper.getFileProvider(f));
          startActivityForResult(intent, TAKE_PHOTO);
        });
  }
  private void takeVideo() {
    var takeVideoIntent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
    if (!IntentChecker.isAvailable(mainActivity, takeVideoIntent,
        new String[]{FEATURE_CAMERA})) {
      mainActivity.showMessage(R.string.feature_not_available_on_this_device, ONStyle.ALERT);
      return;
    }
    PermissionsHelper.requestPermission(this, CAMERA,
        R.string.permission_camera, binding.snackbarPlaceholder, () -> {
          var f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_VIDEO_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          attachmentUri = Uri.fromFile(f);
          takeVideoIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
          takeVideoIntent.putExtra(MediaStore.EXTRA_OUTPUT, FileProviderHelper.getFileProvider(f));
          var maxVideoSizeStr = "".equals(Prefs.getString("settings_max_video_size", ""))
              ? "0" : Prefs.getString("settings_max_video_size", "");
          long maxVideoSize = parseLong(maxVideoSizeStr) * 1024L * 1024L;
          takeVideoIntent.putExtra(MediaStore.EXTRA_SIZE_LIMIT, maxVideoSize);
          startActivityForResult(takeVideoIntent, TAKE_VIDEO);
        });
  }
  private void takeSketch(Attachment attachment) {
    File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_SKETCH_EXT);
    if (f == null) {
      mainActivity.showMessage(R.string.error, ONStyle.ALERT);
      return;
    }
    attachmentUri = Uri.fromFile(f);
    mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
    FragmentTransaction transaction = mainActivity.getSupportFragmentManager().beginTransaction();
    mainActivity.animateTransition(transaction, TRANSITION_HORIZONTAL);
    SketchFragment mSketchFragment = new SketchFragment();
    Bundle b = new Bundle();
    b.putParcelable(MediaStore.EXTRA_OUTPUT, attachmentUri);
    if (attachment != null) {
      b.putParcelable("base", attachment.getUri());
    }
    mSketchFragment.setArguments(b);
    transaction.replace(R.id.fragment_container, mSketchFragment, FRAGMENT_SKETCH_TAG)
        .addToBackStack(FRAGMENT_DETAIL_TAG).commit();
  }
  private void addTimestamp() {
    Editable editable = binding.fragmentDetailContent.detailContent.getText();
    int position = binding.fragmentDetailContent.detailContent.getSelectionStart();
    DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT);
    String dateStamp = dateFormat.format(new Date().getTime()) + " ";
    if (noteTmp.isChecklist()) {
      if (mChecklistManager.getFocusedItemView() != null) {
        editable = mChecklistManager.getFocusedItemView().getEditText().getEditableText();
        position = mChecklistManager.getFocusedItemView().getEditText().getSelectionStart();
      } else {
        ((CheckListView) toggleChecklistView)
            .addItem(dateStamp, false, mChecklistManager.getCount());
      }
    }
    String leadSpace = position == 0 ? "" : " ";
    dateStamp = leadSpace + dateStamp;
    editable.insert(position, dateStamp);
    Selection.setSelection(editable, position + dateStamp.length());
  }
  @SuppressLint("NewApi")
  @Override
  public void onActivityResult(int requestCode, int resultCode, Intent intent) {
    Attachment attachment;
    if (resultCode == Activity.RESULT_OK) {
      switch (requestCode) {
        case TAKE_PHOTO:
          attachment = new Attachment(attachmentUri, MIME_TYPE_IMAGE);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case TAKE_VIDEO:
          attachment = new Attachment(attachmentUri, MIME_TYPE_VIDEO);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case FILES:
          onActivityResultManageReceivedFiles(intent);
          break;
        case SET_PASSWORD:
          noteTmp.setPasswordChecked(true);
          lockUnlock();
          break;
        case SKETCH:
          attachment = new Attachment(attachmentUri, MIME_TYPE_SKETCH);
          addAttachment(attachment);
          mAttachmentAdapter.notifyDataSetChanged();
          mGridView.autoresize();
          break;
        case CATEGORY:
          mainActivity.showMessage(R.string.category_saved, ONStyle.CONFIRM);
          Category category = intent.getParcelableExtra("category");
          noteTmp.setCategory(category);
          setTagMarkerColor(category);
          break;
        case DETAIL:
          mainActivity.showMessage(R.string.note_updated, ONStyle.CONFIRM);
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + requestCode);
      }
    }
  }
  private void onActivityResultManageReceivedFiles(Intent intent) {
    List<Uri> uris = new ArrayList<>();
    if (intent.getClipData() != null) {
      for (int i = 0; i < intent.getClipData().getItemCount(); i++) {
        uris.add(intent.getClipData().getItemAt(i).getUri());
      }
    } else {
      uris.add(intent.getData());
    }
    for (Uri uri : uris) {
      String name = FileHelper.getNameFromUri(mainActivity, uri);
      new AttachmentTask(this, uri, name, this).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }
  }
  private void discard() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.undo_changes_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          if (!noteTmp.getAttachmentsList().equals(note.getAttachmentsList())) {
            for (Attachment newAttachment : noteTmp.getAttachmentsList()) {
              if (!note.getAttachmentsList().contains(newAttachment)) {
                StorageHelper.delete(mainActivity, newAttachment.getUri().getPath());
              }
            }
          }
          goBack = true;
          if (noteTmp.equals(noteOriginal)) {
            goHome();
          }
          if (noteOriginal.get_id() != null) {
            new SaveNoteTask(false).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteOriginal);
            BaseActivity.notifyAppWidgets(mainActivity);
          } else {
            goHome();
          }
        }).build().show();
  }
  @SuppressLint("NewApi")
  private void archiveNote(boolean archive) {
    if (noteTmp.get_id() == null) {
      goHome();
      return;
    }
    noteTmp.setArchived(archive);
    goBack = true;
    exitMessage = archive ? getString(R.string.note_archived) : getString(R.string.note_unarchived);
    exitCroutonStyle = archive ? ONStyle.WARN : ONStyle.INFO;
    saveNote();
  }
  @SuppressLint("NewApi")
  private void trashNote(boolean trash) {
    if (noteTmp.get_id() == null) {
      goHome();
      return;
    }
    noteTmp.setTrashed(trash);
    goBack = true;
    exitMessage = trash ? getString(R.string.note_trashed) : getString(R.string.note_untrashed);
    exitCroutonStyle = trash ? ONStyle.WARN : ONStyle.INFO;
    if (trash) {
      ShortcutHelper.removeShortcut(getAppContext(), noteTmp);
      ReminderHelper.removeReminder(getAppContext(), noteTmp);
    } else {
      ReminderHelper.addReminder(getAppContext(), note);
    }
    saveNote();
  }
  private void deleteNote() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.delete_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          mainActivity.deleteNote(noteTmp);
          LogDelegate.d("Deleted note with ID '" + noteTmp.get_id() + "'");
          mainActivity.showMessage(R.string.note_deleted, ONStyle.ALERT);
          goHome();
        }).build().show();
  }
  public void saveAndExit() {
    if (isAdded()) {
      exitMessage = getString(R.string.note_updated);
      exitCroutonStyle = ONStyle.CONFIRM;
      goBack = true;
      saveNote();
    }
  }
  void saveNote() {
    noteTmp.setTitle(getNoteTitle());
    noteTmp.setContent(getNoteContent());
    if (goBack && TextUtils.isEmpty(noteTmp.getTitle()) && TextUtils.isEmpty(noteTmp.getContent())
        && noteTmp.getAttachmentsList().isEmpty()) {
      LogDelegate.d("Empty note not saved");
      exitMessage = getString(R.string.empty_note_not_saved);
      exitCroutonStyle = ONStyle.INFO;
      goHome();
      return;
    }
    if (saveNotNeeded()) {
      exitMessage = "";
      if (goBack) {
        goHome();
      }
      return;
    }
    noteTmp.setAttachmentsListOld(note.getAttachmentsList());
    new SaveNoteTask(lastModificationUpdatedNeeded()).executeOnExecutor(AsyncTask
        .THREAD_POOL_EXECUTOR, noteTmp);
  }
  private boolean saveNotNeeded() {
    if (noteTmp.get_id() == null && Prefs.getBoolean(PREF_AUTO_LOCATION, false)) {
      note.setLatitude(noteTmp.getLatitude());
      note.setLongitude(noteTmp.getLongitude());
    }
    return !noteTmp.isChanged(note) || (noteTmp.isLocked() && !noteTmp.isPasswordChecked());
  }
  private boolean lastModificationUpdatedNeeded() {
    note.setCategory(noteTmp.getCategory());
    note.setArchived(noteTmp.isArchived());
    note.setTrashed(noteTmp.isTrashed());
    note.setLocked(noteTmp.isLocked());
    return noteTmp.isChanged(note);
  }
  private void deleteMergedNotes(List<String> mergedNotesIds) {
    ArrayList<Note> notesToDelete = new ArrayList<>();
    if (mergedNotesIds != null) {
      for (String mergedNoteId : mergedNotesIds) {
        Note noteToDelete = new Note();
        noteToDelete.set_id(Long.valueOf(mergedNoteId));
        notesToDelete.add(noteToDelete);
      }
      new NoteProcessorDelete(notesToDelete).process();
    }
  }
  private String getNoteTitle() {
    if (!TextUtils.isEmpty(binding.detailTitle.getText())) {
      return binding.detailTitle.getText().toString();
    } else {
      return "";
    }
  }
  private String getNoteContent() {
    String contentText = "";
    if (Boolean.FALSE.equals(noteTmp.isChecklist())) {
      View contentView = binding.detailRoot.findViewById(R.id.detail_content);
      if (contentView instanceof EditText) {
        contentText = ((EditText) contentView).getText().toString();
      } else if (contentView instanceof android.widget.EditText) {
        contentText = ((android.widget.EditText) contentView).getText().toString();
      }
    } else {
      if (mChecklistManager != null) {
        mChecklistManager.keepChecked(true).showCheckMarks(true);
        contentText = mChecklistManager.getText();
      }
    }
    return contentText;
  }
  private void shareNote() {
    Note sharedNote = new Note(noteTmp);
    sharedNote.setTitle(getNoteTitle());
    sharedNote.setContent(getNoteContent());
    mainActivity.shareNote(sharedNote);
  }
  private void lockNote() {
    LogDelegate.d("Locking or unlocking note " + note.get_id());
    if (Prefs.getString(PREF_PASSWORD, null) == null) {
      Intent passwordIntent = new Intent(mainActivity, PasswordActivity.class);
      startActivityForResult(passwordIntent, SET_PASSWORD);
      return;
    }
    if (noteTmp.isPasswordChecked() || Prefs.getBoolean("settings_password_access", false)) {
      lockUnlock();
      return;
    }
    PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
      if (passwordConfirmed == Result.SUCCEED) {
        lockUnlock();
      }
    });
  }
  private void lockUnlock() {
    if (Prefs.getString(PREF_PASSWORD, null) == null) {
      mainActivity.showMessage(R.string.password_not_set, ONStyle.WARN);
      return;
    }
    mainActivity.showMessage(R.string.save_note_to_lock_it, ONStyle.INFO);
    mainActivity.supportInvalidateOptionsMenu();
    noteTmp.setLocked(!noteTmp.isLocked());
    noteTmp.setPasswordChecked(true);
  }
  private String initReminder(Note note) {
    if (noteTmp.getAlarm() == null) {
      return "";
    }
    long reminder = parseLong(note.getAlarm());
    String rrule = note.getRecurrenceRule();
    if (!TextUtils.isEmpty(rrule)) {
      return RecurrenceHelper.getNoteRecurrentReminderText(reminder, rrule);
    } else {
      return RecurrenceHelper.getNoteReminderText(reminder);
    }
  }
  private void playback(View v, Uri uri) {
    if (mPlayer != null && mPlayer.isPlaying()) {
      if (isPlayingView != v) {
        stopPlaying();
        isPlayingView = v;
        startPlaying(uri);
        replacePlayingAudioBitmap(v);
      } else {
        stopPlaying();
      }
    } else {
      isPlayingView = v;
      startPlaying(uri);
      replacePlayingAudioBitmap(v);
    }
  }
  private void replacePlayingAudioBitmap(View v) {
    Drawable d = ((ImageView) v.findViewById(R.id.gridview_item_picture)).getDrawable();
    if (BitmapDrawable.class.isAssignableFrom(d.getClass())) {
      recordingBitmap = ((BitmapDrawable) d).getBitmap();
    } else {
      recordingBitmap = ((BitmapDrawable) d.getCurrent()).getBitmap();
    }
    ((ImageView) v.findViewById(R.id.gridview_item_picture)).setImageBitmap(ThumbnailUtils
        .extractThumbnail(BitmapFactory.decodeResource(mainActivity.getResources(),
            R.drawable.stop), THUMBNAIL_SIZE, THUMBNAIL_SIZE));
  }
  private void startPlaying(Uri uri) {
    if (mPlayer == null) {
      mPlayer = new MediaPlayer();
    }
    try {
      mPlayer.setDataSource(mainActivity, uri);
      mPlayer.prepare();
      mPlayer.start();
      mPlayer.setOnCompletionListener(mp -> {
        mPlayer = null;
        if (isPlayingView != null) {
          ((ImageView) isPlayingView.findViewById(R.id.gridview_item_picture)).setImageBitmap
              (recordingBitmap);
          recordingBitmap = null;
          isPlayingView = null;
        }
      });
    } catch (IOException e) {
      LogDelegate.e("prepare() failed", e);
      mainActivity.showMessage(R.string.error, ONStyle.ALERT);
    }
  }
  private void stopPlaying() {
    if (mPlayer != null) {
      if (isPlayingView != null) {
        ((ImageView) isPlayingView.findViewById(R.id.gridview_item_picture))
            .setImageBitmap(recordingBitmap);
      }
      isPlayingView = null;
      recordingBitmap = null;
      mPlayer.release();
      mPlayer = null;
    }
  }
  private void startRecording(View v) {
    PermissionsHelper.requestPermission(this, Manifest.permission.RECORD_AUDIO,
        R.string.permission_audio_recording, binding.snackbarPlaceholder, () -> {
          isRecording = true;
          toggleAudioRecordingStop(v);
          File f = StorageHelper.createNewAttachmentFile(mainActivity, MIME_TYPE_AUDIO_EXT);
          if (f == null) {
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
            return;
          }
          if (mRecorder == null) {
            mRecorder = new MediaRecorder();
            mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
            mRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);
            mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);
            mRecorder.setAudioEncodingBitRate(96000);
            mRecorder.setAudioSamplingRate(44100);
          }
          recordName = f.getAbsolutePath();
          mRecorder.setOutputFile(recordName);
          try {
            audioRecordingTimeStart = Calendar.getInstance().getTimeInMillis();
            mRecorder.prepare();
            mRecorder.start();
          } catch (IOException | IllegalStateException e) {
            LogDelegate.e("prepare() failed", e);
            mainActivity.showMessage(R.string.error, ONStyle.ALERT);
          }
        });
  }
  private void toggleAudioRecordingStop(View v) {
    if (isRecording) {
      ((android.widget.TextView) v).setText(getString(R.string.stop));
      ((android.widget.TextView) v).setTextColor(Color.parseColor("#ff0000"));
    }
  }
  private void stopRecording() {
    isRecording = false;
    if (mRecorder != null) {
      mRecorder.stop();
      audioRecordingTime = Calendar.getInstance().getTimeInMillis() - audioRecordingTimeStart;
      mRecorder.release();
      mRecorder = null;
    }
  }
  private void fade(final View v, boolean fadeIn) {
    int anim = R.animator.fade_out_support;
    int visibilityTemp = View.GONE;
    if (fadeIn) {
      anim = R.animator.fade_in_support;
      visibilityTemp = View.VISIBLE;
    }
    final int visibility = visibilityTemp;
    if (mainActivity != null) {
      Animation mAnimation = AnimationUtils.loadAnimation(mainActivity, anim);
      mAnimation.setAnimationListener(new AnimationListener() {
        @Override
        public void onAnimationStart(Animation animation) {
        }
        @Override
        public void onAnimationRepeat(Animation animation) {
        }
        @Override
        public void onAnimationEnd(Animation animation) {
          v.setVisibility(visibility);
        }
      });
      v.startAnimation(mAnimation);
    }
  }
  private void pinNote() {
    if (!new NotificationsHelper(getAppContext()).checkNotificationsEnabled(getAppContext())) {
      mainActivity.showToast(getText(R.string.denied_notifications_permission), Toast.LENGTH_LONG);
      return;
    }
    PendingIntent notifyIntent = IntentHelper
        .getNotePendingIntent(getContext(), SnoozeActivity.class, ACTION_PINNED, note);
    Spanned[] titleAndContent = TextHelper.parseTitleAndContent(getContext(), note);
    String pinnedTitle = titleAndContent[0].toString();
    String pinnedContent = titleAndContent[1].toString();
    NotificationsHelper notificationsHelper = new NotificationsHelper(getContext());
    notificationsHelper
        .createOngoingNotification(NotificationChannelNames.PINNED, R.drawable.ic_stat_notification,
            pinnedTitle, notifyIntent).setMessage(pinnedContent);
    List<Attachment> attachments = note.getAttachmentsList();
    if (!attachments.isEmpty() && !attachments.get(0).getMime_type().equals(MIME_TYPE_FILES)) {
      Bitmap notificationIcon = BitmapHelper
          .getBitmapFromAttachment(getContext(), note.getAttachmentsList().get(0), 128,
              128);
      notificationsHelper.setLargeIcon(notificationIcon);
    }
    PendingIntent unpinIntent = IntentHelper
        .getNotePendingIntent(getContext(), SnoozeActivity.class, ACTION_DISMISS, note);
    notificationsHelper.getBuilder()
        .addAction(R.drawable.ic_material_reminder_time_light, getContext().getString(R.string.done), unpinIntent);
    notificationsHelper.show(note.get_id());
  }
  private void addShortcut() {
    ShortcutHelper.addShortcut(getAppContext(), noteTmp);
    mainActivity.showMessage(R.string.shortcut_added, ONStyle.INFO);
  }
  @SuppressLint("NewApi")
  @Override
  public boolean onTouch(View v, MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();
    switch (event.getAction()) {
      case MotionEvent.ACTION_DOWN:
        LogDelegate.v("MotionEvent.ACTION_DOWN");
        int w;
        Point displaySize = Display.getUsableSize(mainActivity);
        w = displaySize.x;
        if (x < SWIPE_MARGIN || x > w - SWIPE_MARGIN) {
          swiping = true;
          startSwipeX = x;
        }
        break;
      case MotionEvent.ACTION_UP:
        LogDelegate.v("MotionEvent.ACTION_UP");
        if (swiping) {
          swiping = false;
        }
        break;
      case MotionEvent.ACTION_MOVE:
        if (swiping) {
          LogDelegate.v("MotionEvent.ACTION_MOVE at position " + x + ", " + y);
          if (Math.abs(x - startSwipeX) > SWIPE_OFFSET) {
            swiping = false;
            FragmentTransaction transaction = mainActivity.getSupportFragmentManager()
                .beginTransaction();
            mainActivity.animateTransition(transaction, TRANSITION_VERTICAL);
            DetailFragment mDetailFragment = new DetailFragment();
            Bundle b = new Bundle();
            b.putParcelable(INTENT_NOTE, new Note());
            mDetailFragment.setArguments(b);
            transaction.replace(R.id.fragment_container, mDetailFragment, FRAGMENT_DETAIL_TAG)
                .addToBackStack(
                    FRAGMENT_DETAIL_TAG).commit();
          }
        }
        break;
      default:
        LogDelegate.e("Wrong element choosen: " + event.getAction());
    }
    return true;
  }
  @Override
  public void onAttachingFileErrorOccurred(Attachment mAttachment) {
    mainActivity.showMessage(R.string.error_saving_attachments, ONStyle.ALERT);
    if (noteTmp.getAttachmentsList().contains(mAttachment)) {
      removeAttachment(mAttachment);
      mAttachmentAdapter.notifyDataSetChanged();
      mGridView.autoresize();
    }
  }
  private void addAttachment(Attachment attachment) {
    noteTmp.addAttachment(attachment);
  }
  private void removeAttachment(Attachment mAttachment) {
    noteTmp.removeAttachment(mAttachment);
  }
  private void removeAttachment(int position) {
    noteTmp.removeAttachment(noteTmp.getAttachmentsList().get(position));
  }
  private void removeAllAttachments() {
    noteTmp.setAttachmentsList(new ArrayList<>());
    mAttachmentAdapter = new AttachmentAdapter(mainActivity, new ArrayList<>());
    mGridView.invalidateViews();
    mGridView.setAdapter(mAttachmentAdapter);
  }
  @Override
  public void onAttachingFileFinished(Attachment mAttachment) {
    addAttachment(mAttachment);
    mAttachmentAdapter.notifyDataSetChanged();
    mGridView.autoresize();
  }
  @Override
  public void onReminderPicked(long reminder) {
    noteTmp.setAlarm(reminder);
    if (mFragment.isAdded()) {
      binding.fragmentDetailContent.reminderIcon.setImageResource(R.drawable.ic_alarm_black_18dp);
      binding.fragmentDetailContent.datetime
          .setText(RecurrenceHelper.getNoteReminderText(reminder));
    }
  }
  @Override
  public void onRecurrenceReminderPicked(String recurrenceRule) {
    noteTmp.setRecurrenceRule(recurrenceRule);
    if (!TextUtils.isEmpty(recurrenceRule)) {
      LogDelegate.d("Recurrent reminder set: " + recurrenceRule);
      binding.fragmentDetailContent.datetime.setText(RecurrenceHelper
          .getNoteRecurrentReminderText(Long.parseLong(noteTmp.getAlarm()), recurrenceRule));
    }
  }
  @Override
  public void onTextChanged(CharSequence s, int start, int before, int count) {
    scrollContent();
  }
  @Override
  public void beforeTextChanged(CharSequence s, int start, int count, int after) {
  }
  @Override
  public void afterTextChanged(Editable s) {
  }
  @Override
  public void onCheckListChanged() {
    scrollContent();
  }
  private void scrollContent() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      if (mChecklistManager.getCount() > contentLineCounter) {
        binding.contentWrapper.scrollBy(0, 60);
      }
      contentLineCounter = mChecklistManager.getCount();
    } else {
      if (binding.fragmentDetailContent.detailContent.getLineCount() > contentLineCounter) {
        binding.contentWrapper.scrollBy(0, 60);
      }
      contentLineCounter = binding.fragmentDetailContent.detailContent.getLineCount();
    }
  }
  private void addTags() {
    contentCursorPosition = getCursorIndex();
    final List<Tag> tags = TagsHelper.getAllTags();
    if (tags.isEmpty()) {
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    final Note currentNote = new Note();
    currentNote.setTitle(getNoteTitle());
    currentNote.setContent(getNoteContent());
    Integer[] preselectedTags = TagsHelper.getPreselectedTagsArray(currentNote, tags);
    MaterialDialog dialog = new MaterialDialog.Builder(mainActivity)
        .title(R.string.select_tags)
        .positiveText(R.string.ok)
        .items(TagsHelper.getTagsArray(tags))
        .itemsCallbackMultiChoice(preselectedTags, (dialog1, which, text) -> {
          dialog1.dismiss();
          tagNote(tags, which, currentNote);
          return false;
        }).build();
    dialog.show();
  }
  private void tagNote(List<Tag> tags, Integer[] selectedTags, Note note) {
    var taggingResult = TagsHelper.addTagToNote(tags, selectedTags, note);
    if (!taggingResult.first.isEmpty()) {
      if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
        tagChecklistNote(taggingResult);
      } else {
        tagTextNote(taggingResult);
      }
    }
    eventuallyRemoveDeselectedTags(taggingResult.second);
  }
  private void tagTextNote(Pair<String, List<Tag>> taggingResult) {
    var sb = new StringBuilder(getNoteContent());
    var detailContent = binding.fragmentDetailContent.detailContent;
    if (detailContent.hasFocus()) {
      if (!taggingResult.first.isEmpty()) {
        sb.insert(contentCursorPosition, " " + taggingResult.first + " ");
      }
      detailContent.setText(sb.toString());
      detailContent.setSelection(contentCursorPosition + taggingResult.first.length() + 1);
    } else {
      if (!getNoteContent().trim().isEmpty()) {
        sb.append(System.getProperty("line.separator")).append(System.getProperty("line.separator"));
      }
      sb.append(taggingResult.first);
      detailContent.setText(sb.toString());
    }
  }
  private void tagChecklistNote(Pair<String, List<Tag>> taggingResult) {
    StringBuilder sb;
    var checkListItem = mChecklistManager.getFocusedItemView();
    if (checkListItem != null) {
      sb = new StringBuilder(checkListItem.getText());
      if (!taggingResult.first.isEmpty()) {
        sb.insert(contentCursorPosition, " " + taggingResult.first + " ");
      }
      checkListItem.setText(sb.toString());
      checkListItem.getEditText().setSelection(contentCursorPosition + taggingResult.first.length() + 1);
    } else {
      binding.detailTitle.append(" " + taggingResult.first);
    }
  }
  private void eventuallyRemoveDeselectedTags(List<Tag> tagsToRemove) {
    if (CollectionUtils.isEmpty(tagsToRemove)) {
      return;
    }
    boolean currentlyChecklist = Boolean.TRUE.equals(noteTmp.isChecklist());
    if (currentlyChecklist) {
      toggleChecklist2(true, true);
    }
    String titleWithoutTags = TagsHelper.removeTags(getNoteTitle(), tagsToRemove);
    binding.detailTitle.setText(titleWithoutTags);
    String contentWithoutTags = TagsHelper.removeTags(getNoteContent(), tagsToRemove);
    binding.fragmentDetailContent.detailContent.setText(contentWithoutTags);
    if (currentlyChecklist) {
      toggleChecklist2();
    }
  }
  private int getCursorIndex() {
    if (Boolean.TRUE.equals(noteTmp.isChecklist())) {
      CheckListViewItem mCheckListViewItem = mChecklistManager.getFocusedItemView();
      return mCheckListViewItem != null ? mCheckListViewItem.getEditText().getSelectionStart() : 0;
    } else {
      return binding.fragmentDetailContent.detailContent.getSelectionStart();
    }
  }
  public Note getCurrentNote() {
    return note;
  }
  private boolean isNoteLocationValid() {
    return noteTmp.getLatitude() != null
        && noteTmp.getLatitude() != 0
        && noteTmp.getLongitude() != null
        && noteTmp.getLongitude() != 0;
  }
  public void startGetContentAction() {
    Intent filesIntent;
    filesIntent = new Intent(Intent.ACTION_GET_CONTENT);
    filesIntent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true);
    filesIntent.addCategory(Intent.CATEGORY_OPENABLE);
    filesIntent.setType("*
  @SuppressLint("InlinedApi")
  private class AttachmentOnClickListener implements OnClickListener {
    @Override
    public void onClick(View v) {
      switch (v.getId()) {
        case R.id.camera:
          takePhoto();
          break;
        case R.id.recording:
          if (!isRecording) {
            startRecording(v);
          } else {
            stopRecording();
            Attachment attachment = new Attachment(Uri.fromFile(new File(recordName)),
                MIME_TYPE_AUDIO);
            attachment.setLength(audioRecordingTime);
            addAttachment(attachment);
            mAttachmentAdapter.notifyDataSetChanged();
            mGridView.autoresize();
          }
          break;
        case R.id.video:
          takeVideo();
          break;
        case R.id.files:
          startGetContentAction();
          break;
        case R.id.sketch:
          takeSketch(null);
          break;
        case R.id.location:
          displayLocationDialog();
          break;
        case R.id.timestamp:
          addTimestamp();
          break;
        case R.id.pushbullet:
          MessagingExtension.mirrorMessage(mainActivity, getString(R.string.app_name),
              getString(R.string.pushbullet),
              getNoteContent(), BitmapFactory.decodeResource(getResources(),
                  R.drawable.ic_stat_literal_icon),
              null, 0);
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + v.getId());
      }
      if (!isRecording) {
        attachmentDialog.dismiss();
      }
    }
  }
}
package it.feio.android.omninotes.db;
import static android.database.sqlite.SQLiteDatabase.CONFLICT_REPLACE;
import static it.feio.android.checklistview.interfaces.Constants.UNCHECKED_SYM;
import static it.feio.android.omninotes.utils.Constants.DATABASE_NAME;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_FILES;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_SKETCH;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FILTER_ARCHIVED_IN_CATEGORIES;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FILTER_PAST_REMINDERS;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_SORTING_COLUMN;
import static it.feio.android.omninotes.utils.ConstantsBase.TIMESTAMP_UNIX_EPOCH;
import static it.feio.android.omninotes.utils.Navigation.checkNavigation;
import static java.util.regex.Pattern.MULTILINE;
import static java.util.stream.Collectors.toList;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.net.Uri;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.async.upgrade.UpgradeProcessor;
import it.feio.android.omninotes.exceptions.DatabaseException;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.NotesHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.Stats;
import it.feio.android.omninotes.models.Tag;
import it.feio.android.omninotes.utils.AssetUtils;
import it.feio.android.omninotes.utils.Navigation;
import it.feio.android.omninotes.utils.Security;
import it.feio.android.omninotes.utils.TagsHelper;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.regex.Pattern;
import org.apache.commons.lang3.StringUtils;
public class DbHelper extends SQLiteOpenHelper {
  private static final int DATABASE_VERSION = 625;
  private static final String SQL_DIR = "sql";
  public static final String TABLE_NOTES = "notes";
  public static final String KEY_ID = "creation";
  public static final String KEY_CREATION = "creation";
  public static final String KEY_LAST_MODIFICATION = "last_modification";
  public static final String KEY_TITLE = "title";
  public static final String KEY_CONTENT = "content";
  public static final String KEY_ARCHIVED = "archived";
  public static final String KEY_TRASHED = "trashed";
  public static final String KEY_REMINDER = "alarm";
  public static final String KEY_REMINDER_FIRED = "reminder_fired";
  public static final String KEY_RECURRENCE_RULE = "recurrence_rule";
  public static final String KEY_LATITUDE = "latitude";
  public static final String KEY_LONGITUDE = "longitude";
  public static final String KEY_ADDRESS = "address";
  public static final String KEY_CATEGORY = "category_id";
  public static final String KEY_LOCKED = "locked";
  public static final String KEY_CHECKLIST = "checklist";
  public static final String TABLE_ATTACHMENTS = "attachments";
  public static final String KEY_ATTACHMENT_ID = "attachment_id";
  public static final String KEY_ATTACHMENT_URI = "uri";
  public static final String KEY_ATTACHMENT_NAME = "name";
  public static final String KEY_ATTACHMENT_SIZE = "size";
  public static final String KEY_ATTACHMENT_LENGTH = "length";
  public static final String KEY_ATTACHMENT_MIME_TYPE = "mime_type";
  public static final String KEY_ATTACHMENT_NOTE_ID = "note_id";
  public static final String TABLE_CATEGORY = "categories";
  public static final String KEY_CATEGORY_ID = "category_id";
  public static final String KEY_CATEGORY_NAME = "name";
  public static final String KEY_CATEGORY_DESCRIPTION = "description";
  public static final String KEY_CATEGORY_COLOR = "color";
  private static final String CREATE_QUERY = "create.sql";
  private static final String UPGRADE_QUERY_PREFIX = "upgrade-";
  private static final String UPGRADE_QUERY_SUFFIX = ".sql";
  private final Context mContext;
  private static DbHelper instance = null;
  private SQLiteDatabase db;
  public static synchronized DbHelper getInstance() {
    return getInstance(OmniNotes.getAppContext());
  }
  public static synchronized DbHelper getInstance(Context context) {
    if (instance == null) {
      instance = new DbHelper(context);
    }
    return instance;
  }
  public static synchronized DbHelper getInstance(boolean forcedNewInstance) {
    if (instance == null || forcedNewInstance) {
      Context context = (instance == null || instance.mContext == null) ? OmniNotes.getAppContext()
          : instance.mContext;
      instance = new DbHelper(context);
    }
    return instance;
  }
  private DbHelper(Context mContext) {
    super(mContext, DATABASE_NAME, null, DATABASE_VERSION);
    this.mContext = mContext;
  }
  public String getDatabaseName() {
    return DATABASE_NAME;
  }
  public SQLiteDatabase getDatabase() {
    return getDatabase(false);
  }
  public SQLiteDatabase getDatabase(boolean forceWritable) {
    try {
      return forceWritable ? getWritableDatabase() : getReadableDatabase();
    } catch (IllegalStateException e) {
      return this.db;
    }
  }
  @Override
  public void onOpen(SQLiteDatabase db) {
    db.disableWriteAheadLogging();
    super.onOpen(db);
  }
  @Override
  public void onCreate(SQLiteDatabase db) {
    try {
      LogDelegate.i("Database creation");
      execSqlFile(CREATE_QUERY, db);
    } catch (IOException e) {
      throw new DatabaseException("Database creation failed: " + e.getMessage(), e);
    }
  }
  @Override
  public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    this.db = db;
    LogDelegate.i("Upgrading database version from " + oldVersion + " to " + newVersion);
    try {
      UpgradeProcessor.process(oldVersion, newVersion);
      for (String sqlFile : AssetUtils.list(SQL_DIR, mContext.getAssets())) {
        if (sqlFile.startsWith(UPGRADE_QUERY_PREFIX)) {
          int fileVersion = Integer.parseInt(sqlFile.substring(UPGRADE_QUERY_PREFIX.length(),
              sqlFile.length() - UPGRADE_QUERY_SUFFIX.length()));
          if (fileVersion > oldVersion && fileVersion <= newVersion) {
            execSqlFile(sqlFile, db);
          }
        }
      }
      LogDelegate.i("Database upgrade successful");
    } catch (IOException | InvocationTargetException | IllegalAccessException e) {
      throw new RuntimeException("Database upgrade failed", e);
    }
  }
  public Note updateNote(Note note, boolean updateLastModification) {
    db = getDatabase(true);
    String content = Boolean.TRUE.equals(note.isLocked())
        ? Security.encrypt(note.getContent(), Prefs.getString(PREF_PASSWORD, ""))
        : note.getContent();
    db.beginTransaction();
    ContentValues values = new ContentValues();
    values.put(KEY_TITLE, note.getTitle());
    values.put(KEY_CONTENT, content);
    values.put(KEY_CREATION,
        note.getCreation() != null ? note.getCreation() : Calendar.getInstance().getTimeInMillis());
    long lastModification = note.getLastModification() != null && !updateLastModification
        ? note.getLastModification()
        : Calendar.getInstance().getTimeInMillis();
    values.put(KEY_LAST_MODIFICATION, lastModification);
    values.put(KEY_ARCHIVED, note.isArchived());
    values.put(KEY_TRASHED, note.isTrashed());
    values.put(KEY_REMINDER, note.getAlarm());
    values.put(KEY_REMINDER_FIRED, note.isReminderFired());
    values.put(KEY_RECURRENCE_RULE, note.getRecurrenceRule());
    values.put(KEY_LATITUDE, note.getLatitude());
    values.put(KEY_LONGITUDE, note.getLongitude());
    values.put(KEY_ADDRESS, note.getAddress());
    values.put(KEY_CATEGORY, note.getCategory() != null ? note.getCategory().getId() : null);
    values.put(KEY_LOCKED, note.isLocked() != null && note.isLocked());
    values.put(KEY_CHECKLIST, note.isChecklist() != null && note.isChecklist());
    db.insertWithOnConflict(TABLE_NOTES, KEY_ID, values, CONFLICT_REPLACE);
    LogDelegate.d("Updated note titled '" + note.getTitle() + "'");
    List<Attachment> deletedAttachments = note.getAttachmentsListOld();
    for (Attachment attachment : note.getAttachmentsList()) {
      updateAttachment(note.get_id() != null ? note.get_id() : values.getAsLong(KEY_CREATION),
          attachment, db);
      deletedAttachments.remove(attachment);
    }
    for (Attachment attachmentDeleted : deletedAttachments) {
      db.delete(TABLE_ATTACHMENTS, KEY_ATTACHMENT_ID + " = ?",
          new String[]{String.valueOf(attachmentDeleted.getId())});
    }
    db.setTransactionSuccessful();
    db.endTransaction();
    note.setCreation(
        note.getCreation() != null ? note.getCreation() : values.getAsLong(KEY_CREATION));
    note.setLastModification(values.getAsLong(KEY_LAST_MODIFICATION));
    return note;
  }
  private void execSqlFile(String sqlFile, SQLiteDatabase db) throws SQLException, IOException {
    LogDelegate.i("  exec sql file: {}" + sqlFile);
    for (String sqlInstruction : SqlParser
        .parseSqlFile(SQL_DIR + "/" + sqlFile, mContext.getAssets())) {
      LogDelegate.v("    sql: {}" + sqlInstruction);
      try {
        db.execSQL(sqlInstruction);
      } catch (Exception e) {
        LogDelegate.e("Error executing command: " + sqlInstruction, e);
      }
    }
  }
  public Attachment updateAttachment(Attachment attachment) {
    var noteId = attachment.getNoteId() != null ? attachment.getNoteId() : -1;
    return updateAttachment(noteId, attachment, getDatabase(true));
  }
  public Attachment updateAttachment(long noteId, Attachment attachment, SQLiteDatabase db) {
    var valuesAttachments = new ContentValues();
    valuesAttachments.put(KEY_ATTACHMENT_ID,
        attachment.getId() != null ? attachment.getId() : Calendar.getInstance().getTimeInMillis());
    valuesAttachments.put(KEY_ATTACHMENT_NOTE_ID, noteId);
    valuesAttachments.put(KEY_ATTACHMENT_URI, attachment.getUri().toString());
    valuesAttachments.put(KEY_ATTACHMENT_MIME_TYPE, attachment.getMime_type());
    valuesAttachments.put(KEY_ATTACHMENT_NAME, attachment.getName());
    valuesAttachments.put(KEY_ATTACHMENT_SIZE, attachment.getSize());
    valuesAttachments.put(KEY_ATTACHMENT_LENGTH, attachment.getLength());
    db.insertWithOnConflict(TABLE_ATTACHMENTS, KEY_ATTACHMENT_ID, valuesAttachments, CONFLICT_REPLACE);
    return attachment;
  }
  public Note getNote(long id) {
    List<Note> notes = getNotes(" WHERE " + KEY_ID + " = " + id, true);
    return notes.isEmpty() ? null : notes.get(0);
  }
  public List<Note> getAllNotes(Boolean checkNavigation) {
    String whereCondition = "";
    if (Boolean.TRUE.equals(checkNavigation)) {
      int navigation = Navigation.getNavigation();
      switch (navigation) {
        case Navigation.NOTES:
          return getNotesActive();
        case Navigation.ARCHIVE:
          return getNotesArchived();
        case Navigation.REMINDERS:
          return getNotesWithReminder(Prefs.getBoolean(PREF_FILTER_PAST_REMINDERS, false));
        case Navigation.TRASH:
          return getNotesTrashed();
        case Navigation.UNCATEGORIZED:
          return getNotesUncategorized();
        case Navigation.CATEGORY:
          return getNotesByCategory(Navigation.getCategory());
        default:
          return getNotes(whereCondition, true);
      }
    } else {
      return getNotes(whereCondition, true);
    }
  }
  public List<Note> getNotesActive() {
    String whereCondition =
        " WHERE " + KEY_ARCHIVED + " IS NOT 1 AND " + KEY_TRASHED + " IS NOT 1 ";
    return getNotes(whereCondition, true);
  }
  public List<Note> getNotesArchived() {
    String whereCondition = " WHERE " + KEY_ARCHIVED + " = 1 AND " + KEY_TRASHED + " IS NOT 1 ";
    return getNotes(whereCondition, true);
  }
  public List<Note> getNotesTrashed() {
    String whereCondition = " WHERE " + KEY_TRASHED + " = 1 ";
    return getNotes(whereCondition, true);
  }
  public List<Note> getNotesUncategorized() {
    String whereCondition = " WHERE "
        + "(" + KEY_CATEGORY_ID + " IS NULL OR " + KEY_CATEGORY_ID + " == 0) "
        + "AND " + KEY_TRASHED + " IS NOT 1";
    return getNotes(whereCondition, true);
  }
  public List<Note> getNotesWithLocation() {
    String whereCondition = " WHERE " + KEY_LONGITUDE + " IS NOT NULL "
        + "AND " + KEY_LONGITUDE + " != 0 ";
    return getNotes(whereCondition, true);
  }
  public List<Note> getNotes(String whereCondition, boolean order) {
    List<Note> noteList = new ArrayList<>();
    String sortColumn = "";
    String sortOrder = "";
    if (checkNavigation(Navigation.REMINDERS)) {
      sortColumn = KEY_REMINDER;
    } else {
      sortColumn = Prefs.getString(PREF_SORTING_COLUMN, KEY_TITLE);
    }
    if (order) {
      sortOrder =
          KEY_TITLE.equals(sortColumn) || KEY_REMINDER.equals(sortColumn) ? " ASC " : " DESC ";
    }
    sortColumn = KEY_TITLE.equals(sortColumn) ? KEY_TITLE + "||" + KEY_CONTENT : sortColumn;
    sortColumn = KEY_REMINDER.equals(sortColumn) ? "IFNULL(" + KEY_REMINDER + ", " +
        "" + TIMESTAMP_UNIX_EPOCH + ")" : sortColumn;
    String query = "SELECT "
        + KEY_CREATION + ","
        + KEY_LAST_MODIFICATION + ","
        + KEY_TITLE + ","
        + KEY_CONTENT + ","
        + KEY_ARCHIVED + ","
        + KEY_TRASHED + ","
        + KEY_REMINDER + ","
        + KEY_REMINDER_FIRED + ","
        + KEY_RECURRENCE_RULE + ","
        + KEY_LATITUDE + ","
        + KEY_LONGITUDE + ","
        + KEY_ADDRESS + ","
        + KEY_LOCKED + ","
        + KEY_CHECKLIST + ","
        + KEY_CATEGORY + ","
        + KEY_CATEGORY_NAME + ","
        + KEY_CATEGORY_DESCRIPTION + ","
        + KEY_CATEGORY_COLOR
        + " FROM " + TABLE_NOTES
        + " LEFT JOIN " + TABLE_CATEGORY + " USING( " + KEY_CATEGORY + ") "
        + whereCondition
        + (order ? " ORDER BY " + sortColumn + " COLLATE NOCASE " + sortOrder : "");
    LogDelegate.v("Query: " + query);
    try (Cursor cursor = getDatabase().rawQuery(query, null)) {
      if (cursor.moveToFirst()) {
        do {
          int i = 0;
          Note note = new Note();
          note.setCreation(cursor.getLong(i++));
          note.setLastModification(cursor.getLong(i++));
          note.setTitle(cursor.getString(i++));
          note.setContent(cursor.getString(i++));
          note.setArchived("1".equals(cursor.getString(i++)));
          note.setTrashed("1".equals(cursor.getString(i++)));
          note.setAlarm(cursor.getString(i++));
          note.setReminderFired(cursor.getInt(i++));
          note.setRecurrenceRule(cursor.getString(i++));
          note.setLatitude(cursor.getString(i++));
          note.setLongitude(cursor.getString(i++));
          note.setAddress(cursor.getString(i++));
          note.setLocked("1".equals(cursor.getString(i++)));
          note.setChecklist("1".equals(cursor.getString(i++)));
          if (Boolean.TRUE.equals(note.isLocked())) {
            note.setContent(
                Security.decrypt(note.getContent(), Prefs.getString(PREF_PASSWORD, "")));
          }
          long categoryId = cursor.getLong(i++);
          if (categoryId != 0) {
            Category category = new Category(categoryId, cursor.getString(i++),
                cursor.getString(i++), cursor.getString(i));
            note.setCategory(category);
          }
          note.setAttachmentsList(getNoteAttachments(note));
          noteList.add(note);
        } while (cursor.moveToNext());
      }
    }
    LogDelegate.v("Query: Retrieval finished!");
    return noteList;
  }
  public void archiveNote(Note note, boolean archive) {
    note.setArchived(archive);
    updateNote(note, false);
  }
  public void trashNote(Note note, boolean trash) {
    note.setTrashed(trash);
    updateNote(note, false);
  }
  public boolean deleteNote(Note note) {
    return deleteNote(note, false);
  }
  public boolean deleteNote(Note note, boolean keepAttachments) {
    return deleteNote(note.get_id(), keepAttachments);
  }
  public boolean deleteNote(long noteId, boolean keepAttachments) {
    SQLiteDatabase db = getDatabase(true);
    db.delete(TABLE_NOTES, KEY_ID + " = ?", new String[]{String.valueOf(noteId)});
    if (!keepAttachments) {
      db.delete(TABLE_ATTACHMENTS, KEY_ATTACHMENT_NOTE_ID + " = ?",
          new String[]{String.valueOf(noteId)});
    }
    return true;
  }
  public void emptyTrash() {
    for (Note note : getNotesTrashed()) {
      deleteNote(note);
    }
  }
  public List<Note> getNotesByPattern(String pattern) {
    String escapedPattern = escapeSql(pattern);
    int navigation = Navigation.getNavigation();
    String whereCondition = " WHERE "
        + KEY_TRASHED + (navigation == Navigation.TRASH ? " IS 1" : " IS NOT 1")
        + (navigation == Navigation.ARCHIVE ? " AND " + KEY_ARCHIVED + " IS 1" : "")
        + (navigation == Navigation.CATEGORY ? " AND " + KEY_CATEGORY + " = " + Navigation
        .getCategory() : "")
        + (navigation == Navigation.UNCATEGORIZED ? " AND (" + KEY_CATEGORY + " IS NULL OR "
        + KEY_CATEGORY_ID
        + " == 0) " : "")
        + (checkNavigation(Navigation.REMINDERS) ? " AND " + KEY_REMINDER
        + " IS NOT NULL" : "")
        + " AND ("
        + " ( " + KEY_LOCKED + " IS NOT 1 AND (" + KEY_TITLE + " LIKE '%" + escapedPattern
        + "%' ESCAPE '\\' " + " OR "
        +
        KEY_CONTENT + " LIKE '%" + escapedPattern + "%' ESCAPE '\\' ))"
        + " OR ( " + KEY_LOCKED + " = 1 AND " + KEY_TITLE + " LIKE '%" + escapedPattern
        + "%' ESCAPE '\\' )"
        + ")";
    return getNotes(whereCondition, true);
  }
  static String escapeSql(String pattern) {
    return StringUtils.replace(pattern, "'", "''")
        .replace("%", "\\%")
        .replace("_", "\\_");
  }
  public List<Note> getNotesWithReminder(boolean filterPastReminders) {
    String whereCondition = " WHERE " + KEY_REMINDER
        + (filterPastReminders ? " >= " + Calendar.getInstance().getTimeInMillis() : " IS NOT NULL")
        + " AND " + KEY_ARCHIVED + " IS NOT 1"
        + " AND " + KEY_TRASHED + " IS NOT 1";
    return getNotes(whereCondition, true);
  }
  public List<Note> getNotesWithReminderNotFired() {
    String whereCondition = " WHERE " + KEY_REMINDER + " IS NOT NULL"
        + " AND " + KEY_REMINDER_FIRED + " IS NOT 1"
        + " AND " + KEY_ARCHIVED + " IS NOT 1"
        + " AND " + KEY_TRASHED + " IS NOT 1";
    return getNotes(whereCondition, true);
  }
  public List<Note> getNotesWithLock(boolean locked) {
    String whereCondition = " WHERE " + KEY_LOCKED + (locked ? " = 1 " : " IS NOT 1 ");
    return getNotes(whereCondition, true);
  }
  public List<Note> getTodayReminders() {
    String whereCondition =
        " WHERE DATE(" + KEY_REMINDER + "/1000, 'unixepoch') = DATE('now') AND " +
            KEY_TRASHED + " IS NOT 1";
    return getNotes(whereCondition, false);
  }
  public List<Attachment> getNoteAttachments(Note note) {
    String whereCondition = " WHERE " + KEY_ATTACHMENT_NOTE_ID + " = " + note.get_id();
    return getAttachments(whereCondition);
  }
  public List<Note> getChecklists() {
    String whereCondition = " WHERE " + KEY_CHECKLIST + " = 1";
    return getNotes(whereCondition, false);
  }
  public List<Note> getMasked() {
    String whereCondition = " WHERE " + KEY_LOCKED + " = 1";
    return getNotes(whereCondition, false);
  }
  public List<Note> getNotesByCategory(Long categoryId) {
    List<Note> notes;
    boolean filterArchived = Prefs
        .getBoolean(PREF_FILTER_ARCHIVED_IN_CATEGORIES + categoryId, false);
    try {
      String whereCondition = " WHERE "
          + KEY_CATEGORY_ID + " = " + categoryId
          + " AND " + KEY_TRASHED + " IS NOT 1"
          + (filterArchived ? " AND " + KEY_ARCHIVED + " IS NOT 1" : "");
      notes = getNotes(whereCondition, true);
    } catch (NumberFormatException e) {
      notes = getAllNotes(true);
    }
    return notes;
  }
  public List<Tag> getTags() {
    return getTags(null);
  }
  public List<Tag> getTags(Note note) {
    List<Tag> tags = new ArrayList<>();
    HashMap<String, Integer> tagsMap = new HashMap<>();
    String whereCondition = " WHERE "
        + (note != null ? KEY_ID + " = " + note.get_id() + " AND " : "")
        + "(" + KEY_CONTENT + " LIKE '%#%' OR " + KEY_TITLE + " LIKE '%#%' " + ")"
        + " AND " + KEY_TRASHED + " IS " + (checkNavigation(Navigation.TRASH) ? "1" : " NOT 1")
        + " AND " + KEY_LOCKED + " IS NOT 1";
    List<Note> notesRetrieved = getNotes(whereCondition, true);
    for (Note noteRetrieved : notesRetrieved) {
      Map<String, Integer> tagsRetrieved = TagsHelper.retrieveTags(noteRetrieved);
      for (String s : tagsRetrieved.keySet()) {
        int count = tagsMap.get(s) == null ? 0 : tagsMap.get(s);
        tagsMap.put(s, ++count);
      }
    }
    for (Entry<String, Integer> entry : tagsMap.entrySet()) {
      Tag tag = new Tag(entry.getKey(), entry.getValue());
      tags.add(tag);
    }
    Collections.sort(tags, (tag1, tag2) -> tag1.getText().compareToIgnoreCase(tag2.getText()));
    return tags;
  }
  public List<Note> getNotesByTag(String tag) {
    return tag.contains(",")
      ? getNotesByTag(tag.split(","))
      : getNotesByTag(new String[]{tag});
  }
  public List<Note> getNotesByTag(String[] tags) {
    var whereCondition = new StringBuilder();
    whereCondition.append(" WHERE ");
    for (int i = 0; i < tags.length; i++) {
      if (i != 0) {
        whereCondition.append(" AND ");
      }
      whereCondition.append(String.format("((%s IS 1 AND %s LIKE '%%%s%%') OR (%s is NOT 1 AND (%s LIKE '%%%s%%' OR %s LIKE '%%%s%%')))"
          , KEY_LOCKED, KEY_TITLE, tags[i], KEY_LOCKED, KEY_CONTENT, tags[i], KEY_TITLE, tags[i]));
    }
    whereCondition.append(" AND " + KEY_TRASHED + " IS ")
        .append(checkNavigation(Navigation.TRASH) ? "" : "NOT ").append("1");
    return getNotes(whereCondition.toString(), true).stream()
        .map(note -> {
          boolean matches = Arrays.stream(tags)
              .allMatch(tag -> {
                var p = Pattern.compile(".*(\\s|^)" + tag + "(\\s|$).*", MULTILINE);
                return p.matcher((note.getTitle() + " " + note.getContent())).find();
              });
          return matches ? note : null;
        })
        .filter(Objects::nonNull)
        .collect(toList());
  }
  public List<Note> getNotesByUncompleteChecklist() {
    String whereCondition =
        " WHERE " + KEY_CHECKLIST + " = 1 AND " + KEY_CONTENT + " LIKE '%" + UNCHECKED_SYM + "%' AND "
    + KEY_TRASHED + (checkNavigation(Navigation.TRASH) ? " IS 1" : " IS NOT 1");
    return getNotes(whereCondition, true);
  }
  public ArrayList<Attachment> getAllAttachments() {
    return getAttachments("");
  }
  public ArrayList<Attachment> getAttachments(String whereCondition) {
    ArrayList<Attachment> attachmentsList = new ArrayList<>();
    String sql = "SELECT "
        + KEY_ATTACHMENT_ID + ","
        + KEY_ATTACHMENT_URI + ","
        + KEY_ATTACHMENT_NAME + ","
        + KEY_ATTACHMENT_SIZE + ","
        + KEY_ATTACHMENT_LENGTH + ","
        + KEY_ATTACHMENT_MIME_TYPE + ","
        + KEY_ATTACHMENT_NOTE_ID
        + " FROM " + TABLE_ATTACHMENTS
        + whereCondition;
    Cursor cursor = null;
    try {
      cursor = getDatabase().rawQuery(sql, null);
      if (cursor.moveToFirst()) {
        do {
          var attachment = new Attachment(cursor.getLong(0),
              Uri.parse(cursor.getString(1)), cursor.getString(2), cursor.getInt(3),
              cursor.getInt(4), cursor.getString(5));
          attachment.setNoteId(cursor.getLong(6));
          attachmentsList.add(attachment);
        } while (cursor.moveToNext());
      }
    } finally {
      if (cursor != null) {
        cursor.close();
      }
    }
    return attachmentsList;
  }
  public ArrayList<Category> getCategories() {
    ArrayList<Category> categoriesList = new ArrayList<>();
    String sql = "SELECT "
        + KEY_CATEGORY_ID + ","
        + KEY_CATEGORY_NAME + ","
        + KEY_CATEGORY_DESCRIPTION + ","
        + KEY_CATEGORY_COLOR + ","
        + " COUNT(" + KEY_ID + ") count"
        + " FROM " + TABLE_CATEGORY
        + " LEFT JOIN ("
        + " SELECT " + KEY_ID + ", " + KEY_CATEGORY
        + " FROM " + TABLE_NOTES
        + " WHERE " + KEY_TRASHED + " IS NOT 1"
        + ") USING( " + KEY_CATEGORY + ") "
        + " GROUP BY "
        + KEY_CATEGORY_ID + ","
        + KEY_CATEGORY_NAME + ","
        + KEY_CATEGORY_DESCRIPTION + ","
        + KEY_CATEGORY_COLOR
        + " ORDER BY IFNULL(NULLIF(" + KEY_CATEGORY_NAME + ", ''),'zzzzzzzz') ";
    Cursor cursor = null;
    try {
      cursor = getDatabase().rawQuery(sql, null);
      if (cursor.moveToFirst()) {
        do {
          categoriesList.add(new Category(cursor.getLong(0),
              cursor.getString(1), cursor.getString(2), cursor
              .getString(3), cursor.getInt(4)));
        } while (cursor.moveToNext());
      }
    } finally {
      if (cursor != null) {
        cursor.close();
      }
    }
    return categoriesList;
  }
  public Category updateCategory(Category category) {
    ContentValues values = new ContentValues();
    values.put(KEY_CATEGORY_ID, category.getId() != null ? category.getId() : Calendar.getInstance()
        .getTimeInMillis());
    values.put(KEY_CATEGORY_NAME, category.getName());
    values.put(KEY_CATEGORY_DESCRIPTION, category.getDescription());
    values.put(KEY_CATEGORY_COLOR, category.getColor());
    getDatabase(true).insertWithOnConflict(TABLE_CATEGORY, KEY_CATEGORY_ID, values, CONFLICT_REPLACE);
    return category;
  }
  public long deleteCategory(Category category) {
    long deleted;
    SQLiteDatabase db = getDatabase(true);
    ContentValues values = new ContentValues();
    values.putNull(KEY_CATEGORY);
    db.update(TABLE_NOTES, values, KEY_CATEGORY + " = ?",
        new String[]{String.valueOf(category.getId())});
    deleted = db.delete(TABLE_CATEGORY, KEY_CATEGORY_ID + " = ?",
        new String[]{String.valueOf(category.getId())});
    return deleted;
  }
  public Category getCategory(Long id) {
    Category category = null;
    String sql = "SELECT "
        + KEY_CATEGORY_ID + ","
        + KEY_CATEGORY_NAME + ","
        + KEY_CATEGORY_DESCRIPTION + ","
        + KEY_CATEGORY_COLOR
        + " FROM " + TABLE_CATEGORY
        + " WHERE " + KEY_CATEGORY_ID + " = " + id;
    try (Cursor cursor = getDatabase().rawQuery(sql, null)) {
      if (cursor.moveToFirst()) {
        category = new Category(cursor.getLong(0), cursor.getString(1),
            cursor.getString(2), cursor.getString(3));
      }
    }
    return category;
  }
  public int getCategorizedCount(Category category) {
    int count = 0;
    String sql = "SELECT COUNT(*)"
        + " FROM " + TABLE_NOTES
        + " WHERE " + KEY_CATEGORY + " = " + category.getId();
    try (Cursor cursor = getDatabase().rawQuery(sql, null)) {
      if (cursor.moveToFirst()) {
        count = cursor.getInt(0);
      }
    }
    return count;
  }
  public Stats getStats() {
    Stats mStats = new Stats();
    mStats.setCategories(getCategories().size());
    int notesActive = 0;
    int notesArchived = 0;
    int notesTrashed = 0;
    int reminders = 0;
    int remindersFuture = 0;
    int checklists = 0;
    int notesMasked = 0;
    int tags = 0;
    int locations = 0;
    int totalWords = 0;
    int totalChars = 0;
    int maxWords = 0;
    int maxChars = 0;
    int avgWords;
    int avgChars;
    int words;
    int chars;
    List<Note> notes = getAllNotes(false);
    for (Note note : notes) {
      if (Boolean.TRUE.equals(note.isTrashed())) {
        notesTrashed++;
      } else if (note.isArchived()) {
        notesArchived++;
      } else {
        notesActive++;
      }
      if (note.getAlarm() != null && Long.parseLong(note.getAlarm()) > 0) {
        if (Long.parseLong(note.getAlarm()) > Calendar.getInstance().getTimeInMillis()) {
          remindersFuture++;
        } else {
          reminders++;
        }
      }
      if (Boolean.TRUE.equals(note.isChecklist())) {
        checklists++;
      }
      if (Boolean.TRUE.equals(note.isLocked())) {
        notesMasked++;
      }
      tags += TagsHelper.retrieveTags(note).size();
      if (note.getLongitude() != null && note.getLongitude() != 0) {
        locations++;
      }
      words = NotesHelper.getWords(note);
      chars = NotesHelper.getChars(note);
      if (words > maxWords) {
        maxWords = words;
      }
      if (chars > maxChars) {
        maxChars = chars;
      }
      totalWords += words;
      totalChars += chars;
    }
    mStats.setNotesActive(notesActive);
    mStats.setNotesArchived(notesArchived);
    mStats.setNotesTrashed(notesTrashed);
    mStats.setReminders(reminders);
    mStats.setRemindersFutures(remindersFuture);
    mStats.setNotesChecklist(checklists);
    mStats.setNotesMasked(notesMasked);
    mStats.setTags(tags);
    mStats.setLocation(locations);
    avgWords = totalWords / (!notes.isEmpty() ? notes.size() : 1);
    avgChars = totalChars / (!notes.isEmpty() ? notes.size() : 1);
    mStats.setWords(totalWords);
    mStats.setWordsMax(maxWords);
    mStats.setWordsAvg(avgWords);
    mStats.setChars(totalChars);
    mStats.setCharsMax(maxChars);
    mStats.setCharsAvg(avgChars);
    int images = 0;
    int videos = 0;
    int audioRecordings = 0;
    int sketches = 0;
    int files = 0;
    List<Attachment> attachments = getAllAttachments();
    for (Attachment attachment : attachments) {
      if (MIME_TYPE_IMAGE.equals(attachment.getMime_type())) {
        images++;
      } else if (MIME_TYPE_VIDEO.equals(attachment.getMime_type())) {
        videos++;
      } else if (MIME_TYPE_AUDIO.equals(attachment.getMime_type())) {
        audioRecordings++;
      } else if (MIME_TYPE_SKETCH.equals(attachment.getMime_type())) {
        sketches++;
      } else if (MIME_TYPE_FILES.equals(attachment.getMime_type())) {
        files++;
      }
    }
    mStats.setAttachments(attachments.size());
    mStats.setImages(images);
    mStats.setVideos(videos);
    mStats.setAudioRecordings(audioRecordings);
    mStats.setSketches(sketches);
    mStats.setFiles(files);
    return mStats;
  }
  public void setReminderFired(long noteId, boolean fired) {
    ContentValues values = new ContentValues();
    values.put(KEY_REMINDER_FIRED, fired);
    getDatabase(true)
        .update(TABLE_NOTES, values, KEY_ID + " = ?", new String[]{String.valueOf(noteId)});
  }
}
package it.feio.android.omninotes.utils;
import static androidx.core.content.FileProvider.getUriForFile;
import static it.feio.android.omninotes.OmniNotes.getAppContext;
import android.net.Uri;
import androidx.annotation.Nullable;
import it.feio.android.omninotes.models.Attachment;
import java.io.File;
import java.io.FileNotFoundException;
import lombok.experimental.UtilityClass;
@UtilityClass
public class FileProviderHelper {
  public static Uri getFileProvider(File file) {
    return getUriForFile(getAppContext(), getAppContext().getPackageName() + ".authority", file);
  }
  public static @Nullable Uri getShareableUri(Attachment attachment) throws FileNotFoundException {
    var uri = attachment.getUri();
    if (uri.getScheme().equals("content")
        && uri.getAuthority().equals(getAppContext().getPackageName() + ".authority")) {
      return uri;
    }
    File attachmentFile = new File(uri.getPath());
    if (!attachmentFile.exists()) {
      throw new FileNotFoundException("Required attachment not found in " + attachment.getUriPath());
    }
    return getFileProvider(attachmentFile);
  }
}
package it.feio.android.omninotes.utils;
import android.content.Context;
import android.view.View;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import it.feio.android.omninotes.MainActivity;
public class KeyboardUtils {
  private KeyboardUtils() {
  }
  public static void showKeyboard(View view) {
    if (view == null) {
      return;
    }
    view.requestFocus();
    InputMethodManager inputManager = (InputMethodManager) view.getContext().getSystemService(
        Context.INPUT_METHOD_SERVICE);
    inputManager.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);
    ((InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE))
        .showSoftInput(view, 0);
    if (!isKeyboardShowed(view)) {
      inputManager.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0);
    }
  }
  public static boolean isKeyboardShowed(View view) {
    if (view == null) {
      return false;
    }
    InputMethodManager inputManager = (InputMethodManager) view.getContext().getSystemService(
        Context.INPUT_METHOD_SERVICE);
    return inputManager.isActive(view);
  }
  public static void hideKeyboard(View view) {
    if (view == null) {
      return;
    }
    InputMethodManager imm = (InputMethodManager) view.getContext()
        .getSystemService(Context.INPUT_METHOD_SERVICE);
    if (!imm.isActive()) {
      return;
    }
    imm.hideSoftInputFromWindow(view.getWindowToken(), 0);
  }
  public static void hideKeyboard(MainActivity mActivity) {
    mActivity.getWindow().setSoftInputMode(
        WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
  }
}
package it.feio.android.omninotes;
import static android.content.Context.LAYOUT_INFLATER_SERVICE;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Bundle;
import android.provider.MediaStore;
import android.util.DisplayMetrics;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.ImageView;
import android.widget.LinearLayout.LayoutParams;
import android.widget.PopupWindow;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;
import androidx.appcompat.app.AppCompatActivity;
import androidx.fragment.app.Fragment;
import com.afollestad.materialdialogs.MaterialDialog;
import com.larswerkman.holocolorpicker.ColorPicker;
import it.feio.android.checklistview.utils.AlphaManager;
import it.feio.android.omninotes.databinding.FragmentSketchBinding;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.listeners.OnDrawChangedListener;
import it.feio.android.omninotes.models.views.SketchView;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
public class SketchFragment extends Fragment implements OnDrawChangedListener {
  private int seekBarStrokeProgress;
  private int seekBarEraserProgress;
  private View popupLayout;
  private View popupEraserLayout;
  private ImageView strokeImageView;
  private ImageView eraserImageView;
  private int size;
  private ColorPicker mColorPicker;
  private FragmentSketchBinding binding;
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setHasOptionsMenu(true);
    setRetainInstance(false);
  }
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
      Bundle savedInstanceState) {
    binding = FragmentSketchBinding.inflate(inflater, container, false);
    return binding.getRoot();
  }
  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    getMainActivity().getToolbar().setNavigationOnClickListener(v -> getActivity().onBackPressed());
    binding.drawing.setOnDrawChangedListener(this);
    Uri baseUri = getArguments().getParcelable("base");
    if (baseUri != null) {
      Bitmap bmp;
      try {
        bmp = BitmapFactory
            .decodeStream(getActivity().getContentResolver().openInputStream(baseUri));
        binding.drawing.setBackgroundBitmap(getActivity(), bmp);
      } catch (FileNotFoundException e) {
        LogDelegate.e("Error replacing sketch bitmap background", e);
      }
    }
    if (getMainActivity().getSupportActionBar() != null) {
      getMainActivity().getSupportActionBar().setDisplayShowTitleEnabled(true);
      getMainActivity().getSupportActionBar().setTitle(R.string.title_activity_sketch);
      getMainActivity().getSupportActionBar().setDisplayHomeAsUpEnabled(true);
    }
    binding.sketchStroke.setOnClickListener(v -> {
      if (binding.drawing.getMode() == SketchView.STROKE) {
        showPopup(v, SketchView.STROKE);
      } else {
        binding.drawing.setMode(SketchView.STROKE);
        AlphaManager.setAlpha(binding.sketchEraser, 0.4f);
        AlphaManager.setAlpha(binding.sketchStroke, 1f);
      }
    });
    AlphaManager.setAlpha(binding.sketchEraser, 0.4f);
    binding.sketchEraser.setOnClickListener(v -> {
      if (binding.drawing.getMode() == SketchView.ERASER) {
        showPopup(v, SketchView.ERASER);
      } else {
        binding.drawing.setMode(SketchView.ERASER);
        AlphaManager.setAlpha(binding.sketchStroke, 0.4f);
        AlphaManager.setAlpha(binding.sketchEraser, 1f);
      }
    });
    binding.sketchUndo.setOnClickListener(v -> binding.drawing.undo());
    binding.sketchRedo.setOnClickListener(v -> binding.drawing.redo());
    binding.sketchErase.setOnClickListener(new OnClickListener() {
      @Override
      public void onClick(View v) {
        askForErase();
      }
      private void askForErase() {
        new MaterialDialog.Builder(getActivity())
            .content(R.string.erase_sketch)
            .positiveText(R.string.confirm)
            .onPositive((dialog, which) -> binding.drawing.erase()).build().show();
      }
    });
    LayoutInflater inflater = (LayoutInflater) getActivity().getSystemService(
        LAYOUT_INFLATER_SERVICE);
    popupLayout = inflater.inflate(R.layout.popup_sketch_stroke, null);
    LayoutInflater inflaterEraser = (LayoutInflater) getActivity().getSystemService(
        LAYOUT_INFLATER_SERVICE);
    popupEraserLayout = inflaterEraser.inflate(R.layout.popup_sketch_eraser, null);
    strokeImageView = popupLayout.findViewById(R.id.stroke_circle);
    final Drawable circleDrawable = getResources().getDrawable(R.drawable.circle);
    size = circleDrawable.getIntrinsicWidth();
    eraserImageView = popupEraserLayout.findViewById(R.id.stroke_circle);
    size = circleDrawable.getIntrinsicWidth();
    setSeekbarProgress(SketchView.DEFAULT_STROKE_SIZE, SketchView.STROKE);
    setSeekbarProgress(SketchView.DEFAULT_ERASER_SIZE, SketchView.ERASER);
    mColorPicker = popupLayout.findViewById(R.id.stroke_color_picker);
    mColorPicker.addSVBar(popupLayout.findViewById(R.id.svbar));
    mColorPicker.addOpacityBar(popupLayout.findViewById(R.id.opacitybar));
    mColorPicker.setOnColorChangedListener(binding.drawing::setStrokeColor);
    mColorPicker.setColor(binding.drawing.getStrokeColor());
    mColorPicker.setOldCenterColor(binding.drawing.getStrokeColor());
  }
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
    if (item.getItemId() == android.R.id.home) {
      getActivity().onBackPressed();
    } else {
      LogDelegate.e("Wrong element choosen: " + item.getItemId());
    }
    return super.onOptionsItemSelected(item);
  }
  public void save() {
    Bitmap bitmap = binding.drawing.getBitmap();
    if (bitmap != null) {
      try {
        Uri uri = getArguments().getParcelable(MediaStore.EXTRA_OUTPUT);
        File bitmapFile = new File(uri.getPath());
        FileOutputStream out = new FileOutputStream(bitmapFile);
        bitmap.compress(Bitmap.CompressFormat.PNG, 90, out);
        out.close();
        if (bitmapFile.exists()) {
          getMainActivity().setSketchUri(uri);
        } else {
          getMainActivity().showMessage(R.string.error, ONStyle.ALERT);
        }
      } catch (Exception e) {
        LogDelegate.e("Error writing sketch image data", e);
      }
    }
  }
  private void showPopup(View anchor, final int eraserOrStroke) {
    boolean isErasing = eraserOrStroke == SketchView.ERASER;
    int oldColor = mColorPicker.getColor();
    DisplayMetrics metrics = new DisplayMetrics();
    getActivity().getWindowManager().getDefaultDisplay().getMetrics(metrics);
    PopupWindow popup = new PopupWindow(getActivity());
    popup.setContentView(isErasing ? popupEraserLayout : popupLayout);
    popup.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
    popup.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
    popup.setFocusable(true);
    popup.setOnDismissListener(() -> {
      if (mColorPicker.getColor() != oldColor) {
        mColorPicker.setOldCenterColor(oldColor);
      }
    });
    popup.setBackgroundDrawable(new BitmapDrawable());
    popup.showAsDropDown(anchor);
    SeekBar mSeekBar;
    mSeekBar = (SeekBar) (isErasing ? popupEraserLayout
        .findViewById(R.id.stroke_seekbar) : popupLayout
        .findViewById(R.id.stroke_seekbar));
    mSeekBar.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
      @Override
      public void onStopTrackingTouch(SeekBar seekBar) {
      }
      @Override
      public void onStartTrackingTouch(SeekBar seekBar) {
      }
      @Override
      public void onProgressChanged(SeekBar seekBar, int progress,
          boolean fromUser) {
        setSeekbarProgress(progress, eraserOrStroke);
      }
    });
    int progress = isErasing ? seekBarEraserProgress : seekBarStrokeProgress;
    mSeekBar.setProgress(progress);
  }
  protected void setSeekbarProgress(int progress, int eraserOrStroke) {
    int calcProgress = progress > 1 ? progress : 1;
    int newSize = Math.round((size / 100f) * calcProgress);
    int offset = (size - newSize) / 2;
    LogDelegate.v("Stroke size " + newSize + " (" + calcProgress + "%)");
    LayoutParams lp = new LayoutParams(newSize, newSize);
    lp.setMargins(offset, offset, offset, offset);
    if (eraserOrStroke == SketchView.STROKE) {
      strokeImageView.setLayoutParams(lp);
      seekBarStrokeProgress = progress;
    } else {
      eraserImageView.setLayoutParams(lp);
      seekBarEraserProgress = progress;
    }
    binding.drawing.setSize(newSize, eraserOrStroke);
  }
  @Override
  public void onDrawChanged() {
    if (binding.drawing.getPaths().isEmpty()) {
      AlphaManager.setAlpha(binding.sketchUndo, 1f);
    } else {
      AlphaManager.setAlpha(binding.sketchUndo, 0.4f);
    }
    if (binding.drawing.getUndoneCount() > 0) {
      AlphaManager.setAlpha(binding.sketchRedo, 1f);
    } else {
      AlphaManager.setAlpha(binding.sketchRedo, 0.4f);
    }
  }
  private MainActivity getMainActivity() {
    return (MainActivity) getActivity();
  }
}
package it.feio.android.omninotes.async.bus;
import it.feio.android.omninotes.helpers.LogDelegate;
import lombok.Getter;
import lombok.Setter;
public class SwitchFragmentEvent {
  public enum Direction {
    CHILDREN, PARENT
  }
  @Getter
  @Setter
  private Direction direction;
  public SwitchFragmentEvent(Direction direction) {
    LogDelegate.d(this.getClass().getName());
    this.direction = direction;
  }
}
package it.feio.android.omninotes.helpers.notifications;
import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
import static it.feio.android.omninotes.helpers.IntentHelper.immutablePendingIntentFlag;
import android.Manifest.permission;
import android.annotation.TargetApi;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Color;
import android.media.AudioAttributes;
import android.media.RingtoneManager;
import android.net.Uri;
import android.os.Build;
import android.os.Build.VERSION_CODES;
import android.provider.Settings;
import androidx.activity.ComponentActivity;
import androidx.activity.result.contract.ActivityResultContracts.RequestPermission;
import androidx.core.app.NotificationCompat;
import androidx.core.app.NotificationCompat.Builder;
import androidx.core.content.ContextCompat;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.async.bus.NotificationsGrantedEvent;
import it.feio.android.omninotes.helpers.BuildHelper;
import lombok.NonNull;
public class NotificationsHelper {
  private final Context mContext;
  private Builder mBuilder;
  private NotificationManager mNotificationManager;
  public NotificationsHelper(Context mContext) {
    this.mContext = mContext.getApplicationContext();
    if (mNotificationManager == null) {
      mNotificationManager = (NotificationManager) mContext
          .getSystemService(Context.NOTIFICATION_SERVICE);
    }
  }
  @TargetApi(VERSION_CODES.O)
  public void initNotificationChannels() {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.O)) {
      String soundFromPrefs = Prefs.getString("settings_notification_ringtone", null);
      Uri sound = soundFromPrefs != null ? Uri.parse(soundFromPrefs)
          : RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);
      NotificationChannels.channels.forEach(
          (notificationChannelNames, notificationChannel) -> {
            NotificationChannel channel = new NotificationChannel(notificationChannel.id,
                notificationChannel
                    .name, notificationChannel.importance);
            channel.setDescription(notificationChannel.description);
            AudioAttributes audioAttributes = new AudioAttributes.Builder()
                .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
                .setUsage(AudioAttributes.USAGE_NOTIFICATION)
                .build();
            channel.setSound(sound, audioAttributes);
            mNotificationManager.createNotificationChannel(channel);
          });
    }
  }
  @TargetApi(Build.VERSION_CODES.O)
  public void updateNotificationChannelsSound() {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.O)) {
      Intent intent = new Intent(Settings.ACTION_APP_NOTIFICATION_SETTINGS);
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
      intent.putExtra(Settings.EXTRA_APP_PACKAGE, mContext.getPackageName());
      mContext.startActivity(intent);
    }
  }
  public NotificationsHelper createStandardNotification(
      @NonNull NotificationChannels.NotificationChannelNames channelName, int
      smallIcon, String title, PendingIntent notifyIntent) {
    return createNotification(channelName, smallIcon, title, notifyIntent, false);
  }
  public NotificationsHelper createOngoingNotification(
      @NonNull NotificationChannels.NotificationChannelNames channelName, int
      smallIcon, String title, PendingIntent notifyIntent) {
    return createNotification(channelName, smallIcon, title, notifyIntent, true);
  }
  public NotificationsHelper createNotification(
      @NonNull NotificationChannels.NotificationChannelNames channelName, int
      smallIcon, String title, PendingIntent notifyIntent, boolean isOngoing) {
    mBuilder = new NotificationCompat.Builder(mContext,
        NotificationChannels.channels.get(channelName).id)
        .setSmallIcon(smallIcon)
        .setContentTitle(title)
        .setAutoCancel(!isOngoing)
        .setOngoing(isOngoing)
        .setColor(mContext.getResources().getColor(R.color.colorAccent))
        .setContentIntent(notifyIntent);
    setLargeIcon(R.drawable.logo_notification_lollipop);
    return this;
  }
  public Builder getBuilder() {
    return mBuilder;
  }
  public NotificationsHelper setLargeIcon(Bitmap largeIconBitmap) {
    mBuilder.setLargeIcon(largeIconBitmap);
    return this;
  }
  public NotificationsHelper setLargeIcon(int largeIconResource) {
    Bitmap largeIconBitmap = BitmapFactory
        .decodeResource(mContext.getResources(), largeIconResource);
    return setLargeIcon(largeIconBitmap);
  }
  public NotificationsHelper setRingtone(String ringtone) {
    if (ringtone != null && BuildHelper.isBelow(VERSION_CODES.O)) {
      mBuilder.setSound(Uri.parse(ringtone));
    }
    return this;
  }
  public NotificationsHelper setVibration() {
    return setVibration(null);
  }
  public NotificationsHelper setVibration(long[] pattern) {
    if (pattern == null || pattern.length == 0) {
      pattern = new long[]{500, 500};
    }
    mBuilder.setVibrate(pattern);
    return this;
  }
  public NotificationsHelper setLedActive() {
    mBuilder.setLights(Color.BLUE, 1000, 1000);
    return this;
  }
  public NotificationsHelper setIcon(int icon) {
    mBuilder.setSmallIcon(icon);
    return this;
  }
  public NotificationsHelper setMessage(String message) {
    mBuilder.setContentText(message);
    return this;
  }
  public NotificationsHelper setIndeterminate() {
    mBuilder.setProgress(0, 0, true);
    return this;
  }
  public NotificationsHelper setOngoing() {
    mBuilder.setOngoing(true);
    return this;
  }
  public NotificationsHelper show() {
    show(0);
    return this;
  }
  public NotificationsHelper show(long id) {
    var mNotification = mBuilder.build();
    if (mNotification.contentIntent == null) {
      var emptyExplicitIntent = new Intent(mContext, MainActivity.class);
      var pendingIntent = PendingIntent.getActivity(mContext, 0, emptyExplicitIntent,
          immutablePendingIntentFlag(FLAG_UPDATE_CURRENT));
      mBuilder.setContentIntent(pendingIntent);
    }
    mNotificationManager.notify(String.valueOf(id), 0, mBuilder.build());
    return this;
  }
  public NotificationsHelper start(NotificationChannels.NotificationChannelNames channelName, int
      smallIcon, String title) {
    createStandardNotification(channelName, smallIcon, title, null).setIndeterminate().setOngoing();
    mNotificationManager.notify(0, mBuilder.setOnlyAlertOnce(true).build());
    return this;
  }
  public void updateMessage(String message) {
    updateMessage(0, message);
  }
  public void updateMessage(int id, String message) {
    mNotificationManager.notify(id, mBuilder.setContentText(message).build());
  }
  public void finish(String title, String message) {
    finish(0, title, message);
  }
  public void finish(int id, String title, String message) {
    mBuilder.setContentTitle(title).setContentText(message)
        .setProgress(0, 0, false).setOngoing(false);
    mNotificationManager.notify(id, mBuilder.build());
  }
  public void cancel() {
    mNotificationManager.cancel(0);
  }
  public void cancel(int id) {
    mNotificationManager.cancel(id);
  }
  public boolean checkNotificationsEnabled(Context context) {
    return BuildHelper.isBelow(VERSION_CODES.TIRAMISU)
        || BuildHelper.isDebugBuild()
        || ContextCompat.checkSelfPermission(context, permission.POST_NOTIFICATIONS)
        == PackageManager.PERMISSION_GRANTED;
  }
  public void askToEnableNotifications(ComponentActivity activity) {
    if (BuildHelper.isAboveOrEqual(VERSION_CODES.TIRAMISU)) {
      if (!checkNotificationsEnabled(activity)) {
        activity.registerForActivityResult(new RequestPermission(),
                isGranted -> EventBus.getDefault().post(new NotificationsGrantedEvent(isGranted)))
            .launch(permission.POST_NOTIFICATIONS);
      } else {
        EventBus.getDefault().post(new NotificationsGrantedEvent(true));
      }
    } else {
      EventBus.getDefault().post(new NotificationsGrantedEvent(true));
    }
  }
}
package it.feio.android.omninotes;
import static it.feio.android.omninotes.async.bus.SwitchFragmentEvent.Direction.CHILDREN;
import android.animation.ValueAnimator;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.DecelerateInterpolator;
import androidx.appcompat.app.ActionBarDrawerToggle;
import androidx.core.view.GravityCompat;
import androidx.drawerlayout.widget.DrawerLayout;
import androidx.fragment.app.Fragment;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.async.CategoryMenuTask;
import it.feio.android.omninotes.async.MainMenuTask;
import it.feio.android.omninotes.async.bus.CategoriesUpdatedEvent;
import it.feio.android.omninotes.async.bus.DynamicNavigationReadyEvent;
import it.feio.android.omninotes.async.bus.NavigationUpdatedEvent;
import it.feio.android.omninotes.async.bus.NavigationUpdatedNavDrawerClosedEvent;
import it.feio.android.omninotes.async.bus.NotesDeletedEvent;
import it.feio.android.omninotes.async.bus.NotesLoadedEvent;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import it.feio.android.omninotes.async.bus.SwitchFragmentEvent;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.NavigationItem;
import it.feio.android.omninotes.utils.Display;
public class NavigationDrawerFragment extends Fragment {
  static final int BURGER = 0;
  static final int ARROW = 1;
  ActionBarDrawerToggle mDrawerToggle;
  DrawerLayout mDrawerLayout;
  private MainActivity mActivity;
  private boolean alreadyInitialized;
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setRetainInstance(true);
  }
  @Override
  public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
  }
  @Override
  public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
  }
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
      Bundle savedInstanceState) {
    return inflater.inflate(R.layout.fragment_navigation_drawer, container, false);
  }
  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    mActivity = (MainActivity) getActivity();
    init();
  }
  private MainActivity getMainActivity() {
    return (MainActivity) getActivity();
  }
  public void onEventMainThread(DynamicNavigationReadyEvent event) {
    if (alreadyInitialized) {
      alreadyInitialized = false;
    } else {
      refreshMenus();
    }
  }
  public void onEvent(CategoriesUpdatedEvent event) {
    refreshMenus();
  }
  public void onEventAsync(NotesUpdatedEvent event) {
    alreadyInitialized = false;
  }
  public void onEvent(NotesLoadedEvent event) {
    if (mDrawerLayout != null && (!isDoublePanelActive())) {
        mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED);
    }
    if (getMainActivity().getSupportFragmentManager().getBackStackEntryCount() == 0) {
      init();
    }
    refreshMenus();
    alreadyInitialized = true;
  }
  public void onEvent(SwitchFragmentEvent event) {
    if (CHILDREN.equals(event.getDirection())) {
      animateBurger(ARROW);
    } else {
      animateBurger(BURGER);
    }
  }
  public void onEvent(NavigationUpdatedEvent navigationUpdatedEvent) {
    if (navigationUpdatedEvent.navigationItem.getClass().isAssignableFrom(NavigationItem.class)) {
      mActivity.getSupportActionBar()
          .setTitle(((NavigationItem) navigationUpdatedEvent.navigationItem).getText());
    } else {
      mActivity.getSupportActionBar()
          .setTitle(((Category) navigationUpdatedEvent.navigationItem).getName());
    }
    if (mDrawerLayout != null) {
      if (!isDoublePanelActive()) {
        mDrawerLayout.closeDrawer(GravityCompat.START);
      }
      new Handler()
          .postDelayed(() -> EventBus.getDefault().post(new NavigationUpdatedNavDrawerClosedEvent
              (navigationUpdatedEvent.navigationItem)), 400);
    }
  }
  public void onEventAsync(NotesDeletedEvent event) {
    refreshMenus();
  }
  public void init() {
    LogDelegate.v("Started navigation drawer initialization");
    mDrawerLayout = mActivity.findViewById(R.id.drawer_layout);
    mDrawerLayout.setFocusableInTouchMode(false);
    View leftDrawer = getView().findViewById(R.id.left_drawer);
    int leftDrawerBottomPadding = Display.getNavigationBarHeightKitkat(getActivity());
    leftDrawer.setPadding(leftDrawer.getPaddingLeft(), leftDrawer.getPaddingTop(),
        leftDrawer.getPaddingRight(),
        leftDrawerBottomPadding);
    mDrawerToggle = new ActionBarDrawerToggle(mActivity,
        mDrawerLayout,
        getMainActivity().getToolbar(),
        R.string.drawer_open,
        R.string.drawer_close
    ) {
      @Override
      public void onDrawerClosed(View view) {
        mActivity.supportInvalidateOptionsMenu();
      }
      @Override
      public void onDrawerOpened(View drawerView) {
        mActivity.commitPending();
        mActivity.finishActionMode();
      }
    };
    if (isDoublePanelActive()) {
      mDrawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_OPEN);
    }
    mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);
    mDrawerLayout.addDrawerListener(mDrawerToggle);
    mDrawerToggle.setDrawerIndicatorEnabled(true);
    LogDelegate.v("Finished navigation drawer initialization");
  }
  private void refreshMenus() {
    buildMainMenu();
    LogDelegate.v("Finished main menu initialization");
    buildCategoriesMenu();
    LogDelegate.v("Finished categories menu initialization");
    mDrawerToggle.syncState();
  }
  private void buildCategoriesMenu() {
    CategoryMenuTask task = new CategoryMenuTask(this);
    task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
  private void buildMainMenu() {
    MainMenuTask task = new MainMenuTask(this);
    task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
  }
  void animateBurger(int targetShape) {
    if (mDrawerToggle != null) {
      if (targetShape != BURGER && targetShape != ARROW) {
        return;
      }
      ValueAnimator anim = ValueAnimator.ofFloat((targetShape + 1) % 2, targetShape);
      anim.addUpdateListener(valueAnimator -> {
        float slideOffset = (Float) valueAnimator.getAnimatedValue();
        mDrawerToggle.onDrawerSlide(mDrawerLayout, slideOffset);
      });
      anim.setInterpolator(new DecelerateInterpolator());
      anim.setDuration(500);
      anim.start();
    }
  }
  public static boolean isDoublePanelActive() {
    return false;
  }
}
package it.feio.android.omninotes;
import static android.content.DialogInterface.BUTTON_POSITIVE;
import static android.text.Html.fromHtml;
import static android.text.TextUtils.isEmpty;
import static androidx.core.view.ViewCompat.animate;
import static it.feio.android.omninotes.helpers.BuildHelper.isDebugBuild;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_FAB_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_MERGE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_POSTPONE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SEARCH_UNCOMPLETE_CHECKLISTS;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_SHOW_LIST;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_CATEGORY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.MENU_SORT_GROUP_ID;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_ENABLE_SWIPE;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_EXPANDED_VIEW;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FAB_EXPANSION_BEHAVIOR;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FILTER_ARCHIVED_IN_CATEGORIES;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_FILTER_PAST_REMINDERS;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_SORTING_COLUMN;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_WIDGET_PREFIX;
import static it.feio.android.omninotes.utils.Navigation.checkNavigation;
import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.SearchManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.drawable.AnimationDrawable;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.Parcelable;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MenuItem.OnActionExpandListener;
import android.view.MotionEvent;
import android.view.SubMenu;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.EditorInfo;
import android.widget.ImageView;
import android.widget.LinearLayout;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AlertDialog;
import androidx.appcompat.view.ActionMode;
import androidx.appcompat.widget.SearchView;
import androidx.appcompat.widget.SearchView.OnQueryTextListener;
import androidx.core.util.Pair;
import androidx.core.view.GravityCompat;
import androidx.recyclerview.widget.DefaultItemAnimator;
import androidx.recyclerview.widget.DividerItemDecoration;
import androidx.recyclerview.widget.ItemTouchHelper;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import com.afollestad.materialdialogs.MaterialDialog;
import com.google.android.material.dialog.MaterialAlertDialogBuilder;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import de.keyboardsurfer.android.widget.crouton.Crouton;
import de.keyboardsurfer.android.widget.crouton.Style;
import it.feio.android.omninotes.async.bus.CategoriesUpdatedEvent;
import it.feio.android.omninotes.async.bus.NavigationUpdatedNavDrawerClosedEvent;
import it.feio.android.omninotes.async.bus.NotesLoadedEvent;
import it.feio.android.omninotes.async.bus.NotesMergeEvent;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import it.feio.android.omninotes.async.bus.PasswordRemovedEvent;
import it.feio.android.omninotes.async.notes.NoteLoaderTask;
import it.feio.android.omninotes.async.notes.NoteProcessorArchive;
import it.feio.android.omninotes.async.notes.NoteProcessorCategorize;
import it.feio.android.omninotes.async.notes.NoteProcessorDelete;
import it.feio.android.omninotes.async.notes.NoteProcessorTrash;
import it.feio.android.omninotes.databinding.FragmentListBinding;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.NotesHelper;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.PasswordValidator;
import it.feio.android.omninotes.models.Tag;
import it.feio.android.omninotes.models.UndoBarController;
import it.feio.android.omninotes.models.adapters.CategoryRecyclerViewAdapter;
import it.feio.android.omninotes.models.adapters.NoteAdapter;
import it.feio.android.omninotes.models.listeners.OnViewTouchedListener;
import it.feio.android.omninotes.models.listeners.RecyclerViewItemClickSupport;
import it.feio.android.omninotes.models.views.Fab;
import it.feio.android.omninotes.utils.AnimationsHelper;
import it.feio.android.omninotes.utils.IntentChecker;
import it.feio.android.omninotes.utils.KeyboardUtils;
import it.feio.android.omninotes.utils.Navigation;
import it.feio.android.omninotes.utils.PasswordHelper;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.TagsHelper;
import it.feio.android.omninotes.utils.TextHelper;
import it.feio.android.pixlui.links.UrlCompleter;
import it.feio.android.simplegallery.util.BitmapUtils;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.stream.IntStream;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.ObjectUtils;
public class ListFragment extends BaseFragment implements OnViewTouchedListener,
    UndoBarController.UndoListener {
  private static final int REQUEST_CODE_CATEGORY = 1;
  private static final int REQUEST_CODE_CATEGORY_NOTES = 2;
  private static final int REQUEST_CODE_ADD_ALARMS = 3;
  public static final String LIST_VIEW_POSITION = "listViewPosition";
  public static final String LIST_VIEW_POSITION_OFFSET = "listViewPositionOffset";
  private FragmentListBinding binding;
  private final List<Note> selectedNotes = new ArrayList<>();
  private SearchView searchView;
  private MenuItem searchMenuItem;
  private Menu menu;
  private AnimationDrawable jinglesAnimation;
  private int listViewPosition;
  private int listViewPositionOffset = 16;
  private boolean sendToArchive;
  private ListFragment mFragment;
  private ActionMode actionMode;
  private boolean keepActionMode = false;
  private boolean undoTrash = false;
  private boolean undoArchive = false;
  private boolean undoCategorize = false;
  private Category undoCategorizeCategory = null;
  private final SortedMap<Integer, Note> undoNotesMap = new TreeMap<>();
  private final Map<Note, Category> undoCategoryMap = new HashMap<>();
  private final Map<Note, Boolean> undoArchivedMap = new HashMap<>();
  private String searchQuery;
  private String searchQueryInstant;
  private String searchTags;
  private boolean searchUncompleteChecklists;
  private boolean goBackOnToggleSearchLabel = false;
  private boolean searchLabelActive = false;
  private NoteAdapter listAdapter;
  private UndoBarController ubc;
  private Fab fab;
  private MainActivity mainActivity;
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mFragment = this;
    setHasOptionsMenu(true);
    setRetainInstance(true);
    EventBus.getDefault().register(this, 1);
  }
  @Override
  public void onDestroy() {
    super.onDestroy();
    EventBus.getDefault().unregister(this);
  }
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
      Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      if (savedInstanceState.containsKey(LIST_VIEW_POSITION)) {
        listViewPosition = savedInstanceState.getInt(LIST_VIEW_POSITION);
        listViewPositionOffset = savedInstanceState.getInt(LIST_VIEW_POSITION_OFFSET);
        searchQuery = savedInstanceState.getString("searchQuery");
        searchTags = savedInstanceState.getString("searchTags");
      }
      keepActionMode = false;
    }
    binding = FragmentListBinding.inflate(inflater, container, false);
    View view = binding.getRoot();
    binding.list.setHasFixedSize(true);
    LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getContext());
    binding.list.setLayoutManager(linearLayoutManager);
    DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(
        binding.list.getContext(),
        linearLayoutManager.getOrientation());
    dividerItemDecoration
        .setDrawable(getResources().getDrawable(R.drawable.fragment_list_item_divider));
    binding.list.addItemDecoration(dividerItemDecoration);
    RecyclerView.ItemAnimator itemAnimator = new DefaultItemAnimator();
    itemAnimator.setAddDuration(1000);
    itemAnimator.setRemoveDuration(1000);
    binding.list.setItemAnimator(itemAnimator);
    binding.list.setEmptyView(binding.emptyList);
    return view;
  }
  @Override
  public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    mainActivity = (MainActivity) getActivity();
    if (mainActivity!= null && savedInstanceState != null) {
      mainActivity.navigationTmp = savedInstanceState.getString("navigationTmp");
    }
    init();
  }
  private void init() {
    initEasterEgg();
    initListView();
    ubc = new UndoBarController(binding.undobar.getRoot(), this);
    initNotesList(mainActivity.getIntent());
    initFab();
    initTitle();
  }
  private void initFab() {
    fab = new Fab(binding.fab.getRoot(), binding.list,
        Prefs.getBoolean(PREF_FAB_EXPANSION_BEHAVIOR, false));
    fab.setOnFabItemClickedListener(id -> {
      View v = mainActivity.findViewById(id);
      switch (id) {
        case R.id.fab_camera:
          Intent i = mainActivity.getIntent();
          i.setAction(ACTION_FAB_TAKE_PHOTO);
          mainActivity.setIntent(i);
          editNote(new Note(), v);
          break;
        case R.id.fab_checklist:
          Note note = new Note();
          note.setChecklist(true);
          editNote(note, v);
          break;
        default:
          editNote(new Note(), v);
      }
    });
  }
  boolean closeFab() {
    if (fab != null && fab.isExpanded()) {
      fab.performToggle();
      return true;
    }
    return false;
  }
  private void initTitle() {
    String[] navigationList = getResources().getStringArray(R.array.navigation_list);
    String[] navigationListCodes = getResources().getStringArray(R.array.navigation_list_codes);
    String navigation = mainActivity.navigationTmp != null
        ? mainActivity.navigationTmp
        : Prefs.getString (PREF_NAVIGATION, navigationListCodes[0]);
    int index = Arrays.asList(navigationListCodes).indexOf(navigation);
    String title;
    if (index >= 0 && index < navigationListCodes.length) {
      title = navigationList[index];
    } else {
      Category category = DbHelper.getInstance().getCategory(Long.parseLong(navigation));
      title = category != null ? category.getName() : "";
    }
    title = title == null ? getString(R.string.title_activity_list) : title;
    mainActivity.setActionBarTitle(title);
  }
  private void initEasterEgg() {
    binding.emptyList.setOnClickListener(v -> {
      if (jinglesAnimation == null) {
        jinglesAnimation = (AnimationDrawable) binding.emptyList.getCompoundDrawables()[1];
        binding.emptyList.post(() -> {
          if (jinglesAnimation != null) {
            jinglesAnimation.start();
          }
        });
      } else {
        stopJingles();
      }
    });
  }
  private void stopJingles() {
    if (jinglesAnimation != null) {
      jinglesAnimation.stop();
      jinglesAnimation = null;
      binding.emptyList
          .setCompoundDrawablesWithIntrinsicBounds(0, R.drawable.jingles_animation, 0, 0);
    }
  }
  @Override
  public void onPause() {
    super.onPause();
    searchQueryInstant = searchQuery;
    stopJingles();
    Crouton.cancelAllCroutons();
    closeFab();
    if (!keepActionMode) {
      commitPending();
      if (getActionMode() != null) {
        getActionMode().finish();
      }
    }
  }
  @Override
  public void onSaveInstanceState(@NonNull Bundle outState) {
    super.onSaveInstanceState(outState);
    refreshListScrollPosition();
    outState.putInt("listViewPosition", listViewPosition);
    outState.putInt(LIST_VIEW_POSITION_OFFSET, listViewPositionOffset);
    outState.putString("searchQuery", searchQuery);
    outState.putString("searchTags", searchTags);
  }
  private void refreshListScrollPosition() {
    if(binding != null) {
      listViewPosition = ((LinearLayoutManager) binding.list.getLayoutManager())
          .findFirstVisibleItemPosition();
      View v = binding.list.getChildAt(0);
      listViewPositionOffset =
          (v == null) ? (int) getResources().getDimension(R.dimen.vertical_margin) : v.getTop();
    }
  }
  @Override
  public void onResume() {
    super.onResume();
    if (mainActivity.prefsChanged) {
      mainActivity.prefsChanged = false;
      init();
    } else if (Intent.ACTION_SEARCH.equals(mainActivity.getIntent().getAction())) {
      initNotesList(mainActivity.getIntent());
    }
  }
  private final class ModeCallback implements ActionMode.Callback {
    @Override
    public boolean onCreateActionMode(ActionMode mode, Menu menu) {
      MenuInflater inflater = mode.getMenuInflater();
      inflater.inflate(R.menu.menu_list, menu);
      actionMode = mode;
      fab.setAllowed(isFabAllowed());
      fab.hideFab();
      return true;
    }
    @Override
    public void onDestroyActionMode(ActionMode mode) {
      for (int i = 0; i < listAdapter.getSelectedItems().size(); i++) {
        int key = listAdapter.getSelectedItems().keyAt(i);
      }
      selectedNotes.clear();
      listAdapter.clearSelectedItems();
      listAdapter.notifyDataSetChanged();
      fab.setAllowed(isFabAllowed(true));
      if (undoNotesMap.size() == 0) {
        fab.showFab();
      }
      actionMode = null;
      LogDelegate.d("Closed multiselection contextual menu");
    }
    @Override
    public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
      prepareActionModeMenu();
      return true;
    }
    @Override
    public boolean onActionItemClicked(final ActionMode mode, final MenuItem item) {
      Integer[] protectedActions = {R.id.menu_select_all, R.id.menu_merge};
      if (!Arrays.asList(protectedActions).contains(item.getItemId())) {
        mainActivity.requestPassword(mainActivity, getSelectedNotes(),
            passwordConfirmed -> {
              if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                performAction(item, mode);
              }
            });
      } else {
        performAction(item, mode);
      }
      return true;
    }
  }
  public void finishActionMode() {
    if (getActionMode() != null) {
      getActionMode().finish();
    }
  }
  private void toggleListViewItem(View view, int position) {
    Note note = listAdapter.getItem(position);
    LinearLayout cardLayout = view.findViewById(R.id.card_layout);
    if (!getSelectedNotes().contains(note)) {
      getSelectedNotes().add(note);
      listAdapter.addSelectedItem(position);
      cardLayout.setBackgroundColor(getResources().getColor(R.color.list_bg_selected));
    } else {
      getSelectedNotes().remove(note);
      listAdapter.removeSelectedItem(position);
      listAdapter.restoreDrawable(note, cardLayout);
    }
    prepareActionModeMenu();
    if (getSelectedNotes().isEmpty()) {
      finishActionMode();
    }
  }
  private void initListView() {
    RecyclerViewItemClickSupport.addTo(binding.list)
        .setOnItemClickListener((recyclerView, position, view) -> {
          if (getActionMode() == null) {
            editNote(listAdapter.getItem(position), view);
            return;
          }
          toggleListViewItem(view, position);
          setCabTitle();
        }).setOnItemLongClickListener((recyclerView, position, view) -> {
      if (getActionMode() != null) {
        return false;
      }
      mainActivity.startSupportActionMode(new ModeCallback());
      toggleListViewItem(view, position);
      setCabTitle();
      return true;
    });
    binding.listRoot.setOnViewTouchedListener(this);
  }
  private ImageView getZoomListItemView(View view, Note note) {
    View targetView = null;
    if (!note.getAttachmentsList().isEmpty()) {
      targetView = view.findViewById(R.id.attachmentThumbnail);
    }
    if (targetView == null && note.getCategory() != null) {
      targetView = view.findViewById(R.id.category_marker);
    }
    if (targetView == null) {
      targetView = new ImageView(mainActivity);
      targetView.setBackgroundColor(Color.WHITE);
    }
    targetView.setDrawingCacheEnabled(true);
    targetView.buildDrawingCache();
    Bitmap bmp = targetView.getDrawingCache();
    binding.expandedImage.setBackgroundColor(BitmapUtils.getDominantColor(bmp));
    return binding.expandedImage;
  }
  private AnimatorListenerAdapter buildAnimatorListenerAdapter(final Note note) {
    return new AnimatorListenerAdapter() {
      @Override
      public void onAnimationEnd(Animator animation) {
        editNote2(note);
      }
    };
  }
  @Override
  public void onViewTouchOccurred(MotionEvent ev) {
    LogDelegate.v("Notes list: onViewTouchOccurred " + ev.getAction());
    commitPending();
  }
  @Override
  public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
    inflater.inflate(R.menu.menu_list, menu);
    super.onCreateOptionsMenu(menu, inflater);
    this.menu = menu;
    initSearchView(menu);
  }
  private void initSortingSubmenu() {
    final String[] arrayDb = getResources().getStringArray(R.array.sortable_columns);
    final String[] arrayDialog = getResources()
        .getStringArray(R.array.sortable_columns_human_readable);
    int selected = Arrays.asList(arrayDb).indexOf(Prefs.getString(PREF_SORTING_COLUMN, arrayDb[0]));
    SubMenu sortMenu = this.menu.findItem(R.id.menu_sort).getSubMenu();
    for (int i = 0; i < arrayDialog.length; i++) {
      if (sortMenu.findItem(i) == null) {
        sortMenu.add(MENU_SORT_GROUP_ID, i, i, arrayDialog[i]);
      }
      if (i == selected) {
        sortMenu.getItem(i).setChecked(true);
      }
    }
    sortMenu.setGroupCheckable(MENU_SORT_GROUP_ID, true, true);
  }
  @Override
  public void onPrepareOptionsMenu(Menu menu) {
    setActionItemsVisibility(menu, false);
  }
  private void prepareActionModeMenu() {
    Menu menu = getActionMode().getMenu();
    int navigation = Navigation.getNavigation();
    boolean showArchive =
        navigation == Navigation.NOTES || navigation == Navigation.REMINDERS || navigation ==
            Navigation.UNCATEGORIZED || navigation == Navigation.CATEGORY;
    boolean showUnarchive =
        navigation == Navigation.ARCHIVE || navigation == Navigation.UNCATEGORIZED ||
            navigation == Navigation.CATEGORY;
    if (navigation == Navigation.TRASH) {
      menu.findItem(R.id.menu_untrash).setVisible(true);
      menu.findItem(R.id.menu_delete).setVisible(true);
    } else {
      if (getSelectedCount() == 1) {
        menu.findItem(R.id.menu_share).setVisible(true);
        menu.findItem(R.id.menu_merge).setVisible(false);
        menu.findItem(R.id.menu_archive)
            .setVisible(showArchive && !getSelectedNotes().get(0).isArchived
                ());
        menu.findItem(R.id.menu_unarchive)
            .setVisible(showUnarchive && getSelectedNotes().get(0).isArchived
                ());
      } else {
        menu.findItem(R.id.menu_share).setVisible(false);
        menu.findItem(R.id.menu_merge).setVisible(true);
        menu.findItem(R.id.menu_archive).setVisible(showArchive);
        menu.findItem(R.id.menu_unarchive).setVisible(showUnarchive);
      }
      menu.findItem(R.id.menu_add_reminder).setVisible(true);
      menu.findItem(R.id.menu_category).setVisible(true);
      menu.findItem(R.id.menu_uncomplete_checklists).setVisible(false);
      menu.findItem(R.id.menu_tags).setVisible(true);
      menu.findItem(R.id.menu_trash).setVisible(true);
    }
    menu.findItem(R.id.menu_select_all).setVisible(true);
    setCabTitle();
  }
  private int getSelectedCount() {
    return getSelectedNotes().size();
  }
  private void setCabTitle() {
    if (getActionMode() != null) {
      int title = getSelectedCount();
      getActionMode().setTitle(String.valueOf(title));
    }
  }
  @SuppressLint("NewApi")
  private void initSearchView(final Menu menu) {
    if (mainActivity == null) {
      return;
    }
    searchMenuItem = menu.findItem(R.id.menu_search);
    Bundle args = getArguments();
    if (args != null && args.getBoolean("setSearchFocus")) {
      searchMenuItem.expandActionView();
      KeyboardUtils.hideKeyboard(this.getView());
    }
    SearchManager searchManager = (SearchManager) mainActivity
        .getSystemService(Context.SEARCH_SERVICE);
    searchView = (SearchView) menu.findItem(R.id.menu_search).getActionView();
    searchView.setSearchableInfo(searchManager.getSearchableInfo(mainActivity.getComponentName()));
    searchView.setImeOptions(EditorInfo.IME_ACTION_SEARCH);
    searchView.setOnQueryTextFocusChangeListener(
        (v, hasFocus) -> setActionItemsVisibility(menu, hasFocus));
    searchMenuItem.setOnActionExpandListener(new OnActionExpandListener() {
          boolean searchPerformed = false;
          @Override
          public boolean onMenuItemActionCollapse(MenuItem item) {
            searchQuery = null;
            if (binding.searchLayout.getVisibility() == View.VISIBLE) {
              toggleSearchLabel(false);
            }
            mainActivity.getIntent().setAction(Intent.ACTION_MAIN);
            initNotesList(mainActivity.getIntent());
            mainActivity.supportInvalidateOptionsMenu();
            return true;
          }
          @Override
          public boolean onMenuItemActionExpand(MenuItem item) {
            commitPending();
            searchView.setOnQueryTextListener(new OnQueryTextListener() {
              @Override
              public boolean onQueryTextSubmit(String arg0) {
                return Prefs.getBoolean("settings_instant_search", false);
              }
              @Override
              public boolean onQueryTextChange(String pattern) {
                if (Prefs.getBoolean("settings_instant_search", false)
                    && searchPerformed && mFragment.isAdded()) {
                  searchTags = null;
                  searchQuery = pattern;
                  NoteLoaderTask.getInstance().execute("getNotesByPattern", pattern);
                  return true;
                } else {
                  searchPerformed = true;
                  return false;
                }
              }
            });
            return true;
          }
        });
  }
  private void setActionItemsVisibility(Menu menu, boolean searchViewHasFocus) {
    boolean drawerOpen = mainActivity.getDrawerLayout() != null
        && mainActivity.getDrawerLayout().isDrawerOpen(GravityCompat.START);
    boolean expandedView = Prefs.getBoolean(PREF_EXPANDED_VIEW, true);
    int navigation = Navigation.getNavigation();
    boolean navigationReminders = navigation == Navigation.REMINDERS;
    boolean navigationTrash = navigation == Navigation.TRASH;
    boolean navigationCategory = navigation == Navigation.CATEGORY;
    boolean filterPastReminders = Prefs.getBoolean(PREF_FILTER_PAST_REMINDERS, true);
    boolean filterArchivedInCategory = navigationCategory && Prefs
        .getBoolean(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), false);
    if (isFabAllowed()) {
      fab.setAllowed(true);
      fab.showFab();
    } else {
      fab.setAllowed(false);
      fab.hideFab();
    }
    menu.findItem(R.id.menu_search).setVisible(!drawerOpen);
    menu.findItem(R.id.menu_filter)
        .setVisible(!drawerOpen && !filterPastReminders && navigationReminders &&
            !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_remove)
        .setVisible(!drawerOpen && filterPastReminders && navigationReminders
            && !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_category).setVisible(!drawerOpen && !filterArchivedInCategory &&
        navigationCategory && !searchViewHasFocus);
    menu.findItem(R.id.menu_filter_category_remove)
        .setVisible(!drawerOpen && filterArchivedInCategory && navigationCategory && !searchViewHasFocus);
    menu.findItem(R.id.menu_sort)
        .setVisible(!drawerOpen && !navigationReminders && !searchViewHasFocus);
    menu.findItem(R.id.menu_expanded_view)
        .setVisible(!drawerOpen && !expandedView && !searchViewHasFocus);
    menu.findItem(R.id.menu_contracted_view)
        .setVisible(!drawerOpen && expandedView && !searchViewHasFocus);
    menu.findItem(R.id.menu_empty_trash).setVisible(!drawerOpen && navigationTrash);
    menu.findItem(R.id.menu_uncomplete_checklists).setVisible(searchViewHasFocus);
    menu.findItem(R.id.menu_tags).setVisible(searchViewHasFocus);
  }
  @Override
  public boolean onOptionsItemSelected(final MenuItem item) {
    Integer[] protectedActions = {R.id.menu_empty_trash};
    if (Arrays.asList(protectedActions).contains(item.getItemId())) {
      mainActivity.requestPassword(mainActivity, getSelectedNotes(), passwordConfirmed -> {
        if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
          performAction(item, null);
        }
      });
    } else {
      performAction(item, null);
    }
    return super.onOptionsItemSelected(item);
  }
  public void performAction(MenuItem item, ActionMode actionMode) {
    if (isOptionsItemFastClick()) {
      return;
    }
    if (actionMode == null) {
      switch (item.getItemId()) {
        case android.R.id.home:
          if (mainActivity.getDrawerLayout().isDrawerOpen(GravityCompat.START)) {
            mainActivity.getDrawerLayout().closeDrawer(GravityCompat.START);
          } else {
            mainActivity.getDrawerLayout().openDrawer(GravityCompat.START);
          }
          break;
        case R.id.menu_filter:
          filterReminders(true);
          break;
        case R.id.menu_filter_remove:
          filterReminders(false);
          break;
        case R.id.menu_filter_category:
          filterCategoryArchived(true);
          break;
        case R.id.menu_filter_category_remove:
          filterCategoryArchived(false);
          break;
        case R.id.menu_uncomplete_checklists:
          item.setVisible(false);
          filterByUncompleteChecklists();
          break;
        case R.id.menu_tags:
          filterByTags();
          break;
        case R.id.menu_sort:
          initSortingSubmenu();
          break;
        case R.id.menu_expanded_view:
          switchNotesView();
          break;
        case R.id.menu_contracted_view:
          switchNotesView();
          break;
        case R.id.menu_empty_trash:
          emptyTrash();
          break;
        case R.id.menu_search:
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + item.getItemId());
      }
    } else {
      switch (item.getItemId()) {
        case R.id.menu_category:
          categorizeNotes();
          break;
        case R.id.menu_tags:
          tagNotes();
          break;
        case R.id.menu_share:
          share();
          break;
        case R.id.menu_merge:
          merge();
          break;
        case R.id.menu_archive:
          archiveNotes(true);
          break;
        case R.id.menu_unarchive:
          archiveNotes(false);
          break;
        case R.id.menu_trash:
          trashNotes(true);
          break;
        case R.id.menu_untrash:
          trashNotes(false);
          break;
        case R.id.menu_delete:
          deleteNotes();
          break;
        case R.id.menu_select_all:
          selectAllNotes();
          break;
        case R.id.menu_add_reminder:
          addReminders();
          break;
        default:
          LogDelegate.e("Wrong element choosen: " + item.getItemId());
      }
    }
    checkSortActionPerformed(item);
  }
  private void addReminders() {
    Intent intent = new Intent(OmniNotes.getAppContext(), SnoozeActivity.class);
    intent.setAction(ACTION_POSTPONE);
    intent.putExtra(INTENT_NOTE, selectedNotes.toArray(new Note[selectedNotes.size()]));
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivityForResult(intent, REQUEST_CODE_ADD_ALARMS);
  }
  private void switchNotesView() {
    boolean expandedView = Prefs.getBoolean(PREF_EXPANDED_VIEW, true);
    Prefs.edit().putBoolean(PREF_EXPANDED_VIEW, !expandedView).apply();
    searchQueryInstant = searchQuery;
    initNotesList(mainActivity.getIntent());
    mainActivity.supportInvalidateOptionsMenu();
  }
  void editNote(final Note note, final View view) {
    if (note.isLocked() && !Prefs.getBoolean("settings_password_access", false)) {
      PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
        if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
          note.setPasswordChecked(true);
          AnimationsHelper.zoomListItem(mainActivity, view, getZoomListItemView(view, note),
              binding.listRoot, buildAnimatorListenerAdapter(note));
        }
      });
    } else {
      AnimationsHelper.zoomListItem(mainActivity, view, getZoomListItemView(view, note),
          binding.listRoot, buildAnimatorListenerAdapter(note));
    }
  }
  void editNote2(Note note) {
    if (note.get_id() == null) {
      LogDelegate.d("Adding new note");
      try {
        if (checkNavigation(Navigation.CATEGORY) || !isEmpty(mainActivity.navigationTmp)) {
          String categoryId = ObjectUtils.defaultIfNull(mainActivity.navigationTmp,
              Navigation.getCategory().toString());
          note.setCategory(DbHelper.getInstance().getCategory(Long.parseLong(categoryId)));
        }
      } catch (NumberFormatException e) {
        LogDelegate.v("Maybe was not a category!");
      }
    } else {
      LogDelegate.d("Editing note with ID: " + note.get_id());
    }
    refreshListScrollPosition();
    mainActivity.switchToDetail(note);
  }
  @Override
  public
  void onActivityResult(int requestCode, final int resultCode, Intent intent) {
    super.onActivityResult(requestCode, resultCode, intent);
    switch (requestCode) {
      case REQUEST_CODE_CATEGORY:
        switch (resultCode) {
          case Activity.RESULT_OK:
            mainActivity.showMessage(R.string.category_saved, ONStyle.CONFIRM);
            EventBus.getDefault().post(new CategoriesUpdatedEvent());
            break;
          case Activity.RESULT_FIRST_USER:
            mainActivity.showMessage(R.string.category_deleted, ONStyle.ALERT);
            break;
          default:
            break;
        }
        break;
      case REQUEST_CODE_CATEGORY_NOTES:
        if (intent != null) {
          Category tag = intent.getParcelableExtra(INTENT_CATEGORY);
          categorizeNotesExecute(tag);
        }
        break;
      case REQUEST_CODE_ADD_ALARMS:
        selectedNotes.clear();
        finishActionMode();
        break;
      default:
        break;
    }
  }
  private void checkSortActionPerformed(MenuItem item) {
    if (item.getGroupId() == MENU_SORT_GROUP_ID) {
      final String[] arrayDb = getResources().getStringArray(R.array.sortable_columns);
      Prefs.edit().putString(PREF_SORTING_COLUMN, arrayDb[item.getOrder()]).apply();
      initNotesList(mainActivity.getIntent());
      listViewPositionOffset = 16;
      listViewPosition = 0;
      restoreListScrollPosition();
      toggleSearchLabel(false);
      mainActivity.updateWidgets();
    }
  }
  private void emptyTrash() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.empty_trash_confirmation)
        .positiveText(R.string.ok)
        .onPositive((dialog, which) -> {
          boolean mustDeleteLockedNotes = false;
          for (int i = 0; i < listAdapter.getItemCount(); i++) {
            selectedNotes.add(listAdapter.getItem(i));
            mustDeleteLockedNotes = mustDeleteLockedNotes || listAdapter.getItem(i).isLocked();
          }
          if (mustDeleteLockedNotes) {
            mainActivity.requestPassword(mainActivity, getSelectedNotes(),
                passwordConfirmed -> {
                  if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                    deleteNotesExecute();
                  }
                });
          } else {
            deleteNotesExecute();
          }
        }).build().show();
  }
  void initNotesList(Intent intent) {
    LogDelegate.d("initNotesList intent: " + intent.getAction());
    binding.progressWheel.setAlpha(1);
    binding.list.setAlpha(0);
    if (Intent.ACTION_VIEW.equals(intent.getAction()) && intent.getCategories() != null
        && intent.getCategories().contains(Intent.CATEGORY_BROWSABLE)) {
      searchTags = intent.getDataString().replace(UrlCompleter.HASHTAG_SCHEME, "");
      goBackOnToggleSearchLabel = true;
    }
    if (ACTION_SHORTCUT_WIDGET.equals(intent.getAction())) {
      return;
    }
    searchQuery = searchQueryInstant;
    searchQueryInstant = null;
    if (searchTags != null || searchQuery != null || searchUncompleteChecklists
        || IntentChecker
        .checkAction(intent, Intent.ACTION_SEARCH, ACTION_SEARCH_UNCOMPLETE_CHECKLISTS)) {
      if (searchTags != null && intent.getStringExtra(SearchManager.QUERY) == null) {
        searchQuery = searchTags;
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByTag",
                searchQuery);
      } else if (searchUncompleteChecklists || ACTION_SEARCH_UNCOMPLETE_CHECKLISTS.equals(
          intent.getAction())) {
        searchQuery = getContext().getResources().getString(R.string.uncompleted_checklists);
        searchUncompleteChecklists = true;
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByUncompleteChecklist");
      } else {
        if (intent.getStringExtra(SearchManager.QUERY) != null) {
          searchQuery = intent.getStringExtra(SearchManager.QUERY);
          searchTags = null;
        }
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getNotesByPattern",
                searchQuery);
      }
      toggleSearchLabel(true);
    } else {
      if ((ACTION_WIDGET_SHOW_LIST.equals(intent.getAction()) && intent.hasExtra(INTENT_WIDGET))
          || !isEmpty(mainActivity.navigationTmp)) {
        String widgetId =
            intent.hasExtra(INTENT_WIDGET) ? intent.getExtras().get(INTENT_WIDGET).toString()
                : null;
        if (widgetId != null) {
          String sqlCondition = Prefs.getString(PREF_WIDGET_PREFIX + widgetId, "");
          String categoryId = TextHelper.checkIntentCategory(sqlCondition);
          mainActivity.navigationTmp = !isEmpty(categoryId) ? categoryId : null;
        }
        intent.removeExtra(INTENT_WIDGET);
        if (mainActivity.navigationTmp != null) {
          Long categoryId = Long.parseLong(mainActivity.navigationTmp);
          NoteLoaderTask.getInstance().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,
              "getNotesByCategory", categoryId);
        } else {
          NoteLoaderTask.getInstance()
              .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getAllNotes", true);
        }
      } else {
        NoteLoaderTask.getInstance()
            .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, "getAllNotes", true);
      }
    }
  }
  public void toggleSearchLabel(boolean activate) {
    if (activate) {
      binding.searchQuery.setText(fromHtml(getString(R.string.search) + ":<b> " + searchQuery + "</b>"));
      binding.searchLayout.setVisibility(View.VISIBLE);
      binding.searchCancel.setOnClickListener(v -> toggleSearchLabel(false));
      searchLabelActive = true;
    } else {
      if (searchLabelActive) {
        searchLabelActive = false;
        AnimationsHelper.expandOrCollapse(binding.searchLayout, false);
        searchTags = null;
        searchQuery = null;
        searchUncompleteChecklists = false;
        if (!goBackOnToggleSearchLabel) {
          mainActivity.getIntent().setAction(Intent.ACTION_MAIN);
          if (searchView != null) {
            searchMenuItem.collapseActionView();
          }
          initNotesList(mainActivity.getIntent());
        } else {
          mainActivity.onBackPressed();
        }
        goBackOnToggleSearchLabel = false;
        if (Intent.ACTION_VIEW.equals(mainActivity.getIntent().getAction())) {
          mainActivity.getIntent().setAction(null);
        }
      }
    }
  }
  public void onEvent(NavigationUpdatedNavDrawerClosedEvent navigationUpdatedNavDrawerClosedEvent) {
    listViewPosition = 0;
    listViewPositionOffset = 16;
    initNotesList(mainActivity.getIntent());
    setActionItemsVisibility(menu, false);
  }
  public void onEvent(CategoriesUpdatedEvent categoriesUpdatedEvent) {
    initNotesList(mainActivity.getIntent());
  }
  public void onEvent(NotesLoadedEvent notesLoadedEvent) {
    listAdapter = new NoteAdapter(mainActivity, Prefs.getBoolean(PREF_EXPANDED_VIEW, true),
        notesLoadedEvent.getNotes());
    initSwipeGesture();
    binding.list.setAdapter(listAdapter);
    if (!notesLoadedEvent.getNotes().isEmpty()) {
      if (checkNavigation(Navigation.REMINDERS)) {
        listViewPosition = listAdapter.getClosestNotePosition();
      }
      restoreListScrollPosition();
    }
    animateListView();
    closeFab();
  }
  public void onEvent(NotesUpdatedEvent notesUpdatedEvent) {
    notesUpdatedEvent.getNotes().stream().forEach(updatedNote ->
        IntStream.range(0, listAdapter.getNotes().size() - 1)
            .filter(i -> listAdapter.getItem(i).get_id().equals(updatedNote.get_id()))
            .forEach(i -> {
              listAdapter.getNotes().set(i, updatedNote);
              listAdapter.notifyItemChanged(i);
            }));
  }
  private void initSwipeGesture() {
    ItemTouchHelper.SimpleCallback simpleItemTouchCallback = new ItemTouchHelper.SimpleCallback(0,
        ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT) {
      @Override
      public boolean onMove(@NonNull RecyclerView recyclerView,
          @NonNull RecyclerView.ViewHolder viewHolder,
          @NonNull RecyclerView.ViewHolder target) {
        return false;
      }
      @Override
      public void onSwiped(RecyclerView.ViewHolder viewHolder, int swipeDir) {
        int swipedPosition = viewHolder.getAdapterPosition();
        finishActionMode();
        swipeNote(swipedPosition);
      }
    };
    ItemTouchHelper itemTouchHelper = new ItemTouchHelper(simpleItemTouchCallback);
    if (Navigation.getNavigation() != Navigation.UNCATEGORIZED && Prefs
        .getBoolean(PREF_ENABLE_SWIPE, true)) {
      itemTouchHelper.attachToRecyclerView(binding.list);
    } else {
      itemTouchHelper.attachToRecyclerView(null);
    }
  }
  private void swipeNote(int swipedPosition) {
    try {
      Note note = listAdapter.getItem(swipedPosition);
      if (note.isLocked()) {
        PasswordHelper.requestPassword(mainActivity, passwordConfirmed -> {
          if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
            onNoteSwipedPerformAction(note);
          } else {
            onUndo(null);
          }
        });
      } else {
        onNoteSwipedPerformAction(note);
      }
    } catch (IndexOutOfBoundsException e) {
      LogDelegate.d("Please stop swiping in the zone beneath the last card");
    }
  }
  private void onNoteSwipedPerformAction(Note note) {
    getSelectedNotes().add(note);
    if (checkNavigation(Navigation.TRASH)) {
      trashNotes(false);
    }
    else if (checkNavigation(Navigation.CATEGORY)) {
      categorizeNotesExecute(null);
    } else {
      if (Prefs.getBoolean("settings_swipe_to_trash", false)
          || checkNavigation(Navigation.ARCHIVE)) {
        trashNotes(true);
      } else {
        archiveNotes(true);
      }
    }
  }
  public void onEvent(PasswordRemovedEvent passwordRemovedEvent) {
    initNotesList(mainActivity.getIntent());
  }
  private void animateListView() {
    if (!isDebugBuild()) {
      animate(binding.progressWheel)
          .setDuration(getResources().getInteger(R.integer.list_view_fade_anim)).alpha(0);
      animate(binding.list).setDuration(getResources().getInteger(R.integer.list_view_fade_anim))
          .alpha(1);
    } else {
      binding.progressWheel.setVisibility(View.INVISIBLE);
      binding.list.setAlpha(1);
    }
  }
  private void restoreListScrollPosition() {
    if (listAdapter.getItemCount() > listViewPosition) {
      binding.list.getLayoutManager().scrollToPosition(listViewPosition);
      new Handler().postDelayed(fab::showFab, 150);
    } else {
      binding.list.getLayoutManager().scrollToPosition(0);
    }
  }
  public void trashNotes(boolean trash) {
    int selectedNotesSize = getSelectedNotes().size();
    if (trash) {
      trackModifiedNotes(getSelectedNotes());
      for (Note note : getSelectedNotes()) {
        listAdapter.remove(note);
        ReminderHelper.removeReminder(OmniNotes.getAppContext(), note);
      }
    } else {
      trashNote(getSelectedNotes(), false);
    }
    listAdapter.notifyDataSetChanged();
    finishActionMode();
    if (trash) {
      mainActivity.showMessage(R.string.note_trashed, ONStyle.WARN);
    } else {
      mainActivity.showMessage(R.string.note_untrashed, ONStyle.INFO);
    }
    if (trash) {
      ubc.showUndoBar(false, selectedNotesSize + " " + getString(R.string.trashed), null);
      fab.hideFab();
      undoTrash = true;
    } else {
      getSelectedNotes().clear();
    }
  }
  private ActionMode getActionMode() {
    return actionMode;
  }
  private List<Note> getSelectedNotes() {
    return selectedNotes;
  }
  @SuppressLint("NewApi")
  protected void trashNote(List<Note> notes, boolean trash) {
    listAdapter.remove(notes);
    new NoteProcessorTrash(notes, trash).process();
  }
  private void selectAllNotes() {
    for (int i = 0; i < binding.list.getChildCount(); i++) {
      LinearLayout v = binding.list.getChildAt(i).findViewById(R.id.card_layout);
      v.setBackgroundColor(getResources().getColor(R.color.list_bg_selected));
    }
    selectedNotes.clear();
    for (int i = 0; i < listAdapter.getItemCount(); i++) {
      selectedNotes.add(listAdapter.getItem(i));
      listAdapter.addSelectedItem(i);
    }
    prepareActionModeMenu();
    setCabTitle();
  }
  private void deleteNotes() {
    new MaterialDialog.Builder(mainActivity)
        .content(R.string.delete_note_confirmation)
        .positiveText(R.string.ok)
        .onPositive(
            (dialog, which) -> mainActivity.requestPassword(mainActivity, getSelectedNotes(),
                passwordConfirmed -> {
                  if (passwordConfirmed.equals(PasswordValidator.Result.SUCCEED)) {
                    deleteNotesExecute();
                  }
                }))
        .build()
        .show();
  }
  private void deleteNotesExecute() {
    listAdapter.remove(getSelectedNotes());
    new NoteProcessorDelete(getSelectedNotes()).process();
    selectedNotes.clear();
    finishActionMode();
    mainActivity.showMessage(R.string.note_deleted, ONStyle.ALERT);
  }
  public void archiveNotes(boolean archive) {
    int selectedNotesSize = getSelectedNotes().size();
    sendToArchive = archive;
    if (!archive) {
      archiveNote(getSelectedNotes(), false);
    } else {
      trackModifiedNotes(getSelectedNotes());
    }
    for (Note note : getSelectedNotes()) {
      if (archive) {
        undoArchivedMap.put(note, note.isArchived());
      }
      if (checkNavigation(Navigation.NOTES)
          || (checkNavigation(Navigation.ARCHIVE) && !archive)
          || (checkNavigation(Navigation.CATEGORY) && Prefs.getBoolean(
          PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), false))) {
        listAdapter.remove(note);
      } else {
        note.setArchived(archive);
        listAdapter.replace(note, listAdapter.getPosition(note));
      }
    }
    listAdapter.notifyDataSetChanged();
    finishActionMode();
    int msg = archive ? R.string.note_archived : R.string.note_unarchived;
    Style style = archive ? ONStyle.WARN : ONStyle.INFO;
    mainActivity.showMessage(msg, style);
    if (archive) {
      ubc.showUndoBar(false, selectedNotesSize + " " + getString(R.string.archived), null);
      fab.hideFab();
      undoArchive = true;
    } else {
      getSelectedNotes().clear();
    }
  }
  private void trackModifiedNotes(List<Note> modifiedNotesToTrack) {
    for (Note note : modifiedNotesToTrack) {
      undoNotesMap.put(listAdapter.getPosition(note), note);
    }
  }
  private void archiveNote(List<Note> notes, boolean archive) {
    new NoteProcessorArchive(notes, archive).process();
    if (!checkNavigation(Navigation.CATEGORY)) {
      listAdapter.remove(notes);
    }
    LogDelegate.d("Notes" + (archive ? "archived" : "restored from archive"));
  }
  void editCategory(Category category) {
    Intent categoryIntent = new Intent(mainActivity, CategoryActivity.class);
    categoryIntent.putExtra(INTENT_CATEGORY, category);
    startActivityForResult(categoryIntent, REQUEST_CODE_CATEGORY);
  }
  private void categorizeNotes() {
    var categories = DbHelper.getInstance().getCategories();
    var dialogBuilder = new MaterialDialog.Builder(mainActivity)
        .title(R.string.categorize_as)
        .positiveText(R.string.add_category)
        .positiveColorRes(R.color.colorPrimary)
        .negativeText(R.string.remove_category)
        .negativeColorRes(R.color.colorAccent)
        .onPositive((dialog1, which) -> {
          keepActionMode = true;
          Intent intent = new Intent(mainActivity, CategoryActivity.class);
          intent.putExtra("noHome", true);
          startActivityForResult(intent, REQUEST_CODE_CATEGORY_NOTES);
        }).onNegative((dialog12, which) -> categorizeNotesExecute(null));
    if (CollectionUtils.isNotEmpty(categories)) {
      dialogBuilder.adapter(new CategoryRecyclerViewAdapter(mainActivity, categories), null);
    }
    final var dialog = dialogBuilder.build();
    if (CollectionUtils.isNotEmpty(categories)) {
      RecyclerViewItemClickSupport.addTo(dialog.getRecyclerView())
          .setOnItemClickListener((recyclerView, position, v) -> {
            dialog.dismiss();
            categorizeNotesExecute(categories.get(position));
          });
    }
    dialog.show();
  }
  private void categorizeNotesExecute(Category category) {
    if (category != null) {
      categorizeNote(getSelectedNotes(), category);
    } else {
      trackModifiedNotes(getSelectedNotes());
    }
    for (Note note : getSelectedNotes()) {
      if (category == null) {
        undoCategoryMap.put(note, note.getCategory());
      }
      if ((checkNavigation(Navigation.CATEGORY) && !Navigation
          .checkNavigationCategory(category)) ||
          checkNavigation(Navigation.UNCATEGORIZED)) {
        listAdapter.remove(note);
      } else {
        note.setCategory(category);
        listAdapter.replace(note, listAdapter.getPosition(note));
      }
    }
    finishActionMode();
    String msg;
    if (category != null) {
      msg = getResources().getText(R.string.notes_categorized_as) + " '" + category.getName() + "'";
    } else {
      msg = getResources().getText(R.string.notes_category_removed).toString();
    }
    mainActivity.showMessage(msg, ONStyle.INFO);
    if (category == null) {
      ubc.showUndoBar(false, getString(R.string.notes_category_removed), null);
      fab.hideFab();
      undoCategorize = true;
      undoCategorizeCategory = null;
    } else {
      getSelectedNotes().clear();
    }
  }
  private void categorizeNote(List<Note> notes, Category category) {
    new NoteProcessorCategorize(notes, category).process();
  }
  private void tagNotes() {
    final List<Tag> tags = DbHelper.getInstance().getTags();
    if (tags.isEmpty()) {
      finishActionMode();
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    final Integer[] preSelectedTags = TagsHelper.getPreselectedTagsArray(selectedNotes, tags);
    new MaterialDialog.Builder(mainActivity)
        .title(R.string.select_tags)
        .items(TagsHelper.getTagsArray(tags))
        .positiveText(R.string.ok)
        .itemsCallbackMultiChoice(preSelectedTags, (dialog, which, text) -> {
          dialog.dismiss();
          tagNotesExecute(tags, which, preSelectedTags);
          return false;
        }).build().show();
  }
  private void tagNotesExecute(List<Tag> tags, Integer[] selectedTags, Integer[] preSelectedTags) {
    for (Note note : getSelectedNotes()) {
      tagNote(tags, selectedTags, note);
    }
    if (getActionMode() != null) {
      getActionMode().finish();
    }
    mainActivity.showMessage(R.string.tags_added, ONStyle.INFO);
  }
  private void tagNote(List<Tag> tags, Integer[] selectedTags, Note note) {
    Pair<String, List<Tag>> taggingResult = TagsHelper.addTagToNote(tags, selectedTags, note);
    if (note.isChecklist()) {
      note.setTitle(note.getTitle() + System.getProperty("line.separator") + taggingResult.first);
    } else {
      StringBuilder sb = new StringBuilder(note.getContent());
      if (sb.length() > 0) {
        sb.append(System.getProperty("line.separator"))
            .append(System.getProperty("line.separator"));
      }
      sb.append(taggingResult.first);
      note.setContent(sb.toString());
    }
    eventuallyRemoveDeselectedTags(note, taggingResult.second);
    DbHelper.getInstance().updateNote(note, false);
  }
  private void eventuallyRemoveDeselectedTags(Note note, List<Tag> tagsToRemove) {
    if (CollectionUtils.isNotEmpty(tagsToRemove)) {
      String titleWithoutTags = TagsHelper.removeTags(note.getTitle(), tagsToRemove);
      note.setTitle(titleWithoutTags);
      String contentWithoutTags = TagsHelper.removeTags(note.getContent(), tagsToRemove);
      note.setContent(contentWithoutTags);
    }
  }
  @Override
  public void onUndo(Parcelable undoToken) {
    for (Integer notePosition : undoNotesMap.keySet()) {
      Note currentNote = undoNotesMap.get(notePosition);
      if ((undoCategorize && !Navigation.checkNavigationCategory(undoCategoryMap.get(currentNote)))
          || undoArchive && !checkNavigation(Navigation.NOTES)) {
        if (undoCategorize) {
          currentNote.setCategory(undoCategoryMap.get(currentNote));
        } else if (undoArchive) {
          currentNote.setArchived(undoArchivedMap.get(currentNote));
        }
        listAdapter.replace(currentNote, listAdapter.getPosition(currentNote));
      } else {
        listAdapter.add(notePosition, currentNote);
      }
    }
    listAdapter.notifyDataSetChanged();
    selectedNotes.clear();
    undoNotesMap.clear();
    undoTrash = false;
    undoArchive = false;
    undoCategorize = false;
    undoNotesMap.clear();
    undoCategoryMap.clear();
    undoArchivedMap.clear();
    undoCategorizeCategory = null;
    Crouton.cancelAllCroutons();
    if (getActionMode() != null) {
      getActionMode().finish();
    }
    ubc.hideUndoBar(false);
    fab.showFab();
  }
  void commitPending() {
    if (undoTrash || undoArchive || undoCategorize) {
      List<Note> notesList = new ArrayList<>(undoNotesMap.values());
      if (undoTrash) {
        trashNote(notesList, true);
      } else if (undoArchive) {
        archiveNote(notesList, sendToArchive);
      } else if (undoCategorize) {
        categorizeNote(notesList, undoCategorizeCategory);
      }
      undoTrash = false;
      undoArchive = false;
      undoCategorize = false;
      undoCategorizeCategory = null;
      selectedNotes.clear();
      undoNotesMap.clear();
      undoCategoryMap.clear();
      undoArchivedMap.clear();
      ubc.hideUndoBar(false);
      fab.showFab();
      LogDelegate.d("Changes committed");
    }
    mainActivity.updateWidgets();
  }
  private void share() {
    for (final Note note : getSelectedNotes()) {
      mainActivity.shareNote(note);
    }
    getSelectedNotes().clear();
    if (getActionMode() != null) {
      getActionMode().finish();
    }
  }
  public void merge() {
    EventBus.getDefault().post(new NotesMergeEvent(false));
  }
  public void onEventAsync(NotesMergeEvent notesMergeEvent) {
    final Note finalMergedNote = NotesHelper
        .mergeNotes(getSelectedNotes(), notesMergeEvent.keepMergedNotes);
    new Handler(Looper.getMainLooper()).post(() -> {
      if (!notesMergeEvent.keepMergedNotes) {
        ArrayList<String> notesIds = new ArrayList<>();
        for (Note selectedNote : getSelectedNotes()) {
          notesIds.add(String.valueOf(selectedNote.get_id()));
        }
        mainActivity.getIntent().putExtra("merged_notes", notesIds);
      }
      getSelectedNotes().clear();
      if (getActionMode() != null) {
        getActionMode().finish();
      }
      mainActivity.getIntent().setAction(ACTION_MERGE);
      mainActivity.switchToDetail(finalMergedNote);
    });
  }
  private void filterReminders(boolean filter) {
    Prefs.edit().putBoolean(PREF_FILTER_PAST_REMINDERS, filter).apply();
    initNotesList(mainActivity.getIntent());
    mainActivity.supportInvalidateOptionsMenu();
  }
  private void filterCategoryArchived(boolean filter) {
    if (filter) {
      Prefs.edit().putBoolean(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory(), true)
          .apply();
    } else {
      Prefs.edit().remove(PREF_FILTER_ARCHIVED_IN_CATEGORIES + Navigation.getCategory()).apply();
    }
    initNotesList(mainActivity.getIntent());
    mainActivity.supportInvalidateOptionsMenu();
  }
  private void filterByUncompleteChecklists() {
    initNotesList(new Intent(ACTION_SEARCH_UNCOMPLETE_CHECKLISTS));
  }
  private void filterByTags() {
    final List<Tag> tags = TagsHelper.getAllTags();
    if (tags.isEmpty()) {
      mainActivity.showMessage(R.string.no_tags_created, ONStyle.WARN);
      return;
    }
    var tagsDialog = new MaterialAlertDialogBuilder(mainActivity)
        .setTitle(R.string.select_tags)
        .setPositiveButton(R.string.ok, (dialog, which) -> {
          var items = ((AlertDialog) dialog).getListView().getCheckedItemPositions();
          var selectedTags = new ArrayList<String>();
          for(int i = 0; i < tags.size(); i++) {
            if (items.get(i)) {
              selectedTags.add(tags.get(i).getText());
            }
          }
          searchTags = selectedTags.toString().substring(1, selectedTags.toString().length() - 1)
              .replace(" ", "");
          searchView.clearFocus();
          KeyboardUtils.hideKeyboard(searchView);
          var intent = mainActivity.getIntent();
          intent.removeExtra(SearchManager.QUERY);
          initNotesList(intent);
        })
        .setMultiChoiceItems(TagsHelper.getTagsArray(tags), null, (dialog, which, isChecked) ->
            ((AlertDialog) dialog).getButton(BUTTON_POSITIVE)
            .setEnabled(((AlertDialog) dialog).getListView().getCheckedItemCount() > 0)
        ).create();
    tagsDialog.show();
    tagsDialog.getButton(BUTTON_POSITIVE).setEnabled(false);
  }
  public MenuItem getSearchMenuItem() {
    return searchMenuItem;
  }
  private boolean isFabAllowed() {
    return isFabAllowed(false);
  }
  private boolean isFabAllowed(boolean actionModeFinishing) {
    boolean isAllowed = true;
    isAllowed = isAllowed && (getActionMode() == null || actionModeFinishing);
    int navigation = Navigation.getNavigation();
    isAllowed = isAllowed && navigation != Navigation.ARCHIVE && navigation != Navigation.REMINDERS
        && navigation
        != Navigation.TRASH;
    isAllowed =
        isAllowed && mainActivity.getDrawerLayout() != null && !mainActivity.getDrawerLayout()
            .isDrawerOpen
                (GravityCompat.START);
    return isAllowed;
  }
}
package it.feio.android.omninotes.intro;
import static it.feio.android.omninotes.helpers.BuildHelper.isDebugBuild;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_TOUR_COMPLETE;
import android.os.Bundle;
import com.github.paolorotolo.appintro.AppIntro2;
import com.pixplicity.easyprefs.library.Prefs;
public class IntroActivity extends AppIntro2 {
  @Override
  public void init(Bundle savedInstanceState) {
    addSlide(new IntroSlide1(), getApplicationContext());
    addSlide(new IntroSlide2(), getApplicationContext());
    addSlide(new IntroSlide3(), getApplicationContext());
    addSlide(new IntroSlide4(), getApplicationContext());
    addSlide(new IntroSlide5(), getApplicationContext());
    addSlide(new IntroSlide6(), getApplicationContext());
  }
  @Override
  public void onDonePressed() {
    Prefs.edit().putBoolean(PREF_TOUR_COMPLETE, true).apply();
    finish();
  }
  public static boolean mustRun() {
    return !isDebugBuild() && !Prefs.getBoolean(PREF_TOUR_COMPLETE, false);
  }
  @Override
  public void onBackPressed() {
  }
}
package it.feio.android.omninotes.helpers;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_CURRENT_APP_VERSION;
import android.content.Context;
import android.content.pm.PackageManager.NameNotFoundException;
import com.pixplicity.easyprefs.library.Prefs;
import lombok.experimental.UtilityClass;
@UtilityClass
public class AppVersionHelper {
  public static boolean isAppUpdated(Context context) {
    return getCurrentAppVersion(context) > getAppVersionFromPreferences(context);
  }
  public static int getAppVersionFromPreferences(Context context) {
    try {
      return Prefs.getInt(PREF_CURRENT_APP_VERSION, 1);
    } catch (ClassCastException e) {
      return getCurrentAppVersion(context) - 1;
    }
  }
  public static void updateAppVersionInPreferences(Context context) {
    Prefs.edit().putInt(PREF_CURRENT_APP_VERSION, getCurrentAppVersion(context)).apply();
  }
  public static int getCurrentAppVersion(Context context) {
    try {
      return context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionCode;
    } catch (NameNotFoundException e) {
      return 1;
    }
  }
  public static String getCurrentAppVersionName(Context context) {
    try {
      return context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;
    } catch (NameNotFoundException e) {
      return "1.0.0";
    }
  }
}
package it.feio.android.omninotes.helpers;
import static it.feio.android.checklistview.interfaces.Constants.CHECKED_SYM;
import static it.feio.android.checklistview.interfaces.Constants.UNCHECKED_SYM;
import static it.feio.android.omninotes.utils.ConstantsBase.MERGED_NOTES_SEPARATOR;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_AUDIO;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_FILES;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_IMAGE;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_SKETCH;
import static it.feio.android.omninotes.utils.ConstantsBase.MIME_TYPE_VIDEO;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.helpers.count.CountFactory;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.StatsSingleNote;
import it.feio.android.omninotes.utils.StorageHelper;
import it.feio.android.omninotes.utils.TagsHelper;
import java.util.ArrayList;
import java.util.List;
import lombok.experimental.UtilityClass;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
@UtilityClass
public class NotesHelper {
  public static boolean haveSameId(Note note, Note currentNote) {
    return currentNote != null
        && currentNote.get_id() != null
        && currentNote.get_id().equals(note.get_id());
  }
  public static StringBuilder appendContent(Note note, StringBuilder content,
      boolean includeTitle) {
    if (content.length() > 0
        && (!StringUtils.isEmpty(note.getTitle()) || !StringUtils.isEmpty(note.getContent()))) {
      content.append(System.getProperty("line.separator"))
          .append(System.getProperty("line.separator"))
          .append(MERGED_NOTES_SEPARATOR).append(System.getProperty("line.separator"))
          .append(System.getProperty("line.separator"));
    }
    if (includeTitle && !StringUtils.isEmpty(note.getTitle())) {
      content.append(note.getTitle());
    }
    if (!StringUtils.isEmpty(note.getTitle()) && !StringUtils.isEmpty(note.getContent())) {
      content.append(System.getProperty("line.separator"))
          .append(System.getProperty("line.separator"));
    }
    if (!StringUtils.isEmpty(note.getContent())) {
      content.append(note.getContent());
    }
    return content;
  }
  public static void addAttachments(boolean keepMergedNotes, Note note,
      ArrayList<Attachment> attachments) {
    if (keepMergedNotes) {
      for (Attachment attachment : note.getAttachmentsList()) {
        attachments
            .add(StorageHelper.createAttachmentFromUri(OmniNotes.getAppContext(), attachment.getUri
                ()));
      }
    } else {
      attachments.addAll(note.getAttachmentsList());
    }
  }
  public static Note mergeNotes(List<Note> notes, boolean keepMergedNotes) {
    boolean locked = false;
    ArrayList<Attachment> attachments = new ArrayList<>();
    String reminder = null;
    String reminderRecurrenceRule = null;
    Double latitude = null;
    Double longitude = null;
    Note mergedNote = new Note();
    mergedNote.setTitle(notes.get(0).getTitle());
    mergedNote.setArchived(notes.get(0).isArchived());
    mergedNote.setCategory(notes.get(0).getCategory());
    StringBuilder content = new StringBuilder();
    boolean includeTitle = false;
    for (Note note : notes) {
      appendContent(note, content, includeTitle);
      locked = locked || note.isLocked();
      String currentReminder = note.getAlarm();
      if (!StringUtils.isEmpty(currentReminder) && reminder == null) {
        reminder = currentReminder;
        reminderRecurrenceRule = note.getRecurrenceRule();
      }
      latitude = ObjectUtils.defaultIfNull(latitude, note.getLatitude());
      longitude = ObjectUtils.defaultIfNull(longitude, note.getLongitude());
      addAttachments(keepMergedNotes, note, attachments);
      includeTitle = true;
    }
    mergedNote.setContent(content.toString());
    mergedNote.setLocked(locked);
    mergedNote.setAlarm(reminder);
    mergedNote.setRecurrenceRule(reminderRecurrenceRule);
    mergedNote.setLatitude(latitude);
    mergedNote.setLongitude(longitude);
    mergedNote.setAttachmentsList(attachments);
    return mergedNote;
  }
  public static StatsSingleNote getNoteInfo(Note note) {
    StatsSingleNote infos = new StatsSingleNote();
    int words;
    int chars;
    if (note.isChecklist()) {
      infos.setChecklistCompletedItemsNumber(
          StringUtils.countMatches(note.getContent(), CHECKED_SYM));
      infos.setChecklistItemsNumber(infos.getChecklistCompletedItemsNumber() +
          StringUtils.countMatches(note.getContent(), UNCHECKED_SYM));
    }
    infos.setTags(TagsHelper.retrieveTags(note).size());
    words = getWords(note);
    chars = getChars(note);
    infos.setWords(words);
    infos.setChars(chars);
    int attachmentsAll = 0;
    int images = 0;
    int videos = 0;
    int audioRecordings = 0;
    int sketches = 0;
    int files = 0;
    for (Attachment attachment : note.getAttachmentsList()) {
      if (MIME_TYPE_IMAGE.equals(attachment.getMime_type())) {
        images++;
      } else if (MIME_TYPE_VIDEO.equals(attachment.getMime_type())) {
        videos++;
      } else if (MIME_TYPE_AUDIO.equals(attachment.getMime_type())) {
        audioRecordings++;
      } else if (MIME_TYPE_SKETCH.equals(attachment.getMime_type())) {
        sketches++;
      } else if (MIME_TYPE_FILES.equals(attachment.getMime_type())) {
        files++;
      }
      attachmentsAll++;
    }
    infos.setAttachments(attachmentsAll);
    infos.setImages(images);
    infos.setVideos(videos);
    infos.setAudioRecordings(audioRecordings);
    infos.setSketches(sketches);
    infos.setFiles(files);
    if (note.getCategory() != null) {
      infos.setCategoryName(note.getCategory().getName());
    }
    return infos;
  }
  public static int getWords(Note note) {
    return CountFactory.getWordCounter().countWords(note);
  }
  public static int getChars(Note note) {
    return CountFactory.getWordCounter().countChars(note);
  }
}
package it.feio.android.omninotes.widget;
import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
import static it.feio.android.omninotes.helpers.IntentHelper.immutablePendingIntentFlag;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_SHOW_LIST;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET_TAKE_PHOTO;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_WIDGET;
import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.SparseArray;
import android.widget.RemoteViews;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.helpers.LogDelegate;
public abstract class WidgetProvider extends AppWidgetProvider {
  public static final String EXTRA_WORD = "it.feio.android.omninotes.widget.WORD";
  public static final String TOAST_ACTION = "it.feio.android.omninotes.widget.NOTE";
  public static final String EXTRA_ITEM = "it.feio.android.omninotes.widget.EXTRA_FIELD";
  @Override
  public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
    ComponentName thisWidget = new ComponentName(context, getClass());
    int[] allWidgetIds = appWidgetManager.getAppWidgetIds(thisWidget);
    for (int appWidgetId : allWidgetIds) {
      LogDelegate.d("WidgetProvider onUpdate() widget " + appWidgetId);
      setLayout(context, appWidgetManager, appWidgetId);
    }
    super.onUpdate(context, appWidgetManager, appWidgetIds);
  }
  @Override
  public void onAppWidgetOptionsChanged(Context context, AppWidgetManager appWidgetManager,
      int appWidgetId,
      Bundle newOptions) {
    LogDelegate.d("Widget size changed");
    setLayout(context, appWidgetManager, appWidgetId);
  }
  private void setLayout(Context context, AppWidgetManager appWidgetManager, int widgetId) {
    Intent intentDetail = new Intent(context, MainActivity.class);
    intentDetail.setAction(ACTION_WIDGET);
    intentDetail.putExtra(INTENT_WIDGET, widgetId);
    PendingIntent pendingIntentDetail = PendingIntent
        .getActivity(context, widgetId, intentDetail, immutablePendingIntentFlag(FLAG_ACTIVITY_NEW_TASK));
    Intent intentList = new Intent(context, MainActivity.class);
    intentList.setAction(ACTION_WIDGET_SHOW_LIST);
    intentList.putExtra(INTENT_WIDGET, widgetId);
    PendingIntent pendingIntentList = PendingIntent
        .getActivity(context, widgetId, intentList, immutablePendingIntentFlag(FLAG_ACTIVITY_NEW_TASK));
    Intent intentDetailPhoto = new Intent(context, MainActivity.class);
    intentDetailPhoto.setAction(ACTION_WIDGET_TAKE_PHOTO);
    intentDetailPhoto.putExtra(INTENT_WIDGET, widgetId);
    PendingIntent pendingIntentDetailPhoto = PendingIntent
        .getActivity(context, widgetId, intentDetailPhoto, immutablePendingIntentFlag(FLAG_ACTIVITY_NEW_TASK));
    boolean isSmall = false;
    boolean isSingleLine = true;
    Bundle options = appWidgetManager.getAppWidgetOptions(widgetId);
    isSmall = options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH) < 110;
    isSingleLine = options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) < 110;
    SparseArray<PendingIntent> map = new SparseArray<>();
    map.put(R.id.list, pendingIntentList);
    map.put(R.id.add, pendingIntentDetail);
    map.put(R.id.camera, pendingIntentDetailPhoto);
    RemoteViews views = getRemoteViews(context, widgetId, isSmall, isSingleLine, map);
    appWidgetManager.updateAppWidget(widgetId, views);
  }
  protected abstract RemoteViews getRemoteViews(Context context, int widgetId, boolean isSmall,
      boolean isSingleLine,
      SparseArray<PendingIntent> pendingIntentsMap);
}
package it.feio.android.omninotes.helpers;
import static it.feio.android.checklistview.interfaces.Constants.TAG;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_ENABLE_FILE_LOGGING;
import android.content.Context;
import android.util.Log;
import com.bosphere.filelogger.FL;
import com.bosphere.filelogger.FLConfig;
import com.bosphere.filelogger.FLConst;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.exceptions.GenericException;
import it.feio.android.omninotes.utils.StorageHelper;
import java.io.File;
import lombok.experimental.UtilityClass;
@UtilityClass
public class LogDelegate {
  private static Boolean fileLoggingEnabled;
  public static void v(String message) {
    if (isFileLoggingEnabled()) {
      FL.v(message);
    } else {
      Log.v(TAG, message);
    }
  }
  public static void d(String message) {
    if (isFileLoggingEnabled()) {
      FL.d(message);
    } else {
      Log.d(TAG, message);
    }
  }
  public static void i(String message) {
    if (isFileLoggingEnabled()) {
      FL.i(message);
    } else {
      Log.i(TAG, message);
    }
  }
  public static void w(String message, Throwable e) {
    if (isFileLoggingEnabled()) {
      FL.w(message, e);
    } else {
      Log.w(TAG, message, e);
    }
  }
  public static void w(String message) {
    if (isFileLoggingEnabled()) {
      FL.w(message);
    } else {
      Log.w(TAG, message);
    }
  }
  public static void e(String message, Throwable e) {
    if (isFileLoggingEnabled()) {
      FL.e(message, e);
    } else {
      Log.e(TAG, message, e);
    }
  }
  public static void e(String message) {
    e(message, new GenericException(message));
  }
  private static boolean isFileLoggingEnabled() {
    if (fileLoggingEnabled == null) {
      fileLoggingEnabled = Prefs.getBoolean(PREF_ENABLE_FILE_LOGGING, false);
      if (Boolean.TRUE.equals(fileLoggingEnabled)) {
        Context context = OmniNotes.getAppContext();
        FL.init(new FLConfig.Builder(context)
            .minLevel(FLConst.Level.V)
            .logToFile(true)
            .dir(new File(StorageHelper.getOrCreateExternalStoragePublicDir(), "logs"))
            .retentionPolicy(FLConst.RetentionPolicy.FILE_COUNT)
            .build());
        FL.setEnabled(true);
      }
    }
    return fileLoggingEnabled;
  }
}
package it.feio.android.omninotes.async;
import android.content.Context;
import android.os.AsyncTask;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.BaseActivity;
import it.feio.android.omninotes.async.bus.NotesUpdatedEvent;
import java.lang.ref.WeakReference;
public class UpdateWidgetsTask extends AsyncTask<Void, Void, Void> {
  private WeakReference<Context> context;
  public UpdateWidgetsTask(Context context) {
    this.context = new WeakReference<>(context);
  }
  @Override
  protected Void doInBackground(Void... params) {
    WidgetUpdateSubscriber widgetUpdateSubscriber = new WidgetUpdateSubscriber();
    return null;
  }
  class WidgetUpdateSubscriber {
    WidgetUpdateSubscriber() {
      EventBus.getDefault().register(this);
    }
    public void onEvent(NotesUpdatedEvent event) {
      BaseActivity.notifyAppWidgets(context.get());
      EventBus.getDefault().unregister(this);
    }
  }
}
package it.feio.android.omninotes.async.notes;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.async.bus.NotesDeletedEvent;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.utils.StorageHelper;
import java.util.List;
public class NoteProcessorDelete extends NoteProcessor {
  private final boolean keepAttachments;
  public NoteProcessorDelete(List<Note> notes) {
    this(notes, false);
  }
  public NoteProcessorDelete(List<Note> notes, boolean keepAttachments) {
    super(notes);
    this.keepAttachments = keepAttachments;
  }
  @Override
  protected void processNote(Note note) {
    DbHelper db = DbHelper.getInstance();
    if (db.deleteNote(note) && !keepAttachments) {
      for (Attachment mAttachment : note.getAttachmentsList()) {
        StorageHelper
            .deleteExternalStoragePrivateFile(OmniNotes.getAppContext(), mAttachment.getUri()
                .getLastPathSegment());
      }
    }
  }
  @Override
  protected void afterProcess(List<Note> notes) {
    EventBus.getDefault().post(new NotesDeletedEvent(notes));
  }
}
package it.feio.android.omninotes.utils;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD_ANSWER;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PASSWORD_QUESTION;
import android.app.Activity;
import android.os.Handler;
import android.view.LayoutInflater;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.widget.EditText;
import com.afollestad.materialdialogs.DialogAction;
import com.afollestad.materialdialogs.MaterialDialog;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.async.bus.PasswordRemovedEvent;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.models.PasswordValidator;
import lombok.experimental.UtilityClass;
@UtilityClass
public class PasswordHelper {
  public static void requestPassword(final Activity mActivity,
      final PasswordValidator mPasswordValidator) {
    LayoutInflater inflater = mActivity.getLayoutInflater();
    final View v = inflater.inflate(R.layout.password_request_dialog_layout, null);
    final EditText passwordEditText = v.findViewById(R.id.password_request);
    MaterialDialog dialog = new MaterialDialog.Builder(mActivity)
        .autoDismiss(false)
        .title(R.string.insert_security_password)
        .customView(v, false)
        .positiveText(R.string.ok)
        .positiveColorRes(R.color.colorPrimary)
        .onPositive((dialog12, which) -> {
          String storedPassword = Prefs.getString(PREF_PASSWORD, "");
          String password = passwordEditText.getText().toString();
          boolean result = Security.md5(password).equals(storedPassword);
          if (result) {
            KeyboardUtils.hideKeyboard(passwordEditText);
            dialog12.dismiss();
            mPasswordValidator.onPasswordValidated(PasswordValidator.Result.SUCCEED);
          } else {
            passwordEditText.setError(mActivity.getString(R.string.wrong_password));
          }
        })
        .neutralText(mActivity.getResources().getString(R.string.password_forgot))
        .onNeutral((dialog13, which) -> {
          PasswordHelper.resetPassword(mActivity);
          mPasswordValidator.onPasswordValidated(PasswordValidator.Result.RESTORE);
          dialog13.dismiss();
        })
        .build();
    dialog.setOnCancelListener(dialog1 -> {
      KeyboardUtils.hideKeyboard(passwordEditText);
      dialog1.dismiss();
      mPasswordValidator.onPasswordValidated(PasswordValidator.Result.FAIL);
    });
    passwordEditText.setOnEditorActionListener((textView, actionId, keyEvent) -> {
      if (actionId == EditorInfo.IME_ACTION_DONE) {
        dialog.getActionButton(DialogAction.POSITIVE).callOnClick();
        return true;
      }
      return false;
    });
    dialog.show();
    new Handler().postDelayed(() -> KeyboardUtils.showKeyboard(passwordEditText), 100);
  }
  public static void resetPassword(final Activity mActivity) {
    View layout = mActivity.getLayoutInflater()
        .inflate(R.layout.password_reset_dialog_layout, null);
    final EditText answerEditText = layout.findViewById(R.id.reset_password_answer);
    MaterialDialog dialog = new MaterialDialog.Builder(mActivity)
        .title(Prefs.getString(PREF_PASSWORD_QUESTION, ""))
        .customView(layout, false)
        .autoDismiss(false)
        .contentColorRes(R.color.text_color)
        .positiveText(R.string.ok)
        .onPositive((dialogElement, which) -> {
          String oldAnswer = Prefs.getString(PREF_PASSWORD_ANSWER, "");
          String answer1 = answerEditText.getText().toString();
          boolean result = Security.md5(answer1).equals(oldAnswer);
          if (result) {
            dialogElement.dismiss();
            removePassword();
          } else {
            answerEditText.setError(mActivity.getString(R.string.wrong_answer));
          }
        }).build();
    dialog.show();
    answerEditText.setOnEditorActionListener((textView, actionId, keyEvent) -> {
      if (actionId == EditorInfo.IME_ACTION_DONE) {
        dialog.getActionButton(DialogAction.POSITIVE).callOnClick();
        return true;
      }
      return false;
    });
    new Handler().postDelayed(() -> KeyboardUtils.showKeyboard(answerEditText), 100);
  }
  public static void removePassword() {
    DbHelper.getInstance().getNotesWithLock(true).forEach(note -> {
      note.setLocked(false);
      DbHelper.getInstance().updateNote(note, false);
    });
    Prefs.edit()
        .remove(PREF_PASSWORD)
        .remove(PREF_PASSWORD_QUESTION)
        .remove(PREF_PASSWORD_ANSWER)
        .remove("settings_password_access")
        .apply();
    EventBus.getDefault().post(new PasswordRemovedEvent());
  }
}
package it.feio.android.omninotes.widget;
import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
import static it.feio.android.omninotes.helpers.IntentHelper.mutablePendingIntentFlag;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_WIDGET;
import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.util.SparseArray;
import android.widget.RemoteViews;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
public class ListWidgetProvider extends WidgetProvider {
  @Override
  protected RemoteViews getRemoteViews(Context mContext, int widgetId,
      boolean isSmall, boolean isSingleLine,
      SparseArray<PendingIntent> pendingIntentsMap) {
    RemoteViews views;
    if (isSmall) {
      views = new RemoteViews(mContext.getPackageName(),
          R.layout.widget_layout_small);
      views.setOnClickPendingIntent(R.id.list,
          pendingIntentsMap.get(R.id.list));
    } else if (isSingleLine) {
      views = new RemoteViews(mContext.getPackageName(),
          R.layout.widget_layout);
      views.setOnClickPendingIntent(R.id.add,
          pendingIntentsMap.get(R.id.add));
      views.setOnClickPendingIntent(R.id.list,
          pendingIntentsMap.get(R.id.list));
      views.setOnClickPendingIntent(R.id.camera,
          pendingIntentsMap.get(R.id.camera));
    } else {
      views = new RemoteViews(mContext.getPackageName(),
          R.layout.widget_layout_list);
      views.setOnClickPendingIntent(R.id.add,
          pendingIntentsMap.get(R.id.add));
      views.setOnClickPendingIntent(R.id.list,
          pendingIntentsMap.get(R.id.list));
      views.setOnClickPendingIntent(R.id.camera,
          pendingIntentsMap.get(R.id.camera));
      Intent intent = new Intent(mContext, ListWidgetService.class);
      intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, widgetId);
      intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));
      views.setRemoteAdapter(R.id.widget_list, intent);
      Intent clickIntent = new Intent(mContext, MainActivity.class);
      clickIntent.setAction(ACTION_WIDGET);
      PendingIntent clickPI = PendingIntent.getActivity(mContext, 0,
          clickIntent, mutablePendingIntentFlag(FLAG_UPDATE_CURRENT));
      views.setPendingIntentTemplate(R.id.widget_list, clickPI);
    }
    return views;
  }
}
package it.feio.android.omninotes.models.adapters;
import static android.graphics.Color.parseColor;
import static android.view.LayoutInflater.from;
import static it.feio.android.omninotes.databinding.DrawerListItemBinding.inflate;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import static java.lang.Integer.parseInt;
import android.app.Activity;
import android.graphics.LightingColorFilter;
import android.graphics.Typeface;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.adapters.category.CategoryViewHolder;
import java.util.List;
public class CategoryRecyclerViewAdapter extends RecyclerView.Adapter<CategoryViewHolder> {
  private final Activity mActivity;
  private final List<Category> categories;
  private final String navigationTmp;
  public CategoryRecyclerViewAdapter(Activity mActivity, List<Category> categories) {
    this(mActivity, categories, null);
  }
  public CategoryRecyclerViewAdapter(Activity mActivity, List<Category> categories,
      String navigationTmp) {
    this.mActivity = mActivity;
    this.categories = categories;
    this.navigationTmp = navigationTmp;
  }
  @Override
  public int getItemCount() {
    return categories.size();
  }
  @NonNull
  @Override
  public CategoryViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
    return new CategoryViewHolder(inflate(from(parent.getContext()), parent, false));
  }
  @Override
  public void onBindViewHolder(@NonNull CategoryViewHolder holder, int position) {
    var category = categories.get(position);
    holder.txtTitle.setText(category.getName());
    if (isSelected(position)) {
      holder.txtTitle.setTypeface(null, Typeface.BOLD);
      holder.txtTitle.setTextColor(parseInt(category.getColor()));
    } else {
      holder.txtTitle.setTypeface(null, Typeface.NORMAL);
      holder.txtTitle.setTextColor(mActivity.getResources().getColor(R.color.drawer_text));
    }
    if (category.getColor() != null && category.getColor().length() > 0) {
      var img = mActivity.getResources().getDrawable(R.drawable.ic_folder_special_black_24dp);
      var cf = new LightingColorFilter(parseColor("#000000"), parseInt(category.getColor()));
      img.mutate().setColorFilter(cf);
      holder.imgIcon.setImageDrawable(img);
      holder.imgIcon.setPadding(4, 4, 4, 4);
    }
    showCategoryCounter(holder, category);
  }
  private void showCategoryCounter(@NonNull CategoryViewHolder holder, Category category) {
    if (Prefs.getBoolean("settings_show_category_count", true)) {
      holder.count.setText(String.valueOf(category.getCount()));
      holder.count.setVisibility(View.VISIBLE);
    }
  }
  @Override
  public long getItemId(int position) {
    return position;
  }
  private boolean isSelected(int position) {
    var navigationListCodes = mActivity.getResources()
        .getStringArray(R.array.navigation_list_codes);
    var navigationTmpLocal = MainActivity.class.isAssignableFrom(mActivity.getClass())
        ? ((MainActivity) mActivity).getNavigationTmp()
        : null;
    navigationTmpLocal = this.navigationTmp != null ? this.navigationTmp : navigationTmpLocal;
    var navigation = navigationTmp != null
        ? navigationTmpLocal
        : Prefs.getString(PREF_NAVIGATION, navigationListCodes[0]);
    return navigation.equals(String.valueOf(categories.get(position).getId()));
  }
}
package it.feio.android.omninotes.async;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.view.LayoutInflater;
import android.view.View;
import androidx.fragment.app.Fragment;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.SettingsActivity;
import it.feio.android.omninotes.async.bus.NavigationUpdatedEvent;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.ONStyle;
import it.feio.android.omninotes.models.adapters.CategoryBaseAdapter;
import it.feio.android.omninotes.models.views.NonScrollableListView;
import java.lang.ref.WeakReference;
import java.util.Collections;
import java.util.List;
public class CategoryMenuTask extends AsyncTask<Void, Void, List<Category>> {
  private final WeakReference<Fragment> mFragmentWeakReference;
  private final MainActivity mainActivity;
  private NonScrollableListView mDrawerCategoriesList;
  private View settingsView;
  private View settingsViewCat;
  private NonScrollableListView mDrawerList;
  public CategoryMenuTask(Fragment mFragment) {
    mFragmentWeakReference = new WeakReference<>(mFragment);
    this.mainActivity = (MainActivity) mFragment.getActivity();
  }
  @Override
  protected void onPreExecute() {
    super.onPreExecute();
    mDrawerList = mainActivity.findViewById(R.id.drawer_nav_list);
    LayoutInflater inflater = (LayoutInflater) mainActivity
        .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    settingsView = mainActivity.findViewById(R.id.settings_view);
    mDrawerCategoriesList = mainActivity.findViewById(R.id.drawer_tag_list);
    if (mDrawerCategoriesList.getAdapter() == null
        && mDrawerCategoriesList.getFooterViewsCount() == 0) {
      settingsViewCat = inflater.inflate(R.layout.drawer_category_list_footer, null);
      mDrawerCategoriesList.addFooterView(settingsViewCat);
    } else {
      settingsViewCat = mDrawerCategoriesList.getChildAt(mDrawerCategoriesList.getChildCount() - 1);
    }
  }
  @Override
  protected List<Category> doInBackground(Void... params) {
    if (isAlive()) {
      return buildCategoryMenu();
    } else {
      cancel(true);
      return Collections.emptyList();
    }
  }
  @Override
  @Deprecated
  protected void onPostExecute(final List<Category> categories) {
    if (isAlive()) {
      mDrawerCategoriesList.setAdapter(new CategoryBaseAdapter(mainActivity, categories,
          mainActivity.getNavigationTmp()));
      if (categories.isEmpty()) {
        setWidgetVisibility(settingsViewCat, false);
        setWidgetVisibility(settingsView, true);
      } else {
        setWidgetVisibility(settingsViewCat, true);
        setWidgetVisibility(settingsView, false);
      }
      mDrawerCategoriesList.justifyListViewHeightBasedOnChildren();
    }
  }
  private void setWidgetVisibility(View view, boolean visible) {
    if (view != null) {
      view.setVisibility(visible ? View.VISIBLE : View.GONE);
    }
  }
  private boolean isAlive() {
    return mFragmentWeakReference.get() != null
        && mFragmentWeakReference.get().isAdded()
        && mFragmentWeakReference.get().getActivity() != null
        && !mFragmentWeakReference.get().getActivity().isFinishing();
  }
  private List<Category> buildCategoryMenu() {
    List<Category> categories = DbHelper.getInstance().getCategories();
    View settings = categories.isEmpty() ? settingsView : settingsViewCat;
    if (settings == null) {
      return categories;
    }
    mainActivity.runOnUiThread(() -> {
      settings.setOnClickListener(v -> {
        Intent settingsIntent = new Intent(mainActivity, SettingsActivity.class);
        mainActivity.startActivity(settingsIntent);
      });
      buildCategoryMenuClickEvent();
      buildCategoryMenuLongClickEvent();
    });
    return categories;
  }
  private void buildCategoryMenuLongClickEvent() {
    mDrawerCategoriesList.setOnItemLongClickListener((arg0, view, position, arg3) -> {
      if (mDrawerCategoriesList.getAdapter() != null) {
        Object item = mDrawerCategoriesList.getAdapter().getItem(position);
        if (item != null) {
          mainActivity.editTag((Category) item);
        }
      } else {
        mainActivity.showMessage(R.string.category_deleted, ONStyle.ALERT);
      }
      return true;
    });
  }
  private void buildCategoryMenuClickEvent() {
    mDrawerCategoriesList.setOnItemClickListener((arg0, arg1, position, arg3) -> {
      Object item = mDrawerCategoriesList.getAdapter().getItem(position);
      if (mainActivity.updateNavigation(String.valueOf(((Category) item).getId()))) {
        mDrawerCategoriesList.setItemChecked(position, true);
        if (mDrawerList != null) {
          mDrawerList.setItemChecked(0, false);
          EventBus.getDefault()
              .post(new NavigationUpdatedEvent(mDrawerCategoriesList.getItemAtPosition
                  (position)));
        }
      }
    });
  }
}
package it.feio.android.omninotes.async;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_DYNAMIC_MENU;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_SHOW_UNCATEGORIZED;
import android.content.Intent;
import android.content.res.TypedArray;
import android.os.AsyncTask;
import androidx.fragment.app.Fragment;
import com.pixplicity.easyprefs.library.Prefs;
import de.greenrobot.event.EventBus;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.async.bus.NavigationUpdatedEvent;
import it.feio.android.omninotes.models.NavigationItem;
import it.feio.android.omninotes.models.adapters.NavDrawerAdapter;
import it.feio.android.omninotes.models.misc.DynamicNavigationLookupTable;
import it.feio.android.omninotes.models.views.NonScrollableListView;
import it.feio.android.omninotes.utils.Navigation;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;
public class MainMenuTask extends AsyncTask<Void, Void, List<NavigationItem>> {
  private final WeakReference<Fragment> fragmentWeakReference;
  private final WeakReference<MainActivity> mainActivity;
  private NonScrollableListView navDrawer;
  public MainMenuTask(Fragment fragment) {
    fragmentWeakReference = new WeakReference<>(fragment);
    mainActivity = new WeakReference<>((MainActivity) fragment.getActivity());
  }
  @Override
  protected List<NavigationItem> doInBackground(Void... params) {
    return buildMainMenu();
  }
  @Override
  protected void onPostExecute(final List<NavigationItem> items) {
    navDrawer = mainActivity.get().findViewById(R.id.drawer_nav_list);
    if (isAlive()) {
      navDrawer.setAdapter(new NavDrawerAdapter(mainActivity.get(), items));
      navDrawer.setOnItemClickListener((arg0, arg1, position, arg3) -> {
        String navigation = fragmentWeakReference.get().getResources().getStringArray(R.array
            .navigation_list_codes)[items.get(position).getArrayIndex()];
        updateNavigation(position, navigation);
      });
      navDrawer.justifyListViewHeightBasedOnChildren();
    }
  }
  private void updateNavigation(int position, String navigation) {
    if (mainActivity.get().updateNavigation(navigation)) {
      navDrawer.setItemChecked(position, true);
      navDrawer.setItemChecked(0, false); 
      mainActivity.get().getIntent().setAction(Intent.ACTION_MAIN);
      EventBus.getDefault()
          .post(new NavigationUpdatedEvent(navDrawer.getItemAtPosition(position)));
    }
  }
  private boolean isAlive() {
    return fragmentWeakReference.get() != null
        && fragmentWeakReference.get().isAdded()
        && fragmentWeakReference.get().getActivity() != null
        && !fragmentWeakReference.get().getActivity().isFinishing();
  }
  private List<NavigationItem> buildMainMenu() {
    if (!isAlive()) {
      return new ArrayList<>();
    }
    String[] mNavigationArray = mainActivity.get().getResources().getStringArray(R.array.navigation_list);
    TypedArray mNavigationIconsArray = mainActivity.get().getResources()
        .obtainTypedArray(R.array.navigation_list_icons);
    TypedArray mNavigationIconsSelectedArray = mainActivity.get().getResources().obtainTypedArray(R.array
        .navigation_list_icons_selected);
    final List<NavigationItem> items = new ArrayList<>();
    for (int i = 0; i < mNavigationArray.length; i++) {
      if (!checkSkippableItem(i)) {
        NavigationItem item = new NavigationItem(i, mNavigationArray[i],
            mNavigationIconsArray.getResourceId(i,
                0), mNavigationIconsSelectedArray.getResourceId(i, 0));
        items.add(item);
      }
    }
    return items;
  }
  private boolean checkSkippableItem(int i) {
    boolean skippable = false;
    boolean dynamicMenu = Prefs.getBoolean(PREF_DYNAMIC_MENU, true);
    DynamicNavigationLookupTable dynamicNavigationLookupTable = null;
    if (dynamicMenu) {
      dynamicNavigationLookupTable = DynamicNavigationLookupTable.getInstance();
    }
    switch (i) {
      case Navigation.REMINDERS:
        if (dynamicMenu && dynamicNavigationLookupTable.getReminders() == 0) {
          skippable = true;
        }
        break;
      case Navigation.UNCATEGORIZED:
        boolean showUncategorized = Prefs.getBoolean(PREF_SHOW_UNCATEGORIZED, false);
        if (!showUncategorized || (dynamicMenu
            && dynamicNavigationLookupTable.getUncategorized() == 0)) {
          skippable = true;
        }
        break;
      case Navigation.ARCHIVE:
        if (dynamicMenu && dynamicNavigationLookupTable.getArchived() == 0) {
          skippable = true;
        }
        break;
      case Navigation.TRASH:
        if (dynamicMenu && dynamicNavigationLookupTable.getTrashed() == 0) {
          skippable = true;
        }
        break;
    }
    return skippable;
  }
}
package it.feio.android.omninotes.models.adapters;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import android.app.Activity;
import android.content.Context;
import android.graphics.PorterDuff;
import android.graphics.Typeface;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageView;
import com.neopixl.pixlui.components.textview.TextView;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.models.NavigationItem;
import java.util.Arrays;
import java.util.List;
public class NavDrawerAdapter extends BaseAdapter {
  private Activity mActivity;
  private List<NavigationItem> items;
  private LayoutInflater inflater;
  public NavDrawerAdapter(Activity mActivity, List<NavigationItem> items) {
    this.mActivity = mActivity;
    this.items = items;
    inflater = (LayoutInflater) mActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
  @Override
  public int getCount() {
    return items.size();
  }
  @Override
  public Object getItem(int position) {
    return items.get(position);
  }
  @Override
  public long getItemId(int position) {
    return position;
  }
  public View getView(int position, View convertView, ViewGroup parent) {
    NoteDrawerAdapterViewHolder holder;
    if (convertView == null) {
      convertView = inflater.inflate(R.layout.drawer_list_item, parent, false);
      holder = new NoteDrawerAdapterViewHolder();
      holder.imgIcon = convertView.findViewById(R.id.icon);
      holder.txtTitle = convertView.findViewById(R.id.title);
      convertView.setTag(holder);
    } else {
      holder = (NoteDrawerAdapterViewHolder) convertView.getTag();
    }
    holder.txtTitle.setText(items.get(position).getText());
    if (isSelected(position)) {
      holder.imgIcon.setImageResource(items.get(position).getIconSelected());
      holder.txtTitle.setTypeface(null, Typeface.BOLD);
      int color = mActivity.getResources().getColor(R.color.colorPrimaryDark);
      holder.txtTitle.setTextColor(color);
      holder.imgIcon.getDrawable().mutate().setColorFilter(color, PorterDuff.Mode.SRC_ATOP);
    } else {
      holder.imgIcon.setImageResource(items.get(position).getIcon());
      holder.txtTitle.setTypeface(null, Typeface.NORMAL);
      holder.txtTitle.setTextColor(mActivity.getResources().getColor(R.color.drawer_text));
    }
    return convertView;
  }
  private boolean isSelected(int position) {
    String[] navigationListCodes = mActivity.getResources()
        .getStringArray(R.array.navigation_list_codes);
    String navigationTmp =
        MainActivity.class.isAssignableFrom(mActivity.getClass()) ? ((MainActivity) mActivity)
            .getNavigationTmp() : null;
    String navigation = navigationTmp != null ? navigationTmp
        : Prefs.getString(PREF_NAVIGATION, navigationListCodes[0]);
    int index = Arrays.asList(navigationListCodes).indexOf(navigation);
    if (index == -1) {
      return false;
    }
    String navigationLocalized = mActivity.getResources()
        .getStringArray(R.array.navigation_list)[index];
    return navigationLocalized.equals(items.get(position).getText());
  }
}
class NoteDrawerAdapterViewHolder {
  ImageView imgIcon;
  TextView txtTitle;
}
package it.feio.android.omninotes.models.adapters;
import static it.feio.android.omninotes.databinding.DrawerListItemBinding.inflate;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_NAVIGATION;
import android.app.Activity;
import android.content.Context;
import android.graphics.Color;
import android.graphics.LightingColorFilter;
import android.graphics.Typeface;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.models.Category;
import it.feio.android.omninotes.models.adapters.category.CategoryViewHolder;
import java.util.List;
public class CategoryBaseAdapter extends BaseAdapter {
  private final Activity mActivity;
  private final int layout;
  private final List<Category> categories;
  private final LayoutInflater inflater;
  private final String navigationTmp;
  public CategoryBaseAdapter(Activity mActivity, List<Category> categories) {
    this(mActivity, categories, null);
  }
  public CategoryBaseAdapter(Activity mActivity, List<Category> categories, String navigationTmp) {
    this.mActivity = mActivity;
    this.layout = R.layout.drawer_list_item;
    this.categories = categories;
    this.navigationTmp = navigationTmp;
    inflater = (LayoutInflater) mActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
  }
  @Override
  public int getCount() {
    return categories.size();
  }
  @Override
  public Object getItem(int position) {
    return categories.get(position);
  }
  @Override
  public long getItemId(int position) {
    return position;
  }
  public View getView(int position, View convertView, ViewGroup parent) {
    var category = categories.get(position);
    CategoryViewHolder holder;
    if (convertView == null) {
      convertView = inflater.inflate(layout, parent, false);
      holder = new CategoryViewHolder(
          inflate(LayoutInflater.from(parent.getContext()), parent, false));
      holder.imgIcon = convertView.findViewById(R.id.icon);
      holder.txtTitle = convertView.findViewById(R.id.title);
      holder.count = convertView.findViewById(R.id.count);
      convertView.setTag(holder);
    } else {
      holder = (CategoryViewHolder) convertView.getTag();
    }
    holder.txtTitle.setText(category.getName());
    if (isSelected(position)) {
      holder.txtTitle.setTypeface(null, Typeface.BOLD);
      holder.txtTitle.setTextColor(Integer.parseInt(category.getColor()));
    } else {
      holder.txtTitle.setTypeface(null, Typeface.NORMAL);
      holder.txtTitle.setTextColor(mActivity.getResources().getColor(R.color.drawer_text));
    }
    if (category.getColor() != null && category.getColor().length() > 0) {
      var img = mActivity.getResources().getDrawable(R.drawable.ic_folder_special_black_24dp);
      var cf = new LightingColorFilter(Color.parseColor("#000000"),
          Integer.parseInt(category.getColor()));
      img.mutate().setColorFilter(cf);
      holder.imgIcon.setImageDrawable(img);
      int padding = 4;
      holder.imgIcon.setPadding(padding, padding, padding, padding);
    }
    if (Prefs.getBoolean("settings_show_category_count", true)) {
      holder.count.setText(String.valueOf(category.getCount()));
      holder.count.setVisibility(View.VISIBLE);
    }
    return convertView;
  }
  private boolean isSelected(int position) {
    var navigationListCodes = mActivity.getResources()
        .getStringArray(R.array.navigation_list_codes);
    var navigationTmpLocal = MainActivity.class.isAssignableFrom(mActivity.getClass())
        ? ((MainActivity) mActivity).getNavigationTmp()
        : null;
    navigationTmpLocal = this.navigationTmp != null ? this.navigationTmp : navigationTmpLocal;
    var navigation = navigationTmp != null
        ? navigationTmpLocal
        : Prefs.getString(PREF_NAVIGATION, navigationListCodes[0]);
    return navigation.equals(String.valueOf(categories.get(position).getId()));
  }
}
package it.feio.android.omninotes.ui;
import static androidx.test.espresso.Espresso.onView;
import static androidx.test.espresso.action.ViewActions.click;
import static androidx.test.espresso.action.ViewActions.closeSoftKeyboard;
import static androidx.test.espresso.action.ViewActions.replaceText;
import static androidx.test.espresso.action.ViewActions.scrollTo;
import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
import static androidx.test.espresso.matcher.ViewMatchers.withId;
import static androidx.test.espresso.matcher.ViewMatchers.withParent;
import static org.hamcrest.Matchers.allOf;
import androidx.core.view.GravityCompat;
import androidx.test.espresso.ViewInteraction;
import androidx.test.espresso.matcher.ViewMatchers;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import it.feio.android.omninotes.R;
import org.hamcrest.Matchers;
import org.junit.Test;
import org.junit.runner.RunWith;
@LargeTest
@RunWith(AndroidJUnit4.class)
public class NoteLifecycleTest extends BaseEspressoTest {
  @Test
  public void createNote() {
    String title = "Note title";
    String content = "Note content";
    ViewInteraction viewInteraction = onView(
        Matchers.allOf(ViewMatchers.withId(R.id.fab_expand_menu_button),
            withParent(withId(R.id.fab)),
            isDisplayed()));
    if (activityRule.getActivity().getDrawerLayout().isDrawerOpen(GravityCompat.START)) {
      viewInteraction.perform(click());
    }
    viewInteraction.perform(click());
    onView(allOf(withId(R.id.fab_note),
        withParent(withId(R.id.fab)),
        isDisplayed())).perform(click());
    onView(allOf(withId(R.id.detail_title),
        withParent(allOf(withId(R.id.title_wrapper),
            withParent(withId(R.id.detail_tile_card)))),
        isDisplayed())).perform(click());
    onView(allOf(withId(R.id.detail_title),
        withParent(allOf(withId(R.id.title_wrapper),
            withParent(withId(R.id.detail_tile_card)))),
        isDisplayed())).perform(replaceText(title), closeSoftKeyboard());
    onView(withId(R.id.detail_content))
        .perform(scrollTo(), replaceText(content), closeSoftKeyboard());
    navigateUp();
  }
}
package it.feio.android.omninotes.ui;
import static androidx.test.espresso.Espresso.onData;
import static androidx.test.espresso.Espresso.onView;
import static androidx.test.espresso.action.ViewActions.click;
import static androidx.test.espresso.action.ViewActions.scrollTo;
import static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;
import static androidx.test.espresso.matcher.ViewMatchers.isRoot;
import static androidx.test.espresso.matcher.ViewMatchers.withClassName;
import static androidx.test.espresso.matcher.ViewMatchers.withContentDescription;
import static androidx.test.espresso.matcher.ViewMatchers.withId;
import static org.hamcrest.Matchers.allOf;
import static org.hamcrest.Matchers.anything;
import static org.hamcrest.Matchers.is;
import android.view.InputDevice;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewParent;
import androidx.test.espresso.PerformException;
import androidx.test.espresso.UiController;
import androidx.test.espresso.ViewAction;
import androidx.test.espresso.action.GeneralLocation;
import androidx.test.espresso.action.GeneralSwipeAction;
import androidx.test.espresso.action.Press;
import androidx.test.espresso.action.Swipe;
import androidx.test.espresso.action.Tap;
import androidx.test.espresso.action.ViewActions;
import androidx.test.espresso.contrib.RecyclerViewActions;
import androidx.test.espresso.util.HumanReadables;
import androidx.test.espresso.util.TreeIterables;
import androidx.test.rule.ActivityTestRule;
import it.feio.android.omninotes.testutils.BaseAndroidTestCase;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.utils.ClickWithoutDisplayConstraint;
import java.util.concurrent.TimeoutException;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;
import org.junit.Before;
import org.junit.Rule;
public class BaseEspressoTest extends BaseAndroidTestCase {
  @Rule
  public ActivityTestRule<MainActivity> activityRule = new ActivityTestRule<>(MainActivity.class,
      false, false);
  static Matcher<View> childAtPosition(
      final Matcher<View> parentMatcher, final int position) {
    return new TypeSafeMatcher<View>() {
      @Override
      public void describeTo(Description description) {
        description.appendText("Child at position " + position + " in parent ");
        parentMatcher.describeTo(description);
      }
      @Override
      public boolean matchesSafely(View view) {
        ViewParent parent = view.getParent();
        return parent instanceof ViewGroup && parentMatcher.matches(parent)
            && view.equals(((ViewGroup) parent).getChildAt(position));
      }
    };
  }
  @Before
  public void setUp() {
    activityRule.launchActivity(null);
  }
  void selectNoteInList(int number) {
    onView(withId(R.id.list)).perform(RecyclerViewActions.actionOnItemAtPosition(number, click()));
  }
  void navigateUp() {
    onView(allOf(childAtPosition(allOf(withId(R.id.toolbar),
        childAtPosition(withClassName(is("android.widget.RelativeLayout")), 0)
    ), 0), isDisplayed())).perform(click());
  }
  void navigateUPSearch() {
    onView(allOf(childAtPosition(allOf(withId(R.id.toolbar),
        childAtPosition(withClassName(is("android.widget.RelativeLayout")), 0)
    ), 1), isDisplayed())).perform(click());
  }
  void navigateUpSettings() {
    onView(allOf(withContentDescription(R.string.abc_action_bar_up_description),
        childAtPosition(allOf(withId(R.id.toolbar),
            childAtPosition(withClassName(is("android.widget.RelativeLayout")), 0)),
            1), isDisplayed())).perform(click());
  }
  public static ViewAction waitId(final int viewId, final long millis) {
    return new ViewAction() {
      @Override
      public Matcher<View> getConstraints() {
        return isRoot();
      }
      @Override
      public String getDescription() {
        return "wait for a specific view with id <" + viewId + "> during " + millis + " millis.";
      }
      @Override
      public void perform(final UiController uiController, final View view) {
        uiController.loopMainThreadUntilIdle();
        final long startTime = System.currentTimeMillis();
        final long endTime = startTime + millis;
        final Matcher<View> viewMatcher = withId(viewId);
        do {
          for (View child : TreeIterables.breadthFirstViewTraversal(view)) {
            if (viewMatcher.matches(child)) {
              return;
            }
          }
          uiController.loopMainThreadForAtLeast(50);
        }
        while (System.currentTimeMillis() < endTime);
        throw new PerformException.Builder()
            .withActionDescription(this.getDescription())
            .withViewDescription(HumanReadables.describe(view))
            .withCause(new TimeoutException())
            .build();
      }
    };
  }
  ClickWithoutDisplayConstraint getClickAction() {
    return new ClickWithoutDisplayConstraint(
        Tap.SINGLE,
        GeneralLocation.VISIBLE_CENTER,
        Press.FINGER,
        InputDevice.SOURCE_UNKNOWN,
        MotionEvent.BUTTON_PRIMARY);
  }
  ClickWithoutDisplayConstraint getLongClickAction() {
    return new ClickWithoutDisplayConstraint(
        Tap.LONG,
        GeneralLocation.CENTER,
        Press.FINGER,
        InputDevice.SOURCE_UNKNOWN,
        MotionEvent.BUTTON_PRIMARY);
  }
  ViewAction getSwipeAction(final int fromX, final int fromY, final int toX, final int toY) {
    return ViewActions.actionWithAssertions(
        new GeneralSwipeAction(
            Swipe.SLOW,
            view -> new float[]{fromX, fromY},
            view -> new float[]{toX, toY},
            Press.FINGER));
  }
  protected void openDrawer() {
    onView(allOf(withContentDescription("drawer open"),
        childAtPosition(
            allOf(withId(R.id.toolbar),
                childAtPosition(
                    withClassName(is("android.widget.RelativeLayout")),
                    0)),
            1),
        isDisplayed())).perform(click());
  }
  protected void navigateTo(int menuPosition) {
    openDrawer();
    onData(anything())
        .inAdapterView(allOf(withId(R.id.drawer_nav_list),
            childAtPosition(
                withId(R.id.left_drawer),
                1)))
        .atPosition(menuPosition).perform(scrollTo(), click());
  }
}
package it.feio.android.omninotes.utils;
import static it.feio.android.omninotes.helpers.IntentHelper.immutablePendingIntentFlag;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_KEY;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_PRETTIFIED_DATES;
import static java.util.Collections.singletonList;
import android.annotation.TargetApi;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ShortcutInfo;
import android.content.pm.ShortcutManager;
import android.graphics.drawable.Icon;
import android.net.Uri;
import android.os.Build.VERSION_CODES;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.helpers.BuildHelper;
import it.feio.android.omninotes.helpers.date.DateHelper;
import it.feio.android.omninotes.models.Note;
import lombok.SneakyThrows;
import lombok.experimental.UtilityClass;
@UtilityClass
public class ShortcutHelper {
  public static void addShortcut(Context context, Note note) {
    String shortcutTitle =
        note.getTitle().length() > 0 ? note.getTitle() : DateHelper.getFormattedDate(note
                .getCreation(),
            Prefs.getBoolean(PREF_PRETTIFIED_DATES, true));
    if (BuildHelper.isBelow(VERSION_CODES.O)) {
      createShortcutPreOreo(context, note, shortcutTitle);
    } else {
      createShortcutPostOreo(context, note, shortcutTitle);
    }
  }
  @TargetApi(VERSION_CODES.O)
  private static void createShortcutPostOreo(Context context, Note note, String shortcutTitle) {
    ShortcutManager shortcutManager = context.getSystemService(ShortcutManager.class);
    if (shortcutManager.isRequestPinShortcutSupported()) {
      Uri uri = new Uri.Builder().scheme("app")
          .authority(context.getString(R.string.app_package))
          .appendQueryParameter("id", String.valueOf(note.get_id()))
          .build();
      Intent intent = new Intent(Intent.ACTION_VIEW, uri);
      ShortcutInfo pinShortcutInfo = new ShortcutInfo
          .Builder(context, String.valueOf(note.get_id()))
          .setIcon(createShortcutIcon(context, note))
          .setIntent(intent)
          .setShortLabel(shortcutTitle)
          .build();
      Intent pinnedShortcutCallbackIntent = shortcutManager
          .createShortcutResultIntent(pinShortcutInfo);
      PendingIntent successCallback = PendingIntent
          .getBroadcast(context, 0, pinnedShortcutCallbackIntent, immutablePendingIntentFlag(0));
      shortcutManager.requestPinShortcut(pinShortcutInfo, successCallback.getIntentSender()
      );
    }
  }
  @SneakyThrows
  @TargetApi(VERSION_CODES.O)
  private static Icon createShortcutIcon(Context context, Note note) {
    if (note.getAttachmentsList().isEmpty()) {
      return Icon.createWithResource(context, R.drawable.ic_shortcut);
    } else {
      return Icon.createWithBitmap(
          BitmapHelper.getBitmapFromAttachment(context, note.getAttachmentsList().get(0), 64, 64));
    }
  }
  private static void createShortcutPreOreo(Context context, Note note, String shortcutTitle) {
    Intent shortcutIntent = new Intent(context, MainActivity.class);
    shortcutIntent.putExtra(INTENT_KEY, note.get_id());
    shortcutIntent.setAction(ACTION_SHORTCUT);
    Intent addIntent = new Intent();
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, shortcutTitle);
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE,
        Intent.ShortcutIconResource.fromContext(context, R.drawable.ic_shortcut));
    addIntent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
    context.sendBroadcast(addIntent);
  }
  public static void removeShortcut(Context context, Note note) {
    if (BuildHelper.isBelow(VERSION_CODES.O)) {
      removeShortcutPreOreo(context, note);
    } else {
      removeShortcutPostOreo(context, note);
    }
  }
  @TargetApi(VERSION_CODES.O)
  private static void removeShortcutPostOreo(Context context, Note note) {
    ShortcutManager shortcutManager = context.getSystemService(ShortcutManager.class);
    shortcutManager.getPinnedShortcuts().stream()
        .filter(ps -> ps.getId().equals(String.valueOf(note.get_id())))
        .forEach(ps -> shortcutManager.disableShortcuts(singletonList(ps.getId()),
            context.getString(R.string.shortcut_disabled)));
  }
  private static void removeShortcutPreOreo(Context context, Note note) {
    Intent shortcutIntent = new Intent(context, MainActivity.class);
    shortcutIntent.putExtra(INTENT_KEY, note.get_id());
    shortcutIntent.setAction(ACTION_SHORTCUT);
    Intent addIntent = new Intent();
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
    String shortcutTitle =
        note.getTitle().length() > 0 ? note.getTitle() : DateHelper.getFormattedDate(note
                .getCreation(),
            Prefs.getBoolean(PREF_PRETTIFIED_DATES, true));
    addIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, shortcutTitle);
    addIntent.setAction("com.android.launcher.action.UNINSTALL_SHORTCUT");
    context.sendBroadcast(addIntent);
  }
}
package it.feio.android.omninotes.async;
import static android.app.PendingIntent.FLAG_UPDATE_CURRENT;
import static it.feio.android.omninotes.helpers.IntentHelper.immutablePendingIntentFlag;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_RESTART_APP;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_BACKUP_FOLDER_URI;
import android.annotation.TargetApi;
import android.app.IntentService;
import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Build.VERSION_CODES;
import com.lazygeniouz.dfc.file.DocumentFileCompat;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.OmniNotes;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.exceptions.BackupException;
import it.feio.android.omninotes.helpers.BackupHelper;
import it.feio.android.omninotes.helpers.DocumentFileHelper;
import it.feio.android.omninotes.helpers.LogDelegate;
import it.feio.android.omninotes.helpers.SpringImportHelper;
import it.feio.android.omninotes.helpers.notifications.NotificationChannels.NotificationChannelNames;
import it.feio.android.omninotes.helpers.notifications.NotificationsHelper;
import it.feio.android.omninotes.models.Attachment;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.listeners.OnAttachingFileListener;
import it.feio.android.omninotes.utils.ReminderHelper;
import java.io.IOException;
public class DataBackupIntentService extends IntentService implements OnAttachingFileListener {
  public static final String INTENT_BACKUP_NAME = "backup_name";
  public static final String ACTION_DATA_EXPORT = "action_data_export";
  public static final String ACTION_DATA_IMPORT = "action_data_import";
  public static final String ACTION_DATA_DELETE = "action_data_delete";
  private NotificationsHelper mNotificationsHelper;
  public DataBackupIntentService() {
    super("DataBackupIntentService");
  }
  @Override
  protected void onHandleIntent(Intent intent) {
    mNotificationsHelper = new NotificationsHelper(this).start(NotificationChannelNames.BACKUPS,
        R.drawable.ic_content_save_white_24dp, getString(R.string.working));
    if (ACTION_DATA_EXPORT.equals(intent.getAction())) {
      exportData(intent);
    } else if (ACTION_DATA_IMPORT.equals(intent.getAction())) {
      importData(intent);
    } else if (SpringImportHelper.ACTION_DATA_IMPORT_SPRINGPAD.equals(intent.getAction())) {
      importDataFromSpringpad(intent, mNotificationsHelper);
    } else if (ACTION_DATA_DELETE.equals(intent.getAction())) {
      deleteData(intent);
    }
  }
  private void importDataFromSpringpad(Intent intent, NotificationsHelper mNotificationsHelper) {
    new SpringImportHelper(OmniNotes.getAppContext())
        .importDataFromSpringpad(intent, mNotificationsHelper);
    String title = getString(R.string.data_import_completed);
    String text = getString(R.string.click_to_refresh_application);
    createNotification(intent, this, title, text);
  }
  private void exportData(Intent intent) {
    String backupName = intent.getStringExtra(INTENT_BACKUP_NAME);
    var backupDir = DocumentFileCompat.Companion.fromTreeUri(getBaseContext(),
        Uri.parse(Prefs.getString(PREF_BACKUP_FOLDER_URI, null))).createDirectory(backupName);
    BackupHelper.exportNotes(backupDir);
    BackupHelper.exportAttachments(backupDir, mNotificationsHelper);
    var readableBackupFolder = BackupHelper.getBackupFolderPath() + "/" + backupName;
    mNotificationsHelper.finish(getString(R.string.data_export_completed), readableBackupFolder);
  }
  @TargetApi(VERSION_CODES.O)
  private synchronized void importData(Intent intent) {
    var backupDir = DocumentFileCompat.Companion.fromTreeUri(getBaseContext(),
            Uri.parse(Prefs.getString(PREF_BACKUP_FOLDER_URI, null))).listFiles().stream()
        .filter(f -> f.getName().equals(intent.getStringExtra(INTENT_BACKUP_NAME))).findFirst();
    if (!backupDir.isPresent()) {
      throw new BackupException("Backup folder not found", new RuntimeException());
    }
    BackupHelper.importNotes(backupDir.get());
    BackupHelper.importAttachments(backupDir.get(), mNotificationsHelper);
    resetReminders();
    mNotificationsHelper.cancel();
    createNotification(intent, this, getString(R.string.data_import_completed),
        getString(R.string.click_to_refresh_application));
  }
  private synchronized void deleteData(Intent intent) {
    String backupName = intent.getStringExtra(INTENT_BACKUP_NAME);
    var backupDir = DocumentFileCompat.Companion.fromTreeUri(getBaseContext(),
            Uri.parse(Prefs.getString(PREF_BACKUP_FOLDER_URI, null))).listFiles().stream()
        .filter(f -> f.getName().equals(intent.getStringExtra(INTENT_BACKUP_NAME)))
        .findFirst();
    if (backupDir.isPresent()) {
      try {
        if (DocumentFileHelper.delete(backupDir.get())) {
          mNotificationsHelper.finish(getString(R.string.data_deletion_completed),
              backupName + " " + getString(R.string.deleted));
        } else {
          LogDelegate.e("Can't delete backup " + backupName);
          mNotificationsHelper.finish(getString(R.string.data_deletion_error), backupName);
        }
      } catch (IOException e) {
        LogDelegate.e("Can't delete backup " + backupName, e);
        mNotificationsHelper.finish(getString(R.string.data_deletion_error), backupName);
      }
    }
  }
  private void createNotification(Intent intent, Context context, String title, String message) {
    Intent intentLaunch;
    if (DataBackupIntentService.ACTION_DATA_IMPORT.equals(intent.getAction())
        || SpringImportHelper.ACTION_DATA_IMPORT_SPRINGPAD.equals(intent.getAction())) {
      intentLaunch = new Intent(context, MainActivity.class);
      intentLaunch.setAction(ACTION_RESTART_APP);
    } else {
      intentLaunch = new Intent();
    }
    intentLaunch.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intentLaunch.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    PendingIntent notifyIntent = PendingIntent.getActivity(context, 0, intentLaunch,
        immutablePendingIntentFlag(FLAG_UPDATE_CURRENT));
    NotificationsHelper notificationsHelper = new NotificationsHelper(context);
    notificationsHelper.createStandardNotification(NotificationChannelNames.BACKUPS,
        R.drawable.ic_content_save_white_24dp, title, notifyIntent)
        .setMessage(message).setRingtone(Prefs.getString("settings_notification_ringtone", null))
        .setLedActive();
    if (Prefs.getBoolean("settings_notification_vibration", true)) {
      notificationsHelper.setVibration();
    }
    notificationsHelper.show();
  }
  private void resetReminders() {
    LogDelegate.d("Resetting reminders");
    for (Note note : DbHelper.getInstance().getNotesWithReminderNotFired()) {
      ReminderHelper.addReminder(OmniNotes.getAppContext(), note);
    }
  }
  @Override
  public void onAttachingFileErrorOccurred(Attachment mAttachment) {
  }
  @Override
  public void onAttachingFileFinished(Attachment mAttachment) {
  }
}
package it.feio.android.omninotes;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SHORTCUT_WIDGET;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
public class ShortcutActivity extends Activity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    Intent shortcutIntent = new Intent(this, MainActivity.class);
    shortcutIntent.setAction(ACTION_SHORTCUT_WIDGET);
    Intent.ShortcutIconResource iconResource = Intent.ShortcutIconResource
        .fromContext(this, R.drawable
            .shortcut_icon);
    Intent intent = new Intent();
    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, getString(R.string.add_note));
    intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconResource);
    setResult(RESULT_OK, intent);
    finish();
  }
}
package it.feio.android.omninotes.extensions;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_UPDATE_DASHCLOCK;
import android.annotation.SuppressLint;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import com.google.android.apps.dashclock.api.DashClockExtension;
import com.google.android.apps.dashclock.api.ExtensionData;
import it.feio.android.omninotes.MainActivity;
import it.feio.android.omninotes.R;
import it.feio.android.omninotes.db.DbHelper;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.utils.TextHelper;
import it.feio.android.omninotes.utils.date.DateUtils;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
public class ONDashClockExtension extends DashClockExtension {
  private enum Counters {ACTIVE, REMINDERS, TODAY, TOMORROW}
  private DashClockUpdateReceiver mDashClockReceiver;
  @Override
  protected void onInitialize(boolean isReconnect) {
    super.onInitialize(isReconnect);
    LocalBroadcastManager broadcastMgr = LocalBroadcastManager.getInstance(this);
    if (mDashClockReceiver != null) {
      broadcastMgr.unregisterReceiver(mDashClockReceiver);
    }
    mDashClockReceiver = new DashClockUpdateReceiver();
    broadcastMgr.registerReceiver(mDashClockReceiver, new IntentFilter(INTENT_UPDATE_DASHCLOCK));
  }
  @SuppressLint("DefaultLocale")
  @Override
  protected void onUpdateData(int reason) {
    Map<Counters, List<Note>> notesCounters = getNotesCounters();
    int reminders = notesCounters.get(Counters.REMINDERS).size();
    StringBuilder expandedTitle = new StringBuilder();
    expandedTitle.append(notesCounters.get(Counters.ACTIVE).size()).append(" ").append(
        getString(R.string.notes).toLowerCase());
    if (reminders > 0) {
      expandedTitle.append(", ").append(reminders).append(" ")
          .append(getString(R.string.reminders));
    }
    StringBuilder expandedBody = new StringBuilder();
    if (!notesCounters.get(Counters.TODAY).isEmpty()) {
      expandedBody.append(notesCounters.get(Counters.TODAY).size()).append(" ").append(
          getString(R.string.today)).append(":");
      for (Note todayReminder : notesCounters.get(Counters.TODAY)) {
        expandedBody.append(System.getProperty("line.separator")).append(("☆ "))
            .append(getNoteTitle(this,
                todayReminder));
      }
      expandedBody.append("\n");
    }
    if (!notesCounters.get(Counters.TOMORROW).isEmpty()) {
      expandedBody.append(notesCounters.get(Counters.TOMORROW).size()).append(" ").append(
          getString(R.string.tomorrow)).append(":");
      for (Note tomorrowReminder : notesCounters.get(Counters.TOMORROW)) {
        expandedBody.append(System.getProperty("line.separator")).append(("☆ "))
            .append(getNoteTitle(this,
                tomorrowReminder));
      }
    }
    Intent launchIntent = new Intent(this, MainActivity.class);
    launchIntent.setAction(Intent.ACTION_MAIN);
    publishUpdate(new ExtensionData()
        .visible(true)
        .icon(R.drawable.ic_stat_literal_icon)
        .status(String.valueOf(notesCounters.get(Counters.ACTIVE).size()))
        .expandedTitle(expandedTitle.toString())
        .expandedBody(expandedBody.toString())
        .clickIntent(launchIntent));
  }
  private String getNoteTitle(Context context, Note note) {
    return TextHelper
        .getAlternativeTitle(context, note, TextHelper.parseTitleAndContent(context, note)[0]);
  }
  private Map<Counters, List<Note>> getNotesCounters() {
    Map noteCounters = new HashMap<>();
    List<Note> activeNotes = new ArrayList<>();
    List<Note> reminders = new ArrayList<>();
    List<Note> today = new ArrayList<>();
    List<Note> tomorrow = new ArrayList<>();
    for (Note note : DbHelper.getInstance().getNotesActive()) {
      activeNotes.add(note);
      if (note.getAlarm() != null && !note.isReminderFired()) {
        reminders.add(note);
        if (DateUtils
            .isSameDay(Long.valueOf(note.getAlarm()), Calendar.getInstance().getTimeInMillis())) {
          today.add(note);
        } else if (
            (Long.valueOf(note.getAlarm()) - Calendar.getInstance().getTimeInMillis()) / (1000 * 60
                *
                60) < 24) {
          tomorrow.add(note);
        }
      }
    }
    noteCounters.put(Counters.ACTIVE, activeNotes);
    noteCounters.put(Counters.REMINDERS, reminders);
    noteCounters.put(Counters.TODAY, today);
    noteCounters.put(Counters.TOMORROW, tomorrow);
    return noteCounters;
  }
  public class DashClockUpdateReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
      onUpdateData(UPDATE_REASON_MANUAL);
    }
  }
}
package it.feio.android.omninotes;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_DISMISS;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_NOTIFICATION_CLICK;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_PINNED;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_POSTPONE;
import static it.feio.android.omninotes.utils.ConstantsBase.ACTION_SNOOZE;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_KEY;
import static it.feio.android.omninotes.utils.ConstantsBase.INTENT_NOTE;
import static it.feio.android.omninotes.utils.ConstantsBase.PREF_SNOOZE_DEFAULT;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import androidx.appcompat.app.AppCompatActivity;
import com.pixplicity.easyprefs.library.Prefs;
import it.feio.android.omninotes.async.notes.SaveNoteTask;
import it.feio.android.omninotes.helpers.date.RecurrenceHelper;
import it.feio.android.omninotes.models.Note;
import it.feio.android.omninotes.models.listeners.OnReminderPickedListener;
import it.feio.android.omninotes.utils.ReminderHelper;
import it.feio.android.omninotes.utils.date.DateUtils;
import it.feio.android.omninotes.utils.date.ReminderPickers;
import java.util.Arrays;
import java.util.Calendar;
public class SnoozeActivity extends AppCompatActivity implements OnReminderPickedListener {
  private Note note;
  private Note[] notes;
  public static void setNextRecurrentReminder(Note note) {
    long nextReminder = RecurrenceHelper.nextReminderFromRecurrenceRule(note);
    if (nextReminder > 0) {
      updateNoteReminder(nextReminder, note, true);
    } else {
      new SaveNoteTask(false).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, note);
    }
  }
  private static void updateNoteReminder(long reminder, Note note) {
    updateNoteReminder(reminder, note, false);
  }
  private static void updateNoteReminder(long reminder, Note noteToUpdate, boolean updateNote) {
    if (updateNote) {
      noteToUpdate.setAlarm(reminder);
      new SaveNoteTask(false).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, noteToUpdate);
    } else {
      ReminderHelper.addReminder(OmniNotes.getAppContext(), noteToUpdate, reminder);
      ReminderHelper.showReminderMessage(noteToUpdate.getAlarm());
    }
  }
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    if (getIntent().getParcelableExtra(INTENT_NOTE) != null) {
      note = getIntent().getParcelableExtra(INTENT_NOTE);
      manageNotification();
    } else {
      Object[] notesObjs = (Object[]) getIntent().getExtras().get(INTENT_NOTE);
      notes = Arrays.copyOf(notesObjs, notesObjs.length, Note[].class);
      postpone(DateUtils.getNextMinute(), null);
    }
  }
  private void manageNotification() {
    if (ACTION_DISMISS.equals(getIntent().getAction())) {
      setNextRecurrentReminder(note);
      finish();
    } else if (ACTION_SNOOZE.equals(getIntent().getAction())) {
      String snoozeDelay = Prefs.getString("settings_notification_snooze_delay", PREF_SNOOZE_DEFAULT);
      long newReminder =
          Calendar.getInstance().getTimeInMillis() + Integer.parseInt(snoozeDelay) * 60 * 1000;
      updateNoteReminder(newReminder, note);
      finish();
    } else if (ACTION_POSTPONE.equals(getIntent().getAction())) {
      postpone(Long.parseLong(note.getAlarm()), note.getRecurrenceRule());
    } else {
      Intent intent = new Intent(this, MainActivity.class);
      intent.putExtra(INTENT_KEY, note.get_id());
      intent.setAction(ACTION_NOTIFICATION_CLICK);
      startActivity(intent);
      finish();
    }
    if (!ACTION_PINNED.equals(getIntent().getAction())) {
      removeNotification(note);
    }
  }
  private void postpone(Long alarm, String recurrenceRule) {
    ReminderPickers reminderPicker = new ReminderPickers(this, this);
    reminderPicker.pick(alarm, recurrenceRule);
  }
  private void removeNotification(Note note) {
    NotificationManager manager = (NotificationManager) getSystemService(
        Context.NOTIFICATION_SERVICE);
    manager.cancel(String.valueOf(note.get_id()), 0);
  }
  @Override
  public void onReminderPicked(long reminder) {
    if (note != null) {
      note.setAlarm(reminder);
    } else {
      for (Note currentNote : notes) {
        currentNote.setAlarm(reminder);
      }
    }
  }
  @Override
  public void onRecurrenceReminderPicked(String recurrenceRule) {
    if (note != null) {
      note.setRecurrenceRule(recurrenceRule);
      setNextRecurrentReminder(note);
    } else {
      for (Note processedNotes : notes) {
        processedNotes.setRecurrenceRule(recurrenceRule);
        setNextRecurrentReminder(processedNotes);
      }
      setResult(RESULT_OK, getIntent());
    }
    finish();
  }
}