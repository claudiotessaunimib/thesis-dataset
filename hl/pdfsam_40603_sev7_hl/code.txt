// Copyright (c) 2007-2025 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client.impl.nio;
import com.rabbitmq.client.impl.Environment;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.Selector;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadFactory;
/**
 *
 */
public class NioLoopContext {
    private static final Logger LOGGER = LoggerFactory.getLogger(NioLoopContext.class);
    private final SocketChannelFrameHandlerFactory socketChannelFrameHandlerFactory;
    private final ExecutorService executorService;
    private final ThreadFactory threadFactory;
    final ByteBuffer readBuffer, writeBuffer;
    SelectorHolder readSelectorState;
    SelectorHolder writeSelectorState;
    public NioLoopContext(SocketChannelFrameHandlerFactory socketChannelFrameHandlerFactory,
        NioParams nioParams) {
        this.socketChannelFrameHandlerFactory = socketChannelFrameHandlerFactory;
        this.executorService = nioParams.getNioExecutor();
        this.threadFactory = nioParams.getThreadFactory();
        NioContext nioContext = new NioContext(nioParams, null);
        this.readBuffer = nioParams.getByteBufferFactory().createReadBuffer(nioContext);
        this.writeBuffer = nioParams.getByteBufferFactory().createWriteBuffer(nioContext);
    }
    void initStateIfNecessary() throws IOException {
        // This code is supposed to be called only from the SocketChannelFrameHandlerFactory
        // and while holding the lock.
        // We lock just in case some other code calls this method in the future.
        socketChannelFrameHandlerFactory.lock();
        try {
            if (this.readSelectorState == null) {
                this.readSelectorState = new SelectorHolder(Selector.open());
                this.writeSelectorState = new SelectorHolder(Selector.open());
                startIoLoops();
            }
        } finally {
            socketChannelFrameHandlerFactory.unlock();
        }
    }
    private void startIoLoops() {
        if (executorService == null) {
            Thread nioThread = Environment.newThread(
                threadFactory,
                new NioLoop(socketChannelFrameHandlerFactory.nioParams, this),
                "rabbitmq-nio"
            );
            nioThread.start();
        } else {
            this.executorService.submit(new NioLoop(socketChannelFrameHandlerFactory.nioParams, this));
        }
    }
    protected boolean cleanUp() {
        int readRegistrationsCount = readSelectorState.registrations.size();
        if(readRegistrationsCount != 0) {
            return false;
        }
        socketChannelFrameHandlerFactory.lock();
        try {
            if (readRegistrationsCount != readSelectorState.registrations.size()) {
                // a connection request has come in meanwhile, don't do anything
                return false;
            }
            try {
                readSelectorState.selector.close();
            } catch (IOException e) {
                LOGGER.warn("Could not close read selector: {}", e.getMessage());
            }
            try {
                writeSelectorState.selector.close();
            } catch (IOException e) {
                LOGGER.warn("Could not close write selector: {}", e.getMessage());
            }
            this.readSelectorState = null;
            this.writeSelectorState = null;
        } finally {
            socketChannelFrameHandlerFactory.unlock();
        }
        return true;
    }
}
// Copyright (c) 2007-2025 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client.impl.nio;
import com.rabbitmq.client.SocketChannelConfigurator;
import com.rabbitmq.client.SocketChannelConfigurators;
import com.rabbitmq.client.SslEngineConfigurator;
import javax.net.ssl.SSLEngine;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.function.Function;
import static com.rabbitmq.client.SslEngineConfigurators.ENABLE_HOSTNAME_VERIFICATION;
/**
 * Parameters used to configure the NIO mode of a {@link com.rabbitmq.client.ConnectionFactory}.
 *
 * @since 4.0.0
 */
public class NioParams {
    static Function<NioContext, NioQueue> DEFAULT_WRITE_QUEUE_FACTORY =
        ctx -> new BlockingQueueNioQueue(
            new ArrayBlockingQueue<>(ctx.getNioParams().getWriteQueueCapacity(), true),
            ctx.getNioParams().getWriteEnqueuingTimeoutInMs()
        );
    /**
     * size of the byte buffer used for inbound data
     */
    private int readByteBufferSize = 32768;
    /**
     * size of the byte buffer used for outbound data
     */
    private int writeByteBufferSize = 32768;
    /**
     * the max number of IO threads
     */
    private int nbIoThreads = 1;
    /**
     * the timeout to enqueue outbound frames
     */
    private int writeEnqueuingTimeoutInMs = 10 * 1000;
    /**
     * the capacity of the queue used for outbound frames
     */
    private int writeQueueCapacity = 10000;
    /**
     * the executor service used for IO threads and connections shutdown
     */
    private ExecutorService nioExecutor;
    /**
     * the thread factory used for IO threads and connections shutdown
     */
    private ThreadFactory threadFactory;
    /**
     * the hook to configure the socket channel before it's open
     */
    private SocketChannelConfigurator socketChannelConfigurator = SocketChannelConfigurators.defaultConfigurator();
    /**
     * the hook to configure the SSL engine before the connection is open
     */
    private SslEngineConfigurator sslEngineConfigurator = sslEngine -> {
    };
    /**
     * the executor service used for connection shutdown
     *
     * @since 5.4.0
     */
    private ExecutorService connectionShutdownExecutor;
    /**
     * The factory to create {@link java.nio.ByteBuffer}s.
     * The default is to create heap-based {@link java.nio.ByteBuffer}s.
     *
     * @since 5.5.0
     */
    private ByteBufferFactory byteBufferFactory = new DefaultByteBufferFactory();
    /**
     * Factory to create a {@link NioQueue}.
     *
     * @since 5.5.0
     */
    private Function<NioContext, NioQueue> writeQueueFactory =
        DEFAULT_WRITE_QUEUE_FACTORY;
    public NioParams() {
    }
    public NioParams(NioParams nioParams) {
        setReadByteBufferSize(nioParams.getReadByteBufferSize());
        setWriteByteBufferSize(nioParams.getWriteByteBufferSize());
        setNbIoThreads(nioParams.getNbIoThreads());
        setWriteEnqueuingTimeoutInMs(nioParams.getWriteEnqueuingTimeoutInMs());
        setWriteQueueCapacity(nioParams.getWriteQueueCapacity());
        setNioExecutor(nioParams.getNioExecutor());
        setThreadFactory(nioParams.getThreadFactory());
        setSocketChannelConfigurator(nioParams.getSocketChannelConfigurator());
        setSslEngineConfigurator(nioParams.getSslEngineConfigurator());
        setConnectionShutdownExecutor(nioParams.getConnectionShutdownExecutor());
        setByteBufferFactory(nioParams.getByteBufferFactory());
        setWriteQueueFactory(nioParams.getWriteQueueFactory());
    }
    /**
     * Enable server hostname verification for TLS connections.
     *
     * @return this {@link NioParams} instance
     * @see NioParams#setSslEngineConfigurator(SslEngineConfigurator)
     * @see com.rabbitmq.client.SslEngineConfigurators#ENABLE_HOSTNAME_VERIFICATION
     */
    public NioParams enableHostnameVerification() {
        if (this.sslEngineConfigurator == null) {
            this.sslEngineConfigurator = ENABLE_HOSTNAME_VERIFICATION;
        } else {
            this.sslEngineConfigurator = this.sslEngineConfigurator.andThen(ENABLE_HOSTNAME_VERIFICATION);
        }
        return this;
    }
    public int getReadByteBufferSize() {
        return readByteBufferSize;
    }
    /**
     * Sets the size in byte of the read {@link java.nio.ByteBuffer} used in the NIO loop.
     * Default is 32768.
     * <p>
     * This parameter isn't used when using SSL/TLS, where {@link java.nio.ByteBuffer}
     * size is set up according to the {@link javax.net.ssl.SSLSession} packet size.
     *
     * @param readByteBufferSize size of the {@link java.nio.ByteBuffer} for inbound data
     * @return this {@link NioParams} instance
     */
    public NioParams setReadByteBufferSize(int readByteBufferSize) {
        if (readByteBufferSize <= 0) {
            throw new IllegalArgumentException("Buffer size must be greater than 0");
        }
        this.readByteBufferSize = readByteBufferSize;
        return this;
    }
    public int getWriteByteBufferSize() {
        return writeByteBufferSize;
    }
    /**
     * Sets the size in byte of the write {@link java.nio.ByteBuffer} used in the NIO loop.
     * Default is 32768.
     * <p>
     * This parameter isn't used when using SSL/TLS, where {@link java.nio.ByteBuffer}
     * size is set up according to the {@link javax.net.ssl.SSLSession} packet size.
     *
     * @param writeByteBufferSize size of the {@link java.nio.ByteBuffer} used for outbound data
     * @return this {@link NioParams} instance
     */
    public NioParams setWriteByteBufferSize(int writeByteBufferSize) {
        if (writeByteBufferSize <= 0) {
            throw new IllegalArgumentException("Buffer size must be greater than 0");
        }
        this.writeByteBufferSize = writeByteBufferSize;
        return this;
    }
    public int getNbIoThreads() {
        return nbIoThreads;
    }
    /**
     * Sets the max number of threads/tasks used for NIO. Default is 1.
     * Set this number according to the number of simultaneous connections
     * and their activity.
     * Threads/tasks are created as necessary (e.g. with 10 threads, when
     * 10 connections have been created).
     * Once a connection is created, it's assigned to a thread/task and
     * all its IO activity is handled by this thread/task.
     * <p>
     * When idle for a few seconds (i.e. without any connection to perform IO for),
     * a thread/task stops and is recreated if necessary.
     *
     * @param nbIoThreads
     * @return this {@link NioParams} instance
     */
    public NioParams setNbIoThreads(int nbIoThreads) {
        if (nbIoThreads <= 0) {
            throw new IllegalArgumentException("Number of threads must be greater than 0");
        }
        this.nbIoThreads = nbIoThreads;
        return this;
    }
    public int getWriteEnqueuingTimeoutInMs() {
        return writeEnqueuingTimeoutInMs;
    }
    /**
     * Sets the timeout for queuing outbound frames. Default is 10,000 ms.
     * Every requests to the server is divided into frames
     * that are then queued in a {@link java.util.concurrent.BlockingQueue} before
     * being sent on the network by a IO thread.
     * <p>
     * If the IO thread cannot cope with the frames dispatch, the
     * {@link java.util.concurrent.BlockingQueue} gets filled up and blocks
     * (blocking the calling thread by the same occasion). This timeout is the
     * time the {@link java.util.concurrent.BlockingQueue} will wait before
     * rejecting the outbound frame. The calling thread will then received
     * an exception.
     * <p>
     * The appropriate value depends on the application scenarios:
     * rate of outbound data (published messages, acknowledgment, etc), network speed...
     *
     * @param writeEnqueuingTimeoutInMs
     * @return this {@link NioParams} instance
     * @see NioParams#setWriteQueueCapacity(int)
     */
    public NioParams setWriteEnqueuingTimeoutInMs(int writeEnqueuingTimeoutInMs) {
        this.writeEnqueuingTimeoutInMs = writeEnqueuingTimeoutInMs;
        return this;
    }
    public ExecutorService getNioExecutor() {
        return nioExecutor;
    }
    /**
     * Sets the {@link ExecutorService} to use for NIO threads/tasks.
     * Default is to use the thread factory.
     * <p>
     * The {@link ExecutorService} should be able to run the
     * number of requested IO threads, plus a few more, as it's also
     * used to dispatch the shutdown of connections.
     * <p>
     * Connection shutdown can also be handled by a dedicated {@link ExecutorService},
     * see {@link #setConnectionShutdownExecutor(ExecutorService)}.
     * <p>
     * It's developer's responsibility to shut down the executor
     * when it is no longer needed.
     * <p>
     * The thread factory isn't used if an executor service is set up.
     *
     * @param nioExecutor {@link ExecutorService} used for IO threads and connection shutdown
     * @return this {@link NioParams} instance
     * @see NioParams#setNbIoThreads(int)
     * @see NioParams#setThreadFactory(ThreadFactory)
     * @see NioParams#setConnectionShutdownExecutor(ExecutorService)
     */
    public NioParams setNioExecutor(ExecutorService nioExecutor) {
        this.nioExecutor = nioExecutor;
        return this;
    }
    public ThreadFactory getThreadFactory() {
        return threadFactory;
    }
    /**
     * Sets the {@link ThreadFactory} to use for NIO threads/tasks.
     * Default is to use the {@link com.rabbitmq.client.ConnectionFactory}'s
     * {@link ThreadFactory}.
     * <p>
     * The {@link ThreadFactory} is used to spawn the IO threads
     * and dispatch the shutdown of connections.
     *
     * @param threadFactory {@link ThreadFactory} used for IO threads and connection shutdown
     * @return this {@link NioParams} instance
     * @see NioParams#setNbIoThreads(int)
     * @see NioParams#setNioExecutor(ExecutorService)
     */
    public NioParams setThreadFactory(ThreadFactory threadFactory) {
        this.threadFactory = threadFactory;
        return this;
    }
    public int getWriteQueueCapacity() {
        return writeQueueCapacity;
    }
    /**
     * Set the capacity of the queue used for outbound frames.
     * Default capacity is 10,000.
     *
     * @param writeQueueCapacity
     * @return this {@link NioParams} instance
     * @see NioParams#setWriteEnqueuingTimeoutInMs(int)
     */
    public NioParams setWriteQueueCapacity(int writeQueueCapacity) {
        if (writeQueueCapacity <= 0) {
            throw new IllegalArgumentException("Write queue capacity must be greater than 0");
        }
        this.writeQueueCapacity = writeQueueCapacity;
        return this;
    }
    public SocketChannelConfigurator getSocketChannelConfigurator() {
        return socketChannelConfigurator;
    }
    /**
     * Set the {@link java.nio.channels.SocketChannel} configurator.
     * This gets a chance to "configure" a socket channel
     * before it has been opened. The default implementation disables
     * Nagle's algorithm.
     *
     * @param configurator the configurator to use
     * @return this {@link NioParams} instance
     */
    public NioParams setSocketChannelConfigurator(SocketChannelConfigurator configurator) {
        this.socketChannelConfigurator = configurator;
        return this;
    }
    public SslEngineConfigurator getSslEngineConfigurator() {
        return sslEngineConfigurator;
    }
    /**
     * Set the {@link SSLEngine} configurator.
     * This gets a change to "configure" the SSL engine
     * before the connection has been opened. This can be
     * used e.g. to set {@link javax.net.ssl.SSLParameters}.
     * The default implementation doesn't do anything.
     *
     * @param configurator the configurator to use
     * @return this {@link NioParams} instance
     */
    public NioParams setSslEngineConfigurator(SslEngineConfigurator configurator) {
        this.sslEngineConfigurator = configurator;
        return this;
    }
    public ExecutorService getConnectionShutdownExecutor() {
        return connectionShutdownExecutor;
    }
    /**
     * Set the {@link ExecutorService} used for connection shutdown.
     * If not set, falls back to the NIO executor and then the thread factory.
     * This executor service is useful when strict control of the number of threads
     * is necessary, the application can experience the closing of several connections
     * at once, and automatic recovery is enabled. In such cases, the connection recovery
     * can take place in the same pool of threads as the NIO operations, which can
     * create deadlocks (all the threads of the pool are busy recovering, and there's no
     * thread left for NIO, so connections never recover).
     * <p>
     * Note it's developer's responsibility to shut down the executor
     * when it is no longer needed.
     * <p>
     * Using the thread factory for such scenarios avoid the deadlocks, at the price
     * of potentially creating many short-lived threads in case of massive connection lost.
     * <p>
     * With both the NIO and connection shutdown executor services set and configured
     * accordingly, the application can control reliably the number of threads used.
     *
     * @param connectionShutdownExecutor the executor service to use
     * @return this {@link NioParams} instance
     * @see NioParams#setNioExecutor(ExecutorService)
     * @since 5.4.0
     */
    public NioParams setConnectionShutdownExecutor(ExecutorService connectionShutdownExecutor) {
        this.connectionShutdownExecutor = connectionShutdownExecutor;
        return this;
    }
    /**
     * Set the factory to create {@link java.nio.ByteBuffer}s.
     * <p>
     * The default implementation creates heap-based {@link java.nio.ByteBuffer}s.
     *
     * @param byteBufferFactory the factory to use
     * @return this {@link NioParams} instance
     * @see ByteBufferFactory
     * @see DefaultByteBufferFactory
     * @since 5.5.0
     */
    public NioParams setByteBufferFactory(ByteBufferFactory byteBufferFactory) {
        this.byteBufferFactory = byteBufferFactory;
        return this;
    }
    public ByteBufferFactory getByteBufferFactory() {
        return byteBufferFactory;
    }
    /**
     * Set the factory to create {@link NioQueue}s.
     * <p>
     * The default uses a {@link ArrayBlockingQueue}.
     *
     * @param writeQueueFactory the factory to use
     * @return this {@link NioParams} instance
     * @see NioQueue
     * @since 5.5.0
     */
    public NioParams setWriteQueueFactory(
        Function<NioContext, NioQueue> writeQueueFactory) {
        this.writeQueueFactory = writeQueueFactory;
        return this;
    }
    public Function<NioContext, NioQueue> getWriteQueueFactory() {
        return writeQueueFactory;
    }
}
// Copyright (c) 2007-2025 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client.impl.nio;
import com.rabbitmq.client.Address;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.SslContextFactory;
import com.rabbitmq.client.impl.AbstractFrameHandlerFactory;
import com.rabbitmq.client.impl.FrameHandler;
import com.rabbitmq.client.impl.TlsUtils;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.WritableByteChannel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLHandshakeException;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
/**
 *
 */
public class SocketChannelFrameHandlerFactory extends AbstractFrameHandlerFactory {
    private static final Logger LOGGER = LoggerFactory.getLogger(SocketChannelFrameHandler.class);
    final NioParams nioParams;
    private final SslContextFactory sslContextFactory;
    private final Lock stateLock = new ReentrantLock();
    private final AtomicLong globalConnectionCount = new AtomicLong();
    private final List<NioLoopContext> nioLoopContexts;
    public SocketChannelFrameHandlerFactory(int connectionTimeout, NioParams nioParams, boolean ssl,
                                            SslContextFactory sslContextFactory,
                                            int maxInboundMessageBodySize) {
        super(connectionTimeout, null, ssl, maxInboundMessageBodySize);
        this.nioParams = new NioParams(nioParams);
        this.sslContextFactory = sslContextFactory;
        this.nioLoopContexts = new ArrayList<>(this.nioParams.getNbIoThreads());
        for (int i = 0; i < this.nioParams.getNbIoThreads(); i++) {
            this.nioLoopContexts.add(new NioLoopContext(this, this.nioParams));
        }
    }
    @Override
    public FrameHandler create(Address addr, String connectionName) throws IOException {
        int portNumber = ConnectionFactory.portOrDefault(addr.getPort(), ssl);
        SSLEngine sslEngine = null;
        SocketChannel channel = null;
        try {
            if (ssl) {
                SSLContext sslContext = sslContextFactory.create(connectionName);
                sslEngine = sslContext.createSSLEngine(addr.getHost(), portNumber);
                sslEngine.setUseClientMode(true);
                if (nioParams.getSslEngineConfigurator() != null) {
                    nioParams.getSslEngineConfigurator().configure(sslEngine);
                }
            }
            SocketAddress address = addr.toInetSocketAddress(portNumber);
            // No Sonar: the channel is closed in case of error and it cannot
            // be closed here because it's part of the state of the connection
            // to be returned.
            channel = SocketChannel.open(); //NOSONAR
            channel.configureBlocking(true);
            if(nioParams.getSocketChannelConfigurator() != null) {
                nioParams.getSocketChannelConfigurator().configure(channel);
            }
            channel.socket().connect(address, this.connectionTimeout);
            if (ssl) {
                int initialSoTimeout = channel.socket().getSoTimeout();
                channel.socket().setSoTimeout(this.connectionTimeout);
                sslEngine.beginHandshake();
                try {
                    ReadableByteChannel wrappedReadChannel = Channels.newChannel(
                        channel.socket().getInputStream());
                    WritableByteChannel wrappedWriteChannel = Channels.newChannel(
                        channel.socket().getOutputStream());
                    boolean handshake = SslEngineHelper.doHandshake(
                        wrappedWriteChannel, wrappedReadChannel, sslEngine);
                    if (!handshake) {
                        LOGGER.error("TLS connection failed");
                        throw new SSLException("TLS handshake failed");
                    }
                    channel.socket().setSoTimeout(initialSoTimeout);
                } catch (SSLHandshakeException e) {
                    LOGGER.error("TLS connection failed: {}", e.getMessage());
                    throw e;
                }
                TlsUtils.logPeerCertificateInfo(sslEngine.getSession());
            }
            channel.configureBlocking(false);
            // lock
            stateLock.lock();
            NioLoopContext nioLoopContext = null;
            try {
                long modulo = globalConnectionCount.getAndIncrement() % nioParams.getNbIoThreads();
                nioLoopContext = nioLoopContexts.get((int) modulo);
                nioLoopContext.initStateIfNecessary();
                SocketChannelFrameHandlerState state = new SocketChannelFrameHandlerState(
                    channel,
                    nioLoopContext,
                    nioParams,
                    sslEngine,
                    this.maxInboundMessageBodySize
                );
                state.startReading();
                SocketChannelFrameHandler frameHandler = new SocketChannelFrameHandler(state);
                return frameHandler;
            } finally {
                stateLock.unlock();
            }
        } catch(IOException e) {
            try {
                if(sslEngine != null && channel != null) {
                    SslEngineHelper.close(channel, sslEngine);
                }
                if (channel != null) {
                    channel.close();
                }
            } catch(IOException closingException) {
                // ignore
            }
            throw e;
        }
    }
    void lock() {
        stateLock.lock();
    }
    void unlock() {
        stateLock.unlock();
    }
}
// Copyright (c) 2018-2023 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client;
import javax.net.ssl.SSLParameters;
/**
 * Ready-to-use instances and builder for {@link SslEngineConfigurator}s.
 * <p>
 * Note {@link SslEngineConfigurator}s can be combined with
 * {@link SslEngineConfigurator#andThen(SslEngineConfigurator)}.
 *
 * @since 5.4.0
 */
public abstract class SslEngineConfigurators {
    /**
     * Default {@link SslEngineConfigurator}, does nothing.
     */
    public static final SslEngineConfigurator DEFAULT = sslEngine -> {
    };
    /**
     * {@link SslEngineConfigurator} that enables server hostname verification.
     */
    public static final SslEngineConfigurator ENABLE_HOSTNAME_VERIFICATION = sslEngine -> {
        SSLParameters sslParameters = SocketConfigurators.enableHostnameVerification(sslEngine.getSSLParameters());
        sslEngine.setSSLParameters(sslParameters);
    };
    /**
     * Default {@link SslEngineConfigurator}, does nothing.
     *
     * @return
     */
    public static SslEngineConfigurator defaultConfigurator() {
        return DEFAULT;
    }
    /**
     * {@link SslEngineConfigurator} that enables server hostname verification.
     *
     * @return
     */
    public static SslEngineConfigurator enableHostnameVerification() {
        return ENABLE_HOSTNAME_VERIFICATION;
    }
    /**
     * Builder to configure and creates a {@link SslEngineConfigurator} instance.
     *
     * @return
     */
    public static Builder builder() {
        return new Builder();
    }
    public static class Builder {
        private SslEngineConfigurator configurator = channel -> {
        };
        /**
         * Set default configuration (no op).
         *
         * @return
         */
        public Builder defaultConfigurator() {
            configurator = configurator.andThen(DEFAULT);
            return this;
        }
        /**
         * Enables server hostname verification.
         *
         * @return
         */
        public Builder enableHostnameVerification() {
            configurator = configurator.andThen(ENABLE_HOSTNAME_VERIFICATION);
            return this;
        }
        /**
         * Add extra configuration step.
         *
         * @param extraConfiguration
         * @return
         */
        public Builder add(SslEngineConfigurator extraConfiguration) {
            configurator = configurator.andThen(extraConfiguration);
            return this;
        }
        /**
         * Return the configured {@link SslEngineConfigurator}.
         *
         * @return
         */
        public SslEngineConfigurator build() {
            return configurator;
        }
    }
}
// Copyright (c) 2007-2025 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client.impl.nio;
import com.rabbitmq.client.impl.Environment;
import com.rabbitmq.client.impl.Frame;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.DataOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.ThreadFactory;
/**
 * Logic of the NIO loop.
 */
public class NioLoop implements Runnable {
    private static final Logger LOGGER = LoggerFactory.getLogger(NioLoop.class);
    private final NioLoopContext context;
    private final NioParams nioParams;
    private final ExecutorService connectionShutdownExecutor;
    public NioLoop(NioParams nioParams, NioLoopContext loopContext) {
        this.nioParams = nioParams;
        this.context = loopContext;
        this.connectionShutdownExecutor = nioParams.getConnectionShutdownExecutor();
    }
    @Override
    public void run() {
        final SelectorHolder selectorState = context.readSelectorState;
        final Selector selector = selectorState.selector;
        final Set<SocketChannelRegistration> registrations = selectorState.registrations;
        final ByteBuffer buffer = context.readBuffer;
        final SelectorHolder writeSelectorState = context.writeSelectorState;
        final Selector writeSelector = writeSelectorState.selector;
        final Set<SocketChannelRegistration> writeRegistrations = writeSelectorState.registrations;
        // whether there have been write registrations in the previous loop
        // registrations are done after Selector.select(), to work on clean keys
        // thus, any write operation is performed in the next loop
        // we don't want to wait in the read Selector.select() if there are
        // pending writes
        boolean writeRegistered = false;
        try {
            while (!Thread.currentThread().isInterrupted()) {
                for (SelectionKey selectionKey : selector.keys()) {
                    SocketChannelFrameHandlerState state = (SocketChannelFrameHandlerState) selectionKey.attachment();
                    if (state.getConnection() != null && state.getHeartbeatNanoSeconds() > 0) {
                        long now = System.nanoTime();
                        if ((now - state.getLastActivity()) > state.getHeartbeatNanoSeconds() * 2) {
                            try {
                                handleHeartbeatFailure(state);
                            } catch (Exception e) {
                                LOGGER.warn("Error after heartbeat failure of connection {}", state.getConnection());
                            } finally {
                                selectionKey.cancel();
                            }
                        }
                    }
                }
                int select;
                if (!writeRegistered && registrations.isEmpty() && writeRegistrations.isEmpty()) {
                    // we can block, registrations will call Selector.wakeup()
                    select = selector.select(1000);
                    if (selector.keys().isEmpty()) {
                        // we haven't been doing anything for a while, shutdown state
                        boolean clean = context.cleanUp();
                        if (clean) {
                            // we stop this thread
                            return;
                        }
                        // there may be incoming connections, keep going
                    }
                } else {
                    // we don't have to block, we need to select and clean cancelled keys before registration
                    select = selector.selectNow();
                }
                writeRegistered = false;
                // registrations should be done after select,
                // once the cancelled keys have been actually removed
                SocketChannelRegistration registration;
                Iterator<SocketChannelRegistration> registrationIterator = registrations.iterator();
                while (registrationIterator.hasNext()) {
                    registration = registrationIterator.next();
                    registrationIterator.remove();
                    int operations = registration.operations;
                    try {
                        if (registration.state.getChannel().isOpen()) {
                            registration.state.getChannel().register(selector, operations, registration.state);
                        }
                    } catch (Exception e) {
                        // can happen if the channel has been closed since the operation has been enqueued
                        LOGGER.info("Error while registering socket channel for read: {}", e.getMessage());
                    }
                }
                if (select > 0) {
                    Set<SelectionKey> readyKeys = selector.selectedKeys();
                    Iterator<SelectionKey> iterator = readyKeys.iterator();
                    while (iterator.hasNext()) {
                        SelectionKey key = iterator.next();
                        iterator.remove();
                        if (!key.isValid()) {
                            continue;
                        }
                        final SocketChannelFrameHandlerState state = (SocketChannelFrameHandlerState) key.attachment();
                        try {
                            if (key.isReadable()) {
                                if (!state.getChannel().isOpen()) {
                                    key.cancel();
                                    continue;
                                }
                                if(state.getConnection() == null) {
                                    // we're in AMQConnection#start, between the header sending and the FrameHandler#initialize
                                    // let's wait a bit more
                                    continue;
                                }
                                state.prepareForReadSequence();
                                while (state.continueReading()) {
                                    final Frame frame = state.frameBuilder.readFrame();
                                    if (frame != null) {
                                        try {
                                            state.getConnection().ioLoopThread(Thread.currentThread());
                                            boolean noProblem = state.getConnection().handleReadFrame(frame);
                                            if (noProblem && (!state.getConnection().isRunning() || state.getConnection().hasBrokerInitiatedShutdown())) {
                                                // looks like the frame was Close-Ok or Close
                                                dispatchShutdownToConnection(state);
                                                key.cancel();
                                                break;
                                            }
                                        } catch (Throwable ex) {
                                            // problem during frame processing, tell connection, and
                                            // we can stop for this channel
                                            handleIoError(state, ex);
                                            key.cancel();
                                            break;
                                        }
                                    }
                                }
                                state.setLastActivity(System.nanoTime());
                            }
                        } catch (final Exception e) {
                            LOGGER.warn("Error during reading frames", e);
                            handleIoError(state, e);
                            key.cancel();
                        } finally {
                            buffer.clear();
                        }
                    }
                }
                // write loop
                select = writeSelector.selectNow();
                // registrations should be done after select,
                // once the cancelled keys have been actually removed
                SocketChannelRegistration writeRegistration;
                Iterator<SocketChannelRegistration> writeRegistrationIterator = writeRegistrations.iterator();
                while (writeRegistrationIterator.hasNext()) {
                    writeRegistration = writeRegistrationIterator.next();
                    writeRegistrationIterator.remove();
                    int operations = writeRegistration.operations;
                    try {
                        if (writeRegistration.state.getChannel().isOpen()) {
                            writeRegistration.state.getChannel().register(writeSelector, operations, writeRegistration.state);
                            writeRegistered = true;
                        }
                    } catch (Exception e) {
                        // can happen if the channel has been closed since the operation has been enqueued
                        LOGGER.info("Error while registering socket channel for write: {}", e.getMessage());
                    }
                }
                if (select > 0) {
                    Set<SelectionKey> readyKeys = writeSelector.selectedKeys();
                    Iterator<SelectionKey> iterator = readyKeys.iterator();
                    while (iterator.hasNext()) {
                        SelectionKey key = iterator.next();
                        iterator.remove();
                        SocketChannelFrameHandlerState state = (SocketChannelFrameHandlerState) key.attachment();
                        if (!key.isValid()) {
                            continue;
                        }
                        try {
                            if (key.isWritable()) {
                                if (!state.getChannel().isOpen()) {
                                    key.cancel();
                                    continue;
                                }
                                state.prepareForWriteSequence();
                                int toBeWritten = state.getWriteQueue().size();
                                int written = 0;
                                DataOutputStream outputStream = state.outputStream;
                                WriteRequest request;
                                while (written <= toBeWritten && (request = state.getWriteQueue().poll()) != null) {
                                    request.handle(outputStream);
                                    written++;
                                }
                                outputStream.flush();
                            }
                        } catch (Exception e) {
                            handleIoError(state, e);
                        } finally {
                            state.endWriteSequence();
                            key.cancel();
                        }
                    }
                }
            }
        } catch (Exception e) {
            LOGGER.error("Error in NIO loop", e);
        }
    }
    protected void handleIoError(SocketChannelFrameHandlerState state, Throwable ex) {
        if (needToDispatchIoError(state)) {
            dispatchIoErrorToConnection(state, ex);
        } else {
            try {
                state.close();
            } catch (IOException ignored) {
            }
        }
    }
    protected void handleHeartbeatFailure(SocketChannelFrameHandlerState state) {
        if (needToDispatchIoError(state)) {
            dispatchShutdownToConnection(
                () -> state.getConnection().handleHeartbeatFailure(),
                state.getConnection().toString()
            );
        } else {
            try {
                state.close();
            } catch (IOException ignored) {
            }
        }
    }
    protected boolean needToDispatchIoError(final SocketChannelFrameHandlerState state) {
        return state.getConnection().isOpen();
    }
    protected void dispatchIoErrorToConnection(final SocketChannelFrameHandlerState state, final Throwable ex) {
        dispatchShutdownToConnection(
            () -> state.getConnection().handleIoError(ex),
            state.getConnection().toString()
        );
    }
    protected void dispatchShutdownToConnection(final SocketChannelFrameHandlerState state) {
        dispatchShutdownToConnection(
            () -> state.getConnection().doFinalShutdown(),
            state.getConnection().toString()
        );
    }
    protected void dispatchShutdownToConnection(Runnable connectionShutdownRunnable, String connectionName) {
        // In case of recovery after the shutdown,
        // the new connection shouldn't be initialized in
        // the NIO thread, to avoid a deadlock.
        if (this.connectionShutdownExecutor != null) {
            connectionShutdownExecutor.execute(connectionShutdownRunnable);
        } else if (executorService() != null) {
            executorService().execute(connectionShutdownRunnable);
        } else {
            String name = "rabbitmq-connection-shutdown-" + connectionName;
            Thread shutdownThread = Environment.newThread(threadFactory(), connectionShutdownRunnable, name);
            shutdownThread.start();
        }
    }
    private ExecutorService executorService() {
        return nioParams.getNioExecutor();
    }
    private ThreadFactory threadFactory() {
        return nioParams.getThreadFactory();
    }
}
package com.rabbitmq.client.impl.nio;
import javax.net.ssl.SSLEngine;
/**
 * Context when creating resources for a NIO-based connection.
 *
 * @see ByteBufferFactory
 * @since 5.5.0
 */
public class NioContext {
    private final NioParams nioParams;
    private final SSLEngine sslEngine;
    NioContext(NioParams nioParams, SSLEngine sslEngine) {
        this.nioParams = nioParams;
        this.sslEngine = sslEngine;
    }
    /**
     * NIO params.
     *
     * @return
     */
    public NioParams getNioParams() {
        return nioParams;
    }
    /**
     * {@link SSLEngine} for SSL/TLS connection.
     * Null for plain connection.
     *
     * @return
     */
    public SSLEngine getSslEngine() {
        return sslEngine;
    }
}
// Copyright (c) 2018-2023 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client;
/**
 * Ready-to-use instances and builder for {@link SocketChannelConfigurator}.
 * <p>
 * Note {@link SocketChannelConfigurator}s can be combined with
 * {@link SocketChannelConfigurator#andThen(SocketChannelConfigurator)}.
 *
 * @since 5.4.0
 */
public abstract class SocketChannelConfigurators {
    /**
     * Disable Nagle's algorithm.
     */
    public static final SocketChannelConfigurator DISABLE_NAGLE_ALGORITHM =
        socketChannel -> SocketConfigurators.DISABLE_NAGLE_ALGORITHM.configure(socketChannel.socket());
    /**
     * Default {@link SocketChannelConfigurator} that disables Nagle's algorithm.
     */
    public static final SocketChannelConfigurator DEFAULT = DISABLE_NAGLE_ALGORITHM;
    /**
     * The default {@link SocketChannelConfigurator} that disables Nagle's algorithm.
     *
     * @return
     */
    public static SocketChannelConfigurator defaultConfigurator() {
        return DEFAULT;
    }
    /**
     * {@link SocketChannelConfigurator} that disables Nagle's algorithm.
     *
     * @return
     */
    public static SocketChannelConfigurator disableNagleAlgorithm() {
        return DISABLE_NAGLE_ALGORITHM;
    }
    /**
     * Builder to configure and creates a {@link SocketChannelConfigurator} instance.
     *
     * @return
     */
    public static SocketChannelConfigurators.Builder builder() {
        return new SocketChannelConfigurators.Builder();
    }
    public static class Builder {
        private SocketChannelConfigurator configurator = channel -> {
        };
        /**
         * Set default configuration.
         *
         * @return
         */
        public Builder defaultConfigurator() {
            configurator = configurator.andThen(DEFAULT);
            return this;
        }
        /**
         * Disable Nagle's Algorithm.
         *
         * @return
         */
        public Builder disableNagleAlgorithm() {
            configurator = configurator.andThen(DISABLE_NAGLE_ALGORITHM);
            return this;
        }
        /**
         * Add an extra configuration step.
         *
         * @param extraConfiguration
         * @return
         */
        public Builder add(SocketChannelConfigurator extraConfiguration) {
            configurator = configurator.andThen(extraConfiguration);
            return this;
        }
        /**
         * Return the configured {@link SocketConfigurator}.
         *
         * @return
         */
        public SocketChannelConfigurator build() {
            return configurator;
        }
    }
}
// Copyright (c) 2007-2025 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client.impl.nio;
import com.rabbitmq.client.impl.AMQConnection;
import com.rabbitmq.client.impl.Frame;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.net.ssl.SSLEngine;
import java.io.DataOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.SocketChannel;
import java.time.Duration;
/**
 *
 */
public class SocketChannelFrameHandlerState {
    private static final Logger LOGGER = LoggerFactory.getLogger(SocketChannelFrameHandlerState.class);
    /** Time to linger before closing the socket forcefully. */
    private static final int SOCKET_CLOSING_TIMEOUT = 1;
    private final SocketChannel channel;
    private final NioQueue writeQueue;
    private volatile AMQConnection connection;
    private volatile long heartbeatNanoSeconds = -1;
    /** should be used only in the NIO read thread */
    private long lastActivity;
    private final SelectorHolder writeSelectorState;
    private final SelectorHolder readSelectorState;
    final boolean ssl;
    final SSLEngine sslEngine;
    /** outbound app data (to be crypted if TLS is on) */
    final ByteBuffer plainOut;
    /** inbound app data (deciphered if TLS is on) */
    final ByteBuffer plainIn;
    /** outbound net data (ciphered if TLS is on) */
    final ByteBuffer cipherOut;
    /** inbound data (ciphered if TLS is on) */
    final ByteBuffer cipherIn;
    final DataOutputStream outputStream;
    final FrameBuilder frameBuilder;
    public SocketChannelFrameHandlerState(SocketChannel channel, NioLoopContext nioLoopsState,
                                          NioParams nioParams, SSLEngine sslEngine,
                                          int maxFramePayloadSize) {
        this.channel = channel;
        this.readSelectorState = nioLoopsState.readSelectorState;
        this.writeSelectorState = nioLoopsState.writeSelectorState;
        NioContext nioContext = new NioContext(nioParams, sslEngine);
        this.writeQueue = nioParams.getWriteQueueFactory() == null ?
            NioParams.DEFAULT_WRITE_QUEUE_FACTORY.apply(nioContext) :
            nioParams.getWriteQueueFactory().apply(nioContext);
        this.sslEngine = sslEngine;
        if(this.sslEngine == null) {
            this.ssl = false;
            this.plainOut = nioLoopsState.writeBuffer;
            this.cipherOut = null;
            this.plainIn = nioLoopsState.readBuffer;
            this.cipherIn = null;
            this.outputStream = new DataOutputStream(
                new ByteBufferOutputStream(channel, plainOut)
            );
            this.frameBuilder = new FrameBuilder(channel, plainIn, maxFramePayloadSize);
        } else {
            this.ssl = true;
            this.plainOut = nioParams.getByteBufferFactory().createWriteBuffer(nioContext);
            this.cipherOut = nioParams.getByteBufferFactory().createEncryptedWriteBuffer(nioContext);
            this.plainIn = nioParams.getByteBufferFactory().createReadBuffer(nioContext);
            this.cipherIn = nioParams.getByteBufferFactory().createEncryptedReadBuffer(nioContext);
            this.outputStream = new DataOutputStream(
                new SslEngineByteBufferOutputStream(sslEngine, plainOut, cipherOut, channel)
            );
            this.frameBuilder = new SslEngineFrameBuilder(sslEngine, plainIn,
                cipherIn, channel, maxFramePayloadSize);
        }
    }
    public SocketChannel getChannel() {
        return channel;
    }
    public NioQueue getWriteQueue() {
        return writeQueue;
    }
    public void sendHeader() throws IOException {
        sendWriteRequest(HeaderWriteRequest.SINGLETON);
    }
    public void write(Frame frame) throws IOException {
        sendWriteRequest(new FrameWriteRequest(frame));
    }
    private void sendWriteRequest(WriteRequest writeRequest) throws IOException {
        try {
            boolean offered = this.writeQueue.offer(writeRequest);
            if(offered) {
                this.writeSelectorState.registerFrameHandlerState(this, SelectionKey.OP_WRITE);
                this.readSelectorState.selector.wakeup();
            } else {
                throw new IOException("Frame enqueuing failed");
            }
        } catch (InterruptedException e) {
            LOGGER.warn("Thread interrupted during enqueuing frame in write queue");
            Thread.currentThread().interrupt();
        }
    }
    public void startReading() {
        this.readSelectorState.registerFrameHandlerState(this, SelectionKey.OP_READ);
    }
    public AMQConnection getConnection() {
        return connection;
    }
    public void setConnection(AMQConnection connection) {
        this.connection = connection;
    }
    void setHeartbeat(Duration ht) {
        this.heartbeatNanoSeconds = ht.toNanos();
    }
    public void setLastActivity(long lastActivity) {
        this.lastActivity = lastActivity;
    }
    public long getLastActivity() {
        return lastActivity;
    }
    long getHeartbeatNanoSeconds() {
        return this.heartbeatNanoSeconds;
    }
    void prepareForWriteSequence() {
        if(ssl) {
            plainOut.clear();
            cipherOut.clear();
        }
    }
    void endWriteSequence() {
        if(!ssl) {
            plainOut.clear();
        }
    }
    void prepareForReadSequence() throws IOException {
        if(ssl) {
            if (!frameBuilder.isUnderflowHandlingEnabled()) {
                cipherIn.clear();
                cipherIn.flip();
            }
            plainIn.clear();
            plainIn.flip();
        } else {
            NioHelper.read(channel, plainIn);
            plainIn.flip();
        }
    }
    boolean continueReading() throws IOException {
        if(ssl) {
            if (frameBuilder.isUnderflowHandlingEnabled()) {
                int bytesRead = NioHelper.read(channel, cipherIn);
                if (bytesRead == 0) {
                    return false;
                } else {
                    cipherIn.flip();
                    return true;
                }
            }
            if (!plainIn.hasRemaining() && !cipherIn.hasRemaining()) {
                // need to try to read something
                cipherIn.clear();
                int bytesRead = NioHelper.read(channel, cipherIn);
                if (bytesRead == 0) {
                    return false;
                } else {
                    cipherIn.flip();
                    return true;
                }
            } else {
                return true;
            }
        } else {
            if (!plainIn.hasRemaining()) {
                plainIn.clear();
                NioHelper.read(channel, plainIn);
                plainIn.flip();
            }
            return plainIn.hasRemaining();
        }
    }
    void close() throws IOException {
        if(ssl) {
            SslEngineHelper.close(channel, sslEngine);
        }
        if(channel.isOpen()) {
            channel.socket().setSoLinger(true, SOCKET_CLOSING_TIMEOUT);
            channel.close();
        }
    }
}
// Copyright (c) 2007-2025 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client;
import com.rabbitmq.client.impl.*;
import com.rabbitmq.client.impl.nio.NioParams;
import com.rabbitmq.client.impl.nio.SocketChannelFrameHandlerFactory;
import com.rabbitmq.client.impl.recovery.AutorecoveringConnection;
import com.rabbitmq.client.impl.recovery.RecoveredQueueNameSupplier;
import com.rabbitmq.client.impl.recovery.RetryHandler;
import com.rabbitmq.client.impl.recovery.TopologyRecoveryFilter;
import com.rabbitmq.client.observation.ObservationCollector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLDecoder;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.*;
import java.util.function.BiConsumer;
import java.util.function.Predicate;
import static java.util.concurrent.TimeUnit.MINUTES;
/**
 * Convenience factory class to facilitate opening a {@link Connection} to a RabbitMQ node.
 *
 * Most connection and socket settings are configured using this factory.
 * Some settings that apply to connections can also be configured here
 * and will apply to all connections produced by this factory.
 */
public class ConnectionFactory implements Cloneable {
    private static final int MAX_UNSIGNED_SHORT = 65535;
    /** Default user name */
    public static final String DEFAULT_USER = "guest";
    /** Default password */
    public static final String DEFAULT_PASS = "guest";
    /** Default virtual host */
    public static final String DEFAULT_VHOST = "/";
    /** Default maximum channel number;
     *  2047 because it's 2048 on the server side minus channel 0,
     *  which each connection uses for negotiation
     *  and error communication */
    public static final int    DEFAULT_CHANNEL_MAX = 2047;
    /** Default maximum frame size;
     *  zero means no limit */
    public static final int    DEFAULT_FRAME_MAX = 0;
    /** Default heart-beat interval;
     *  60 seconds */
    public static final int    DEFAULT_HEARTBEAT = 60;
    /** The default host */
    public static final String DEFAULT_HOST = "localhost";
    /** 'Use the default port' port */
    public static final int    USE_DEFAULT_PORT = -1;
    /** The default non-ssl port */
    public static final int    DEFAULT_AMQP_PORT = AMQP.PROTOCOL.PORT;
    /** The default ssl port */
    public static final int    DEFAULT_AMQP_OVER_SSL_PORT = 5671;
    /** The default TCP connection timeout: 60 seconds */
    public static final int    DEFAULT_CONNECTION_TIMEOUT = 60000;
    /**
     * The default AMQP 0-9-1 connection handshake timeout. See DEFAULT_CONNECTION_TIMEOUT
     * for TCP (socket) connection timeout.
     */
    public static final int    DEFAULT_HANDSHAKE_TIMEOUT = 10000;
    /** The default shutdown timeout;
     *  zero means wait indefinitely */
    public static final int    DEFAULT_SHUTDOWN_TIMEOUT = 10000;
    /** The default continuation timeout for RPC calls in channels: 10 minutes */
    public static final int    DEFAULT_CHANNEL_RPC_TIMEOUT = (int) MINUTES.toMillis(10);
    
    /** The default network recovery interval: 5000 millis */
    public static final long   DEFAULT_NETWORK_RECOVERY_INTERVAL = 5000;
    /** The default timeout for work pool enqueueing: no timeout */
    public static final int    DEFAULT_WORK_POOL_TIMEOUT = -1;
    private static final String PREFERRED_TLS_PROTOCOL = "TLSv1.2";
    private static final String FALLBACK_TLS_PROTOCOL = "TLSv1";
    private String virtualHost                    = DEFAULT_VHOST;
    private String host                           = DEFAULT_HOST;
    private int port                              = USE_DEFAULT_PORT;
    private int requestedChannelMax               = DEFAULT_CHANNEL_MAX;
    private int requestedFrameMax                 = DEFAULT_FRAME_MAX;
    private int requestedHeartbeat                = DEFAULT_HEARTBEAT;
    private int connectionTimeout                 = DEFAULT_CONNECTION_TIMEOUT;
    private int handshakeTimeout                  = DEFAULT_HANDSHAKE_TIMEOUT;
    private int shutdownTimeout                   = DEFAULT_SHUTDOWN_TIMEOUT;
    private Map<String, Object> _clientProperties = AMQConnection.defaultClientProperties();
    private SocketFactory socketFactory           = null;
    private SaslConfig saslConfig                 = DefaultSaslConfig.PLAIN;
    private ExecutorService sharedExecutor;
    private ThreadFactory threadFactory             = Executors.defaultThreadFactory();
    // minimises the number of threads rapid closure of many
    // connections uses, see rabbitmq/rabbitmq-java-client#86
    private ExecutorService shutdownExecutor;
    private ScheduledExecutorService heartbeatExecutor;
    private SocketConfigurator socketConf           = SocketConfigurators.defaultConfigurator();
    private ExceptionHandler exceptionHandler       = new DefaultExceptionHandler();
    private CredentialsProvider credentialsProvider = new DefaultCredentialsProvider(DEFAULT_USER, DEFAULT_PASS);
    private boolean automaticRecovery               = true;
    private boolean topologyRecovery                = true;
    private ExecutorService topologyRecoveryExecutor;
    
    // long is used to make sure the users can use both ints
    // and longs safely. It is unlikely that anybody'd need
    // to use recovery intervals > Integer.MAX_VALUE in practice.
    private long networkRecoveryInterval          = DEFAULT_NETWORK_RECOVERY_INTERVAL;
    private RecoveryDelayHandler recoveryDelayHandler;
    private MetricsCollector metricsCollector;
    private ObservationCollector observationCollector = ObservationCollector.NO_OP;
    private boolean nio = false;
    private FrameHandlerFactory frameHandlerFactory;
    private NioParams nioParams = new NioParams();
    private SslContextFactory sslContextFactory;
    /**
     * Continuation timeout on RPC calls.
     * @since 4.1.0
     */
    private int channelRpcTimeout = DEFAULT_CHANNEL_RPC_TIMEOUT;
    /**
     * Whether or not channels check the reply type of an RPC call.
     * Default is false.
     * @since 4.2.0
     */
    private boolean channelShouldCheckRpcResponseType = false;
    /**
     * Listener called when a connection gets an IO error trying to write on the socket.
     * Default listener triggers connection recovery asynchronously and propagates
     * the exception.
     * @since 4.5.0
     */
    private ErrorOnWriteListener errorOnWriteListener;
    /**
     * Timeout in ms for work pool enqueuing.
     * @since 4.5.0
     */
    private int workPoolTimeout = DEFAULT_WORK_POOL_TIMEOUT;
    /**
     * Filter to include/exclude entities from topology recovery.
     * @since 4.8.0
     */
    private TopologyRecoveryFilter topologyRecoveryFilter;
    /**
     * Condition to trigger automatic connection recovery.
     * @since 5.4.0
     */
    private Predicate<ShutdownSignalException> connectionRecoveryTriggeringCondition;
    /**
     * Retry handler for topology recovery.
     * Default is no retry.
     * @since 5.4.0
     */
    private RetryHandler topologyRecoveryRetryHandler;
    private RecoveredQueueNameSupplier recoveredQueueNameSupplier;
    /**
     * Traffic listener notified of inbound and outbound {@link Command}s.
     * <p>
     * Useful for debugging purposes. Default is no-op.
     *
     * @since 5.5.0
     */
    private TrafficListener trafficListener = TrafficListener.NO_OP;
    private CredentialsRefreshService credentialsRefreshService;
    /**
     * Maximum body size of inbound (received) messages in bytes.
     *
     * <p>Default value is 67,108,864 (64 MiB).
     */
    private int maxInboundMessageBodySize = 1_048_576 * 64;
    /** @return the default host to use for connections */
    public String getHost() {
        return host;
    }
    /** @param host the default host to use for connections */
    public ConnectionFactory setHost(String host) {
        this.host = host;
        return this;
    }
    public static int portOrDefault(int port, boolean ssl) {
        if (port != USE_DEFAULT_PORT) return port;
        else if (ssl) return DEFAULT_AMQP_OVER_SSL_PORT;
        else return DEFAULT_AMQP_PORT;
    }
    /** @return the default port to use for connections */
    public int getPort() {
        return portOrDefault(port, isSSL());
    }
    /**
     * Set the target port.
     * @param port the default port to use for connections
     */
    public ConnectionFactory setPort(int port) {
        this.port = port;
        return this;
    }
    /**
     * Retrieve the user name.
     * @return the AMQP user name to use when connecting to the broker
     */
    public String getUsername() {
        return credentialsProvider.getUsername();
    }
    /**
     * Set the user name.
     * @param username the AMQP user name to use when connecting to the broker
     */
    public ConnectionFactory setUsername(String username) {
        this.credentialsProvider = new DefaultCredentialsProvider(
            username,
            this.credentialsProvider.getPassword()
        );
        return this;
    }
    /**
     * Retrieve the password.
     * @return the password to use when connecting to the broker
     */
    public String getPassword() {
        return credentialsProvider.getPassword();
    }
    /**
     * Set the password.
     * @param password the password to use when connecting to the broker
     */
    public ConnectionFactory setPassword(String password) {
        this.credentialsProvider = new DefaultCredentialsProvider(
            this.credentialsProvider.getUsername(),
            password
        );
        return this;
    }
    /**
     * Set a custom credentials provider.
     * Default implementation uses static username and password.
     * @param credentialsProvider The custom implementation of CredentialsProvider to use when connecting to the broker.
     * @see com.rabbitmq.client.impl.DefaultCredentialsProvider
     * @since 4.5.0
     */
    public ConnectionFactory setCredentialsProvider(CredentialsProvider credentialsProvider) {
        this.credentialsProvider = credentialsProvider;
        return this;
    }
    
    /**
     * Retrieve the virtual host.
     * @return the virtual host to use when connecting to the broker
     */
    public String getVirtualHost() {
        return this.virtualHost;
    }
    /**
     * Set the virtual host.
     * @param virtualHost the virtual host to use when connecting to the broker
     */
    public ConnectionFactory setVirtualHost(String virtualHost) {
        this.virtualHost = virtualHost;
        return this;
    }
    /**
     * Convenience method for setting the fields in an AMQP URI: host,
     * port, username, password and virtual host.  If any part of the
     * URI is omitted, the ConnectionFactory's corresponding variable
     * is left unchanged.
     * @param uri is the AMQP URI containing the data
     */
    public ConnectionFactory setUri(URI uri)
        throws URISyntaxException, NoSuchAlgorithmException, KeyManagementException
    {
        if ("amqp".equals(uri.getScheme().toLowerCase())) {
            // nothing special to do
        } else if ("amqps".equals(uri.getScheme().toLowerCase())) {
            setPort(DEFAULT_AMQP_OVER_SSL_PORT);
            // SSL context factory not set yet, we use the default one
            if (this.sslContextFactory == null) {
                useSslProtocol();
            }
        } else {
            throw new IllegalArgumentException("Wrong scheme in AMQP URI: " +
                                               uri.getScheme());
        }
        String host = uri.getHost();
        if (host != null) {
            setHost(host);
        }
        int port = uri.getPort();
        if (port != -1) {
            setPort(port);
        }
        String userInfo = uri.getRawUserInfo();
        if (userInfo != null) {
            String userPass[] = userInfo.split(":");
            if (userPass.length > 2) {
                throw new IllegalArgumentException("Bad user info in AMQP " +
                                                   "URI: " + userInfo);
            }
            setUsername(uriDecode(userPass[0]));
            if (userPass.length == 2) {
                setPassword(uriDecode(userPass[1]));
            }
        }
        String path = uri.getRawPath();
        if (path != null && path.length() > 0) {
            if (path.indexOf('/', 1) != -1) {
                throw new IllegalArgumentException("Multiple segments in " +
                                                   "path of AMQP URI: " +
                                                   path);
            }
            setVirtualHost(uriDecode(uri.getPath().substring(1)));
        }
        
        String rawQuery = uri.getRawQuery();
        if (rawQuery != null && rawQuery.length() > 0) {
            setQuery(rawQuery);
        }
        return this;
    }
    /**
     * Convenience method for setting the fields in an AMQP URI: host,
     * port, username, password and virtual host.  If any part of the
     * URI is omitted, the ConnectionFactory's corresponding variable
     * is left unchanged.  Note that not all valid AMQP URIs are
     * accepted; in particular, the hostname must be given if the
     * port, username or password are given, and escapes in the
     * hostname are not permitted.
     * @param uriString is the AMQP URI containing the data
     */
    public ConnectionFactory setUri(String uriString)
        throws URISyntaxException, NoSuchAlgorithmException, KeyManagementException
    {
        setUri(new URI(uriString));
        return this;
    }
    private static String uriDecode(String s) {
        try {
            // URLDecode decodes '+' to a space, as for
            // form encoding.  So protect plus signs.
            return URLDecoder.decode(s.replace("+", "%2B"), "US-ASCII");
        }
        catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
  private static final Map<String, BiConsumer<String, ConnectionFactory>> URI_QUERY_PARAMETER_HANDLERS =
      new HashMap<String, BiConsumer<String, ConnectionFactory>>() {
        {
            put("heartbeat", (value, cf) -> {
                try {
                    int heartbeatInt = Integer.parseInt(value);
                    cf.setRequestedHeartbeat(heartbeatInt);
                } catch (NumberFormatException e) {
                    throw new IllegalArgumentException("Requested heartbeat must an integer");
                }
            });
            put("connection_timeout", (value, cf) -> {
              try {
                int connectionTimeoutInt = Integer.parseInt(value);
                cf.setConnectionTimeout(connectionTimeoutInt);
              } catch (NumberFormatException e) {
                throw new IllegalArgumentException("TCP connection timeout must an integer");
              }
            });
            put("channel_max", (value, cf) -> {
                try {
                    int channelMaxInt = Integer.parseInt(value);
                    cf.setRequestedChannelMax(channelMaxInt);
                } catch (NumberFormatException e) {
                    throw new IllegalArgumentException("Requested channel max must an integer");
                }
            });
        }
      };
    /**
     * Convenience method for setting some fields from query parameters
     * Will handle only a subset of the query parameters supported by the
     * official erlang client
     * https://www.rabbitmq.com/uri-query-parameters.html
     * @param rawQuery is the string containing the raw query parameters part from a URI
     */
    private ConnectionFactory setQuery(String rawQuery) {
        Map<String, String> parameters = new HashMap<>();
        // parsing the query parameters
        try {
            for (String param : rawQuery.split("&")) {
                String[] pair = param.split("=");
                String key = URLDecoder.decode(pair[0], "US-ASCII");
                String value = null;
                if (pair.length > 1) {
                    value = URLDecoder.decode(pair[1], "US-ASCII");
                }
                parameters.put(key, value);
            }
        } catch (IOException e) {
            throw new IllegalArgumentException("Cannot parse the query parameters", e);
        }
        for (Entry<String, String> entry : parameters.entrySet()) {
            BiConsumer<String, ConnectionFactory> handler = URI_QUERY_PARAMETER_HANDLERS
                .get(entry.getKey());
            if (handler != null) {
                handler.accept(entry.getValue(), this);
            } else {
                processUriQueryParameter(entry.getKey(), entry.getValue());
            }
        }
        return this;
    }
    /**
     * Hook to process query parameters not handled natively.
     * Handled natively: <code>heartbeat</code>, <code>connection_timeout</code>,
     * <code>channel_max</code>.
     * @param key
     * @param value
     */
    protected void processUriQueryParameter(String key, String value) {
    }
    /**
     * Retrieve the requested maximum channel number
     * @return the initially requested maximum channel number; zero for unlimited
     */
    public int getRequestedChannelMax() {
        return this.requestedChannelMax;
    }
    /**
     * Set the requested maximum channel number.
     * <p>
     * Note the value must be between 0 and 65535 (unsigned short in AMQP 0-9-1).
     *
     * @param requestedChannelMax initially requested maximum channel number; zero for unlimited
     */
    public ConnectionFactory setRequestedChannelMax(int requestedChannelMax) {
        if (requestedChannelMax < 0 || requestedChannelMax > MAX_UNSIGNED_SHORT) {
            throw new IllegalArgumentException("Requested channel max must be between 0 and " + MAX_UNSIGNED_SHORT);
        }
        this.requestedChannelMax = requestedChannelMax;
        return this;
    }
    /**
     * Retrieve the requested maximum frame size
     * @return the initially requested maximum frame size, in octets; zero for unlimited
     */
    public int getRequestedFrameMax() {
        return this.requestedFrameMax;
    }
    /**
     * Set the requested maximum frame size
     * @param requestedFrameMax initially requested maximum frame size, in octets; zero for unlimited
     */
    public ConnectionFactory setRequestedFrameMax(int requestedFrameMax) {
        this.requestedFrameMax = requestedFrameMax;
        return this;
    }
    /**
     * Retrieve the requested heartbeat interval.
     * @return the initially requested heartbeat interval, in seconds; zero for none
     */
    public int getRequestedHeartbeat() {
        return this.requestedHeartbeat;
    }
    /**
     * Set the TCP connection timeout.
     * @param timeout connection TCP establishment timeout in milliseconds; zero for infinite
     */
    public ConnectionFactory setConnectionTimeout(int timeout) {
        if(timeout < 0) {
            throw new IllegalArgumentException("TCP connection timeout cannot be negative");
        }
        this.connectionTimeout = timeout;
        return this;
    }
    /**
     * Retrieve the TCP connection timeout.
     * @return the TCP connection timeout, in milliseconds; zero for infinite
     */
    public int getConnectionTimeout() {
        return this.connectionTimeout;
    }
    /**
     * Retrieve the AMQP 0-9-1 protocol handshake timeout.
     * @return the AMQP0-9-1 protocol handshake timeout, in milliseconds
     */
    public int getHandshakeTimeout() {
        return handshakeTimeout;
    }
    /**
     * Set the AMQP0-9-1 protocol handshake timeout.
     * @param timeout the AMQP0-9-1 protocol handshake timeout, in milliseconds
     */
    public ConnectionFactory setHandshakeTimeout(int timeout) {
        if(timeout < 0) {
            throw new IllegalArgumentException("handshake timeout cannot be negative");
        }
        this.handshakeTimeout = timeout;
        return this;
    }
    /**
     * Set the shutdown timeout. This is the amount of time that Consumer implementations have to
     * continue working through deliveries (and other Consumer callbacks) <b>after</b> the connection
     * has closed but before the ConsumerWorkService is torn down. If consumers exceed this timeout
     * then any remaining queued deliveries (and other Consumer callbacks, <b>including</b>
     * the Consumer's handleShutdownSignal() invocation) will be lost.
     * @param shutdownTimeout shutdown timeout in milliseconds; zero for infinite; default 10000
     */
    public ConnectionFactory setShutdownTimeout(int shutdownTimeout) {
        this.shutdownTimeout = shutdownTimeout;
        return this;
    }
    /**
     * Retrieve the shutdown timeout.
     * @return the shutdown timeout, in milliseconds; zero for infinite
     */
    public int getShutdownTimeout() {
        return shutdownTimeout;
    }
    /**
     * Set the requested heartbeat timeout. Heartbeat frames will be sent at about 1/2 the timeout interval.
     * If server heartbeat timeout is configured to a non-zero value, this method can only be used
     * to lower the value; otherwise any value provided by the client will be used.
     * <p>
     * Note the value must be between 0 and 65535 (unsigned short in AMQP 0-9-1).
     *
     * @param requestedHeartbeat the initially requested heartbeat timeout, in seconds; zero for none
     * @see <a href="https://rabbitmq.com/heartbeats.html">RabbitMQ Heartbeats Guide</a>
     */
    public ConnectionFactory setRequestedHeartbeat(int requestedHeartbeat) {
        if (requestedHeartbeat < 0 || requestedHeartbeat > MAX_UNSIGNED_SHORT) {
            throw new IllegalArgumentException("Requested heartbeat must be between 0 and " + MAX_UNSIGNED_SHORT);
        }
        this.requestedHeartbeat = requestedHeartbeat;
        return this;
    }
    /**
     * Retrieve the currently-configured table of client properties
     * that will be sent to the server during connection
     * startup. Clients may add, delete, and alter keys in this
     * table. Such changes will take effect when the next new
     * connection is started using this factory.
     * @return the map of client properties
     * @see #setClientProperties
     */
    public Map<String, Object> getClientProperties() {
        return _clientProperties;
    }
    /**
     * Replace the table of client properties that will be sent to the
     * server during subsequent connection startups.
     * @param clientProperties the map of extra client properties
     * @see #getClientProperties
     */
    public ConnectionFactory setClientProperties(Map<String, Object> clientProperties) {
        this._clientProperties = clientProperties;
        return this;
    }
    /**
     * Gets the sasl config to use when authenticating
     * @return the sasl config
     * @see com.rabbitmq.client.SaslConfig
     */
    public SaslConfig getSaslConfig() {
        return saslConfig;
    }
    /**
     * Sets the sasl config to use when authenticating
     * @param saslConfig
     * @see com.rabbitmq.client.SaslConfig
     */
    public ConnectionFactory setSaslConfig(SaslConfig saslConfig) {
        this.saslConfig = saslConfig;
        return this;
    }
    /**
     * Retrieve the socket factory used to make connections with.
     */
    public SocketFactory getSocketFactory() {
        return this.socketFactory;
    }
    /**
     * Set the socket factory used to create sockets for new connections. Can be
     * used to customize TLS-related settings by passing in a
     * javax.net.ssl.SSLSocketFactory instance.
     * Note this applies only to blocking IO, not to
     * NIO, as the NIO API doesn't use the SocketFactory API.
     * @see #useSslProtocol
     */
    public ConnectionFactory setSocketFactory(SocketFactory factory) {
        this.socketFactory = factory;
        return this;
    }
    /**
     * Get the socket configurator.
     *
     * @see #setSocketConfigurator(SocketConfigurator)
     */
    public SocketConfigurator getSocketConfigurator() {
        return socketConf;
    }
    /**
     * Set the socket configurator. This gets a chance to "configure" a socket
     * before it has been opened. The default socket configurator disables
     * Nagle's algorithm.
     *
     * @param socketConfigurator the configurator to use
     */
    public ConnectionFactory setSocketConfigurator(SocketConfigurator socketConfigurator) {
        this.socketConf = socketConfigurator;
        return this;
    }
    /**
     * Set the executor to use for consumer operation dispatch
     * by default for newly created connections.
     * All connections that use this executor share it.
     *
     * It's developer's responsibility to shut down the executor
     * when it is no longer needed.
     *
     * @param executor executor service to be used for
     *                 consumer operation
     */
    public ConnectionFactory setSharedExecutor(ExecutorService executor) {
        this.sharedExecutor = executor;
        return this;
    }
    /**
     * Set the executor to use for connection shutdown.
     * All connections that use this executor share it.
     *
     * It's developer's responsibility to shut down the executor
     * when it is no longer needed.
     *
     * @param executor executor service to be used for
     *                 connection shutdown
     */
    public ConnectionFactory setShutdownExecutor(ExecutorService executor) {
        this.shutdownExecutor = executor;
        return this;
    }
    /**
     * Set the executor to use to send heartbeat frames.
     * All connections that use this executor share it.
     *
     * It's developer's responsibility to shut down the executor
     * when it is no longer needed.
     *
     * @param executor executor service to be used to send heartbeat 
     */
    public ConnectionFactory setHeartbeatExecutor(ScheduledExecutorService executor) {
        this.heartbeatExecutor = executor;
        return this;
    }
    
    /**
     * Retrieve the thread factory used to instantiate new threads.
     * @see ThreadFactory
     */
    public ThreadFactory getThreadFactory() {
        return threadFactory;
    }
    /**
     * Set the thread factory used to instantiate new threads.
     * @see ThreadFactory
     */
    public ConnectionFactory setThreadFactory(ThreadFactory threadFactory) {
        this.threadFactory = threadFactory;
        return this;
    }
    /**
    * Get the exception handler.
    *
    * @see com.rabbitmq.client.ExceptionHandler
    */
    public ExceptionHandler getExceptionHandler() {
        return exceptionHandler;
    }
    /**
     * Set the exception handler to use for newly created connections.
     * @see com.rabbitmq.client.ExceptionHandler
     */
    public ConnectionFactory setExceptionHandler(ExceptionHandler exceptionHandler) {
        if (exceptionHandler == null) {
          throw new IllegalArgumentException("exception handler cannot be null!");
        }
        this.exceptionHandler = exceptionHandler;
        return this;
    }
    public boolean isSSL(){
        return getSocketFactory() instanceof SSLSocketFactory || sslContextFactory != null;
    }
    /**
     * Convenience method for configuring TLS using
     * the default set of TLS protocols and a trusting TrustManager.
     * This setup is <strong>only suitable for development
     * and QA environments</strong>.
     * The trust manager will <strong>trust every server certificate presented</strong>
     * to it, this is convenient for local development but
     * <strong>not recommended to use in production</strong> as it provides no protection
     * against man-in-the-middle attacks. Prefer {@link #useSslProtocol(SSLContext)}.
     */
    public ConnectionFactory useSslProtocol()
        throws NoSuchAlgorithmException, KeyManagementException
    {
        return useSslProtocol(computeDefaultTlsProtocol(SSLContext.getDefault().getSupportedSSLParameters().getProtocols()));
    }
    /**
     * Convenience method for configuring TLS using
     * the supplied protocol and a very trusting TrustManager. This setup is <strong>only suitable for development
     * and QA environments</strong>.
     * The trust manager <strong>will trust every server certificate presented</strong>
     * to it, this is convenient for local development but
     * not recommended to use in production as it <strong>provides no protection
     * against man-in-the-middle attacks</strong>.
     *
     * Use {@link #useSslProtocol(SSLContext)} in production environments.
     * The produced {@link SSLContext} instance will be shared by all
     * the connections created by this connection factory.
     *
     * Use {@link #setSslContextFactory(SslContextFactory)} for more flexibility.
     * @see #setSslContextFactory(SslContextFactory)
     */
    public ConnectionFactory useSslProtocol(String protocol)
        throws NoSuchAlgorithmException, KeyManagementException
    {
        return useSslProtocol(protocol, new TrustEverythingTrustManager());
    }
    /**
     * Convenience method for configuring TLS.
     * Pass in the TLS protocol version to use, e.g. "TLSv1.2" or "TLSv1.1", and
     * a desired {@link TrustManager}.
     *
     *
     * The produced {@link SSLContext} instance will be shared with all
     * the connections created by this connection factory. Use
     * {@link #setSslContextFactory(SslContextFactory)} for more flexibility.
     * @param protocol the TLS protocol to use.
     * @param trustManager the {@link TrustManager} implementation to use.
     * @see #setSslContextFactory(SslContextFactory)
     * @see #useSslProtocol(SSLContext)
     */
    public ConnectionFactory useSslProtocol(String protocol, TrustManager trustManager)
        throws NoSuchAlgorithmException, KeyManagementException
    {
        SSLContext c = SSLContext.getInstance(protocol);
        c.init(null, new TrustManager[] { trustManager }, null);
        return useSslProtocol(c);
    }
    /**
     * Sets up TLS with an initialized {@link SSLContext}. The caller is responsible
     * for setting up the context with a {@link TrustManager} with suitable security guarantees,
     * e.g. peer verification.
     *
     *
     * The {@link SSLContext} instance will be shared with all
     * the connections created by this connection factory. Use
     * {@link #setSslContextFactory(SslContextFactory)} for more flexibility.
     * @param context An initialized SSLContext
     * @see #setSslContextFactory(SslContextFactory)
     */
    public ConnectionFactory useSslProtocol(SSLContext context) {
        this.sslContextFactory = name -> context;
        setSocketFactory(context.getSocketFactory());
        return this;
    }
    /**
     * Enable server hostname verification for TLS connections.
     * <p>
     * This enables hostname verification regardless of the IO mode
     * used (blocking or non-blocking IO).
     * <p>
     * This can be called typically after setting the {@link SSLContext}
     * with one of the <code>useSslProtocol</code> methods.
     *
     * @see NioParams#enableHostnameVerification()
     * @see NioParams#setSslEngineConfigurator(SslEngineConfigurator)
     * @see SslEngineConfigurators#ENABLE_HOSTNAME_VERIFICATION
     * @see SocketConfigurators#ENABLE_HOSTNAME_VERIFICATION
     * @see ConnectionFactory#useSslProtocol(String)
     * @see ConnectionFactory#useSslProtocol(SSLContext)
     * @see ConnectionFactory#useSslProtocol()
     * @see ConnectionFactory#useSslProtocol(String, TrustManager)
     * @since 5.4.0
     */
    public ConnectionFactory enableHostnameVerification() {
        enableHostnameVerificationForNio();
        enableHostnameVerificationForBlockingIo();
        return this;
    }
    protected void enableHostnameVerificationForNio() {
        if (this.nioParams == null) {
            this.nioParams = new NioParams();
        }
        this.nioParams = this.nioParams.enableHostnameVerification();
    }
    protected void enableHostnameVerificationForBlockingIo() {
        if (this.socketConf == null) {
            this.socketConf = SocketConfigurators.builder().defaultConfigurator().enableHostnameVerification().build();
        } else {
            this.socketConf = this.socketConf.andThen(SocketConfigurators.enableHostnameVerification());
        }
    }
    public static String computeDefaultTlsProtocol(String[] supportedProtocols) {
        if(supportedProtocols != null) {
            for (String supportedProtocol : supportedProtocols) {
                if(PREFERRED_TLS_PROTOCOL.equalsIgnoreCase(supportedProtocol)) {
                    return supportedProtocol;
                }
            }
        }
        return FALLBACK_TLS_PROTOCOL;
    }
    /**
     * Returns true if <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, false otherwise
     * @return true if automatic connection recovery is enabled, false otherwise
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public boolean isAutomaticRecoveryEnabled() {
        return automaticRecovery;
    }
    /**
     * Enables or disables <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>.
     * @param automaticRecovery if true, enables connection recovery
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public ConnectionFactory setAutomaticRecoveryEnabled(boolean automaticRecovery) {
        this.automaticRecovery = automaticRecovery;
        return this;
    }
    /**
     * Returns true if topology recovery is enabled, false otherwise
     * @return true if topology recovery is enabled, false otherwise
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public boolean isTopologyRecoveryEnabled() {
        return topologyRecovery;
    }
    /**
     * Enables or disables topology recovery
     * @param topologyRecovery if true, enables topology recovery
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public ConnectionFactory setTopologyRecoveryEnabled(boolean topologyRecovery) {
        this.topologyRecovery = topologyRecovery;
        return this;
    }
    
    /**
     * Get the executor to use for parallel topology recovery. If null (the default), recovery is done single threaded on the main connection thread.
     * @return thread pool executor
     * @since 4.7.0
     */
    public ExecutorService getTopologyRecoveryExecutor() {
        return topologyRecoveryExecutor;
    }
    
    /**
     * Set the executor to use for parallel topology recovery. If null (the default), recovery is done single threaded on the main connection thread.
     * It is recommended to pass a ThreadPoolExecutor that will allow its core threads to timeout so these threads can die when recovery is complete.
     * It's developer's responsibility to shut down the executor when it is no longer needed.
     * Note: your {@link ExceptionHandler#handleTopologyRecoveryException(Connection, Channel, TopologyRecoveryException)} method should be thread-safe.
     * @param topologyRecoveryExecutor thread pool executor
     * @since 4.7.0
     */
    public ConnectionFactory setTopologyRecoveryExecutor(final ExecutorService topologyRecoveryExecutor) {
        this.topologyRecoveryExecutor = topologyRecoveryExecutor;
        return this;
    }
    public ConnectionFactory setMetricsCollector(MetricsCollector metricsCollector) {
        this.metricsCollector = metricsCollector;
        return this;
    }
    public MetricsCollector getMetricsCollector() {
        return metricsCollector;
    }
  /**
   * Set observation collector.
   *
   * @param observationCollector the collector instance
   * @since 5.19.0
   * @see ObservationCollector
   * @see com.rabbitmq.client.observation.micrometer.MicrometerObservationCollectorBuilder
   */
  public void setObservationCollector(ObservationCollector observationCollector) {
        this.observationCollector = observationCollector;
    }
    /**
     * Set a {@link CredentialsRefreshService} instance to handle credentials refresh if appropriate.
     * <p>
     * Each created connection will register to the refresh service to send an AMQP <code>update.secret</code>
     * frame when credentials are about to expire. This is the refresh service responsibility to schedule
     * credentials refresh and <code>udpate.secret</code> frame sending, based on the information provided
     * by the {@link CredentialsProvider}.
     * <p>
     * Note the {@link CredentialsRefreshService} is used only when the {@link CredentialsProvider}
     * signals credentials can expire, by returning a non-null value from {@link CredentialsProvider#getTimeBeforeExpiration()}.
     *
     * @param credentialsRefreshService the refresh service to use
     * @see #setCredentialsProvider(CredentialsProvider)
     * @see DefaultCredentialsRefreshService
     */
    public ConnectionFactory setCredentialsRefreshService(CredentialsRefreshService credentialsRefreshService) {
        this.credentialsRefreshService = credentialsRefreshService;
        return this;
    }
    protected synchronized FrameHandlerFactory createFrameHandlerFactory() throws IOException {
        if(nio) {
            if(this.frameHandlerFactory == null) {
                if(this.nioParams.getNioExecutor() == null && this.nioParams.getThreadFactory() == null) {
                    this.nioParams.setThreadFactory(getThreadFactory());
                }
                this.frameHandlerFactory = new SocketChannelFrameHandlerFactory(
                    connectionTimeout, nioParams, isSSL(), sslContextFactory,
                    this.maxInboundMessageBodySize);
            }
            return this.frameHandlerFactory;
        } else {
            return new SocketFrameHandlerFactory(connectionTimeout, socketFactory,
                socketConf, isSSL(), this.shutdownExecutor, sslContextFactory,
                this.maxInboundMessageBodySize);
        }
    }
    /**
     * Create a new broker connection, picking the first available address from
     * the list.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address from the provided list.
     *
     * @param addrs an array of known broker addresses (hostname/port pairs) to try in order
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     */
    public Connection newConnection(Address[] addrs) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, Arrays.asList(addrs), null);
    }
    /**
     * Create a new broker connection, picking the first available address from
     * the list provided by the {@link AddressResolver}.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address provided by the {@link AddressResolver}.
     *
     * @param addressResolver discovery service to list potential addresses (hostname/port pairs) to connect to
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public Connection newConnection(AddressResolver addressResolver) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, addressResolver, null);
    }
    /**
     * Create a new broker connection with a client-provided name, picking the first available address from
     * the list.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address from the provided list.
     *
     * @param addrs an array of known broker addresses (hostname/port pairs) to try in order
     * @param clientProvidedName application-specific connection name, will be displayed
     *                           in the management UI if RabbitMQ server supports it.
     *                           This value doesn't have to be unique and cannot be used
     *                           as a connection identifier e.g. in HTTP API requests.
     *                           This value is supposed to be human-readable.
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     */
    public Connection newConnection(Address[] addrs, String clientProvidedName) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, Arrays.asList(addrs), clientProvidedName);
    }
    /**
     * Create a new broker connection, picking the first available address from
     * the list.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address from the provided list.
     *
     * @param addrs a List of known broker addresses (hostname/port pairs) to try in order
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     */
    public Connection newConnection(List<Address> addrs) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, addrs, null);
    }
    /**
     * Create a new broker connection with a client-provided name, picking the first available address from
     * the list.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address from the provided list.
     *
     * @param addrs a List of known broker addresses (hostname/port pairs) to try in order
     * @param clientProvidedName application-specific connection name, will be displayed
     *                           in the management UI if RabbitMQ server supports it.
     *                           This value doesn't have to be unique and cannot be used
     *                           as a connection identifier e.g. in HTTP API requests.
     *                           This value is supposed to be human-readable.
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     */
    public Connection newConnection(List<Address> addrs, String clientProvidedName) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, addrs, clientProvidedName);
    }
    /**
     * Create a new broker connection, picking the first available address from
     * the list.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address from the provided list.
     *
     * @param executor thread execution service for consumers on the connection
     * @param addrs an array of known broker addresses (hostname/port pairs) to try in order
     * @return an interface to the connection
     * @throws java.io.IOException if it encounters a problem
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public Connection newConnection(ExecutorService executor, Address[] addrs) throws IOException, TimeoutException {
        return newConnection(executor, Arrays.asList(addrs), null);
    }
    /**
     * Create a new broker connection with a client-provided name, picking the first available address from
     * the list.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address from the provided list.
     *
     * @param executor thread execution service for consumers on the connection
     * @param addrs an array of known broker addresses (hostname/port pairs) to try in order
     * @param clientProvidedName application-specific connection name, will be displayed
     *                           in the management UI if RabbitMQ server supports it.
     *                           This value doesn't have to be unique and cannot be used
     *                           as a connection identifier e.g. in HTTP API requests.
     *                           This value is supposed to be human-readable.
     * @return an interface to the connection
     * @throws java.io.IOException if it encounters a problem
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public Connection newConnection(ExecutorService executor, Address[] addrs, String clientProvidedName) throws IOException, TimeoutException {
        return newConnection(executor, Arrays.asList(addrs), clientProvidedName);
    }
    /**
     * Create a new broker connection, picking the first available address from
     * the list.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address from the provided list.
     *
     * @param executor thread execution service for consumers on the connection
     * @param addrs a List of known broker addrs (hostname/port pairs) to try in order
     * @return an interface to the connection
     * @throws java.io.IOException if it encounters a problem
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public Connection newConnection(ExecutorService executor, List<Address> addrs) throws IOException, TimeoutException {
        return newConnection(executor, addrs, null);
    }
    /**
     * Create a new broker connection, picking the first available address from
     * the list provided by the {@link AddressResolver}.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address provided by the {@link AddressResolver}.
     *
     * @param executor thread execution service for consumers on the connection
     * @param addressResolver discovery service to list potential addresses (hostname/port pairs) to connect to
     * @return an interface to the connection
     * @throws java.io.IOException if it encounters a problem
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public Connection newConnection(ExecutorService executor, AddressResolver addressResolver) throws IOException, TimeoutException {
        return newConnection(executor, addressResolver, null);
    }
    /**
     * Create a new broker connection with a client-provided name, picking the first available address from
     * the list.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address from the provided list.
     *
     * @param executor thread execution service for consumers on the connection
     * @param addrs a List of known broker addrs (hostname/port pairs) to try in order
     * @param clientProvidedName application-specific connection name, will be displayed
     *                           in the management UI if RabbitMQ server supports it.
     *                           This value doesn't have to be unique and cannot be used
     *                           as a connection identifier e.g. in HTTP API requests.
     *                           This value is supposed to be human-readable.
     * @return an interface to the connection
     * @throws java.io.IOException if it encounters a problem
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public Connection newConnection(ExecutorService executor, List<Address> addrs, String clientProvidedName)
            throws IOException, TimeoutException {
        return newConnection(executor, createAddressResolver(addrs), clientProvidedName);
    }
    /**
     * Create a new broker connection with a client-provided name, picking the first available address from
     * the list provided by the {@link AddressResolver}.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Future
     * reconnection attempts will pick a random accessible address provided by the {@link AddressResolver}.
     *
     * @param executor thread execution service for consumers on the connection
     * @param addressResolver discovery service to list potential addresses (hostname/port pairs) to connect to
     * @param clientProvidedName application-specific connection name, will be displayed
     *                           in the management UI if RabbitMQ server supports it.
     *                           This value doesn't have to be unique and cannot be used
     *                           as a connection identifier e.g. in HTTP API requests.
     *                           This value is supposed to be human-readable.
     * @return an interface to the connection
     * @throws java.io.IOException if it encounters a problem
     * @see <a href="https://www.rabbitmq.com/api-guide.html#recovery">Automatic Recovery</a>
     */
    public Connection newConnection(ExecutorService executor, AddressResolver addressResolver, String clientProvidedName)
        throws IOException, TimeoutException {
        if(this.metricsCollector == null) {
            this.metricsCollector = new NoOpMetricsCollector();
        }
        // make sure we respect the provided thread factory
        FrameHandlerFactory fhFactory = createFrameHandlerFactory();
        ConnectionParams params = params(executor);
        // set client-provided via a client property
        if (clientProvidedName != null) {
            Map<String, Object> properties = new HashMap<String, Object>(params.getClientProperties());
            properties.put("connection_name", clientProvidedName);
            params.setClientProperties(properties);
        }
        if (isAutomaticRecoveryEnabled()) {
            // see com.rabbitmq.client.impl.recovery.RecoveryAwareAMQConnectionFactory#newConnection
            // No Sonar: no need to close this resource because we're the one that creates it
            // and hands it over to the user
            AutorecoveringConnection conn = new AutorecoveringConnection(
                params, fhFactory, addressResolver, metricsCollector, observationCollector); //NOSONAR
            conn.init();
            return conn;
        } else {
            List<Address> addrs = addressResolver.getAddresses();
            Exception lastException = null;
            for (Address addr : addrs) {
                try {
                    FrameHandler handler = fhFactory.create(addr, clientProvidedName);
                    AMQConnection conn = createConnection(params, handler, metricsCollector);
                    conn.start();
                    this.metricsCollector.newConnection(conn);
                    return conn;
                } catch (IOException e) {
                    lastException = e;
                } catch (TimeoutException te) {
                    lastException = te;
                }
            }
            if (lastException != null) {
                if (lastException instanceof IOException) {
                    throw (IOException) lastException;
                } else if (lastException instanceof TimeoutException) {
                    throw (TimeoutException) lastException;
                }
            }
            throw new IOException("failed to connect");
        }
    }
    public ConnectionParams params(ExecutorService consumerWorkServiceExecutor) {
        ConnectionParams result = new ConnectionParams();
        result.setCredentialsProvider(credentialsProvider);
        result.setConsumerWorkServiceExecutor(consumerWorkServiceExecutor);
        result.setVirtualHost(virtualHost);
        result.setClientProperties(getClientProperties());
        result.setRequestedFrameMax(requestedFrameMax);
        result.setRequestedChannelMax(requestedChannelMax);
        result.setShutdownTimeout(shutdownTimeout);
        result.setSaslConfig(saslConfig);
        result.setNetworkRecoveryInterval(networkRecoveryInterval);
        result.setRecoveryDelayHandler(recoveryDelayHandler);
        result.setTopologyRecovery(topologyRecovery);
        result.setTopologyRecoveryExecutor(topologyRecoveryExecutor);
        result.setExceptionHandler(exceptionHandler);
        result.setThreadFactory(threadFactory);
        result.setHandshakeTimeout(handshakeTimeout);
        result.setRequestedHeartbeat(requestedHeartbeat);
        result.setShutdownExecutor(shutdownExecutor);
        result.setHeartbeatExecutor(heartbeatExecutor);
        result.setChannelRpcTimeout(channelRpcTimeout);
        result.setChannelShouldCheckRpcResponseType(channelShouldCheckRpcResponseType);
        result.setWorkPoolTimeout(workPoolTimeout);
        result.setErrorOnWriteListener(errorOnWriteListener);
        result.setTopologyRecoveryFilter(topologyRecoveryFilter);
        result.setConnectionRecoveryTriggeringCondition(connectionRecoveryTriggeringCondition);
        result.setTopologyRecoveryRetryHandler(topologyRecoveryRetryHandler);
        result.setRecoveredQueueNameSupplier(recoveredQueueNameSupplier);
        result.setTrafficListener(trafficListener);
        result.setCredentialsRefreshService(credentialsRefreshService);
        result.setMaxInboundMessageBodySize(maxInboundMessageBodySize);
        return result;
    }
    protected AMQConnection createConnection(ConnectionParams params, FrameHandler frameHandler, MetricsCollector metricsCollector) {
        return new AMQConnection(params, frameHandler, metricsCollector, observationCollector);
    }
    /**
     * Create a new broker connection.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Reconnection
     * attempts will always use the address configured on {@link ConnectionFactory}.
     *
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     */
    public Connection newConnection() throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, Collections.singletonList(new Address(getHost(), getPort())));
    }
    /**
     * Create a new broker connection.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Reconnection
     * attempts will always use the address configured on {@link ConnectionFactory}.
     *
     * @param connectionName client-provided connection name (an arbitrary string). Will
     *                       be displayed in management UI if the server supports it.
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     */
    public Connection newConnection(String connectionName) throws IOException, TimeoutException {
        return newConnection(this.sharedExecutor, Collections.singletonList(new Address(getHost(), getPort())), connectionName);
    }
    /**
     * Create a new broker connection.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Reconnection
     * attempts will always use the address configured on {@link ConnectionFactory}.
     *
     * @param executor thread execution service for consumers on the connection
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     */
    public Connection newConnection(ExecutorService executor) throws IOException, TimeoutException {
        return newConnection(executor, Collections.singletonList(new Address(getHost(), getPort())));
    }
    /**
     * Create a new broker connection.
     *
     * If <a href="https://www.rabbitmq.com/api-guide.html#recovery">automatic connection recovery</a>
     * is enabled, the connection returned by this method will be {@link Recoverable}. Reconnection
     * attempts will always use the address configured on {@link ConnectionFactory}.
     *
     * @param executor thread execution service for consumers on the connection
     * @param connectionName client-provided connection name (an arbitrary string). Will
     *                       be displayed in management UI if the server supports it.
     * @return an interface to the connection
     * @throws IOException if it encounters a problem
     */
    public Connection newConnection(ExecutorService executor, String connectionName) throws IOException, TimeoutException {
        return newConnection(executor, Collections.singletonList(new Address(getHost(), getPort())), connectionName);
    }
    protected AddressResolver createAddressResolver(List<Address> addresses) {
        if (addresses == null || addresses.isEmpty()) {
            throw new IllegalArgumentException("Please provide at least one address to connect to");
        } else if (addresses.size() > 1) {
            return new ListAddressResolver(addresses);
        } else {
            return new DnsRecordIpAddressResolver(addresses.get(0), isSSL());
        }
    }
    @Override public ConnectionFactory clone(){
        try {
            ConnectionFactory clone = (ConnectionFactory)super.clone();
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * Load settings from a property file.
     * Keys must be prefixed with <code>rabbitmq.</code>,
     * use {@link ConnectionFactory#load(String, String)} to
     * specify your own prefix.
     * @param propertyFileLocation location of the property file to use
     * @throws IOException when something goes wrong reading the file
     * @since 4.4.0
     * @see ConnectionFactoryConfigurator
     */
    public ConnectionFactory load(String propertyFileLocation) throws IOException {
        ConnectionFactoryConfigurator.load(this, propertyFileLocation);
        return this;
    }
    /**
     * Load settings from a property file.
     * @param propertyFileLocation location of the property file to use
     * @param prefix key prefix for the entries in the file
     * @throws IOException when something goes wrong reading the file
     * @since 4.4.0
     * @see ConnectionFactoryConfigurator
     */
    public ConnectionFactory load(String propertyFileLocation, String prefix) throws IOException {
        ConnectionFactoryConfigurator.load(this, propertyFileLocation, prefix);
        return this;
    }
    /**
     * Load settings from a {@link Properties} instance.
     * Keys must be prefixed with <code>rabbitmq.</code>,
     * use {@link ConnectionFactory#load(Properties, String)} to
     * specify your own prefix.
     * @param properties source for settings
     * @since 4.4.0
     * @see ConnectionFactoryConfigurator
     */
    public ConnectionFactory load(Properties properties) {
        ConnectionFactoryConfigurator.load(this, properties);
        return this;
    }
    /**
     * Load settings from a {@link Properties} instance.
     * @param properties source for settings
     * @param prefix key prefix for properties entries
     * @since 4.4.0
     * @see ConnectionFactoryConfigurator
     */
    @SuppressWarnings("unchecked")
    public ConnectionFactory load(Properties properties, String prefix) {
        ConnectionFactoryConfigurator.load(this, (Map) properties, prefix);
        return this;
    }
    /**
     * Load settings from a {@link Map} instance.
     * Keys must be prefixed with <code>rabbitmq.</code>,
     * use {@link ConnectionFactory#load(Map, String)} to
     * specify your own prefix.
     * @param properties source for settings
     * @since 4.4.0
     * @see ConnectionFactoryConfigurator
     */
    public ConnectionFactory load(Map<String, String> properties) {
        ConnectionFactoryConfigurator.load(this, properties);
        return this;
    }
    /**
     * Load settings from a {@link Map} instance.
     * @param properties source for settings
     * @param prefix key prefix for map entries
     * @since 4.4.0
     * @see ConnectionFactoryConfigurator
     */
    public ConnectionFactory load(Map<String, String> properties, String prefix) {
        ConnectionFactoryConfigurator.load(this, properties, prefix);
        return this;
    }
    /**
     * Returns automatic connection recovery interval in milliseconds.
     * @return how long will automatic recovery wait before attempting to reconnect, in ms; default is 5000
     */
    public long getNetworkRecoveryInterval() {
        return networkRecoveryInterval;
    }
    /**
     * Sets connection recovery interval. Default is 5000.
     * Uses {@link com.rabbitmq.client.RecoveryDelayHandler.DefaultRecoveryDelayHandler} by default.
     * Use another {@link RecoveryDelayHandler} implementation for more flexibility.
     * @param networkRecoveryInterval how long will automatic recovery wait before attempting to reconnect, in ms
     * @see RecoveryDelayHandler
     */
    public ConnectionFactory setNetworkRecoveryInterval(int networkRecoveryInterval) {
        this.networkRecoveryInterval = networkRecoveryInterval;
        return this;
    }
    /**
     * Sets connection recovery interval. Default is 5000.
     * Uses {@link com.rabbitmq.client.RecoveryDelayHandler.DefaultRecoveryDelayHandler} by default.
     * Use another {@link RecoveryDelayHandler} implementation for more flexibility.
     * @param networkRecoveryInterval how long will automatic recovery wait before attempting to reconnect, in ms
     * @see RecoveryDelayHandler
     */
    public ConnectionFactory setNetworkRecoveryInterval(long networkRecoveryInterval) {
        this.networkRecoveryInterval = networkRecoveryInterval;
        return this;
    }
    
    /**
     * Returns automatic connection recovery delay handler.
     * @return recovery delay handler. May be null if not set.
     * @since 4.3.0
     */
    public RecoveryDelayHandler getRecoveryDelayHandler() {
        return recoveryDelayHandler;
    }
    
    /**
     * Sets the automatic connection recovery delay handler.
     * @param recoveryDelayHandler the recovery delay handler
     * @since 4.3.0
     */
    public ConnectionFactory setRecoveryDelayHandler(final RecoveryDelayHandler recoveryDelayHandler) {
        this.recoveryDelayHandler = recoveryDelayHandler;
        return this;
    }
    /**
     * Sets the parameters when using NIO.
     *
     *
     * @param nioParams
     * @see NioParams
     */
    public ConnectionFactory setNioParams(NioParams nioParams) {
        this.nioParams = nioParams;
        return this;
    }
    /**
     * Retrieve the parameters for NIO mode.
     * @return
     */
    public NioParams getNioParams() {
        return nioParams;
    }
    /**
     * Use non-blocking IO (NIO) for communication with the server.
     * With NIO, several connections created from the same {@link ConnectionFactory}
     * can use the same IO thread.
     *
     * A client process using a lot of not-so-active connections can benefit
     * from NIO, as it would use fewer threads than with the traditional, blocking IO mode.
     *
     * Use {@link NioParams} to tune NIO and a {@link SocketChannelConfigurator} to
     * configure the underlying {@link java.nio.channels.SocketChannel}s for connections.
     *
     * @see NioParams
     * @see SocketChannelConfigurator
     * @see java.nio.channels.SocketChannel
     * @see java.nio.channels.Selector
     */
    public ConnectionFactory useNio() {
        this.nio = true;
        return this;
    }
    /**
     * Use blocking IO for communication with the server.
     * With blocking IO, each connection creates its own thread
     * to read data from the server.
     */
    public ConnectionFactory useBlockingIo() {
        this.nio = false;
        return this;
    }
    /**
     * Set the continuation timeout for RPC calls in channels.
     * Default is 10 minutes. 0 means no timeout.
     * @param channelRpcTimeout
     */
    public ConnectionFactory setChannelRpcTimeout(int channelRpcTimeout) {
        if(channelRpcTimeout < 0) {
            throw new IllegalArgumentException("Timeout cannot be less than 0");
        }
        this.channelRpcTimeout = channelRpcTimeout;
        return this;
    }
    /**
     * Get the timeout for RPC calls in channels.
     * @return
     */
    public int getChannelRpcTimeout() {
        return channelRpcTimeout;
    }
    /**
     * Maximum body size of inbound (received) messages in bytes.
     *
     * <p>Default value is 67,108,864 (64 MiB).
     *
     * @param maxInboundMessageBodySize the maximum size of inbound messages
     */
    public void setMaxInboundMessageBodySize(int maxInboundMessageBodySize) {
        if (maxInboundMessageBodySize <= 0) {
            throw new IllegalArgumentException("Max inbound message body size must be greater than 0: "
                + maxInboundMessageBodySize);
        }
        this.maxInboundMessageBodySize = maxInboundMessageBodySize;
    }
    /**
     * The factory to create SSL contexts.
     * This provides more flexibility to create {@link SSLContext}s
     * for different connections than sharing the {@link SSLContext}
     * with all the connections produced by the connection factory
     * (which is the case with the {@link #useSslProtocol()} methods).
     * This way, different connections with a different certificate
     * for each of them is a possible scenario.
     * @param sslContextFactory
     * @see #useSslProtocol(SSLContext)
     * @since 5.0.0
     */
    public ConnectionFactory setSslContextFactory(SslContextFactory sslContextFactory) {
        this.sslContextFactory = sslContextFactory;
        return this;
    }
    /**
     * When set to true, channels will check the response type (e.g. queue.declare
     * expects a queue.declare-ok response) of RPC calls
     * and ignore those that do not match.
     * Default is false.
     * @param channelShouldCheckRpcResponseType
     */
    public ConnectionFactory setChannelShouldCheckRpcResponseType(boolean channelShouldCheckRpcResponseType) {
        this.channelShouldCheckRpcResponseType = channelShouldCheckRpcResponseType;
        return this;
    }
    public boolean isChannelShouldCheckRpcResponseType() {
        return channelShouldCheckRpcResponseType;
    }
    /**
     * Timeout (in ms) for work pool enqueueing.
     * The {@link com.rabbitmq.client.impl.WorkPool} dispatches several types of responses
     * from the broker (e.g. deliveries). A high-traffic
     * client with slow consumers can exhaust the work pool and
     * compromise the whole connection (by e.g. letting the broker
     * saturate the receive TCP buffers). Setting a timeout
     * would make the connection fail early and avoid hard-to-diagnose
     * TCP connection failure. Note this shouldn't happen
     * with clients that set appropriate QoS values.
     * Default is no timeout.
     *
     * @param workPoolTimeout timeout in ms
     * @since 4.5.0
     */
    public ConnectionFactory setWorkPoolTimeout(int workPoolTimeout) {
        this.workPoolTimeout = workPoolTimeout;
        return this;
    }
    public int getWorkPoolTimeout() {
        return workPoolTimeout;
    }
    /**
     * Set a listener to be called when connection gets an IO error trying to write on the socket.
     * Default listener triggers connection recovery asynchronously and propagates
     * the exception. Override the default listener to disable or
     * customise automatic connection triggering on write operations.
     *
     * @param errorOnWriteListener the listener
     * @since 4.5.0
     */
    public ConnectionFactory setErrorOnWriteListener(ErrorOnWriteListener errorOnWriteListener) {
        this.errorOnWriteListener = errorOnWriteListener;
        return this;
    }
    /**
     * Set filter to include/exclude entities from topology recovery.
     *
     * @since 4.8.0
     */
    public ConnectionFactory setTopologyRecoveryFilter(TopologyRecoveryFilter topologyRecoveryFilter) {
        this.topologyRecoveryFilter = topologyRecoveryFilter;
        return this;
    }
    /**
     * Allows to decide on automatic connection recovery is triggered.
     * Default is for shutdown not initiated by application or missed heartbeat errors.
     *
     * @param connectionRecoveryTriggeringCondition
     */
    public ConnectionFactory setConnectionRecoveryTriggeringCondition(Predicate<ShutdownSignalException> connectionRecoveryTriggeringCondition) {
        this.connectionRecoveryTriggeringCondition = connectionRecoveryTriggeringCondition;
        return this;
    }
    /**
     * Set retry handler for topology recovery.
     * Default is no retry.
     *
     * @param topologyRecoveryRetryHandler
     * @since 5.4.0
     */
    public ConnectionFactory setTopologyRecoveryRetryHandler(RetryHandler topologyRecoveryRetryHandler) {
        this.topologyRecoveryRetryHandler = topologyRecoveryRetryHandler;
        return this;
    }
    /**
     * Set the recovered queue name supplier. Default is use the same queue name when recovering queues.
     * 
     * @param recoveredQueueNameSupplier queue name supplier
     */
    public ConnectionFactory setRecoveredQueueNameSupplier(RecoveredQueueNameSupplier recoveredQueueNameSupplier) {
        this.recoveredQueueNameSupplier = recoveredQueueNameSupplier;
        return this;
    }
    /**
     * Traffic listener notified of inbound and outbound {@link Command}s.
     * <p>
     * Useful for debugging purposes, e.g. logging all sent and received messages.
     * Default is no-op.
     *
     * @param trafficListener
     * @see TrafficListener
     * @see com.rabbitmq.client.impl.LogTrafficListener
     * @since 5.5.0
     */
    public ConnectionFactory setTrafficListener(TrafficListener trafficListener) {
        this.trafficListener = trafficListener;
        return this;
    }
}
package com.rabbitmq.client.impl.nio;
import java.nio.ByteBuffer;
import java.util.function.Function;
/**
 * Default {@link ByteBufferFactory} that creates heap-based {@link ByteBuffer}s.
 * This behavior can be changed by passing in a custom {@link Function<Integer, ByteBuffer>}
 * to the constructor.
 *
 * @see NioParams
 * @see ByteBufferFactory
 * @since 5.5.0
 */
public class DefaultByteBufferFactory implements ByteBufferFactory {
    private final Function<Integer, ByteBuffer> allocator;
    public DefaultByteBufferFactory(Function<Integer, ByteBuffer> allocator) {
        this.allocator = allocator;
    }
    public DefaultByteBufferFactory() {
        this(capacity -> ByteBuffer.allocate(capacity));
    }
    @Override
    public ByteBuffer createReadBuffer(NioContext nioContext) {
        if (nioContext.getSslEngine() == null) {
            return allocator.apply(nioContext.getNioParams().getReadByteBufferSize());
        } else {
            return allocator.apply(nioContext.getSslEngine().getSession().getApplicationBufferSize());
        }
    }
    @Override
    public ByteBuffer createWriteBuffer(NioContext nioContext) {
        if (nioContext.getSslEngine() == null) {
            return allocator.apply(nioContext.getNioParams().getWriteByteBufferSize());
        } else {
            return allocator.apply(nioContext.getSslEngine().getSession().getApplicationBufferSize());
        }
    }
    @Override
    public ByteBuffer createEncryptedReadBuffer(NioContext nioContext) {
        return createEncryptedByteBuffer(nioContext);
    }
    @Override
    public ByteBuffer createEncryptedWriteBuffer(NioContext nioContext) {
        return createEncryptedByteBuffer(nioContext);
    }
    protected ByteBuffer createEncryptedByteBuffer(NioContext nioContext) {
        if (nioContext.getSslEngine() == null) {
            throw new IllegalArgumentException("Encrypted byte buffer should be created only in SSL/TLS context");
        } else {
            return allocator.apply(nioContext.getSslEngine().getSession().getPacketBufferSize());
        }
    }
}
// Copyright (c) 2017-2023 Broadcom. All Rights Reserved. The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
//
// This software, the RabbitMQ Java client library, is triple-licensed under the
// Mozilla Public License 2.0 ("MPL"), the GNU General Public License version 2
// ("GPL") and the Apache License version 2 ("ASL"). For the MPL, please see
// LICENSE-MPL-RabbitMQ. For the GPL, please see LICENSE-GPL2.  For the ASL,
// please see LICENSE-APACHE2.
//
// This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND,
// either express or implied. See the LICENSE file for specific language governing
// rights and limitations of this software.
//
// If you have any questions regarding licensing, please contact us at
// info@rabbitmq.com.
package com.rabbitmq.client;
import com.rabbitmq.client.impl.AMQConnection;
import com.rabbitmq.client.impl.nio.NioParams;
import javax.net.ssl.*;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URISyntaxException;
import java.security.*;
import java.security.cert.CertificateException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
/**
 * Helper class to load {@link ConnectionFactory} settings from a property file.
 * <p>
 * The authorised keys are the constants values in this class (e.g. USERNAME).
 * The property file/properties instance/map instance keys can have
 * a prefix, the default being <code>rabbitmq.</code>.
 * <p>
 * Property files can be loaded from the file system (the default),
 * but also from the classpath, by using the <code>classpath:</code> prefix
 * in the location.
 * <p>
 * Client properties can be set by using
 * the <code>client.properties.</code> prefix, e.g. <code>client.properties.app.name</code>.
 * Default client properties and custom client properties are merged. To remove
 * a default client property, set its key to an empty value.
 *
 * @see ConnectionFactory#load(String, String)
 * @since 5.1.0
 */
public class ConnectionFactoryConfigurator {
    public static final String DEFAULT_PREFIX = "rabbitmq.";
    public static final String USERNAME = "username";
    public static final String PASSWORD = "password"; //NOSONAR
    public static final String VIRTUAL_HOST = "virtual.host";
    public static final String HOST = "host";
    public static final String PORT = "port";
    public static final String CONNECTION_CHANNEL_MAX = "connection.channel.max";
    public static final String CONNECTION_FRAME_MAX = "connection.frame.max";
    public static final String CONNECTION_HEARTBEAT = "connection.heartbeat";
    public static final String CONNECTION_TIMEOUT = "connection.timeout";
    public static final String HANDSHAKE_TIMEOUT = "handshake.timeout";
    public static final String SHUTDOWN_TIMEOUT = "shutdown.timeout";
    public static final String CLIENT_PROPERTIES_PREFIX = "client.properties.";
    public static final String CONNECTION_RECOVERY_ENABLED = "connection.recovery.enabled";
    public static final String TOPOLOGY_RECOVERY_ENABLED = "topology.recovery.enabled";
    public static final String CONNECTION_RECOVERY_INTERVAL = "connection.recovery.interval";
    public static final String CHANNEL_RPC_TIMEOUT = "channel.rpc.timeout";
    public static final String CHANNEL_SHOULD_CHECK_RPC_RESPONSE_TYPE = "channel.should.check.rpc.response.type";
    public static final String USE_NIO = "use.nio";
    public static final String NIO_READ_BYTE_BUFFER_SIZE = "nio.read.byte.buffer.size";
    public static final String NIO_WRITE_BYTE_BUFFER_SIZE = "nio.write.byte.buffer.size";
    public static final String NIO_NB_IO_THREADS = "nio.nb.io.threads";
    public static final String NIO_WRITE_ENQUEUING_TIMEOUT_IN_MS = "nio.write.enqueuing.timeout.in.ms";
    public static final String NIO_WRITE_QUEUE_CAPACITY = "nio.write.queue.capacity";
    public static final String SSL_ALGORITHM = "ssl.algorithm";
    public static final String SSL_ENABLED = "ssl.enabled";
    public static final String SSL_KEY_STORE = "ssl.key.store";
    public static final String SSL_KEY_STORE_PASSWORD = "ssl.key.store.password";
    public static final String SSL_KEY_STORE_TYPE = "ssl.key.store.type";
    public static final String SSL_KEY_STORE_ALGORITHM = "ssl.key.store.algorithm";
    public static final String SSL_TRUST_STORE = "ssl.trust.store";
    public static final String SSL_TRUST_STORE_PASSWORD = "ssl.trust.store.password";
    public static final String SSL_TRUST_STORE_TYPE = "ssl.trust.store.type";
    public static final String SSL_TRUST_STORE_ALGORITHM = "ssl.trust.store.algorithm";
    public static final String SSL_VALIDATE_SERVER_CERTIFICATE = "ssl.validate.server.certificate";
    public static final String SSL_VERIFY_HOSTNAME = "ssl.verify.hostname";
    // aliases allow to be compatible with keys from Spring Boot and still be consistent with
    // the initial naming of the keys
    private static final Map<String, List<String>> ALIASES = new ConcurrentHashMap<String, List<String>>() {{
        put(SSL_KEY_STORE, Arrays.asList("ssl.key-store"));
        put(SSL_KEY_STORE_PASSWORD, Arrays.asList("ssl.key-store-password"));
        put(SSL_KEY_STORE_TYPE, Arrays.asList("ssl.key-store-type"));
        put(SSL_KEY_STORE_ALGORITHM, Arrays.asList("ssl.key-store-algorithm"));
        put(SSL_TRUST_STORE, Arrays.asList("ssl.trust-store"));
        put(SSL_TRUST_STORE_PASSWORD, Arrays.asList("ssl.trust-store-password"));
        put(SSL_TRUST_STORE_TYPE, Arrays.asList("ssl.trust-store-type"));
        put(SSL_TRUST_STORE_ALGORITHM, Arrays.asList("ssl.trust-store-algorithm"));
        put(SSL_VALIDATE_SERVER_CERTIFICATE, Arrays.asList("ssl.validate-server-certificate"));
        put(SSL_VERIFY_HOSTNAME, Arrays.asList("ssl.verify-hostname"));
    }};
    @SuppressWarnings("unchecked")
    public static void load(ConnectionFactory cf, String propertyFileLocation, String prefix) throws IOException {
        if (propertyFileLocation == null || propertyFileLocation.isEmpty()) {
            throw new IllegalArgumentException("Property file argument cannot be null or empty");
        }
        Properties properties = new Properties();
        try (InputStream in = loadResource(propertyFileLocation)) {
            properties.load(in);
        }
        load(cf, (Map) properties, prefix);
    }
    private static InputStream loadResource(String location) throws FileNotFoundException {
        if (location.startsWith("classpath:")) {
            return ConnectionFactoryConfigurator.class.getResourceAsStream(
                    location.substring("classpath:".length())
            );
        } else {
            return new FileInputStream(location);
        }
    }
    public static void load(ConnectionFactory cf, Map<String, String> properties, String prefix) {
        prefix = prefix == null ? "" : prefix;
        String uri = properties.get(prefix + "uri");
        if (uri != null) {
            try {
                cf.setUri(uri);
            } catch (URISyntaxException e) {
                throw new IllegalArgumentException("Error while setting AMQP URI: " + uri, e);
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalArgumentException("Error while setting AMQP URI: " + uri, e);
            } catch (KeyManagementException e) {
                throw new IllegalArgumentException("Error while setting AMQP URI: " + uri, e);
            }
        }
        String username = lookUp(USERNAME, properties, prefix);
        if (username != null) {
            cf.setUsername(username);
        }
        String password = lookUp(PASSWORD, properties, prefix);
        if (password != null) {
            cf.setPassword(password);
        }
        String vhost = lookUp(VIRTUAL_HOST, properties, prefix);
        if (vhost != null) {
            cf.setVirtualHost(vhost);
        }
        String host = lookUp(HOST, properties, prefix);
        if (host != null) {
            cf.setHost(host);
        }
        String port = lookUp(PORT, properties, prefix);
        if (port != null) {
            cf.setPort(Integer.valueOf(port));
        }
        String requestedChannelMax = lookUp(CONNECTION_CHANNEL_MAX, properties, prefix);
        if (requestedChannelMax != null) {
            cf.setRequestedChannelMax(Integer.valueOf(requestedChannelMax));
        }
        String requestedFrameMax = lookUp(CONNECTION_FRAME_MAX, properties, prefix);
        if (requestedFrameMax != null) {
            cf.setRequestedFrameMax(Integer.valueOf(requestedFrameMax));
        }
        String requestedHeartbeat = lookUp(CONNECTION_HEARTBEAT, properties, prefix);
        if (requestedHeartbeat != null) {
            cf.setRequestedHeartbeat(Integer.valueOf(requestedHeartbeat));
        }
        String connectionTimeout = lookUp(CONNECTION_TIMEOUT, properties, prefix);
        if (connectionTimeout != null) {
            cf.setConnectionTimeout(Integer.valueOf(connectionTimeout));
        }
        String handshakeTimeout = lookUp(HANDSHAKE_TIMEOUT, properties, prefix);
        if (handshakeTimeout != null) {
            cf.setHandshakeTimeout(Integer.valueOf(handshakeTimeout));
        }
        String shutdownTimeout = lookUp(SHUTDOWN_TIMEOUT, properties, prefix);
        if (shutdownTimeout != null) {
            cf.setShutdownTimeout(Integer.valueOf(shutdownTimeout));
        }
        Map<String, Object> clientProperties = new HashMap<String, Object>();
        Map<String, Object> defaultClientProperties = AMQConnection.defaultClientProperties();
        clientProperties.putAll(defaultClientProperties);
        for (Map.Entry<String, String> entry : properties.entrySet()) {
            if (entry.getKey().startsWith(prefix + CLIENT_PROPERTIES_PREFIX)) {
                String clientPropertyKey = entry.getKey().substring((prefix + CLIENT_PROPERTIES_PREFIX).length());
                if (defaultClientProperties.containsKey(clientPropertyKey) && (entry.getValue() == null || entry.getValue().trim().isEmpty())) {
                    // if default property and value is empty, remove this property
                    clientProperties.remove(clientPropertyKey);
                } else {
                    clientProperties.put(
                            clientPropertyKey,
                            entry.getValue()
                    );
                }
            }
        }
        cf.setClientProperties(clientProperties);
        String automaticRecovery = lookUp(CONNECTION_RECOVERY_ENABLED, properties, prefix);
        if (automaticRecovery != null) {
            cf.setAutomaticRecoveryEnabled(Boolean.valueOf(automaticRecovery));
        }
        String topologyRecovery = lookUp(TOPOLOGY_RECOVERY_ENABLED, properties, prefix);
        if (topologyRecovery != null) {
            cf.setTopologyRecoveryEnabled(Boolean.valueOf(topologyRecovery));
        }
        String networkRecoveryInterval = lookUp(CONNECTION_RECOVERY_INTERVAL, properties, prefix);
        if (networkRecoveryInterval != null) {
            cf.setNetworkRecoveryInterval(Long.valueOf(networkRecoveryInterval));
        }
        String channelRpcTimeout = lookUp(CHANNEL_RPC_TIMEOUT, properties, prefix);
        if (channelRpcTimeout != null) {
            cf.setChannelRpcTimeout(Integer.valueOf(channelRpcTimeout));
        }
        String channelShouldCheckRpcResponseType = lookUp(CHANNEL_SHOULD_CHECK_RPC_RESPONSE_TYPE, properties, prefix);
        if (channelShouldCheckRpcResponseType != null) {
            cf.setChannelShouldCheckRpcResponseType(Boolean.valueOf(channelShouldCheckRpcResponseType));
        }
        String useNio = lookUp(USE_NIO, properties, prefix);
        if (useNio != null && Boolean.valueOf(useNio)) {
            cf.useNio();
            NioParams nioParams = new NioParams();
            String readByteBufferSize = lookUp(NIO_READ_BYTE_BUFFER_SIZE, properties, prefix);
            if (readByteBufferSize != null) {
                nioParams.setReadByteBufferSize(Integer.valueOf(readByteBufferSize));
            }
            String writeByteBufferSize = lookUp(NIO_WRITE_BYTE_BUFFER_SIZE, properties, prefix);
            if (writeByteBufferSize != null) {
                nioParams.setWriteByteBufferSize(Integer.valueOf(writeByteBufferSize));
            }
            String nbIoThreads = lookUp(NIO_NB_IO_THREADS, properties, prefix);
            if (nbIoThreads != null) {
                nioParams.setNbIoThreads(Integer.valueOf(nbIoThreads));
            }
            String writeEnqueuingTime = lookUp(NIO_WRITE_ENQUEUING_TIMEOUT_IN_MS, properties, prefix);
            if (writeEnqueuingTime != null) {
                nioParams.setWriteEnqueuingTimeoutInMs(Integer.valueOf(writeEnqueuingTime));
            }
            String writeQueueCapacity = lookUp(NIO_WRITE_QUEUE_CAPACITY, properties, prefix);
            if (writeQueueCapacity != null) {
                nioParams.setWriteQueueCapacity(Integer.valueOf(writeQueueCapacity));
            }
            cf.setNioParams(nioParams);
        }
        String useSsl = lookUp(SSL_ENABLED, properties, prefix);
        if (useSsl != null && Boolean.valueOf(useSsl)) {
            setUpSsl(cf, properties, prefix);
        }
    }
    private static void setUpSsl(ConnectionFactory cf, Map<String, String> properties, String prefix) {
        String algorithm = lookUp(SSL_ALGORITHM, properties, prefix);
        String keyStoreLocation = lookUp(SSL_KEY_STORE, properties, prefix);
        String keyStorePassword = lookUp(SSL_KEY_STORE_PASSWORD, properties, prefix);
        String keyStoreType = lookUp(SSL_KEY_STORE_TYPE, properties, prefix, "PKCS12");
        String keyStoreAlgorithm = lookUp(SSL_KEY_STORE_ALGORITHM, properties, prefix, "SunX509");
        String trustStoreLocation = lookUp(SSL_TRUST_STORE, properties, prefix);
        String trustStorePassword = lookUp(SSL_TRUST_STORE_PASSWORD, properties, prefix);
        String trustStoreType = lookUp(SSL_TRUST_STORE_TYPE, properties, prefix, "JKS");
        String trustStoreAlgorithm = lookUp(SSL_TRUST_STORE_ALGORITHM, properties, prefix, "SunX509");
        String validateServerCertificate = lookUp(SSL_VALIDATE_SERVER_CERTIFICATE, properties, prefix);
        String verifyHostname = lookUp(SSL_VERIFY_HOSTNAME, properties, prefix);
        try {
            algorithm = algorithm == null ?
                    ConnectionFactory.computeDefaultTlsProtocol(SSLContext.getDefault().getSupportedSSLParameters().getProtocols()) : algorithm;
            boolean enableHostnameVerification = verifyHostname == null ? Boolean.FALSE : Boolean.valueOf(verifyHostname);
            if (keyStoreLocation == null && trustStoreLocation == null) {
                setUpBasicSsl(
                        cf,
                        validateServerCertificate == null ? Boolean.FALSE : Boolean.valueOf(validateServerCertificate),
                        enableHostnameVerification,
                        algorithm
                );
            } else {
                KeyManager[] keyManagers = configureKeyManagers(keyStoreLocation, keyStorePassword, keyStoreType, keyStoreAlgorithm);
                TrustManager[] trustManagers = configureTrustManagers(trustStoreLocation, trustStorePassword, trustStoreType, trustStoreAlgorithm);
                // create ssl context
                SSLContext sslContext = SSLContext.getInstance(algorithm);
                sslContext.init(keyManagers, trustManagers, null);
                cf.useSslProtocol(sslContext);
                if (enableHostnameVerification) {
                    cf.enableHostnameVerification();
                }
            }
        } catch (NoSuchAlgorithmException | IOException | CertificateException |
                UnrecoverableKeyException | KeyStoreException | KeyManagementException e) {
            throw new IllegalStateException("Error while configuring TLS", e);
        }
    }
    private static KeyManager[] configureKeyManagers(String keystore, String keystorePassword, String keystoreType, String keystoreAlgorithm) throws KeyStoreException, IOException, NoSuchAlgorithmException,
            CertificateException, UnrecoverableKeyException {
        char[] keyPassphrase = null;
        if (keystorePassword != null) {
            keyPassphrase = keystorePassword.toCharArray();
        }
        KeyManager[] keyManagers = null;
        if (keystore != null) {
            KeyStore ks = KeyStore.getInstance(keystoreType);
            try (InputStream in = loadResource(keystore)) {
                ks.load(in, keyPassphrase);
            }
            KeyManagerFactory kmf = KeyManagerFactory.getInstance(keystoreAlgorithm);
            kmf.init(ks, keyPassphrase);
            keyManagers = kmf.getKeyManagers();
        }
        return keyManagers;
    }
    private static TrustManager[] configureTrustManagers(String truststore, String truststorePassword, String truststoreType, String truststoreAlgorithm)
            throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
        char[] trustPassphrase = null;
        if (truststorePassword != null) {
            trustPassphrase = truststorePassword.toCharArray();
        }
        TrustManager[] trustManagers = null;
        if (truststore != null) {
            KeyStore tks = KeyStore.getInstance(truststoreType);
            try (InputStream in = loadResource(truststore)) {
                tks.load(in, trustPassphrase);
            }
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(truststoreAlgorithm);
            tmf.init(tks);
            trustManagers = tmf.getTrustManagers();
        }
        return trustManagers;
    }
    private static void setUpBasicSsl(ConnectionFactory cf, boolean validateServerCertificate, boolean verifyHostname, String sslAlgorithm) throws KeyManagementException, NoSuchAlgorithmException, KeyStoreException {
        if (validateServerCertificate) {
            useDefaultTrustStore(cf, sslAlgorithm, verifyHostname);
        } else {
            if (sslAlgorithm == null) {
                cf.useSslProtocol();
            } else {
                cf.useSslProtocol(sslAlgorithm);
            }
        }
    }
    private static void useDefaultTrustStore(ConnectionFactory cf, String sslAlgorithm, boolean verifyHostname) throws NoSuchAlgorithmException, KeyStoreException, KeyManagementException {
        SSLContext sslContext = SSLContext.getInstance(sslAlgorithm);
        TrustManagerFactory trustManagerFactory =
                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init((KeyStore) null);
        sslContext.init(null, trustManagerFactory.getTrustManagers(), null);
        cf.useSslProtocol(sslContext);
        if (verifyHostname) {
            cf.enableHostnameVerification();
        }
    }
    public static void load(ConnectionFactory connectionFactory, String propertyFileLocation) throws IOException {
        load(connectionFactory, propertyFileLocation, DEFAULT_PREFIX);
    }
    @SuppressWarnings("unchecked")
    public static void load(ConnectionFactory connectionFactory, Properties properties) {
        load(connectionFactory, (Map) properties, DEFAULT_PREFIX);
    }
    @SuppressWarnings("unchecked")
    public static void load(ConnectionFactory connectionFactory, Properties properties, String prefix) {
        load(connectionFactory, (Map) properties, prefix);
    }
    public static void load(ConnectionFactory connectionFactory, Map<String, String> properties) {
        load(connectionFactory, properties, DEFAULT_PREFIX);
    }
    public static String lookUp(String key, Map<String, String> properties, String prefix) {
        return lookUp(key, properties, prefix, null);
    }
    public static String lookUp(String key, Map<String, String> properties, String prefix, String defaultValue) {
        String value = properties.get(prefix + key);
        if (value == null) {
            value = ALIASES.getOrDefault(key, Collections.emptyList()).stream()
                    .map(alias -> properties.get(prefix + alias))
                    .filter(v -> v != null)
                    .findFirst().orElse(defaultValue);
        }
        return value;
    }
}
package com.rabbitmq.client.impl.nio;
import java.nio.ByteBuffer;
/**
 * Contract to create {@link ByteBuffer}s.
 *
 * @see NioParams
 * @since 5.5.0
 */
public interface ByteBufferFactory {
    /**
     * Create the {@link ByteBuffer} that contains inbound frames.
     * This buffer is the network buffer for plain connections.
     * When using SSL/TLS, this buffer isn't directly connected to
     * the network, the encrypted read buffer is.
     *
     * @param nioContext
     * @return
     */
    ByteBuffer createReadBuffer(NioContext nioContext);
    /**
     * Create the {@link ByteBuffer} that contains outbound frames.
     * This buffer is the network buffer for plain connections.
     * When using SSL/TLS, this buffer isn't directed connected to
     * the network, the encrypted write buffer is.
     *
     * @param nioContext
     * @return
     */
    ByteBuffer createWriteBuffer(NioContext nioContext);
    /**
     * Create the network read {@link ByteBuffer}.
     * This buffer contains encrypted frames read from the network.
     * The {@link javax.net.ssl.SSLEngine} decrypts frame and pass them
     * over to the read buffer.
     *
     * @param nioContext
     * @return
     */
    ByteBuffer createEncryptedReadBuffer(NioContext nioContext);
    /**
     * Create the network write {@link ByteBuffer}.
     * This buffer contains encrypted outbound frames. These
     * frames come from the write buffer that sends them through
     * the {@link javax.net.ssl.SSLContext} for encryption to
     * this buffer.
     *
     * @param nioContext
     * @return
     */
    ByteBuffer createEncryptedWriteBuffer(NioContext nioContext);
}
package com.rabbitmq.client.impl.nio;
/**
 * Contract to exchange frame between application threads and NIO thread.
 * <p>
 * This is a simplified subset of {@link java.util.concurrent.BlockingQueue}.
 * This interface is considered a SPI and is likely to move between
 * minor and patch releases.
 *
 * @see NioParams
 * @since 5.5.0
 */
public interface NioQueue {
    /**
     * Enqueue a frame, block if the queue is full.
     *
     * @param writeRequest
     * @return
     * @throws InterruptedException
     */
    boolean offer(WriteRequest writeRequest) throws InterruptedException;
    /**
     * Get the current size of the queue.
     *
     * @return
     */
    int size();
    /**
     * Retrieves and removes the head of this queue,
     * or returns {@code null} if this queue is empty.
     *
     * @return the head of this queue, or {@code null} if this queue is empty
     */
    WriteRequest poll();
    /**
     * Returns {@code true} if the queue contains no element.
     *
     * @return {@code true} if the queue contains no element
     */
    boolean isEmpty();
}
package com.rabbitmq.client.impl.nio;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
/**
 * Bridge between {@link NioQueue} and JDK's {@link BlockingQueue}.
 *
 * @see NioQueue
 * @since 5.5.0
 */
public class BlockingQueueNioQueue implements NioQueue {
    private final BlockingQueue<WriteRequest> delegate;
    private final int writeEnqueuingTimeoutInMs;
    public BlockingQueueNioQueue(BlockingQueue<WriteRequest> delegate, int writeEnqueuingTimeoutInMs) {
        this.delegate = delegate;
        this.writeEnqueuingTimeoutInMs = writeEnqueuingTimeoutInMs;
    }
    @Override
    public boolean offer(WriteRequest writeRequest) throws InterruptedException {
        return this.delegate.offer(writeRequest, writeEnqueuingTimeoutInMs, TimeUnit.MILLISECONDS);
    }
    @Override
    public int size() {
        return this.delegate.size();
    }
    @Override
    public WriteRequest poll() {
        return this.delegate.poll();
    }
    @Override
    public boolean isEmpty() {
        return this.delegate.isEmpty();
    }
}