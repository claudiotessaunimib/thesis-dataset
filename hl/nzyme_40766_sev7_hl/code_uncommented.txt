package app.nzyme.core.rest.resources.system;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.crypto.CryptoRegistryKeys;
import app.nzyme.core.crypto.PGPKeyFingerprint;
import app.nzyme.core.crypto.tls.*;
import app.nzyme.core.distributed.MetricExternalName;
import app.nzyme.core.distributed.Node;
import app.nzyme.core.distributed.database.metrics.TimerSnapshot;
import app.nzyme.core.rest.requests.PGPConfigurationUpdateRequest;
import app.nzyme.core.rest.requests.UpdateTLSWildcardNodeMatcherRequest;
import app.nzyme.core.rest.responses.crypto.*;
import app.nzyme.plugin.distributed.messaging.ClusterMessage;
import app.nzyme.plugin.distributed.messaging.Message;
import app.nzyme.plugin.distributed.messaging.MessageType;
import app.nzyme.plugin.rest.configuration.ConfigurationEntryConstraintValidator;
import app.nzyme.plugin.rest.configuration.ConfigurationEntryResponse;
import app.nzyme.plugin.rest.configuration.ConfigurationEntryValueType;
import app.nzyme.plugin.rest.security.PermissionLevel;
import app.nzyme.plugin.rest.security.RESTSecured;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import app.nzyme.core.NzymeNode;
import app.nzyme.core.rest.responses.metrics.TimerResponse;
import com.google.common.collect.Sets;
import com.google.common.math.Stats;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.glassfish.jersey.media.multipart.FormDataParam;
import org.joda.time.DateTime;
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import java.io.InputStream;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.cert.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
@Path("/api/system/crypto")
@RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
@Produces(MediaType.APPLICATION_JSON)
public class CryptoResource {
    private static final Logger LOG = LogManager.getLogger(CryptoResource.class);
    @Inject
    private NzymeNode nzyme;
    @GET
    @Path("summary")
    public Response summary() {
        Map<String, PGPKeyResponse> fingerprints = Maps.newHashMap();
        for (PGPKeyFingerprint fp : nzyme.getCrypto().getPGPKeysByNode()) {
            fingerprints.put(fp.nodeName(), PGPKeyResponse.create(fp.nodeName(), fp.fingerprint(), fp.createdAt()));
        }
        Map<UUID, TimerSnapshot> encryption = nzyme.getClusterManager().findMetricTimer(
                MetricExternalName.PGP_ENCRYPTION_TIMER.database_label
        );
        Map<UUID, TimerSnapshot> decryption = nzyme.getClusterManager().findMetricTimer(
                MetricExternalName.PGP_DECRYPTION_TIMER.database_label
        );
        Map<String, CryptoMetricsResponse> nodeMetrics = Maps.newTreeMap();
        List<UUID> nodeIds = Lists.newArrayList();
        nodeIds.addAll(encryption.keySet());
        nodeIds.addAll(decryption.keySet());
        Set<Long> encryptionMeans = Sets.newHashSet();
        Set<Long> encryptionMaxs = Sets.newHashSet();
        Set<Long> encryptionMins = Sets.newHashSet();
        Set<Long> encryptionStddevs = Sets.newHashSet();
        Set<Long> encryptionP99s = Sets.newHashSet();
        Set<Long> encryptionCounters = Sets.newHashSet();
        Set<Long> decryptionMeans = Sets.newHashSet();
        Set<Long> decryptionMaxs = Sets.newHashSet();
        Set<Long> decryptionMins = Sets.newHashSet();
        Set<Long> decryptionStddevs = Sets.newHashSet();
        Set<Long> decryptionP99s = Sets.newHashSet();
        Set<Long> decryptionCounters = Sets.newHashSet();
        for (UUID nodeId : nodeIds) {
            TimerSnapshot nodeEncryption = encryption.get(nodeId);
            TimerSnapshot nodeDecryption = decryption.get(nodeId);
            if (nodeEncryption != null) {
                if (nodeEncryption.mean() > 0) encryptionMeans.add(nodeEncryption.mean());
                if (nodeEncryption.max() > 0) encryptionMaxs.add(nodeEncryption.max());
                if (nodeEncryption.min() > 0) encryptionMins.add(nodeEncryption.min());
                if (nodeEncryption.stddev() > 0) encryptionStddevs.add(nodeEncryption.stddev());
                if (nodeEncryption.p99() > 0) encryptionP99s.add(nodeEncryption.p99());
                if (nodeEncryption.counter() > 0) encryptionCounters.add(nodeEncryption.counter());
                if (nodeDecryption.mean() > 0) decryptionMeans.add(nodeDecryption.mean());
                if (nodeDecryption.max() > 0) decryptionMaxs.add(nodeDecryption.max());
                if (nodeDecryption.min() > 0) decryptionMins.add(nodeDecryption.min());
                if (nodeDecryption.stddev() > 0) decryptionStddevs.add(nodeDecryption.stddev());
                if (nodeDecryption.p99() > 0) decryptionP99s.add(nodeDecryption.p99());
                if (nodeDecryption.counter() > 0) decryptionCounters.add(nodeDecryption.counter());
                nodeMetrics.put(nzyme.getNodeManager().findNameOfNode(nodeId), CryptoMetricsResponse.create(
                        TimerResponse.create(
                                nodeEncryption.mean(),
                                nodeEncryption.max(),
                                nodeEncryption.min(),
                                nodeEncryption.stddev(),
                                nodeEncryption.p99(),
                                nodeEncryption.counter()
                        ),
                        TimerResponse.create(
                                nodeDecryption.mean(),
                                nodeDecryption.max(),
                                nodeDecryption.min(),
                                nodeDecryption.stddev(),
                                nodeDecryption.p99(),
                                nodeDecryption.counter()
                        )
                ));
            }
        }
        CryptoMetricsResponse clusterMetrics = CryptoMetricsResponse.create(
                TimerResponse.create(
                        encryptionMeans.isEmpty() ? 0 : Stats.meanOf(encryptionMeans),
                        encryptionMaxs.isEmpty() ? 0 : Stats.of(encryptionMaxs).max(),
                        encryptionMins.isEmpty() ? 0 :  Stats.of(encryptionMins).min(),
                        encryptionStddevs.isEmpty() ? 0 : Stats.meanOf(encryptionStddevs),
                        encryptionP99s.isEmpty() ? 0 : Stats.of(encryptionP99s).max(),
                        encryptionCounters.isEmpty() ? 0 : ((Double) Stats.of(encryptionCounters).sum()).longValue()
                ),
                TimerResponse.create(
                        decryptionMeans.isEmpty() ? 0 : Stats.meanOf(decryptionMeans),
                        decryptionMaxs.isEmpty() ? 0 : Stats.of(decryptionMaxs).max(),
                        decryptionMins.isEmpty() ? 0 : Stats.of(decryptionMins).min(),
                        decryptionStddevs.isEmpty() ? 0 : Stats.meanOf(decryptionStddevs),
                        decryptionP99s.isEmpty() ? 0 : Stats.of(decryptionP99s).max(),
                        decryptionCounters.isEmpty() ? 0 : ((Double) Stats.of(decryptionCounters).sum()).longValue()
                )
        );
        CryptoNodeMetricsResponse metrics = CryptoNodeMetricsResponse.create(nodeMetrics, clusterMetrics);
        Map<String, TLSCertificateResponse> tlsCertificates = Maps.newTreeMap();
        for (TLSKeyAndCertificate cert : nzyme.getCrypto().getTLSCertificateByNode()) {
            Optional<Node> node = nzyme.getNodeManager().getNode(cert.nodeId());
            if (node.isPresent() && node.get().lastSeen().isAfter(DateTime.now().minusMinutes(2))) {
                String nodeName = nzyme.getNodeManager().findNameOfNode(cert.nodeId());
                Map<UUID, TLSKeyAndCertificate> matchingNodes = nzyme.getCrypto().getTLSWildcardCertificatesForMatchingNodes();
                TLSKeyAndCertificate wildcardTls = matchingNodes.get(node.get().uuid());
                if (wildcardTls != null) {
                    X509Certificate firstCert = cert.certificates().get(0);
                    Collection<List<?>> issuerAlternativeNames;
                    Collection<List<?>> subjectAlternativeNames;
                    try {
                        issuerAlternativeNames = firstCert.getIssuerAlternativeNames();
                        subjectAlternativeNames = firstCert.getSubjectAlternativeNames();
                    } catch (CertificateParsingException e) {
                        LOG.error("Could not parse certificate.", e);
                        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
                    }
                    tlsCertificates.put(
                            nodeName,
                            TLSCertificateResponse.create(
                                    wildcardTls.nodeId().toString(),
                                    wildcardTls.sourceType().toString(),
                                    nodeName,
                                    wildcardTls.signature(),
                                    firstCert.getSigAlgName(),
                                    buildPrincipalResponse(firstCert.getIssuerX500Principal(), issuerAlternativeNames),
                                    buildPrincipalResponse(firstCert.getSubjectX500Principal(), subjectAlternativeNames),
                                    wildcardTls.validFrom(),
                                    wildcardTls.expiresAt()
                            )
                    );
                } else {
                    X509Certificate firstCert = cert.certificates().get(0);
                    Collection<List<?>> issuerAlternativeNames;
                    Collection<List<?>> subjectAlternativeNames;
                    try {
                        issuerAlternativeNames = firstCert.getIssuerAlternativeNames();
                        subjectAlternativeNames = firstCert.getSubjectAlternativeNames();
                    } catch (CertificateParsingException e) {
                        LOG.error("Could not parse certificate.", e);
                        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
                    }
                    tlsCertificates.put(
                            nodeName,
                            TLSCertificateResponse.create(
                                    cert.nodeId().toString(),
                                    cert.sourceType().toString(),
                                    nodeName,
                                    cert.signature(),
                                    firstCert.getSigAlgName(),
                                    buildPrincipalResponse(firstCert.getIssuerX500Principal(), issuerAlternativeNames),
                                    buildPrincipalResponse(firstCert.getSubjectX500Principal(), subjectAlternativeNames),
                                    cert.validFrom(),
                                    cert.expiresAt()
                            )
                    );
                }
            }
        }
        List<TLSWildcartCertificateResponse> tlsWildcartCertificates = Lists.newArrayList();
        for (TLSWildcardKeyAndCertificate entry : nzyme.getCrypto().getTLSWildcardCertificates()) {
            X509Certificate firstCert = entry.certificates().get(0);
            Collection<List<?>> issuerAlternativeNames;
            Collection<List<?>> subjectAlternativeNames;
            try {
                issuerAlternativeNames = firstCert.getIssuerAlternativeNames();
                subjectAlternativeNames = firstCert.getSubjectAlternativeNames();
            } catch (CertificateParsingException e) {
                LOG.error("Could not parse certificate.", e);
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
            }
            tlsWildcartCertificates.add(TLSWildcartCertificateResponse.create(
                    entry.id(),
                    entry.nodeMatcher(),
                    buildMatchingNodes(entry.nodeMatcher()),
                    entry.sourceType().toString(),
                    entry.signature(),
                    firstCert.getSigAlgName(),
                    buildPrincipalResponse(firstCert.getIssuerX500Principal(), issuerAlternativeNames),
                    buildPrincipalResponse(firstCert.getSubjectX500Principal(), subjectAlternativeNames),
                    entry.validFrom(),
                    entry.expiresAt()
            ));
        }
        PGPConfigurationResponse pgpConfiguration = PGPConfigurationResponse.create(ConfigurationEntryResponse.create(
                CryptoRegistryKeys.PGP_KEY_SYNC_ENABLED.key(),
                "PGP Key Sync Enabled",
                nzyme.getCrypto().isPGPKeySyncEnabled(),
                ConfigurationEntryValueType.BOOLEAN,
                CryptoRegistryKeys.PGP_KEY_SYNC_ENABLED.defaultValue().get(),
                CryptoRegistryKeys.PGP_KEY_SYNC_ENABLED.requiresRestart(),
                CryptoRegistryKeys.PGP_KEY_SYNC_ENABLED.constraints().get(),
                "pgp-key-sync"
        ));
        return Response.ok(CryptoResponse.create(
                metrics,
                fingerprints,
                tlsCertificates,
                tlsWildcartCertificates,
                nzyme.getCrypto().allPGPKeysEqualAcrossCluster(),
                pgpConfiguration
        )).build();
    }
    @GET
    @Path("/tls/node/{node_id}")
    public Response tlsCertificate(@PathParam("node_id") UUID nodeId) {
        Optional<Node> node = nzyme.getNodeManager().getNode(nodeId);
        if (node.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TLSKeyAndCertificate> tls = nzyme.getCrypto().getTLSCertificateOfNode(nodeId);
        if (tls.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TLSKeyAndCertificate cert = tls.get();
        X509Certificate firstCert = cert.certificates().get(0);
        Collection<List<?>> issuerAlternativeNames;
        Collection<List<?>> subjectAlternativeNames;
        try {
            issuerAlternativeNames = firstCert.getIssuerAlternativeNames();
            subjectAlternativeNames = firstCert.getSubjectAlternativeNames();
        } catch (CertificateParsingException e) {
            LOG.error("Could not parse certificate.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(TLSCertificateResponse.create(
                cert.nodeId().toString(),
                cert.sourceType().toString(),
                node.get().name(),
                cert.signature(),
                firstCert.getSigAlgName(),
                buildPrincipalResponse(firstCert.getIssuerX500Principal(), issuerAlternativeNames),
                buildPrincipalResponse(firstCert.getSubjectX500Principal(), subjectAlternativeNames),
                cert.validFrom(),
                cert.expiresAt()
        )).build();
    }
    @GET
    @Path("/tls/wildcard/{cert_id}")
    public Response tlsWildcardCertificate(@PathParam("cert_id") long certificateId) {
        Optional<TLSWildcardKeyAndCertificate> certResult = nzyme.getCrypto().getTLSWildcardCertificate(certificateId);
        if (certResult.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TLSWildcardKeyAndCertificate cert = certResult.get();
        X509Certificate firstCert = cert.certificates().get(0);
        Collection<List<?>> issuerAlternativeNames;
        Collection<List<?>> subjectAlternativeNames;
        try {
            issuerAlternativeNames = firstCert.getIssuerAlternativeNames();
            subjectAlternativeNames = firstCert.getSubjectAlternativeNames();
        } catch (CertificateParsingException e) {
            LOG.error("Could not parse certificate.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        return Response.ok(TLSWildcartCertificateResponse.create(
                cert.id(),
                cert.nodeMatcher(),
                buildMatchingNodes(cert.nodeMatcher()),
                cert.sourceType().toString(),
                cert.signature(),
                firstCert.getSigAlgName(),
                buildPrincipalResponse(firstCert.getIssuerX500Principal(), issuerAlternativeNames),
                buildPrincipalResponse(firstCert.getSubjectX500Principal(), subjectAlternativeNames),
                cert.validFrom(),
                cert.expiresAt()
        )).build();
    }
    @PUT
    @Path("/tls/node/{node_id}/regenerate")
    public Response regenerateTLSCertificate(@PathParam("node_id") UUID nodeId) {
        if (nzyme.getNodeManager().getNode(nodeId).isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        final Crypto crypto = nzyme.getCrypto();
        try {
            crypto.updateTLSCertificateOfNode(
                    nodeId,
                    crypto.generateTLSCertificate(Crypto.DEFAULT_TLS_SUBJECT_DN, 12)
            );
        } catch (Crypto.CryptoOperationException e) {
            LOG.error("Could not generate TLS certificate.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        requestHttpServerRestart(nodeId);
        return Response.ok().build();
    }
    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Path("/tls/test")
    public Response testNodeTLSCertificate(@FormDataParam("certificate") InputStream certificate,
                                           @FormDataParam("private_key") InputStream privateKey) {
        String certificateInput, keyInput;
        try {
            certificateInput = new String(certificate.readAllBytes());
            keyInput = new String(privateKey.readAllBytes());
        } catch (Exception e) {
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        boolean certSuccess;
        List<X509Certificate> certificates = Lists.newArrayList();
        try {
            certificates.addAll(TLSUtils.readCertificateChainFromPEM(certificateInput));
            certSuccess = true;
        } catch(Exception e) {
            certSuccess = false;
            LOG.error("Testing TLS private key failed.", e);
        }
        boolean privateKeySuccess;
        PrivateKey key = null;
        try {
            key = TLSUtils.readKeyFromPEM(keyInput);
            privateKeySuccess = true;
        } catch(Exception e) {
            privateKeySuccess = false;
            LOG.error("Testing TLS private key failed.", e);
        }
        if (certSuccess && privateKeySuccess) {
            X509Certificate firstCert = certificates.get(0);
            String fingerprint;
            Collection<List<?>> issuerAlternativeNames;
            Collection<List<?>> subjectAlternativeNames;
            try {
                fingerprint = TLSUtils.calculateTLSCertificateFingerprint(firstCert);
                issuerAlternativeNames = firstCert.getIssuerAlternativeNames();
                subjectAlternativeNames = firstCert.getSubjectAlternativeNames();
            } catch (NoSuchAlgorithmException | CertificateEncodingException | CertificateParsingException e) {
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
            }
            TLSKeyAndCertificate tls = TLSKeyAndCertificate.create(
                    UUID.randomUUID(), 
                    TLSSourceType.TEST,
                    certificates,
                    key,
                    fingerprint,
                    new DateTime(firstCert.getNotBefore()),
                    new DateTime(firstCert.getNotAfter())
            );
            return Response.ok(TLSCertificateTestResponse.create(
                    true,
                    true,
                    TLSCertificateResponse.create(
                            "[test]",
                            tls.sourceType().toString(),
                            "[test]",
                            tls.signature(),
                            firstCert.getSigAlgName(),
                            buildPrincipalResponse(firstCert.getIssuerX500Principal(), issuerAlternativeNames),
                            buildPrincipalResponse(firstCert.getSubjectX500Principal(), subjectAlternativeNames),
                            tls.validFrom(),
                            tls.expiresAt()
                    )
            )).build();
        } else {
            return Response.status(Response.Status.UNAUTHORIZED)
                    .entity(TLSCertificateTestResponse.create(
                            certSuccess, privateKeySuccess, null
                    )).build();
        }
    }
    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Path("/tls/node/{node_id}")
    public Response uploadNodeTLSCertificate(@PathParam("node_id") UUID nodeId,
                                             @FormDataParam("certificate") InputStream certificate,
                                             @FormDataParam("private_key") InputStream privateKey) {
        if (nzyme.getNodeManager().getNode(nodeId).isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TLSKeyAndCertificate tls;
        try {
            tls = TLSUtils.readTLSKeyAndCertificateFromInputStreams(nodeId, TLSSourceType.INDIVIDUAL, certificate, privateKey);
        } catch (TLSUtils.TLSCertificateCreationException e) {
            LOG.error("Could not create TLS certificate.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        nzyme.getCrypto().updateTLSCertificateOfNode(nodeId, tls);
        requestHttpServerRestart(nodeId);
        return Response.ok(Response.Status.CREATED).build();
    }
    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Path("/tls/wildcard")
    public Response uploadWildcardTLSCertificate(@FormDataParam("node_matcher") String nodeMatcher,
                                                 @FormDataParam("certificate") InputStream certificate,
                                                 @FormDataParam("private_key") InputStream privateKey) {
        if (nodeMatcher == null || nodeMatcher.trim().isEmpty()) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        TLSWildcardKeyAndCertificate tls;
        try {
            tls = TLSUtils.readTLSWildcardKeyAndCertificateFromInputStreams(nodeMatcher, TLSSourceType.WILDCARD, certificate, privateKey);
        } catch (TLSUtils.TLSCertificateCreationException e) {
            LOG.error("Could not create TLS certificate.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        nzyme.getCrypto().writeTLSWildcardCertificate(tls);
        requestHttpServerRestartAcrossCluster();
        return Response.ok(Response.Status.CREATED).build();
    }
    @POST
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    @Path("/tls/wildcard/{cert_id}/replace")
    public Response replaceWildcardTLSCertificate(@PathParam("cert_id") long certificateId,
                                                  @FormDataParam("certificate") InputStream certificate,
                                                  @FormDataParam("private_key") InputStream privateKey) {
        Optional<TLSWildcardKeyAndCertificate> certResult = nzyme.getCrypto().getTLSWildcardCertificate(certificateId);
        if (certResult.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TLSWildcardKeyAndCertificate oldCert = certResult.get();
        TLSWildcardKeyAndCertificate newCert;
        try {
            newCert = TLSUtils.readTLSWildcardKeyAndCertificateFromInputStreams(oldCert.nodeMatcher(), TLSSourceType.WILDCARD, certificate, privateKey);
        } catch (TLSUtils.TLSCertificateCreationException e) {
            LOG.error("Could not create TLS certificate.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        nzyme.getCrypto().replaceTLSWildcardCertificate(certificateId, newCert);
        requestHttpServerRestartAcrossCluster();
        return Response.ok(Response.Status.CREATED).build();
    }
    @GET
    @Path("/tls/wildcard/nodematchertest")
    public Response testTLSWildcardNodeMatcher(@QueryParam("regex") String regex) {
        return Response.ok(buildMatchingNodes(regex)).build();
    }
    @PUT
    @Path("/tls/wildcard/{cert_id}/node_matcher")
    public Response updateTLSWildcardCertificateNodeMatcher(@PathParam("cert_id") long certificateId,
                                                            UpdateTLSWildcardNodeMatcherRequest request) {
        Optional<TLSWildcardKeyAndCertificate> certResult = nzyme.getCrypto().getTLSWildcardCertificate(certificateId);
        if (certResult.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (request.nodeMatcher().trim().isEmpty()) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        nzyme.getCrypto().updateTLSWildcardCertificateNodeMatcher(certificateId, request.nodeMatcher());
        requestHttpServerRestartAcrossCluster();
        return Response.ok().build();
    }
    @DELETE
    @Path("/tls/wildcard/{cert_id}")
    public Response deleteTLSWildcardCertificate(@PathParam("cert_id") long certificateId) {
        nzyme.getCrypto().deleteTLSWildcardCertificate(certificateId);
        requestHttpServerRestartAcrossCluster();
        return Response.ok().build();
    }
    @PUT
    @Path("/pgp/configuration")
    public Response update(PGPConfigurationUpdateRequest ur) {
        if (ur.change().isEmpty()) {
            LOG.info("Empty configuration parameters.");
            return Response.status(422).build();
        }
        for (Map.Entry<String, Object> c : ur.change().entrySet()) {
            switch (c.getKey()) {
                case "pgp_key_sync_enabled":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(CryptoRegistryKeys.PGP_KEY_SYNC_ENABLED, c)) {
                        return Response.status(422).build();
                    }
                    nzyme.getDatabaseCoreRegistry().setValue(c.getKey(), c.getValue().toString());
                    break;
                default:
                    LOG.info("Unknown configuration parameter [{}].", c.getKey());
                    return Response.status(422).build();
            }
        }
        return Response.ok().build();
    }
    private TLSCertificatePrincipalResponse buildPrincipalResponse(Principal principal, Collection<List<?>> alternativeNames) {
        List<String> an = Lists.newArrayList();
        if (alternativeNames != null) {
            for (List<?> alternativeName : alternativeNames) {
                an.add((String) alternativeName.get(1));
            }
        }
        String cn;
        Matcher cnMatcher = Pattern.compile("CN=(.+?)(,|$)").matcher(principal.toString());
        if (cnMatcher.find()) {
            cn = cnMatcher.group(1);
        } else {
            cn = null;
        }
        String o;
        Matcher oMatcher = Pattern.compile("O=(.+?)(,|$)").matcher(principal.toString());
        if (oMatcher.find()) {
            o = oMatcher.group(1);
        } else {
            o = null;
        }
        String c;
        Matcher cMatcher = Pattern.compile("C=(.+?)(,|$)").matcher(principal.toString());
        if (cMatcher.find()) {
            c = cMatcher.group(1);
        } else {
            c = null;
        }
        return TLSCertificatePrincipalResponse.create(an, cn, o, c);
    }
    private List<MatchingNodeResponse> buildMatchingNodes(String regex) {
        TLSWildcardNodeMatcher matcher = new TLSWildcardNodeMatcher();
        List<MatchingNodeResponse> matchingNodes = Lists.newArrayList();
        for (Node node : matcher.match(regex, nzyme.getNodeManager().getNodes())) {
            matchingNodes.add(MatchingNodeResponse.create(node.uuid(), node.name()));
        }
        return matchingNodes;
    }
    private void requestHttpServerRestart(UUID nodeId) {
        nzyme.getMessageBus().send(Message.create(
                nodeId,
                MessageType.CHECK_RESTART_HTTP_SERVER,
                Collections.emptyMap(),
                true
        ));
    }
    private void requestHttpServerRestartAcrossCluster() {
        nzyme.getMessageBus().sendToAllOnlineNodes(ClusterMessage.create(
                MessageType.CHECK_RESTART_HTTP_SERVER,
                Collections.emptyMap(),
                true
        ));
    }
}
package app.nzyme.core.crypto;
import app.nzyme.core.crypto.database.TLSKeyAndCertificateEntry;
import app.nzyme.core.crypto.pgp.PGPKeyMessageBusReceiver;
import app.nzyme.core.crypto.pgp.PGPKeyProviderTaskHandler;
import app.nzyme.core.crypto.pgp.PGPKeys;
import app.nzyme.core.crypto.tls.*;
import app.nzyme.core.crypto.database.TLSWildcardKeyAndCertificateEntry;
import app.nzyme.core.distributed.Node;
import app.nzyme.plugin.Database;
import app.nzyme.plugin.distributed.messaging.MessageType;
import app.nzyme.plugin.distributed.tasksqueue.Task;
import app.nzyme.plugin.distributed.tasksqueue.TaskType;
import com.codahale.metrics.Timer;
import app.nzyme.core.NzymeNode;
import app.nzyme.core.util.MetricNames;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.io.BaseEncoding;
import com.google.common.io.Files;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.BasicConstraints;
import org.bouncycastle.bcpg.HashAlgorithmTags;
import org.bouncycastle.cert.CertIOException;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.jcajce.JcaPGPObjectFactory;
import org.bouncycastle.openpgp.operator.PGPDigestCalculator;
import org.bouncycastle.openpgp.operator.jcajce.*;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.util.io.Streams;
import org.joda.time.DateTime;
import java.io.*;
import java.math.BigInteger;
import java.nio.file.Paths;
import java.security.*;
import java.security.cert.*;
import java.security.cert.Certificate;
import java.security.spec.InvalidKeySpecException;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class Crypto {
    private static final Logger LOG = LogManager.getLogger(Crypto.class);
    private enum KeyType {
        PGP
    }
    public static final String DEFAULT_TLS_SUBJECT_DN = "CN=nzyme";
    public static final String PGP_PRIVATE_KEY_FILE_NAME = "pgp_private.pgp";
    public static final String PGP_PUBLIC_KEY_FILE_NAME = "pgp_public.pgp";
    public static final String TLS_CERTIFICATE_FILE_NAME = "tls.cert";
    public static final String TLS_KEY_FILE_NAME = "tls.key";
    private final File cryptoDirectoryConfig;
    private final Database database;
    private final String nodeName;
    private final UUID nodeId;
    private final Timer encryptionTimer;
    private final Timer decryptionTimer;
    private final NzymeNode nzyme;
    private final BouncyCastleProvider bcProvider;
    private PGPKeys nodeLocalPGPKeys = null;
    public Crypto(NzymeNode nzyme) {
        this.nzyme = nzyme;
        this.cryptoDirectoryConfig = new File(nzyme.getConfiguration().cryptoDirectory());
        this.database = nzyme.getDatabase();
        this.nodeName = nzyme.getNodeInformation().name();
        this.nodeId = nzyme.getNodeInformation().id();
        this.encryptionTimer = nzyme.getMetrics().timer(MetricNames.PGP_ENCRYPTION_TIMING);
        this.decryptionTimer = nzyme.getMetrics().timer(MetricNames.PGP_DECRYPTION_TIMING);
        this.bcProvider = new BouncyCastleProvider();
        Security.addProvider(this.bcProvider);
    }
    public void initialize() throws CryptoInitializationException {
        this.initialize(true);
    }
    public void initialize(boolean withRetentionCleaning) throws CryptoInitializationException {
        File privateKeyLocation = Paths.get(cryptoDirectoryConfig.toString(), PGP_PRIVATE_KEY_FILE_NAME).toFile();
        File publicKeyLocation = Paths.get(cryptoDirectoryConfig.toString(), PGP_PUBLIC_KEY_FILE_NAME).toFile();
        try {
            nodeLocalPGPKeys = generatePGPKeys();
            nzyme.getNodeManager().setLocalPGPPublicKey(nodeLocalPGPKeys);
        } catch (PGPException | NoSuchProviderException | NoSuchAlgorithmException | IOException e) {
            throw new CryptoInitializationException("Could not generate node-local PGP key.", e);
        }
        if (!privateKeyLocation.exists() || !publicKeyLocation.exists()) {
            if (nzyme.getClusterManager().joinedExistingCluster()) {
                if (!isPGPKeySyncEnabled()) {
                    throw new CryptoInitializationException("Joining existing cluster but no PGP keys found and PGP key " +
                            "sync was disabled. Please transfer keys manually.");
                }
                LOG.info("PGP private or public key missing but not a new cluster. Requesting keys from other nodes...");
                nzyme.getMessageBus().onMessageReceived(
                        MessageType.CLUSTER_PGP_KEYS_PROVIDED,
                        new PGPKeyMessageBusReceiver(cryptoDirectoryConfig, this)
                );
                nzyme.getTasksQueue().publish(Task.create(
                        TaskType.PROVIDE_PGP_KEYS,
                        false,
                        Collections.emptyMap(),
                        true
                ));
                LOG.info("Keys requested.");
                while (true) {
                    if (privateKeyLocation.exists() && publicKeyLocation.exists()) {
                        LOG.info("PGP keys received. Continuing crypto initialization.");
                        break;
                    }
                    LOG.info("Waiting for keys...");
                    try {
                        Thread.sleep(5000);
                    } catch (InterruptedException ignored) {}
                }
            } else {
                LOG.warn("PGP private or public key missing and automatic fetching disabled. Re-generating pair. This will " +
                        "make existing encrypted registry values unreadable. Please consult the nzyme documentation.");
                try {
                    PGPKeys keys = generatePGPKeys();
                    Files.write(keys.privateKey(), privateKeyLocation);
                    Files.write(keys.publicKey(), publicKeyLocation);
                } catch (NoSuchAlgorithmException | NoSuchProviderException | PGPException e) {
                    throw new CryptoInitializationException("Unexpected crypto provider exception when trying " +
                            "to create key.", e);
                } catch (IOException e) {
                    throw new CryptoInitializationException("Could not write key file.", e);
                }
            }
        }
        String keySignature;
        DateTime keyDate;
        try {
            PGPPublicKey pk = readPublicKey(publicKeyLocation);
            keySignature = String.format("%016X", pk.getKeyID());
            keyDate = new DateTime(pk.getCreationTime());
        } catch (IOException e) {
            throw new CryptoInitializationException("Could not read key file.", e);
        } catch (PGPException e) {
            throw new CryptoInitializationException("Unexpected crypto provider exception when trying " +
                    "to read existing key.", e);
        }
        List<String> signatures = database.withHandle(handle ->
                handle.createQuery("SELECT key_signature FROM crypto_keys " +
                        "WHERE node_id = :node_id AND key_type = :key_type")
                        .bind("node_id", nodeId)
                        .bind("key_type", KeyType.PGP)
                        .mapTo(String.class)
                        .list()
        );
        if (signatures.size() == 1) {
            if (!signatures.contains(keySignature)) {
                database.useHandle(handle ->
                        handle.createUpdate("UPDATE crypto_keys SET key_signature = :key_signature, " +
                                        "created_at = :created_at WHERE key_type = :key_type AND node_id = :node_id")
                                .bind("node_id", nodeId)
                                .bind("key_type", KeyType.PGP)
                                .bind("key_signature", keySignature)
                                .bind("created_at", keyDate)
                                .execute()
                );
            }
        } else if(signatures.size() == 0) {
            database.useHandle(handle ->
                    handle.createUpdate("INSERT INTO crypto_keys(node_id, node_name, key_type, key_signature, created_at) " +
                                    "VALUES(:node_id, :node_name, :key_type, :key_signature, :created_at)")
                            .bind("node_id", nodeId)
                            .bind("node_name", nodeName)
                            .bind("key_type", KeyType.PGP)
                            .bind("key_signature", keySignature)
                            .bind("created_at", keyDate)
                            .execute()
            );
        } else {
            throw new CryptoInitializationException("Unexpected number of PGP keys for this node in database. Cannot continue.");
        }
        nzyme.getTasksQueue().onMessageReceived(TaskType.PROVIDE_PGP_KEYS,
                new PGPKeyProviderTaskHandler(
                        cryptoDirectoryConfig,
                        nzyme.getMessageBus(),
                        nzyme.getNodeManager(),
                        nzyme.getCrypto()
                )
        );
        if (findTLSKeyAndCertificateOfNode(nodeId).isEmpty()) {
            try {
                LOG.info("No TLS certificate found. Generating self-signed certificate.");
                TLSKeyAndCertificate tls = generateTLSCertificate(DEFAULT_TLS_SUBJECT_DN, 12);
                setTLSKeyAndCertificateOfNode(nodeId, tls);
            } catch (CryptoOperationException e) {
                throw new CryptoInitializationException("Could not generate TLS certificate.", e);
            }
        }
        if (withRetentionCleaning) {
            Executors.newSingleThreadScheduledExecutor(
                    new ThreadFactoryBuilder()
                            .setNameFormat("crypto-retentionclean-%d")
                            .setDaemon(true)
                            .build()
            ).scheduleAtFixedRate(this::retentionCleanKeys, 0, 1, TimeUnit.MINUTES);
        }
    }
    private PGPKeys generatePGPKeys() throws PGPException, IOException, NoSuchAlgorithmException, NoSuchProviderException {
        try (ByteArrayOutputStream privateOut = new ByteArrayOutputStream();
             ByteArrayOutputStream publicOut = new ByteArrayOutputStream()) {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
            keyPairGenerator.initialize(4096);
            KeyPair pair = keyPairGenerator.generateKeyPair();
            PGPDigestCalculator shaCalc = new JcaPGPDigestCalculatorProviderBuilder()
                    .build()
                    .get(HashAlgorithmTags.SHA1);
            PGPKeyPair keyPair = new JcaPGPKeyPair(PGPPublicKey.RSA_GENERAL, pair, new Date());
            PGPSecretKey privateKey = new PGPSecretKey(
                    PGPSignature.DEFAULT_CERTIFICATION,
                    keyPair,
                    "nzyme-pgp",
                    shaCalc,
                    null,
                    null,
                    new JcaPGPContentSignerBuilder(
                            keyPair.getPublicKey().getAlgorithm(),
                            HashAlgorithmTags.SHA256),
                    new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.AES_256, shaCalc)
                            .setProvider("BC")
                            .build("nzyme".toCharArray())
            );
            privateKey.encode(privateOut);
            PGPPublicKey key = privateKey.getPublicKey();
            key.encode(publicOut);
            return PGPKeys.create(
                    privateOut.toByteArray(),
                    publicOut.toByteArray()
            );
        }
    }
    public TLSKeyAndCertificate generateTLSCertificate(String subjectDN, int validityMonths) throws CryptoOperationException {
        SecureRandom random = new SecureRandom();
        DateTime now = new DateTime();
        Date startDate = now.toDate();
        Date endDate = now.plusMonths(validityMonths).toDate();
        KeyPair keyPair;
        try {
            KeyPairGenerator keypairGen = KeyPairGenerator.getInstance("RSA", "BC");
            keypairGen.initialize(2048, random);
            keyPair = keypairGen.generateKeyPair();
        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
            throw new CryptoOperationException("Could not initialize key pair generator.", e);
        }
        X500Name dnName = new X500Name(subjectDN);
        BigInteger certSerialNumber = new BigInteger(Long.toString(now.getMillis()));
        String signatureAlgorithm = "SHA256WithRSA";
        ContentSigner contentSigner;
        try {
            contentSigner = new JcaContentSignerBuilder(signatureAlgorithm).build(keyPair.getPrivate());
        } catch (OperatorCreationException e) {
            throw new CryptoOperationException("Could not initialize content signer.", e);
        }
        JcaX509v3CertificateBuilder certBuilder = new JcaX509v3CertificateBuilder(
                dnName,
                certSerialNumber,
                startDate,
                endDate,
                dnName,
                keyPair.getPublic()
        );
        try {
            certBuilder.addExtension(new ASN1ObjectIdentifier("2.5.29.19"), true, new BasicConstraints(true));
        } catch (CertIOException e) {
            throw new CryptoOperationException("Could not add extension.", e);
        }
        try {
            X509Certificate certificate = new JcaX509CertificateConverter().setProvider(this.bcProvider)
                    .getCertificate(certBuilder.build(contentSigner));
            ArrayList<X509Certificate> certificates = Lists.newArrayList();
            certificates.add(certificate);
            return TLSKeyAndCertificate.create(
                    nzyme.getNodeManager().getLocalNodeId(),
                    TLSSourceType.GENERATED_SELF_SIGNED,
                    certificates,
                    keyPair.getPrivate(),
                    TLSUtils.calculateTLSCertificateFingerprint(certificate),
                    new DateTime(certificate.getNotBefore()),
                    new DateTime(certificate.getNotAfter())
            );
        } catch (CertificateException | NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
    public byte[] encryptWithClusterKey(byte[] value) throws CryptoOperationException {
        File publicKeyLocation = Paths.get(cryptoDirectoryConfig.toString(), PGP_PUBLIC_KEY_FILE_NAME).toFile();
        try {
            return encrypt(value, readPublicKey(publicKeyLocation));
        } catch (IOException | PGPException e) {
            throw new CryptoOperationException("Cannot encrypt value.", e);
        }
    }
    public byte[] encrypt(byte[] value, PGPPublicKey publicKey) throws CryptoOperationException {
        try(ByteArrayOutputStream out = new ByteArrayOutputStream(); ByteArrayOutputStream literalData = new ByteArrayOutputStream();){
            Timer.Context timer = encryptionTimer.time();
            PGPLiteralDataGenerator literalDataGenerator = new PGPLiteralDataGenerator();
            OutputStream literalOut = literalDataGenerator.open(literalData, PGPLiteralData.BINARY, "nzymepgp", value.length, DateTime.now().toDate());
            literalOut.write(value);
            byte[] bytes = literalData.toByteArray();
            literalDataGenerator.close();
            PGPEncryptedDataGenerator encGen = new PGPEncryptedDataGenerator(
                    new JcePGPDataEncryptorBuilder(PGPEncryptedData.AES_256)
                            .setWithIntegrityPacket(true)
                            .setSecureRandom(new SecureRandom())
                            .setProvider("BC")
            );
            encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(publicKey).setProvider("BC"));
            OutputStream enc = encGen.open(out, bytes.length);
            enc.write(bytes);
            enc.close();
            timer.stop();
            return out.toByteArray();
        } catch (PGPException | IOException e) {
            throw new CryptoOperationException("Cannot encrypt value.", e);
        }
    }
    public byte[] decryptWithClusterKey(byte[] value) throws CryptoOperationException {
        File privateKeyLocation = Paths.get(cryptoDirectoryConfig.toString(), PGP_PRIVATE_KEY_FILE_NAME).toFile();
        try(InputStream keyIn = new FileInputStream(privateKeyLocation)) {
            return decrypt(value, keyIn);
        } catch (CryptoOperationException | IOException e) {
            throw new CryptoOperationException("Cannot decrypt value.", e);
        }
    }
    public byte[] decrypt(byte[] value, InputStream keyInput) throws CryptoOperationException {
        try(InputStream dataIn = PGPUtil.getDecoderStream(new ByteArrayInputStream(value))) {
            Timer.Context timer = decryptionTimer.time();
            JcaPGPObjectFactory pgpF = new JcaPGPObjectFactory(dataIn);
            PGPEncryptedDataList enc;
            Object o = pgpF.nextObject();
            if (o instanceof PGPEncryptedDataList) {
                enc = (PGPEncryptedDataList) o;
            } else {
                enc = (PGPEncryptedDataList) pgpF.nextObject();
            }
            Iterator<PGPEncryptedData> it = enc.getEncryptedDataObjects();
            PGPPrivateKey sKey = null;
            PGPPublicKeyEncryptedData pbe = null;
            PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(
                    PGPUtil.getDecoderStream(keyInput), new JcaKeyFingerprintCalculator()
            );
            while (sKey == null && it.hasNext()) {
                pbe = (PGPPublicKeyEncryptedData) it.next();
                sKey = findSecretKey(pgpSec, pbe.getKeyID());
            }
            if (sKey == null) {
                throw new IllegalArgumentException("Secret key for message not found.");
            }
            InputStream clear = pbe.getDataStream(
                    new JcePublicKeyDataDecryptorFactoryBuilder()
                            .setProvider("BC")
                            .build(sKey)
            );
            JcaPGPObjectFactory plainFact = new JcaPGPObjectFactory(clear);
            Object message = plainFact.nextObject();
            clear.close();
            if (message instanceof PGPCompressedData) {
                PGPCompressedData cData = (PGPCompressedData) message;
                JcaPGPObjectFactory pgpFact = new JcaPGPObjectFactory(cData.getDataStream());
                message = pgpFact.nextObject();
            }
            ByteArrayOutputStream data = new ByteArrayOutputStream();
            if (message instanceof PGPLiteralData) {
                PGPLiteralData ld = (PGPLiteralData) message;
                InputStream unc = ld.getInputStream();
                Streams.pipeAll(unc, data, 8192);
                unc.close();
            } else {
                throw new PGPException("Data type unknown: " + message.getClass().getCanonicalName());
            }
            if (pbe.isIntegrityProtected() && !pbe.verify()) {
                throw new CryptoOperationException("PGP data integrity check failed.");
            }
            data.close();
            timer.stop();
            return data.toByteArray();
        } catch(IOException | PGPException | IllegalArgumentException e) {
            throw new CryptoOperationException("Cannot decrypt value.", e);
        }
    }
    public List<PGPKeyFingerprint> getPGPKeysByNode() {
        return database.withHandle(handle ->
                handle.createQuery("SELECT node_name, node_id, key_signature, created_at " +
                        "FROM crypto_keys WHERE key_type = :key_type ORDER BY node_name")
                        .bind("key_type", KeyType.PGP)
                        .mapTo(PGPKeyFingerprint.class)
                        .list()
        );
    }
    public String getLocalPGPKeyFingerprint() {
        return database.withHandle(handle ->
                handle.createQuery("SELECT key_signature FROM crypto_keys " +
                                "WHERE key_type = :key_type AND node_id = :node_id")
                        .bind("key_type", KeyType.PGP)
                        .bind("node_id", nodeId)
                        .mapTo(String.class)
                        .one()
        );
    }
    public boolean allPGPKeysEqualAcrossCluster() {
        Set<String> uniqueFingerprints = Sets.newHashSet();
        for (PGPKeyFingerprint fp : getPGPKeysByNode()) {
            uniqueFingerprints.add(fp.fingerprint());
        }
        return uniqueFingerprints.size() == 1;
    }
    public List<TLSKeyAndCertificate> getTLSCertificateByNode() {
        List<TLSKeyAndCertificateEntry> entries = database.withHandle(handle ->
                handle.createQuery("SELECT node_id, certificate, source_type, key, valid_from, expires_at " +
                                "FROM crypto_tls_certificates ORDER BY node_id DESC")
                        .mapTo(TLSKeyAndCertificateEntry.class)
                        .list()
        );
        List<TLSKeyAndCertificate> result = Lists.newArrayList();
        for (TLSKeyAndCertificateEntry entry : entries) {
            try {
                result.add(tlsKeyAndCertificateEntryToObject(entry));
            } catch (CertificateException | NoSuchAlgorithmException | InvalidKeySpecException | TLSUtils.PEMParserException e) {
                LOG.error("Could not build TLS certificate from database. Skipping.", e);
            }
        }
        return result;
    }
    public Optional<TLSKeyAndCertificate> getTLSCertificateOfNode(UUID nodeId) {
        Optional<TLSKeyAndCertificateEntry> entry = database.withHandle(handle ->
                handle.createQuery("SELECT node_id, certificate, source_type, key, valid_from, expires_at " +
                                "FROM crypto_tls_certificates WHERE node_id = :node_id")
                        .bind("node_id", nodeId)
                        .mapTo(TLSKeyAndCertificateEntry.class)
                        .findOne()
        );
        if (entry.isEmpty()) {
            return Optional.empty();
        }
        try {
            return Optional.of(tlsKeyAndCertificateEntryToObject(entry.get()));
        } catch (CertificateException | NoSuchAlgorithmException | InvalidKeySpecException | TLSUtils.PEMParserException e) {
            throw new RuntimeException("Could not build TLS certificate from database.", e);
        }
    }
    private List<TLSWildcardKeyAndCertificateEntry> getTLSWildcardCertificateEntries() {
        return database.withHandle(handle ->
                handle.createQuery("SELECT id, node_matcher, certificate, key, valid_from, expires_at, source_type " +
                                "FROM crypto_tls_certificates_wildcard ORDER BY node_matcher DESC")
                        .mapTo(TLSWildcardKeyAndCertificateEntry.class)
                        .list()
        );
    }
    public List<TLSWildcardKeyAndCertificate> getTLSWildcardCertificates() {
        List<TLSWildcardKeyAndCertificateEntry> entries = getTLSWildcardCertificateEntries();
        List<TLSWildcardKeyAndCertificate> result = Lists.newArrayList();
        for (TLSWildcardKeyAndCertificateEntry entry : entries) {
            try {
                result.add(tlsWildcardKeyAndCertificateEntryToObject(entry));
            } catch (TLSUtils.PEMParserException | CertificateException | NoSuchAlgorithmException |
                     InvalidKeySpecException e) {
                throw new RuntimeException("Could not build TLS wildcard certificate from database.");
            }
        }
        return result;
    }
    public Optional<TLSWildcardKeyAndCertificate> getTLSWildcardCertificate(long id) {
        Optional<TLSWildcardKeyAndCertificateEntry> entry = database.withHandle(handle ->
                handle.createQuery("SELECT id, node_matcher, certificate, key, valid_from, expires_at, source_type " +
                        "FROM crypto_tls_certificates_wildcard WHERE id = :id")
                        .bind("id", id)
                        .mapTo(TLSWildcardKeyAndCertificateEntry.class)
                        .findOne()
        );
        if (entry.isEmpty()) {
            return Optional.empty();
        }
        try {
            return Optional.of(tlsWildcardKeyAndCertificateEntryToObject(entry.get()));
        } catch (CertificateException | NoSuchAlgorithmException | InvalidKeySpecException |
                 TLSUtils.PEMParserException e) {
            throw new RuntimeException("Could not build TLS wildcard certificate from database.");
        }
    }
    public Map<UUID, TLSKeyAndCertificate> getTLSWildcardCertificatesForMatchingNodes() {
        List<TLSWildcardKeyAndCertificateEntry> entries = getTLSWildcardCertificateEntries();
        Map<UUID, TLSKeyAndCertificate> result = new TreeMap<>();
        List<Node> nodes = nzyme.getNodeManager().getNodes();
        for (TLSWildcardKeyAndCertificateEntry entry : entries) {
            for (Node node : nodes) {
                if (node.name().matches(entry.nodeMatcher())) {
                    try {
                        result.put(node.uuid(), tlsWildcardKeyAndCertificateEntryToNodeCertificate(entry, node));
                    } catch (TLSUtils.PEMParserException | NoSuchAlgorithmException | CertificateException |
                             InvalidKeySpecException e) {
                        throw new RuntimeException("Could not build TLS wildcard node certificate from database.");
                    }
                }
            }
        }
        return result;
    }
    public KeyStoreBootstrapResult bootstrapTLSKeyStore() {
        try {
            Optional<TLSKeyAndCertificate> diskCert = loadTLSCertificateFromDisk();
            TLSKeyAndCertificate tls;
            if (diskCert.isPresent()) {
                Optional<TLSKeyAndCertificate> existingCert = findTLSKeyAndCertificateOfNode(nodeId);
                tls = diskCert.get();
                if (existingCert.isPresent()) {
                    updateTLSCertificateOfNode(nodeId, tls);
                } else {
                    setTLSKeyAndCertificateOfNode(nodeId, tls);
                }
            } else {
                Map<UUID, TLSKeyAndCertificate> matchingNodes = getTLSWildcardCertificatesForMatchingNodes();
                TLSKeyAndCertificate wildcardTls = matchingNodes.get(nzyme.getNodeInformation().id());
                if (wildcardTls != null) {
                    tls = wildcardTls;
                } else {
                    Optional<TLSKeyAndCertificate> tlsData = findTLSKeyAndCertificateOfNode(nodeId);
                    if (tlsData.isEmpty()) {
                        throw new RuntimeException("No TLS certificate data of this node found in database.");
                    }
                    tls = tlsData.get();
                }
            }
            List<Certificate> certChain = Lists.newArrayList();
            certChain.addAll(tls.certificates());
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null, null);
            keyStore.setKeyEntry("key", tls.key(), "".toCharArray(), certChain.toArray(new Certificate[certChain.size()]));
            try(ByteArrayOutputStream ksStream = new ByteArrayOutputStream()) {
                keyStore.store(ksStream, "".toCharArray());
                return KeyStoreBootstrapResult.create(ksStream.toByteArray(), tls);
            }
        } catch(Exception e) {
            throw new RuntimeException("Could not build TLS key store.", e);
        }
    }
    private Optional<TLSKeyAndCertificate> loadTLSCertificateFromDisk() {
        File certFile = Paths.get(cryptoDirectoryConfig.toString(), TLS_CERTIFICATE_FILE_NAME).toFile();
        File keyFile = Paths.get(cryptoDirectoryConfig.toString(), TLS_KEY_FILE_NAME).toFile();
        if (certFile.exists() && keyFile.exists()) {
            try (FileInputStream certFileS = new FileInputStream(certFile);
                 FileInputStream keyFileS = new FileInputStream(keyFile)) {
                return Optional.of(
                        TLSUtils.readTLSKeyAndCertificateFromInputStreams(nodeId, TLSSourceType.FILE_LOADED, certFileS, keyFileS)
                );
            } catch (Exception e) {
                throw new RuntimeException("Could not read TLS certificate from disk.", e);
            }
        } else {
            return Optional.empty();
        }
    }
    public void updateTLSCertificateOfNode(UUID nodeId, TLSKeyAndCertificate tls) {
        String certificate;
        String key;
        try {
            certificate = TLSUtils.serializeCertificateChain(tls.certificates());
            key = BaseEncoding.base64().encode(tls.key().getEncoded());
        } catch(Exception e) {
            throw new RuntimeException("Could not encode TLS data.", e);
        }
        String encryptedCertificate, encryptedKey;
        try {
            encryptedCertificate = BaseEncoding.base64().encode(encryptWithClusterKey(certificate.getBytes()));
            encryptedKey = BaseEncoding.base64().encode(encryptWithClusterKey(key.getBytes()));
        } catch(CryptoOperationException e) {
            throw new RuntimeException("Could not encrypt TLS certificate/key for database storage.", e);
        }
        nzyme.getDatabase().useHandle(handle ->
            handle.createUpdate("UPDATE crypto_tls_certificates SET certificate = :certificate, key = :key, " +
                            "source_type = :source_type, valid_from = :valid_from, expires_at = :expires_at " +
                            "WHERE node_id = :node_id")
                    .bind("certificate", encryptedCertificate)
                    .bind("key", encryptedKey)
                    .bind("source_type", tls.sourceType().name())
                    .bind("valid_from", tls.validFrom())
                    .bind("expires_at", tls.expiresAt())
                    .bind("node_id", nodeId)
                    .execute()
        );
    }
    public void writeTLSWildcardCertificate(TLSWildcardKeyAndCertificate tls) {
        String certificate;
        String key;
        try {
            certificate = TLSUtils.serializeCertificateChain(tls.certificates());
            key = BaseEncoding.base64().encode(tls.key().getEncoded());
        } catch(Exception e) {
            throw new RuntimeException("Could not encode TLS data.", e);
        }
        if (tls.nodeMatcher().trim().isEmpty()) {
            throw new RuntimeException("Node matcher is empty.");
        }
        String encryptedCertificate, encryptedKey;
        try {
            encryptedCertificate = BaseEncoding.base64().encode(encryptWithClusterKey(certificate.getBytes()));
            encryptedKey = BaseEncoding.base64().encode(encryptWithClusterKey(key.getBytes()));
        } catch(CryptoOperationException e) {
            throw new RuntimeException("Could not encrypt TLS certificate/key for database storage.", e);
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("INSERT INTO crypto_tls_certificates_wildcard(node_matcher, certificate, key, " +
                                "valid_from, expires_at, source_type) VALUES(:node_matcher, :certificate, :key, :valid_from, " +
                                ":expires_at, :source_type)")
                        .bind("node_matcher", tls.nodeMatcher())
                        .bind("certificate", encryptedCertificate)
                        .bind("key", encryptedKey)
                        .bind("source_type", tls.sourceType().name())
                        .bind("valid_from", tls.validFrom())
                        .bind("expires_at", tls.expiresAt())
                        .execute()
        );
    }
    public void replaceTLSWildcardCertificate(long certificateId, TLSWildcardKeyAndCertificate newCert) {
        String certificate;
        String key;
        try {
            certificate = TLSUtils.serializeCertificateChain(newCert.certificates());
            key = BaseEncoding.base64().encode(newCert.key().getEncoded());
        } catch(Exception e) {
            throw new RuntimeException("Could not encode TLS data.", e);
        }
        if (newCert.nodeMatcher().trim().isEmpty()) {
            throw new RuntimeException("Node matcher is empty.");
        }
        String encryptedCertificate, encryptedKey;
        try {
            encryptedCertificate = BaseEncoding.base64().encode(encryptWithClusterKey(certificate.getBytes()));
            encryptedKey = BaseEncoding.base64().encode(encryptWithClusterKey(key.getBytes()));
        } catch(CryptoOperationException e) {
            throw new RuntimeException("Could not encrypt TLS certificate/key for database storage.", e);
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE crypto_tls_certificates_wildcard SET node_matcher = :node_matcher, " +
                        "certificate = :certificate, key = :key, valid_from = :valid_from, expires_at = :expires_at, " +
                        "source_type = :source_type WHERE id = :certificate_id")
                        .bind("node_matcher", newCert.nodeMatcher())
                        .bind("certificate", encryptedCertificate)
                        .bind("key", encryptedKey)
                        .bind("source_type", newCert.sourceType().name())
                        .bind("valid_from", newCert.validFrom())
                        .bind("expires_at", newCert.expiresAt())
                        .bind("certificate_id", certificateId)
                        .execute()
        );
    }
    public void updateTLSWildcardCertificateNodeMatcher(long certificateId, String nodeMatcher) {
        if (nodeMatcher.trim().isEmpty()) {
            throw new RuntimeException("Node matcher is empty.");
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE crypto_tls_certificates_wildcard SET node_matcher = :node_matcher " +
                                "WHERE id = :certificate_id")
                        .bind("node_matcher", nodeMatcher)
                        .bind("certificate_id", certificateId)
                        .execute()
        );
    }
    public void deleteTLSWildcardCertificate(long certificateId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM crypto_tls_certificates_wildcard WHERE id = :certificate_id")
                        .bind("certificate_id", certificateId)
                        .execute()
        );
    }
    public PGPKeys getNodeLocalPGPKeys() {
        return nodeLocalPGPKeys;
    }
    public static PGPPublicKey readPublicKey(File file) throws IOException, PGPException {
        try(InputStream keyIn = new BufferedInputStream(new FileInputStream(file))) {
            return readPublicKey(keyIn);
        }
    }
    public static PGPPublicKey readPublicKey(byte[] bytes) throws IOException, PGPException {
        try(InputStream keyIn = new BufferedInputStream(new ByteArrayInputStream(bytes))) {
            return readPublicKey(keyIn);
        }
    }
    public static PGPPublicKey readPublicKey(InputStream input) throws IOException, PGPException {
        PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(PGPUtil.getDecoderStream(input), new JcaKeyFingerprintCalculator());
        Iterator keyRingIter = pgpPub.getKeyRings();
        while (keyRingIter.hasNext()) {
            PGPPublicKeyRing keyRing = (PGPPublicKeyRing)keyRingIter.next();
            Iterator keyIter = keyRing.getPublicKeys();
            while (keyIter.hasNext()) {
                PGPPublicKey key = (PGPPublicKey)keyIter.next();
                if (key.isEncryptionKey()) {
                    return key;
                }
            }
        }
        throw new IllegalArgumentException("Can't find encryption key in key ring.");
    }
    public boolean isPGPKeySyncEnabled() {
        return nzyme.getDatabaseCoreRegistry().getValue(CryptoRegistryKeys.PGP_KEY_SYNC_ENABLED.key())
                .map(s -> s.equals("true"))
                .orElse(Boolean.parseBoolean(CryptoRegistryKeys.PGP_KEY_SYNC_ENABLED.defaultValue().get()));
    }
    private PGPPrivateKey findSecretKey(PGPSecretKeyRingCollection pgpSec, long keyID) throws PGPException {
        PGPSecretKey pgpSecKey = pgpSec.getSecretKey(keyID);
        if (pgpSecKey == null) {
            return null;
        }
        return pgpSecKey.extractPrivateKey(
                new JcePBESecretKeyDecryptorBuilder()
                        .setProvider("BC")
                        .build("nzyme".toCharArray())
        );
    }
    private Optional<TLSKeyAndCertificate> findTLSKeyAndCertificateOfNode(UUID nodeId) {
        Optional<TLSKeyAndCertificateEntry> entry = nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT node_id, certificate, key, source_type, valid_from, expires_at " +
                                "FROM crypto_tls_certificates WHERE node_id = :node_id")
                        .bind("node_id", nodeId)
                        .mapTo(TLSKeyAndCertificateEntry.class)
                        .findFirst()
        );
        if (entry.isEmpty()) {
            return Optional.empty();
        } else {
            try {
                return Optional.of(tlsKeyAndCertificateEntryToObject(entry.get()));
            } catch(Exception e) {
                throw new RuntimeException("Could not read TLS data.", e);
            }
        }
    }
    private TLSKeyAndCertificate tlsKeyAndCertificateEntryToObject(TLSKeyAndCertificateEntry entry)
            throws CertificateException, NoSuchAlgorithmException, InvalidKeySpecException, TLSUtils.PEMParserException {
        String decryptedCertificate, decryptedKey;
        try {
            decryptedCertificate = new String(decryptWithClusterKey(entry.certificate().getBytes()));
            decryptedKey = new String(decryptWithClusterKey(entry.key().getBytes()));
        } catch(CryptoOperationException e) {
            throw new RuntimeException("Could not decrypt TLS certificate/key.", e);
        }
        List<X509Certificate> certificates = TLSUtils.deSerializeCertificateChain(decryptedCertificate);
        X509Certificate firstCertificate = certificates.get(0);
        PrivateKey key = TLSUtils.deserializeKey(decryptedKey);
        return TLSKeyAndCertificate.create(
                entry.nodeId(),
                entry.sourceType(),
                certificates,
                key,
                TLSUtils.calculateTLSCertificateFingerprint(firstCertificate),
                new DateTime(firstCertificate.getNotBefore()),
                new DateTime(firstCertificate.getNotAfter())
        );
    }
    private TLSWildcardKeyAndCertificate tlsWildcardKeyAndCertificateEntryToObject(TLSWildcardKeyAndCertificateEntry entry)
            throws CertificateException, NoSuchAlgorithmException, InvalidKeySpecException, TLSUtils.PEMParserException {
        String decryptedCertificate, decryptedKey;
        try {
            decryptedCertificate = new String(decryptWithClusterKey(entry.certificate().getBytes()));
            decryptedKey = new String(decryptWithClusterKey(entry.key().getBytes()));
        } catch(CryptoOperationException e) {
            throw new RuntimeException("Could not decrypt TLS certificate/key.", e);
        }
        List<X509Certificate> certificates = TLSUtils.deSerializeCertificateChain(decryptedCertificate);
        X509Certificate firstCertificate = certificates.get(0);
        PrivateKey key = TLSUtils.deserializeKey(decryptedKey);
        return TLSWildcardKeyAndCertificate.create(
                entry.id(),
                entry.nodeMatcher(),
                entry.sourceType(),
                certificates,
                key,
                TLSUtils.calculateTLSCertificateFingerprint(firstCertificate),
                new DateTime(firstCertificate.getNotBefore()),
                new DateTime(firstCertificate.getNotAfter())
        );
    }
    private TLSKeyAndCertificate tlsWildcardKeyAndCertificateEntryToNodeCertificate(TLSWildcardKeyAndCertificateEntry entry, Node node)
            throws CertificateException, NoSuchAlgorithmException, InvalidKeySpecException, TLSUtils.PEMParserException {
        String decryptedCertificate, decryptedKey;
        try {
            decryptedCertificate = new String(decryptWithClusterKey(entry.certificate().getBytes()));
            decryptedKey = new String(decryptWithClusterKey(entry.key().getBytes()));
        } catch(CryptoOperationException e) {
            throw new RuntimeException("Could not decrypt TLS certificate/key.", e);
        }
        List<X509Certificate> certificates = TLSUtils.deSerializeCertificateChain(decryptedCertificate);
        X509Certificate firstCertificate = certificates.get(0);
        PrivateKey key = TLSUtils.deserializeKey(decryptedKey);
        return TLSKeyAndCertificate.create(
                node.uuid(),
                entry.sourceType(),
                certificates,
                key,
                TLSUtils.calculateTLSCertificateFingerprint(firstCertificate),
                new DateTime(firstCertificate.getNotBefore()),
                new DateTime(firstCertificate.getNotAfter())
        );
    }
    private void setTLSKeyAndCertificateOfNode(UUID nodeId, TLSKeyAndCertificate tls) {
        String certificate;
        String key;
        try {
            certificate = TLSUtils.serializeCertificateChain(tls.certificates());
            key = BaseEncoding.base64().encode(tls.key().getEncoded());
        } catch(Exception e) {
            throw new RuntimeException("Could not encode TLS data.", e);
        }
        String encryptedCertificate, encryptedKey;
        try {
            encryptedCertificate = BaseEncoding.base64().encode(encryptWithClusterKey(certificate.getBytes()));
            encryptedKey = BaseEncoding.base64().encode(encryptWithClusterKey(key.getBytes()));
        } catch(CryptoOperationException e) {
            throw new RuntimeException("Could not encrypt TLS certificate/key for database storage.", e);
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("INSERT INTO crypto_tls_certificates(node_id, certificate, key, source_type, " +
                                "valid_from, expires_at) VALUES(:node_id, :certificate, :key, :source_type, " +
                                ":valid_from, :expires_at)")
                        .bind("node_id", nodeId)
                        .bind("certificate", encryptedCertificate)
                        .bind("key", encryptedKey)
                        .bind("source_type", tls.sourceType().name())
                        .bind("valid_from", tls.validFrom())
                        .bind("expires_at", tls.expiresAt())
                        .execute()
        );
    }
    private void retentionCleanKeys() {
        List<UUID> activeNodeIds = Lists.newArrayList();
        for (Node node : nzyme.getNodeManager().getNodes()) {
            if (node.lastSeen().isAfter(DateTime.now().minusMinutes(2))) {
                activeNodeIds.add(node.uuid());
            }
        }
        for (PGPKeyFingerprint fingerprint : getPGPKeysByNode()) {
            if (!activeNodeIds.contains(fingerprint.nodeId())) {
                LOG.info("Retention cleaning keys of inactive node [{}/{}].",
                        fingerprint.nodeName(), fingerprint.nodeId());
                nzyme.getDatabase().useHandle(handle ->
                        handle.createUpdate("DELETE FROM crypto_keys WHERE node_id = :node_id")
                                .bind("node_id", fingerprint.nodeId())
                                .execute()
                );
            }
        }
    }
    public static final class CryptoInitializationException extends Throwable {
        public CryptoInitializationException(String msg) {
            super(msg);
        }
        public CryptoInitializationException(String msg, Throwable e) {
            super(msg, e);
        }
    }
    public static final class CryptoOperationException extends Throwable {
        public CryptoOperationException(String msg) {
            super(msg);
        }
        public CryptoOperationException(String msg, Throwable e) {
            super(msg, e);
        }
    }
}
package app.nzyme.core;
import app.nzyme.core.bluetooth.Bluetooth;
import app.nzyme.core.bluetooth.sig.BluetoothSigService;
import app.nzyme.core.configuration.base.BaseConfiguration;
import app.nzyme.core.connect.ConnectService;
import app.nzyme.core.context.ContextService;
import app.nzyme.core.detection.alerts.DetectionAlertService;
import app.nzyme.core.distributed.ClusterManager;
import app.nzyme.core.distributed.NodeManager;
import app.nzyme.core.distributed.messaging.postgres.PostgresMessageBusImpl;
import app.nzyme.core.distributed.tasksqueue.postgres.PostgresTasksQueueImpl;
import app.nzyme.core.dot11.Dot11;
import app.nzyme.core.events.EventEngine;
import app.nzyme.core.events.EventEngineImpl;
import app.nzyme.core.integrations.geoip.GeoIpService;
import app.nzyme.core.monitoring.health.HealthMonitor;
import app.nzyme.core.ouis.OuiService;
import app.nzyme.core.registry.RegistryChangeMonitorImpl;
import app.nzyme.core.registry.RegistryImpl;
import app.nzyme.core.rest.server.NzymeHttpServer;
import app.nzyme.core.security.authentication.AuthenticationService;
import app.nzyme.core.subsystems.Subsystems;
import app.nzyme.plugin.Database;
import app.nzyme.plugin.NodeIdentification;
import app.nzyme.plugin.Registry;
import app.nzyme.plugin.RegistryChangeMonitor;
import app.nzyme.plugin.distributed.messaging.MessageBus;
import app.nzyme.plugin.distributed.tasksqueue.TasksQueue;
import app.nzyme.plugin.retro.RetroService;
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.jvm.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import app.nzyme.core.configuration.IncompleteConfigurationException;
import app.nzyme.core.configuration.InvalidConfigurationException;
import app.nzyme.core.configuration.node.NodeConfiguration;
import app.nzyme.core.configuration.node.NodeConfigurationLoader;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.database.DatabaseImpl;
import app.nzyme.core.ethernet.Ethernet;
import app.nzyme.core.tables.TablesService;
import app.nzyme.core.taps.TapManager;
import liquibase.exception.LiquibaseException;
import java.io.File;
import java.io.FileNotFoundException;
import java.net.URL;
import java.nio.file.Path;
import java.util.List;
import java.util.Optional;
import java.util.Random;
import java.util.concurrent.TimeUnit;
public class MockNzyme implements NzymeNode {
    private File loadFromResourceFile(String name) {
        URL resource = getClass().getClassLoader().getResource(name);
        if (resource == null) {
            throw new RuntimeException("test config file does not exist in resources");
        }
        return new File(resource.getFile());
    }
    private final NodeManager nodeManager;
    private final NodeIdentification nodeIdentification;
    private final NodeConfiguration configuration;
    private final OuiService ouiService;
    private final MetricRegistry metricRegistry;
    private final ObjectMapper objectMapper;
    private final Version version;
    private final Database database;
    private final Path dataDirectory;
    private final MessageBus messageBus;
    private final TasksQueue tasksQueue;
    private final BaseConfiguration baseConfiguration;
    private final Crypto crypto;
    private final ClusterManager clusterManager;
    private final AuthenticationService authenticationService;
    private final GeoIpService geoIp;
    private final Registry registry;
    private final RegistryChangeMonitor registryChangeMonitor;
    private final EventEngine eventEngine;
    public MockNzyme() {
        this(Integer.MAX_VALUE, TimeUnit.DAYS);
    }
    public MockNzyme(int taskAndMessagePollInterval, TimeUnit taskAndMessagePollIntervalUnit) {
        this.version = new Version();
        this.baseConfiguration = BaseConfiguration.create(
                "mocky-mock-" + new Random().nextInt(Integer.MAX_VALUE),
                "foo"
        );
        try {
            String configFile = "nzyme-test-complete-valid.conf.test";
            if (System.getProperty("os.name").startsWith("Windows")) {
                configFile = "nzyme-test-complete-valid-windows.conf.test";
                System.out.println("loading Windows nzyme configuration file");
            }
            this.configuration = new NodeConfigurationLoader(loadFromResourceFile(configFile), false).get();
            this.dataDirectory = Path.of("test_data_dir");
        } catch (InvalidConfigurationException | IncompleteConfigurationException | FileNotFoundException e) {
            throw new RuntimeException("Could not load test config file from resources.", e);
        }
        this.database = new DatabaseImpl(configuration);
        try {
            this.database.migrate();
            this.database.initialize();
        } catch (LiquibaseException e) {
            throw new RuntimeException(e);
        }
        this.registry = new RegistryImpl(this, "core");
        this.registryChangeMonitor = new RegistryChangeMonitorImpl(this);
        this.metricRegistry = new MetricRegistry();
        this.metricRegistry.register("gc", new GarbageCollectorMetricSet());
        this.metricRegistry.register("classes", new ClassLoadingGaugeSet());
        this.metricRegistry.register("fds", new FileDescriptorRatioGauge());
        this.metricRegistry.register("jvm", new JvmAttributeGaugeSet());
        this.metricRegistry.register("mem", new MemoryUsageGaugeSet());
        this.metricRegistry.register("threadstates", new ThreadStatesGaugeSet());
        this.geoIp = new GeoIpService(this);
        this.geoIp.initialize();
        this.eventEngine = new EventEngineImpl(this);
        this.nodeManager = new NodeManager(this);
        try {
            this.nodeManager.initialize();
        } catch (NodeManager.NodeInitializationException e) {
            throw new RuntimeException(e);
        }
        this.nodeIdentification = NodeIdentification.create(nodeManager.getLocalNodeId(), baseConfiguration.name());
        this.clusterManager = new ClusterManager(this);
        this.messageBus = new PostgresMessageBusImpl(this);
        ((PostgresMessageBusImpl) this.messageBus).initialize(taskAndMessagePollInterval, taskAndMessagePollIntervalUnit);
        this.tasksQueue = new PostgresTasksQueueImpl(this);
        ((PostgresTasksQueueImpl) this.tasksQueue).initialize(taskAndMessagePollInterval, taskAndMessagePollIntervalUnit);
        this.authenticationService = new AuthenticationService(this);
        this.database.useHandle(handle -> handle.execute("TRUNCATE sentry_ssids"));
        this.crypto = new Crypto(this);
        this.ouiService = new OuiService(this);
        this.objectMapper = new ObjectMapper();
    }
    @Override
    public void initialize() {
        this.clusterManager.initialize();
        try {
            this.crypto.initialize(false);
        } catch (Crypto.CryptoInitializationException e) {
            throw new RuntimeException(e);
        }
        this.authenticationService.initialize();
    }
    @Override
    public void shutdown() {
    }
    @Override
    public NodeManager getNodeManager() {
        return nodeManager;
    }
    @Override
    public ClusterManager getClusterManager() {
        return clusterManager;
    }
    @Override
    public MessageBus getMessageBus() {
        return messageBus;
    }
    @Override
    public TasksQueue getTasksQueue() {
        return tasksQueue;
    }
    @Override
    public AuthenticationService getAuthenticationService() {
        return authenticationService;
    }
    @Override
    public Subsystems getSubsystems() {
        return null;
    }
    @Override
    public HealthMonitor getHealthMonitor() {
        return null;
    }
    @Override
    public Ethernet getEthernet() {
        return null;
    }
    @Override
    public Dot11 getDot11() {
        return null;
    }
    @Override
    public Bluetooth getBluetooth() {
        return null;
    }
    @Override
    public GeoIpService getGeoIpService() {
        return geoIp;
    }
    @Override
    public ContextService getContextService() {
        return null;
    }
    @Override
    public NodeConfiguration getConfiguration() {
        return configuration;
    }
    @Override
    public BaseConfiguration getBaseConfiguration() {
        return baseConfiguration;
    }
    @Override
    public Path getDataDirectory() {
        return dataDirectory;
    }
    @Override
    public MetricRegistry getMetrics() {
        return metricRegistry;
    }
    @Override
    public Database getDatabase() {
        return database;
    }
    @Override
    public TapManager getTapManager() {
        return null;
    }
    @Override
    public TablesService getTablesService() {
        return null;
    }
    @Override
    public OuiService getOuiService() {
        return ouiService;
    }
    @Override
    public BluetoothSigService getBluetoothSigService() {
        return null;
    }
    @Override
    public List<String> getInitializedPlugins() {
        return null;
    }
    @Override
    public Optional<RetroService> retroService() {
        return Optional.empty();
    }
    @Override
    public Crypto getCrypto() {
        return crypto;
    }
    @Override
    public ObjectMapper getObjectMapper() {
        return objectMapper;
    }
    @Override
    public Registry getDatabaseCoreRegistry() {
        return new RegistryImpl(this, "core");
    }
    @Override
    public RegistryChangeMonitor getRegistryChangeMonitor() {
        return registryChangeMonitor;
    }
    @Override
    public DetectionAlertService getDetectionAlertService() {
        return null;
    }
    @Override
    public ConnectService getConnect() {
        return null;
    }
    @Override
    public Version getVersion() {
        return version;
    }
    @Override
    public NzymeHttpServer getHttpServer() {
        return null;
    }
    @Override
    public void registerRetroService(RetroService retroService) {
    }
    @Override
    public void registerRestResource(Object o) {
    }
    public Registry getRegistry(String s) {
        return registry;
    }
    @Override
    public EventEngine getEventEngine() {
        return eventEngine;
    }
    @Override
    public NodeIdentification getNodeInformation() {
        return nodeIdentification;
    }
}
package app.nzyme.core.configuration.node;
import com.google.auto.value.AutoValue;
import java.net.URI;
import java.util.Optional;
@AutoValue
public abstract class NodeConfiguration {
    public abstract boolean versionchecksEnabled();
    public abstract String databasePath();
    public abstract URI restListenUri();
    public abstract URI httpExternalUri();
    public abstract Optional<Integer> httpMaxPostSize();
    public abstract String pluginDirectory();
    public abstract String cryptoDirectory();
    public abstract Optional<Integer> slowQueryLogThreshold();
    public abstract String ntpServer();
    public abstract Optional<ProtocolsConfiguration> protocols();
    public abstract Optional<String> connectApiUri();
    public abstract boolean connectSkip();
    public abstract PerformanceConfiguration performance();
    public abstract MiscConfiguration misc();
    public static NodeConfiguration create(boolean versionchecksEnabled, String databasePath, URI restListenUri, URI httpExternalUri, Optional<Integer> httpMaxPostSize, String pluginDirectory, String cryptoDirectory, Optional<Integer> slowQueryLogThreshold, String ntpServer, Optional<ProtocolsConfiguration> protocols, Optional<String> connectApiUri, boolean connectSkip, PerformanceConfiguration performance, MiscConfiguration misc) {
        return builder()
                .versionchecksEnabled(versionchecksEnabled)
                .databasePath(databasePath)
                .restListenUri(restListenUri)
                .httpExternalUri(httpExternalUri)
                .httpMaxPostSize(httpMaxPostSize)
                .pluginDirectory(pluginDirectory)
                .cryptoDirectory(cryptoDirectory)
                .slowQueryLogThreshold(slowQueryLogThreshold)
                .ntpServer(ntpServer)
                .protocols(protocols)
                .connectApiUri(connectApiUri)
                .connectSkip(connectSkip)
                .performance(performance)
                .misc(misc)
                .build();
    }
    public static Builder builder() {
        return new AutoValue_NodeConfiguration.Builder();
    }
    @AutoValue.Builder
    public abstract static class Builder {
        public abstract Builder versionchecksEnabled(boolean versionchecksEnabled);
        public abstract Builder databasePath(String databasePath);
        public abstract Builder restListenUri(URI restListenUri);
        public abstract Builder httpExternalUri(URI httpExternalUri);
        public abstract Builder httpMaxPostSize(Optional<Integer> httpMaxPostSize);
        public abstract Builder pluginDirectory(String pluginDirectory);
        public abstract Builder cryptoDirectory(String cryptoDirectory);
        public abstract Builder slowQueryLogThreshold(Optional<Integer> slowQueryLogThreshold);
        public abstract Builder ntpServer(String ntpServer);
        public abstract Builder protocols(Optional<ProtocolsConfiguration> protocols);
        public abstract Builder connectApiUri(Optional<String> connectApiUri);
        public abstract Builder connectSkip(boolean connectSkip);
        public abstract Builder performance(PerformanceConfiguration performance);
        public abstract Builder misc(MiscConfiguration misc);
        public abstract NodeConfiguration build();
    }
}
package app.nzyme.core.crypto.tls;
import com.google.auto.value.AutoValue;
import org.joda.time.DateTime;
import javax.annotation.Nullable;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.List;
@AutoValue
public abstract class TLSWildcardKeyAndCertificate {
    @Nullable
    public abstract Long id();
    public abstract String nodeMatcher();
    public abstract TLSSourceType sourceType();
    public abstract List<X509Certificate> certificates();
    public abstract PrivateKey key();
    public abstract String signature();
    public abstract DateTime validFrom();
    public abstract DateTime expiresAt();
    public static TLSWildcardKeyAndCertificate create(Long id, String nodeMatcher, TLSSourceType sourceType, List<X509Certificate> certificates, PrivateKey key, String signature, DateTime validFrom, DateTime expiresAt) {
        return builder()
                .id(id)
                .nodeMatcher(nodeMatcher)
                .sourceType(sourceType)
                .certificates(certificates)
                .key(key)
                .signature(signature)
                .validFrom(validFrom)
                .expiresAt(expiresAt)
                .build();
    }
    public static Builder builder() {
        return new AutoValue_TLSWildcardKeyAndCertificate.Builder();
    }
    @AutoValue.Builder
    public abstract static class Builder {
        public abstract Builder id(Long id);
        public abstract Builder nodeMatcher(String nodeMatcher);
        public abstract Builder sourceType(TLSSourceType sourceType);
        public abstract Builder certificates(List<X509Certificate> certificates);
        public abstract Builder key(PrivateKey key);
        public abstract Builder signature(String signature);
        public abstract Builder validFrom(DateTime validFrom);
        public abstract Builder expiresAt(DateTime expiresAt);
        public abstract TLSWildcardKeyAndCertificate build();
    }
}
package app.nzyme.core.registry;
import app.nzyme.plugin.Registry;
import app.nzyme.plugin.RegistryCryptoException;
import com.google.common.base.Charsets;
import com.google.common.io.BaseEncoding;
import app.nzyme.core.NzymeNode;
import app.nzyme.core.crypto.Crypto;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import javax.annotation.Nullable;
import java.util.Optional;
import java.util.UUID;
public class RegistryImpl implements Registry {
    private static final Logger LOG = LogManager.getLogger(RegistryImpl.class);
    private final NzymeNode nzyme;
    private final String namespace;
    public RegistryImpl(NzymeNode nzyme, String namespace) {
        this.nzyme = nzyme;
        this.namespace = namespace;
    }
    @Override
    public Optional<String> getValue(String key) {
        LOG.debug("Getting value for [{}] from registry.", buildNamespacedKey(namespace, key));
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT value FROM registry WHERE key = :key " +
                                "AND organization_id IS NULL AND tenant_id IS NULL")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .mapTo(String.class)
                        .findOne()
        );
    }
    @Override
    public Optional<String> getValue(String key, UUID organizationId) {
        LOG.debug("Getting value for [{}] (Org <{}>) from registry.",
                buildNamespacedKey(namespace, key), organizationId);
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT value FROM registry WHERE key = :key " +
                                "AND organization_id = :organization_id AND tenant_id IS NULL")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .bind("organization_id", organizationId)
                        .mapTo(String.class)
                        .findOne()
        );
    }
    @Override
    public Optional<String> getValue(String key, UUID organizationId, UUID tenantId) {
        LOG.debug("Getting value for [{}] (Org <{}>, Tenant <{}>) from registry.",
                buildNamespacedKey(namespace, key), organizationId, tenantId);
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT value FROM registry WHERE key = :key " +
                                "AND organization_id = :organization_id AND tenant_id = :tenant_id")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .mapTo(String.class)
                        .findOne()
        );
    }
    @Override
    public Optional<String> getEncryptedValue(String key) throws RegistryCryptoException {
        LOG.debug("Getting encrypted value for [{}] from registry.", buildNamespacedKey(namespace, key));
        Optional<String> encrypted = nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT value FROM registry_encrypted WHERE key = :key")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .mapTo(String.class)
                        .findOne()
        );
        return dbResultToResult(key, encrypted);
    }
    @Override
    public Optional<String> getEncryptedValue(String key, UUID organizationId) throws RegistryCryptoException {
        LOG.debug("Getting encrypted value for [{}] (Org <{}>) from registry.",
                buildNamespacedKey(namespace, key), organizationId);
        Optional<String> encrypted = nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT value FROM registry_encrypted WHERE key = :key " +
                                "AND organization_id = :organization_id AND tenant_id IS NULL")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .bind("organization_id", organizationId)
                        .mapTo(String.class)
                        .findOne()
        );
        return dbResultToResult(key, encrypted);
    }
    @Override
    public Optional<String> getEncryptedValue(String key, UUID organizationId, UUID tenantId) throws RegistryCryptoException {
        LOG.debug("Getting encrypted value for [{}] (Org <{}>, Tenant <{}>) from registry.",
                buildNamespacedKey(namespace, key), organizationId, tenantId);
        Optional<String> encrypted = nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT value FROM registry_encrypted WHERE key = :key " +
                                "AND organization_id = :organization_id AND tenant_id = :tenant_id")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .mapTo(String.class)
                        .findOne()
        );
        return dbResultToResult(key, encrypted);
    }
    private Optional<String> dbResultToResult(String key, Optional<String> encrypted) throws RegistryCryptoException {
        if (encrypted.isEmpty()) {
            return Optional.empty();
        } else {
            try {
                return Optional.of(
                        new String(nzyme.getCrypto().decryptWithClusterKey(
                                BaseEncoding.base64().decode(encrypted.get())
                        ), Charsets.UTF_8)
                );
            } catch (Crypto.CryptoOperationException e) {
                throw new RegistryCryptoException("Could not decrypt registry value for key [" + key + "]", e);
            }
        }
    }
    @Override
    @Nullable
    public String getValueOrNull(String key) {
        return getValue(key).orElse(null);
    }
    @Nullable
    @Override
    public String getValueOrNull(String key, UUID organizationId) {
        return getValue(key, organizationId).orElse(null);
    }
    @Nullable
    @Override
    public String getValueOrNull(String key, UUID organizationId, UUID tenantId) {
        return getValue(key, organizationId, tenantId).orElse(null);
    }
    @Override
    @Nullable
    public String getEncryptedValueOrNull(String key)  throws RegistryCryptoException {
        return getEncryptedValue(key).orElse(null);
    }
    @Nullable
    @Override
    public String getEncryptedValueOrNull(String key, UUID organizationId) throws RegistryCryptoException {
        return getEncryptedValue(key, organizationId).orElse(null);
    }
    @Nullable
    @Override
    public String getEncryptedValueOrNull(String key, UUID organizationId, UUID tenantId) throws RegistryCryptoException {
        return getEncryptedValue(key, organizationId, tenantId).orElse(null);
    }
    @Override
    public void setValue(String key, String value) {
        setValuePreflightChecks(key, value);
        if (getValue(key).isPresent()) {
            LOG.debug("Updating existing value for key [{}] in registry.", buildNamespacedKey(namespace, key));
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("UPDATE registry SET value = :value WHERE key = :key")
                            .bind("key", buildNamespacedKey(namespace, key))
                            .bind("value", value)
                            .execute()
            );
        } else {
            LOG.debug("Inserting new entry for key [{}] in registry.", buildNamespacedKey(namespace, key));
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("INSERT INTO registry(key, value) VALUES(:key, :value)")
                            .bind("key", buildNamespacedKey(namespace, key))
                            .bind("value", value)
                            .execute()
            );
        }
    }
    @Override
    public void setValue(String key, String value, UUID organizationId) {
        setValuePreflightChecks(key, value);
        if (getValue(key, organizationId).isPresent()) {
            LOG.debug("Updating existing value for key [{}] (Org <{}>) in registry.",
                    buildNamespacedKey(namespace, key), organizationId);
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("UPDATE registry SET value = :value WHERE key = :key " +
                                    "AND organization_id = :organization_id AND tenant_id IS NULL")
                            .bind("key", buildNamespacedKey(namespace, key))
                            .bind("value", value)
                            .bind("organization_id", organizationId)
                            .execute()
            );
        } else {
            LOG.debug("Inserting new entry for key [{}] (Org <{}>) in registry.",
                    buildNamespacedKey(namespace, key), organizationId);
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("INSERT INTO registry(key, value, organization_id, tenant_id) " +
                                    "VALUES(:key, :value, :organization_id, NULL)")
                            .bind("key", buildNamespacedKey(namespace, key))
                            .bind("value", value)
                            .bind("organization_id", organizationId)
                            .execute()
            );
        }
    }
    @Override
    public void setValue(String key, String value, UUID organizationId, UUID tenantId) {
        setValuePreflightChecks(key, value);
        if (getValue(key, organizationId, tenantId).isPresent()) {
            LOG.debug("Updating existing value for key [{}] (Org <{}>, Tenant <{}>) in registry.",
                    buildNamespacedKey(namespace, key), organizationId, tenantId);
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("UPDATE registry SET value = :value WHERE key = :key " +
                                    "AND organization_id = :organization_id AND tenant_id = :tenant_id")
                            .bind("key", buildNamespacedKey(namespace, key))
                            .bind("value", value)
                            .bind("organization_id", organizationId)
                            .bind("tenant_id", tenantId)
                            .execute()
            );
        } else {
            LOG.debug("Inserting new entry for key [{}] (Org <{}>, Tenant <{}>) in registry.",
                    buildNamespacedKey(namespace, key), organizationId, tenantId);
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("INSERT INTO registry(key, value, organization_id, tenant_id) " +
                                    "VALUES(:key, :value, :organization_id, :tenant_id)")
                            .bind("key", buildNamespacedKey(namespace, key))
                            .bind("value", value)
                            .bind("organization_id", organizationId)
                            .bind("tenant_id", tenantId)
                            .execute()
            );
        }
    }
    @Override
    public void setEncryptedValue(String key, String value) throws RegistryCryptoException {
        setValuePreflightChecks(key, value);
        String encrypted;
        String keyFingerprint;
        try {
            Crypto crypto = nzyme.getCrypto();
            encrypted = BaseEncoding.base64().encode(crypto.encryptWithClusterKey(value.getBytes(Charsets.UTF_8)));
            keyFingerprint = crypto.getLocalPGPKeyFingerprint();
            value = ""; 
        } catch (Crypto.CryptoOperationException e) {
            throw new RegistryCryptoException("Could not encrypt registry value for key [" + key + "]", e);
        }
        if (getEncryptedValue(key).isPresent()) {
            LOG.debug("Updating existing encrypted value for key [{}] in registry.", buildNamespacedKey(namespace, key));
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("UPDATE registry_encrypted SET value = :value, key_signature = :key_signature " +
                                    "WHERE key = :key")
                            .bind("key", buildNamespacedKey(namespace, key))
                            .bind("value", encrypted)
                            .bind("key_signature", keyFingerprint)
                            .execute()
            );
        } else {
            LOG.debug("Inserting new encrypted entry for key [{}] in registry.", buildNamespacedKey(namespace, key));
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("INSERT INTO registry_encrypted(key, value, key_signature) " +
                                    "VALUES(:key, :value, :key_signature)")
                            .bind("key", buildNamespacedKey(namespace, key))
                            .bind("value", encrypted)
                            .bind("key_signature", keyFingerprint)
                            .execute()
            );
        }
    }
    @Override
    public void setEncryptedValue(String key, String value, UUID organizationId) throws RegistryCryptoException {
        throw new RuntimeException("Encrypted database registry with organization scope not implemented yet.");
    }
    @Override
    public void setEncryptedValue(String key, String value, UUID organizationId, UUID tenantId) throws RegistryCryptoException {
        throw new RuntimeException("Encrypted database registry with tenant scope not implemented yet.");
    }
    @Override
    public void deleteValue(String key) {
        LOG.debug("Deleting registry value for key [{}]", key);
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM registry WHERE key = :key")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .execute()
        );
    }
    @Override
    public void deleteValue(String key, UUID organizationId) {
        LOG.debug("Deleting registry value for key [{}] (Org <{}>)", key, organizationId);
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM registry WHERE key = :key " +
                                "AND organization_id = :organization_id AND tenant_id IS NULL")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .bind("organization_id", organizationId)
                        .execute()
        );
    }
    @Override
    public void deleteValue(String key, UUID organizationId, UUID tenantId) {
        LOG.debug("Deleting registry value for key [{}] (Org <{}>, Tenant <{}>)",
                key, organizationId, tenantId);
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM registry WHERE key = :key " +
                                "AND organization_id = :organization_id AND tenant_id = :tenant_id")
                        .bind("key", buildNamespacedKey(namespace, key))
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .execute()
        );
    }
    private void setValuePreflightChecks(String key, String value) {
        if (key == null || key.trim().isEmpty()) {
            throw new IllegalArgumentException("Empty or null registry key.");
        }
        if (value == null || value.trim().isEmpty()) {
            throw new IllegalArgumentException("Empty or null registry value for key [" + buildNamespacedKey(namespace, key) + "].");
        }
        if (buildNamespacedKey(namespace, key).length() > 128) {
            LOG.error("Registry key length cannot exceed 128 characters. Provided <{}> characters: {}",
                    buildNamespacedKey(namespace, key).length(), buildNamespacedKey(namespace, key));
            throw new IllegalArgumentException("Key length exceeded.");
        }
    }
    public static String buildNamespacedKey(String namespace, String key) {
        return namespace + "." + key;
    }
}
package app.nzyme.core.rest.server;
import app.nzyme.core.NzymeNode;
import app.nzyme.core.crypto.tls.KeyStoreBootstrapResult;
import app.nzyme.core.crypto.tls.TLSKeyAndCertificate;
import app.nzyme.core.rest.CORSFilter;
import app.nzyme.core.rest.NzymeExceptionMapper;
import app.nzyme.core.rest.NzymeLeaderInjectionBinder;
import app.nzyme.core.rest.ObjectMapperProvider;
import app.nzyme.core.rest.authentication.*;
import app.nzyme.core.rest.interceptors.TapTableSizeInterceptor;
import app.nzyme.core.rest.resources.*;
import app.nzyme.core.rest.resources.alerts.AlertsResource;
import app.nzyme.core.rest.resources.assets.WebInterfaceAssetsResource;
import app.nzyme.core.rest.resources.bluetooth.BluetoothDevicesResource;
import app.nzyme.core.rest.resources.context.AssetContextResource;
import app.nzyme.core.rest.resources.dot11.*;
import app.nzyme.core.rest.resources.dot11.BanditsResource;
import app.nzyme.core.rest.resources.dot11.Dot11ClientsResource;
import app.nzyme.core.rest.resources.dot11.Dot11MonitoredNetworksResource;
import app.nzyme.core.rest.resources.dot11.Dot11NetworksResource;
import app.nzyme.core.rest.resources.ethernet.SSHResource;
import app.nzyme.core.rest.resources.ethernet.SocksResource;
import app.nzyme.core.rest.resources.system.authentication.AuthenticationResource;
import app.nzyme.core.rest.resources.system.authentication.mgmt.InitialUserResource;
import app.nzyme.core.rest.resources.system.authentication.mgmt.OrganizationsResource;
import app.nzyme.core.rest.resources.ethernet.DNSResource;
import app.nzyme.core.rest.resources.monitoring.MonitoringResource;
import app.nzyme.core.rest.resources.monitoring.PrometheusResource;
import app.nzyme.core.rest.resources.system.*;
import app.nzyme.core.rest.resources.system.cluster.MessageBusResource;
import app.nzyme.core.rest.resources.system.cluster.NodesResource;
import app.nzyme.core.rest.resources.system.cluster.TasksQueueResource;
import app.nzyme.core.rest.resources.system.connect.ConnectResource;
import app.nzyme.core.rest.resources.system.integrations.SmtpIntegrationResource;
import app.nzyme.core.rest.resources.taps.StatusResource;
import app.nzyme.core.rest.resources.taps.TablesResource;
import app.nzyme.core.rest.resources.taps.TapsResource;
import app.nzyme.core.rest.resources.user.UserProfileResource;
import app.nzyme.plugin.distributed.messaging.*;
import com.fasterxml.jackson.jakarta.rs.json.JacksonJsonProvider;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.glassfish.grizzly.http.CompressionConfig;
import org.glassfish.grizzly.http.server.HttpServer;
import org.glassfish.grizzly.ssl.SSLContextConfigurator;
import org.glassfish.grizzly.ssl.SSLEngineConfigurator;
import org.glassfish.jersey.grizzly2.httpserver.GrizzlyHttpServerFactory;
import org.glassfish.jersey.media.multipart.MultiPartFeature;
import org.glassfish.jersey.message.DeflateEncoder;
import org.glassfish.jersey.message.GZipEncoder;
import org.glassfish.jersey.server.ResourceConfig;
import org.glassfish.jersey.server.filter.EncodingFilter;
import javax.net.ssl.SSLContext;
import java.io.IOException;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class NzymeHttpServer {
    private static final Logger LOG = LogManager.getLogger(NzymeHttpServer.class);
    private final NzymeNode nzyme;
    private final List<Object> pluginRestResources;
    private HttpServer server;
    private TLSKeyAndCertificate certificateInUse;
    public NzymeHttpServer(NzymeNode nzyme, List<Object> pluginRestResources) {
        this.nzyme = nzyme;
        this.pluginRestResources = pluginRestResources;
        nzyme.getMessageBus().onMessageReceived(MessageType.CHECK_RESTART_HTTP_SERVER, new MessageHandler() {
            @Override
            public MessageProcessingResult handle(ReceivedMessage message) {
                LOG.info("Received request to check for a potential restart of HTTP server. Current certificate: [{}]",
                        getCertificateInUse().signature());
                try {
                    KeyStoreBootstrapResult keyStore = nzyme.getCrypto().bootstrapTLSKeyStore();
                    LOG.info("TLS bootstrap certificate decision: [{}]", keyStore.loadedCertificate().signature());
                    if (!keyStore.loadedCertificate().signature().equals(getCertificateInUse().signature())) {
                        LOG.info("Restarting HTTP server to load new TLS certificate.");
                        reloadHttpServer(0, TimeUnit.SECONDS);
                    } else {
                        LOG.info("No restart of HTTP server required: Certificate did not change.");
                    }
                    return MessageProcessingResult.SUCCESS;
                } catch(Exception e) {
                    LOG.error("Could not handle requested HTTP server restart.", e);
                    return MessageProcessingResult.FAILURE;
                }
            }
            @Override
            public String getName() {
                return "Check for required HTTP server restart after TLS configuration change.";
            }
        });
    }
    public void initialize() {
        ResourceConfig resourceConfig = new ResourceConfig();
        resourceConfig.register(new PreMFAAuthenticationFilter(nzyme));
        resourceConfig.register(new RESTAuthenticationFilter(nzyme));
        resourceConfig.register(new TapAuthenticationFilter(nzyme));
        resourceConfig.register(new PrometheusBasicAuthFilter(nzyme));
        resourceConfig.register(new CORSFilter());
        resourceConfig.register(new NzymeLeaderInjectionBinder(nzyme));
        resourceConfig.register(new ObjectMapperProvider());
        resourceConfig.register(new JacksonJsonProvider());
        resourceConfig.register(new NzymeExceptionMapper());
        resourceConfig.register(new TapTableSizeInterceptor(nzyme));
        resourceConfig.register(MultiPartFeature.class);
        resourceConfig.register(AuthenticationResource.class);
        resourceConfig.register(PingResource.class);
        resourceConfig.register(SystemResource.class);
        resourceConfig.register(StatusResource.class);
        resourceConfig.register(TablesResource.class);
        resourceConfig.register(TapsResource.class);
        resourceConfig.register(DNSResource.class);
        resourceConfig.register(PluginResource.class);
        resourceConfig.register(PrometheusResource.class);
        resourceConfig.register(CryptoResource.class);
        resourceConfig.register(MonitoringResource.class);
        resourceConfig.register(NodesResource.class);
        resourceConfig.register(HealthResource.class);
        resourceConfig.register(RegistryResource.class);
        resourceConfig.register(MessageBusResource.class);
        resourceConfig.register(TasksQueueResource.class);
        resourceConfig.register(OrganizationsResource.class);
        resourceConfig.register(InitialUserResource.class);
        resourceConfig.register(UserProfileResource.class);
        resourceConfig.register(EventsResource.class);
        resourceConfig.register(SmtpIntegrationResource.class);
        resourceConfig.register(EventActionsResource.class);
        resourceConfig.register(Dot11NetworksResource.class);
        resourceConfig.register(DatabaseResource.class);
        resourceConfig.register(Dot11ClientsResource.class);
        resourceConfig.register(Dot11MonitoredNetworksResource.class);
        resourceConfig.register(AlertsResource.class);
        resourceConfig.register(BanditsResource.class);
        resourceConfig.register(Dot11DiscoResource.class);
        resourceConfig.register(AssetContextResource.class);
        resourceConfig.register(Dot11LocationsResource.class);
        resourceConfig.register(SocksResource.class);
        resourceConfig.register(SSHResource.class);
        resourceConfig.register(ConnectResource.class);
        resourceConfig.register(BluetoothDevicesResource.class);
        resourceConfig.register(Dot11MonitoredProbeRequestResource.class);
        resourceConfig.register(Dot11MonitoredSSIDsResource.class);
        for (Object resource : pluginRestResources) {
            try {
                resourceConfig.register(resource);
                LOG.info("Loaded plugin REST resource [{}].", resource.getClass().getCanonicalName());
            } catch(Exception e) {
                LOG.error("Could not register plugin REST resource [{}].", resource.getClass().getCanonicalName(), e);
            }
        }
        resourceConfig.registerClasses(EncodingFilter.class, GZipEncoder.class, DeflateEncoder.class);
        resourceConfig.register(WebInterfaceAssetsResource.class);
        try {
            KeyStoreBootstrapResult keyStore = nzyme.getCrypto().bootstrapTLSKeyStore();
            final SSLContextConfigurator sslContextConfigurator = new SSLContextConfigurator();
            sslContextConfigurator.setKeyStorePass("".toCharArray());
            sslContextConfigurator.setKeyStoreBytes(keyStore.keystoreBytes());
            final SSLContext sslContext = sslContextConfigurator.createSSLContext(true);
            SSLEngineConfigurator sslEngineConfigurator = new SSLEngineConfigurator(sslContext, false, false, false);
            server = GrizzlyHttpServerFactory.createHttpServer(
                    nzyme.getConfiguration().restListenUri(),
                    resourceConfig,
                    true,
                    sslEngineConfigurator,
                    false
            );
            this.certificateInUse = keyStore.loadedCertificate();
            LOG.info("Loaded TLS certificate: [{}/{}]",
                    certificateInUse.sourceType(), certificateInUse.signature());
        } catch(Exception e) {
            throw new RuntimeException("Could not start web server.", e);
        }
        CompressionConfig compressionConfig = server.getListener("grizzly").getCompressionConfig();
        compressionConfig.setCompressionMode(CompressionConfig.CompressionMode.ON);
        compressionConfig.setCompressionMinSize(1);
        compressionConfig.setCompressibleMimeTypes();
        int maxPostSize = nzyme.getConfiguration().httpMaxPostSize().orElse(52428800); 
        if (maxPostSize < 5242880) { 
            maxPostSize = 5242880;
        }
        server.getServerConfiguration().setMaxPostSize(maxPostSize);
        LOG.info("Configuring web server with a max POST size of <{} byte>.", maxPostSize);
        try {
            server.start();
        } catch (IOException e) {
            throw new RuntimeException("Could not start REST API.", e);
        }
        LOG.info("Started web interface and REST API at [{}]. Access it at: [{}]",
                nzyme.getConfiguration().restListenUri(),
                nzyme.getConfiguration().httpExternalUri());
    }
    public TLSKeyAndCertificate getCertificateInUse() {
        return certificateInUse;
    }
    public void reloadHttpServer(int gracePeriod, TimeUnit tu) {
        Executors.newSingleThreadExecutor().submit(() -> {
            LOG.info("Restarting HTTP server.");
            server.shutdown(gracePeriod, tu);
            initialize();
        });
    }
    public void shutdownNow() {
        server.shutdownNow();
    }
}
package app.nzyme.core.rest.resources.system.authentication.mgmt;
import app.nzyme.core.NzymeNode;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.detection.alerts.DetectionType;
import app.nzyme.core.events.EventEngineImpl;
import app.nzyme.core.events.actions.EventActionUtilities;
import app.nzyme.core.events.db.EventActionEntry;
import app.nzyme.core.events.types.SystemEvent;
import app.nzyme.core.events.types.SystemEventType;
import app.nzyme.core.floorplans.db.TenantLocationEntry;
import app.nzyme.core.floorplans.db.TenantLocationFloorEntry;
import app.nzyme.core.rest.UserAuthenticatedResource;
import app.nzyme.core.rest.authentication.AuthenticatedUser;
import app.nzyme.core.rest.requests.*;
import app.nzyme.core.rest.responses.authentication.SessionDetailsResponse;
import app.nzyme.core.rest.responses.authentication.SessionsListResponse;
import app.nzyme.core.rest.responses.authentication.mgmt.*;
import app.nzyme.core.rest.responses.events.EventActionDetailsResponse;
import app.nzyme.core.rest.responses.events.EventActionsListResponse;
import app.nzyme.core.rest.responses.floorplans.*;
import app.nzyme.core.rest.responses.misc.ErrorResponse;
import app.nzyme.core.rest.responses.subsystems.SubsystemsConfigurationResponse;
import app.nzyme.core.security.authentication.AuthenticationRegistryKeys;
import app.nzyme.core.security.authentication.PasswordHasher;
import app.nzyme.core.security.authentication.db.OrganizationEntry;
import app.nzyme.core.security.authentication.db.TapPermissionEntry;
import app.nzyme.core.security.authentication.db.TenantEntry;
import app.nzyme.core.security.authentication.db.UserEntry;
import app.nzyme.core.security.authentication.roles.Permission;
import app.nzyme.core.security.authentication.roles.Permissions;
import app.nzyme.core.security.sessions.db.SessionEntry;
import app.nzyme.core.security.sessions.db.SessionEntryWithUserDetails;
import app.nzyme.core.subsystems.SubsystemRegistryKeys;
import app.nzyme.core.taps.Tap;
import app.nzyme.core.util.Tools;
import app.nzyme.plugin.Subsystem;
import app.nzyme.plugin.rest.configuration.ConfigurationEntryConstraintValidator;
import app.nzyme.plugin.rest.configuration.ConfigurationEntryResponse;
import app.nzyme.plugin.rest.configuration.ConfigurationEntryValueType;
import app.nzyme.plugin.rest.security.PermissionLevel;
import app.nzyme.plugin.rest.security.RESTSecured;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import com.google.common.io.BaseEncoding;
import com.google.common.io.ByteStreams;
import jakarta.validation.Valid;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bouncycastle.util.encoders.Base64;
import org.glassfish.jersey.media.multipart.FormDataParam;
import org.joda.time.DateTime;
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;
@Path("/api/system/authentication/mgmt/organizations")
@Produces(MediaType.APPLICATION_JSON)
public class OrganizationsResource extends UserAuthenticatedResource {
    private static final Logger LOG = LogManager.getLogger(OrganizationsResource.class);
    @Inject
    private NzymeNode nzyme;
    @GET
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    public Response findAll(@QueryParam("limit") int limit, @QueryParam("offset") int offset) {
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        List<OrganizationDetailsResponse> organizations = Lists.newArrayList();
        for (OrganizationEntry org : nzyme.getAuthenticationService().findAllOrganizations(limit, offset)) {
            organizations.add(organizationEntryToResponse(org));
        }
        long organizationCount = nzyme.getAuthenticationService().countAllOrganizations();
        return Response.ok(OrganizationsListResponse.create(organizationCount, organizations)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{id}")
    public Response find(@Context SecurityContext sc, @PathParam("id") UUID id) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<OrganizationEntry> org = nzyme.getAuthenticationService().findOrganization(id);
        if (org.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(org.get().uuid())) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        return Response.ok(organizationEntryToResponse(org.get())).build();
    }
    @POST
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    public Response create(@Valid CreateOrganizationRequest req) {
        nzyme.getAuthenticationService().createOrganization(
                req.name(),
                req.description()
        );
        return Response.status(Response.Status.CREATED).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/show/{id}")
    public Response update(@PathParam("id") UUID id,
                           @Valid UpdateOrganizationRequest req) {
        Optional<OrganizationEntry> org = nzyme.getAuthenticationService().findOrganization(id);
        if (org.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().updateOrganization(
                id, req.name(), req.description()
        );
        return Response.ok().build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/show/{id}")
    public Response delete(@PathParam("id") UUID id) {
        Optional<OrganizationEntry> org = nzyme.getAuthenticationService().findOrganization(id);
        if (org.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!nzyme.getAuthenticationService().isOrganizationDeletable(org.get())) {
            return Response.status(Response.Status.FORBIDDEN).build();
        }
        nzyme.getAuthenticationService().deleteOrganization(id);
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/show/{id}/subsystems/configuration")
    public Response getOrganizationSubsystemConfiguration(@PathParam("id") UUID id) {
        Optional<OrganizationEntry> org = nzyme.getAuthenticationService().findOrganization(id);
        if (org.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        boolean ethernetAvailable = nzyme.getSubsystems().isEnabled(Subsystem.ETHERNET, null, null);
        boolean dot11Available = nzyme.getSubsystems().isEnabled(Subsystem.DOT11, null, null);
        boolean bluetoothAvailable = nzyme.getSubsystems().isEnabled(Subsystem.BLUETOOTH, null, null);
        SubsystemsConfigurationResponse response = SubsystemsConfigurationResponse.create(
                ethernetAvailable,
                dot11Available,
                bluetoothAvailable,
                ConfigurationEntryResponse.create(
                        SubsystemRegistryKeys.ETHERNET_ENABLED.key(),
                        "Ethernet is enabled",
                        nzyme.getSubsystems().isEnabled(Subsystem.ETHERNET, org.get().uuid(), null),
                        ConfigurationEntryValueType.BOOLEAN,
                        SubsystemRegistryKeys.ETHERNET_ENABLED.defaultValue().orElse(null),
                        SubsystemRegistryKeys.ETHERNET_ENABLED.requiresRestart(),
                        SubsystemRegistryKeys.ETHERNET_ENABLED.constraints().orElse(Collections.emptyList()),
                        "subsystems"
                ),
                ConfigurationEntryResponse.create(
                        SubsystemRegistryKeys.DOT11_ENABLED.key(),
                        "WiFi/802.11 is enabled",
                        nzyme.getSubsystems().isEnabled(Subsystem.DOT11,  org.get().uuid(), null),
                        ConfigurationEntryValueType.BOOLEAN,
                        SubsystemRegistryKeys.DOT11_ENABLED.defaultValue().orElse(null),
                        SubsystemRegistryKeys.DOT11_ENABLED.requiresRestart(),
                        SubsystemRegistryKeys.DOT11_ENABLED.constraints().orElse(Collections.emptyList()),
                        "subsystems"
                ),
                ConfigurationEntryResponse.create(
                        SubsystemRegistryKeys.BLUETOOTH_ENABLED.key(),
                        "Bluetooth is enabled",
                        nzyme.getSubsystems().isEnabled(Subsystem.BLUETOOTH,  org.get().uuid(), null),
                        ConfigurationEntryValueType.BOOLEAN,
                        SubsystemRegistryKeys.BLUETOOTH_ENABLED.defaultValue().orElse(null),
                        SubsystemRegistryKeys.BLUETOOTH_ENABLED.requiresRestart(),
                        SubsystemRegistryKeys.BLUETOOTH_ENABLED.constraints().orElse(Collections.emptyList()),
                        "subsystems"
                )
        );
        return Response.ok(response).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/show/{id}/subsystems/configuration")
    public Response updateOrganizationSubsystemConfiguration(@PathParam("id") UUID id, UpdateConfigurationRequest req) {
        if (req.change().isEmpty()) {
            LOG.info("Empty configuration parameters.");
            return Response.status(422).build();
        }
        Optional<OrganizationEntry> org = nzyme.getAuthenticationService().findOrganization(id);
        if (org.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        for (Map.Entry<String, Object> c : req.change().entrySet()) {
            switch (c.getKey()) {
                case "subsystem_ethernet_enabled":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(SubsystemRegistryKeys.ETHERNET_ENABLED, c)) {
                        return Response.status(422).build();
                    }
                    if (!nzyme.getSubsystems().isEnabled(Subsystem.ETHERNET, null, null)) {
                        return Response.status(Response.Status.FORBIDDEN).build();
                    }
                    break;
                case "subsystem_dot11_enabled":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(SubsystemRegistryKeys.DOT11_ENABLED, c)) {
                        return Response.status(422).build();
                    }
                    if (!nzyme.getSubsystems().isEnabled(Subsystem.DOT11, null, null)) {
                        return Response.status(Response.Status.FORBIDDEN).build();
                    }
                    break;
                case "subsystem_bluetooth_enabled":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(SubsystemRegistryKeys.BLUETOOTH_ENABLED, c)) {
                        return Response.status(422).build();
                    }
                    if (!nzyme.getSubsystems().isEnabled(Subsystem.BLUETOOTH, null, null)) {
                        return Response.status(Response.Status.FORBIDDEN).build();
                    }
                    break;
            }
            nzyme.getDatabaseCoreRegistry().setValue(c.getKey(), c.getValue().toString(), org.get().uuid());
        }
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants")
    public Response findTenantsOfOrganization(@Context SecurityContext sc,
                                              @PathParam("organizationId") UUID organizationId,
                                              @QueryParam("limit") int limit,
                                              @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        Optional<OrganizationEntry> org = nzyme.getAuthenticationService().findOrganization(organizationId);
        if (org.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(org.get().uuid())) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<TenantDetailsResponse> response = Lists.newArrayList();
        for (TenantEntry tenant : nzyme.getAuthenticationService()
                .findAllTenantsOfOrganization(org.get().uuid(), limit, offset)) {
            response.add(tenantEntryToResponse(tenant));
        }
        long tenantsCount = nzyme.getAuthenticationService().countTenantsOfOrganization(org.get());
        return Response.ok(TenantsListResponse.create(tenantsCount, response)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/administrators")
    public Response findAllOrganizationAdministrators(@Context SecurityContext sc,
                                                      @PathParam("organizationId") UUID organizationId,
                                                      @QueryParam("limit") int limit,
                                                      @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        Optional<OrganizationEntry> org = nzyme.getAuthenticationService().findOrganization(organizationId);
        if (org.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(org.get().uuid())) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<UserDetailsResponse> users = Lists.newArrayList();
        for (UserEntry user : nzyme.getAuthenticationService().findAllOrganizationAdministrators(
                org.get().uuid(), limit, offset)) {
            users.add(userEntryToResponse(user, Collections.emptyList(), Collections.emptyList()));
        }
        long orgAdminCount = nzyme.getAuthenticationService().countOrganizationAdministrators(org.get().uuid());
        return Response.ok(UsersListResponse.create(orgAdminCount, users)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/administrators/show/{id}")
    public Response findOrganizationAdministrator(@Context SecurityContext sc,
                                                  @PathParam("organizationId") UUID organizationId,
                                                  @PathParam("id") UUID userId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<UserEntry> orgAdmin = nzyme.getAuthenticationService().findOrganizationAdministrator(
                organizationId, userId);
        if (orgAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        boolean isDeletable = !authenticatedUser.getUserId().equals(userId);
        return Response.ok(OrganizationAdministratorDetailsResponse.create(
                userEntryToResponse(orgAdmin.get(), Collections.emptyList(), Collections.emptyList()), isDeletable
        )).build();
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/administrators")
    public Response createOrganizationAdministrator(@Context SecurityContext sc,
                                                    @PathParam("organizationId") UUID organizationId,
                                                    @Valid CreateUserRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!validateCreateUserRequest(req)) {
            LOG.info("Invalid parameters in create user request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (nzyme.getAuthenticationService().userWithEmailExists(req.email().toLowerCase())) {
            LOG.info("User with email address already exists.");
            return Response.status(Response.Status.UNAUTHORIZED).entity(
                    ErrorResponse.create("Email address already in use.")
            ).build();
        }
        PasswordHasher hasher = new PasswordHasher(nzyme.getMetrics());
        PasswordHasher.GeneratedHashAndSalt hash = hasher.createHash(req.password());
        nzyme.getAuthenticationService().createOrganizationAdministrator(
                organizationId,
                req.name(),
                req.email().toLowerCase(),
                hash
        );
        return Response.status(Response.Status.CREATED).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/administrators/show/{id}")
    public Response editOrganizationAdministrator(@Context SecurityContext sc,
                                                  @PathParam("organizationId") UUID organizationId,
                                                  @PathParam("id") UUID userId,
                                                  @Valid UpdateUserRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<UserEntry> orgAdmin = nzyme.getAuthenticationService().findOrganizationAdministrator(
                organizationId, userId);
        if (orgAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!validateUpdateUserRequest(req)) {
            LOG.info("Invalid parameters in update user request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!orgAdmin.get().email().equals(req.email()) && nzyme.getAuthenticationService().userWithEmailExists(
                req.email().toLowerCase())) {
            LOG.info("User with email address already exists.");
            return Response.status(Response.Status.UNAUTHORIZED).entity(
                    ErrorResponse.create("Email address already in use.")
            ).build();
        }
        nzyme.getAuthenticationService().editUser(
                userId,
                req.name(),
                req.email().toLowerCase()
        );
        return Response.ok().build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/administrators/show/{id}/password")
    public Response editOrganizationAdministratorPassword(@Context SecurityContext sc,
                                                          @PathParam("organizationId") UUID organizationId,
                                                          @PathParam("id") UUID userId,
                                                          @Valid UpdatePasswordRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<UserEntry> orgAdmin = nzyme.getAuthenticationService().findOrganizationAdministrator(
                organizationId, userId);
        if (orgAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!validateUpdatePasswordRequest(req)) {
            LOG.info("Invalid password in update password request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        PasswordHasher hasher = new PasswordHasher(nzyme.getMetrics());
        PasswordHasher.GeneratedHashAndSalt hash = hasher.createHash(req.password());
        nzyme.getAuthenticationService().editUserPassword(
                userId,
                hash
        );
        nzyme.getAuthenticationService().deleteAllSessionsOfUser(userId);
        nzyme.getEventEngine().processEvent(SystemEvent.create(
                SystemEventType.AUTHENTICATION_PASSWORD_CHANGED,
                DateTime.now(),
                "Password of organization administrator [" + orgAdmin.get().email() + "] was changed by administrator."
        ), organizationId, null);
        return Response.ok().build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/administrators/show/{id}")
    public Response deleteOrganizationAdministrator(@Context SecurityContext sc,
                                                    @PathParam("organizationId") UUID organizationId,
                                                    @PathParam("id") UUID userId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (authenticatedUser.getUserId() == userId) {
            LOG.warn("Organization administrators cannot delete themselves.");
            return Response.status(Response.Status.FORBIDDEN).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<UserEntry> orgAdmin = nzyme.getAuthenticationService().findOrganizationAdministrator(
                organizationId, userId);
        if (orgAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().deleteOrganizationAdministrator(organizationId, userId);
        return Response.ok().build();
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/administrators/show/{id}/mfa/reset")
    public Response resetOrganizationAdministratorMFA(@Context SecurityContext sc,
                                                      @PathParam("organizationId") UUID organizationId,
                                                      @PathParam("id") UUID userId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<UserEntry> orgAdmin = nzyme.getAuthenticationService().findOrganizationAdministrator(
                organizationId, userId);
        if (orgAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().resetMFAOfUser(userId);
        LOG.info("Reset MFA credentials of organization administrator [{}] on admin request.",
                orgAdmin.get().email());
        nzyme.getEventEngine().processEvent(SystemEvent.create(
                SystemEventType.AUTHENTICATION_MFA_RESET,
                DateTime.now(),
                "MFA method of organization administrator [" + orgAdmin.get().email() + "] was reset by administrator."
        ), organizationId, null);
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}")
    public Response findTenantOfOrganization(@Context SecurityContext sc,
                                             @PathParam("organizationId") UUID organizationId,
                                             @PathParam("tenantId") UUID tenantId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantEntry> tenant = nzyme.getAuthenticationService().findTenant(tenantId);
        if (tenant.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        return Response.ok(tenantEntryToResponse(tenant.get())).build();
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/")
    public Response createTenant(@Context SecurityContext sc,
                                 @PathParam("organizationId") UUID organizationId,
                                 @Valid CreateTenantRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().createTenant(
                organizationId,
                req.name(),
                req.description(),
                req.sessionTimeoutMinutes(),
                req.sessionInactivityTimeoutMinutes(),
                req.mfaTimeoutMinutes()
        );
        return Response.status(Response.Status.CREATED).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}")
    public Response updateTenant(@Context SecurityContext sc,
                                 @PathParam("organizationId") UUID organizationId,
                                 @PathParam("tenantId") UUID tenantId,
                                 @Valid UpdateTenantRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().updateTenant(
                tenantId,
                req.name(),
                req.description(),
                req.sessionTimeoutMinutes(),
                req.sessionInactivityTimeoutMinutes(),
                req.mfaTimeoutMinutes()
        );
        return Response.ok().build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}")
    public Response deleteTenant(@Context SecurityContext sc,
                                 @PathParam("organizationId") UUID organizationId,
                                 @PathParam("tenantId") UUID tenantId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().deleteTenant(tenantId);
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/subsystems/configuration")
    public Response getTenantSubsystemConfiguration(@Context SecurityContext sc,
                                                    @PathParam("organizationId") UUID organizationId,
                                                    @PathParam("tenantId") UUID tenantId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        boolean ethernetAvailable = nzyme.getSubsystems().isEnabled(Subsystem.ETHERNET, organizationId, null);
        boolean dot11Available = nzyme.getSubsystems().isEnabled(Subsystem.DOT11, organizationId, null);
        boolean bluetoothAvailable = nzyme.getSubsystems().isEnabled(Subsystem.BLUETOOTH, organizationId, null);
        SubsystemsConfigurationResponse response = SubsystemsConfigurationResponse.create(
                ethernetAvailable,
                dot11Available,
                bluetoothAvailable,
                ConfigurationEntryResponse.create(
                        SubsystemRegistryKeys.ETHERNET_ENABLED.key(),
                        "Ethernet is enabled",
                        nzyme.getSubsystems().isEnabled(Subsystem.ETHERNET, organizationId, tenantId),
                        ConfigurationEntryValueType.BOOLEAN,
                        SubsystemRegistryKeys.ETHERNET_ENABLED.defaultValue().orElse(null),
                        SubsystemRegistryKeys.ETHERNET_ENABLED.requiresRestart(),
                        SubsystemRegistryKeys.ETHERNET_ENABLED.constraints().orElse(Collections.emptyList()),
                        "subsystems"
                ),
                ConfigurationEntryResponse.create(
                        SubsystemRegistryKeys.DOT11_ENABLED.key(),
                        "WiFi/802.11 is enabled",
                        nzyme.getSubsystems().isEnabled(Subsystem.DOT11,  organizationId, tenantId),
                        ConfigurationEntryValueType.BOOLEAN,
                        SubsystemRegistryKeys.DOT11_ENABLED.defaultValue().orElse(null),
                        SubsystemRegistryKeys.DOT11_ENABLED.requiresRestart(),
                        SubsystemRegistryKeys.DOT11_ENABLED.constraints().orElse(Collections.emptyList()),
                        "subsystems"
                ),
                ConfigurationEntryResponse.create(
                        SubsystemRegistryKeys.BLUETOOTH_ENABLED.key(),
                        "Bluetooth is enabled",
                        nzyme.getSubsystems().isEnabled(Subsystem.BLUETOOTH,  organizationId, tenantId),
                        ConfigurationEntryValueType.BOOLEAN,
                        SubsystemRegistryKeys.BLUETOOTH_ENABLED.defaultValue().orElse(null),
                        SubsystemRegistryKeys.BLUETOOTH_ENABLED.requiresRestart(),
                        SubsystemRegistryKeys.BLUETOOTH_ENABLED.constraints().orElse(Collections.emptyList()),
                        "subsystems"
                )
        );
        return Response.ok(response).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/subsystems/configuration")
    public Response updateTenantSubsystemConfiguration(@Context SecurityContext sc,
                                                       @PathParam("organizationId") UUID organizationId,
                                                       @PathParam("tenantId") UUID tenantId,
                                                       UpdateConfigurationRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (req.change().isEmpty()) {
            LOG.info("Empty configuration parameters.");
            return Response.status(422).build();
        }
        for (Map.Entry<String, Object> c : req.change().entrySet()) {
            switch (c.getKey()) {
                case "subsystem_ethernet_enabled":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(SubsystemRegistryKeys.ETHERNET_ENABLED, c)) {
                        return Response.status(422).build();
                    }
                    if (!nzyme.getSubsystems().isEnabled(Subsystem.ETHERNET, organizationId, null)) {
                        return Response.status(Response.Status.FORBIDDEN).build();
                    }
                    break;
                case "subsystem_dot11_enabled":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(SubsystemRegistryKeys.DOT11_ENABLED, c)) {
                        return Response.status(422).build();
                    }
                    if (!nzyme.getSubsystems().isEnabled(Subsystem.DOT11, organizationId, null)) {
                        return Response.status(Response.Status.FORBIDDEN).build();
                    }
                    break;
                case "subsystem_bluetooth_enabled":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(SubsystemRegistryKeys.BLUETOOTH_ENABLED, c)) {
                        return Response.status(422).build();
                    }
                    if (!nzyme.getSubsystems().isEnabled(Subsystem.BLUETOOTH, organizationId, null)) {
                        return Response.status(Response.Status.FORBIDDEN).build();
                    }
                    break;
            }
            nzyme.getDatabaseCoreRegistry().setValue(c.getKey(), c.getValue().toString(), organizationId, tenantId);
        }
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users")
    public Response findAllUsersOfTenant(@Context SecurityContext sc,
                                         @PathParam("organizationId") UUID organizationId,
                                         @PathParam("tenantId") UUID tenantId,
                                         @QueryParam("limit") int limit,
                                         @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<UserDetailsResponse> users = Lists.newArrayList();
        for (UserEntry user : nzyme.getAuthenticationService().findAllUsersOfTenant(
                organizationId, tenantId, limit, offset)) {
            users.add(userEntryToResponse(
                    user,
                    nzyme.getAuthenticationService().findPermissionsOfUser(user.uuid()),
                    nzyme.getAuthenticationService().findTapPermissionsOfUser(user.uuid())
            ));
        }
        long userCount = nzyme.getAuthenticationService().countUsersOfTenant(
                nzyme.getAuthenticationService().findTenant(tenantId).get()
        );
        return Response.ok(UsersListResponse.create(userCount, users)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users/show/{userId}")
    public Response findUserOfTenant(@Context SecurityContext sc,
                                     @PathParam("organizationId") UUID organizationId,
                                     @PathParam("tenantId") UUID tenantId,
                                     @PathParam("userId") UUID userId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserOfTenant(organizationId, tenantId, userId);
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        boolean isDeletable = authenticatedUser.getUserId() != userId;
        return Response.ok(UserOfTenantDetailsResponse.create(
                userEntryToResponse(
                        user.get(),
                        nzyme.getAuthenticationService().findPermissionsOfUser(user.get().uuid()),
                        nzyme.getAuthenticationService().findTapPermissionsOfUser(user.get().uuid())
                ),
                isDeletable)
        ).build();
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users")
    public Response createUserOfTenant(@Context SecurityContext sc,
                                       @PathParam("organizationId") UUID organizationId,
                                       @PathParam("tenantId") UUID tenantId,
                                       @Valid CreateUserRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!validateCreateUserRequest(req)) {
            LOG.info("Invalid parameters in create user request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (nzyme.getAuthenticationService().userWithEmailExists(req.email().toLowerCase())) {
            LOG.info("User with email address already exists.");
            return Response.status(Response.Status.UNAUTHORIZED).entity(
                    ErrorResponse.create("Email address already in use.")
            ).build();
        }
        PasswordHasher hasher = new PasswordHasher(nzyme.getMetrics());
        PasswordHasher.GeneratedHashAndSalt hash = hasher.createHash(req.password());
        nzyme.getAuthenticationService().createUserOfTenant(
                organizationId,
                tenantId,
                req.name(),
                req.email().toLowerCase(),
                hash
        );
        return Response.status(Response.Status.CREATED).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users/show/{userId}")
    public Response editUserOfTenant(@Context SecurityContext sc,
                                     @PathParam("organizationId") UUID organizationId,
                                     @PathParam("tenantId") UUID tenantId,
                                     @PathParam("userId") UUID userId,
                                     @Valid UpdateUserRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserOfTenant(organizationId, tenantId, userId);
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!validateUpdateUserRequest(req)) {
            LOG.info("Invalid parameters in update user request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!user.get().email().equals(req.email()) && nzyme.getAuthenticationService().userWithEmailExists(
                req.email().toLowerCase())) {
            LOG.info("User with email address already exists.");
            return Response.status(Response.Status.UNAUTHORIZED).entity(
                    ErrorResponse.create("Email address already in use.")
            ).build();
        }
        nzyme.getAuthenticationService().editUser(
                userId,
                req.name(),
                req.email().toLowerCase()
        );
        return Response.ok().build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users/show/{userId}/taps")
    public Response editUserOfTenantTapPermissions(@Context SecurityContext sc,
                                                   @PathParam("organizationId") UUID organizationId,
                                                   @PathParam("tenantId") UUID tenantId,
                                                   @PathParam("userId") UUID userId,
                                                   UpdateUserTapPermissionsRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserOfTenant(organizationId, tenantId, userId);
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<UUID> requestedPermissions = Lists.newArrayList();
        for (String tap : req.taps()) {
            requestedPermissions.add(UUID.fromString(tap));
        }
        List<UUID> newPermissions = Lists.newArrayList();
        for (TapPermissionEntry tap : nzyme.getAuthenticationService().findAllTapsOfTenant(organizationId, tenantId)) {
            if (requestedPermissions.contains(tap.uuid())) {
                newPermissions.add(tap.uuid());
            }
        }
        nzyme.getAuthenticationService().setUserTapPermissions(user.get().uuid(), newPermissions);
        nzyme.getAuthenticationService().setUserTapPermissionsAllowAll(user.get().uuid(), req.allowAccessAllTenantTaps());
        return Response.ok().build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users/show/{userId}/permissions")
    public Response editUserOfTenantPermissions(@Context SecurityContext sc,
                                                @PathParam("organizationId") UUID organizationId,
                                                @PathParam("tenantId") UUID tenantId,
                                                @PathParam("userId") UUID userId,
                                                UpdateUserPermissionsRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserOfTenant(organizationId, tenantId, userId);
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().setUserPermissions(user.get().uuid(), req.permissions());
        return Response.ok().build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users/show/{userId}")
    public Response deleteUserOfTenant(@Context SecurityContext sc,
                                       @PathParam("organizationId") UUID organizationId,
                                       @PathParam("tenantId") UUID tenantId,
                                       @PathParam("userId") UUID userId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserOfTenant(organizationId, tenantId, userId);
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (authenticatedUser.getUserId() == userId) {
            LOG.warn("User [{}] cannot delete themselves.", user.get().email());
            return Response.status(Response.Status.FORBIDDEN).build();
        }
        nzyme.getAuthenticationService().deleteUserOfTenant(organizationId, tenantId, userId);
        return Response.ok().build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users/show/{userId}/password")
    public Response editUserOfTenantPassword(@Context SecurityContext sc,
                                             @PathParam("organizationId") UUID organizationId,
                                             @PathParam("tenantId") UUID tenantId,
                                             @PathParam("userId") UUID userId,
                                             UpdatePasswordRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserOfTenant(organizationId, tenantId, userId);
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!validateUpdatePasswordRequest(req)) {
            LOG.info("Invalid password in update password request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        PasswordHasher hasher = new PasswordHasher(nzyme.getMetrics());
        PasswordHasher.GeneratedHashAndSalt hash = hasher.createHash(req.password());
        nzyme.getAuthenticationService().editUserPassword(
                userId,
                hash
        );
        nzyme.getAuthenticationService().deleteAllSessionsOfUser(user.get().uuid());
        nzyme.getEventEngine().processEvent(SystemEvent.create(
                SystemEventType.AUTHENTICATION_PASSWORD_CHANGED,
                DateTime.now(),
                "Password of user [" + user.get().email() + "] was changed by administrator."
        ), organizationId, tenantId);
        return Response.ok().build();
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/users/show/{userId}/mfa/reset")
    public Response resetMFAOfUserOfTenant(@Context SecurityContext sc,
                                           @PathParam("organizationId") UUID organizationId,
                                           @PathParam("tenantId") UUID tenantId,
                                           @PathParam("userId") UUID userId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserOfTenant(organizationId, tenantId, userId);
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().resetMFAOfUser(user.get().uuid());
        LOG.info("Reset MFA credentials of user [{}] on admin request.", user.get().email());
        nzyme.getEventEngine().processEvent(SystemEvent.create(
                SystemEventType.AUTHENTICATION_MFA_RESET,
                DateTime.now(),
                "MFA method of user [" + user.get().email() + "] was reset by administrator."
        ), organizationId, tenantId);
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/sessions")
    public Response findAllSessions(@QueryParam("limit") int limit, @QueryParam("offset") int offset) {
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        List<SessionDetailsResponse> sessions = Lists.newArrayList();
        for (SessionEntryWithUserDetails session : nzyme.getAuthenticationService().findAllSessions(limit, offset)) {
            sessions.add(SessionDetailsResponse.create(
                    session.id(),
                    session.organizationId(),
                    session.tenantId(),
                    session.userId(),
                    session.userEmail(),
                    session.userName(),
                    session.isSuperadmin(),
                    session.isOrgadmin(),
                    session.remoteIp(),
                    session.createdAt(),
                    session.lastActivity(),
                    session.mfaValid(),
                    session.mfaRequestedAt()
            ));
        }
        long sessionCount = nzyme.getAuthenticationService().countAllSessions();
        return Response.ok(SessionsListResponse.create(sessionCount, sessions)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/sessions")
    public Response findSessionsOfOrganization(@Context SecurityContext sc,
                                               @PathParam("organizationId") UUID organizationId,
                                               @QueryParam("limit") int limit,
                                               @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if(!organizationExists(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<SessionDetailsResponse> sessions = Lists.newArrayList();
        for (SessionEntryWithUserDetails session : nzyme.getAuthenticationService().findSessionsOfOrganization(
                organizationId, limit, offset)) {
            sessions.add(SessionDetailsResponse.create(
                    session.id(),
                    session.organizationId(),
                    session.tenantId(),
                    session.userId(),
                    session.userEmail(),
                    session.userName(),
                    session.isSuperadmin(),
                    session.isOrgadmin(),
                    session.remoteIp(),
                    session.createdAt(),
                    session.lastActivity(),
                    session.mfaValid(),
                    session.mfaRequestedAt()
            ));
        }
        long sessionCount = nzyme.getAuthenticationService().countSessionsOfOrganization(organizationId);
        return Response.ok(SessionsListResponse.create(sessionCount, sessions)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/sessions")
    public Response findSessionsOfTenant(@Context SecurityContext sc,
                                         @PathParam("organizationId") UUID organizationId,
                                         @PathParam("tenantId") UUID tenantId,
                                         @QueryParam("limit") int limit,
                                         @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<SessionDetailsResponse> sessions = Lists.newArrayList();
        for (SessionEntryWithUserDetails session : nzyme.getAuthenticationService().findSessionsOfTenant(
                organizationId, tenantId, limit, offset)) {
            sessions.add(SessionDetailsResponse.create(
                    session.id(),
                    session.organizationId(),
                    session.tenantId(),
                    session.userId(),
                    session.userEmail(),
                    session.userName(),
                    session.isSuperadmin(),
                    session.isOrgadmin(),
                    session.remoteIp(),
                    session.createdAt(),
                    session.lastActivity(),
                    session.mfaValid(),
                    session.mfaRequestedAt()
            ));
        }
        long sessionCount = nzyme.getAuthenticationService().countSessionsOfTenant(organizationId, tenantId);
        return Response.ok(SessionsListResponse.create(sessionCount, sessions)).build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/sessions/show/{sessionId}")
    public Response invalidateSession(@Context SecurityContext sc,
                                      @PathParam("sessionId") long sessionId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<SessionEntry> session = nzyme.getAuthenticationService()
                .findSessionWithOrWithoutPassedMFAById(sessionId);
        if (session.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserById(session.get().userId());
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(user.get().organizationId())) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().deleteSession(sessionId);
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/taps")
    public Response findAllTapsOfTenant(@Context SecurityContext sc,
                                @PathParam("organizationId") UUID organizationId,
                                @PathParam("tenantId") UUID tenantId,
                                @QueryParam("limit") int limit,
                                @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<TapPermissionDetailsResponse> taps = Lists.newArrayList();
        for (TapPermissionEntry tap : nzyme.getAuthenticationService()
                .findAllTapsOfTenant(organizationId, tenantId, limit, offset)) {
            taps.add(tapPermissionEntryToResponse(tap));
        }
        long tapCount = nzyme.getAuthenticationService().countTapsOfTenant(
                nzyme.getAuthenticationService().findTenant(tenantId).get()
        );
        return Response.ok(TapPermissionsListResponse.create(tapCount, taps)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/taps/show/{tapUuid}")
    public Response findTap(@Context SecurityContext sc,
                            @PathParam("organizationId") UUID organizationId,
                            @PathParam("tenantId") UUID tenantId,
                            @PathParam("tapUuid") UUID tapId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TapPermissionEntry> tap = nzyme.getAuthenticationService().findTap(organizationId, tenantId, tapId);
        if (tap.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        return Response.ok(tapPermissionEntryToResponse(tap.get())).build();
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/taps")
    public Response createTap(@Context SecurityContext sc,
                              @PathParam("organizationId") UUID organizationId,
                              @PathParam("tenantId") UUID tenantId,
                              @Valid CreateTapRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        String secret = RandomStringUtils.random(64, true, true);
        nzyme.getAuthenticationService().createTap(
                organizationId,
                tenantId,
                secret,
                req.name(),
                req.description()
        );
        return Response.status(Response.Status.CREATED).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/taps/show/{tapUuid}")
    public Response editTap(@Context SecurityContext sc,
                            @PathParam("organizationId") UUID organizationId,
                            @PathParam("tenantId") UUID tenantId,
                            @PathParam("tapUuid") UUID tapId,
                            @Valid UpdateTapRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TapPermissionEntry> tap = nzyme.getAuthenticationService().findTap(organizationId, tenantId, tapId);
        if (tap.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().editTap(organizationId, tenantId, tapId, req.name(), req.description());
        return Response.ok().build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/taps/show/{tapUuid}")
    public Response deleteTap(@Context SecurityContext sc,
                              @PathParam("organizationId") UUID organizationId,
                              @PathParam("tenantId") UUID tenantId,
                              @PathParam("tapUuid") UUID tapId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TapPermissionEntry> tap = nzyme.getAuthenticationService().findTap(organizationId, tenantId, tapId);
        if (tap.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().deleteTap(organizationId, tenantId, tapId);
        return Response.ok().build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/taps/show/{tapUuid}/secret/cycle")
    public Response cycleTapSecret(@Context SecurityContext sc,
                                   @PathParam("organizationId") UUID organizationId,
                                   @PathParam("tenantId") UUID tenantId,
                                   @PathParam("tapUuid") UUID tapId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TapPermissionEntry> tap = nzyme.getAuthenticationService().findTap(organizationId, tenantId, tapId);
        if (tap.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        String newSecret = RandomStringUtils.random(64, true, true);
        nzyme.getAuthenticationService().cycleTapSecret(organizationId, tenantId, tapId, newSecret);
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}")
    public Response findTenantLocation(@Context SecurityContext sc,
                                       @PathParam("organizationId") UUID organizationId,
                                       @PathParam("tenantId") UUID tenantId,
                                       @PathParam("locationId") UUID locationId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> result = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (result.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TenantLocationEntry tl = result.get();
        long floorCount = nzyme.getAuthenticationService().countFloorsOfTenantLocation(tl.uuid());
        long tapCount = nzyme.getAuthenticationService().countTapsOfTenantLocation(tl.uuid());
        return Response.ok(TenantLocationDetailsResponse.create(
                tl.uuid(), tl.name(), tl.description(), floorCount, tapCount, tl.createdAt(), tl.updatedAt()
        )).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations")
    public Response findAllTenantLocations(@Context SecurityContext sc,
                                           @PathParam("organizationId") UUID organizationId,
                                           @PathParam("tenantId") UUID tenantId,
                                           @QueryParam("limit") int limit,
                                           @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        long locationCount = nzyme.getAuthenticationService().countAllTenantLocations(organizationId, tenantId);
        List<TenantLocationDetailsResponse> locations = Lists.newArrayList();
        for (TenantLocationEntry tl :
                nzyme.getAuthenticationService().findAllTenantLocations(organizationId, tenantId, limit, offset)) {
            long floorCount = nzyme.getAuthenticationService().countFloorsOfTenantLocation(tl.uuid());
            long tapCount = nzyme.getAuthenticationService().countTapsOfTenantLocation(tl.uuid());
            locations.add(TenantLocationDetailsResponse.create(
                    tl.uuid(), tl.name(), tl.description(), floorCount, tapCount, tl.createdAt(), tl.updatedAt()
            ));
        }
        return Response.ok(TenantLocationListResponse.create(locationCount, locations)).build();
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations")
    public Response createTenantLocation(@Context SecurityContext sc,
                                         @Valid CreateTenantLocationRequest req,
                                         @PathParam("organizationId") UUID organizationId,
                                         @PathParam("tenantId") UUID tenantId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        String description = Strings.isNullOrEmpty(req.description()) ? null : req.description();
        nzyme.getAuthenticationService().createTenantLocation(organizationId, tenantId, req.name(), description);
        return Response.status(Response.Status.CREATED).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}")
    public Response updateTenantLocation(@Context SecurityContext sc,
                                         @Valid UpdateTenantLocationRequest req,
                                         @PathParam("organizationId") UUID organizationId,
                                         @PathParam("tenantId") UUID tenantId,
                                         @PathParam("locationId") UUID locationId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        String description = Strings.isNullOrEmpty(req.description()) ? null : req.description();
        nzyme.getAuthenticationService().updateTenantLocation(location.get().id(), req.name(), description);
        return Response.status(Response.Status.CREATED).build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}")
    public Response deleteTenantLocation(@Context SecurityContext sc,
                                         @PathParam("organizationId") UUID organizationId,
                                         @PathParam("tenantId") UUID tenantId,
                                         @PathParam("locationId") UUID locationId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> result = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (result.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TenantLocationEntry tl = result.get();
        long floorCount = nzyme.getAuthenticationService().countFloorsOfTenantLocation(tl.uuid());
        if (floorCount > 0) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }
        nzyme.getAuthenticationService().deleteTenantLocation(tl.id());
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors")
    public Response findAllFloorsOfTenantLocation(@Context SecurityContext sc,
                                                  @PathParam("organizationId") UUID organizationId,
                                                  @PathParam("tenantId") UUID tenantId,
                                                  @PathParam("locationId") UUID locationId,
                                                  @QueryParam("limit") int limit,
                                                  @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        long floorCount = nzyme.getAuthenticationService().countAllFloorsOfTenantLocation(location.get().uuid());
        List<TenantLocationFloorDetailsResponse> floors = Lists.newArrayList();
        for (TenantLocationFloorEntry floor : nzyme.getAuthenticationService()
                .findAllFloorsOfTenantLocation(location.get().uuid(), limit, offset)) {
            List<TapPositionResponse> tapPositions = Lists.newArrayList();
            for (Tap t : nzyme.getTapManager().findAllTapsOnFloor(organizationId, tenantId, locationId, floor.uuid())) {
                tapPositions.add(TapPositionResponse.create(
                        t.uuid(), t.name(), t.x(), t.y(), t.lastReport(), Tools.isTapActive(t.lastReport())
                ));
            }
            floors.add(TenantLocationFloorDetailsResponse.create(
                    floor.uuid(),
                    floor.locationId(),
                    floor.number(),
                    floor.name() == null ? "Floor " + floor.number() : floor.name(),
                    floor.plan() != null,
                    tapPositions.size(),
                    tapPositions,
                    Tools.round(floor.pathLossExponent(), 1),
                    floor.createdAt(),
                    floor.updatedAt()
            ));
        }
        return Response.ok(TenantLocationFloorListResponse.create(floorCount, floors)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors/show/{floorId}")
    public Response findFloorOfTenantLocation(@Context SecurityContext sc,
                                              @PathParam("organizationId") UUID organizationId,
                                              @PathParam("tenantId") UUID tenantId,
                                              @PathParam("locationId") UUID locationId,
                                              @PathParam("floorId") UUID floorId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationFloorEntry> result = nzyme.getAuthenticationService()
                .findFloorOfTenantLocation(location.get().uuid(), floorId);
        if (result.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TenantLocationFloorEntry floor = result.get();
        List<TapPositionResponse> tapPositions = Lists.newArrayList();
        for (Tap t : nzyme.getTapManager().findAllTapsOnFloor(organizationId, tenantId, locationId, floor.uuid())) {
            tapPositions.add(TapPositionResponse.create(
                    t.uuid(), t.name(), t.x(), t.y(), t.lastReport(), Tools.isTapActive(t.lastReport())
            ));
        }
        return Response.ok(TenantLocationFloorDetailsResponse.create(
                floor.uuid(),
                floor.locationId(),
                floor.number(),
                floor.name() == null ? "Floor " + floor.number() : floor.name(),
                floor.plan() != null,
                tapPositions.size(),
                tapPositions,
                Tools.round(floor.pathLossExponent(), 1),
                floor.createdAt(),
                floor.updatedAt()
        )).build();
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors")
    public Response createFloorOfTenantLocation(@Context SecurityContext sc,
                                                @Valid CreateFloorOfTenantLocationRequest req,
                                                @PathParam("organizationId") UUID organizationId,
                                                @PathParam("tenantId") UUID tenantId,
                                                @PathParam("locationId") UUID locationId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (nzyme.getAuthenticationService().tenantLocationHasFloorWithNumber(location.get().uuid(), req.number())) {
            return Response.status(Response.Status.UNAUTHORIZED).entity(
                    ErrorResponse.create("This location already has a floor with that number.")
            ).build();
        }
        String name = Strings.isNullOrEmpty(req.name()) ? null : req.name();
        nzyme.getAuthenticationService().createFloorOfTenantLocation(
                location.get().uuid(), req.number(), name, Tools.round(req.pathLossExponent(), 1)
        );
        nzyme.getAuthenticationService().updateUpdatedAtOfTenantLocation(location.get().id());
        return Response.status(Response.Status.CREATED).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors/show/{floorId}")
    public Response updateFloorOfTenantLocation(@Context SecurityContext sc,
                                                @Valid UpdateFloorOfTenantLocationRequest req,
                                                @PathParam("organizationId") UUID organizationId,
                                                @PathParam("tenantId") UUID tenantId,
                                                @PathParam("locationId") UUID locationId,
                                                @PathParam("floorId") UUID floorId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationFloorEntry> result = nzyme.getAuthenticationService()
                .findFloorOfTenantLocation(location.get().uuid(), floorId);
        if (result.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TenantLocationFloorEntry floor = result.get();
        if (floor.number() != req.number()
                && nzyme.getAuthenticationService()
                .tenantLocationHasFloorWithNumber(location.get().uuid(), req.number())) {
            return Response.status(Response.Status.UNAUTHORIZED).entity(
                    ErrorResponse.create("This location already has a floor with that number.")
            ).build();
        }
        String name = Strings.isNullOrEmpty(req.name()) ? null : req.name();
        nzyme.getAuthenticationService().updateFloorOfTenantLocation(
                floor.id(), req.number(), name, Tools.round(req.pathLossExponent(), 1)
        );
        nzyme.getAuthenticationService().updateUpdatedAtOfTenantLocation(location.get().id());
        return Response.ok().build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors/show/{floorId}")
    public Response deleteFloorOfTenantLocation(@Context SecurityContext sc,
                                                @Valid UpdateFloorOfTenantLocationRequest req,
                                                @PathParam("organizationId") UUID organizationId,
                                                @PathParam("tenantId") UUID tenantId,
                                                @PathParam("locationId") UUID locationId,
                                                @PathParam("floorId") UUID floorId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationFloorEntry> result = nzyme.getAuthenticationService()
                .findFloorOfTenantLocation(location.get().uuid(), floorId);
        if (result.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TenantLocationFloorEntry floor = result.get();
        for (Tap tap : nzyme.getTapManager().findAllTapsOnFloor(organizationId, tenantId, locationId, floorId)) {
            nzyme.getAuthenticationService().removeTapFromFloor(tap.id(), locationId, floorId);
        }
        nzyme.getAuthenticationService().deleteFloorOfTenantLocation(floor.id());
        nzyme.getAuthenticationService().updateUpdatedAtOfTFloor(floor.id());
        nzyme.getAuthenticationService().updateUpdatedAtOfTenantLocation(location.get().id());
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors/show/{floorId}/plan")
    public Response findFloorPlan(@Context SecurityContext sc,
                                  @PathParam("organizationId") UUID organizationId,
                                  @PathParam("tenantId") UUID tenantId,
                                  @PathParam("locationId") UUID locationId,
                                  @PathParam("floorId") UUID floorId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationFloorEntry> floor = nzyme.getAuthenticationService()
                .findFloorOfTenantLocation(location.get().uuid(), floorId);
        if (floor.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (floor.get().plan() == null) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        ByteArrayInputStream imageBytes = new ByteArrayInputStream(floor.get().plan());
        try {
            BufferedImage image = ImageIO.read(imageBytes);
            return Response.ok(FloorPlanResponse.create(
                    BaseEncoding.base64().encode(
                            floor.get().plan()), image.getWidth(), image.getHeight(), floor.get().planWidthMeters(), floor.get().planLengthMeters()
                    )
            ).build();
        } catch (Exception e) {
            LOG.error("Could not read floor plan image data from database. Floor: {}", floor.get(), e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
    }
    @POST
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors/show/{floorId}/plan")
    public Response uploadFloorPlan(@Context SecurityContext sc,
                                    @FormDataParam("plan") InputStream planFile,
                                    @FormDataParam("width_meters") int widthMeters,
                                    @FormDataParam("length_meters") int lengthMeters,
                                    @PathParam("organizationId") UUID organizationId,
                                    @PathParam("tenantId") UUID tenantId,
                                    @PathParam("locationId") UUID locationId,
                                    @PathParam("floorId") UUID floorId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (widthMeters <= 0 || lengthMeters <= 0) {
            return Response.status(Response.Status.BAD_REQUEST).build();
        }
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationFloorEntry> floor = nzyme.getAuthenticationService()
                .findFloorOfTenantLocation(location.get().uuid(), floorId);
        if (floor.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        byte[] planBytes;
        try {
            planBytes = ByteStreams.limit(planFile, 5242881).readAllBytes();
        } catch (IOException e) {
            LOG.error(e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        if (planBytes.length == 0) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(ErrorResponse.create("Uploaded floor plan file is empty."))
                    .build();
        }
        if (planBytes.length == 5242881) {
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(ErrorResponse.create("Uploaded floor plan file is too large. Maximum file size is 5MB."))
                    .build();
        }
        try {
            BufferedImage image = ImageIO.read(new ByteArrayInputStream(planBytes));
            if (image == null) {
                return Response.status(Response.Status.BAD_REQUEST)
                        .entity(ErrorResponse.create("Could not read image file. Make sure it is a JPG or PNG file."))
                        .build();
            }
            ByteArrayOutputStream pngOut = new ByteArrayOutputStream();
            ImageIO.write(image, "png", pngOut);
            nzyme.getAuthenticationService().writeFloorPlan(
                    floor.get().id(),
                    pngOut.toByteArray(),
                    image.getWidth(),
                    image.getHeight(),
                    widthMeters,
                    lengthMeters
            );
        } catch (Exception e) {
            LOG.warn("Could not process uploaded floor plan file.", e);
            return Response.status(Response.Status.BAD_REQUEST)
                    .entity(ErrorResponse.create("Could not process uploaded floor plan file. Make sure it is a JPG or " +
                            "PNG file."))
                    .build();
        }
        nzyme.getAuthenticationService().updateUpdatedAtOfTenantLocation(location.get().id());
        return Response.status(Response.Status.CREATED).build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors/show/{floorId}/plan")
    public Response deleteFloorPlan(@Context SecurityContext sc,
                                    @PathParam("organizationId") UUID organizationId,
                                    @PathParam("tenantId") UUID tenantId,
                                    @PathParam("locationId") UUID locationId,
                                    @PathParam("floorId") UUID floorId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationFloorEntry> floor = nzyme.getAuthenticationService()
                .findFloorOfTenantLocation(location.get().uuid(), floorId);
        if (floor.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        for (Tap tap : nzyme.getTapManager().findAllTapsOnFloor(organizationId, tenantId, locationId, floorId)) {
            nzyme.getAuthenticationService().removeTapFromFloor(tap.id(), locationId, floorId);
        }
        nzyme.getAuthenticationService().deleteFloorPlan(floor.get().id());
        nzyme.getAuthenticationService().updateUpdatedAtOfTenantLocation(location.get().id());
        return Response.ok().build();
    }
    @PUT
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors/show/{floorId}/plan/taps/show/{tapId}/coords")
    public Response placeTapOnFloor(@Context SecurityContext sc,
                                    @Valid PlaceTapRequest req,
                                    @PathParam("organizationId") UUID organizationId,
                                    @PathParam("tenantId") UUID tenantId,
                                    @PathParam("locationId") UUID locationId,
                                    @PathParam("floorId") UUID floorId,
                                    @PathParam("tapId") UUID tapId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationFloorEntry> floor = nzyme.getAuthenticationService()
                .findFloorOfTenantLocation(location.get().uuid(), floorId);
        if (floor.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TapPermissionEntry> tap = nzyme.getAuthenticationService().findTap(organizationId, tenantId, tapId);
        if (tap.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().placeTapOnFloor(tap.get().id(), locationId, floorId, req.x(), req.y());
        nzyme.getAuthenticationService().updateUpdatedAtOfTFloor(floor.get().id());
        nzyme.getAuthenticationService().updateUpdatedAtOfTenantLocation(location.get().id());
        return Response.status(Response.Status.OK).build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/tenants/show/{tenantId}/locations/show/{locationId}/floors/show/{floorId}/plan/taps/show/{tapId}")
    public Response deleteTapFromFloor(@Context SecurityContext sc,
                                    @PathParam("organizationId") UUID organizationId,
                                    @PathParam("tenantId") UUID tenantId,
                                    @PathParam("locationId") UUID locationId,
                                    @PathParam("floorId") UUID floorId,
                                    @PathParam("tapId") UUID tapId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationAndTenantExists(organizationId, tenantId)) {
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationEntry> location = nzyme.getAuthenticationService()
                .findTenantLocation(locationId, organizationId, tenantId);
        if (location.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TenantLocationFloorEntry> floor = nzyme.getAuthenticationService()
                .findFloorOfTenantLocation(location.get().uuid(), floorId);
        if (floor.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<TapPermissionEntry> tap = nzyme.getAuthenticationService().findTap(organizationId, tenantId, tapId);
        if (tap.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().removeTapFromFloor(tap.get().id(), locationId, floorId);
        nzyme.getAuthenticationService().updateUpdatedAtOfTFloor(floor.get().id());
        nzyme.getAuthenticationService().updateUpdatedAtOfTenantLocation(location.get().id());
        return Response.status(Response.Status.OK).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/events/actions")
    public Response findAllEventActionsOfOrganization(@Context SecurityContext sc,
                                                      @PathParam("organizationId") UUID organizationId,
                                                      @QueryParam("limit") int limit,
                                                      @QueryParam("offset") int offset) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationExists(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        EventEngineImpl eventEngine = (EventEngineImpl) nzyme.getEventEngine();
        long total = eventEngine.countAllEventActionsOfOrganization(organizationId);
        List<EventActionDetailsResponse> events = Lists.newArrayList();
        for (EventActionEntry ea : eventEngine.findAllEventActionsOfOrganization(organizationId, limit, offset)) {
            List<SystemEventType> subscribedSystemEvents = eventEngine
                    .findAllSystemEventTypesActionIsSubscribedTo(ea.uuid());
            List<DetectionType> subscribedDetectionEvents = eventEngine
                    .findAllDetectionEventTypesActionIsSubscribedTo(ea.uuid());
            events.add(EventActionUtilities.eventActionEntryToResponse(
                    ea,
                    subscribedSystemEvents,
                    subscribedDetectionEvents
            ));
        }
        return Response.ok(EventActionsListResponse.create(total, events)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/show/{organizationId}/events/actions/show/{actionId}")
    public Response findEventActionOfOrganization(@Context SecurityContext sc,
                                                  @PathParam("organizationId") UUID organizationId,
                                                  @PathParam("actionId") UUID actionId) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        if (!organizationExists(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!authenticatedUser.isSuperAdministrator() && !authenticatedUser.getOrganizationId().equals(organizationId)) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        EventEngineImpl eventEngine = (EventEngineImpl) nzyme.getEventEngine();
        Optional<EventActionEntry> ea = eventEngine.findEventActionOfOrganization(organizationId, actionId);
        if (ea.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<SystemEventType> subscribedSystemEvents = eventEngine
                .findAllSystemEventTypesActionIsSubscribedTo(ea.get().uuid());
        List<DetectionType> subscribedDetectionEvents = eventEngine
                .findAllDetectionEventTypesActionIsSubscribedTo(ea.get().uuid());
        return Response.ok(EventActionUtilities.eventActionEntryToResponse(
                ea.get(),
                subscribedSystemEvents,
                subscribedDetectionEvents
        )).build();
    }
    @GET
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/global/configuration")
    public Response getGlobalSuperAdministratorConfiguration() {
        int sessionTimeoutMinutes = Integer.parseInt(nzyme.getDatabaseCoreRegistry()
                .getValue(AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.key())
                .orElse(AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.defaultValue().get()));
        int sessionInactivityTimeoutMinutes =  Integer.parseInt(nzyme.getDatabaseCoreRegistry()
                .getValue(AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.key())
                .orElse(AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.defaultValue().get()));
        int mfaTimeoutMinutes =  Integer.parseInt(nzyme.getDatabaseCoreRegistry()
                .getValue(AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.key())
                .orElse(AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.defaultValue().get()));
        SuperadminSettingsResponse response = SuperadminSettingsResponse.create(
                ConfigurationEntryResponse.create(
                        AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.key(),
                        "Session Timeout (minutes)",
                        sessionTimeoutMinutes,
                        ConfigurationEntryValueType.NUMBER,
                        AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.defaultValue().orElse(null),
                        AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.requiresRestart(),
                        AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.constraints().orElse(Collections.emptyList()),
                        "authentication-settings"
                ),
                ConfigurationEntryResponse.create(
                        AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.key(),
                        "Session Inactivity Timeout (minutes)",
                        sessionInactivityTimeoutMinutes,
                        ConfigurationEntryValueType.NUMBER,
                        AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.defaultValue().orElse(null),
                        AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.requiresRestart(),
                        AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.constraints().orElse(Collections.emptyList()),
                        "authentication-settings"
                ),
                ConfigurationEntryResponse.create(
                        AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.key(),
                        "MFA Timeout (minutes)",
                        mfaTimeoutMinutes,
                        ConfigurationEntryValueType.NUMBER,
                        AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.defaultValue().orElse(null),
                        AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.requiresRestart(),
                        AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.constraints().orElse(Collections.emptyList()),
                        "authentication-settings"
                )
        );
        return Response.ok(response).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/global/configuration")
    public Response setGlobalSuperAdministratorConfiguration(@Valid SuperadminSettingsUpdateRequest ur) {
        for (Map.Entry<String, Object> c : ur.change().entrySet()) {
            switch (c.getKey()) {
                case "session_timeout_minutes":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES, c)) {
                        return Response.status(422).build();
                    }
                    break;
                case "session_inactivity_timeout_minutes":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES, c)) {
                        return Response.status(422).build();
                    }
                    break;
                case "mfa_timeout_minutes":
                    if (!ConfigurationEntryConstraintValidator.checkConstraints(AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES, c)) {
                        return Response.status(422).build();
                    }
                    break;
            }
            nzyme.getDatabaseCoreRegistry().setValue(c.getKey(), c.getValue().toString());
        }
         return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/superadmins")
    public Response findAllSuperAdministrators(@QueryParam("limit") int limit, @QueryParam("offset") int offset) {
        if (limit > 250) {
            LOG.warn("Requested limit larger than 250. Not allowed.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        List<UserDetailsResponse> users = Lists.newArrayList();
        for (UserEntry user : nzyme.getAuthenticationService().findAllSuperAdministrators(limit, offset)) {
            users.add(userEntryToResponse(
                    user,
                    Collections.emptyList(),
                    Collections.emptyList())
            );
        }
        long superadminCount = nzyme.getAuthenticationService().countSuperAdministrators();
        return Response.ok(UsersListResponse.create(superadminCount, users)).build();
    }
    @GET
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/superadmins/show/{id}")
    public Response findSuperAdministrator(@Context SecurityContext sc, @PathParam("id") UUID userId) {
        AuthenticatedUser sessionUser = getAuthenticatedUser(sc);
        Optional<UserEntry> superAdmin = nzyme.getAuthenticationService().findSuperAdministrator(userId);
        if (superAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        boolean isDeletable = nzyme.getAuthenticationService().countSuperAdministrators() != 1
                && sessionUser.getUserId() != userId;
        return Response.ok(SuperAdministratorDetailsResponse.create(
                userEntryToResponse(
                        superAdmin.get(),
                        Collections.emptyList(),
                        Collections.emptyList()
                ), isDeletable
        )).build();
    }
    @POST
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/superadmins")
    public Response createSuperAdministrator(@Valid CreateUserRequest req) {
        if (!validateCreateUserRequest(req)) {
            LOG.info("Invalid parameters in create user request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (nzyme.getAuthenticationService().userWithEmailExists(req.email().toLowerCase())) {
            LOG.info("User with email address already exists.");
            return Response.status(Response.Status.UNAUTHORIZED).entity(
                    ErrorResponse.create("Email address already in use.")
            ).build();
        }
        PasswordHasher hasher = new PasswordHasher(nzyme.getMetrics());
        PasswordHasher.GeneratedHashAndSalt hash = hasher.createHash(req.password());
        nzyme.getAuthenticationService().createSuperAdministrator(
                req.name(),
                req.email().toLowerCase(),
                hash
        );
        nzyme.getEventEngine().processEvent(SystemEvent.create(
                SystemEventType.AUTHENTICATION_SUPERADMIN_CREATED,
                DateTime.now(),
                "A new super administrator [" + req.email() + "] was created."
        ), null, null);
        return Response.status(Response.Status.CREATED).build();
    }
    @PUT
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/superadmins/show/{userId}")
    public Response editSuperAdministrator(@PathParam("userId") UUID userId,
                                           @Valid UpdateUserRequest req) {
        Optional<UserEntry> superAdmin = nzyme.getAuthenticationService().findSuperAdministrator(userId);
        if (superAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!validateUpdateUserRequest(req)) {
            LOG.info("Invalid parameters in update user request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        if (!superAdmin.get().email().equals(req.email()) && nzyme.getAuthenticationService().userWithEmailExists(
                req.email().toLowerCase())) {
            LOG.info("User with email address already exists.");
            return Response.status(Response.Status.UNAUTHORIZED).entity(
                    ErrorResponse.create("Email address already in use.")
            ).build();
        }
        nzyme.getAuthenticationService().editUser(
                userId,
                req.name(),
                req.email().toLowerCase()
        );
        return Response.ok().build();
    }
    @PUT
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/superadmins/show/{userId}/password")
    public Response editSuperAdministratorPassword(@Context SecurityContext sc,
                                                   @PathParam("userId") UUID userId,
                                                   UpdatePasswordRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<UserEntry> superAdmin = nzyme.getAuthenticationService().findSuperAdministrator(userId);
        if (superAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        if (!validateUpdatePasswordRequest(req)) {
            LOG.info("Invalid password in update password request.");
            return Response.status(Response.Status.UNAUTHORIZED).build();
        }
        PasswordHasher hasher = new PasswordHasher(nzyme.getMetrics());
        PasswordHasher.GeneratedHashAndSalt hash = hasher.createHash(req.password());
        nzyme.getAuthenticationService().editUserPassword(
                userId,
                hash
        );
        nzyme.getAuthenticationService().deleteAllSessionsOfUser(superAdmin.get().uuid());
        nzyme.getEventEngine().processEvent(SystemEvent.create(
                SystemEventType.AUTHENTICATION_SUPERADMIN_PASSWORD_CHANGED,
                DateTime.now(),
                "Password of super administrator [" + superAdmin.get().email() + "] was changed by [" +
                        authenticatedUser.getEmail() + "]."
        ), null, null);
        return Response.ok().build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/superadmins/show/{id}")
    public Response deleteSuperAdministrator(@Context SecurityContext sc, @PathParam("id") UUID userId) {
        AuthenticatedUser sessionUser = getAuthenticatedUser(sc);
        if (sessionUser.getUserId().equals(userId)) {
            LOG.warn("Super administrators cannot delete themselves.");
            return Response.status(Response.Status.FORBIDDEN).build();
        }
        if (nzyme.getAuthenticationService().countSuperAdministrators() == 1) {
            LOG.warn("Last remaining super administrator cannot be deleted.");
            return Response.status(Response.Status.FORBIDDEN).build();
        }
        Optional<UserEntry> superAdmin = nzyme.getAuthenticationService().findSuperAdministrator(userId);
        if (superAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().deleteSuperAdministrator(userId);
        return Response.ok().build();
    }
    @POST
    @RESTSecured(PermissionLevel.SUPERADMINISTRATOR)
    @Path("/superadmins/show/{id}/mfa/reset")
    public Response resetSuperAdministratorMFA(@Context SecurityContext sc, @PathParam("id") UUID userId) {
        AuthenticatedUser sessionUser = getAuthenticatedUser(sc);
        Optional<UserEntry> superAdmin = nzyme.getAuthenticationService().findSuperAdministrator(userId);
        if (superAdmin.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().resetMFAOfUser(superAdmin.get().uuid());
        LOG.info("Reset MFA credentials of super administrator [{}] on admin request.", superAdmin.get().email());
        nzyme.getEventEngine().processEvent(SystemEvent.create(
                SystemEventType.AUTHENTICATION_SUPERADMIN_MFA_RESET,
                DateTime.now(),
                "MFA method of super administrator [" + superAdmin.get().email() + "] was reset by ["
                        + sessionUser.getEmail() + "]"
        ), null, null);
        return Response.ok().build();
    }
    @GET
    @RESTSecured(PermissionLevel.ORGADMINISTRATOR)
    @Path("/permissions/all")
    public Response getAllPermissions() {
        List<PermissionDetailsResponse> permissions = Lists.newArrayList();
        for (Permission permission : Permissions.ALL.values()) {
            permissions.add(PermissionDetailsResponse.create(
                    permission.id(),
                    permission.name(),
                    permission.description(),
                    permission.respectsTapScope()
            ));
        }
        return Response.ok(PermissionListResponse.create(permissions)).build();
    }
    private OrganizationDetailsResponse organizationEntryToResponse(OrganizationEntry org) {
        return OrganizationDetailsResponse.create(
                org.uuid(),
                org.name(),
                org.description(),
                org.createdAt(),
                org.updatedAt(),
                nzyme.getAuthenticationService().countTenantsOfOrganization(org),
                nzyme.getAuthenticationService().countUsersOfOrganization(org),
                nzyme.getAuthenticationService().countTapsOfOrganization(org),
                nzyme.getAuthenticationService().isOrganizationDeletable(org)
        );
    }
    private TenantDetailsResponse tenantEntryToResponse(TenantEntry t) {
        return TenantDetailsResponse.create(
                t.uuid(),
                t.organizationUuid(),
                t.name(),
                t.description(),
                t.createdAt(),
                t.updatedAt(),
                nzyme.getAuthenticationService().countUsersOfTenant(t),
                nzyme.getAuthenticationService().countTapsOfTenant(t),
                t.sessionTimeoutMinutes(),
                t.sessionInactivityTimeoutMinutes(),
                t.mfaTimeoutMinutes(),
                nzyme.getAuthenticationService().isTenantDeletable(t)
        );
    }
    private UserDetailsResponse userEntryToResponse(UserEntry u, List<String> permissions, List<UUID> tapPermissions) {
        return UserDetailsResponse.create(
                u.uuid(),
                u.organizationId(),
                u.tenantId(),
                u.email(),
                u.name(),
                u.createdAt(),
                u.updatedAt(),
                u.lastActivity(),
                u.lastRemoteIp(),
                u.lastGeoCity(),
                u.lastGeoCountry(),
                u.lastGeoAsn(),
                permissions,
                u.accessAllTenantTaps(),
                tapPermissions,
                u.isLoginThrottled()
        );
    }
    private TapPermissionDetailsResponse tapPermissionEntryToResponse(TapPermissionEntry tpe) {
        String decryptedSecret;
        try {
            decryptedSecret = new String(nzyme.getCrypto().decryptWithClusterKey(Base64.decode(tpe.secret())));
        } catch (Crypto.CryptoOperationException e) {
            throw new RuntimeException("Could not decrypt tap secret.", e);
        }
        return TapPermissionDetailsResponse.create(
                tpe.uuid(),
                tpe.organizationId(),
                tpe.tenantId(),
                tpe.name(),
                tpe.description(),
                decryptedSecret,
                tpe.floorId() != null && tpe.locationId() != null,
                tpe.locationId(),
                tpe.floorId(),
                tpe.floorLocationX(),
                tpe.floorLocationY(),
                tpe.createdAt(),
                tpe.updatedAt(),
                tpe.lastReport(),
                Tools.isTapActive(tpe.lastReport())
        );
    }
    private boolean organizationExists(UUID organizationId) {
        return nzyme.getAuthenticationService().findOrganization(organizationId).isPresent();
    }
    private boolean organizationAndTenantExists(UUID organizationId, UUID tenantId) {
        Optional<OrganizationEntry> org = nzyme.getAuthenticationService().findOrganization(organizationId);
        if (org.isEmpty()) {
            return false;
        }
        Optional<TenantEntry> tenant = nzyme.getAuthenticationService().findTenant(tenantId);
        return tenant.isPresent();
    }
    public static boolean validateCreateUserRequest(CreateUserRequest req) {
        if (req == null) {
            return false;
        }
        if (req.name() == null || req.name().trim().isEmpty()) {
            return false;
        }
        if (req.email() == null || !req.email().toLowerCase().matches("^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$")) {
            return false;
        }
        if (req.password() == null || req.password().length() < 12 || req.password().length() > 128) {
            return false;
        }
        return true;
    }
    private boolean validateUpdateUserRequest(UpdateUserRequest req) {
        if (req == null) {
            return false;
        }
        if (req.name() == null || req.name().trim().isEmpty()) {
            return false;
        }
        if (req.email() == null || !req.email().toLowerCase().matches("^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,}$")) {
            return false;
        }
        return true;
    }
    private boolean validateUpdatePasswordRequest(UpdatePasswordRequest req) {
        if (req == null) {
            return false;
        }
        if (req.password() == null || req.password().length() < 12 || req.password().length() > 128) {
            return false;
        }
        return true;
    }
}
package app.nzyme.core.security.authentication;
import app.nzyme.core.NzymeNode;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.floorplans.db.TenantLocationEntry;
import app.nzyme.core.floorplans.db.TenantLocationFloorEntry;
import app.nzyme.core.integrations.geoip.GeoIpLookupResult;
import app.nzyme.core.security.authentication.db.OrganizationEntry;
import app.nzyme.core.security.authentication.db.TapPermissionEntry;
import app.nzyme.core.security.authentication.db.TenantEntry;
import app.nzyme.core.security.authentication.db.UserEntry;
import app.nzyme.core.security.sessions.db.SessionEntry;
import app.nzyme.core.security.sessions.db.SessionEntryWithUserDetails;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.Lists;
import com.google.common.io.BaseEncoding;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.joda.time.DateTime;
import javax.annotation.Nullable;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
public class AuthenticationService {
    private static final Logger LOG = LogManager.getLogger(AuthenticationService.class);
    public final NzymeNode nzyme;
    public AuthenticationService(NzymeNode nzyme) {
        this.nzyme = nzyme;
    }
    public void initialize() {
        seedDatabase();
        Executors.newSingleThreadScheduledExecutor(
                new ThreadFactoryBuilder()
                        .setNameFormat("session-cleaner-%d")
                        .build()
        ).scheduleAtFixedRate(this::runSessionCleaning, 0, 30, TimeUnit.SECONDS);
    }
    private void seedDatabase() {
        long orgCount = nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_organizations")
                        .mapTo(Long.class)
                        .one()
        );
        if (orgCount > 0) {
            return;
        }
        LOG.info("Creating default organization and tenant.");
        OrganizationEntry organization = createOrganization(
                "Default Organization",
                "The nzyme default organization"
        );
        createTenant(organization.uuid(),
                "Default Tenant",
                "The nzyme default tenant",
                Integer.parseInt(AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.defaultValue().get()),
                Integer.parseInt(AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.defaultValue().get()),
                Integer.parseInt(AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.defaultValue().get())
        );
    }
    public long countSuperAdministrators() {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_users WHERE is_superadmin = true")
                        .mapTo(Long.class)
                        .one()
        );
    }
    public List<UserEntry> findAllSuperAdministrators(int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_users WHERE is_superadmin = true " +
                                "ORDER BY name ASC LIMIT :limit OFFSET :offset")
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(UserEntry.class)
                        .list()
        );
    }
    public Optional<UserEntry> findSuperAdministrator(UUID userId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_users WHERE is_superadmin = true AND uuid = :user_id")
                        .bind("user_id", userId)
                        .mapTo(UserEntry.class)
                        .findOne()
        );
    }
    public UserEntry createSuperAdministrator(String name, String email,PasswordHasher.GeneratedHashAndSalt password) {
        DateTime now = new DateTime();
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("INSERT INTO auth_users(organization_id, tenant_id, email, password, " +
                                "password_salt, name, created_at, updated_at, is_superadmin, is_orgadmin) " +
                                "VALUES(NULL, NULL, :email, :password, :password_salt, :name, " +
                                ":created_at, :updated_at, true, false) RETURNING *")
                        .bind("email", email)
                        .bind("password", password.hash())
                        .bind("password_salt", password.salt())
                        .bind("name", name)
                        .bind("created_at", now)
                        .bind("updated_at", now)
                        .mapTo(UserEntry.class)
                        .one()
        );
    }
    public void deleteSuperAdministrator(UUID userId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_users WHERE is_superadmin = true AND uuid = :user_id")
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public OrganizationEntry createOrganization(String name, String description) {
        DateTime now = DateTime.now();
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("INSERT INTO auth_organizations(name, description, created_at, updated_at) " +
                                "VALUES(:name, :description, :created_at, :updated_at) RETURNING *")
                        .bind("name", name)
                        .bind("description", description)
                        .bind("created_at", now)
                        .bind("updated_at", now)
                        .mapTo(OrganizationEntry.class)
                        .one()
        );
    }
    public List<OrganizationEntry> findAllOrganizations() {
        return findAllOrganizations(Integer.MAX_VALUE, 0);
    }
    public List<OrganizationEntry> findAllOrganizations(int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT uuid, name, description, created_at, updated_at FROM auth_organizations " +
                                "ORDER BY name ASC LIMIT :limit OFFSET :offset")
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(OrganizationEntry.class)
                        .list()
        );
    }
    public long countAllOrganizations() {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_organizations")
                        .mapTo(Long.class)
                        .one()
        );
    }
    public Optional<OrganizationEntry> findOrganization(UUID id) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT uuid, name, description, created_at, updated_at FROM auth_organizations " +
                                "WHERE uuid = :id")
                        .bind("id", id)
                        .mapTo(OrganizationEntry.class)
                        .findOne()
        );
    }
    public void updateOrganization(UUID id, String name, String description) {
        Optional<OrganizationEntry> org = findOrganization(id);
        if (org.isEmpty()) {
            throw new RuntimeException("Organization with ID <" + id + "> does not exist.");
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_organizations SET name = :name, description = :description, " +
                                "updated_at = NOW() WHERE uuid = :id")
                        .bind("name", name)
                        .bind("description", description)
                        .bind("id", id)
                        .execute()
        );
    }
    public void deleteOrganization(UUID id) {
        Optional<OrganizationEntry> org = findOrganization(id);
        if (org.isEmpty()) {
            throw new RuntimeException("Organization with ID <" + id + "> does not exist.");
        }
        if (!isOrganizationDeletable(org.get())) {
            throw new RuntimeException("Organization with ID <" + id + "> cannot be deleted. Cannot have tenants and " +
                    "cannot be last remaining organization.");
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_organizations WHERE uuid = :id")
                        .bind("id", id)
                        .execute()
        );
    }
    public long countTenantsOfOrganization(OrganizationEntry o) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_tenants " +
                                "WHERE organization_id = :organization_id")
                        .bind("organization_id", o.uuid())
                        .mapTo(Long.class)
                        .one()
        );
    }
    public long countUsersOfOrganization(OrganizationEntry o) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_users " +
                                "WHERE organization_id = :organization_id")
                        .bind("organization_id", o.uuid())
                        .mapTo(Long.class)
                        .one()
        );
    }
    public long countTapsOfOrganization(OrganizationEntry o) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM taps " +
                                "WHERE organization_id = :organization_id")
                        .bind("organization_id", o.uuid())
                        .mapTo(Long.class)
                        .one()
        );
    }
    public boolean isOrganizationDeletable(OrganizationEntry org) {
        long organizationTenantCount = countTenantsOfOrganization(org);
        long totalOrganizationsCount = countAllOrganizations();
        return organizationTenantCount == 0 && totalOrganizationsCount > 1;
    }
    public List<UserEntry> findAllOrganizationAdministrators(UUID organizationId, int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_users WHERE is_orgadmin = true AND organization_id = :organization_id " +
                                "ORDER BY name ASC LIMIT :limit OFFSET :offset")
                        .bind("organization_id", organizationId)
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(UserEntry.class)
                        .list()
        );
    }
    public Optional<UserEntry> findOrganizationAdministrator(UUID organizationId, UUID userId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_users " +
                                "WHERE is_orgadmin = true AND organization_id = :organization_id AND uuid = :user_id")
                        .bind("organization_id", organizationId)
                        .bind("user_id", userId)
                        .mapTo(UserEntry.class)
                        .findOne()
        );
    }
    public long countOrganizationAdministrators(UUID organizationId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_users " +
                                "WHERE is_orgadmin = true AND organization_id = :organization_id")
                        .bind("organization_id", organizationId)
                        .mapTo(Long.class)
                        .one()
        );
    }
    public UserEntry createOrganizationAdministrator(UUID organizationId,
                                                     String name,
                                                     String email,
                                                     PasswordHasher.GeneratedHashAndSalt password) {
        DateTime now = new DateTime();
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("INSERT INTO auth_users(organization_id, tenant_id, email, password, " +
                                "password_salt, name, created_at, updated_at, is_superadmin, is_orgadmin) " +
                                "VALUES(:organization_id, NULL, :email, :password, :password_salt, :name, " +
                                ":created_at, :updated_at, false, true) RETURNING *")
                        .bind("organization_id", organizationId)
                        .bind("email", email)
                        .bind("password", password.hash())
                        .bind("password_salt", password.salt())
                        .bind("name", name)
                        .bind("created_at", now)
                        .bind("updated_at", now)
                        .mapTo(UserEntry.class)
                        .one()
        );
    }
    public void deleteOrganizationAdministrator(UUID organizationId, UUID userId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_users " +
                                "WHERE is_orgadmin = true AND organization_id = :organization_id AND uuid = :user_id")
                        .bind("organization_id", organizationId)
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public TenantEntry createTenant(UUID organizationId,
                                    String name,
                                    String description,
                                    int sessionTimeoutMinutes,
                                    int sessionInactivityTimeoutMinutes,
                                    int mfaTimeoutMinutes) {
        DateTime now = DateTime.now();
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("INSERT INTO auth_tenants(organization_id, name, description, " +
                                "session_timeout_minutes, session_inactivity_timeout_minutes, mfa_timeout_minutes, " +
                                "created_at, updated_at) VALUES(:organization_id, :name, :description, " +
                                ":session_timeout_minutes, :session_inactivity_timeout_minutes, :mfa_timeout_minutes, " +
                                ":created_at, :updated_at) RETURNING *")
                        .bind("organization_id", organizationId)
                        .bind("name", name)
                        .bind("description", description)
                        .bind("session_timeout_minutes", sessionTimeoutMinutes)
                        .bind("session_inactivity_timeout_minutes", sessionInactivityTimeoutMinutes)
                        .bind("mfa_timeout_minutes", mfaTimeoutMinutes)
                        .bind("created_at", now)
                        .bind("updated_at", now)
                        .mapTo(TenantEntry.class)
                        .one()
        );
    }
    public List<TenantEntry> findAllTenantsOfOrganization(UUID organizationId) {
        return findAllTenantsOfOrganization(organizationId, Integer.MAX_VALUE, 0);
    }
    public List<TenantEntry> findAllTenantsOfOrganization(UUID organizationId, int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_tenants " +
                                "WHERE organization_id = :organization_id " +
                                "ORDER BY name DESC LIMIT :limit OFFSET :offset")
                        .bind("organization_id", organizationId)
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(TenantEntry.class)
                        .list()
        );
    }
    public Optional<TenantEntry> findTenant(UUID tenantId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_tenants WHERE uuid = :id")
                        .bind("id", tenantId)
                        .mapTo(TenantEntry.class)
                        .findOne()
        );
    }
    public void updateTenant(UUID id,
                             String name,
                             String description,
                             int sessionTimeoutMinutes,
                             int sessionInactivityTimeoutMinutes,
                             int mfaTimeoutMinutes) {
        Optional<TenantEntry> tenant = findTenant(id);
        if (tenant.isEmpty()) {
            throw new RuntimeException("Tenant with ID <" + id + "> does not exist.");
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_tenants SET name = :name, description = :description, " +
                                "session_timeout_minutes = :session_timeout_minutes, " +
                                "session_inactivity_timeout_minutes = :session_inactivity_timeout_minutes, " +
                                "mfa_timeout_minutes = :mfa_timeout_minutes, updated_at = NOW() WHERE uuid = :id")
                        .bind("name", name)
                        .bind("description", description)
                        .bind("session_timeout_minutes", sessionTimeoutMinutes)
                        .bind("session_inactivity_timeout_minutes", sessionInactivityTimeoutMinutes)
                        .bind("mfa_timeout_minutes", mfaTimeoutMinutes)
                        .bind("id", id)
                        .execute()
        );
    }
    public void deleteTenant(UUID id) {
        Optional<TenantEntry> tenant = findTenant(id);
        if (tenant.isEmpty()) {
            throw new RuntimeException("Tenant with ID <" + id + "> does not exist.");
        }
        if (!isTenantDeletable(tenant.get())) {
            throw new RuntimeException("Tenant with ID <" + id + "> cannot be deleted. Cannot have users in it.");
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_tenants WHERE uuid = :id")
                        .bind("id", id)
                        .execute()
        );
    }
    public Optional<UserEntry> findUserOfTenant(UUID organizationId, UUID tenantId, UUID userId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_users WHERE organization_id = :organization_id AND tenant_id = :tenant_id " +
                                "AND uuid = :user_id")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("user_id", userId)
                        .mapTo(UserEntry.class)
                        .findOne()
        );
    }
    public List<UserEntry> findAllUsersOfTenant(UUID organizationId, UUID tenantId, int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_users WHERE organization_id = :organization_id AND tenant_id = :tenant_id " +
                                "ORDER BY name ASC LIMIT :limit OFFSET :offset")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(UserEntry.class)
                        .list()
        );
    }
    public Optional<UserEntry> findUserByEmail(String email) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_users WHERE email = :email")
                        .bind("email", email)
                        .mapTo(UserEntry.class)
                        .findOne()
        );
    }
    public Optional<UserEntry> findUserById(UUID id) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_users WHERE uuid = :id")
                        .bind("id", id)
                        .mapTo(UserEntry.class)
                        .findOne()
        );
    }
    public List<String> findPermissionsOfUser(UUID userId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT permission FROM auth_permissions WHERE user_id = :user_id")
                        .bind("user_id", userId)
                        .mapTo(String.class)
                        .list()
        );
    }
    public List<UUID> findTapPermissionsOfUser(UUID userId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT t.uuid FROM auth_users_taps AS u " +
                                "LEFT JOIN taps t on u.tap_id = t.uuid " +
                                "WHERE u.user_id = :user_id")
                        .bind("user_id", userId)
                        .mapTo(UUID.class)
                        .list()
        );
    }
    public void setUserTapPermissionsAllowAll(UUID userId, boolean allowAccessAllTenantTaps) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET access_all_tenant_taps = :state WHERE uuid = :user_id")
                        .bind("state", allowAccessAllTenantTaps)
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public void setUserTapPermissions(UUID userId, List<UUID> newPermissions) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_users_taps WHERE user_id = :user_id")
                        .bind("user_id", userId)
                        .execute()
        );
        for (UUID tapUuid : newPermissions) {
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("INSERT INTO auth_users_taps(user_id, tap_id) " +
                                    "VALUES(:user_id, :tap_id)")
                            .bind("user_id", userId)
                            .bind("tap_id", tapUuid)
                            .execute()
            );
        }
    }
    public void setUserPermissions(UUID userId, List<String> permissions) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_permissions WHERE user_id = :user_id")
                        .bind("user_id", userId)
                        .execute()
        );
        for (String permission : permissions) {
            nzyme.getDatabase().useHandle(handle ->
                    handle.createUpdate("INSERT INTO auth_permissions(user_id, permission) " +
                                    "VALUES(:user_id, :permission)")
                            .bind("user_id", userId)
                            .bind("permission", permission)
                            .execute()
            );
        }
    }
    public UserEntry createUserOfTenant(UUID organizationId,
                                        UUID tenantId,
                                        String name,
                                        String email,
                                        PasswordHasher.GeneratedHashAndSalt password) {
        DateTime now = new DateTime();
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("INSERT INTO auth_users(organization_id, tenant_id, email, password, " +
                                "password_salt, name, created_at, updated_at, is_superadmin, is_orgadmin) " +
                                "VALUES(:organization_id, :tenant_id, :email, :password, :password_salt, :name, " +
                                ":created_at, :updated_at, false, false) RETURNING *")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("email", email)
                        .bind("password", password.hash())
                        .bind("password_salt", password.salt())
                        .bind("name", name)
                        .bind("created_at", now)
                        .bind("updated_at", now)
                        .mapTo(UserEntry.class)
                        .one()
        );
    }
    public void editUser(UUID userId, String name, String email) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET name = :name, email = :email, updated_at = NOW() " +
                                "WHERE uuid = :user_id")
                        .bind("name", name)
                        .bind("email", email)
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public void editUserPassword(UUID userId, PasswordHasher.GeneratedHashAndSalt password) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET password = :password, password_salt = :password_salt, " +
                        "updated_at = NOW() WHERE uuid = :user_id")
                        .bind("password", password.hash())
                        .bind("password_salt", password.salt())
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public void deleteUserOfTenant(UUID organizationId, UUID tenantId, UUID userId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_users " +
                                "WHERE organization_id = :organization_id AND tenant_id = :tenant_id AND uuid = :user_id")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public void resetMFAOfUser(UUID userId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET mfa_complete = false, " +
                                "totp_secret = NULL, mfa_recovery_codes = NULL WHERE uuid = :user_id")
                        .bind("user_id", userId)
                        .execute()
        );
        deleteAllSessionsOfUser(userId);
    }
    public long countUsersOfTenant(TenantEntry t) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_users WHERE organization_id = :organization_id AND " +
                                "tenant_id = :tenant_id")
                        .bind("organization_id", t.organizationUuid())
                        .bind("tenant_id", t.uuid())
                        .mapTo(Long.class)
                        .one()
        );
    }
    public long countTapsOfTenant(TenantEntry t) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM taps WHERE organization_id = :organization_id AND " +
                                "tenant_id = :tenant_id")
                        .bind("organization_id", t.organizationUuid())
                        .bind("tenant_id", t.uuid())
                        .mapTo(Long.class)
                        .one()
        );
    }
    public boolean userWithEmailExists(String email) {
        if (email == null || email.trim().isEmpty()) {
            throw new RuntimeException("NULL or empty email address.");
        }
        long count = nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_users WHERE email = :email")
                        .bind("email", email.toLowerCase())
                        .mapTo(Long.class)
                        .one()
        );
        return count > 0;
    }
    public void setUserTOTPSecret(UUID userId, String secret) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET totp_secret = :secret WHERE uuid = :user_id")
                        .bind("secret", secret)
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public void setUserMFARecoveryCodes(UUID userId, String recoveryCodes) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET mfa_recovery_codes = :recovery_codes WHERE uuid = :user_id")
                        .bind("recovery_codes", recoveryCodes)
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public Optional<Map<String, Boolean>> getUserMFARecoveryCodes(UUID userId) {
        Optional<String> result = nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT mfa_recovery_codes FROM auth_users WHERE uuid = :user_id")
                        .bind("user_id", userId)
                        .mapTo(String.class)
                        .findOne()
        );
        if (result.isEmpty()) {
            return Optional.empty();
        }
        byte[] encrypted = BaseEncoding.base64().decode(result.get());
        String json;
        try {
            json = new String(nzyme.getCrypto().decryptWithClusterKey(encrypted));
        } catch(Crypto.CryptoOperationException e) {
            throw new RuntimeException("Could not decrypt MFA recovery codes.", e);
        }
        try {
            ObjectMapper om = new ObjectMapper();
            return Optional.of(om.readValue(json, new TypeReference<>() {}));
        } catch (JsonProcessingException e) {
            throw new RuntimeException("Could not parse MFA recovery code JSON.", e);
        }
    }
    public void setUserMFAComplete(UUID userId, boolean complete) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET mfa_complete = :mfa_complete WHERE uuid = :user_id")
                        .bind("mfa_complete", complete)
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public void markUserFailedLogin(UserEntry user) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET failed_login_count = COALESCE(failed_login_count+1, 1) " +
                                "WHERE uuid = :user_id")
                        .bind("user_id", user.uuid())
                        .execute()
        );
    }
    public void markUserSuccessfulLogin(UserEntry user) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET failed_login_count = NULL WHERE uuid = :user_id")
                        .bind("user_id", user.uuid())
                        .execute()
        );
    }
    public void createSession(String sessionId, UUID userId, String remoteIp) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("INSERT INTO auth_sessions(sessionid, user_id, remote_ip, created_at, " +
                                "mfa_valid, mfa_requested_at) VALUES(:sessionid, :user_id, :remote_ip, NOW(), " +
                                "false, NOW())")
                        .bind("sessionid", sessionId)
                        .bind("user_id", userId)
                        .bind("remote_ip", remoteIp)
                        .execute()
        );
    }
    public List<SessionEntryWithUserDetails> findAllSessions(int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT s.id, s.sessionid, s.user_id, s.remote_ip, s.created_at, u.last_activity, " +
                                "u.tenant_id, u.organization_id, u.email, u.name, u.is_superadmin, u.is_orgadmin, " +
                                "s.mfa_valid, s.mfa_requested_at " +
                                "FROM auth_sessions AS s " +
                                "LEFT JOIN auth_users u ON s.user_id = u.uuid " +
                                "ORDER BY u.email ASC " +
                                "LIMIT :limit OFFSET :offset")
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(SessionEntryWithUserDetails.class)
                        .list()
        );
    }
    public List<SessionEntryWithUserDetails> findSessionsOfOrganization(UUID organizationId, int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT s.id, s.sessionid, s.user_id, s.remote_ip, s.created_at, u.last_activity, " +
                                "u.tenant_id, u.organization_id, u.email, u.name, u.is_superadmin, u.is_orgadmin, " +
                                "s.mfa_valid, s.mfa_requested_at " +
                                "FROM auth_sessions AS s " +
                                "LEFT JOIN auth_users u ON s.user_id = u.uuid " +
                                "WHERE u.organization_id = :organization_id " +
                                "ORDER BY u.email ASC " +
                                "LIMIT :limit OFFSET :offset")
                        .bind("organization_id", organizationId)
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(SessionEntryWithUserDetails.class)
                        .list()
        );
    }
    public List<SessionEntryWithUserDetails> findSessionsOfTenant(UUID organizationId, UUID tenantId, int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT s.id, s.sessionid, s.user_id, s.remote_ip, s.created_at, u.last_activity, " +
                                "u.tenant_id, u.organization_id, u.email, u.name, u.is_superadmin, u.is_orgadmin, " +
                                "s.mfa_valid, s.mfa_requested_at " +
                                "FROM auth_sessions AS s " +
                                "LEFT JOIN auth_users u ON s.user_id = u.uuid " +
                                "WHERE u.organization_id = :organization_id AND u.tenant_id = :tenant_id " +
                                "ORDER BY u.email ASC " +
                                "LIMIT :limit OFFSET :offset")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(SessionEntryWithUserDetails.class)
                        .list()
        );
    }
    public Optional<SessionEntry> findSessionWithOrWithoutPassedMFABySessionId(String sessionId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT sessionid, user_id, remote_ip, created_at, elevated, elevated_since, " +
                                "mfa_valid, mfa_requested_at FROM auth_sessions WHERE sessionid = :sessionid")
                        .bind("sessionid", sessionId)
                        .mapTo(SessionEntry.class)
                        .findOne()
        );
    }
    public Optional<SessionEntry> findSessionWithOrWithoutPassedMFAById(long id) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT sessionid, user_id, remote_ip, created_at, elevated, elevated_since, " +
                                "mfa_valid, mfa_requested_at FROM auth_sessions WHERE id = :id")
                        .bind("id", id)
                        .mapTo(SessionEntry.class)
                        .findOne()
        );
    }
    public Optional<SessionEntry> findSessionWithPassedMFABySessionId(String sessionId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT sessionid, user_id, remote_ip, created_at, elevated, elevated_since, " +
                                "mfa_valid, mfa_requested_at " +
                                "FROM auth_sessions WHERE sessionid = :sessionid AND mfa_valid = true")
                        .bind("sessionid", sessionId)
                        .mapTo(SessionEntry.class)
                        .findOne()
        );
    }
    public void markSessionAsMFAValid(String sessionId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_sessions SET mfa_valid = true, mfa_requested_at = NULL " +
                                "WHERE sessionid = :sessionid")
                        .bind("sessionid", sessionId)
                        .execute()
        );
    }
    public void deleteSession(long id) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_sessions WHERE id = :id")
                        .bind("id", id)
                        .execute()
        );
    }
    public long countAllSessions() {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_sessions")
                        .mapTo(Long.class)
                        .one()
        );
    }
    public long countSessionsOfOrganization(UUID organizationId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_sessions AS s " +
                                "LEFT JOIN auth_users u ON s.user_id = u.uuid " +
                                "WHERE u.organization_id = :organization_id")
                        .bind("organization_id", organizationId)
                        .mapTo(Long.class)
                        .one()
        );
    }
    public long countSessionsOfTenant(UUID organizationId, UUID tenantId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_sessions AS s " +
                                "LEFT JOIN auth_users u ON s.user_id = u.uuid " +
                                "WHERE u.organization_id = :organization_id AND u.tenant_id = :tenant_id")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .mapTo(Long.class)
                        .one()
        );
    }
    public void updateLastUserActivity(UUID userId, String remoteIp, @Nullable GeoIpLookupResult remoteIpGeo) {
        String countryCode = remoteIpGeo != null && remoteIpGeo.geo() != null ? remoteIpGeo.geo().countryCode() : null;
        String city = remoteIpGeo != null && remoteIpGeo.geo() != null ? remoteIpGeo.geo().city() : null;
        String asnName = remoteIpGeo != null && remoteIpGeo.asn() != null ? remoteIpGeo.asn().name() : null;;
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET last_activity = NOW(), last_remote_ip = :remote_ip, " +
                                "last_geo_country = :country_code, last_geo_city = :city, last_geo_asn = :asn " +
                                "WHERE uuid = :user_id")
                        .bind("remote_ip", remoteIp)
                        .bind("country_code", countryCode)
                        .bind("city", city)
                        .bind("asn", asnName)
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public void deleteAllSessionsOfUser(UUID userId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_sessions WHERE user_id = :user_id")
                        .bind("user_id", userId)
                        .execute()
        );
    }
    public TapPermissionEntry createTap(UUID organizationId, UUID tenantId, String secret, String name, String description) {
        String encryptedSecret;
        try {
            encryptedSecret = BaseEncoding.base64().encode(nzyme.getCrypto().encryptWithClusterKey(secret.getBytes()));
        } catch (Crypto.CryptoOperationException e) {
            throw new RuntimeException("Could not encrypt tap secret.", e);
        }
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("INSERT INTO taps(uuid, organization_id, tenant_id, secret, name, " +
                                "description, deleted, created_at, updated_at) VALUES(:uuid, :organization_id, :tenant_id, " +
                                ":secret, :name, :description, false, :created_at, :updated_at) RETURNING *")
                        .bind("uuid", UUID.randomUUID())
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("secret", encryptedSecret)
                        .bind("name", name)
                        .bind("description", description)
                        .bind("created_at", DateTime.now())
                        .bind("updated_at", DateTime.now())
                        .mapTo(TapPermissionEntry.class)
                        .one()
        );
    }
    public List<TapPermissionEntry> findAllTapsOfTenant(UUID organizationId, UUID tenantId) {
        return findAllTapsOfTenant(organizationId, tenantId, Integer.MAX_VALUE, 0);
    }
    public List<TapPermissionEntry> findAllTapsOfTenant(UUID organizationId, UUID tenantId, int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM taps " +
                                "WHERE organization_id = :organization_id AND tenant_id = :tenant_id " +
                                "ORDER BY name ASC LIMIT :limit OFFSET :offset")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(TapPermissionEntry.class)
                        .list()
        );
    }
    public Optional<TapPermissionEntry> findTap(UUID organizationId, UUID tenantId, UUID tapId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM taps " +
                                "WHERE organization_id = :organization_id AND tenant_id = :tenant_id " +
                                "AND uuid = :uuid")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("uuid", tapId)
                        .mapTo(TapPermissionEntry.class)
                        .findOne()
        );
    }
    public Optional<TapPermissionEntry> findTapBySecret(String secret) {
        List<TapPermissionEntry> taps = nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM taps")
                        .mapTo(TapPermissionEntry.class)
                        .list()
        );
        for (TapPermissionEntry tap : taps) {
            try {
                String decryptedSecret = new String(
                        nzyme.getCrypto().decryptWithClusterKey(
                                BaseEncoding.base64().decode(tap.secret())
                        )
                );
                if (secret.equals(decryptedSecret)) {
                    return Optional.of(tap);
                }
            } catch (Crypto.CryptoOperationException e) {
                throw new RuntimeException("Could not decrypt tap key.", e);
            }
        }
        return Optional.empty();
    }
    public void deleteTap(UUID organizationId, UUID tenantId, UUID tapId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM taps WHERE organization_id = :organization_id " +
                                "AND tenant_id = :tenant_id AND uuid = :uuid")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("uuid", tapId)
                        .execute()
        );
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_users_taps WHERE tap_id = :uuid")
                        .bind("uuid", tapId)
                        .execute()
        );
    }
    public void editTap(UUID organizationId, UUID tenantId, UUID tapId, String name, String description) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE taps SET name = :name, description = :description, updated_at = NOW() " +
                                "WHERE organization_id = :organization_id AND tenant_id = :tenant_id AND uuid = :uuid")
                        .bind("name", name)
                        .bind("description", description)
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("uuid", tapId)
                        .execute()
        );
    }
    public void cycleTapSecret(UUID organizationId, UUID tenantId, UUID tapId, String newSecret) {
        String encryptedSecret;
        try {
            encryptedSecret = BaseEncoding.base64().encode(nzyme.getCrypto().encryptWithClusterKey(newSecret.getBytes()));
        } catch (Crypto.CryptoOperationException e) {
            throw new RuntimeException("Could not encrypt tap secret.", e);
        }
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE taps SET secret = :secret, updated_at = NOW() " +
                                "WHERE organization_id = :organization_id AND tenant_id = :tenant_id AND uuid = :uuid")
                        .bind("secret", encryptedSecret)
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("uuid", tapId)
                        .execute()
        );
    }
    public List<TenantLocationEntry> findAllTenantLocations(UUID organizationId, UUID tenantId, int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_tenants_locations " +
                                "WHERE organization_id = :organization_id AND tenant_id = :tenant_id " +
                                "ORDER BY name ASC LIMIT :limit OFFSET :offset")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(TenantLocationEntry.class)
                        .list()
        );
    }
    public Optional<TenantLocationEntry> findTenantLocation(UUID locationId, UUID organizationId, UUID tenantId) {
        if (organizationId == null && tenantId == null) {
            return nzyme.getDatabase().withHandle(handle ->
                    handle.createQuery("SELECT * FROM auth_tenants_locations WHERE uuid = :location_id")
                            .bind("location_id", locationId)
                            .mapTo(TenantLocationEntry.class)
                            .findOne()
            );
        }
        if (organizationId != null && tenantId == null) {
            return nzyme.getDatabase().withHandle(handle ->
                    handle.createQuery("SELECT * FROM auth_tenants_locations " +
                                    "WHERE organization_id = :organization_id AND uuid = :location_id")
                            .bind("location_id", locationId)
                            .bind("organization_id", organizationId)
                            .mapTo(TenantLocationEntry.class)
                            .findOne()
            );
        }
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_tenants_locations " +
                                "WHERE organization_id = :organization_id AND tenant_id = :tenant_id " +
                                "AND uuid = :location_id")
                        .bind("location_id", locationId)
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .mapTo(TenantLocationEntry.class)
                        .findOne()
        );
    }
    public long countAllTenantLocations(UUID organizationId, UUID tenantId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_tenants_locations " +
                                "WHERE organization_id = :organization_id AND tenant_id = :tenant_id")
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .mapTo(Long.class)
                        .one()
        );
    }
    public void createTenantLocation(UUID organizationId, UUID tenantId, String name, @Nullable String description) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("INSERT INTO auth_tenants_locations(uuid, organization_id, tenant_id, name, " +
                                "description, created_at, updated_at) VALUES(:uuid, :organization_id, :tenant_id, " +
                                ":name, :description, NOW(), NOW())")
                        .bind("uuid", UUID.randomUUID())
                        .bind("organization_id", organizationId)
                        .bind("tenant_id", tenantId)
                        .bind("name", name)
                        .bind("description", description)
                        .execute()
        );
    }
    public void updateTenantLocation(long locationId, String name, @Nullable String description) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_tenants_locations SET name = :name, description = :description, " +
                                "updated_at = NOW() WHERE id = :id")
                        .bind("uuid", UUID.randomUUID())
                        .bind("id", locationId)
                        .bind("name", name)
                        .bind("description", description)
                        .execute()
        );
    }
    public void deleteTenantLocation(long locationId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_tenants_locations WHERE id = :id")
                        .bind("uuid", UUID.randomUUID())
                        .bind("id", locationId)
                        .execute()
        );
    }
    public void updateUpdatedAtOfTenantLocation(long locationId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_tenants_locations SET updated_at = NOW() WHERE id = :id")
                        .bind("id", locationId)
                        .execute()
        );
    }
    public long countFloorsOfTenantLocation(UUID locationId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_tenants_locations_floors WHERE location_id = :id")
                        .bind("id", locationId)
                        .mapTo(Long.class)
                        .one()
        );
    }
    public long countTapsOfTenantLocation(UUID locationId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM taps WHERE location_uuid = :id")
                        .bind("id", locationId)
                        .mapTo(Long.class)
                        .one()
        );
    }
    public List<TenantLocationFloorEntry> findAllFloorsOfTenantLocation(UUID locationId, int limit, int offset) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_tenants_locations_floors " +
                                "WHERE location_id = :location_id " +
                                "ORDER BY number ASC LIMIT :limit OFFSET :offset")
                        .bind("location_id", locationId)
                        .bind("limit", limit)
                        .bind("offset", offset)
                        .mapTo(TenantLocationFloorEntry.class)
                        .list()
        );
    }
    public Optional<TenantLocationFloorEntry> findFloorOfTenantLocation(UUID locationId, UUID floorId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT * FROM auth_tenants_locations_floors " +
                                "WHERE uuid = :uuid AND location_id = :location_id")
                        .bind("uuid", floorId)
                        .bind("location_id", locationId)
                        .mapTo(TenantLocationFloorEntry.class)
                        .findOne()
        );
    }
    public void createFloorOfTenantLocation(UUID locationId, long number, @Nullable String name, float pathLossExponent) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("INSERT INTO auth_tenants_locations_floors(uuid, location_id, number, name, " +
                                "path_loss_exponent, created_at, updated_at) VALUES(:uuid, :location_id, :number, " +
                                ":name, :path_loss_exponent, NOW(), NOW())")
                        .bind("uuid", UUID.randomUUID())
                        .bind("location_id", locationId)
                        .bind("number", number)
                        .bind("name", name)
                        .bind("path_loss_exponent", pathLossExponent)
                        .execute()
        );
    }
    public long countAllFloorsOfTenantLocation(UUID locationId) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_tenants_locations_floors " +
                                "WHERE location_id = :location_id")
                        .bind("location_id", locationId)
                        .mapTo(Long.class)
                        .one()
        );
    }
    public boolean tenantLocationHasFloorWithNumber(UUID locationId, long number) {
        return nzyme.getDatabase().withHandle(handle ->
                handle.createQuery("SELECT COUNT(*) FROM auth_tenants_locations_floors " +
                                "WHERE location_id = :location_id AND number = :number")
                        .bind("location_id", locationId)
                        .bind("number", number)
                        .mapTo(Long.class)
                        .one()
        ) > 0;
    }
    public void updateFloorOfTenantLocation(long floorId, long number, @Nullable String name, float pathLossExponent) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_tenants_locations_floors SET number = :number, name = :name, " +
                                "path_loss_exponent = :path_loss_exponent, updated_at = NOW() WHERE id = :id")
                        .bind("number", number)
                        .bind("name", name)
                        .bind("path_loss_exponent", pathLossExponent)
                        .bind("id", floorId)
                        .execute()
        );
    }
    public void deleteFloorOfTenantLocation(long floorId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("DELETE FROM auth_tenants_locations_floors WHERE id = :id")
                        .bind("id", floorId)
                        .execute()
        );
    }
    public void writeFloorPlan(long floorId, byte[] plan, int widthPixels, int lengthPixels, int widthMeters, int lengthMeters) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_tenants_locations_floors SET plan = :plan, " +
                                "plan_width_pixels = :width_pixels, plan_length_pixels = :length_pixels, " +
                                "plan_width_meters = :width_meters, plan_length_meters = :length_meters, " +
                                "updated_at = NOW() WHERE id = :id")
                        .bind("plan", plan)
                        .bind("width_pixels", widthPixels)
                        .bind("length_pixels", lengthPixels)
                        .bind("width_meters", widthMeters)
                        .bind("length_meters", lengthMeters)
                        .bind("id", floorId)
                        .execute()
        );
    }
    public void deleteFloorPlan(long floorId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_tenants_locations_floors SET plan = NULL, plan_width = NULL, " +
                                "plan_height = NULL, updated_at = NOW() WHERE id = :id")
                        .bind("id", floorId)
                        .execute()
        );
    }
    public void placeTapOnFloor(long tapId, UUID locationId, UUID floorId, int x, int y) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE taps SET location_uuid = :location_id, floor_uuid = :floor_id, " +
                                "floor_location_x = :x, floor_location_y = :y WHERE id = :tap_id")
                        .bind("tap_id", tapId)
                        .bind("location_id", locationId)
                        .bind("floor_id", floorId)
                        .bind("x", x)
                        .bind("y", y)
                        .execute()
        );
    }
    public void removeTapFromFloor(long tapId, UUID locationId, UUID floorId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE taps SET location_uuid = NULL, floor_uuid = NULL, " +
                                "floor_location_x = NULL, floor_location_y = NULL " +
                                "WHERE location_uuid = :location_id AND floor_uuid = :floor_id AND id = :tap_id")
                        .bind("tap_id", tapId)
                        .bind("location_id", locationId)
                        .bind("floor_id", floorId)
                        .execute()
        );
    }
    public void updateUpdatedAtOfTFloor(long floorId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_tenants_locations_floors SET updated_at = NOW() WHERE id = :id")
                        .bind("id", floorId)
                        .execute()
        );
    }
    public void setUserDefaultTenant(UUID userId, @Nullable UUID organizationId, @Nullable UUID tenantId) {
        nzyme.getDatabase().useHandle(handle ->
                handle.createUpdate("UPDATE auth_users SET default_organization = :organization_uuid, " +
                                "default_tenant = :tenant_uuid WHERE uuid = :uuid")
                        .bind("organization_uuid", organizationId)
                        .bind("tenant_uuid", tenantId)
                        .bind("uuid", userId)
                        .execute()
        );
    }
    private void runSessionCleaning() {
        List<UUID> sessionsToClean = Lists.newArrayList();
        try {
            int sessionTimeoutMinutes = Integer.parseInt(nzyme.getDatabaseCoreRegistry()
                    .getValue(AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.key())
                    .orElse(AuthenticationRegistryKeys.SESSION_TIMEOUT_MINUTES.defaultValue().get()));
            int sessionInactivityTimeoutMinutes = Integer.parseInt(nzyme.getDatabaseCoreRegistry()
                    .getValue(AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.key())
                    .orElse(AuthenticationRegistryKeys.SESSION_INACTIVITY_TIMEOUT_MINUTES.defaultValue().get()));
            int mfaTimeoutMinutes = Integer.parseInt(nzyme.getDatabaseCoreRegistry()
                    .getValue(AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.key())
                    .orElse(AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.defaultValue().get()));
            sessionsToClean.addAll(
                    nzyme.getDatabase().withHandle(handle ->
                            handle.createQuery("SELECT u.uuid FROM auth_users AS u " +
                                            "LEFT JOIN auth_sessions AS s ON s.user_id = u.uuid " +
                                            "WHERE (u.is_orgadmin = true OR u.is_superadmin = true) " +
                                            "AND (s.created_at < :session_timeout OR (s.mfa_valid = true " +
                                            "AND u.last_activity < :inactivity_timeout) OR (s.mfa_valid = false " +
                                            "AND s.mfa_requested_at < :mfa_timeout))")
                                    .bind("session_timeout", DateTime.now().minusMinutes(sessionTimeoutMinutes))
                                    .bind("inactivity_timeout", DateTime.now().minusMinutes(sessionInactivityTimeoutMinutes))
                                    .bind("mfa_timeout", DateTime.now().minusMinutes(mfaTimeoutMinutes))
                                    .mapTo(UUID.class)
                                    .list()
                    )
            );
        } catch(Exception e) {
            LOG.error("Could not determine sessions of super admins and org admins to clean.", e);
        }
        try {
            for (OrganizationEntry organization : findAllOrganizations(Integer.MAX_VALUE, 0)) {
                for (TenantEntry tenant : findAllTenantsOfOrganization(organization.uuid())) {
                    sessionsToClean.addAll(
                            nzyme.getDatabase().withHandle(handle ->
                                    handle.createQuery("SELECT u.uuid FROM auth_users AS u " +
                                                    "LEFT JOIN auth_sessions AS s ON s.user_id = u.uuid " +
                                                    "WHERE u.organization_id = :organization_id " +
                                                    "AND u.tenant_id = :tenant_id " +
                                                    "AND (s.created_at < :session_timeout OR (s.mfa_valid = true " +
                                                    "AND u.last_activity < :inactivity_timeout) " +
                                                    "OR (s.mfa_valid = false AND s.mfa_requested_at < :mfa_timeout))")
                                            .bind("organization_id", organization.uuid())
                                            .bind("tenant_id", tenant.uuid())
                                            .bind("session_timeout", DateTime.now().minusMinutes(tenant.sessionTimeoutMinutes()))
                                            .bind("inactivity_timeout", DateTime.now().minusMinutes(tenant.sessionInactivityTimeoutMinutes()))
                                            .bind("mfa_timeout", DateTime.now().minusMinutes(tenant.mfaTimeoutMinutes()))
                                            .mapTo(UUID.class)
                                            .list()
                            )
                    );
                }
            }
        } catch(Exception e) {
            LOG.error("Could not determine sessions of tenant users to clean.", e);
        }
        if (!sessionsToClean.isEmpty()) {
            try {
                nzyme.getDatabase().useHandle(handle ->
                        handle.createUpdate("DELETE FROM auth_sessions WHERE user_id IN (<user_ids>)")
                                .bindList("user_ids", sessionsToClean)
                                .execute()
                );
            } catch(Exception e) {
                LOG.error("Could not delete sessions marked for deletion.", e);
            }
        }
    }
    public boolean isTenantDeletable(TenantEntry t) {
        return countTapsOfTenant(t) == 0 && countUsersOfTenant(t) == 0;
    }
}
package app.nzyme.core.crypto.tls;
import com.google.common.base.CharMatcher;
import com.google.common.base.Joiner;
import com.google.common.base.Splitter;
import com.google.common.collect.Lists;
import com.google.common.io.BaseEncoding;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;
import org.bouncycastle.openssl.PEMKeyPair;
import org.bouncycastle.openssl.PEMParser;
import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
import org.joda.time.DateTime;
import javax.xml.bind.DatatypeConverter;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.math.BigInteger;
import java.security.*;
import java.security.cert.*;
import java.security.cert.Certificate;
import java.security.spec.*;
import java.util.Iterator;
import java.util.List;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class TLSUtils {
    private static final Pattern CERT_BASE64_BLOCKS = Pattern.compile(
            "-+BEGIN\\s+.*CERTIFICATE[^-]*-+(?:\\s|\\r|\\n)+" +
                    "([a-z0-9+/=\\r\\n]+)" +
                    "-+END\\s+.*CERTIFICATE[^-]*-+",
            Pattern.CASE_INSENSITIVE);
    private static final Pattern KEY_BASE64_BLOCK = Pattern.compile(
            "-+BEGIN\\s+.*PRIVATE\\s+KEY[^-]*-+(?:\\s|\\r|\\n)+" +
                    "([a-z0-9+/=\\r\\n]+)" +
                    "-+END\\s+.*PRIVATE\\s+KEY[^-]*-+",
            Pattern.CASE_INSENSITIVE);
    public static List<X509Certificate> readCertificateChainFromPEM(String pem) throws PEMParserException {
        final Matcher m = CERT_BASE64_BLOCKS.matcher(pem);
        final List<X509Certificate> certs = Lists.newArrayList();
        int pos = 0;
        while (m.find(pos)) {
            byte[] bytes = BaseEncoding.base64().decode(
                    CharMatcher
                            .breakingWhitespace()
                            .removeFrom(m.group(1))
            );
            try {
                CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
                certs.add((X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(bytes)));
            } catch(Exception e) {
                throw new PEMParserException("Could not construct certificate.", e);
            }
            pos = m.end();
        }
        if (certs.isEmpty()) {
            throw new PEMParserException("Could not find any certificates in certificate file.");
        }
        return certs;
    }
    public static PrivateKey readKeyFromPEM(String pem) throws PEMParserException {
        final Matcher m = KEY_BASE64_BLOCK.matcher(pem);
        if (!m.find()) {
            throw new PEMParserException("No key found in data.");
        }
        return parseKey(
                BaseEncoding.base64().decode(
                        CharMatcher
                                .breakingWhitespace()
                                .removeFrom(m.group(1)))
        );
    }
    public static PrivateKey deserializeKey(String base64) throws PEMParserException {
        return parseKey(BaseEncoding.base64().decode(base64));
    }
    public static PrivateKey parseKey(byte[] bytes) throws PEMParserException {
        try {
            return parsePKCS8Key(bytes);
        } catch (Exception ignored) {
            try {
                return parsePKCS1Key(bytes);
            } catch (Exception e) {
                throw new PEMParserException("Parsing key failed. Both PKCS#1 and PKCS#8 parsing did not succeed.", e);
            }
        }
    }
    private static PrivateKey parsePKCS8Key(byte[] bytes) throws PEMParserException, NoSuchAlgorithmException {
        KeySpec keySpec = new PKCS8EncodedKeySpec(bytes);
        try {
            return KeyFactory.getInstance("RSA").generatePrivate(keySpec);
        } catch (InvalidKeySpecException ignore) {
            try {
                return KeyFactory.getInstance("DSA").generatePrivate(keySpec);
            } catch (InvalidKeySpecException ignore2) {
                try {
                    return KeyFactory.getInstance("EC").generatePrivate(keySpec);
                } catch (InvalidKeySpecException e) {
                    throw new PEMParserException("Could not construct private key.", e);
                }
            }
        }
    }
    private static PrivateKey parsePKCS1Key(byte[] bytes) throws IOException {
        String key = reconstructECPEMFromBytes(bytes);
        Object parsed = new PEMParser(new StringReader(key)).readObject();
        KeyPair pair = new JcaPEMKeyConverter().getKeyPair((PEMKeyPair) parsed);
        return pair.getPrivate();
    }
    private static String reconstructECPEMFromBytes(byte[] bytes) {
        Iterable<String> split = Splitter.fixedLength(64)
                .split(BaseEncoding.base64().encode(bytes));
        StringBuilder result = new StringBuilder();
        result.append("-----BEGIN EC PRIVATE KEY-----\n");
        for (String s : split) {
            result.append(s).append("\n");
        }
        result.append("-----END EC PRIVATE KEY-----");
        return result.toString();
    }
    public static String serializeCertificateChain(List<X509Certificate> certificates) throws CertificateEncodingException {
        List<String> strings = Lists.newArrayList();
        for (Certificate certificate : certificates) {
            strings.add(BaseEncoding.base64().encode(certificate.getEncoded()));
        }
        return Joiner.on(",").join(strings);
    }
    public static List<X509Certificate> deSerializeCertificateChain(String serialized) throws CertificateException {
        List<X509Certificate> certificates = Lists.newArrayList();
        for (String s : Splitter.on(",").split(serialized)) {
            byte[] certBytes = BaseEncoding.base64().decode(s);
            CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
            certificates.add((X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(certBytes)));
        }
        return certificates;
    }
    public static String calculateTLSCertificateFingerprint(X509Certificate certificate) throws NoSuchAlgorithmException, CertificateEncodingException {
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        md.update(certificate.getEncoded());
        return DatatypeConverter.printHexBinary(md.digest()).toLowerCase();
    }
    public static TLSKeyAndCertificate readTLSKeyAndCertificateFromInputStreams(UUID nodeId,
                                                                                TLSSourceType sourceType,
                                                                                InputStream certificate,
                                                                                InputStream privateKey) throws TLSCertificateCreationException {
        String certificateInput, keyInput;
        try {
            certificateInput = new String(certificate.readAllBytes());
            keyInput = new String(privateKey.readAllBytes());
        } catch (Exception e) {
            throw new RuntimeException("Could not read provided TLS certificate form data.", e);
        }
        List<X509Certificate> certificates;
        PrivateKey key;
        try {
            certificates = TLSUtils.readCertificateChainFromPEM(certificateInput);
            key = TLSUtils.readKeyFromPEM(keyInput);
        } catch(Exception e) {
            throw new TLSCertificateCreationException("Could not build key/certificate from provided data.", e);
        }
        X509Certificate firstCert = certificates.get(0);
        String fingerprint;
        try {
            fingerprint = TLSUtils.calculateTLSCertificateFingerprint(firstCert);
        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {
            throw new TLSCertificateCreationException("Could not build certificate fingerprint.", e);
        }
        return TLSKeyAndCertificate.create(
                nodeId,
                sourceType,
                certificates,
                key,
                fingerprint,
                new DateTime(firstCert.getNotBefore()),
                new DateTime(firstCert.getNotAfter())
        );
    }
    public static TLSWildcardKeyAndCertificate readTLSWildcardKeyAndCertificateFromInputStreams(String nodeMatcher,
                                                                                                TLSSourceType sourceType,
                                                                                                InputStream certificate,
                                                                                                InputStream privateKey)
            throws TLSCertificateCreationException {
        String certificateInput, keyInput;
        try {
            certificateInput = new String(certificate.readAllBytes());
            keyInput = new String(privateKey.readAllBytes());
        } catch (Exception e) {
            throw new RuntimeException("Could not read provided TLS certificate form data.", e);
        }
        List<X509Certificate> certificates;
        PrivateKey key;
        try {
            certificates = TLSUtils.readCertificateChainFromPEM(certificateInput);
            key = TLSUtils.readKeyFromPEM(keyInput);
        } catch(Exception e) {
            throw new TLSCertificateCreationException("Could not build key/certificate from provided data.", e);
        }
        X509Certificate firstCert = certificates.get(0);
        String fingerprint;
        try {
            fingerprint = TLSUtils.calculateTLSCertificateFingerprint(firstCert);
        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {
            throw new TLSCertificateCreationException("Could not build certificate fingerprint.", e);
        }
        return TLSWildcardKeyAndCertificate.create(
                null,
                nodeMatcher,
                sourceType,
                certificates,
                key,
                fingerprint,
                new DateTime(firstCert.getNotBefore()),
                new DateTime(firstCert.getNotAfter())
        );
    }
    public static final class PEMParserException extends Exception {
        public PEMParserException(String msg) {
            super(msg);
        }
        public PEMParserException(String msg, Throwable t) {
            super(msg, t);
        }
    }
    public static final class TLSCertificateCreationException extends Exception {
        public TLSCertificateCreationException(String msg, Throwable t) {
            super(msg, t);
        }
    }
}
package app.nzyme.core;
import app.nzyme.core.bluetooth.Bluetooth;
import app.nzyme.core.bluetooth.sig.BluetoothSigService;
import app.nzyme.core.cache.CacheManager;
import app.nzyme.core.connect.ConnectService;
import app.nzyme.core.context.ContextService;
import app.nzyme.core.database.DataCategory;
import app.nzyme.core.database.DataTableInformation;
import app.nzyme.core.database.tasks.handlers.GlobalPurgeCategoryTaskHandler;
import app.nzyme.core.database.tasks.handlers.OrganizationPurgeCategoryTaskHandler;
import app.nzyme.core.database.tasks.handlers.TenantPurgeCategoryTaskHandler;
import app.nzyme.core.detection.alerts.DetectionAlertService;
import app.nzyme.core.distributed.ClusterManager;
import app.nzyme.core.distributed.NodeManager;
import app.nzyme.core.distributed.messaging.postgres.PostgresMessageBusImpl;
import app.nzyme.core.distributed.tasksqueue.postgres.PostgresTasksQueueImpl;
import app.nzyme.core.dot11.Dot11;
import app.nzyme.core.dot11.monitoring.Dot11SignalTrackMonitor;
import app.nzyme.core.dot11.monitoring.clients.KnownClientMonitor;
import app.nzyme.core.dot11.monitoring.disco.Dot11DiscoMonitor;
import app.nzyme.core.dot11.monitoring.ssids.KnownSSIDMonitor;
import app.nzyme.core.ethernet.EthernetConnectionCleaner;
import app.nzyme.core.events.EventEngine;
import app.nzyme.core.events.EventEngineImpl;
import app.nzyme.core.integrations.geoip.GeoIpService;
import app.nzyme.core.monitoring.health.HealthMonitor;
import app.nzyme.core.ouis.OuiService;
import app.nzyme.core.periodicals.connect.ConnectStatusReporter;
import app.nzyme.core.context.ContextCleaner;
import app.nzyme.core.periodicals.distributed.NodeUpdater;
import app.nzyme.core.registry.RegistryChangeMonitorImpl;
import app.nzyme.core.rest.server.NzymeHttpServer;
import app.nzyme.core.security.authentication.AuthenticationService;
import app.nzyme.core.subsystems.Subsystems;
import app.nzyme.plugin.*;
import app.nzyme.plugin.distributed.messaging.MessageBus;
import app.nzyme.plugin.distributed.tasksqueue.*;
import app.nzyme.plugin.retro.RetroService;
import com.codahale.metrics.Gauge;
import com.codahale.metrics.MetricRegistry;
import com.codahale.metrics.jmx.JmxReporter;
import com.codahale.metrics.jvm.*;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.Lists;
import app.nzyme.core.configuration.base.BaseConfiguration;
import app.nzyme.core.configuration.node.NodeConfiguration;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.database.DatabaseImpl;
import app.nzyme.core.ethernet.Ethernet;
import app.nzyme.core.periodicals.PeriodicalManager;
import app.nzyme.core.periodicals.versioncheck.VersioncheckThread;
import app.nzyme.core.plugin.loading.PluginLoader;
import app.nzyme.core.registry.RegistryImpl;
import app.nzyme.core.tables.TablesService;
import app.nzyme.core.taps.TapManager;
import app.nzyme.core.util.MetricNames;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.Nullable;
import java.io.File;
import java.nio.file.Path;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
public class NzymeNodeImpl implements NzymeNode {
    private static final Logger LOG = LogManager.getLogger(NzymeNodeImpl.class);
    private final Version version;
    private final NodeIdentification nodeIdentification;
    private final NodeConfiguration configuration;
    private final BaseConfiguration baseConfiguration;
    private final Path dataDirectory;
    private final DatabaseImpl database;
    private final AuthenticationService authenticationService;
    private final RegistryImpl registry;
    private final RegistryChangeMonitor registryChangeMonitor;
    private final Subsystems subsystems;
    private final NodeManager nodeManager;
    private final ClusterManager clusterManager;
    private final NzymeHttpServer httpServer;
    private final MetricRegistry metrics;
    private final TapManager tapManager;
    private final MessageBus messageBus;
    private final TasksQueue tasksQueue;
    private final GeoIpService geoIpService;
    private final OuiService ouiService;
    private final BluetoothSigService bluetoothSigService;
    private final ContextService contextService;
    private final Ethernet ethernet;
    private final Dot11 dot11;
    private final Bluetooth bluetooth;
    private final TablesService tablesService;
    private final ObjectMapper objectMapper;
    private final DetectionAlertService detectionAlertService;
    private final EventEngine eventEngine;
    private final ConnectService connect;
    private final HealthMonitor healthMonitor;
    private List<String> plugins;
    private Optional<RetroService> retroService = Optional.empty();
    private final Crypto crypto;
    private final List<Object> pluginRestResources;
    public NzymeNodeImpl(BaseConfiguration baseConfiguration, NodeConfiguration configuration, DatabaseImpl database) {
        this.baseConfiguration = baseConfiguration;
        this.version = new Version();
        this.dataDirectory = Path.of(baseConfiguration.dataDirectory());
        this.metrics = new MetricRegistry();
        this.database = database;
        this.configuration = configuration;
        this.registry = new RegistryImpl(this, "core");
        this.registryChangeMonitor = new RegistryChangeMonitorImpl(this);
        this.authenticationService = new AuthenticationService(this);
        this.subsystems = new Subsystems(this);
        this.nodeManager = new NodeManager(this);
        try {
            this.nodeManager.initialize();
            this.nodeIdentification = NodeIdentification.create(nodeManager.getLocalNodeId(), baseConfiguration.name());
            this.nodeManager.registerSelf();
        } catch (NodeManager.NodeInitializationException e) {
            throw new RuntimeException("Could not initialize distributed subsystem.", e);
        }
        this.clusterManager = new ClusterManager(this);
        this.messageBus = new PostgresMessageBusImpl(this);
        this.tasksQueue = new PostgresTasksQueueImpl(this);
        this.geoIpService = new GeoIpService(this);
        this.ouiService = new OuiService(this);
        this.bluetoothSigService = new BluetoothSigService(this);
        this.contextService = new ContextService(this);
        this.pluginRestResources = Lists.newArrayList();
        this.plugins = Lists.newArrayList();
        this.httpServer = new NzymeHttpServer(this, this.pluginRestResources);
        this.ethernet = new Ethernet(this);
        this.dot11 = new Dot11(this);
        this.bluetooth = new Bluetooth(this);
        this.tapManager = new TapManager(this);
        this.crypto = new Crypto(this);
        this.objectMapper = new ObjectMapper();
        this.connect = new ConnectService(this);
        this.healthMonitor = new HealthMonitor(this);
        this.metrics.register("gc", new GarbageCollectorMetricSet());
        this.metrics.register("classes", new ClassLoadingGaugeSet());
        this.metrics.register("fds", new FileDescriptorRatioGauge());
        this.metrics.register("jvm", new JvmAttributeGaugeSet());
        this.metrics.register("mem", new MemoryUsageGaugeSet());
        this.metrics.register("threadstates", new ThreadStatesGaugeSet());
        this.detectionAlertService = new DetectionAlertService(this);
        this.eventEngine = new EventEngineImpl(this);
        this.tablesService = new TablesService(this);
    }
    @Override
    public void initialize() {
        LOG.info("Initializing nzyme version: {}.", version.getVersionString());
        LOG.info("Initializing cluster manager...");
        this.clusterManager.initialize();
        LOG.info("Done.");
        LOG.info("Initializing message bus [{}] ...", this.messageBus.getClass().getCanonicalName());
        this.messageBus.initialize();
        LOG.info("Done.");
        LOG.info("Initializing tasks queue [{}] ...", this.tasksQueue.getClass().getCanonicalName());
        this.tasksQueue.initialize();
        LOG.info("Done.");
        this.tasksQueue.onMessageReceived(
                TaskType.PURGE_DATA_CATEGORY_GLOBAL,
                new GlobalPurgeCategoryTaskHandler(this)
        );
        this.tasksQueue.onMessageReceived(
                TaskType.PURGE_DATA_CATEGORY_ORGANIZATION,
                new OrganizationPurgeCategoryTaskHandler(this)
        );
        this.tasksQueue.onMessageReceived(
                TaskType.PURGE_DATA_CATEGORY_TENANT,
                new TenantPurgeCategoryTaskHandler(this)
        );
        try {
            this.crypto.initialize();
        } catch (Crypto.CryptoInitializationException e) {
            throw new RuntimeException("Could not load cryptographic subsystem.", e);
        }
        if (configuration.connectSkip()) {
            LOG.warn("Connect has been disabled in configuration file. Not connecting.");
        }
        LOG.info("Initializing Geo IP service...");
        this.geoIpService.initialize();
        LOG.info("Done.");
        LOG.info("Initializing OUI service...");
        this.ouiService.initialize();
        LOG.info("Done.");
        LOG.info("Initializing Bluetooth SIG service...");
        this.bluetoothSigService.initialize();
        LOG.info("Done.");
        LOG.info("Initializing authentication service...");
        this.authenticationService.initialize();
        LOG.info("Done.");
        final JmxReporter reporter = JmxReporter.forRegistry(metrics).build();
        reporter.start();
        metrics.register(MetricNames.DATABASE_SIZE, (Gauge<Long>) database::getTotalSize);
        PeriodicalManager periodicalManager = new PeriodicalManager();
        periodicalManager.scheduleAtFixedRate(new NodeUpdater(this), 0, 5, TimeUnit.SECONDS);
        periodicalManager.scheduleAtFixedRate(new ConnectStatusReporter(this), 0, 1, TimeUnit.MINUTES);
        periodicalManager.scheduleAtFixedRate(new EthernetConnectionCleaner(this), 0, 1, TimeUnit.MINUTES);
        periodicalManager.scheduleAtFixedRate(new Dot11SignalTrackMonitor(this), 1, 1, TimeUnit.MINUTES);
        periodicalManager.scheduleAtFixedRate(new Dot11DiscoMonitor(this), 1, 1, TimeUnit.MINUTES);
        periodicalManager.scheduleAtFixedRate(new ContextCleaner(getContextService()), 0, 1, TimeUnit.MINUTES);
        periodicalManager.scheduleAtFixedRate(new KnownSSIDMonitor(this), 1, 1, TimeUnit.MINUTES);
        periodicalManager.scheduleAtFixedRate(new KnownClientMonitor(this), 1, 1, TimeUnit.MINUTES);
        if (configuration.versionchecksEnabled()) {
            periodicalManager.scheduleAtFixedRate(new VersioncheckThread(version, this), 0, 60, TimeUnit.MINUTES);
        } else {
            LOG.info("Versionchecks are disabled.");
        }
        healthMonitor.initialize();
        PluginLoader pl = new PluginLoader(new File(configuration.pluginDirectory())); 
        for (Plugin plugin : pl.loadPlugins()) {
            LOG.info("Initializing plugin of type [{}]: [{}] ...", plugin.getClass().getCanonicalName(), plugin.getName());
            try {
                plugin.initialize(this, getDatabaseRegistry(plugin.getId()), this, this);
            } catch(Exception e) {
                LOG.error("Could not load plugin. Skipping.", e);
                continue;
            }
            this.plugins.add(plugin.getId());
            LOG.info("Done.");
        }
        CacheManager cacheManager = new CacheManager(this);
        cacheManager.initialize();
        java.util.logging.Logger.getLogger("org.glassfish.grizzly").setLevel(Level.SEVERE);
        java.util.logging.Logger.getLogger("org.glassfish.jersey.internal.inject.Providers").setLevel(Level.SEVERE);
        this.httpServer.initialize();
    }
    public void shutdown() {
        LOG.info("Shutting down.");
        if (httpServer != null) {
            LOG.info("Stopping REST API.");
            httpServer.shutdownNow();
        }
        LOG.info("Shutdown complete.");
    }
    @Override
    public NodeManager getNodeManager() {
        return nodeManager;
    }
    @Override
    public ClusterManager getClusterManager() {
        return clusterManager;
    }
    @Override
    public MessageBus getMessageBus() {
        return messageBus;
    }
    @Override
    public TasksQueue getTasksQueue() {
        return tasksQueue;
    }
    @Override
    public AuthenticationService getAuthenticationService() {
        return authenticationService;
    }
    @Override
    public Subsystems getSubsystems() {
        return subsystems;
    }
    @Override
    public HealthMonitor getHealthMonitor() {
        return healthMonitor;
    }
    @Override
    public Ethernet getEthernet() {
        return ethernet;
    }
    @Override
    public Dot11 getDot11() {
        return dot11;
    }
    @Override
    public Bluetooth getBluetooth() {
        return bluetooth;
    }
    @Override
    public GeoIpService getGeoIpService() {
        return geoIpService;
    }
    @Override
    public OuiService getOuiService() {
        return ouiService;
    }
    @Override
    public BluetoothSigService getBluetoothSigService() {
        return bluetoothSigService;
    }
    @Override
    public ContextService getContextService() {
        return contextService;
    }
    @Override
    public EventEngine getEventEngine() {
        return eventEngine;
    }
    @Override
    public TapManager getTapManager() {
        return tapManager;
    }
    @Override
    public TablesService getTablesService() {
        return tablesService;
    }
    @Override
    public List<String> getInitializedPlugins() {
        return plugins;
    }
    @Nullable
    @Override
    public Optional<RetroService> retroService() {
        return retroService;
    }
    @Override
    public Crypto getCrypto() {
        return crypto;
    }
    @Override
    public ObjectMapper getObjectMapper() {
        return objectMapper;
    }
    @Override
    public NodeConfiguration getConfiguration() {
        return configuration;
    }
    @Override
    public BaseConfiguration getBaseConfiguration() {
        return baseConfiguration;
    }
    @Override
    public Path getDataDirectory() {
        return dataDirectory;
    }
    @Override
    public MetricRegistry getMetrics() {
        return metrics;
    }
    @Override
    public Database getDatabase() {
        return database;
    }
    @Override
    public Version getVersion() {
        return version;
    }
    @Override
    public NzymeHttpServer getHttpServer() {
        return httpServer;
    }
    @Override
    public void registerRetroService(RetroService service) {
        if (this.retroService.isPresent()) {
            LOG.error("Attempt to register a new RetroService but one already exists. Aborting.");
            return;
        }
        this.retroService = Optional.of(service);
    }
    @Override
    public void registerRestResource(Object resource) {
        this.pluginRestResources.add(resource);
    }
    public Registry getDatabaseRegistry(String namespace) {
        return new RegistryImpl(this, namespace);
    }
    @Override
    public Registry getDatabaseCoreRegistry() {
        return registry;
    }
    @Override
    public RegistryChangeMonitor getRegistryChangeMonitor() {
        return registryChangeMonitor;
    }
    @Override
    public DetectionAlertService getDetectionAlertService() {
        return detectionAlertService;
    }
    @Override
    public ConnectService getConnect() {
        return connect;
    }
    @Override
    public NodeIdentification getNodeInformation() {
        return nodeIdentification;
    }
}
package app.nzyme.core.crypto.tls;
import com.google.auto.value.AutoValue;
import org.joda.time.DateTime;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.List;
import java.util.UUID;
@AutoValue
public abstract class TLSKeyAndCertificate {
    public abstract UUID nodeId();
    public abstract TLSSourceType sourceType();
    public abstract List<X509Certificate> certificates();
    public abstract PrivateKey key();
    public abstract String signature();
    public abstract DateTime validFrom();
    public abstract DateTime expiresAt();
    public static TLSKeyAndCertificate create(UUID nodeId, TLSSourceType sourceType, List<X509Certificate> certificates, PrivateKey key, String signature, DateTime validFrom, DateTime expiresAt) {
        return builder()
                .nodeId(nodeId)
                .sourceType(sourceType)
                .certificates(certificates)
                .key(key)
                .signature(signature)
                .validFrom(validFrom)
                .expiresAt(expiresAt)
                .build();
    }
    public static Builder builder() {
        return new AutoValue_TLSKeyAndCertificate.Builder();
    }
    @AutoValue.Builder
    public abstract static class Builder {
        public abstract Builder nodeId(UUID nodeId);
        public abstract Builder sourceType(TLSSourceType sourceType);
        public abstract Builder certificates(List<X509Certificate> certificates);
        public abstract Builder key(PrivateKey key);
        public abstract Builder signature(String signature);
        public abstract Builder validFrom(DateTime validFrom);
        public abstract Builder expiresAt(DateTime expiresAt);
        public abstract TLSKeyAndCertificate build();
    }
}
package app.nzyme.core;
import app.nzyme.core.bluetooth.Bluetooth;
import app.nzyme.core.bluetooth.sig.BluetoothSigService;
import app.nzyme.core.configuration.base.BaseConfiguration;
import app.nzyme.core.connect.ConnectService;
import app.nzyme.core.context.ContextService;
import app.nzyme.core.detection.alerts.DetectionAlertService;
import app.nzyme.core.distributed.ClusterManager;
import app.nzyme.core.distributed.NodeManager;
import app.nzyme.core.dot11.Dot11;
import app.nzyme.core.events.EventEngine;
import app.nzyme.core.integrations.geoip.GeoIpService;
import app.nzyme.core.monitoring.health.HealthMonitor;
import app.nzyme.core.ouis.OuiService;
import app.nzyme.core.rest.server.NzymeHttpServer;
import app.nzyme.core.security.authentication.AuthenticationService;
import app.nzyme.core.subsystems.Subsystems;
import app.nzyme.plugin.*;
import app.nzyme.plugin.distributed.messaging.MessageBus;
import app.nzyme.plugin.distributed.tasksqueue.TasksQueue;
import app.nzyme.plugin.retro.RetroService;
import com.codahale.metrics.MetricRegistry;
import com.fasterxml.jackson.databind.ObjectMapper;
import app.nzyme.core.configuration.node.NodeConfiguration;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.ethernet.Ethernet;
import app.nzyme.core.tables.TablesService;
import app.nzyme.core.taps.TapManager;
import java.nio.file.Path;
import java.util.List;
import java.util.Optional;
public interface NzymeNode extends PluginEntryPoint, DatabaseProvider, NodeIdentificationProvider, MetricsRegistryProvider {
    void initialize();
    void shutdown();
    NodeManager getNodeManager();
    ClusterManager getClusterManager();
    MessageBus getMessageBus();
    TasksQueue getTasksQueue();
    AuthenticationService getAuthenticationService();
    Subsystems getSubsystems();
    HealthMonitor getHealthMonitor();
    Ethernet getEthernet();
    Dot11 getDot11();
    Bluetooth getBluetooth();
    ContextService getContextService();
    NodeConfiguration getConfiguration();
    BaseConfiguration getBaseConfiguration();
    Path getDataDirectory();
    MetricRegistry getMetrics();
    Database getDatabase();
    EventEngine getEventEngine();
    TapManager getTapManager();
    TablesService getTablesService();
    GeoIpService getGeoIpService();
    OuiService getOuiService();
    BluetoothSigService getBluetoothSigService();
    List<String> getInitializedPlugins();
    Optional<RetroService> retroService();
    Crypto getCrypto();
    ObjectMapper getObjectMapper();
    Registry getDatabaseCoreRegistry();
    RegistryChangeMonitor getRegistryChangeMonitor();
    DetectionAlertService getDetectionAlertService();
    ConnectService getConnect();
    Version getVersion();
    NzymeHttpServer getHttpServer();
}
package app.nzyme.core.monitoring.health.indicators;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.monitoring.health.Indicator;
import app.nzyme.core.monitoring.health.db.IndicatorStatus;
public class CryptoSyncIndicator extends Indicator {
    private final Crypto crypto;
    public CryptoSyncIndicator(Crypto crypto) {
        this.crypto = crypto;
    }
    @Override
    protected IndicatorStatus doRun() {
        return crypto.allPGPKeysEqualAcrossCluster()
                ? IndicatorStatus.green(this) : IndicatorStatus.red(this);
    }
    @Override
    public String getId() {
        return "crypto_sync";
    }
    @Override
    public String getName() {
        return "Crypto Sync";
    }
}
package app.nzyme.core.util;
import app.nzyme.core.bluetooth.sig.BluetoothSigService;
import app.nzyme.core.context.ContextService;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.database.DatabaseImpl;
import app.nzyme.core.integrations.geoip.GeoIpService;
import app.nzyme.core.ouis.OuiService;
import app.nzyme.core.rest.interceptors.TapTableSizeInterceptor;
import app.nzyme.core.security.authentication.PasswordHasher;
import app.nzyme.core.tables.bluetooth.BluetoothTable;
import app.nzyme.core.tables.dns.DNSTable;
import app.nzyme.core.tables.dot11.Dot11Table;
import app.nzyme.core.tables.socks.SOCKSTable;
import app.nzyme.core.tables.ssh.SSHTable;
import app.nzyme.core.tables.tcp.TCPTable;
import static com.codahale.metrics.MetricRegistry.name;
public class MetricNames {
    public static final String OUI_LOOKUP_TIMING = name(OuiService.class, "lookup-timing");
    public static final String BTSIG_CID_LOOKUP_TIMING = name(BluetoothSigService.class, "company-id-lookup-timing");
    public static final String BTSIG_SUUID_LOOKUP_TIMING = name(BluetoothSigService.class, "service-uuid-lookup-timing");
    public static final String DATABASE_SIZE = name(DatabaseImpl.class, "size");
    public static final String GEOIP_CACHE_SIZE = name(GeoIpService.class, "cache-size");
    public static final String GEOIP_LOOKUP_TIMING_UNCACHED = name(GeoIpService.class, "lookup-timing-uncached");
    public static final String PGP_ENCRYPTION_TIMING = name(Crypto.class, "encryption-timing");
    public static final String PGP_DECRYPTION_TIMING = name(Crypto.class, "decryption-timing");
    public static final String PASSWORD_HASHING_TIMER = name(PasswordHasher.class, "hashing-timer");
    public static final String TAP_TABLE_REQUEST_SIZES = name(TapTableSizeInterceptor.class, "request_size");
    public static final String CONTEXT_MAC_CACHE_SIZE = name(ContextService.class, "mac-cache-size");
    public static final String CONTEXT_MAC_LOOKUP_TIMING = name(ContextService.class, "mac-lookup-timing");
    public static final String DOT11_TOTAL_REPORT_PROCESSING_TIMER = name(Dot11Table.class, "total-report-processing-timing");
    public static final String DOT11_BSSID_REPORT_PROCESSING_TIMER = name(Dot11Table.class, "bssid-report-processing-timing");
    public static final String DOT11_CLIENTS_REPORT_PROCESSING_TIMER = name(Dot11Table.class, "clients-report-processing-timing");
    public static final String DOT11_DISCO_REPORT_PROCESSING_TIMER = name(Dot11Table.class, "disco-report-processing-timing");
    public static final String DOT11_ALERT_PROCESSING_TIMER = name(Dot11Table.class, "alert-processing-timing");
    public static final String BLUETOOTH_TOTAL_REPORT_PROCESSING_TIMER = name(BluetoothTable.class, "total-report-processing-timing");
    public static final String DNS_TOTAL_REPORT_PROCESSING_TIMER = name(DNSTable.class, "total-report-processing-timing");
    public static final String DNS_STATISTICS_REPORT_PROCESSING_TIMER = name(DNSTable.class, "statistics-report-processing-timing");
    public static final String DNS_PAIRS_REPORT_PROCESSING_TIMER = name(DNSTable.class, "pairs-report-processing-timing");
    public static final String DNS_LOG_REPORT_PROCESSING_TIMER = name(DNSTable.class, "log-report-processing-timing");
    public static final String DNS_ENTROPY_REPORT_PROCESSING_TIMER = name(DNSTable.class, "entropy-report-processing-timing");
    public static final String TCP_TOTAL_REPORT_PROCESSING_TIMER = name(TCPTable.class, "total-report-processing-timing");
    public static final String TCP_SESSIONS_REPORT_PROCESSING_TIMER = name(TCPTable.class, "sessions-report-processing-timing");
    public static final String TCP_SESSION_DISCOVERY_QUERY_TIMER = name(TCPTable.class, "session-discovery-query-timing");
    public static final String SOCKS_TOTAL_REPORT_PROCESSING_TIMER = name(SOCKSTable.class, "total-report-processing-timing");
    public static final String SSH_TOTAL_REPORT_PROCESSING_TIMER = name(SSHTable.class, "total-report-processing-timing");
}
package app.nzyme.core.crypto.pgp;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.plugin.distributed.messaging.MessageHandler;
import app.nzyme.plugin.distributed.messaging.MessageProcessingResult;
import app.nzyme.plugin.distributed.messaging.ReceivedMessage;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.io.BaseEncoding;
import com.google.common.io.Files;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Paths;
public class PGPKeyMessageBusReceiver implements MessageHandler {
    private static final Logger LOG = LogManager.getLogger(PGPKeyMessageBusReceiver.class);
    private final Crypto crypto;
    private final File cryptoDirectoryConfig;
    private final ObjectMapper om;
    public PGPKeyMessageBusReceiver(File cryptoDirectory, Crypto crypto) {
        this.crypto = crypto;
        this.cryptoDirectoryConfig = cryptoDirectory;
        this.om = new ObjectMapper();
    }
    @Override
    public MessageProcessingResult handle(ReceivedMessage message) {
        try {
            if (!crypto.isPGPKeySyncEnabled()) {
                LOG.warn("PGP sync is disabled. Not reading keys.");
                return MessageProcessingResult.FAILURE;
            }
            LOG.info("Received [{}] from [{}].", message.type(), message.sender());
            PGPKeyMessagePayload payload = om.readValue(message.parametersString(), PGPKeyMessagePayload.class);
            byte[] privateKey, publicKey;
            try(InputStream privateKeyIn = new ByteArrayInputStream(crypto.getNodeLocalPGPKeys().privateKey()); InputStream privateKeyIn2 = new ByteArrayInputStream(crypto.getNodeLocalPGPKeys().privateKey())) {
                privateKey = crypto.decrypt(BaseEncoding.base64().decode(payload.privateKey()), privateKeyIn);
                publicKey = crypto.decrypt((BaseEncoding.base64().decode(payload.publicKey())), privateKeyIn2);
            } catch (Crypto.CryptoOperationException e) {
                throw new RuntimeException("Could not decrypt and decode received keys.", e);
            }
            LOG.info("Received keys decrypted and decoded.");
            File privateKeyLocation = Paths.get(cryptoDirectoryConfig.toString(),
                    Crypto.PGP_PRIVATE_KEY_FILE_NAME).toFile();
            File publicKeyLocation = Paths.get(cryptoDirectoryConfig.toString(),
                    Crypto.PGP_PUBLIC_KEY_FILE_NAME).toFile();
            Files.write(privateKey, privateKeyLocation);
            Files.write(publicKey, publicKeyLocation);
            LOG.info("Decrypted keys written to disk.");
            return MessageProcessingResult.SUCCESS;
        } catch(Exception e) {
            LOG.info("Could not process received PGP key.", e);
            return MessageProcessingResult.FAILURE;
        }
    }
    @Override
    public String getName() {
        return "PGP Key Receiver";
    }
}
package app.nzyme.core.crypto.database;
import app.nzyme.core.crypto.tls.TLSSourceType;
import com.google.auto.value.AutoValue;
import org.joda.time.DateTime;
@AutoValue
public abstract class TLSWildcardKeyAndCertificateEntry {
    public abstract long id();
    public abstract String nodeMatcher();
    public abstract String certificate();
    public abstract String key();
    public abstract TLSSourceType sourceType();
    public abstract DateTime validFrom();
    public abstract DateTime expiresAt();
    public static TLSWildcardKeyAndCertificateEntry create(long id, String nodeMatcher, String certificate, String key, TLSSourceType sourceType, DateTime validFrom, DateTime expiresAt) {
        return builder()
                .id(id)
                .nodeMatcher(nodeMatcher)
                .certificate(certificate)
                .key(key)
                .sourceType(sourceType)
                .validFrom(validFrom)
                .expiresAt(expiresAt)
                .build();
    }
    public static Builder builder() {
        return new AutoValue_TLSWildcardKeyAndCertificateEntry.Builder();
    }
    @AutoValue.Builder
    public abstract static class Builder {
        public abstract Builder id(long id);
        public abstract Builder nodeMatcher(String nodeMatcher);
        public abstract Builder certificate(String certificate);
        public abstract Builder key(String key);
        public abstract Builder sourceType(TLSSourceType sourceType);
        public abstract Builder validFrom(DateTime validFrom);
        public abstract Builder expiresAt(DateTime expiresAt);
        public abstract TLSWildcardKeyAndCertificateEntry build();
    }
}
package app.nzyme.core.rest.resources.system.authentication;
import app.nzyme.core.NzymeNode;
import app.nzyme.core.branding.BrandingRegistryKeys;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.events.types.SystemEvent;
import app.nzyme.core.events.types.SystemEventType;
import app.nzyme.core.monitoring.health.db.IndicatorStatus;
import app.nzyme.core.rest.UserAuthenticatedResource;
import app.nzyme.core.rest.authentication.AuthenticatedUser;
import app.nzyme.core.rest.authentication.PreMFASecured;
import app.nzyme.core.rest.requests.MFARecoveryCodeRequest;
import app.nzyme.core.rest.requests.MFAVerificationRequest;
import app.nzyme.core.rest.responses.authentication.MFAInitResponse;
import app.nzyme.core.rest.responses.authentication.SessionInformationResponse;
import app.nzyme.core.rest.responses.authentication.SessionTokenResponse;
import app.nzyme.core.rest.responses.authentication.SessionUserInformationDetailsResponse;
import app.nzyme.core.rest.responses.authentication.branding.BrandingResponse;
import app.nzyme.core.security.authentication.AuthenticationRegistryKeys;
import app.nzyme.core.security.authentication.PasswordHasher;
import app.nzyme.core.security.authentication.RecoveryCodes;
import app.nzyme.core.security.authentication.db.UserEntry;
import app.nzyme.core.security.sessions.SessionId;
import app.nzyme.core.security.sessions.db.SessionEntry;
import app.nzyme.plugin.Subsystem;
import app.nzyme.plugin.rest.security.PermissionLevel;
import app.nzyme.plugin.rest.security.RESTSecured;
import app.nzyme.core.rest.requests.CreateSessionRequest;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.io.BaseEncoding;
import dev.samstevens.totp.code.CodeGenerator;
import dev.samstevens.totp.code.CodeVerifier;
import dev.samstevens.totp.code.DefaultCodeGenerator;
import dev.samstevens.totp.code.DefaultCodeVerifier;
import dev.samstevens.totp.secret.DefaultSecretGenerator;
import dev.samstevens.totp.secret.SecretGenerator;
import dev.samstevens.totp.time.SystemTimeProvider;
import dev.samstevens.totp.time.TimeProvider;
import jakarta.validation.constraints.NotNull;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.validator.routines.InetAddressValidator;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.joda.time.DateTime;
import jakarta.inject.Inject;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.Context;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.core.SecurityContext;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
@Path("/api/system/authentication")
@Produces(MediaType.APPLICATION_JSON)
public class AuthenticationResource extends UserAuthenticatedResource {
    private static final Logger LOG = LogManager.getLogger(AuthenticationResource.class);
    @Inject
    private NzymeNode nzyme;
    @POST
    @Path("/session")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response createSession(@Context org.glassfish.grizzly.http.server.Request rc,
                                  @NotNull CreateSessionRequest request) {
        String remoteIp = rc.getHeader("X-Forwarded-For") == null
                ? rc.getRemoteAddr() : rc.getHeader("X-Forwarded-For").split(",")[0];
        InetAddressValidator inetValidator = new InetAddressValidator();
        if (!inetValidator.isValid(remoteIp)) {
            LOG.warn("Invalid remote IP or X-Forwarded-For header in session request: [{}]. Aborting.", remoteIp);
            return Response.status(Response.Status.BAD_REQUEST).build();
        }
        String username = request.username();
        String password = request.password();
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserByEmail(request.username());
        PasswordHasher hasher = new PasswordHasher(nzyme.getMetrics());
        if (!hasher.runPasswordPreconditions(request.password())) {
            LOG.warn("Failed login attempt for user [{}]. (Password preconditions not met.)", username);
            return Response.status(Response.Status.FORBIDDEN).build();
        }
        String hash;
        String salt;
        if (user.isPresent()) {
            hash = user.get().passwordHash();
            salt = user.get().passwordSalt();
        } else {
            PasswordHasher.GeneratedHashAndSalt generated = hasher.createHash(
                    RandomStringUtils.random(18, true, true)
            );
            hash = generated.hash();
            salt = generated.salt();
        }
        if (user.isPresent() && user.get().isLoginThrottled()) {
            if (user.get().failedLoginCount() == 5) {
                if (user.get().isSuperAdmin()) {
                    nzyme.getEventEngine().processEvent(SystemEvent.create(
                            SystemEventType.AUTHENTICATION_SUPERADMIN_LOGIN_THROTTLED,
                            DateTime.now(),
                            "Login attempts of super administrator [" + user.get().email() + "] were throttled."
                    ), null, null);
                } else {
                    nzyme.getEventEngine().processEvent(SystemEvent.create(
                            SystemEventType.AUTHENTICATION_USER_LOGIN_THROTTLED,
                            DateTime.now(),
                            "Login attempts of user [" + user.get().email() + "] were throttled."
                    ), user.get().organizationId(), user.get().tenantId());
                }
            }
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
            }
        }
        if (hasher.compareHash(password, hash, salt)) {
            String sessionId = SessionId.createSessionId();
            nzyme.getAuthenticationService().deleteAllSessionsOfUser(user.get().uuid());
            nzyme.getAuthenticationService().createSession(sessionId, user.get().uuid(), remoteIp);
            nzyme.getAuthenticationService().markUserSuccessfulLogin(user.get());
            LOG.info("Creating session for user [{}]", username);
            return Response.status(Response.Status.CREATED).entity(SessionTokenResponse.create(sessionId)).build();
        } else {
            user.ifPresent(u -> nzyme.getAuthenticationService().markUserFailedLogin(u));
            LOG.warn("Failed login attempt for user [{}].", username);
            return Response.status(Response.Status.FORBIDDEN).build();
        }
    }
    @GET
    @PreMFASecured
    @Path("/session")
    public Response getSessionInformation(@Context SecurityContext sc) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<SessionEntry> session = nzyme.getAuthenticationService().findSessionWithOrWithoutPassedMFABySessionId(
                authenticatedUser.getSessionId()
        );
        if (session.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserById(session.get().userId());
        if (user.isEmpty()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        UserEntry u = user.get();
        int mfaTimeoutMinutes;
        if (authenticatedUser.isSuperAdministrator() || authenticatedUser.isOrganizationAdministrator()) {
            mfaTimeoutMinutes = Integer.parseInt(nzyme.getDatabaseCoreRegistry()
                    .getValue(AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.key())
                    .orElse(AuthenticationRegistryKeys.MFA_TIMEOUT_MINUTES.defaultValue().get()));
        } else {
            mfaTimeoutMinutes = nzyme.getAuthenticationService().findTenant(user.get().tenantId()).get()
                    .mfaTimeoutMinutes();
        }
        List<String> featurePermissions = nzyme.getAuthenticationService().findPermissionsOfUser(u.uuid());
        DateTime mfaExpiresAt = session.get().mfaRequestedAt() == null
                ? null : session.get().mfaRequestedAt().plusMinutes(mfaTimeoutMinutes);
        String sidebarTitleText = nzyme.getDatabaseCoreRegistry()
                .getValue(BrandingRegistryKeys.SIDEBAR_TITLE_TEXT.key())
                .orElse(BrandingRegistryKeys.SIDEBAR_TITLE_TEXT.defaultValue().get());
        String sidebarSubtitleText = nzyme.getDatabaseCoreRegistry()
                .getValueOrNull(BrandingRegistryKeys.SIDEBAR_SUBTITLE_TEXT.key());
        boolean hasActiveAlerts = false;
        List<String> userPermissions = nzyme.getAuthenticationService().findPermissionsOfUser(user.get().uuid());
        if (user.get().isSuperAdmin() || user.get().isOrganizationAdmin() || userPermissions.contains("alerts_view")) {
            hasActiveAlerts = nzyme.getDetectionAlertService().countActiveAlerts(
                    authenticatedUser.getOrganizationId(),
                    authenticatedUser.getTenantId(),
                    null
            ) > 0;
        }
        List<String> subsystems = Lists.newArrayList();
        if (nzyme.getSubsystems().isEnabled(Subsystem.ETHERNET, user.get().organizationId(), user.get().tenantId())) {
            subsystems.add("ethernet");
        }
        if (nzyme.getSubsystems().isEnabled(Subsystem.DOT11, user.get().organizationId(), user.get().tenantId())) {
            subsystems.add("dot11");
        }
        if (nzyme.getSubsystems().isEnabled(Subsystem.BLUETOOTH, user.get().organizationId(), user.get().tenantId())) {
            subsystems.add("bluetooth");
        }
        String healthIndicatorLevel = null;
        if (user.get().isSuperAdmin()) {
            boolean hasRed = false;
            boolean hasOrange = false;
            Optional<List<IndicatorStatus>> indicators = nzyme.getHealthMonitor().getIndicatorStatus();
            if (indicators.isPresent()) {
                for (IndicatorStatus status : indicators.get()) {
                    if (status.active()) {
                        if (status.resultLevel().equals("RED")) {
                            hasRed = true;
                        }
                        if (status.resultLevel().equals("ORANGE")) {
                            hasOrange = true;
                        }
                    }
                }
            }
            if (hasRed) {
                healthIndicatorLevel = "RED";
            } else if (hasOrange) {
                healthIndicatorLevel = "ORANGE";
            } else {
                healthIndicatorLevel = "GREEN";
            }
        }
        return Response.ok(SessionInformationResponse.create(
                SessionUserInformationDetailsResponse.create(
                        u.uuid(),
                        u.email(),
                        u.name(),
                        u.isSuperAdmin(),
                        u.isOrganizationAdmin(),
                        u.organizationId(),
                        u.tenantId(),
                        u.defaultOrganizationId(),
                        u.defaultTenantId(),
                        featurePermissions,
                        subsystems
                ),
                session.get().mfaValid(),
                user.get().mfaComplete(),
                mfaExpiresAt,
                BrandingResponse.create(sidebarTitleText, sidebarSubtitleText),
                hasActiveAlerts,
                healthIndicatorLevel
        )).build();
    }
    @POST
    @PreMFASecured
    @Path("/session/touch")
    @Consumes(MediaType.APPLICATION_JSON)
    public Response touchSession(@Context SecurityContext sc) {
        return Response.ok().build();
    }
    @GET
    @PreMFASecured
    @Path("/mfa/setup/initialize")
    public Response initializeMfaSetup(@Context SecurityContext sc) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<SessionEntry> session = nzyme.getAuthenticationService().findSessionWithOrWithoutPassedMFABySessionId(
                authenticatedUser.getSessionId()
        );
        if (session.isEmpty() || session.get().mfaValid()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserById(session.get().userId());
        if (user.isEmpty() || user.get().mfaComplete()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        String userSecret;
        Map<String, Boolean> recoveryCodes;
        if (Strings.isNullOrEmpty(user.get().totpSecret())) {
            SecretGenerator secretGenerator = new DefaultSecretGenerator();
            RecoveryCodes recoveryCodeGenerator = new RecoveryCodes();
            userSecret = secretGenerator.generate();
            recoveryCodes = Maps.newHashMap();
            for (String code : recoveryCodeGenerator.generateCodes(8)) {
                recoveryCodes.put(code, false);
            }
            String recoveryCodesJson;
            try {
                recoveryCodesJson = new ObjectMapper().writeValueAsString(recoveryCodes);
            } catch (JsonProcessingException e) {
                LOG.error("Could not serialize MFA recovery codes.", e);
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
            }
            String encryptedUserSecret;
            String encryptedRecoveryCodesJson;
            try {
                encryptedUserSecret = BaseEncoding.base64().encode(
                        nzyme.getCrypto().encryptWithClusterKey(userSecret.getBytes())
                );
                encryptedRecoveryCodesJson = BaseEncoding.base64().encode(
                        nzyme.getCrypto().encryptWithClusterKey(recoveryCodesJson.getBytes())
                );
            } catch (Crypto.CryptoOperationException e) {
                LOG.error("Could not encrypt MFA data codes.", e);
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
            }
            nzyme.getAuthenticationService().setUserTOTPSecret(user.get().uuid(), encryptedUserSecret);
            nzyme.getAuthenticationService().setUserMFARecoveryCodes(user.get().uuid(), encryptedRecoveryCodesJson);
        } else {
            try {
                userSecret = new String(nzyme.getCrypto().decryptWithClusterKey(
                        BaseEncoding.base64().decode(user.get().totpSecret())
                ));
            } catch (Crypto.CryptoOperationException e) {
                LOG.error("Could not decrypt MFA data codes.", e);
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
            }
            try {
                String recoveryCodesDecryptedJson;
                try {
                    recoveryCodesDecryptedJson = new String(nzyme.getCrypto().decryptWithClusterKey(
                            BaseEncoding.base64().decode(user.get().mfaRecoveryCodes())
                    ));
                } catch (Crypto.CryptoOperationException e) {
                    LOG.error("Could not decrypt MFA data codes.", e);
                    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
                }
                recoveryCodes = new ObjectMapper().readValue(recoveryCodesDecryptedJson, new TypeReference<>() {});
            } catch (JsonProcessingException e) {
                LOG.error("Could not deserialize MFA recovery codes.", e);
                return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
            }
        }
        return Response.ok(
                MFAInitResponse.create(userSecret, user.get().email(), new ArrayList<>(recoveryCodes.keySet()))
        ).build();
    }
    @POST
    @PreMFASecured
    @Path("/mfa/setup/complete")
    public Response completeMfaSetup(@Context SecurityContext sc) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<SessionEntry> session = nzyme.getAuthenticationService().findSessionWithOrWithoutPassedMFABySessionId(
                authenticatedUser.getSessionId()
        );
        if (session.isEmpty() || session.get().mfaValid()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserById(session.get().userId());
        if (user.isEmpty() || user.get().mfaComplete()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        nzyme.getAuthenticationService().setUserMFAComplete(user.get().uuid(), true);
        return Response.ok().build();
    }
    @POST
    @PreMFASecured
    @Path("/mfa/verify")
    public Response verifyMfa(@Context SecurityContext sc, MFAVerificationRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<SessionEntry> session = nzyme.getAuthenticationService().findSessionWithOrWithoutPassedMFABySessionId(
                authenticatedUser.getSessionId()
        );
        if (session.isEmpty() || session.get().mfaValid()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserById(session.get().userId());
        if (user.isEmpty() || !user.get().mfaComplete()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        TimeProvider timeProvider = new SystemTimeProvider();
        CodeGenerator codeGenerator = new DefaultCodeGenerator();
        CodeVerifier verifier = new DefaultCodeVerifier(codeGenerator, timeProvider);
        String userSecret;
        try {
            userSecret = new String(nzyme.getCrypto().decryptWithClusterKey(
                    BaseEncoding.base64().decode(user.get().totpSecret())
            ));
        } catch (Crypto.CryptoOperationException e) {
            LOG.error("Could not decrypt MFA data codes.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        if (!verifier.isValidCode(userSecret, req.code())) {
            LOG.info("User <{}> failed MFA challenge.", user.get().email());
            return Response.status(Response.Status.FORBIDDEN).build();
        }
        LOG.info("User <{}> passed MFA challenge.", user.get().email());
        nzyme.getAuthenticationService().markSessionAsMFAValid(session.get().sessionId());
        return Response.ok().build();
    }
    @POST
    @PreMFASecured
    @Path("/mfa/recovery")
    public Response mfaRecoveryCodeValidation(@Context SecurityContext sc, MFARecoveryCodeRequest req) {
        AuthenticatedUser authenticatedUser = getAuthenticatedUser(sc);
        Optional<SessionEntry> session = nzyme.getAuthenticationService().findSessionWithOrWithoutPassedMFABySessionId(
                authenticatedUser.getSessionId()
        );
        if (session.isEmpty() || session.get().mfaValid()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<UserEntry> user = nzyme.getAuthenticationService().findUserById(session.get().userId());
        if (user.isEmpty() || !user.get().mfaComplete()) {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        Optional<Map<String, Boolean>> codes = nzyme.getAuthenticationService()
                .getUserMFARecoveryCodes(user.get().uuid());
        if (codes.isEmpty()) {
            LOG.warn("No MFA recovery codes found for user [{}].", user.get().email());
            return Response.status(Response.Status.NOT_FOUND).build();
        }
        List<String> unusedCodes = Lists.newArrayList();
        List<String> usedCodes = Lists.newArrayList();
        for (Map.Entry<String, Boolean> code : codes.get().entrySet()) {
            if (!code.getValue()) {
                unusedCodes.add(code.getKey());
            } else {
                usedCodes.add(code.getKey());
            }
        }
        if (!unusedCodes.contains(req.code())) {
            if (usedCodes.contains(req.code())) {
                LOG.warn("User [{}] attempted to use previously used MFA recovery code.", user.get().email());
                if (user.get().isSuperAdmin()) {
                    nzyme.getEventEngine().processEvent(SystemEvent.create(
                            SystemEventType.AUTHENTICATION_SUPERADMIN_MFA_RECOVERY_CODE_REUSED,
                            DateTime.now(),
                            "Super administrator [" + user.get().email() + "] attempted to reuse one of their " +
                                    "previously utilized MFA recovery codes for login, which was unsuccessful."
                    ), null, null);
                } else {
                    nzyme.getEventEngine().processEvent(SystemEvent.create(
                            SystemEventType.AUTHENTICATION_MFA_RECOVERY_CODE_REUSED,
                            DateTime.now(),
                            "User [" + user.get().email() + "] attempted to reuse one of their previously utilized " +
                                    "MFA recovery codes for login, which was unsuccessful."
                    ), user.get().organizationId(), user.get().tenantId());
                }
                return Response.status(Response.Status.UNAUTHORIZED).build();
            } else {
                LOG.warn("User [{}] attempted to use invalid MFA recovery code.", user.get().email());
                return Response.status(Response.Status.UNAUTHORIZED).build();
            }
        }
        Map<String, Boolean> newCodes = Maps.newHashMap();
        for (Map.Entry<String, Boolean> code : codes.get().entrySet()) {
            newCodes.put(code.getKey(), code.getKey().equals(req.code()) || code.getValue());
        }
        String recoveryCodesJson;
        try {
            recoveryCodesJson = new ObjectMapper().writeValueAsString(newCodes);
        } catch (JsonProcessingException e) {
            LOG.error("Could not serialize MFA recovery codes.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        String encryptedRecoveryCodesJson;
        try {
            encryptedRecoveryCodesJson = BaseEncoding.base64().encode(
                    nzyme.getCrypto().encryptWithClusterKey(recoveryCodesJson.getBytes())
            );
        } catch (Crypto.CryptoOperationException e) {
            LOG.error("Could not encrypt MFA data codes.", e);
            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).build();
        }
        nzyme.getAuthenticationService().setUserMFARecoveryCodes(user.get().uuid(), encryptedRecoveryCodesJson);
        LOG.info("User [{}] passed MFA challenge with recovery code.", user.get().email());
        nzyme.getAuthenticationService().markSessionAsMFAValid(session.get().sessionId());
        if (user.get().isSuperAdmin()) {
            nzyme.getEventEngine().processEvent(SystemEvent.create(
                    SystemEventType.AUTHENTICATION_SUPERADMIN_MFA_RECOVERY_CODE_USED,
                    DateTime.now(),
                    "Super administrator [" + user.get().email() + "] used a MFA recovery code to log in."
            ), null, null);
        } else {
            nzyme.getEventEngine().processEvent(SystemEvent.create(
                    SystemEventType.AUTHENTICATION_MFA_RECOVERY_CODE_USED,
                    DateTime.now(),
                    "User [" + user.get().email() + "] used a MFA recovery code to log in."
            ), user.get().organizationId(), user.get().tenantId());
        }
        return Response.ok().build();
    }
    @DELETE
    @RESTSecured(PermissionLevel.ANY)
    @Path("/session")
    public Response deleteSessionOfOwnUser(@Context SecurityContext sc) {
        AuthenticatedUser user = getAuthenticatedUser(sc);
        nzyme.getAuthenticationService().deleteAllSessionsOfUser(user.getUserId());
        LOG.info("Deleting session of user [{}].", user.getEmail());
        return Response.ok().build();
    }
}
package app.nzyme.core.crypto.pgp;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.distributed.NodeManager;
import app.nzyme.plugin.distributed.messaging.Message;
import app.nzyme.plugin.distributed.messaging.MessageBus;
import app.nzyme.plugin.distributed.messaging.MessageType;
import app.nzyme.plugin.distributed.tasksqueue.ReceivedTask;
import app.nzyme.plugin.distributed.tasksqueue.TaskHandler;
import app.nzyme.plugin.distributed.tasksqueue.TaskProcessingResult;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.io.BaseEncoding;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.bouncycastle.openpgp.PGPPublicKey;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Map;
public class PGPKeyProviderTaskHandler implements TaskHandler {
    private static final Logger LOG = LogManager.getLogger(PGPKeyMessageBusReceiver.class);
    private final File cryptoDirectoryConfig;
    private final MessageBus messageBus;
    private final NodeManager nodeManager;
    private final Crypto crypto;
    private final ObjectMapper om;
    public PGPKeyProviderTaskHandler(File cryptoDirectory, MessageBus messageBus, NodeManager nodeManager, Crypto crypto) {
        this.cryptoDirectoryConfig = cryptoDirectory;
        this.messageBus = messageBus;
        this.nodeManager = nodeManager;
        this.crypto = crypto;
        this.om = new ObjectMapper();
    }
    @Override
    public TaskProcessingResult handle(ReceivedTask task) {
        try {
            if (!crypto.isPGPKeySyncEnabled()) {
                LOG.warn("PGP sync is disabled. Not sending keys.");
                return TaskProcessingResult.FAILURE;
            }
            LOG.info("Responding to PGP key request by [{}].", task.senderNodeId());
            LOG.info("Loading keys from disk.");
            File privateKeyLocation = Paths.get(cryptoDirectoryConfig.toString(),
                    Crypto.PGP_PRIVATE_KEY_FILE_NAME).toFile();
            File publicKeyLocation = Paths.get(cryptoDirectoryConfig.toString(),
                    Crypto.PGP_PUBLIC_KEY_FILE_NAME).toFile();
            byte[] privateKey, publicKey;
            if (privateKeyLocation.canRead() && publicKeyLocation.canRead()) {
                privateKey = Files.readAllBytes(privateKeyLocation.toPath());
                publicKey = Files.readAllBytes(publicKeyLocation.toPath());
            } else {
                throw new RuntimeException("Could not read PGP keys from disk.");
            }
            LOG.info("Encrypting keys with public key of node [{}]", task.senderNodeId());
            PGPPublicKey nodeKey = Crypto.readPublicKey(nodeManager.getPGPPublicKeyOfNode(task.senderNodeId()));
            byte[] encryptedPrivateKey = crypto.encrypt(privateKey, nodeKey);
            byte[] encryptedPublicKey = crypto.encrypt(publicKey, nodeKey);
            String encryptedPrivateKeyEncoded = BaseEncoding.base64().encode(encryptedPrivateKey);
            String encryptedPublicKeyEncoded = BaseEncoding.base64().encode(encryptedPublicKey);
            PGPKeyMessagePayload payload = PGPKeyMessagePayload.create(encryptedPublicKeyEncoded, encryptedPrivateKeyEncoded);
            Map<String, Object> parameters = this.om.convertValue(payload, new TypeReference<>() {});
            LOG.info("Keys encrypted and encoded. Publishing message to requesting node.");
            messageBus.send(Message.create(
                    task.senderNodeId(),
                    MessageType.CLUSTER_PGP_KEYS_PROVIDED,
                    parameters,
                    true
            ));
            LOG.info("Message published. Task complete.");
            return TaskProcessingResult.SUCCESS;
        } catch(Exception | Crypto.CryptoOperationException e) {
            LOG.error("Could not respond to PGP key request.", e);
            return TaskProcessingResult.FAILURE;
        }
    }
    @Override
    public String getName() {
        return "PGP Key Provider";
    }
}
package app.nzyme.core.crypto.tls;
import com.google.auto.value.AutoValue;
@AutoValue
public abstract class KeyStoreBootstrapResult {
    public abstract byte[] keystoreBytes();
    public abstract TLSKeyAndCertificate loadedCertificate();
    public static KeyStoreBootstrapResult create(byte[] keystoreBytes, TLSKeyAndCertificate loadedCertificate) {
        return builder()
                .keystoreBytes(keystoreBytes)
                .loadedCertificate(loadedCertificate)
                .build();
    }
    public static Builder builder() {
        return new AutoValue_KeyStoreBootstrapResult.Builder();
    }
    @AutoValue.Builder
    public abstract static class Builder {
        public abstract Builder keystoreBytes(byte[] keystoreBytes);
        public abstract Builder loadedCertificate(TLSKeyAndCertificate loadedCertificate);
        public abstract KeyStoreBootstrapResult build();
    }
}
package app.nzyme.core.crypto.database;
import app.nzyme.core.crypto.tls.TLSSourceType;
import com.google.auto.value.AutoValue;
import org.joda.time.DateTime;
import java.util.UUID;
@AutoValue
public abstract class TLSKeyAndCertificateEntry {
    public abstract UUID nodeId();
    public abstract String certificate();
    public abstract String key();
    public abstract TLSSourceType sourceType();
    public abstract DateTime validFrom();
    public abstract DateTime expiresAt();
    public static TLSKeyAndCertificateEntry create(UUID nodeId, String certificate, String key, TLSSourceType sourceType, DateTime validFrom, DateTime expiresAt) {
        return builder()
                .nodeId(nodeId)
                .certificate(certificate)
                .key(key)
                .sourceType(sourceType)
                .validFrom(validFrom)
                .expiresAt(expiresAt)
                .build();
    }
    public static Builder builder() {
        return new AutoValue_TLSKeyAndCertificateEntry.Builder();
    }
    @AutoValue.Builder
    public abstract static class Builder {
        public abstract Builder nodeId(UUID nodeId);
        public abstract Builder certificate(String certificate);
        public abstract Builder key(String key);
        public abstract Builder sourceType(TLSSourceType sourceType);
        public abstract Builder validFrom(DateTime validFrom);
        public abstract Builder expiresAt(DateTime expiresAt);
        public abstract TLSKeyAndCertificateEntry build();
    }
}
package app.nzyme.core.monitoring.health.indicators;
import app.nzyme.core.NzymeNode;
import app.nzyme.core.crypto.Crypto;
import app.nzyme.core.crypto.tls.TLSKeyAndCertificate;
import app.nzyme.core.crypto.tls.TLSWildcardKeyAndCertificate;
import app.nzyme.core.distributed.Node;
import app.nzyme.core.distributed.NodeManager;
import app.nzyme.core.monitoring.health.Indicator;
import app.nzyme.core.monitoring.health.db.IndicatorStatus;
import org.joda.time.DateTime;
import java.util.Optional;
public class TLSExpirationIndicator extends Indicator  {
    private final Crypto crypto;
    private final NodeManager nodes;
    public TLSExpirationIndicator(Crypto crypto, NodeManager nodes) {
        this.crypto = crypto;
        this.nodes = nodes;
    }
    @Override
    protected IndicatorStatus doRun() {
        for (Node node : nodes.getNodes()) {
            Optional<TLSKeyAndCertificate> tls = crypto.getTLSCertificateOfNode(node.uuid());
            if (tls.isPresent()) {
                if (tls.get().expiresAt().isBefore(DateTime.now().plusDays(7))) {
                    return IndicatorStatus.red(this);
                }
            }
        }
        for (TLSWildcardKeyAndCertificate tls : crypto.getTLSWildcardCertificates()) {
            if (tls.expiresAt().isBefore(DateTime.now().plusDays(7))) {
                return IndicatorStatus.red(this);
            }
        }
        return IndicatorStatus.green(this);
    }
    @Override
    public String getId() {
        return "tls_exp";
    }
    @Override
    public String getName() {
        return "TLS Expiration";
    }
}