package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.List;
import java.util.Objects;
import org.bukkit.Bukkit;
import org.bukkit.Material;
import org.bukkit.block.Block;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
public class AdminBlueprintOriginCommand extends CompositeCommand {
    public AdminBlueprintOriginCommand(AdminBlueprintCommand parent) {
        super(parent, "origin");
    }
    @Override
    public void setup() {
        setPermission("admin.blueprint.origin");
        setParametersHelp("commands.admin.blueprint.origin.parameters");
        setDescription("commands.admin.blueprint.origin.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        BlueprintClipboard clipboard = parent.getClipboards().computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        if (clipboard.getPos1() == null || clipboard.getPos2() == null) {
            user.sendMessage("commands.admin.blueprint.need-pos1-pos2");
            return false;
        }
        // Get the block player is looking at
        Block b = Objects.requireNonNull(user.getPlayer()).getLineOfSight(null, 20).stream().filter(x -> !x.getType().equals(Material.AIR)).findFirst().orElse(null);
        if (b != null) {
            clipboard.setOrigin(b.getLocation().toVector());
            user.getPlayer().sendBlockChange(b.getLocation(), Material.REDSTONE_BLOCK.createBlockData());
            Bukkit.getScheduler().runTaskLater(getPlugin(),
                    () -> user.getPlayer().sendBlockChange(b.getLocation(), b.getBlockData()), 20L);
            user.sendMessage("general.success");
            return true;
        }
        user.sendMessage("commands.admin.blueprint.look-at-a-block");
        return false;
    }
}
package world.bentobox.bentobox.api.user;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang.math.NumberUtils;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Color;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.OfflinePlayer;
import org.bukkit.Particle;
import org.bukkit.Particle.DustTransition;
import org.bukkit.Vibration;
import org.bukkit.World;
import org.bukkit.block.data.BlockData;
import org.bukkit.command.CommandSender;
import org.bukkit.entity.Player;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.PlayerInventory;
import org.bukkit.permissions.PermissionAttachment;
import org.bukkit.permissions.PermissionAttachmentInfo;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.common.base.Enums;
import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.HoverEvent;
import net.md_5.bungee.api.chat.TextComponent;
import net.md_5.bungee.api.chat.hover.content.Text;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.api.events.OfflineMessageEvent;
import world.bentobox.bentobox.api.metadata.MetaDataAble;
import world.bentobox.bentobox.api.metadata.MetaDataValue;
import world.bentobox.bentobox.database.objects.Players;
import world.bentobox.bentobox.util.Util;
/**
 * Combines {@link Player}, {@link OfflinePlayer} and {@link CommandSender} to
 * provide convenience methods related to localization and generic interactions.
 * <br/>
 * Therefore, a User could usually be a Player, an OfflinePlayer or the server's
 * console. Preliminary checks should be performed before trying to run methods
 * that relies on a specific implementation. <br/>
 * <br/>
 * It is good practice to use the User instance whenever possible instead of
 * Player or CommandSender.
 *
 * @author tastybento
 */
public class User implements MetaDataAble {
    private static final Map<UUID, User> users = new HashMap<>();
    // Used for particle validation
    private static final Map<Particle, Class<?>> VALIDATION_CHECK;
    static {
        Map<Particle, Class<?>> v = new EnumMap<>(Particle.class);
        v.put(Enums.getIfPresent(Particle.class, "DUST")
                .or(Enums.getIfPresent(Particle.class, "REDSTONE").or(Particle.FLAME)), Particle.DustOptions.class);
        if (Enums.getIfPresent(Particle.class, "ITEM").isPresent()) {
            // 1.20.6 Particles
            v.put(Particle.ITEM, ItemStack.class);
            v.put(Particle.ITEM_COBWEB, ItemStack.class);
            v.put(Particle.BLOCK, BlockData.class);
            v.put(Particle.DUST_PILLAR, BlockData.class);
            v.put(Particle.ENTITY_EFFECT, Color.class);
        }
        v.put(Particle.FALLING_DUST, BlockData.class);
        v.put(Particle.BLOCK_MARKER, BlockData.class);
        v.put(Particle.DUST_COLOR_TRANSITION, DustTransition.class);
        v.put(Particle.VIBRATION, Vibration.class);
        v.put(Particle.SCULK_CHARGE, Float.class);
        v.put(Particle.SHRIEK, Integer.class);
        VALIDATION_CHECK = Collections.unmodifiableMap(v);
    }
    /**
     * Clears all users from the user list
     */
    public static void clearUsers() {
        users.clear();
    }
    /**
     * Gets an instance of User from a CommandSender
     * 
     * @param sender - command sender, e.g. console
     * @return user - user
     */
    @NonNull
    public static User getInstance(@NonNull CommandSender sender) {
        if (sender instanceof Player p) {
            return getInstance(p);
        }
        // Console
        return new User(sender);
    }
    /**
     * Gets an instance of User from a Player object.
     * 
     * @param player - the player
     * @return user - user
     */
    @NonNull
    public static User getInstance(@NonNull Player player) {
        if (users.containsKey(player.getUniqueId())) {
            return users.get(player.getUniqueId());
        }
        return new User(player);
    }
    /**
     * Gets an instance of User from a UUID. This will always return a user object.
     * If the player is offline then the getPlayer value will be null.
     * 
     * @param uuid - UUID
     * @return user - user
     */
    @NonNull
    public static User getInstance(@NonNull UUID uuid) {
        if (users.containsKey(uuid)) {
            return users.get(uuid);
        }
        // Return a user instance
        return new User(uuid);
    }
    /**
     * Gets an instance of User from an OfflinePlayer
     * 
     * @param offlinePlayer offline Player
     * @return user
     * @since 1.3.0
     */
    @NonNull
    public static User getInstance(@NonNull OfflinePlayer offlinePlayer) {
        if (users.containsKey(offlinePlayer.getUniqueId())) {
            return users.get(offlinePlayer.getUniqueId());
        }
        return new User(offlinePlayer);
    }
    /**
     * Removes this player from the User cache and player manager cache
     * 
     * @param player the player
     */
    public static void removePlayer(Player player) {
        if (player != null) {
            users.remove(player.getUniqueId());
        }
    }
    // ----------------------------------------------------
    private static BentoBox plugin = BentoBox.getInstance();
    @Nullable
    private final Player player;
    private OfflinePlayer offlinePlayer;
    private final UUID playerUUID;
    @Nullable
    private final CommandSender sender;
    private Addon addon;
    private User(@Nullable CommandSender sender) {
        player = null;
        playerUUID = null;
        this.sender = sender;
    }
    private User(@NonNull Player player) {
        this.player = player;
        offlinePlayer = player;
        sender = player;
        playerUUID = player.getUniqueId();
        users.put(playerUUID, this);
    }
    private User(@NonNull OfflinePlayer offlinePlayer) {
        this.player = offlinePlayer.isOnline() ? offlinePlayer.getPlayer() : null;
        this.playerUUID = offlinePlayer.getUniqueId();
        this.sender = offlinePlayer.isOnline() ? offlinePlayer.getPlayer() : null;
        this.offlinePlayer = offlinePlayer;
    }
    private User(UUID playerUUID) {
        player = Bukkit.getPlayer(playerUUID);
        this.playerUUID = playerUUID;
        sender = player;
        offlinePlayer = Bukkit.getOfflinePlayer(playerUUID);
    }
    /**
     * Used for testing
     * 
     * @param p - plugin
     */
    public static void setPlugin(BentoBox p) {
        plugin = p;
    }
    public Set<PermissionAttachmentInfo> getEffectivePermissions() {
        return sender.getEffectivePermissions();
    }
    /**
     * Get the user's inventory
     * 
     * @return player's inventory
     */
    @NonNull
    public PlayerInventory getInventory() {
        return Objects.requireNonNull(player, "getInventory can only be called for online players!").getInventory();
    }
    /**
     * Get the user's location
     * 
     * @return location
     */
    @NonNull
    public Location getLocation() {
        return Objects.requireNonNull(player, "getLocation can only be called for online players!").getLocation();
    }
    /**
     * Get the user's name
     * 
     * @return player's name
     */
    @NonNull
    public String getName() {
        return player != null ? player.getName() : plugin.getPlayers().getName(playerUUID);
    }
    /**
     * Get the user's display name
     * 
     * @return player's display name if the player is online otherwise just their
     *         name
     * @since 1.22.1
     */
    @NonNull
    public String getDisplayName() {
        return player != null ? player.getDisplayName() : plugin.getPlayers().getName(playerUUID);
    }
    /**
     * Check if the User is a player before calling this method. {@link #isPlayer()}
     * 
     * @return the player
     */
    @NonNull
    public Player getPlayer() {
        return Objects.requireNonNull(player, "User is not a player!");
    }
    /**
     * @return true if this user is a player, false if not, e.g., console
     */
    public boolean isPlayer() {
        return player != null;
    }
    /**
     * Use {@link #isOfflinePlayer()} before calling this method
     * 
     * @return the offline player
     * @since 1.3.0
     */
    @NonNull
    public OfflinePlayer getOfflinePlayer() {
        return Objects.requireNonNull(offlinePlayer, "User is not an OfflinePlayer!");
    }
    /**
     * @return true if this user is an OfflinePlayer, false if not, e.g., console
     * @since 1.3.0
     */
    public boolean isOfflinePlayer() {
        return offlinePlayer != null;
    }
    @Nullable
    public CommandSender getSender() {
        return sender;
    }
    public UUID getUniqueId() {
        return playerUUID;
    }
    /**
     * @param permission permission string
     * @return true if permission is empty or null or if the player has that
     *         permission or if the player is op.
     */
    public boolean hasPermission(@Nullable String permission) {
        return permission == null || permission.isEmpty() || isOp() || sender.hasPermission(permission);
    }
    /**
     * Removes permission from user
     * 
     * @param name - Name of the permission to remove
     * @return true if successful
     * @since 1.5.0
     */
    public boolean removePerm(String name) {
        for (PermissionAttachmentInfo p : player.getEffectivePermissions()) {
            if (p.getPermission().equals(name) && p.getAttachment() != null) {
                player.removeAttachment(p.getAttachment());
                break;
            }
        }
        player.recalculatePermissions();
        return !player.hasPermission(name);
    }
    /**
     * Add a permission to user
     * 
     * @param name - Name of the permission to attach
     * @return The PermissionAttachment that was just created
     * @since 1.5.0
     */
    public PermissionAttachment addPerm(String name) {
        return player.addAttachment(plugin, name, true);
    }
    public boolean isOnline() {
        return player != null && player.isOnline();
    }
    /**
     * Checks if user is Op
     * 
     * @return true if user is Op
     */
    public boolean isOp() {
        if (sender != null) {
            return sender.isOp();
        }
        if (playerUUID != null && offlinePlayer != null) {
            return offlinePlayer.isOp();
        }
        return false;
    }
    /**
     * Get the maximum value of a numerical permission setting. If a player is given
     * an explicit negative number then this is treated as "unlimited" and returned
     * immediately.
     * 
     * @param permissionPrefix the start of the perm, e.g.,
     *                         {@code plugin.mypermission}
     * @param defaultValue     the default value; the result may be higher or lower
     *                         than this
     * @return max value
     */
    public int getPermissionValue(String permissionPrefix, int defaultValue) {
        // If requester is console, then return the default value
        if (!isPlayer())
            return defaultValue;
        // If there is a dot at the end of the permissionPrefix, remove it
        if (permissionPrefix.endsWith(".")) {
            permissionPrefix = permissionPrefix.substring(0, permissionPrefix.length() - 1);
        }
        final String permPrefix = permissionPrefix + ".";
        List<String> permissions = player.getEffectivePermissions().stream().filter(PermissionAttachmentInfo::getValue) // Must
                // be
                // a
                // positive
                // permission,
                // not
                // a
                // negative
                // one
                .map(PermissionAttachmentInfo::getPermission).filter(permission -> permission.startsWith(permPrefix))
                .toList();
        if (permissions.isEmpty())
            return defaultValue;
        return iteratePerms(permissions, permPrefix, defaultValue);
    }
    private int iteratePerms(List<String> permissions, String permPrefix, int defaultValue) {
        int value = 0;
        for (String permission : permissions) {
            if (permission.contains(permPrefix + "*")) {
                // 'Star' permission
                return defaultValue;
            } else {
                String[] spl = permission.split(permPrefix);
                if (spl.length > 1) {
                    if (!NumberUtils.isNumber(spl[1])) {
                        plugin.logError("Player " + player.getName() + " has permission: '" + permission
                                + "' <-- the last part MUST be a number! Ignoring...");
                    } else {
                        int v = Integer.parseInt(spl[1]);
                        if (v < 0) {
                            return v;
                        }
                        value = Math.max(value, v);
                    }
                }
            }
        }
        return value;
    }
    /**
     * Gets a translation for a specific world
     * 
     * @param world     - world of translation
     * @param reference - reference found in a locale file
     * @param variables - variables to insert into translated string. Variables go
     *                  in pairs, for example "[name]", "tastybento"
     * @return Translated string with colors converted, or the reference if nothing
     *         has been found
     * @since 1.3.0
     */
    public String getTranslation(World world, String reference, String... variables) {
        // Get translation.
        String addonPrefix = plugin.getIWM().getAddon(world)
                .map(a -> a.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".").orElse("");
        return Util.translateColorCodes(translate(addonPrefix, reference, variables));
    }
    /**
     * Gets a translation of this reference for this user with colors converted.
     * Translations may be overridden by Addons by using the same reference prefixed
     * by the addon name (from the Addon Description) in lower case.
     * 
     * @param reference - reference found in a locale file
     * @param variables - variables to insert into translated string. Variables go
     *                  in pairs, for example "[name]", "tastybento"
     * @return Translated string with colors converted, or the reference if nothing
     *         has been found
     */
    public String getTranslation(String reference, String... variables) {
        // Get addonPrefix
        String addonPrefix = addon == null ? "" : addon.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".";
        return Util.translateColorCodes(translate(addonPrefix, reference, variables));
    }
    /**
     * Gets a translation of this reference for this user without colors translated.
     * Translations may be overridden by Addons by using the same reference prefixed
     * by the addon name (from the Addon Description) in lower case.
     * 
     * @param reference - reference found in a locale file
     * @param variables - variables to insert into translated string. Variables go
     *                  in pairs, for example "[name]", "tastybento"
     * @return Translated string or the reference if nothing has been found
     * @since 1.17.4
     */
    public String getTranslationNoColor(String reference, String... variables) {
        // Get addonPrefix
        String addonPrefix = addon == null ? "" : addon.getDescription().getName().toLowerCase(Locale.ENGLISH) + ".";
        return translate(addonPrefix, reference, variables);
    }
    private String translate(String addonPrefix, String reference, String[] variables) {
        // Try to get the translation for this specific addon
        String translation = plugin.getLocalesManager().get(this, addonPrefix + reference);
        if (translation == null) {
            // No luck, try to get the generic translation
            translation = plugin.getLocalesManager().get(this, reference);
            if (translation == null) {
                // Nothing found. Replace vars (probably will do nothing) and return
                return replaceVars(reference, variables);
            }
        }
        // If this is a prefix, just gather and return the translation
        if (!reference.startsWith("prefixes.")) {
            // Replace the prefixes
            return replacePrefixes(translation, variables);
        }
        return translation;
    }
    private String replacePrefixes(String translation, String[] variables) {
        for (String prefix : plugin.getLocalesManager().getAvailablePrefixes(this)) {
            String prefixTranslation = getTranslation("prefixes." + prefix);
            // Replace the prefix in the actual message
            translation = translation.replace("[prefix_" + prefix + "]", prefixTranslation);
        }
        // Then replace variables
        if (variables.length > 1) {
            for (int i = 0; i < variables.length; i += 2) {
                // Prevent a NPE if the substituting variable is null
                if (variables[i + 1] != null) {
                    translation = translation.replace(variables[i], variables[i + 1]);
                }
            }
        }
        // Then replace Placeholders, this will only work if this is a player
        if (player != null) {
            translation = plugin.getPlaceholdersManager().replacePlaceholders(player, translation);
        }
        // Replace game mode and friendly name in general
        // Replace the [gamemode] text variable
        if (addon != null && addon.getDescription() != null) {
            translation = translation.replace("[gamemode]", addon.getDescription().getName());
        }
        if (player != null && player.getWorld() != null) {
            // Replace the [friendly_name] text variable
            translation = translation.replace("[friendly_name]",
                    isPlayer() ? plugin.getIWM().getFriendlyName(getWorld()) : "[friendly_name]");
        }
        return translation;
    }
    private String replaceVars(String reference, String[] variables) {
        // Then replace variables
        if (variables.length > 1) {
            for (int i = 0; i < variables.length; i += 2) {
                reference = reference.replace(variables[i], variables[i + 1]);
            }
        }
        // Then replace Placeholders, this will only work if this is a player
        if (player != null) {
            reference = plugin.getPlaceholdersManager().replacePlaceholders(player, reference);
        }
        // If no translation has been found, return the reference for debug purposes.
        return reference;
    }
    /**
     * Gets a translation of this reference for this user.
     * 
     * @param reference - reference found in a locale file
     * @param variables - variables to insert into translated string. Variables go
     *                  in pairs, for example "[name]", "tastybento"
     * @return Translated string with colors converted, or a blank String if nothing
     *         has been found
     */
    public String getTranslationOrNothing(String reference, String... variables) {
        String translation = getTranslation(reference, variables);
        return translation.equals(reference) ? "" : translation;
    }
    /**
     * Send a message to sender if message is not empty.
     * 
     * @param reference - language file reference
     * @param variables - CharSequence target, replacement pairs
     */
    public void sendMessage(String reference, String... variables) {
        String message = getTranslation(reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty()) {
            sendRawMessage(message);
        }
    }
    /**
     * Sends a raw message to the sender, parsing inline commands embedded within square brackets.
     * <p>
     * The method supports embedding clickable and hoverable actions into the message text using inline commands.
     * Recognized commands are:
     * <ul>
     *   <li><code>[run_command: &lt;command&gt;]</code> - Runs the specified command when the message is clicked.</li>
     *   <li><code>[suggest_command: &lt;command&gt;]</code> - Suggests the specified command in the chat input.</li>
     *   <li><code>[copy_to_clipboard: &lt;text&gt;]</code> - Copies the specified text to the player's clipboard.</li>
     *   <li><code>[open_url: &lt;url&gt;]</code> - Opens the specified URL when the message is clicked.</li>
     *   <li><code>[hover: &lt;text&gt;]</code> - Shows the specified text when the message is hovered over.</li>
     * </ul>
     * <p>
     * The commands can be placed anywhere in the message and will apply to the entire message component.
     * If multiple commands of the same type are provided, only the first one encountered will be applied.
     * Unrecognized or invalid commands enclosed in square brackets will be preserved in the output text.
     * <p>
     * Example usage:
     * <pre>
     * sendRawMessage("Hello [not-a-command: hello][run_command: /help] World [hover: This is a hover text]");
     * </pre>
     * The above message will display "Hello [not-a-command: hello] World" where clicking the message runs the "/help" command,
     * and hovering over the message shows "This is a hover text".
     *
     * @param message The message to send, containing inline commands in square brackets.
     */
    public void sendRawMessage(String message) {
        // Create a base TextComponent for the message
        TextComponent baseComponent = new TextComponent();
        // Regex to find inline commands like [run_command: /help] and [hover: click for help!], or unrecognized commands
        Pattern pattern = Pattern.compile("\\[(\\w+): ([^\\]]+)]|\\[\\[(.*?)\\]]");
        Matcher matcher = pattern.matcher(message);
        // Keep track of the current position in the message
        int lastMatchEnd = 0;
        ClickEvent clickEvent = null;
        HoverEvent hoverEvent = null;
        while (matcher.find()) {
            // Add any text before the current match
            if (matcher.start() > lastMatchEnd) {
                String beforeMatch = message.substring(lastMatchEnd, matcher.start());
                baseComponent.addExtra(TextComponent.fromLegacy(beforeMatch));
            }
            // Check if it's a recognized command or an unknown bracketed text
            if (matcher.group(1) != null && matcher.group(2) != null) {
                // Parse the inline command (action) and value
                String actionType = matcher.group(1).toUpperCase(Locale.ENGLISH); // e.g., RUN_COMMAND, HOVER
                String actionValue = matcher.group(2); // The command or text to display
                // Apply the first valid click event or hover event encountered
                switch (actionType) {
                    case "RUN_COMMAND":
                    case "SUGGEST_COMMAND":
                    case "COPY_TO_CLIPBOARD":
                    case "OPEN_URL":
                        if (clickEvent == null) {
                            clickEvent = new ClickEvent(ClickEvent.Action.valueOf(actionType), actionValue);
                        }
                        break;
                    case "HOVER":
                        if (hoverEvent == null) {
                            hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, new Text(actionValue));
                        }
                        break;
                    default:
                        // Unrecognized command; preserve it in the output text
                        baseComponent.addExtra(TextComponent.fromLegacy(matcher.group(0)));
                }
            } else if (matcher.group(3) != null) {
                // Unrecognized bracketed text; preserve it in the output
                baseComponent.addExtra(TextComponent.fromLegacy("[[" + matcher.group(3) + "]]"));
            }
            // Update the last match end position
            lastMatchEnd = matcher.end();
        }
        // Add any remaining text after the last match
        if (lastMatchEnd < message.length()) {
            String remainingText = message.substring(lastMatchEnd);
            baseComponent.addExtra(TextComponent.fromLegacy(remainingText));
        }
        // Apply the first encountered ClickEvent and HoverEvent to the entire message
        if (clickEvent != null) {
            baseComponent.setClickEvent(clickEvent);
        }
        if (hoverEvent != null) {
            baseComponent.setHoverEvent(hoverEvent);
        }
        // Send the final component to the sender
        if (sender != null) {
            sender.spigot().sendMessage(baseComponent);
        } else {
            // Handle offline player messaging or alternative actions
            Bukkit.getPluginManager().callEvent(new OfflineMessageEvent(this.playerUUID, message));
        }
    }
    /**
     * Sends a message to sender if message is not empty and if the same wasn't sent
     * within the previous Notifier.NOTIFICATION_DELAY seconds.
     * 
     * @param reference - language file reference
     * @param variables - CharSequence target, replacement pairs
     *
     * @see Notifier
     */
    public void notify(String reference, String... variables) {
        String message = getTranslation(reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty() && sender != null) {
            plugin.getNotifier().notify(this, message);
        }
    }
    /**
     * Sends a message to sender if message is not empty and if the same wasn't sent
     * within the previous Notifier.NOTIFICATION_DELAY seconds.
     * 
     * @param world     - the world the translation should come from
     * @param reference - language file reference
     * @param variables - CharSequence target, replacement pairs
     *
     * @see Notifier
     * @since 1.3.0
     */
    public void notify(World world, String reference, String... variables) {
        String message = getTranslation(world, reference, variables);
        if (!ChatColor.stripColor(message).trim().isEmpty() && sender != null) {
            plugin.getNotifier().notify(this, message);
        }
    }
    /**
     * Sets the user's game mode
     * 
     * @param mode - GameMode
     */
    public void setGameMode(GameMode mode) {
        player.setGameMode(mode);
    }
    /**
     * Teleports user to this location. If the user is in a vehicle, they will exit
     * first.
     * 
     * @param location - the location
     */
    public void teleport(Location location) {
        player.teleport(location);
    }
    /**
     * Gets the current world this entity resides in
     * 
     * @return World - world
     */
    @NonNull
    public World getWorld() {
        Objects.requireNonNull(player, "Cannot be called on a non-player User!");
        return Objects.requireNonNull(player.getWorld(), "Player's world cannot be null!");
    }
    /**
     * Closes the user's inventory
     */
    public void closeInventory() {
        player.closeInventory();
    }
    /**
     * Get the user's locale
     * 
     * @return Locale
     */
    public Locale getLocale() {
        if (sender instanceof Player && !plugin.getPlayers().getLocale(playerUUID).isEmpty()) {
            return Locale.forLanguageTag(plugin.getPlayers().getLocale(playerUUID));
        }
        return Locale.forLanguageTag(plugin.getSettings().getDefaultLanguage());
    }
    /**
     * Forces an update of the user's complete inventory. Deprecated, but there is
     * no current alternative.
     */
    public void updateInventory() {
        player.updateInventory();
    }
    /**
     * Performs a command as the player
     * 
     * @param command - command to execute
     * @return true if the command was successful, otherwise false
     */
    public boolean performCommand(String command) {
        PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(getPlayer(), command);
        Bukkit.getPluginManager().callEvent(event);
        // only perform the command, if the event wasn't cancelled by an other plugin:
        if (!event.isCancelled()) {
            return getPlayer().performCommand(
                    event.getMessage().startsWith("/") ? event.getMessage().substring(1) : event.getMessage());
        }
        // Cancelled, but it was recognized, so return true
        return true;
    }
    /**
     * Checks if a user is in one of the game worlds
     * 
     * @return true if user is, false if not
     */
    public boolean inWorld() {
        return plugin.getIWM().inWorld(getLocation());
    }
    /**
     * Spawn particles to the player. They are only displayed if they are within the
     * server's view distance.
     * 
     * @param particle    Particle to display.
     * @param dustOptions Particle.DustOptions for the particle to display.
     * @param x           X coordinate of the particle to display.
     * @param y           Y coordinate of the particle to display.
     * @param z           Z coordinate of the particle to display.
     */
    public void spawnParticle(Particle particle, @Nullable Object dustOptions, double x, double y, double z) {
        Class<?> expectedClass = VALIDATION_CHECK.get(particle);
        if (expectedClass == null)
            throw new IllegalArgumentException("Unexpected value: " + particle);
        if (!(expectedClass.isInstance(dustOptions))) {
            throw new IllegalArgumentException("A non-null " + expectedClass.getSimpleName()
                    + " must be provided when using Particle." + particle + " as particle.");
        }
        // Check if this particle is beyond the viewing distance of the server
        if (this.player != null && this.player.getLocation().toVector().distanceSquared(new Vector(x, y,
                z)) < (Bukkit.getServer().getViewDistance() * 256 * Bukkit.getServer().getViewDistance())) {
            if (particle.equals(Enums.getIfPresent(Particle.class, "DUST")
                    .or(Enums.getIfPresent(Particle.class, "REDSTONE").or(Particle.FLAME)))) {
                player.spawnParticle(particle, x, y, z, 1, 0, 0, 0, 1, dustOptions);
            } else if (dustOptions != null) {
                player.spawnParticle(particle, x, y, z, 1, dustOptions);
            } else {
                // This will never be called unless the value in VALIDATION_CHECK is null in the
                // future
                player.spawnParticle(particle, x, y, z, 1);
            }
        }
    }
    /**
     * Spawn particles to the player. They are only displayed if they are within the
     * server's view distance. Compatibility method for older usages.
     * 
     * @param particle    Particle to display.
     * @param dustOptions Particle.DustOptions for the particle to display.
     * @param x           X coordinate of the particle to display.
     * @param y           Y coordinate of the particle to display.
     * @param z           Z coordinate of the particle to display.
     */
    public void spawnParticle(Particle particle, Particle.DustOptions dustOptions, double x, double y, double z) {
        this.spawnParticle(particle, (Object) dustOptions, x, y, z);
    }
    /**
     * Spawn particles to the player. They are only displayed if they are within the
     * server's view distance.
     * 
     * @param particle    Particle to display.
     * @param dustOptions Particle.DustOptions for the particle to display.
     * @param x           X coordinate of the particle to display.
     * @param y           Y coordinate of the particle to display.
     * @param z           Z coordinate of the particle to display.
     */
    public void spawnParticle(Particle particle, Particle.DustOptions dustOptions, int x, int y, int z) {
        this.spawnParticle(particle, dustOptions, (double) x, (double) y, (double) z);
    }
    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#hashCode()
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((playerUUID == null) ? 0 : playerUUID.hashCode());
        return result;
    }
    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof User other)) {
            return false;
        }
        if (playerUUID == null) {
            return other.playerUUID == null;
        } else
            return playerUUID.equals(other.playerUUID);
    }
    /**
     * Set the addon context when a command is executed
     * 
     * @param addon - the addon executing the command
     */
    public void setAddon(Addon addon) {
        this.addon = addon;
    }
    /**
     * Get all the meta data for this user
     * 
     * @return the metaData
     * @since 1.15.4
     */
    @Override
    public Optional<Map<String, MetaDataValue>> getMetaData() {
        Players p = plugin.getPlayers().getPlayer(playerUUID);
        return Objects.requireNonNull(p, "Unknown player for " + playerUUID).getMetaData();
    }
    /**
     * @param metaData the metaData to set
     * @since 1.15.4
     */
    @Override
    public void setMetaData(Map<String, MetaDataValue> metaData) {
        Players p = plugin.getPlayers().getPlayer(playerUUID);
        Objects.requireNonNull(p, "Unknown player for " + playerUUID).setMetaData(metaData);
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.bukkit.Bukkit;
import org.bukkit.Color;
import org.bukkit.Particle;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.commands.admin.range.AdminRangeDisplayCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.panels.BlueprintManagementPanel;
public class AdminBlueprintCommand extends ConfirmableCommand {
    // Clipboards
    private Map<UUID, BlueprintClipboard> clipboards;
    // Map containing selection cuboid display tasks
    private Map<User, Integer> displayClipboards;
    private static final Particle.DustOptions PARTICLE_DUST_OPTIONS = new Particle.DustOptions(Color.RED, 1.0F);
    public AdminBlueprintCommand(CompositeCommand parent) {
        super(parent, "blueprint", "bp", "blu");
    }
    @Override
    public void setup() {
        setPermission("admin.blueprint");
        setParametersHelp("commands.admin.blueprint.parameters");
        setDescription("commands.admin.blueprint.description");
        setOnlyPlayer(true);
        clipboards = new HashMap<>();
        displayClipboards = new HashMap<>();
        new AdminBlueprintLoadCommand(this);
        new AdminBlueprintPasteCommand(this);
        new AdminBlueprintOriginCommand(this);
        new AdminBlueprintCopyCommand(this);
        new AdminBlueprintSaveCommand(this);
        new AdminBlueprintRenameCommand(this);
        new AdminBlueprintDeleteCommand(this);
        new AdminBlueprintPos1Command(this);
        new AdminBlueprintPos2Command(this);
        new AdminBlueprintListCommand(this);
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        new BlueprintManagementPanel(getPlugin(), user, getAddon()).openPanel();
        return true;
    }
    protected Map<UUID, BlueprintClipboard> getClipboards() {
        return clipboards;
    }
    /**
     * This method shows clipboard for requested user.
     * @param user User who need to see clipboard.
     */
    protected void showClipboard(User user)
    {
        this.displayClipboards.computeIfAbsent(user,
            key -> Bukkit.getScheduler().scheduleSyncRepeatingTask(this.getPlugin(), () ->
            {
                if (!key.isPlayer() || !key.getPlayer().isOnline())
                {
                    this.hideClipboard(key);
                }
                if (this.clipboards.containsKey(key.getUniqueId()))
                {
                    BlueprintClipboard clipboard = this.clipboards.get(key.getUniqueId());
                    this.paintAxis(key, clipboard);
                }
            }, 20, 20));
    }
    private void paintAxis(User user, BlueprintClipboard clipboard) {
        if (clipboard.getPos1() == null || clipboard.getPos2() == null) {
            return;
        }
        int minX = Math.min(clipboard.getPos1().getBlockX(), clipboard.getPos2().getBlockX());
        int minY = Math.min(clipboard.getPos1().getBlockY(), clipboard.getPos2().getBlockY());
        int minZ = Math.min(clipboard.getPos1().getBlockZ(), clipboard.getPos2().getBlockZ());
        int maxX = Math.max(clipboard.getPos1().getBlockX(), clipboard.getPos2().getBlockX());
        int maxY = Math.max(clipboard.getPos1().getBlockY(), clipboard.getPos2().getBlockY());
        int maxZ = Math.max(clipboard.getPos1().getBlockZ(), clipboard.getPos2().getBlockZ());
        // Drawing x-axes
        for (int x = minX; x <= maxX; x++) {
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, x + 0.5, minY + 0.5,
                    minZ + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, x + 0.5, maxY + 0.5,
                    minZ + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, x + 0.5, minY + 0.5,
                    maxZ + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, x + 0.5, maxY + 0.5,
                    maxZ + 0.5);
        }
        // Drawing y-axes
        for (int y = minY; y <= maxY; y++) {
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, minX + 0.5, y + 0.5,
                    minZ + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, maxX + 0.5, y + 0.5,
                    minZ + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, minX + 0.5, y + 0.5,
                    maxZ + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, maxX + 0.5, y + 0.5,
                    maxZ + 0.5);
        }
        // Drawing z-axes
        for (int z = minZ; z <= maxZ; z++) {
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, minX + 0.5, minY + 0.5,
                    z + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, maxX + 0.5, minY + 0.5,
                    z + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, minX + 0.5, maxY + 0.5,
                    z + 0.5);
            user.spawnParticle(AdminRangeDisplayCommand.PARTICLE, PARTICLE_DUST_OPTIONS, maxX + 0.5, maxY + 0.5,
                    z + 0.5);
        }
    }
    protected void hideClipboard(User user) {
        if (displayClipboards.containsKey(user)) {
            Bukkit.getScheduler().cancelTask(displayClipboards.get(user));
            displayClipboards.remove(user);
        }
    }
    protected File getBlueprintsFolder() {
        return new File(getIWM().getDataFolder(getWorld()), BlueprintsManager.FOLDER_NAME);
    }
}
package world.bentobox.bentobox.api.commands;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.logging.Logger;
import org.bukkit.World;
import org.bukkit.command.Command;
import org.bukkit.command.CommandSender;
import org.bukkit.command.PluginIdentifiableCommand;
import org.bukkit.entity.Player;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.Settings;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.api.events.command.CommandEvent;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.managers.IslandWorldManager;
import world.bentobox.bentobox.managers.IslandsManager;
import world.bentobox.bentobox.managers.PlayersManager;
import world.bentobox.bentobox.managers.RanksManager;
import world.bentobox.bentobox.util.Util;
/**
 * BentoBox composite command. Provides an abstract implementation of a command.
 * 
 * @author tastybento
 * @author Poslovitch
 */
public abstract class CompositeCommand extends Command implements PluginIdentifiableCommand, BentoBoxCommand {
    private static final String COMMANDS = "commands.";
    private final BentoBox plugin;
    /**
     * True if the command is for the player only (not for the console)
     */
    private boolean onlyPlayer = false;
    /**
     * True if the command is only for the console
     * 
     * @since 1.24.0
     */
    private boolean onlyConsole = false;
    /**
     * True if command is a configurable rank
     */
    private boolean configurableRankCommand = false;
    /**
     * Make default command rank as owner rank.
     * 
     * @since 1.20.0
     */
    private int defaultCommandRank = RanksManager.OWNER_RANK;
    /**
     * True if command is hidden from help and tab complete
     * 
     * @since 1.13.0
     */
    private boolean hidden = false;
    /**
     * The parameters string for this command. It is the commands followed by a
     * locale reference.
     */
    private String parameters = "";
    /**
     * The parent command to this one. If this is a top-level command it will be
     * empty.
     */
    protected final CompositeCommand parent;
    /**
     * The permission required to execute this command
     */
    private String permission = "";
    /**
     * This is the command level. 0 is the top, 1 is the first level sub command.
     */
    private final int subCommandLevel;
    /**
     * Map of sub commands
     */
    private final Map<String, CompositeCommand> subCommands;
    /**
     * Map of aliases for subcommands
     */
    private final Map<String, CompositeCommand> subCommandAliases;
    /**
     * The command chain from the very top, e.g., island team promote
     */
    private String usage;
    /**
     * The prefix to be used in this command
     */
    @Nullable
    private final String permissionPrefix;
    /**
     * The world that this command operates in. This is an overworld and will cover
     * any associated nether or end If the world value does not exist, then the
     * command is general across worlds
     */
    private World world;
    /**
     * The addon creating this command, if any
     */
    private final Addon addon;
    /**
     * The top level label
     */
    private final String topLabel;
    /**
     * Cool down tracker
     */
    private final Map<String, Map<String, Long>> cooldowns = new HashMap<>();
    /**
     * Top level command
     * 
     * @param addon   - addon creating the command
     * @param label   - string for this command
     * @param aliases - aliases
     */
    protected CompositeCommand(Addon addon, String label, String... aliases) {
        super(label, "", "", Arrays.asList(aliases));
        this.addon = addon;
        this.topLabel = label;
        this.plugin = BentoBox.getInstance();
        setAliases(new ArrayList<>(Arrays.asList(aliases)));
        parent = null;
        setUsage("");
        subCommandLevel = 0; // Top level
        subCommands = new LinkedHashMap<>();
        subCommandAliases = new LinkedHashMap<>();
        // Register command if it is not already registered
        if (plugin.getCommand(label) == null) {
            plugin.getCommandsManager().registerCommand(this);
        }
        // Default references to description and parameters
        setDescription(COMMANDS + label + ".description");
        setParametersHelp(COMMANDS + label + ".parameters");
        permissionPrefix = (addon != null) ? addon.getPermissionPrefix() : "";
        // Run setup
        setup();
        if (getSubCommand("help").isEmpty() && !label.equals("help")) {
            new DefaultHelpCommand(this);
        }
    }
    /**
     * This is the top-level command constructor for commands that have no parent.
     * 
     * @param label   - string for this command
     * @param aliases - aliases for this command
     */
    protected CompositeCommand(String label, String... aliases) {
        this((Addon) null, label, aliases);
    }
    /**
     * Sub-command constructor
     * 
     * @param parent  - the parent composite command
     * @param label   - string label for this subcommand
     * @param aliases - aliases for this subcommand
     */
    protected CompositeCommand(CompositeCommand parent, String label, String... aliases) {
        this(parent.getAddon(), parent, label, aliases);
    }
    /**
     * Command to register a command from an addon under a parent command (that
     * could be from another addon)
     * 
     * @param addon   - this command's addon
     * @param parent  - parent command
     * @param aliases - aliases for this command
     */
    protected CompositeCommand(Addon addon, CompositeCommand parent, String label, String... aliases) {
        super(label, "", "", Arrays.asList(aliases));
        this.topLabel = parent.getTopLabel();
        this.plugin = BentoBox.getInstance();
        this.addon = addon;
        this.parent = parent;
        subCommandLevel = parent.getLevel() + 1;
        // Add this sub-command to the parent
        parent.getSubCommands().put(label.toLowerCase(java.util.Locale.ENGLISH), this);
        setAliases(new ArrayList<>(Arrays.asList(aliases)));
        subCommands = new LinkedHashMap<>();
        subCommandAliases = new LinkedHashMap<>();
        // Add aliases to the parent for this command
        for (String alias : aliases) {
            parent.getSubCommandAliases().put(alias.toLowerCase(java.util.Locale.ENGLISH), this);
        }
        setUsage("");
        // Inherit permission prefix
        this.permissionPrefix = parent.getPermissionPrefix();
        // Default references to description and parameters
        StringBuilder reference = new StringBuilder();
        reference.append(label);
        CompositeCommand p = this;
        int index = 0;
        while (p.getParent() != null && index < 20) {
            reference.insert(0, p.getParent().getLabel() + ".");
            p = p.getParent();
            index++;
        }
        setDescription(COMMANDS + reference + ".description");
        setParametersHelp(COMMANDS + reference + ".parameters");
        setup();
        // If this command does not define its own help class, then use the default help
        // command
        if (getSubCommand("help").isEmpty() && !label.equals("help")) {
            new DefaultHelpCommand(this);
        }
    }
    /**
     * This method deals with the command execution. It traverses the tree of
     * subcommands until it finds the right object and then runs execute on it.
     */
    @Override
    public boolean execute(@NonNull CommandSender sender, @NonNull String label, String[] args) {
        // Get the User instance for this sender
        User user = User.getInstance(sender);
        // Fire an event to see if this command should be cancelled
        CommandEvent event = CommandEvent.builder().setCommand(this).setLabel(label).setSender(sender).setArgs(args)
                .build();
        if (event.isCancelled()) {
            return false;
        }
        // Get command
        CompositeCommand cmd = getCommandFromArgs(args);
        String cmdLabel = (cmd.subCommandLevel > 0) ? args[cmd.subCommandLevel - 1] : label;
        List<String> cmdArgs = Arrays.asList(args).subList(cmd.subCommandLevel, args.length);
        return cmd.call(user, cmdLabel, cmdArgs);
    }
    /**
     * Calls this composite command. Does not traverse the tree of subcommands in
     * args. Event is not fired and it cannot be cancelled.
     * 
     * @param user     - user calling this command
     * @param cmdLabel - label used
     * @param cmdArgs  - list of args
     * @return {@code true} if successful, {@code false} if not.
     * @since 1.5.3
     */
    public boolean call(User user, String cmdLabel, List<String> cmdArgs) {
        // Check for console and permissions
        if (isOnlyPlayer() && !user.isPlayer()) {
            user.sendMessage("general.errors.use-in-game");
            return false;
        }
        if (isOnlyConsole() && user.isPlayer()) {
            user.sendMessage("general.errors.use-in-console");
            return false;
        }
        if (!this.runPermissionCheck(user)) {
            // Error message is displayed by permission check.
            return false;
        }
        // Set the user's addon context
        user.setAddon(addon);
        // Execute and trim args
        return canExecute(user, cmdLabel, cmdArgs) && execute(user, cmdLabel, cmdArgs);
    }
    /**
     * This method checks and returns if user has access to the called command. It
     * also recursively checks if user has access to the all parent commands.
     * 
     * @param user User who permission must be checked.
     * @return {@code true} is user can execute given command, {@code false}
     *         otherwise.
     */
    private boolean runPermissionCheck(User user) {
        // Check perms, but only if this isn't the console
        if (user.isPlayer() && !user.isOp() && this.getPermission() != null && !this.getPermission().isEmpty()
                && !user.hasPermission(this.getPermission())) {
            user.sendMessage("general.errors.no-permission", TextVariables.PERMISSION, this.getPermission());
            return false;
        }
        // Recursive permission check to find if user has access to the parent command.
        return this.getParent() == null || this.getParent().runPermissionCheck(user);
    }
    /**
     * Get the current composite command based on the arguments
     * 
     * @param args - arguments
     * @return the current composite command based on the arguments
     */
    private CompositeCommand getCommandFromArgs(String[] args) {
        CompositeCommand subCommand = this;
        // Run through any arguments
        for (String arg : args) {
            // get the subcommand corresponding to the arg
            if (subCommand.hasSubCommands()) {
                Optional<CompositeCommand> sub = subCommand.getSubCommand(arg);
                if (sub.isEmpty()) {
                    return subCommand;
                }
                // Step down one
                subCommand = sub.orElse(subCommand);
                // Set the label
                subCommand.setLabel(arg);
            } else {
                // We are at the end of the walk
                return subCommand;
            }
            // else continue the loop
        }
        return subCommand;
    }
    /**
     * Convenience method to get the island manager
     * 
     * @return IslandsManager
     */
    public IslandsManager getIslands() {
        return plugin.getIslands();
    }
    /**
     * Convenience method to get the island manager
     * 
     * @return IslandsManager
     */
    protected IslandsManager getIslandsManager() {
        return plugin.getIslandsManager();
    }
    /**
     * @return this command's sub-level. Top level is 0. Every time a command
     *         registers with a parent, their level will be set.
     */
    protected int getLevel() {
        return subCommandLevel;
    }
    /**
     * @return Logger
     */
    public Logger getLogger() {
        return plugin.getLogger();
    }
    /**
     * Convenience method to obtain team members of the active island for user. Note
     * that the user may have more than one island in this world.
     * 
     * @param world - world to check
     * @param user  - the User
     * @return set of UUIDs of all team members, or empty set if there is no island
     */
    protected Set<UUID> getMembers(World world, User user) {
        Island island = plugin.getIslands().getIsland(world, user);
        if (island == null) {
            return Set.of();
        }
        return island.getMemberSet();
    }
    public String getParameters() {
        return parameters;
    }
    /**
     * @return the parent command object
     */
    public CompositeCommand getParent() {
        return parent;
    }
    @Override
    public String getPermission() {
        return permission;
    }
    /**
     * Convenience method to get the player manager
     * 
     * @return PlayersManager
     */
    protected PlayersManager getPlayers() {
        return plugin.getPlayers();
    }
    @Override
    public @NonNull BentoBox getPlugin() {
        return plugin;
    }
    /**
     * Get the island worlds manager
     * 
     * @return island worlds manager
     */
    public IslandWorldManager getIWM() {
        return plugin.getIWM();
    }
    /**
     * @return Settings object
     */
    public Settings getSettings() {
        return plugin.getSettings();
    }
    /**
     * Returns the CompositeCommand object referring to this command label
     * 
     * @param label - command label or alias
     * @return CompositeCommand or null if none found
     */
    public Optional<CompositeCommand> getSubCommand(String label) {
        label = label.toLowerCase(java.util.Locale.ENGLISH);
        if (subCommands.containsKey(label)) {
            return Optional.ofNullable(subCommands.get(label));
        }
        // Try aliases
        if (subCommandAliases.containsKey(label)) {
            return Optional.ofNullable(subCommandAliases.get(label));
        }
        return Optional.empty();
    }
    /**
     * @return Map of sub commands for this command
     */
    public Map<String, CompositeCommand> getSubCommands() {
        return subCommands;
    }
    /**
     * Returns a map of sub commands for this command. As it needs more calculations
     * to handle the Help subcommand, it is preferable to use
     * {@link #getSubCommands()} when no such distinction is needed.
     * 
     * @param ignoreHelp Whether the Help subcommand should not be returned in the
     *                   map or not.
     * @return Map of sub commands for this command
     * @see #hasSubCommands(boolean)
     */
    public Map<String, CompositeCommand> getSubCommands(boolean ignoreHelp) {
        if (ignoreHelp && getSubCommand("help").isPresent()) {
            Map<String, CompositeCommand> result = subCommands;
            result.remove("help");
            return result;
        }
        return getSubCommands();
    }
    @Override
    public @NonNull String getUsage() {
        return "/" + usage;
    }
    /**
     * Check if this command has a specific sub command.
     * 
     * @param subCommand - sub command
     * @return true if this command has this sub command
     */
    protected boolean hasSubCommand(String subCommand) {
        return subCommands.containsKey(subCommand) || subCommandAliases.containsKey(subCommand);
    }
    /**
     * Check if this command has any sub commands.
     * 
     * @return true if this command has subcommands
     */
    protected boolean hasSubCommands() {
        return !subCommands.isEmpty();
    }
    /**
     * Check if this command has any sub commands. As it needs more calculations to
     * handle the Help subcommand, it is preferable to use {@link #hasSubCommands()}
     * when no such distinction is needed.
     * 
     * @param ignoreHelp Whether the Help subcommand should not be taken into
     *                   account or not.
     * @return true if this command has subcommands
     * @see #getSubCommands(boolean)
     */
    protected boolean hasSubCommands(boolean ignoreHelp) {
        return !getSubCommands(ignoreHelp).isEmpty();
    }
    /**
     * Convenience method to check if a user has a team.
     * Consider checking the island itself {@link Island#inTeam(UUID)}
     * 
     * @param world - the world to check
     * @param user  - the User
     * @return true if player is in a team
     */
    protected boolean inTeam(World world, User user) {
        return plugin.getIslands().inTeam(world, user.getUniqueId());
    }
    /**
     * Check if this command is only for players.
     * 
     * @return true or false
     */
    public boolean isOnlyPlayer() {
        return onlyPlayer;
    }
    /**
     * Check if this command is only for consoles.
     * 
     * @return true or false
     */
    public boolean isOnlyConsole() {
        return onlyConsole;
    }
    /**
     * Sets whether this command should only be run by players. If this is set to
     * {@code true}, this command will only be runnable by objects implementing
     * {@link Player}. <br/>
     * <br/>
     * The default value provided when instantiating this CompositeCommand is
     * {@code false}. Therefore, this method should only be used in case you want to
     * explicitly edit the value.
     * 
     * @param onlyPlayer {@code true} if this command should only be run by players.
     */
    public void setOnlyPlayer(boolean onlyPlayer) {
        this.onlyPlayer = onlyPlayer;
    }
    /**
     * Sets whether this command should only be run in the console. This is for
     * commands that dump a lot of data or are for debugging. The default value
     * provided when instantiating this CompositeCommand is {@code false}.
     * Therefore, this method should only be used in case you want to explicitly
     * edit the value.
     * 
     * @param onlyConsole {@code true} if this command should only be run in the
     *                    console.
     * @since 1.24.0
     */
    public void setOnlyConsole(boolean onlyConsole) {
        this.onlyConsole = onlyConsole;
    }
    /**
     * Sets locale reference to this command's description. It is used to display
     * the help of this command.
     *
     * <br/>
     * <br/>
     *
     * A default value is provided when instantiating this CompositeCommand:
     *
     * <ul>
     * <li>{@code "commands." + getLabel() + ".description"} if this is a top-level
     * command;</li>
     * <li>{@code "commands." + getParent.getLabel() + getLabel() + ".description"}
     * if this is a sub-command. <br/>
     * Note that it can have up to 20 parent commands' labels being inserted before
     * this sub-command's label. Here are a few examples :
     * <ul>
     * <li>/bentobox info : {@code "commands.bentobox.info.description"};</li>
     * <li>/bsbadmin range set :
     * {@code "commands.bsbadmin.range.set.description"};</li>
     * <li>/mycommand sub1 sub2 sub3 [...] sub22 :
     * {@code "commands.sub3.[...].sub20.sub21.sub22.description"}.</li>
     * </ul>
     * </li>
     * </ul>
     *
     * This method should therefore only be used in case you want to provide a
     * different value than the default one.
     *
     * @param description The locale command's description reference to set.
     * @return The instance of this {@link Command}.
     */
    @Override
    public @NonNull Command setDescription(@NonNull String description) {
        super.setDescription(description);
        return this;
    }
    /**
     * Sets locale reference to this command's parameters. It is used to display the
     * help of this command.
     *
     * <br/>
     * <br/>
     *
     * A default value is provided when instantiating this CompositeCommand:
     *
     * <ul>
     * <li>{@code "commands." + getLabel() + ".parameters"} if this is a top-level
     * command;</li>
     * <li>{@code "commands." + getParent.getLabel() + getLabel() + ".parameters"}
     * if this is a sub-command. <br/>
     * Note that it can have up to 20 parent commands' labels being inserted before
     * this sub-command's label. Here are a few examples :
     * <ul>
     * <li>/bentobox info : {@code "commands.bentobox.info.parameters"};</li>
     * <li>/bsbadmin range set :
     * {@code "commands.bsbadmin.range.set.parameters"};</li>
     * <li>/mycommand sub1 sub2 sub3 [...] sub22 :
     * {@code "commands.sub3.[...].sub20.sub21.sub22.parameters"}.</li>
     * </ul>
     * </li>
     * </ul>
     *
     * This method should therefore only be used in case you want to provide a
     * different value than the default one.
     *
     * @param parametersHelp The locale command's paramaters reference to set.
     */
    public void setParametersHelp(String parametersHelp) {
        this.parameters = parametersHelp;
    }
    /*
     * (non-Javadoc)
     * 
     * @see org.bukkit.command.Command#setPermission(java.lang.String)
     */
    @Override
    public void setPermission(String permission) {
        this.permission = ((permissionPrefix != null && !permissionPrefix.isEmpty()) ? permissionPrefix : "")
                + permission;
    }
    /**
     * Inherits the permission from parent command
     */
    public void inheritPermission() {
        this.permission = parent.getPermission();
    }
    /**
     * This creates the full linking chain of commands
     */
    @Override
    public @NonNull Command setUsage(@NonNull String usage) {
        // Go up the chain
        CompositeCommand parentCommand = getParent();
        StringBuilder u = new StringBuilder().append(getLabel()).append(" ").append(usage);
        while (parentCommand != null) {
            u.insert(0, " ");
            u.insert(0, parentCommand.getLabel());
            parentCommand = parentCommand.getParent();
        }
        this.usage = u.toString().trim();
        return this;
    }
    @Override
    @NonNull
    public List<String> tabComplete(final @NonNull CommandSender sender, final @NonNull String alias,
            final String[] args) {
        // Get command object based on args entered so far
        CompositeCommand command = getCommandFromArgs(args);
        // Check for console and permissions
        if ((command.isOnlyPlayer() && !(sender instanceof Player))
                || (command.isOnlyConsole() && sender instanceof Player)) {
            return List.of();
        }
        if (command.getPermission() != null && !command.getPermission().isEmpty()
                && !sender.hasPermission(command.getPermission()) && !sender.isOp()) {
            return List.of();
        }
        // Add any tab completion from the subcommand
        List<String> options = new ArrayList<>(
                command.tabComplete(User.getInstance(sender), alias, new LinkedList<>(Arrays.asList(args)))
                        .orElseGet(ArrayList::new));
        if (command.hasSubCommands()) {
            options.addAll(getSubCommandLabels(sender, command));
        }
        /*
         * /!\ The following check is likely a poor quality patch-up job. If any better
         * solution can be applied, don't hesitate to do so.
         */
        // See https://github.com/BentoBoxWorld/BentoBox/issues/416
        // "help" shouldn't appear twice, so remove it if it is already in the args.
        if (Arrays.asList(args).contains("help")) {
            options.remove("help");
        }
        /* ------------ */
        String lastArg = args.length != 0 ? args[args.length - 1] : "";
        return Util.tabLimit(options, lastArg).stream().sorted().toList();
    }
    /**
     * Returns a list containing all the labels of the subcommands for the provided
     * CompositeCommand excluding any hidden commands
     * 
     * @param sender  the CommandSender
     * @param command the CompositeCommand to get the subcommands from
     * @return a list of subcommands labels or an empty list.
     */
    @NonNull
    private List<String> getSubCommandLabels(@NonNull CommandSender sender, @NonNull CompositeCommand command) {
        List<String> result = new ArrayList<>();
        for (CompositeCommand cc : command.getSubCommands().values()) {
            // Player or not
            if (sender instanceof Player) {
                if (!cc.isHidden() && !cc.isOnlyConsole()
                        && (cc.getPermission().isEmpty() || sender.hasPermission(cc.getPermission()))) {
                    result.add(cc.getLabel());
                }
            } else if (!cc.isOnlyPlayer()) {
                result.add(cc.getLabel());
            }
        }
        return result;
    }
    /**
     * Show help
     * 
     * @param command - command that this help is for
     * @param user    - the User
     * @return result of help command or false if no help defined
     */
    public boolean showHelp(CompositeCommand command, User user) {
        return command.getSubCommand("help")
                .map(helpCommand -> helpCommand.execute(user, helpCommand.getLabel(), new ArrayList<>())).orElse(false);
    }
    /**
     * @return the subCommandAliases
     */
    public Map<String, CompositeCommand> getSubCommandAliases() {
        return subCommandAliases;
    }
    /**
     * If the permission prefix has been set, will return the prefix plus a trailing
     * dot.
     * 
     * @return the permissionPrefix
     */
    @Nullable
    public String getPermissionPrefix() {
        return permissionPrefix;
    }
    /**
     * The the world that this command applies to.
     * 
     * @return the world
     */
    public World getWorld() {
        // Search up the tree until the world at the top is found
        return parent != null ? parent.getWorld() : world;
    }
    /**
     * @param world the world to set
     */
    public void setWorld(World world) {
        this.world = world;
    }
    /**
     * Get the parental addon
     * 
     * @return the addon
     */
    @SuppressWarnings("unchecked")
    public <T extends Addon> T getAddon() {
        return (T) addon;
    }
    /**
     * @return top level label, e.g., island
     */
    public String getTopLabel() {
        return topLabel;
    }
    /**
     * Set a cool down - can be set by other commands on this one
     * 
     * @param uniqueId      - the unique ID that is having the cooldown
     * @param targetUUID    - the target (if any)
     * @param timeInSeconds - time in seconds to cool down
     * @since 1.5.0
     */
    public void setCooldown(String uniqueId, String targetUUID, int timeInSeconds) {
        cooldowns.computeIfAbsent(uniqueId, k -> new HashMap<>()).put(targetUUID,
                System.currentTimeMillis() + timeInSeconds * 1000L);
    }
    /**
     * Set a cool down - can be set by other commands on this one
     * 
     * @param uniqueId      - the UUID that is having the cooldown
     * @param targetUUID    - the target UUID (if any)
     * @param timeInSeconds - time in seconds to cool down
     */
    public void setCooldown(UUID uniqueId, UUID targetUUID, int timeInSeconds) {
        cooldowns.computeIfAbsent(uniqueId.toString(), k -> new HashMap<>()).put(
                targetUUID == null ? null : targetUUID.toString(), System.currentTimeMillis() + timeInSeconds * 1000L);
    }
    /**
     * Set a cool down for a user - can be set by other commands on this one
     * 
     * @param uniqueId      - the UUID that is having the cooldown
     * @param timeInSeconds - time in seconds to cool down
     * @since 1.5.0
     */
    public void setCooldown(UUID uniqueId, int timeInSeconds) {
        setCooldown(uniqueId, null, timeInSeconds);
    }
    /**
     * Check if cool down is in progress for user
     * 
     * @param user       - the caller of the command
     * @param targetUUID - the target (if any)
     * @return true if cool down in place, false if not
     */
    protected boolean checkCooldown(User user, UUID targetUUID) {
        return checkCooldown(user, user.getUniqueId().toString(), targetUUID == null ? null : targetUUID.toString());
    }
    /**
     * Check if cool down is in progress for user
     * 
     * @param user - the user to check
     * @return true if cool down in place, false if not
     * @since 1.5.0
     */
    protected boolean checkCooldown(User user) {
        return checkCooldown(user, user.getUniqueId().toString(), null);
    }
    /**
     * Check if cool down is in progress
     * 
     * @param user       - the caller of the command
     * @param uniqueId   - the id that needs to be checked
     * @param targetUUID - the target (if any)
     * @return true if cool down in place, false if not
     * @since 1.5.0
     */
    protected boolean checkCooldown(User user, String uniqueId, String targetUUID) {
        if (!cooldowns.containsKey(uniqueId) || user.isOp()
                || user.hasPermission(getPermissionPrefix() + "mod.bypasscooldowns")) {
            return false;
        }
        cooldowns.putIfAbsent(uniqueId, new HashMap<>());
        if (cooldowns.get(uniqueId).getOrDefault(targetUUID, 0L) - System.currentTimeMillis() <= 0) {
            // Cool down is done
            cooldowns.get(uniqueId).remove(targetUUID);
            return false;
        }
        int timeToGo = (int) ((cooldowns.get(uniqueId).getOrDefault(targetUUID, 0L) - System.currentTimeMillis())
                / 1000);
        user.sendMessage("general.errors.you-must-wait", TextVariables.NUMBER, String.valueOf(timeToGo));
        return true;
    }
    /**
     * @return the configurableRankCommand
     */
    public boolean isConfigurableRankCommand() {
        return configurableRankCommand;
    }
    /**
     * This command can be configured for use by different ranks
     */
    public void setConfigurableRankCommand() {
        this.configurableRankCommand = true;
    }
    /**
     * Sets default command rank.
     *
     * @param rank the rank
     * @since 1.20.0
     */
    public void setDefaultCommandRank(int rank) {
        this.defaultCommandRank = rank;
    }
    /**
     * Gets default command rank.
     *
     * @return the default command rank
     * @since 1.20.0
     */
    public int getDefaultCommandRank() {
        return this.defaultCommandRank;
    }
    /**
     * Checks if a command is hidden
     * 
     * @return the hidden
     * @since 1.13.0
     */
    public boolean isHidden() {
        return hidden;
    }
    /**
     * Sets a command and all its help and tab complete as hidden
     * 
     * @param hidden whether command is hidden or not
     * @since 1.13.0
     */
    public void setHidden(boolean hidden) {
        this.hidden = hidden;
    }
}
package world.bentobox.bentobox.blueprints;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.NamespacedKey;
import org.bukkit.World;
import org.bukkit.block.Banner;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.block.CreatureSpawner;
import org.bukkit.block.Sign;
import org.bukkit.block.TrialSpawner;
import org.bukkit.block.data.Attachable;
import org.bukkit.block.sign.Side;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.inventory.InventoryHolder;
import org.bukkit.inventory.ItemStack;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.scheduler.BukkitTask;
import org.bukkit.util.BoundingBox;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintCreatureSpawner;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintEntity;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintTrialSpawner;
import world.bentobox.bentobox.hooks.FancyNpcsHook;
import world.bentobox.bentobox.hooks.MythicMobsHook;
import world.bentobox.bentobox.hooks.ZNPCsPlusHook;
/**
 * The clipboard provides the holding spot for an active blueprint that is being
 * manipulated by a user. It supports copying from the world and setting of coordinates
 * such as the bounding box around the cuboid copy area.
 * Pasting is done by the {@link BlueprintPaster} class.
 * @author tastybento
 * @since 1.5.0
 */
public class BlueprintClipboard {
    /**
     * Used to filter out hidden DisplayEntity armor stands when copying
     */
    private static final NamespacedKey KEY = new NamespacedKey(BentoBox.getInstance(), "associatedDisplayEntity");
    private @Nullable Blueprint blueprint;
    private @Nullable Location pos1;
    private @Nullable Location pos2;
    private @Nullable Vector origin;
    private BukkitTask copyTask;
    private int count;
    private boolean copying;
    private int index;
    private int lastPercentage;
    private final Map<Vector, List<BlueprintEntity>> bpEntities = new LinkedHashMap<>();
    private final Map<Vector, BlueprintBlock> bpAttachable = new LinkedHashMap<>();
    private final Map<Vector, BlueprintBlock> bpBlocks = new LinkedHashMap<>();
    private final BentoBox plugin = BentoBox.getInstance();
    private Optional<MythicMobsHook> mmh;
    private Optional<FancyNpcsHook> npc;
    private Optional<ZNPCsPlusHook> znpc;
    /**
     * Create a clipboard for blueprint
     * @param blueprint - the blueprint to load into the clipboard
     */
    public BlueprintClipboard(@NonNull Blueprint blueprint) {
        this();
        this.blueprint = blueprint;
    }
    public BlueprintClipboard() {
        // Fancy NPCs Hook
        npc = plugin.getHooks().getHook("FancyNpcs").filter(FancyNpcsHook.class::isInstance)
                .map(FancyNpcsHook.class::cast);
        // MythicMobs Hook
        mmh = plugin.getHooks().getHook("MythicMobs").filter(MythicMobsHook.class::isInstance)
                .map(MythicMobsHook.class::cast);
        // ZNPCs Plus Hook
        znpc = plugin.getHooks().getHook("ZNPCsPlus").filter(ZNPCsPlusHook.class::isInstance)
                .map(ZNPCsPlusHook.class::cast);
    }
    /**
     * Copy the blocks between pos1 and pos2 into the clipboard for a user.
     * This will erase any previously registered data from the clipboard.
     * Copying is done async.
     * @param user - user
     * @return true if successful, false if pos1 or pos2 are undefined.
     */
    public boolean copy(User user, boolean copyAir, boolean copyBiome, boolean noWater) {
        if (copying) {
            user.sendMessage("commands.admin.blueprint.mid-copy");
            return false;
        }
        if (pos1 == null || pos2 == null) {
            user.sendMessage("commands.admin.blueprint.need-pos1-pos2");
            return false;
        }
        if (origin == null) {
            setOrigin(user.getLocation().toVector());
        }
        user.sendMessage("commands.admin.blueprint.copying");
        // World
        World world = pos1.getWorld();
        if (world == null) {
            return false;
        }
        // Clear the clipboard
        blueprint = new Blueprint();
        bpEntities.clear();
        bpAttachable.clear();
        bpBlocks.clear();
        count = 0;
        index = 0;
        lastPercentage = 0;
        BoundingBox toCopy = BoundingBox.of(pos1, pos2);
        blueprint.setxSize((int)toCopy.getWidthX());
        blueprint.setySize((int)toCopy.getHeight());
        blueprint.setzSize((int)toCopy.getWidthZ());
        int speed = plugin.getSettings().getPasteSpeed();
        List<Vector> vectorsToCopy = getVectors(toCopy);
        Bukkit.getScheduler().runTaskAsynchronously(plugin,
                () -> copyAsync(world, user, vectorsToCopy, speed, copyAir, copyBiome, noWater));
        return true;
    }
    private void copyAsync(World world, User user, List<Vector> vectorsToCopy, int speed, boolean copyAir,
            boolean copyBiome, boolean noWater) {
        copying = false;
        // FancyNpcs
        if (npc.isPresent()) {
            // Add all the citizens for the area in one go. This is pretty fast.
            bpEntities.putAll(npc.get().getNpcsInArea(world, vectorsToCopy, origin));
        }
        // ZNPCsPlus NPCs
        if (znpc.isPresent()) {
            bpEntities.putAll(znpc.get().getNpcsInArea(world, vectorsToCopy, origin));
        }
        // Repeating copy task
        copyTask = Bukkit.getScheduler().runTaskTimer(plugin, () -> {
            if (copying) {
                return;
            }
            copying = true;
            vectorsToCopy.stream().skip(index).limit(speed).forEach(v -> {
                List<Entity> ents = world.getEntities().stream()
                        .filter(Objects::nonNull)
                        .filter(e -> !(e instanceof Player))
                        .filter(e -> !e.getPersistentDataContainer().has(KEY, PersistentDataType.STRING)) // Do not copy hidden display entities
                        .filter(e -> new Vector(e.getLocation().getBlockX(), e.getLocation().getBlockY(),
                                e.getLocation().getBlockZ()).equals(v))
                        .toList();
                if (copyBlock(v.toLocation(world), copyAir, copyBiome, ents, noWater)) {
                    count++;
                }
            });
            index += speed;
            int percent = (int)(index * 100 / (double)vectorsToCopy.size());
            if (percent != lastPercentage && percent % 10 == 0) {
                user.sendMessage("commands.admin.blueprint.copied-percent", TextVariables.NUMBER, String.valueOf(percent));
                lastPercentage = percent;
            }
            if (index > vectorsToCopy.size()) {
                copyTask.cancel();
                assert blueprint != null;
                blueprint.setAttached(bpAttachable);
                blueprint.setBlocks(bpBlocks);
                blueprint.setEntities(bpEntities);
                user.sendMessage("general.success");
                user.sendMessage("commands.admin.blueprint.copied-blocks", TextVariables.NUMBER, String.valueOf(count));
            }
            copying = false;
        }, 0L, 1L);
    }
    /**
     * Get all the x,y,z coords that must be copied
     * @param b - bounding box
     * @return - list of vectors
     */
    protected List<Vector> getVectors(BoundingBox b) {
        List<Vector> r = new ArrayList<>();
        for (int y = (int) Math.floor(b.getMinY()); y <= b.getMaxY(); y++) {
            for (int x = (int) Math.floor(b.getMinX()); x <= b.getMaxX(); x++) {
                for (int z = (int) Math.floor(b.getMinZ()); z <= b.getMaxZ(); z++) {
                    r.add(new Vector(x,y,z));
                }
            }
        }
        return r;
    }
    private boolean copyBlock(Location l, boolean copyAir, boolean copyBiome, List<Entity> ents, boolean noWater) {
        Block block = l.getBlock();
        if (!copyAir && block.getType().equals(Material.AIR) && ents.isEmpty()) {
            return false;
        }
        if (noWater && block.getType() == Material.WATER && ents.isEmpty()) {
            return false;
        }
        // Create position
        Vector origin2 = origin == null ? new Vector(0,0,0) : origin;
        int x = l.getBlockX() - origin2.getBlockX();
        int y = l.getBlockY() - origin2.getBlockY();
        int z = l.getBlockZ() - origin2.getBlockZ();
        Vector pos = new Vector(x, y, z);
        // Set entities
        List<BlueprintEntity> bpEnts = setEntities(ents);
        // Store
        if (!bpEnts.isEmpty()) {
            bpEntities.put(pos, bpEnts);
        }
        // Return if this is just air block
        if (!copyAir && block.getType().equals(Material.AIR) && !ents.isEmpty()) {
            return true;
        }
        if (noWater && block.getType().equals(Material.WATER) && !ents.isEmpty()) {
            return true;
        }
        BlueprintBlock b = bluePrintBlock(pos, block, copyBiome);
        if (b != null) {
            this.bpBlocks.put(pos, b);
        }
        return true;
    }
    private BlueprintBlock bluePrintBlock(Vector pos, Block block, boolean copyBiome) {
        // Block state
        BlockState blockState = block.getState();
        BlueprintBlock b = new BlueprintBlock(block.getBlockData().getAsString());
        if (copyBiome) {
            // Biome
            b.setBiome(block.getBiome());
        }
        // Signs
        if (blockState instanceof Sign sign) {
            for (Side side : Side.values()) {
                b.setSignLines(side, Arrays.asList(sign.getSide(side).getLines()));
                b.setGlowingText(side, sign.getSide(side).isGlowingText());
            }
        }
        // Set block data
        if (blockState.getBlockData() instanceof Attachable) {
            // Placeholder for attachment
            bpBlocks.put(pos, new BlueprintBlock("minecraft:air"));
            bpAttachable.put(pos, b);
            return null;
        }
        if (block.getType().equals(Material.BEDROCK)) {
            // Find highest bedrock
            if(blueprint.getBedrock() == null) {
                blueprint.setBedrock(pos);
            } else {
                if (pos.getBlockY() > blueprint.getBedrock().getBlockY()) {
                    blueprint.setBedrock(pos);
                }
            }
        }
        // Chests
        if (blockState instanceof InventoryHolder ih) {
            b.setInventory(new HashMap<>());
            for (int i = 0; i < ih.getInventory().getSize(); i++) {
                ItemStack item = ih.getInventory().getItem(i);
                if (item != null) {
                    b.getInventory().put(i, item);
                }
            }
        }
        if (blockState instanceof CreatureSpawner spawner) {
            b.setCreatureSpawner(getSpawner(spawner));
        }
        if (blockState instanceof TrialSpawner spawner) {
            if (spawner.isOminous()) {
                b.setTrialSpawner(new BlueprintTrialSpawner(true, spawner.getOminousConfiguration()));
            } else {
                b.setTrialSpawner(new BlueprintTrialSpawner(false, spawner.getNormalConfiguration()));
            }
        }
        // Banners
        if (blockState instanceof Banner banner) {
            b.setBannerPatterns(banner.getPatterns());
        }
        return b;
    }
    private BlueprintCreatureSpawner getSpawner(CreatureSpawner spawner) {
        BlueprintCreatureSpawner cs = new BlueprintCreatureSpawner();
        cs.setSpawnedType(spawner.getSpawnedType());
        cs.setDelay(spawner.getDelay());
        cs.setMaxNearbyEntities(spawner.getMaxNearbyEntities());
        cs.setMaxSpawnDelay(spawner.getMaxSpawnDelay());
        cs.setMinSpawnDelay(spawner.getMinSpawnDelay());
        cs.setRequiredPlayerRange(spawner.getRequiredPlayerRange());
        cs.setSpawnRange(spawner.getSpawnRange());
        return cs;
    }
    /**
     * Deals with any entities that are in this block. Technically, this could be more than one, but is usually one.
     * @param ents collection of entities
     * @return Serialized list of entities
     */
    private List<BlueprintEntity> setEntities(List<Entity> ents) {
        List<BlueprintEntity> bpEnts = new ArrayList<>();
        for (Entity entity : ents) {
            BlueprintEntity bpe = new BlueprintEntity(entity);
            // Mythic mob check
            mmh.filter(mm -> mm.isMythicMob(entity)).map(mm -> mm.getMythicMob(entity))
                    .ifPresent(bpe::setMythicMobsRecord);
            bpEnts.add(bpe);
        }
        return bpEnts;
    }
    /**
     * @return the origin
     */
    @Nullable
    public Vector getOrigin() {
        return origin;
    }
    /**
     * @return the pos1
     */
    @Nullable
    public Location getPos1() {
        return pos1;
    }
    /**
     * @return the pos2
     */
    @Nullable
    public Location getPos2() {
        return pos2;
    }
    public boolean isFull() {
        return blueprint != null;
    }
    /**
     * @param origin the origin to set
     */
    public void setOrigin(@Nullable Vector origin) {
        this.origin = origin;
    }
    /**
     * @param pos1 the pos1 to set
     */
    public void setPos1(@Nullable Location pos1) {
        origin = null;
        if (pos1 != null) {
            final int minHeight = pos1.getWorld() == null ? 0 : pos1.getWorld().getMinHeight();
            final int maxHeight = pos1.getWorld() == null ? 255 : pos1.getWorld().getMaxHeight();
            if (pos1.getBlockY() < minHeight)
            {
                pos1.setY(minHeight);
            }
            if (pos1.getBlockY() > maxHeight)
            {
                pos1.setY(maxHeight);
            }
        }
        this.pos1 = pos1;
    }
    /**
     * @param pos2 the pos2 to set
     */
    public void setPos2(@Nullable Location pos2) {
        origin = null;
        if (pos2 != null) {
            final int minHeight = pos2.getWorld() == null ? 0 : pos2.getWorld().getMinHeight();
            final int maxHeight = pos2.getWorld() == null ? 255 : pos2.getWorld().getMaxHeight();
            if (pos2.getBlockY() < minHeight)
            {
                pos2.setY(minHeight);
            }
            if (pos2.getBlockY() > maxHeight)
            {
                pos2.setY(maxHeight);
            }
        }
        this.pos2 = pos2;
    }
    /**
     * @return the blueprint
     */
    public @Nullable Blueprint getBlueprint() {
        return blueprint;
    }
    /**
     * @param blueprint the blueprint to set
     */
    public BlueprintClipboard setBlueprint(Blueprint blueprint) {
        this.blueprint = blueprint;
        return this;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.List;
import java.util.Optional;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
public class AdminBlueprintCopyCommand extends CompositeCommand
{
    public AdminBlueprintCopyCommand(AdminBlueprintCommand parent)
    {
        super(parent, "copy");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.copy");
        setParametersHelp("commands.admin.blueprint.copy.parameters");
        setDescription("commands.admin.blueprint.copy.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        if (args.size() > 2)
        {
            this.showHelp(this, user);
            return false;
        }
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        BlueprintClipboard clipboard =
                parent.getClipboards().computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        boolean copyAir = args.stream().anyMatch(key -> key.equalsIgnoreCase("air"));
        boolean copyBiome = args.stream().anyMatch(key -> key.equalsIgnoreCase("biome"));
        boolean noWater = args.stream().anyMatch(key -> key.equalsIgnoreCase("nowater"));
        return clipboard.copy(user, copyAir, copyBiome, noWater);
    }
    @Override
    public Optional<List<String>> tabComplete(User user, String alias, List<String> args)
    {
        return Optional.of(List.of("air", "biome", "nowater"));
    }
}
package world.bentobox.bentobox.api.commands.admin;
import java.util.List;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.commands.admin.blueprints.AdminBlueprintCommand;
import world.bentobox.bentobox.api.commands.admin.deaths.AdminDeathsCommand;
import world.bentobox.bentobox.api.commands.admin.purge.AdminPurgeCommand;
import world.bentobox.bentobox.api.commands.admin.range.AdminRangeCommand;
import world.bentobox.bentobox.api.commands.admin.resets.AdminResetsCommand;
import world.bentobox.bentobox.api.commands.admin.team.AdminTeamAddCommand;
import world.bentobox.bentobox.api.commands.admin.team.AdminTeamCommand;
import world.bentobox.bentobox.api.commands.admin.team.AdminTeamDisbandCommand;
import world.bentobox.bentobox.api.commands.admin.team.AdminTeamKickCommand;
import world.bentobox.bentobox.api.commands.admin.team.AdminTeamSetownerCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
/**
 * This is default Admin command for console and op. It contains all necessary parts that
 * for main command.
 * @since 1.13.0
 * @author BONNe
 */
public abstract class DefaultAdminCommand extends CompositeCommand {
    /**
     * This is the top-level command constructor for commands that have no parent.
     *
     * @param addon   - GameMode addon
     */
    protected DefaultAdminCommand(GameModeAddon addon) {
        // Register command with alias from config.
        // The first command listed is the "label" and the others are aliases.
        super(addon,
                addon.getWorldSettings().getAdminCommandAliases().split(" ")[0],
                addon.getWorldSettings().getAdminCommandAliases().split(" "));
    }
    /**
     * Setups anything that is necessary for default main admin command.
     * @see world.bentobox.bentobox.api.commands.BentoBoxCommand#setup()
     */
    @Override
    public void setup() {
        this.setPermission("admin");
        this.setOnlyPlayer(false);
        this.setParametersHelp("commands.admin.help.parameters");
        this.setDescription("commands.admin.help.description");
        new AdminVersionCommand(this);
        new AdminTeleportCommand(this, "tp");
        new AdminTeleportCommand(this, "tpnether");
        new AdminTeleportCommand(this, "tpend");
        new AdminTeleportUserCommand(this, "tpuser");
        new AdminTeleportUserCommand(this, "tpusernether");
        new AdminTeleportUserCommand(this, "tpuserend");
        new AdminGetrankCommand(this);
        new AdminSetrankCommand(this);
        new AdminInfoCommand(this);
        // Team commands
        new AdminTeamCommand(this);
        new AdminTeamAddCommand(this);
        new AdminTeamKickCommand(this);
        new AdminTeamDisbandCommand(this);
        new AdminTeamSetownerCommand(this);
        // Blueprints
        new AdminBlueprintCommand(this);
        // Register/unregister islands
        new AdminRegisterCommand(this);
        new AdminUnregisterCommand(this);
        // Range
        new AdminRangeCommand(this);
        // Resets
        new AdminResetsCommand(this);
        // Delete
        new AdminDeleteCommand(this);
        // Why
        new AdminWhyCommand(this);
        // Deaths
        new AdminDeathsCommand(this);
        // Reload
        new AdminReloadCommand(this);
        // Spawn
        new AdminSetspawnCommand(this);
        // Spawn Point command
        new AdminSetSpawnPointCommand(this);
        // Reset flags
        new AdminResetFlagsCommand(this);
        // Switch
        new AdminSwitchCommand(this);
        // Purge
        new AdminPurgeCommand(this);
        // Settings
        new AdminSettingsCommand(this);
        // Location
        new AdminSetProtectionCenterCommand(this);
        // Delete homes
        new AdminDeleteHomesCommand(this);
        // Reset name
        new AdminResetNameCommand(this);
        // Max homes
        new AdminMaxHomesCommand(this);
        // Reset Home
        new AdminResetHomeCommand(this);
    }
    /**
     * Defines what will be executed when this command is run.
     * @see world.bentobox.bentobox.api.commands.BentoBoxCommand#execute(User, String, List)
     */
    @Override
    public boolean execute(User user, String label, List<String> args) {
        if (user != null && !args.isEmpty()) {
            user.sendMessage("general.errors.unknown-command", TextVariables.LABEL, getTopLabel());
            return false;
        }
        // By default run the attached help command, if it exists (it should)
        return this.showHelp(this, user);
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.managers.BlueprintClipboardManager;
import world.bentobox.bentobox.util.Util;
public class AdminBlueprintLoadCommand extends CompositeCommand {
    public AdminBlueprintLoadCommand(AdminBlueprintCommand parent) {
        super(parent, "load");
    }
    @Override
    public void setup() {
        setPermission("admin.blueprint.load");
        setParametersHelp("commands.admin.blueprint.load.parameters");
        setDescription("commands.admin.blueprint.load.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        if (args.size() != 1) {
            showHelp(this, user);
            return false;
        }
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        BlueprintClipboardManager bp = new BlueprintClipboardManager(getPlugin(), parent.getBlueprintsFolder());
        if (bp.load(user, Util.sanitizeInput(args.get(0)))) {
            parent.getClipboards().put(user.getUniqueId(), bp.getClipboard());
            return true;
        }
        return false;
    }
    @Override
    public Optional<List<String>> tabComplete(User user, String alias, List<String> args) {
        List<String> options = new ArrayList<>();
        options.add("island");
        options.add("nether-island");
        options.add("end-island");
        String lastArg = !args.isEmpty() ? args.get(args.size()-1) : "";
        return Optional.of(Util.tabLimit(options, lastArg));
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.List;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.blueprints.BlueprintPaster;
public class AdminBlueprintPasteCommand extends CompositeCommand {
    public AdminBlueprintPasteCommand(AdminBlueprintCommand parent) {
        super(parent, "paste");
    }
    @Override
    public void setup() {
        setPermission("admin.blueprint.paste");
        setParametersHelp("commands.admin.blueprint.paste.parameters");
        setDescription("commands.admin.blueprint.paste.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        BlueprintClipboard clipboard = parent.getClipboards().computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        if (clipboard.isFull()) {
            new BlueprintPaster(getPlugin(), clipboard, user.getLocation()).paste(false).thenAccept(b -> {
                user.sendMessage("general.success");
                parent.showClipboard(user);
            });
            user.sendMessage("commands.admin.blueprint.paste.pasting");
            return true;
        }
        user.sendMessage("commands.admin.blueprint.copy-first");
        return false;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.List;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
/**
 * Renames an existing blueprint.
 * @author Poslovitch
 * @since 1.10.0
 */
public class AdminBlueprintRenameCommand extends ConfirmableCommand
{
    public AdminBlueprintRenameCommand(AdminBlueprintCommand parent)
    {
        super(parent, "rename");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.rename");
        this.setParametersHelp("commands.admin.blueprint.rename.parameters");
        this.setDescription("commands.admin.blueprint.rename.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (args.size() != 2)
        {
            // Blueprint must have a name.
            this.showHelp(this, user);
            return false;
        }
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        // Check if name is changed.
        if (from.equals(to))
        {
            user.sendMessage("commands.admin.blueprint.rename.pick-different-name");
            return false;
        }
        // Check if the 'from' file exists
        AdminBlueprintCommand parent = (AdminBlueprintCommand) this.getParent();
        File fromFile = new File(parent.getBlueprintsFolder(), from + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (!fromFile.exists())
        {
            user.sendMessage("commands.admin.blueprint.no-such-file");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        // Check if the names are the same
        String from = Util.sanitizeInput(args.get(0));
        String to = Util.sanitizeInput(args.get(1));
        // Check if the 'to' file exists
        File toFile = new File(parent.getBlueprintsFolder(), to + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (toFile.exists())
        {
            // Ask for confirmation to overwrite
            this.askConfirmation(user,
                    user.getTranslation("commands.admin.blueprint.file-exists"),
                    () -> this.rename(user, from, to, args.get(1)));
        }
        else
        {
            this.askConfirmation(user, () -> this.rename(user, from, to, args.get(1)));
        }
        return true;
    }
    private void rename(User user, String blueprintName, String fileName, String displayName)
    {
        Blueprint blueprint = this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).get(blueprintName);
        this.getPlugin().getBlueprintsManager().renameBlueprint(this.getAddon(), blueprint, fileName, displayName);
        user.sendMessage("commands.admin.blueprint.rename.success",
                "[old]",
                blueprintName,
                TextVariables.NAME,
                blueprint.getName(),
                "[display]",
                blueprint.getDisplayName());
    }
}
package world.bentobox.bentobox.api.commands;
import java.util.HashMap;
import java.util.Map;
import org.bukkit.Bukkit;
import org.bukkit.scheduler.BukkitTask;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.api.user.User;
/**
 * BentoBox Confirmable Command
 * Adds ability to confirm a command before execution.
 * See {@link #askConfirmation(User, Runnable)}, {@link #askConfirmation(User, String, Runnable)}
 * @author tastybento
 * @author Poslovitch
 */
public abstract class ConfirmableCommand extends CompositeCommand {
    /**
     * Confirmation tracker
     */
    private static final Map<User, Confirmer> toBeConfirmed = new HashMap<>();
    /**
     * Top level command
     * @param addon - addon creating the command
     * @param label - string for this command
     * @param aliases - aliases
     */
    protected ConfirmableCommand(Addon addon, String label, String... aliases) {
        super(addon, label, aliases);
    }
    /**
     * Command to register a command from an addon under a parent command (that could be from another addon)
     * @param addon - this command's addon
     * @param parent - parent command
     * @param aliases - aliases for this command
     */
    protected ConfirmableCommand(Addon addon, CompositeCommand parent, String label, String... aliases ) {
        super(addon, parent, label, aliases);
    }
    /**
     *
     * @param parent - parent command
     * @param label - command label
     * @param aliases - command aliases
     */
    protected ConfirmableCommand(CompositeCommand parent, String label, String... aliases) {
        super(parent, label, aliases);
    }
    /**
     * Tells user to confirm command by retyping it.
     * @param user User to ask confirmation to.
     * @param message Optional message to send to the user to give them a bit more context. It must already be translated.
     * @param confirmed Runnable to be executed if successfully confirmed.
     */
    public void askConfirmation(User user, String message, Runnable confirmed) {
        // Check for pending confirmations
        if (toBeConfirmed.containsKey(user)) {
            if (toBeConfirmed.get(user).topLabel().equals(getTopLabel()) && toBeConfirmed.get(user).label().equalsIgnoreCase(getLabel())) {
                toBeConfirmed.get(user).task().cancel();
                Bukkit.getScheduler().runTask(getPlugin(), toBeConfirmed.get(user).runnable());
                toBeConfirmed.remove(user);
                return;
            } else {
                // Player has another outstanding confirmation request that will now be cancelled
                user.sendMessage("commands.confirmation.previous-request-cancelled");
            }
        }
        // Send user the context message if it is not empty
        if (!message.trim().isEmpty()) {
            user.sendRawMessage(message);
        }
        // Tell user that they need to confirm
        user.sendMessage("commands.confirmation.confirm", "[seconds]", String.valueOf(getSettings().getConfirmationTime()));
        // Set up a cancellation task
        BukkitTask task = Bukkit.getScheduler().runTaskLater(getPlugin(), () -> {
            user.sendMessage("commands.confirmation.request-cancelled");
            toBeConfirmed.remove(user);
        }, getPlugin().getSettings().getConfirmationTime() * 20L);
        // Add to the global confirmation map
        toBeConfirmed.put(user, new Confirmer(getTopLabel(), getLabel(), confirmed, task));
    }
    /**
     * Tells user to confirm command by retyping it. Uses the default message to retype it.<p>
     * If you need a custom message, use {@link #askConfirmation(User, String, Runnable)}
     * @param user User to ask confirmation to.
     * @param confirmed Runnable to be executed if successfully confirmed.
     */
    public void askConfirmation(User user, Runnable confirmed) {
        askConfirmation(user, "", confirmed);
    }
    /**
     * Record to hold the data to run once the confirmation is given
     *
     */
    private record Confirmer (String topLabel, String label, Runnable runnable, BukkitTask task) { }
}
package world.bentobox.bentobox.managers;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.InputMismatchException;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.jar.JarFile;
import java.util.stream.Collectors;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.util.Vector;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.InstanceCreator;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.Addon;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.metadata.MetaDataValue;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.BlueprintPaster;
import world.bentobox.bentobox.blueprints.DisplayListener;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBlock;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.database.json.BentoboxTypeAdapterFactory;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.util.Util;
/**
 * Handles Blueprints
 *
 * @author Poslovitch, tastybento
 * @since 1.5.0
 */
public class BlueprintsManager {
    private static final String BLUEPRINT_BUNDLE_SUFFIX = ".json";
    public static final String BLUEPRINT_SUFFIX = ".blu";
    public static final String DEFAULT_BUNDLE_NAME = "default";
    @NonNull
    public static final String FOLDER_NAME = "blueprints";
    private static final String FOR = "' for ";
    /**
     * Map of blueprint bundles to game mode addon.
     * Inner map's key is the uniqueId of the blueprint bundle so it's
     * easy to get from a UI
     */
    @NonNull
    private final Map<GameModeAddon, List<BlueprintBundle>> blueprintBundles;
    /**
     * Map of blueprints. There can be many blueprints per game mode addon
     * Inner map's key is the blueprint's name so it's easy to get from a UI
     */
    @NonNull
    private final Map<GameModeAddon, List<Blueprint>> blueprints;
    /**
     * Gson used for serializing/deserializing the bundle class
     */
    private final Gson gson;
    private final @NonNull BentoBox plugin;
    @NonNull
    private final Set<GameModeAddon> blueprintsLoaded;
    public BlueprintsManager(@NonNull BentoBox plugin) {
        this.plugin = plugin;
        // Must use ConcurrentHashMap because the maps are loaded async and they need to be thread safe
        this.blueprintBundles = new ConcurrentHashMap<>();
        this.blueprints = new ConcurrentHashMap<>();
        @SuppressWarnings({"rawtypes", "unchecked"})
        GsonBuilder builder = new GsonBuilder()
        .excludeFieldsWithoutExposeAnnotation()
        .enableComplexMapKeySerialization()
        .setPrettyPrinting()
        // This enables gson to deserialize enum maps
        .registerTypeAdapter(EnumMap.class, (InstanceCreator<EnumMap>) type -> {
            Type[] types = (((ParameterizedType) type).getActualTypeArguments());
            return new EnumMap((Class<?>) types[0]);
        });
        // Disable <>'s escaping etc.
        builder.disableHtmlEscaping();
        // Register adapter factory
        builder.registerTypeAdapterFactory(new BentoboxTypeAdapterFactory(plugin));
        gson = builder.create();
        // Loaded tracker
        blueprintsLoaded = new HashSet<>();
        // Register Display listeners
        Bukkit.getPluginManager().registerEvents(new DisplayListener(), plugin);
    }
    /**
     * Extracts the blueprints and bundles provided by this {@link GameModeAddon} in its .jar file.
     * This will do nothing if the blueprints folder already exists for this GameModeAddon.
     *
     * @param addon the {@link GameModeAddon} to extract the blueprints from.
     */
    public void extractDefaultBlueprints(@NonNull GameModeAddon addon) {
        File folder = getBlueprintsFolder(addon);
        if (folder.exists()) {
            // If the folder exists, do not copy anything from the jar
            return;
        }
        if (!folder.exists() && !folder.mkdirs()) {
            plugin.logError("Could not create the '" + FOLDER_NAME + "' folder!");
            plugin.logError("This might be due to incorrectly set-up write permissions on the operating system.");
            return;
        }
        // Get any blueprints or bundles from the jar and save them.
        try (JarFile jar = new JarFile(addon.getFile())) {
            Util.listJarFiles(jar, FOLDER_NAME, BLUEPRINT_BUNDLE_SUFFIX).forEach(name -> addon.saveResource(name, false));
            Util.listJarFiles(jar, FOLDER_NAME, BLUEPRINT_SUFFIX).forEach(name -> addon.saveResource(name, false));
        } catch (IOException e) {
            plugin.logError("Could not load blueprint files from addon jar " + e.getMessage());
        }
    }
    /**
     * Get the blueprint bundles of this addon.
     *
     * @param addon the {@link GameModeAddon} to get the blueprint bundles.
     */
    @NonNull
    public Map<String, BlueprintBundle> getBlueprintBundles(@NonNull GameModeAddon addon) {
        if (!blueprintBundles.containsKey(addon)) {
            return new HashMap<>();
        }
        return blueprintBundles.get(addon).stream().collect(Collectors.toMap(BlueprintBundle::getUniqueId, b -> b));
    }
    /**
     * Get the default blueprint bundle for game mode
     * @param addon - game mode addon
     * @return the default blueprint bundle or null if none
     * @since 1.8.0
     */
    @Nullable
    public BlueprintBundle getDefaultBlueprintBundle(@NonNull GameModeAddon addon) {
        if (blueprintBundles.containsKey(addon)) {
            return blueprintBundles.get(addon).stream().filter(bb -> bb.getUniqueId().equals(DEFAULT_BUNDLE_NAME)).findFirst().orElse(null);
        }
        return null;
    }
    /**
     * Returns a {@link File} instance of the blueprints folder of this {@link GameModeAddon}.
     *
     * @param addon the {@link GameModeAddon}
     * @return a {@link File} instance of the blueprints folder of this GameModeAddon.
     */
    @NonNull
    private File getBlueprintsFolder(@NonNull GameModeAddon addon) {
        return new File(addon.getDataFolder(), FOLDER_NAME);
    }
    /**
     * Loads the blueprint bundles of this addon from its blueprints folder.
     *
     * @param addon the {@link GameModeAddon} to load the blueprints of.
     */
    public void loadBlueprintBundles(@NonNull GameModeAddon addon) {
        // Set loading flag
        blueprintsLoaded.add(addon);
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            // Load bundles
            blueprintBundles.put(addon, new ArrayList<>());
            if (!loadBundles(addon)) {
                makeDefaults(addon);
                loadBundles(addon);
            }
            // Load blueprints
            loadBlueprints(addon);
            // Clear loading flag
            blueprintsLoaded.remove(addon);
        });
    }
    /**
     * Check if all blueprints are loaded. Only query after all GameModes have been loaded.
     * @return true if all blueprints are loaded
     */
    public boolean isBlueprintsLoaded() {
        return blueprintsLoaded.isEmpty();
    }
    private boolean loadBundles(@NonNull GameModeAddon addon) {
        File bpf = getBlueprintsFolder(addon);
        if (!bpf.exists()) {
            plugin.logError("There is no blueprint folder for addon " + addon.getDescription().getName());
            bpf.mkdirs();
        }
        boolean loaded = false;
        File[] bundles = bpf.listFiles((dir, name) -> name.endsWith(BLUEPRINT_BUNDLE_SUFFIX));
        if (bundles == null || bundles.length == 0) {
            return false;
        }
        for (File file : bundles) {
            try (FileReader fileReader = new FileReader(file, StandardCharsets.UTF_8))
            {
                if (!file.getName().equals(Util.sanitizeInput(file.getName())))
                {
                    // fail on all blueprints with incorrect names.
                    throw new InputMismatchException(file.getName());
                }
                BlueprintBundle bb = gson.fromJson(fileReader, BlueprintBundle.class);
                if (bb != null) {
                    // Make sure there is no existing bundle with the same uniqueId
                    if (blueprintBundles.get(addon).stream().noneMatch(bundle ->  bundle.getUniqueId().equals(bb.getUniqueId()))) {
                        blueprintBundles.get(addon).add(bb);
                        plugin.log("Loaded Blueprint Bundle '" + bb.getUniqueId() + FOR + addon.getDescription().getName() + ".");
                        loaded = true;
                    } else {
                        // There is a bundle that already uses this uniqueId.
                        // In that case, we log that and do not load the new bundle.
                        plugin.logWarning("Could not load blueprint bundle '" + file.getName() + FOR + addon.getDescription().getName() + ".");
                        plugin.logWarning("The uniqueId '" + bb.getUniqueId() + "' is already used by another Blueprint Bundle.");
                        plugin.logWarning("This can occur if the Blueprint Bundles' files were manually edited.");
                        plugin.logWarning("Please review your Blueprint Bundles' files and make sure their uniqueIds are not in duplicate.");
                    }
                }
            } catch (Exception e) {
                plugin.logError("Could not load blueprint bundle '" + file.getName() + "'. Cause: " + e.getMessage() + ".");
                plugin.logStacktrace(e);
            }
        }
        return loaded;
    }
    private BlueprintBundle getDefaultBlueprintBundle() {
        BlueprintBundle bb = new BlueprintBundle();
        bb.setIcon(Material.PAPER);
        bb.setUniqueId(DEFAULT_BUNDLE_NAME);
        bb.setDisplayName("Default bundle");
        bb.setDescription(Collections.singletonList(ChatColor.AQUA + "Default bundle of blueprints"));
        return bb;
    }
    private Blueprint getDefaultBlueprint() {
        Blueprint defaultBp = new Blueprint();
        defaultBp.setName("bedrock");
        defaultBp.setDescription(Collections.singletonList(ChatColor.AQUA + "A bedrock block"));
        defaultBp.setBedrock(new Vector(0, 0, 0));
        Map<Vector, BlueprintBlock> map = new HashMap<>();
        map.put(new Vector(0, 0, 0), new BlueprintBlock("minecraft:bedrock"));
        defaultBp.setBlocks(map);
        return defaultBp;
    }
    /**
     * This should never be needed and is just a boot strap
     *
     * @param addon addon
     */
    private void makeDefaults(@NonNull GameModeAddon addon) {
        plugin.logError("No blueprint bundles found! Creating a default one.");
        BlueprintBundle bb = getDefaultBlueprintBundle();
        // Default blueprints
        Blueprint defaultBp = getDefaultBlueprint();
        // Save a default "bedrock" blueprint
        new BlueprintClipboardManager(plugin, getBlueprintsFolder(addon)).saveBlueprint(defaultBp);
        // This blueprint is used for all environments
        bb.setBlueprint(World.Environment.NORMAL, defaultBp);
        bb.setBlueprint(World.Environment.NETHER, defaultBp);
        bb.setBlueprint(World.Environment.THE_END, defaultBp);
        bb.setUniqueId(DEFAULT_BUNDLE_NAME);
        blueprintBundles.get(addon).add(bb);
        this.saveBlueprintBundles();
    }
    /**
     * Loads all the blueprints of this addon from its blueprints folder.
     *
     * @param addon the {@link GameModeAddon} to load the blueprints of.
     */
    public void loadBlueprints(@NonNull GameModeAddon addon) {
        blueprints.put(addon, new ArrayList<>());
        File bpf = getBlueprintsFolder(addon);
        if (!bpf.exists()) {
            plugin.logError("There is no blueprint folder for addon " + addon.getDescription().getName());
            bpf.mkdirs();
        }
        File[] bps = bpf.listFiles((dir, name) -> name.endsWith(BLUEPRINT_SUFFIX));
        if (bps == null || bps.length == 0) {
            plugin.logError("No blueprints found for " + addon.getDescription().getName());
            return;
        }
        for (File file : bps) {
            // Input sanitization is required for weirdos that edit files manually.
            String fileName = Util.sanitizeInput(file.getName().substring(0, file.getName().length() - BLUEPRINT_SUFFIX.length()));
            try {
                Blueprint bp = new BlueprintClipboardManager(plugin, bpf).loadBlueprint(fileName);
                bp.setName(fileName);
                blueprints.get(addon).add(bp);
                plugin.log("Loaded blueprint '" + bp.getName() + FOR + addon.getDescription().getName());
            } catch (Exception e) {
                plugin.logError("Could not load blueprint " + fileName + " " + e.getMessage());
                plugin.logStacktrace(e);
            }
        }
    }
    /**
     * Adds a blueprint to addon's list of blueprints. If the list already contains a blueprint with the same name
     * it is replaced.
     *
     * @param addon - the {@link GameModeAddon}
     * @param bp    - blueprint
     */
    public void addBlueprint(@NonNull GameModeAddon addon, @NonNull Blueprint bp) {
        blueprints.putIfAbsent(addon, new ArrayList<>());
        blueprints.get(addon).removeIf(b -> b.getName().equals(bp.getName()));
        blueprints.get(addon).add(bp);
        plugin.log("Added blueprint '" + bp.getName() + FOR + addon.getDescription().getName());
    }
    /**
     * Saves a blueprint into addon's blueprint folder
     *
     * @param addon - the {@link GameModeAddon}
     * @param bp    - blueprint to save
     */
    public boolean saveBlueprint(@NonNull GameModeAddon addon, @NonNull Blueprint bp) {
        return new BlueprintClipboardManager(plugin, getBlueprintsFolder(addon)).saveBlueprint(bp);
    }
    /**
     * Save blueprint bundle for game mode
     *
     * @param addon - gamemode addon
     * @param bb    blueprint bundle to save
     */
    public void saveBlueprintBundle(GameModeAddon addon, BlueprintBundle bb) {
        Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
            File bpf = getBlueprintsFolder(addon);
            if (!bpf.exists()) {
                bpf.mkdirs();
            }
            File fileName = new File(bpf, bb.getUniqueId() + BLUEPRINT_BUNDLE_SUFFIX);
            String toStore = gson.toJson(bb, BlueprintBundle.class);
            try (FileWriter fileWriter = new FileWriter(fileName, StandardCharsets.UTF_8)) {
                fileWriter.write(toStore);
            } catch (IOException e) {
                plugin.logError("Could not save blueprint bundle file: " + e.getMessage());
            }
        });
    }
    /**
     * Saves all the blueprint bundles
     */
    public void saveBlueprintBundles() {
        blueprintBundles.forEach((k, v) -> v.forEach(m -> saveBlueprintBundle(k, m)));
    }
    /**
     * Get blueprints for this game mode
     *
     * @param addon - game mode addon
     * @return Map of name and blueprint or empty map
     */
    public Map<String, Blueprint> getBlueprints(GameModeAddon addon) {
        if (!blueprints.containsKey(addon)) {
            return new HashMap<>();
        }
        return blueprints.get(addon).stream().collect(Collectors.toMap(Blueprint::getName, b -> b));
    }
    /**
     * Unregisters the Blueprint from the manager and deletes the file.
     * @param addon game mode addon
     * @param name name of the Blueprint to delete
     * @since 1.9.0
     */
    public void deleteBlueprint(GameModeAddon addon, String name)
    {
        List<Blueprint> addonBlueprints = this.blueprints.get(addon);
        Iterator<Blueprint> it = addonBlueprints.iterator();
        while (it.hasNext())
        {
            Blueprint b = it.next();
            if (b.getName().equalsIgnoreCase(name))
            {
                it.remove();
                File file = new File(this.getBlueprintsFolder(addon), b.getName() + BLUEPRINT_SUFFIX);
                // Delete the file
                try
                {
                    Files.deleteIfExists(file.toPath());
                }
                catch (IOException e)
                {
                    this.plugin.logError("Could not delete Blueprint " + e.getLocalizedMessage());
                }
            }
        }
    }
    /**
     * Paste the islands to world
     *
     * @param addon  - GameModeAddon
     * @param island - island
     * @param name   - bundle name
     */
    public void paste(GameModeAddon addon, Island island, String name) {
        paste(addon, island, name, null, true);
    }
    /**
     * Paste islands to the world and run task afterwards
     *
     * @param addon  - the game mode addon
     * @param island - the island
     * @param name   - name of bundle to paste
     * @param task   - task to run after pasting is completed
     * @param useNMS - true to use NMS pasting
     * @return true if okay, false is there is a problem
     */
    public boolean paste(GameModeAddon addon, Island island, String name, Runnable task, boolean useNMS) {
        if (validate(addon, name) == null) {
            plugin.logError("Tried to paste '" + name + "' but the bundle is not loaded!");
            return false;
        }
        BlueprintBundle bb = getBlueprintBundles(addon).get(name.toLowerCase());
        if (!blueprints.containsKey(addon) || blueprints.get(addon).isEmpty()) {
            plugin.logError("No blueprints loaded for bundle '" + name + "'!");
            return false;
        }
        Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.NORMAL));
        if (bp == null) {
            // Oops, no overworld
            bp = getBlueprints(addon).get("island");
            plugin.logError("Blueprint bundle has no normal world blueprint, using default");
            if (bp == null) {
                plugin.logError("NO DEFAULT BLUEPRINT FOUND! Make sure 'island.blu' exists!");
            }
        }
        // Paste
        if (bp != null) {
            new BlueprintPaster(plugin, bp, addon.getOverWorld(), island).paste(useNMS)
                    .thenAccept(b -> pasteNether(addon, bb, island).thenAccept(
                            b2 ->
            pasteEnd(addon, bb, island).thenAccept(message -> sendMessage(island)).thenAccept(b3 -> Bukkit.getScheduler().runTask(plugin, task))));
        }
        // Set the bundle name
        island.putMetaData("bundle", new MetaDataValue(name));
        return true;
    }
    private CompletableFuture<Boolean> pasteNether(GameModeAddon addon, BlueprintBundle bb, Island island) {
        if (bb.getBlueprint(World.Environment.NETHER) != null
                && addon.getWorldSettings().isNetherGenerate()
                && addon.getWorldSettings().isNetherIslands()
                && addon.getNetherWorld() != null) {
            Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.NETHER));
            if (bp != null) {
                return new BlueprintPaster(plugin, bp, addon.getNetherWorld(), island).paste();
            }
        }
        return CompletableFuture.completedFuture(false);
    }
    private CompletableFuture<Boolean> pasteEnd(GameModeAddon addon, BlueprintBundle bb, Island island) {
        // Make end island
        if (bb.getBlueprint(World.Environment.THE_END) != null
                && addon.getWorldSettings().isEndGenerate()
                && addon.getWorldSettings().isEndIslands()
                && addon.getEndWorld() != null) {
            Blueprint bp = getBlueprints(addon).get(bb.getBlueprint(World.Environment.THE_END));
            if (bp != null) {
                return new BlueprintPaster(plugin, bp, addon.getEndWorld(), island).paste();
            }
        }
        return CompletableFuture.completedFuture(false);
    }
    /**
     * This method just sends a message to the island owner that island creating is completed.
     * @param island Island which owner must receive a message.
     */
    private void sendMessage(Island island) {
        if (island != null && island.getOwner() != null) {
            final Optional<User> owner = Optional.of(island).map(i -> User.getInstance(i.getOwner()));
            owner.ifPresent(user -> user.sendMessage("commands.island.create.pasting.done"));
        }
    }
    /**
     * Validate if the bundle name is valid or not
     *
     * @param addon - game mode addon
     * @param name  - bundle name
     * @return bundle name or null if it's invalid
     */
    public @Nullable String validate(GameModeAddon addon, String name) {
        if (name == null) {
            return null;
        }
        if (blueprintBundles.containsKey(addon) && getBlueprintBundles(addon).containsKey(name)) {
            return name;
        }
        return null;
    }
    /**
     * Adds a blueprint bundle. If a bundle with the same uniqueId exists, it will be replaced
     *
     * @param addon - the game mode addon
     * @param bb    - the blueprint bundle
     */
    public void addBlueprintBundle(GameModeAddon addon, BlueprintBundle bb) {
        if (blueprintBundles.containsKey(addon)) {
            // Remove any bundles with the same name
            blueprintBundles.get(addon).removeIf(b -> b.getUniqueId().equals(bb.getUniqueId()));
        }
        blueprintBundles.computeIfAbsent(addon, k -> new ArrayList<>()).add(bb);
    }
    /**
     * Checks if a player has permission to see or use this blueprint bundle.
     *
     * @param addon - addon making the request
     * @param user  - user making the request
     * @param name  - name of the blueprint bundle
     * @return <tt>true</tt> if allowed, <tt>false</tt> if not or bundle does not exist
     */
    public boolean checkPerm(@NonNull Addon addon, @NonNull User user, @NonNull String name) {
        // Permission
        String permission = addon.getPermissionPrefix() + "island.create." + name;
        // Get Blueprint bundle
        BlueprintBundle bb = getBlueprintBundles((GameModeAddon) addon).get(name.toLowerCase());
        if (bb == null || (bb.isRequirePermission() && !name.equals(DEFAULT_BUNDLE_NAME) && !user.hasPermission(permission))) {
            user.sendMessage("general.errors.no-permission", TextVariables.PERMISSION, permission);
            return false;
        }
        return true;
    }
    /**
     * Removes a blueprint bundle
     *
     * @param addon - Game Mode Addon
     * @param bb    - Blueprint Bundle to delete
     */
    public void deleteBlueprintBundle(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        if (blueprintBundles.containsKey(addon)) {
            blueprintBundles.get(addon).removeIf(k -> k.getUniqueId().equals(bb.getUniqueId()));
        }
        File bpf = getBlueprintsFolder(addon);
        File fileName = new File(bpf, bb.getUniqueId() + BLUEPRINT_BUNDLE_SUFFIX);
        try {
            Files.deleteIfExists(fileName.toPath());
        } catch (IOException e) {
            plugin.logError("Could not delete Blueprint Bundle " + e.getLocalizedMessage());
        }
    }
    /**
     * Rename a blueprint
     *
     * @param addon - Game Mode Addon
     * @param bp    - blueprint
     * @param name  - new name
     * @param displayName - display name for blueprint
     */
    public void renameBlueprint(GameModeAddon addon, Blueprint bp, String name, String displayName)
    {
        if (bp.getName().equalsIgnoreCase(name))
        {
            // If the name is the same, do not do anything
            return;
        }
        File bpf = this.getBlueprintsFolder(addon);
        // Get the filename
        File fileName = new File(bpf, bp.getName() + BLUEPRINT_SUFFIX);
        // Delete the old file
        try
        {
            Files.deleteIfExists(fileName.toPath());
        }
        catch (IOException e)
        {
            this.plugin.logError("Could not delete old Blueprint " + e.getLocalizedMessage());
        }
        // Remove blueprint from the blueprints.
        this.blueprints.get(addon).remove(bp);
        // Set new name
        bp.setName(name);
        bp.setDisplayName(displayName);
        // Save it
        this.saveBlueprint(addon, bp);
        this.addBlueprint(addon, bp);
    }
}
package world.bentobox.bentobox.managers;
import java.io.File;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import org.bukkit.Bukkit;
import org.bukkit.Difficulty;
import org.bukkit.GameMode;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.entity.EntityType;
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.configuration.WorldSettings;
import world.bentobox.bentobox.api.flags.Flag;
import world.bentobox.bentobox.api.hooks.Hook;
import world.bentobox.bentobox.hooks.WorldManagementHook;
import world.bentobox.bentobox.lists.Flags;
/**
 * Handles registration and management of worlds
 *
 * @author tastybento
 */
public class IslandWorldManager {
    private final BentoBox plugin;
    /**
     * Map associating Worlds (Overworld, Nether and End) with the GameModeAddon that creates them.
     */
    private final Map<@NonNull World, @NonNull GameModeAddon> gameModes;
    /**
     * Manages worlds registered with BentoBox
     */
    public IslandWorldManager(BentoBox plugin) {
        this.plugin = plugin;
        gameModes = new HashMap<>();
    }
    /**
     * Registers or unregisters worlds with world management plugins
     *
     * @param reg true to register, false to remove registration
     *
     * Updated 1.24.0
     */
    public void registerWorldsToMultiverse(boolean reg) {
        gameModes.values().stream().distinct().forEach(gm -> {
            registerToWorldManagementPlugins(gm.getOverWorld(), true, reg);
            registerSeedWorld(gm.getOverWorld(), reg);
            if (gm.getWorldSettings().isNetherGenerate()) {
                registerToWorldManagementPlugins(gm.getNetherWorld(), gm.getWorldSettings().isNetherIslands(), reg);
                registerSeedWorld(gm.getNetherWorld(), reg);
            }
            if (gm.getWorldSettings().isEndGenerate()) {
                registerToWorldManagementPlugins(gm.getEndWorld(), gm.getWorldSettings().isEndIslands(), reg);
                registerSeedWorld(gm.getEndWorld(), reg);
            }
        });
    }
    private void registerSeedWorld(World world, boolean reg) {
        if (world == null) {
            return;
        }
        World seed = Bukkit.getWorld(world.getName() + "/bentobox");
        if (seed != null) {
            registerToWorldManagementPlugins(seed, true, reg);
        }
    }
    private void registerToWorldManagementPlugins(@NonNull World world, boolean islandWorld, boolean reg) {
        if (plugin.getHooks() == null) {
            return;
        }
        for (Hook hook : plugin.getHooks().getHooks()) {
            if (hook instanceof final WorldManagementHook worldManagementHook) {
                if (Bukkit.isPrimaryThread()) {
                    runTask(worldManagementHook, world, islandWorld, reg);
                } else {
                    Bukkit.getScheduler().runTask(plugin, () -> runTask(worldManagementHook, world, islandWorld, reg));
                }
            }
        }
    }
    private void runTask(WorldManagementHook worldManagementHook, @NonNull World world, boolean islandWorld,
            boolean reg) {
        if (reg) {
            worldManagementHook.registerWorld(world, islandWorld);
        } else {
            worldManagementHook.unregisterWorld(world);
        }
    }
    /**
     * Checks if a location is in any of the island worlds.
     * This will be false if the player is in the standard Nether or standard End.
     *
     * @param loc - location
     * @return true if in a world or false if not. False if in standard Nether or standard End.
     */
    public boolean inWorld(@Nullable Location loc) {
        return loc != null && inWorld(loc.getWorld());
    }
    /**
     * Checks if a world is any of the island worlds
     *
     * @param world world
     * @return true if in a world or false if not
     */
    public boolean inWorld(@Nullable World world) {
        return world != null && gameModes.containsKey(world)
                && (world.getEnvironment().equals(Environment.NORMAL) || isIslandNether(world) || isIslandEnd(world));
    }
    /**
     * @return Set of all worlds registered by GameModeAddons
     * @since 1.1
     */
    @NonNull
    public Set<World> getWorlds() {
        return gameModes.keySet();
    }
    /**
     * @return List of over worlds
     */
    public List<World> getOverWorlds() {
        return gameModes.keySet().stream().filter(w -> w.getEnvironment().equals(Environment.NORMAL)).toList();
    }
    /**
     * Get friendly names of all the over worlds and associated GameModeAddon
     *
     * @return Map of world names and associated GameModeAddon friendly name
     */
    public Map<String, String> getOverWorldNames() {
        return gameModes.values().stream().distinct().collect(
                Collectors.toMap(a -> a.getOverWorld().getName(), a -> a.getWorldSettings().getFriendlyName()));
    }
    /**
     * Check if a name is a known friendly world name, ignores case
     *
     * @param name - world name
     * @return true if name is a known world name
     */
    public boolean isKnownFriendlyWorldName(String name) {
        return gameModes.values().stream().distinct()
                .anyMatch(gm -> gm.getWorldSettings().getFriendlyName().equalsIgnoreCase(name));
    }
    /**
     * Associate a world with a game mode. This enables game modes to register more worlds than just the standard
     * overworld, nether, and end worlds.
     * @param world world
     * @param gameMode game mode
     * @since 1.24.0
     */
    public void addWorld(World world, GameModeAddon gameMode) {
        gameModes.put(world, gameMode);
    }
    /**
     * Adds a GameMode to island world manager
     * @param gameMode - game mode to add
     * @throws NullPointerException - exception if the game mode overworld is null
     */
    public void addGameMode(@NonNull GameModeAddon gameMode) {
        WorldSettings settings = gameMode.getWorldSettings();
        World world = gameMode.getOverWorld();
        if (world == null) {
            throw new NullPointerException(
                    "Gamemode overworld object is null for " + gameMode.getDescription().getName());
        }
        String friendlyName = settings.getFriendlyName().isEmpty() ? world.getName() : settings.getFriendlyName();
        // Add worlds to map
        gameModes.put(world, gameMode);
        // Call Multiverse
        registerToWorldManagementPlugins(world, true, true);
        if (settings.isNetherGenerate() && gameMode.getNetherWorld() != null) {
            gameModes.put(gameMode.getNetherWorld(), gameMode);
            if (settings.isNetherIslands()) {
                registerToWorldManagementPlugins(gameMode.getNetherWorld(), true, true);
            }
        }
        if (settings.isEndGenerate() && gameMode.getEndWorld() != null) {
            gameModes.put(gameMode.getEndWorld(), gameMode);
            if (settings.isEndIslands()) {
                registerToWorldManagementPlugins(gameMode.getEndWorld(), true, true);
            }
        }
        // Set default island settings
        plugin.getFlagsManager().getFlags().stream().filter(f -> f.getType().equals(Flag.Type.PROTECTION))
                .forEach(f -> settings.getDefaultIslandFlagNames().putIfAbsent(f.getID(), f.getDefaultRank()));
        plugin.getFlagsManager().getFlags().stream().filter(f -> f.getType().equals(Flag.Type.SETTING))
                .forEach(f -> settings.getDefaultIslandSettingNames().putIfAbsent(f.getID(), f.getDefaultRank()));
        Bukkit.getScheduler().runTask(plugin, () -> {
            // Set world difficulty
            Difficulty diff = settings.getDifficulty();
            if (diff == null) {
                diff = Difficulty.NORMAL;
                settings.setDifficulty(diff);
            }
            world.setDifficulty(diff);
            // Handle nether and end difficulty levels
            if (settings.isNetherGenerate()) {
                this.getNetherWorld(world).setDifficulty(diff);
            }
            if (settings.isEndGenerate()) {
                this.getEndWorld(world).setDifficulty(diff);
            }
            plugin.log("Added world " + friendlyName + " (" + world.getDifficulty() + ")");
        });
    }
    /**
     * Get the settings for this world or sub-worlds (nether, end)
     *
     * @param world world
     * @return world settings
     */
    @NonNull
    public WorldSettings getWorldSettings(@NonNull World world) {
        return Objects.requireNonNull(gameModes.get(world),
                "Attempt to get WorldSettings for non-game world " + world.getName()).getWorldSettings();
    }
    /**
     * Get the overworld based on friendly name.
     *
     * @param friendlyName friendly name of world
     * @return overworld, or null if it does not exist
     * @since 1.1
     */
    @Nullable
    public World getOverWorld(@NonNull String friendlyName) {
        return gameModes.values().stream().distinct()
                .filter(gm -> gm.getWorldSettings().getFriendlyName().equalsIgnoreCase(friendlyName))
                .map(GameModeAddon::getOverWorld).findFirst().orElse(null);
    }
    /**
     * @return the islandDistance
     */
    public int getIslandDistance(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getIslandDistance() : 0;
    }
    /**
     * Value will always be greater than the world's min height and less than the world's max height.
     * @return the islandHeight
     */
    public int getIslandHeight(@NonNull World world) {
        if (gameModes.containsKey(world) && world.getMaxHeight() > 0) {
            return Math.min(world.getMaxHeight() - 1,
                    Math.max(world.getMinHeight(), gameModes.get(world).getWorldSettings().getIslandHeight()));
        }
        return 0;
    }
    /**
     * @return the islandProtectionRange
     */
    public int getIslandProtectionRange(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getIslandProtectionRange() : 0;
    }
    /**
     * @return the islandStartX
     */
    public int getIslandStartX(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getIslandStartX() : 0;
    }
    /**
     * @return the islandStartZ
     */
    public int getIslandStartZ(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getIslandStartZ() : 0;
    }
    /**
     * @return the islandXOffset
     */
    public int getIslandXOffset(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getIslandXOffset() : 0;
    }
    /**
     * @return the islandZOffset
     */
    public int getIslandZOffset(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getIslandZOffset() : 0;
    }
    /**
     * @return the maxIslands
     */
    public int getMaxIslands(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getMaxIslands() : 0;
    }
    /**
     * @return the netherSpawnRadius
     */
    public int getNetherSpawnRadius(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getNetherSpawnRadius() : 0;
    }
    /**
     * @return the seaHeight
     */
    public int getSeaHeight(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getSeaHeight() : 0;
    }
    /**
     * @return the worldName
     */
    public String getWorldName(@NonNull World world) {
        return gameModes.containsKey(world)
                ? gameModes.get(world).getWorldSettings().getWorldName().toLowerCase(Locale.ENGLISH)
                : world.getName();
    }
    /**
     * @return the endGenerate
     */
    public boolean isEndGenerate(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isEndGenerate();
    }
    /**
     * @return the endIslands
     */
    public boolean isEndIslands(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isEndIslands();
    }
    /**
     * @return the netherGenerate
     */
    public boolean isNetherGenerate(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isNetherGenerate();
    }
    /**
     * @return the netherIslands
     */
    public boolean isNetherIslands(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isNetherIslands();
    }
    /**
     * Checks if a world is a known nether world
     *
     * @param world - world
     * @return true if world is a known and valid nether world
     */
    public boolean isNether(@Nullable World world) {
        return world != null && (world.getEnvironment().equals(Environment.NETHER) && gameModes.containsKey(world)
                && gameModes.get(world).getWorldSettings().isNetherGenerate());
    }
    /**
     * Checks if a world is a known island nether world
     *
     * @param world - world
     * @return true if world is a known and valid nether world
     */
    public boolean isIslandNether(@Nullable World world) {
        return world != null && (world.getEnvironment().equals(Environment.NETHER) && gameModes.containsKey(world)
                && gameModes.get(world).getWorldSettings().isNetherGenerate()
                && gameModes.get(world).getWorldSettings().isNetherIslands());
    }
    /**
     * Checks if a world is a known end world
     *
     * @param world - world
     * @return true if world is a known and valid end world
     */
    public boolean isEnd(@Nullable World world) {
        return world != null && (world.getEnvironment().equals(Environment.THE_END) && gameModes.containsKey(world)
                && gameModes.get(world).getWorldSettings().isEndGenerate());
    }
    /**
     * Checks if a world is a known island end world
     *
     * @param world
     *            - world
     * @return true if world is a known and valid nether world
     */
    public boolean isIslandEnd(@Nullable World world) {
        return world != null && (world.getEnvironment().equals(Environment.THE_END) && gameModes.containsKey(world)
                && gameModes.get(world).getWorldSettings().isEndGenerate()
                && gameModes.get(world).getWorldSettings().isEndIslands());
    }
    /**
     * Get the nether world of this overWorld
     *
     * @param world - overworld
     * @return nether world, or null if it does not exist
     */
    @Nullable
    public World getNetherWorld(@Nullable World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getNetherWorld() : null;
    }
    /**
     * Get the end world of this overWorld
     *
     * @param world - overworld
     * @return end world, or null if it does not exist
     */
    @Nullable
    public World getEndWorld(@Nullable World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getEndWorld() : null;
    }
    /**
     * Whether the End Dragon can spawn or not in this world
     *
     * @param world world
     * @return true (default) if it can spawn or not
     */
    public boolean isDragonSpawn(@Nullable World world) {
        return world == null
                || (!gameModes.containsKey(world) || gameModes.get(world).getWorldSettings().isDragonSpawn());
    }
    /**
     * @return a comma separated string of friendly world names
     */
    public String getFriendlyNames() {
        StringBuilder r = new StringBuilder();
        gameModes.values().stream().distinct()
                .forEach(n -> r.append(n.getWorldSettings().getFriendlyName()).append(", "));
        if (r.length() > 0) {
            r.setLength(r.length() - 2);
        }
        return r.toString();
    }
    /**
     * Gets world from friendly name
     *
     * @param friendlyWorldName friendly world name. Used for commands.
     * @return world, or null if not known
     */
    @Nullable
    public World getIslandWorld(String friendlyWorldName) {
        return gameModes.entrySet().stream()
                .filter(e -> e.getValue().getWorldSettings().getFriendlyName().equalsIgnoreCase(friendlyWorldName))
                .findFirst().map(Map.Entry::getKey).orElse(null);
    }
    /**
     * Get max team size for this world
     *
     * @param world - world
     * @return max team size or zero if world is not a game world
     */
    public int getMaxTeamSize(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getMaxTeamSize() : 0;
    }
    /**
     * Get max coop size for this world
     * @param world - world
     * @return max coop size or zero if world is not a game world
     * @since 1.13.0
     */
    public int getMaxCoopSize(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getMaxCoopSize() : 0;
    }
    /**
     * Get max trust size for this world
     * @param world - world
     * @return max trust size or zero if world is not a game world
     * @since 1.13.0
     */
    public int getMaxTrustSize(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getMaxTrustSize() : 0;
    }
    /**
     * Get max homes for world
     *
     * @param world - world
     * @return max homes or 0 if world is not a game world
     */
    public int getMaxHomes(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getMaxHomes() : 0;
    }
    /**
     * Get the friendly name for world or related nether or end
     *
     * @param world - world
     * @return Friendly name or world name if world is not a game world
     */
    public String getFriendlyName(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getFriendlyName()
                : world.getName();
    }
    /**
     * Get the permission prefix for this world. Trailing dot included.
     *
     * @param world - world
     * @return permission prefix for this world or empty string if world is not a game world
     */
    public String getPermissionPrefix(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getPermissionPrefix() + "." : "";
    }
    /**
     * Get the invincible visitor settings for this world
     *
     * @param world - world
     * @return invincible visitor settings or an empty list if world is not a game world
     */
    public List<String> getIvSettings(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getIvSettings()
                : Collections.emptyList();
    }
    /**
     * Returns whether a world flag is set or not Same result as calling
     * {@link Flag#isSetForWorld(World)}
     *
     * @param world
     *            - world
     * @param flag
     *            - world setting flag
     * @return true or false
     */
    public boolean isWorldFlag(@NonNull World world, @NonNull Flag flag) {
        return flag.isSetForWorld(world);
    }
    /**
     * Get the default game mode for this world.
     *
     * @param world - world
     * @return GameMode: SURVIVAL, CREATIVE, ADVENTURE, SPECTATOR. Default is SURVIVAL if world is not a game world
     */
    public GameMode getDefaultGameMode(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getDefaultGameMode()
                : GameMode.SURVIVAL;
    }
    /**
     * Get the set of entity types not to remove when player teleports to island
     *
     * @param world - world
     * @return - set of entity types
     */
    public Set<EntityType> getRemoveMobsWhitelist(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getRemoveMobsWhitelist()
                : Collections.emptySet();
    }
    /**
     * @return the onJoinResetMoney
     */
    public boolean isOnJoinResetMoney(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnJoinResetMoney();
    }
    /**
     * @return the onJoinResetInventory
     */
    public boolean isOnJoinResetInventory(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnJoinResetInventory();
    }
    /**
     * @return the onJoinResetEnderChest
     */
    public boolean isOnJoinResetEnderChest(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnJoinResetEnderChest();
    }
    /**
     * Returns whether a player's health should be reset upon him joining or creating an island in this World.
     * @param world the World
     * @return {@code true} if health should be reset, {@code false} otherwise.
     * @since 1.8.0
     */
    public boolean isOnJoinResetHealth(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnJoinResetHealth();
    }
    /**
     * Returns whether a player's hunger should be reset upon him joining or creating an island in this World.
     * @param world the World
     * @return {@code true} if hunger should be reset, {@code false} otherwise.
     * @since 1.8.0
     */
    public boolean isOnJoinResetHunger(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnJoinResetHunger();
    }
    /**
     * Returns whether a player's XP should be reset upon him joining or creating an island in this World.
     * @param world the World
     * @return {@code true} if XP should be reset, {@code false} otherwise.
     * @since 1.8.0
     */
    public boolean isOnJoinResetXP(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnJoinResetXP();
    }
    /**
     * Returns a list of commands to execute when the player creates or joins an island.
     * @param world the World
     * @return a list of commands
     * @since 1.8.0
     * @see #getOnLeaveCommands(World)
     */
    @NonNull
    public List<String> getOnJoinCommands(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getOnJoinCommands()
                : Collections.emptyList();
    }
    /**
     * @return the onLeaveResetMoney
     */
    public boolean isOnLeaveResetMoney(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnLeaveResetMoney();
    }
    /**
     * @return the onLeaveResetInventory
     */
    public boolean isOnLeaveResetInventory(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnLeaveResetInventory();
    }
    /**
     * @return the onLeaveResetEnderChest
     */
    public boolean isOnLeaveResetEnderChest(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnLeaveResetEnderChest();
    }
    /**
     * Returns whether a player's health should be reset upon him leaving or resetting his island in this World.
     * @param world the World
     * @return {@code true} if health should be reset, {@code false} otherwise.
     * @since 1.8.0
     */
    public boolean isOnLeaveResetHealth(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnLeaveResetHealth();
    }
    /**
     * Returns whether a player's hunger should be reset upon him leaving or resetting his island in this World.
     * @param world the World
     * @return {@code true} if hunger should be reset, {@code false} otherwise.
     * @since 1.8.0
     */
    public boolean isOnLeaveResetHunger(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnLeaveResetHunger();
    }
    /**
     * Returns whether a player's XP should be reset upon him leaving or resetting his island in this World.
     * @param world the World
     * @return {@code true} if XP should be reset, {@code false} otherwise.
     * @since 1.8.0
     */
    public boolean isOnLeaveResetXP(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isOnLeaveResetXP();
    }
    /**
     * Returns a list of commands to execute when the player resets or leaves an island.
     * @param world the World
     * @return a list of commands
     * @since 1.8.0
     * @see #getOnJoinCommands(World)
     */
    @NonNull
    public List<String> getOnLeaveCommands(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getOnLeaveCommands()
                : Collections.emptyList();
    }
    /**
     * Returns a list of commands to execute when the player respawns and {@link Flags#ISLAND_RESPAWN} is true.
     * @param world the World
     * @return a list of commands
     * @since 1.14.0
     * @see #getOnJoinCommands(World)
     */
    @NonNull
    public List<String> getOnRespawnCommands(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getOnRespawnCommands()
                : Collections.emptyList();
    }
    /**
     * Get data folder for the addon that registered this world
     *
     * @return data folder file object or the plugin's data folder if none found
     */
    public File getDataFolder(@NonNull World world) {
        return getAddon(world).map(GameModeAddon::getDataFolder).orElseGet(plugin::getDataFolder);
    }
    /**
     * Get the game mode addon associated with this world set
     *
     * @param world
     *            - world
     * @return GameModeAddon, or empty
     */
    public Optional<GameModeAddon> getAddon(@Nullable World world) {
        return world == null ? Optional.empty() : Optional.ofNullable(gameModes.get(world));
    }
    /**
     * Get default island flag settings for this world.
     *
     * @param world - world
     * @return default rank settings for new islands.
     */
    public Map<Flag, Integer> getDefaultIslandFlags(@NonNull World world) {
        return this.gameModes.containsKey(world)
                ? this.convertToFlags(this.gameModes.get(world).getWorldSettings().getDefaultIslandFlagNames())
                : Collections.emptyMap();
    }
    /**
     * Returns a list of flags that should NOT be visible to the player
     * @param world - world
     * @return list of hidden flags
     */
    public List<String> getHiddenFlags(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getHiddenFlags()
                : Collections.emptyList();
    }
    /**
     * Return island setting defaults for world
     *
     * @param world - world
     * @return default settings for new islands
     */
    public Map<Flag, Integer> getDefaultIslandSettings(@NonNull World world) {
        return this.gameModes.containsKey(world)
                ? this.convertToFlags(this.gameModes.get(world).getWorldSettings().getDefaultIslandSettingNames())
                : Collections.emptyMap();
    }
    public boolean isUseOwnGenerator(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isUseOwnGenerator();
    }
    /**
     * Check for blocks when searching for a new island. This is a safety net check that does a look
     * around the new island location (3x3x3 block check). If any non-air or non-water blocks are found
     * then the island is marked as being used. It is mainly for migration handling from worlds that
     * do not register island properly. It is incompatible with CaveBlock or other gamemodes that will
     * have blocks there.
     * @param world - world
     * @return true if a check for blocks should happen
     * @since 1.16.0
     */
    public boolean isCheckForBlocks(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isCheckForBlocks();
    }
    /**
     * Return banned commands for visitors
     * @return the visitorbannedcommands
     */
    public List<String> getVisitorBannedCommands(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getVisitorBannedCommands()
                : Collections.emptyList();
    }
    /**
     * Return banned commands when falling
     * @return the fallingbannedcommands
     */
    public List<String> getFallingBannedCommands(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getFallingBannedCommands()
                : Collections.emptyList();
    }
    /**
     * Check if water is not safe, e.g., it is acid, in the world
     * @param world - world
     * @return true if water is not safe, e.g.for home locations
     */
    public boolean isWaterNotSafe(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isWaterUnsafe();
    }
    /**
     * Get a list of entity types that should not exit the island limits
     * @param world - world
     * @return list
     */
    public List<String> getGeoLimitSettings(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getGeoLimitSettings()
                : Collections.emptyList();
    }
    /**
     * Check if a mob type should not spawn in this world
     * @param world - world
     * @return list of limited mobs
     * @since 1.12.0
     */
    public List<String> getMobLimitSettings(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getMobLimitSettings()
                : Collections.emptyList();
    }
    /**
     * Get the reset limit for this world
     * @param world - world
     * @return number of resets allowed. -1 = unlimited
     */
    public int getResetLimit(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getResetLimit() : -1;
    }
    /**
     * Gets the time stamp for when all player resets were zeroed
     * @param world - world
     */
    public long getResetEpoch(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getResetEpoch() : 0L;
    }
    /**
     * Sets the time stamp for when all player resets were zeroed
     * @param world - world
     */
    public void setResetEpoch(@NonNull World world) {
        if (gameModes.containsKey(world))
            gameModes.get(world).getWorldSettings().setResetEpoch(System.currentTimeMillis());
    }
    /**
     * Check if the death count should be reset when joining a team in this world
     * @param world - world
     * @return true or false
     */
    public boolean isTeamJoinDeathReset(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isTeamJoinDeathReset();
    }
    /**
     * Check if deaths in the world are reset when the player starts a new island.
     * This includes a totally new island and also a new island from a reset.
     * @param world - world
     * @return true or false
     * @since 1.6.0
     */
    public boolean isDeathsResetOnNewIsland(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isDeathsResetOnNewIsland();
    }
    /**
     * Get the maximum number of deaths allowed in this world
     * @param world - world
     * @return max deaths
     */
    public int getDeathsMax(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getDeathsMax() : 0;
    }
    /**
     * Get the ban limit for this world
     * @param world - world
     * @return ban limit
     */
    public int getBanLimit(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getBanLimit() : 0;
    }
    /**
     * @return whether leavers should lose a reset or not
     */
    public boolean isLeaversLoseReset(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isLeaversLoseReset();
    }
    /**
     * @return whether players keep their inventory if they are kicked. Overrides leave inventory clearing
     */
    public boolean isKickedKeepInventory(@NonNull World world) {
        return !gameModes.containsKey(world) || gameModes.get(world).getWorldSettings().isKickedKeepInventory();
    }
    /**
     *
     * @param world - world
     * @return true if successful
     * @since 1.9.0
     */
    public boolean isCreateIslandOnFirstLoginEnabled(@NonNull World world) {
        return gameModes.containsKey(world)
                && gameModes.get(world).getWorldSettings().isCreateIslandOnFirstLoginEnabled();
    }
    /**
     *
     * @param world - world
     * @return delay value
     * @since 1.9.0
     */
    public int getCreateIslandOnFirstLoginDelay(@NonNull World world) {
        return gameModes.containsKey(world) ? gameModes.get(world).getWorldSettings().getCreateIslandOnFirstLoginDelay()
                : 0;
    }
    /**
     *
     * @param world - world
     * @return true if creation should happen
     * @since 1.9.0
     */
    public boolean isCreateIslandOnFirstLoginAbortOnLogout(@NonNull World world) {
        return gameModes.containsKey(world)
                && gameModes.get(world).getWorldSettings().isCreateIslandOnFirstLoginAbortOnLogout();
    }
    /**
     * Check if nether or end islands should be pasted on teleporting
     * @param world - over world
     * @return true if missing nether or end islands should be pasted
     * @since 1.10.0
     */
    public boolean isPasteMissingIslands(@NonNull World world) {
        return gameModes.containsKey(world) && gameModes.get(world).getWorldSettings().isPasteMissingIslands();
    }
    /**
     * Toggles whether the player should be teleported on his island after it got created.
     * <br/>
     * If set to {@code true}, the player will be teleported right away.
     * <br/>
     * If set to {@code false}, the player will remain where he is and a message will be sent inviting him to teleport to his island.
     * <br/><br/>
     * This does not apply to any other occurrences such as island reset, or island join.
     * <br/><br/>
     * Default value: {@code true} (to retain backward compatibility).
     * @param world world, not null.
     * @return {@code true} if the player should be teleported to his island, {@code false} otherwise.
     * @since 1.10.0
     */
    public boolean isTeleportPlayerToIslandUponIslandCreation(@NonNull World world) {
        return gameModes.containsKey(world)
                && gameModes.get(world).getWorldSettings().isTeleportPlayerToIslandUponIslandCreation();
    }
    /**
     * This method migrates Map of String, Integer to Map of Flag, Integer.
     * @param flagNamesMap Map that contains flag names to their values.
     * @return Flag objects to their values.
     * @since 1.21
     */
    private Map<Flag, Integer> convertToFlags(Map<String, Integer> flagNamesMap) {
        Map<Flag, Integer> flagMap = new HashMap<>();
        flagNamesMap.forEach(
                (key, value) -> this.plugin.getFlagsManager().getFlag(key).ifPresent(flag -> flagMap.put(flag, value)));
        return flagMap;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.util.List;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.managers.BlueprintClipboardManager;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
/**
 * This method allows to save blueprint from the clipboard.
 */
public class AdminBlueprintSaveCommand extends ConfirmableCommand
{
    public AdminBlueprintSaveCommand(AdminBlueprintCommand parent)
    {
        super(parent, "save");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.save");
        this.setParametersHelp("commands.admin.blueprint.save.parameters");
        this.setDescription("commands.admin.blueprint.save.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (args.size() != 1)
        {
            // Blueprint must have a name.
            this.showHelp(this, user);
            return false;
        }
        BlueprintClipboard clipboard = ((AdminBlueprintCommand) this.getParent()).getClipboards().
                computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        if (!clipboard.isFull())
        {
            // Clipboard is not set up.
            user.sendMessage("commands.admin.blueprint.copy-first");
            return false;
        }
        if (clipboard.getBlueprint() != null && clipboard.getBlueprint().getBedrock() == null)
        {
            // Bedrock is required for all blueprints.
            user.sendMessage("commands.admin.blueprint.bedrock-required");
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) this.getParent();
        BlueprintClipboard clipboard = parent.getClipboards().
                computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        String fileName = Util.sanitizeInput(args.get(0));
        // Check if file exists
        File newFile = new File(parent.getBlueprintsFolder(), fileName + BlueprintsManager.BLUEPRINT_SUFFIX);
        if (newFile.exists())
        {
            this.askConfirmation(user,
                    user.getTranslation("commands.admin.blueprint.file-exists"),
                    () -> this.hideAndSave(user, parent, clipboard, fileName, args.get(0)));
            return false;
        }
        return this.hideAndSave(user, parent, clipboard, fileName, args.get(0));
    }
    /**
     * This method saves given blueprint.
     * @param user User that triggers blueprint save.
     * @param parent Parent command that contains clipboard.
     * @param clipboard Active clipboard.
     * @param name Filename for the blueprint
     * @param displayName Display name for the blueprint.
     * @return {@code true} if blueprint is saved, {@code false} otherwise.
     */
    private boolean hideAndSave(User user,
            AdminBlueprintCommand parent,
            BlueprintClipboard clipboard,
            String name,
            String displayName)
    {
        parent.hideClipboard(user);
        boolean result = new BlueprintClipboardManager(this.getPlugin(),
                parent.getBlueprintsFolder(), clipboard).
                save(user, name, displayName);
        if (result && clipboard.isFull())
        {
            this.getPlugin().getBlueprintsManager().addBlueprint(this.getAddon(), clipboard.getBlueprint());
        }
        return result;
    }
}
package world.bentobox.bentobox.panels;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.stream.Collectors;
import org.bukkit.Material;
import org.bukkit.Sound;
import org.bukkit.World;
import org.bukkit.World.Environment;
import org.bukkit.conversations.Conversable;
import org.bukkit.conversations.ConversationFactory;
import org.bukkit.event.inventory.ClickType;
import org.eclipse.jdt.annotation.NonNull;
import world.bentobox.bentobox.BentoBox;
import world.bentobox.bentobox.api.addons.GameModeAddon;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.panels.PanelItem;
import world.bentobox.bentobox.api.panels.builders.PanelBuilder;
import world.bentobox.bentobox.api.panels.builders.PanelItemBuilder;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.Blueprint;
import world.bentobox.bentobox.blueprints.conversation.DescriptionPrompt;
import world.bentobox.bentobox.blueprints.conversation.NameConversationPrefix;
import world.bentobox.bentobox.blueprints.conversation.NamePrompt;
import world.bentobox.bentobox.blueprints.dataobjects.BlueprintBundle;
import world.bentobox.bentobox.managers.BlueprintsManager;
import world.bentobox.bentobox.util.Util;
/**
 * @author tastybento
 * @since 1.5.0
 */
public class BlueprintManagementPanel {
    private final BentoBox plugin;
    private final Blueprint normalBlueprint;
    private final Blueprint netherBlueprint;
    private final Blueprint endBlueprint;
    private final Map<Integer, World.Environment> slotToEnvironment;
    private final Map<World.Environment, Blueprint> environmentToBlueprint;
    private static final int MAX_WORLD_SLOT = 9;
    private static final int MIN_WORLD_SLOT = 0;
    public static final int MAX_BP_SLOT = 35;
    private static final String INSTRUCTION = "instruction";
    private Entry<Integer, Blueprint> selected;
    private final Map<Integer, Blueprint> blueprints = new HashMap<>();
    private final User user;
    private final GameModeAddon addon;
    /**
     * Class to display the Blueprint Management Panel
     * @param plugin - BentoBox
     * @param user - user to see the panel
     * @param addon - game mode addon requesting the panel
     */
    public BlueprintManagementPanel(@NonNull BentoBox plugin, @NonNull User user, @NonNull GameModeAddon addon) {
        this.plugin = plugin;
        this.user = user;
        this.addon = addon;
        normalBlueprint = new Blueprint().setIcon(Material.GREEN_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.overworld"))
                .setDescription(t(INSTRUCTION));
        netherBlueprint = new Blueprint().setIcon(Material.RED_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.nether"))
                .setDescription(t(INSTRUCTION));
        endBlueprint = new Blueprint().setIcon(Material.YELLOW_STAINED_GLASS_PANE)
                .setName(user.getTranslation("general.worlds.the-end"))
                .setDescription(t(INSTRUCTION));
        slotToEnvironment = Map.of(3, World.Environment.NORMAL, 5, World.Environment.NETHER, 7, World.Environment.THE_END);
        environmentToBlueprint = Map.of(World.Environment.NORMAL, normalBlueprint, World.Environment.NETHER, netherBlueprint, World.Environment.THE_END, endBlueprint);
    }
    /**
     * Translate "commands.admin.blueprint.management." + t reference
     * @param t - end of reference
     * @return translation
     */
    private String t(String t) {
        return user.getTranslation("commands.admin.blueprint.management." + t);
    }
    /**
     * Translate "commands.admin.blueprint.management." + t + vars reference
     * @param t end of reference
     * @param vars any other parameters
     * @return transmation
     */
    private String t(String t, String... vars) {
        return user.getTranslation("commands.admin.blueprint.management." + t, vars);
    }
    /**
     * Opens the management panel
     */
    public void openPanel() {
        // Show panel of blueprint bundles
        // Clicking on a bundle opens up the bundle edit panel
        // Create the panel
        PanelBuilder pb = new PanelBuilder().name(t("title")).user(user).size(45);
        // Panel has New Blueprint Bundle button - clicking in creates a new bundle
        pb.item(36, getNewBundle(addon));
        // Get the bundles
        Comparator<BlueprintBundle> sortByDisplayName = (p, o) -> p.getDisplayName().compareToIgnoreCase(o.getDisplayName());
        plugin.getBlueprintsManager().getBlueprintBundles(addon).values().stream().limit(36)
        .sorted(sortByDisplayName)
        .forEach(bb -> {
            // Make item
            PanelItem item = new PanelItemBuilder()
                    .name(bb.getDisplayName())
                    .description(t("edit"), t("rename"))
                    .icon(bb.getIcon())
                    .clickHandler((panel, u, clickType, slot) -> {
                        u.closeInventory();
                        if (clickType.equals(ClickType.RIGHT)) {
                            // Rename
                            askForName(u.getPlayer(), addon, bb);
                        } else {
                            openBB(bb);
                        }
                        return true;
                    })
                    .build();
            // Determine slot
            if (bb.getSlot() < 0 || bb.getSlot() > MAX_BP_SLOT) {
                bb.setSlot(0);
            }
            if (pb.slotOccupied(bb.getSlot())) {
                int slot = getFirstAvailableSlot(pb);
                if (slot == -1) {
                    // TODO add paging
                    plugin.logError("Too many blueprint bundles to show!");
                    pb.item(item);
                } else {
                    pb.item(slot, item);
                }
            } else {
                pb.item(bb.getSlot(), item);
            }
        });
        pb.build();
    }
    /**
     * @param pb - panel builder
     * @return first available slot, or -1 if none
     */
    private static int getFirstAvailableSlot(PanelBuilder pb) {
        for (int i = 0; i < BlueprintManagementPanel.MAX_BP_SLOT; i++) {
            if (!pb.slotOccupied(i)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Open the Blueprint Bundle panel
     * @param bb - blueprint bundle
     */
    public void openBB(BlueprintBundle bb) {
        int index = 18;
        for (Blueprint bp : plugin.getBlueprintsManager().getBlueprints(addon).values()) {
            blueprints.put(index++, bp);
        }
        // Create the panel
        PanelBuilder pb = new PanelBuilder().name(bb.getDisplayName()).user(user).size(45).listener(new IconChanger(plugin, addon, this, bb));
        // Display bundle icon
        pb.item(0, getBundleIcon(bb));
        slotToEnvironment.forEach((k, v) -> {
            String bpName = bb.getBlueprint(v);
            pb.item(k-1, getWorldInstrTile(v));
            pb.item(k, getBlueprintItem(addon, k, bb, plugin.getBlueprintsManager().getBlueprints(addon).getOrDefault(bpName, environmentToBlueprint.get(v))));
        });
        for (int i = 9; i < 18; i++) {
            pb.item(i, new PanelItemBuilder().icon(Material.BLACK_STAINED_GLASS_PANE).name(" ").build());
        }
        blueprints.entrySet().stream().limit(18).forEach(b -> pb.item(getBlueprintItem(addon, b.getKey(), bb, b.getValue())));
        // Buttons for non-default bundle
        if (bb.getUniqueId().equals(BlueprintsManager.DEFAULT_BUNDLE_NAME)) {
            // Panel has a No Trash icon. If right clicked it is discarded
            pb.item(36, getNoTrashIcon());
            // Toggle permission - default is always allowed
            pb.item(39, getNoPermissionIcon());
        } else {
            // Panel has a Trash icon. If right clicked it is discarded
            pb.item(36, getTrashIcon(addon, bb));
            // Toggle permission - default is always allowed
            pb.item(39, getPermissionIcon(addon, bb));
        }
        if (plugin.getSettings().getIslandNumber() > 1) {
            // Number of times allowed
            pb.item(42, getTimesIcon(bb));
        }
        // Preferred slot
        pb.item(40, getSlotIcon(addon, bb));
        // Panel has a Back icon.
        pb.item(44, new PanelItemBuilder().icon(Material.OAK_DOOR).name(t("back")).clickHandler((panel, u, clickType, slot) -> {
            openPanel();
            return true;
        }).build());
        pb.build();
    }
    private PanelItem getTimesIcon(BlueprintBundle bb) {
        return new PanelItemBuilder().icon(Material.CLOCK).name(t("times"))
                .description(bb.getTimes() == 0 ? t("unlimited-times")
                        : t("maximum-times", TextVariables.NUMBER, String.valueOf(bb.getTimes())))
                .clickHandler((panel, u, clickType, slot) -> {
                    // Left click up, right click down
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    if (clickType == ClickType.LEFT) {
                        bb.setTimes(bb.getTimes() + 1);
                    } else if (clickType == ClickType.RIGHT && bb.getTimes() > 0) {
                        bb.setTimes(bb.getTimes() - 1);
                    }
                    // Save
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(42, getTimesIcon(bb).getItem());
                    return true;
                }).build();
    }
    /**
     * Gets the preferred slot icon
     * @param addon - addon
     * @param bb - blueprint bundle
     * @return slot panel item
     */
    private PanelItem getSlotIcon(GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("slot", TextVariables.NUMBER, String.valueOf(bb.getSlot())))
                .description(t("slot-instructions"))
                .icon(Material.IRON_TRAPDOOR)
                .clickHandler((panel, u, clickType, slot) -> {
                    // Increment or decrement slot
                    if (clickType.isLeftClick()) {
                        bb.setSlot(bb.getSlot() + 1);
                        if (bb.getSlot() > MAX_BP_SLOT) {
                            bb.setSlot(0);
                        }
                    } else if (clickType.isRightClick()) {
                        bb.setSlot(bb.getSlot() - 1);
                        if (bb.getSlot() < 0) {
                            bb.setSlot(MAX_BP_SLOT);
                        }
                    }
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    // Save
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(40, getSlotIcon(addon, bb).getItem());
                    return true;
                })
                .build();
    }
    /**
     * Gets the panel item for Blueprint Bundle
     * @param bb - blueprint bundle
     * @return - panel item
     */
    protected PanelItem getBundleIcon(BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("edit-description"))
                .description(bb.getDescription().stream().map(Util::translateColorCodes).toList())
                .icon(bb.getIcon())
                .clickHandler((panel, u, clickType, slot) -> {
                    u.closeInventory();
                    // Description conversation
                    askForDescription(u.getPlayer(), addon, bb);
                    return true;
                })
                .build();
    }
    private PanelItem getWorldInstrTile(Environment env) {
        Material icon;
        String worldName;
        switch (env) {
        case NORMAL -> {
            icon = Material.GRASS_BLOCK;
            worldName = normalBlueprint.getName();
        }
        case NETHER -> {
            icon = Material.NETHERRACK;
            worldName = netherBlueprint.getName();
        }
        case THE_END -> {
            icon = Material.END_STONE;
            worldName = endBlueprint.getName();
        }
        default -> {
            icon = Material.STONE;
            worldName = Util.prettifyText(env.name());
        }
        }
        return new PanelItemBuilder()
                .name(t("world-name-syntax", TextVariables.NAME, worldName))
                .description(t("world-instructions"))
                .glow(true)
                .icon(icon)
                .build();
    }
    private PanelItem getTrashIcon(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder()
                .name(t("trash"))
                .description(t("trash-instructions"))
                .icon(Material.TNT)
                .clickHandler((panel, u, clickType, slot) -> {
                    if (clickType.equals(ClickType.RIGHT)) {
                        u.getPlayer().playSound(u.getLocation(), Sound.ENTITY_GENERIC_EXPLODE, 1F, 1F);
                        plugin.getBlueprintsManager().deleteBlueprintBundle(addon, bb);
                        openPanel();
                    }
                    return true;
                })
                .build();
    }
    private PanelItem getNoTrashIcon() {
        return new PanelItemBuilder()
                .name(t("no-trash"))
                .description(t("no-trash-instructions"))
                .icon(Material.TNT)
                .build();
    }
    private PanelItem getPermissionIcon(@NonNull GameModeAddon addon, BlueprintBundle bb) {
        return new PanelItemBuilder().icon(Material.PAINTING).name(t("permission"))
                .description(bb.isRequirePermission() ? t("perm-required") : t("perm-not-required"))
                .description(bb.isRequirePermission() ? t("perm-format") + addon.getPermissionPrefix() + "island.create."  + bb.getUniqueId() : "")
                .clickHandler((panel, u, clickType, slot) -> {
                    // Toggle permission
                    u.getPlayer().playSound(u.getLocation(), Sound.UI_BUTTON_CLICK, 1F, 1F);
                    bb.setRequirePermission(!bb.isRequirePermission());
                    // Save
                    plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                    panel.getInventory().setItem(39, getPermissionIcon(addon, bb).getItem());
                    return true;
                }).build();
    }
    private PanelItem getNoPermissionIcon() {
        return new PanelItemBuilder().icon(Material.PAINTING).name(t("no-permission"))
                .description(t("no-perm-required"))
                .build();
    }
    /**
     * Gets a panel item that fully represents a blueprint in a bundle for an addon
     * @param addon - the GameMode Addon
     * @param pos - the position where this icon will be placed - the description changes
     * @param bb - the blueprint bundle this blueprint is in, if any
     * @param blueprint - blueprint itself
     * @return a panel item
     */
    protected PanelItem getBlueprintItem(GameModeAddon addon, int pos, BlueprintBundle bb, Blueprint blueprint) {
        // Create description
        List<String> desc = blueprint.getDescription() == null ? new ArrayList<>() : blueprint.getDescription();
        desc = desc.stream().map(Util::translateColorCodes).collect(Collectors.toList()); // Must be mutable
        if ((!blueprint.equals(endBlueprint) && !blueprint.equals(normalBlueprint) && !blueprint.equals(netherBlueprint))) {
            if ((pos > MIN_WORLD_SLOT && pos < MAX_WORLD_SLOT)) {
                desc.add(t("remove"));
            } else {
                desc.add(t("blueprint-instruction"));
            }
        }
        return new PanelItemBuilder()
                .name(blueprint.getDisplayName() == null ? blueprint.getName() : blueprint.getDisplayName())
                .description(desc)
                .icon(blueprint.getIcon())
                .glow(selected != null && pos == selected.getKey())
                .clickHandler((panel, u, clickType, slot) -> {
                    // Handle the world squares
                    if (slot > MIN_WORLD_SLOT && slot < MAX_WORLD_SLOT) {
                        if (clickType.equals(ClickType.RIGHT)) {
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_GLASS_BREAK, 1F, 1F);
                            // Remove the item and replace with the blank
                            bb.clearBlueprint(slotToEnvironment.get(slot));
                            // Save
                            plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                            openBB(bb);
                        } else if (selected == null) {
                            u.sendMessage("commands.admin.blueprint.management.select-first");
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_ANVIL_HIT, 1F, 1F);
                        } else {
                            // Add
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_METAL_HIT, 1F, 1F);
                            Blueprint bp = selected.getValue();
                            // make slot the chosen one
                            bb.setBlueprint(slotToEnvironment.get(slot), bp);
                            // Save
                            plugin.getBlueprintsManager().saveBlueprintBundle(addon, bb);
                            openBB(bb);
                        }
                    } else {
                        // Select blueprint
                        if (blueprints.containsKey(slot)) {
                            // Renaming blueprint
                            if (clickType.equals(ClickType.RIGHT)) {
                                u.closeInventory();
                                this.askForBlueprintName(u.getPlayer(), addon, blueprint, bb);
                                return true;
                            }
                            if (selected != null && slot == selected.getKey()){
                                // Clicked on same item - deselect
                                selected = null;
                            } else {
                                // Set selected
                                selected = new AbstractMap.SimpleEntry<>(slot, blueprints.get(slot));
                            }
                            u.getPlayer().playSound(u.getLocation(), Sound.BLOCK_METAL_HIT, 1F, 2F);
                            openBB(bb);
                        }
                    }
                    return true;
                })
                .build();
    }
    private PanelItem getNewBundle(@NonNull GameModeAddon addon) {
        return new PanelItemBuilder()
                .name(t("new-bundle"))
                .description(t("new-bundle-instructions"))
                .icon(Material.GREEN_BANNER)
                .clickHandler((panel, u, clickType, slot) -> {
                    u.closeInventory();
                    askForName(u.getPlayer(), addon, null);
                    return true;
                })
                .build();
    }
    public void askForName(Conversable whom, GameModeAddon addon, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new NamePrompt(addon, bb))
        .withEscapeSequence(t("name.quit"))
        .buildConversation(whom).begin();
    }
    public void askForBlueprintName(Conversable whom, GameModeAddon addon, Blueprint bp, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new NamePrompt(addon, bp, bb))
        .withEscapeSequence(t("name.quit"))
        .buildConversation(whom).begin();
    }
    public void askForDescription(Conversable whom, GameModeAddon addon, BlueprintBundle bb) {
        new ConversationFactory(BentoBox.getInstance())
        .withModality(true)
        .withLocalEcho(false)
        .withPrefix(new NameConversationPrefix())
        .withTimeout(90)
        .withFirstPrompt(new DescriptionPrompt(addon, bb))
        .buildConversation(whom).begin();
    }
    /**
     * @return the selected
     */
    public Entry<Integer, Blueprint> getSelected() {
        return selected;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.LinkedList;
import java.util.List;
import java.util.Optional;
import world.bentobox.bentobox.api.commands.ConfirmableCommand;
import world.bentobox.bentobox.api.localization.TextVariables;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.util.Util;
/**
 * Command that deletes a Blueprint.
 * @author Poslovitch
 * @since 1.9.0
 */
public class AdminBlueprintDeleteCommand extends ConfirmableCommand
{
    public AdminBlueprintDeleteCommand(AdminBlueprintCommand parent)
    {
        super(parent, "delete", "remove");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.delete");
        this.setParametersHelp("commands.admin.blueprint.delete.parameters");
        this.setDescription("commands.admin.blueprint.delete.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        if (args.size() != 1)
        {
            this.showHelp(this, user);
            return false;
        }
        String blueprintName = Util.sanitizeInput(args.get(0));
        // Check if blueprint exist
        if (this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).containsKey(blueprintName))
        {
            this.askConfirmation(user, user.getTranslation("commands.admin.blueprint.delete.confirmation"),
                    () -> {
                        this.getPlugin().getBlueprintsManager().deleteBlueprint(this.getAddon(), blueprintName);
                        user.sendMessage("commands.admin.blueprint.delete.success", TextVariables.NAME, blueprintName);
                    });
            return true;
        }
        else
        {
            user.sendMessage("commands.admin.blueprint.delete.no-blueprint", TextVariables.NAME, blueprintName);
            return false;
        }
    }
    @Override
    public Optional<List<String>> tabComplete(User user, String alias, List<String> args)
    {
        return Optional.of(new LinkedList<>(this.getPlugin().getBlueprintsManager().getBlueprints(this.getAddon()).keySet()));
    }
}
package world.bentobox.bentobox.api.commands.admin.range;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.bukkit.Bukkit;
import org.bukkit.Color;
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.Particle;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.database.objects.Island;
import world.bentobox.bentobox.util.Util;
/**
 * @author Poslovitch
 */
public class AdminRangeDisplayCommand extends CompositeCommand {
    // Command aliases
    private static final String DISPLAY = "display";
    private static final String SHOW = "show";
    private static final String HIDE = "hide";
    public static final Particle PARTICLE = Util.findFirstMatchingEnum(Particle.class, "REDSTONE", "DUST");
    private static final Particle PARTICLE2 = Util.findFirstMatchingEnum(Particle.class, "VILLAGER_HAPPY",
            "HAPPY_VILLAGER");
    // Map of users to which ranges must be displayed
    private final Map<User, Integer> displayRanges = new HashMap<>();
    public AdminRangeDisplayCommand(CompositeCommand parent) {
        super(parent, DISPLAY, SHOW, HIDE);
    }
    @Override
    public void setup() {
        setPermission("admin.range.display");
        setDescription("commands.admin.range.display.description");
        setOnlyPlayer(true);
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        // According to the label used to execute the command, there is a different behaviour
        // - display : toggle on/off
        // - show : only set on - and send "error" if already on
        // - hide : only set off - same if already off
        if (!displayRanges.containsKey(user)) {
            switch (label) {
            case DISPLAY, SHOW -> showZones(user);
            case HIDE -> user.sendMessage("commands.admin.range.display.already-off");
            default -> showHelp(this, user);
            }
        } else {
            switch (label) {
            case DISPLAY, HIDE -> hideZones(user);
            case SHOW -> user.sendMessage("commands.admin.range.display.already-on");
            default -> showHelp(this, user);
            }
        }
        return true;
    }
    private void showZones(User user) {
        user.sendMessage("commands.admin.range.display.showing");
        user.sendMessage("commands.admin.range.display.hint");
        displayRanges.put(user, Bukkit.getScheduler().scheduleSyncRepeatingTask(getPlugin(), () -> {
            if (!user.getPlayer().isOnline()) {
                hideZones(user);
            }
            getIslands().getIslandAt(user.getLocation()).ifPresent(island -> {
                // Draw the island protected area
                drawZone(user, Particle.BLOCK_MARKER, Material.BARRIER.createBlockData(), island, island.getProtectionRange());
                // Draw the default protected area if island protected zone is different
                if (island.getProtectionRange() != getPlugin().getIWM().getIslandProtectionRange(getWorld())) {
                    drawZone(user, PARTICLE2, null, island, getPlugin().getIWM().getIslandProtectionRange(getWorld()));
                }
                // Draw the island area
                drawZone(user, PARTICLE, new Particle.DustOptions(Color.GRAY, 1.0F), island, island.getRange());
            });
        }, 20, 30));
    }
    private void hideZones(User user) {
        user.sendMessage("commands.admin.range.display.hiding");
        Bukkit.getScheduler().cancelTask(displayRanges.get(user));
        displayRanges.remove(user);
    }
    private void drawZone(User user, Particle particle, Object dustOptions, Island island, int range) {
        Location center = island.getProtectionCenter();
        // Get player Y coordinate
        int playerY = user.getPlayer().getLocation().getBlockY() + 1;
        // Draw 3 "stages" (one line below, at and above player's y coordinate)
        for (int stage = -1 ; stage <= 1 ; stage++) {
            for (int i = -range ; i <= range ; i++) {
                user.spawnParticle(particle, dustOptions, (double)center.getBlockX() + i, (double)playerY + stage, (double)center.getBlockZ() + range);
                user.spawnParticle(particle, dustOptions, (double)center.getBlockX() + i, (double)playerY + stage, (double)center.getBlockZ() - range);
                user.spawnParticle(particle, dustOptions, (double)center.getBlockX() + range, (double)playerY + stage, (double)center.getBlockZ() + i);
                user.spawnParticle(particle, dustOptions, (double)center.getBlockX() - range, (double)playerY + stage, (double)center.getBlockZ() + i);
            }
        }
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.List;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.util.Util;
public class AdminBlueprintPos1Command extends CompositeCommand {
    public AdminBlueprintPos1Command(AdminBlueprintCommand parent) {
        super(parent, "pos1");
    }
    @Override
    public void setup() {
        setPermission("admin.blueprint.pos1");
        setParametersHelp("commands.admin.blueprint.pos1.parameters");
        setDescription("commands.admin.blueprint.pos1.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        BlueprintClipboard clipboard = parent.getClipboards().computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        if (user.getLocation().equals(clipboard.getPos2())) {
            user.sendMessage("commands.admin.blueprint.set-different-pos");
            return false;
        }
        clipboard.setPos1(user.getLocation());
        user.sendMessage("commands.admin.blueprint.set-pos1", "[vector]", Util.xyz(user.getLocation().toVector()));
        parent.getClipboards().put(user.getUniqueId(), clipboard);
        parent.showClipboard(user);
        return true;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.io.File;
import java.io.FilenameFilter;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.managers.BlueprintsManager;
public class AdminBlueprintListCommand extends CompositeCommand
{
    public AdminBlueprintListCommand(AdminBlueprintCommand parent)
    {
        super(parent, "list");
    }
    @Override
    public void setup()
    {
        setPermission("admin.blueprint.list");
        this.setDescription("commands.admin.blueprint.list.description");
    }
    @Override
    public boolean canExecute(User user, String label, List<String> args)
    {
        if (!args.isEmpty())
        {
            this.showHelp(this, user);
            return false;
        }
        return true;
    }
    @Override
    public boolean execute(User user, String label, List<String> args)
    {
        File blueprints = new File(this.getAddon().getDataFolder(), BlueprintsManager.FOLDER_NAME);
        if (!blueprints.exists())
        {
            user.sendMessage("commands.admin.blueprint.list.no-blueprints");
            return false;
        }
        FilenameFilter blueprintFilter = (File dir, String name) -> name.endsWith(BlueprintsManager.BLUEPRINT_SUFFIX);
        List<String> blueprintList = Arrays.stream(Objects.requireNonNull(blueprints.list(blueprintFilter))).
                map(name -> name.substring(0, name.length() - BlueprintsManager.BLUEPRINT_SUFFIX.length())).
                toList();
        if (blueprintList.isEmpty())
        {
            user.sendMessage("commands.admin.blueprint.list.no-blueprints");
            return false;
        }
        user.sendMessage("commands.admin.blueprint.list.available-blueprints");
        blueprintList.forEach(user::sendRawMessage);
        return true;
    }
}
package world.bentobox.bentobox.api.commands.admin.blueprints;
import java.util.List;
import world.bentobox.bentobox.api.commands.CompositeCommand;
import world.bentobox.bentobox.api.user.User;
import world.bentobox.bentobox.blueprints.BlueprintClipboard;
import world.bentobox.bentobox.util.Util;
public class AdminBlueprintPos2Command extends CompositeCommand {
    public AdminBlueprintPos2Command(AdminBlueprintCommand parent) {
        super(parent, "pos2");
    }
    @Override
    public void setup() {
        setPermission("admin.blueprint.pos2");
        setParametersHelp("commands.admin.blueprint.pos2.parameters");
        setDescription("commands.admin.blueprint.pos2.description");
    }
    @Override
    public boolean execute(User user, String label, List<String> args) {
        AdminBlueprintCommand parent = (AdminBlueprintCommand) getParent();
        BlueprintClipboard clipboard = parent.getClipboards().computeIfAbsent(user.getUniqueId(), v -> new BlueprintClipboard());
        if (user.getLocation().equals(clipboard.getPos1())) {
            user.sendMessage("commands.admin.blueprint.set-different-pos");
            return false;
        }
        clipboard.setPos2(user.getLocation());
        user.sendMessage("commands.admin.blueprint.set-pos2", "[vector]", Util.xyz(user.getLocation().toVector()));
        parent.getClipboards().put(user.getUniqueId(), clipboard);
        parent.showClipboard(user);
        return true;
    }
}