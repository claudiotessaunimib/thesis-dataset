/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.file;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Buttons;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.ui.*;
import com.badlogic.gdx.scenes.scene2d.utils.*;
import com.badlogic.gdx.utils.*;
import com.kotcrab.vis.ui.FocusManager;
import com.kotcrab.vis.ui.Focusable;
import com.kotcrab.vis.ui.Sizes;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.layout.GridGroup;
import com.kotcrab.vis.ui.util.OsUtils;
import com.kotcrab.vis.ui.util.dialog.Dialogs;
import com.kotcrab.vis.ui.util.dialog.Dialogs.OptionDialogType;
import com.kotcrab.vis.ui.util.dialog.InputDialogAdapter;
import com.kotcrab.vis.ui.util.dialog.OptionDialogAdapter;
import com.kotcrab.vis.ui.util.value.ConstantIfVisibleValue;
import com.kotcrab.vis.ui.util.value.PrefHeightIfVisibleValue;
import com.kotcrab.vis.ui.util.value.PrefWidthIfVisibleValue;
import com.kotcrab.vis.ui.widget.*;
import com.kotcrab.vis.ui.widget.Tooltip;
import com.kotcrab.vis.ui.widget.ButtonBar.ButtonType;
import com.kotcrab.vis.ui.widget.file.internal.*;
import com.kotcrab.vis.ui.widget.file.internal.DriveCheckerService.DriveCheckerListener;
import com.kotcrab.vis.ui.widget.file.internal.DriveCheckerService.RootMode;
import com.kotcrab.vis.ui.widget.file.internal.FileChooserWinService.RootNameListener;
import com.kotcrab.vis.ui.widget.file.internal.FileHistoryManager.FileHistoryCallback;
import com.kotcrab.vis.ui.widget.file.internal.FilePopupMenu.FilePopupMenuCallback;
import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.lang.StringBuilder;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import static com.kotcrab.vis.ui.widget.file.internal.FileChooserText.*;
/**
 * Widget allowing user to choose files. FileChooser is heavy widget and should be reused whenever possible, typically
 * one instance is enough for application. Chooser is platform dependent and can be only used on desktop.
 * <p>
 * FileChooser will be centered on screen after adding to Stage use {@link #setCenterOnAdd(boolean)} to change this.
 * @author Kotcrab
 * @since 0.1.0
 */
public class FileChooser extends VisWindow implements FileHistoryCallback {
	private static final long FILE_WATCHER_CHECK_DELAY_MILLIS = 2000;
	private static final ShortcutsComparator SHORTCUTS_COMPARATOR = new ShortcutsComparator();
	private static final Vector2 tmpVector = new Vector2();
	private static boolean saveLastDirectory = false;
	public static boolean focusFileScrollPaneOnShow = true;
	public static boolean focusSelectedFileTextFieldOnShow = true;
	private Mode mode;
	private ViewMode viewMode = ViewMode.DETAILS;
	private SelectionMode selectionMode = SelectionMode.FILES;
	private AtomicReference<FileSorting> sorting = new AtomicReference<FileSorting>(FileSorting.NAME);
	private AtomicBoolean sortingOrderAscending = new AtomicBoolean(true);
	private FileChooserListener listener = new FileChooserAdapter();
	private FileFilter fileFilter = new DefaultFileFilter(this);
	private FileDeleter fileDeleter = new DefaultFileDeleter();
	private FileTypeFilter fileTypeFilter = null;
	private FileTypeFilter.Rule activeFileTypeRule = null;
	private FileIconProvider iconProvider;
	private DriveCheckerService driveCheckerService = DriveCheckerService.getInstance();
	private Array<DriveCheckerListener> driveCheckerListeners = new Array<DriveCheckerListener>();
	private FileChooserWinService chooserWinService = FileChooserWinService.getInstance();
	private ExecutorService listDirExecutor = Executors.newSingleThreadExecutor(new ServiceThreadFactory("FileChooserListDirThread"));
	private Future<?> listDirFuture;
	private ShowBusyBarTask showBusyBarTask = new ShowBusyBarTask();
	private SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm");
	private boolean showSelectionCheckboxes = false;
	public static final int DEFAULT_KEY = -1;
	private boolean multiSelectionEnabled = false;
	private int groupMultiSelectKey = DEFAULT_KEY; //shift by default
	private int multiSelectKey = DEFAULT_KEY; //ctrl (or command on mac) by default
	private PreferencesIO preferencesIO;
	private Array<FileHandle> favorites;
	private Array<FileHandle> recentDirectories;
	private FileHandle currentDirectory;
	private Array<FileHandle> currentFiles = new Array<FileHandle>();
	private IdentityMap<FileHandle, FileHandleMetadata> currentFilesMetadata = new IdentityMap<FileHandle, FileHandleMetadata>();
	private FileListAdapter fileListAdapter;
	private Array<FileItem> selectedItems = new Array<FileItem>();
	private ShortcutItem selectedShortcut;
	private String defaultFileName;
	private boolean watchingFilesEnabled = true;
	private Thread fileWatcherThread;
	private boolean shortcutsListRebuildScheduled;
	private boolean filesListRebuildScheduled;
	private FileHistoryManager historyManager;
	// UI
	private FileChooserStyle style;
	private Sizes sizes;
	private VisSplitPane mainSplitPane;
	private VisTable shortcutsTable;
	private VerticalGroup shortcutsMainPanel;
	private VerticalGroup shortcutsRootsPanel;
	private VerticalGroup shortcutsFavoritesPanel;
	private ListView<FileHandle> fileListView;
	private float maxDateLabelWidth;
	private BusyBar fileListBusyBar;
	private VisImageButton favoriteFolderButton;
	private VisImageButton viewModeButton;
	private Tooltip favoriteFolderButtonTooltip;
	private VisTextField currentPath;
	private VisTextField selectedFileTextField;
	private VisSelectBox<FileTypeFilter.Rule> fileTypeSelectBox;
	private VisTextButton confirmButton;
	private FilePopupMenu fileMenu;
	private FileSuggestionPopup fileNameSuggestionPopup;
	private DirsSuggestionPopup dirsSuggestionPopup;
	private VisLabel fileTypeLabel;
	private PopupMenu viewModePopupMenu;
	/** @param mode whether this chooser will be used to open or save files */
	public FileChooser (Mode mode) {
		this((FileHandle) null, mode);
	}
	/**
	 * @param directory starting chooser directory
	 * @param mode whether this chooser will be used to open or save files
	 */
	public FileChooser (FileHandle directory, Mode mode) {
		super("");
		this.mode = mode;
		getTitleLabel().setText(TITLE_CHOOSE_FILES.get());
		style = VisUI.getSkin().get(FileChooserStyle.class);
		sizes = VisUI.getSizes();
		init(directory);
	}
	/**
	 * @param title chooser window title
	 * @param mode whether this chooser will be used to open or save files
	 */
	public FileChooser (String title, Mode mode) {
		this("default", title, mode);
	}
	/**
	 * @param styleName skin style name
	 * @param title chooser window title
	 * @param mode whether this chooser will be used to open or save files
	 */
	public FileChooser (String styleName, String title, Mode mode) {
		super(title);
		this.mode = mode;
		style = VisUI.getSkin().get(styleName, FileChooserStyle.class);
		sizes = VisUI.getSizes();
		init(null);
	}
	/**
	 * @param prefsName file name that will be used to store chooser preferences such as favorites or recent directories.
	 * Should be your application package name with appended `.filechooser` e.g. com.seriouscompay.seriousprogram.filechooser.
	 * This name should be unique and should not be reused with other preferences of your application to avoid key collisions.
	 */
	public static void setDefaultPrefsName (String prefsName) {
		PreferencesIO.setDefaultPrefsName(prefsName);
	}
	/** @deprecated replaced by {@link #setDefaultPrefsName(String)} */
	@Deprecated
	public static void setFavoritesPrefsName (String name) {
		PreferencesIO.setDefaultPrefsName(name);
	}
	private void init (FileHandle directory) {
		setModal(true);
		setResizable(true);
		setMovable(true);
		addCloseButton();
		closeOnEscape();
		iconProvider = new DefaultFileIconProvider(this);
		preferencesIO = new PreferencesIO();
		reloadPreferences(false);
		createToolbar();
		viewModePopupMenu = new PopupMenu(style.popupMenuStyle);
		createViewModePopupMenu();
		createCenterContentPanel();
		createFileTextBox();
		createBottomButtons();
		createShortcutsMainPanel();
		shortcutsRootsPanel = new VerticalGroup();
		shortcutsFavoritesPanel = new VerticalGroup();
		rebuildShortcutsFavoritesPanel();
		fileMenu = new FilePopupMenu(this, new FilePopupMenuCallback() {
			@Override
			public void showNewDirDialog () {
				showNewDirectoryDialog();
			}
			@Override
			public void showFileDelDialog (FileHandle file) {
				showFileDeleteDialog(file);
			}
		});
		fileNameSuggestionPopup = new FileSuggestionPopup(this);
		fileNameSuggestionPopup.setListener(new PopupMenu.PopupMenuListener() {
			@Override
			public void activeItemChanged (MenuItem newItem, boolean changedByKeyboard) {
				if (changedByKeyboard == false || newItem == null) return;
				highlightFiles(currentDirectory.child(newItem.getText().toString()));
				updateSelectedFileFieldText(true);
			}
		});
		rebuildShortcutsList();
		if (directory == null) {
			FileHandle startingDir = null;
			if (saveLastDirectory) startingDir = preferencesIO.loadLastDirectory();
			if (startingDir == null || startingDir.exists() == false)
				startingDir = getDefaultStartingDirectory();
			setDirectory(startingDir, HistoryPolicy.IGNORE);
		} else {
			setDirectory(directory, HistoryPolicy.IGNORE);
		}
		setSize(500, 600);
		centerWindow();
		createListeners();
		setFileTypeFilter(null);
		setFavoriteFolderButtonVisible(false);
	}
	private void createToolbar () {
		VisTable toolbarTable = new VisTable(true);
		toolbarTable.defaults().minWidth(30).right();
		add(toolbarTable).fillX().expandX().pad(3).padRight(2);
		historyManager = new FileHistoryManager(style, this);
		currentPath = new VisTextField();
		final VisImageButton showRecentDirButton = new VisImageButton(style.expandDropdown);
		showRecentDirButton.setFocusBorderEnabled(false);
		dirsSuggestionPopup = new DirsSuggestionPopup(this, currentPath);
		dirsSuggestionPopup.setListener(new PopupMenu.PopupMenuListener() {
			@Override
			public void activeItemChanged (MenuItem newItem, boolean changedByKeyboard) {
				if (changedByKeyboard == false || newItem == null) return;
				setCurrentPathFieldText(newItem.getText().toString());
			}
		});
		currentPath.addListener(new InputListener() {
			@Override
			public boolean keyTyped (InputEvent event, char character) {
				if (event.getKeyCode() == Keys.ENTER) {
					dirsSuggestionPopup.remove();
					return false;
				}
				float targetWidth = currentPath.getWidth() + showRecentDirButton.getWidth();
				dirsSuggestionPopup.pathFieldKeyTyped(getChooserStage(), targetWidth);
				return false;
			}
			@Override
			public boolean keyDown (InputEvent event, int keycode) {
				if (keycode == Keys.ENTER) {
					FileHandle file = Gdx.files.absolute(currentPath.getText());
					if (file.exists()) {
						if (file.isDirectory() == false) file = file.parent();
						setDirectory(file, HistoryPolicy.ADD);
						addRecentDirectory(file);
					} else {
						showDialog(POPUP_DIRECTORY_DOES_NOT_EXIST.get());
						setCurrentPathFieldText(currentDirectory.path());
					}
					event.stop();
				}
				return false;
			}
		});
		currentPath.addListener(new FocusListener() {
			@Override
			public void keyboardFocusChanged (FocusEvent event, Actor actor, boolean focused) {
				if (focused == false) {
					setCurrentPathFieldText(currentDirectory.path());
				}
			}
		});
		showRecentDirButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				float targetWidth = currentPath.getWidth() + showRecentDirButton.getWidth();
				dirsSuggestionPopup.showRecentDirectories(getChooserStage(), recentDirectories, targetWidth);
			}
		});
		VisImageButton folderParentButton = new VisImageButton(style.iconFolderParent, PARENT_DIRECTORY.get());
		favoriteFolderButton = new VisImageButton(style.iconStar);
		favoriteFolderButtonTooltip = new Tooltip.Builder(CONTEXT_MENU_ADD_TO_FAVORITES.get()).target(favoriteFolderButton).build();
		viewModeButton = new VisImageButton(style.iconListSettings);
		new Tooltip.Builder(CHANGE_VIEW_MODE.get()).target(viewModeButton).build();
		VisImageButton folderNewButton = new VisImageButton(style.iconFolderNew, NEW_DIRECTORY.get());
		toolbarTable.add(historyManager.getButtonsTable());
		toolbarTable.add(currentPath).spaceRight(0).expand().fill();
		toolbarTable.add(showRecentDirButton).width(15 * sizes.scaleFactor).growY();
		toolbarTable.add(folderParentButton);
		toolbarTable.add(favoriteFolderButton).width(PrefWidthIfVisibleValue.INSTANCE).spaceRight(new ConstantIfVisibleValue(sizes.spacingRight));
		toolbarTable.add(viewModeButton).width(PrefWidthIfVisibleValue.INSTANCE).spaceRight(new ConstantIfVisibleValue(sizes.spacingRight));
		toolbarTable.add(folderNewButton);
		folderParentButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				FileHandle parent = currentDirectory.parent();
				// if current directory is drive root (eg. "C:/") navigating to parent
				// would navigate to "/" which would work but it is bad for UX
				if (OsUtils.isWindows() && currentDirectory.path().endsWith(":/")) return;
				setDirectory(parent, HistoryPolicy.ADD);
			}
		});
		favoriteFolderButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				if (favorites.contains(currentDirectory, false)) {
					removeFavorite(currentDirectory);
				} else {
					addFavorite(currentDirectory);
				}
			}
		});
		folderNewButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				showNewDirectoryDialog();
			}
		});
		addListener(historyManager.getDefaultClickListener());
	}
	private void createViewModePopupMenu () {
		rebuildViewModePopupMenu();
		viewModeButton.addListener(new InputListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				//show menu on next frame, without it menu would be closed instantly it was opened
				//the other solution is to call event.stop but this could lead to some other PopupMenu not being closed
				//on touchDown event because event.stop stops event propagation
				Gdx.app.postRunnable(new Runnable() {
					@Override
					public void run () {
						viewModePopupMenu.showMenu(getChooserStage(), viewModeButton);
					}
				});
				return true;
			}
		});
	}
	private void rebuildViewModePopupMenu () {
		viewModePopupMenu.clear();
		for (final ViewMode mode : ViewMode.values()) {
			if (mode.thumbnailMode && iconProvider.isThumbnailModesSupported() == false) continue;
			viewModePopupMenu.addItem(new MenuItem(mode.getBundleText(), new ChangeListener() {
				@Override
				public void changed (ChangeEvent event, Actor actor) {
					setViewMode(mode);
				}
			}));
		}
	}
	private void updateFavoriteFolderButton () {
		VisLabel label = (VisLabel) favoriteFolderButtonTooltip.getContent();
		if (favorites.contains(currentDirectory, false)) {
			favoriteFolderButton.getStyle().imageUp = style.iconStar;
			label.setText(CONTEXT_MENU_REMOVE_FROM_FAVORITES.get());
		} else {
			favoriteFolderButton.getStyle().imageUp = style.iconStarOutline;
			label.setText(CONTEXT_MENU_ADD_TO_FAVORITES.get());
		}
		favoriteFolderButtonTooltip.pack();
	}
	private void createCenterContentPanel () {
		fileListAdapter = new FileListAdapter(this, currentFiles);
		fileListView = new ListView<FileHandle>(fileListAdapter);
		setupDefaultScrollPane(fileListView.getScrollPane());
		VisTable fileScrollPaneTable = new VisTable();
		fileListBusyBar = new BusyBar();
		fileListBusyBar.setVisible(false);
		fileScrollPaneTable.add(fileListBusyBar).space(0).height(PrefHeightIfVisibleValue.INSTANCE).growX().row();
		fileScrollPaneTable.add(fileListView.getMainTable()).pad(2).top().expand().fillX();
		fileScrollPaneTable.setTouchable(Touchable.enabled);
		// shortcutsTable is contained in shortcutsScrollPane contained in shortcutsScrollPaneTable contained in mainSplitPane
		shortcutsTable = new VisTable();
		final VisScrollPane shortcutsScrollPane = setupDefaultScrollPane(new VisScrollPane(shortcutsTable));
		VisTable shortcutsScrollPaneTable = new VisTable();
		shortcutsScrollPaneTable.add(shortcutsScrollPane).pad(2).top().expand().fillX();
		mainSplitPane = new VisSplitPane(shortcutsScrollPaneTable, fileScrollPaneTable, false) {
			@Override
			public void invalidate () {
				super.invalidate();
				invalidateChildHierarchy(shortcutsScrollPane);
			}
		};
		mainSplitPane.setSplitAmount(0.3f);
		mainSplitPane.setMinSplitAmount(0.05f);
		mainSplitPane.setMaxSplitAmount(0.80f);
		row();
		add(mainSplitPane).expand().fill();
		row();
		fileScrollPaneTable.addListener(new InputListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				return true;
			}
			@Override
			public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
				if (button == Buttons.RIGHT && fileMenu.isAddedToStage() == false) {
					fileMenu.build();
					fileMenu.showMenu(getChooserStage(), event.getStageX(), event.getStageY());
				}
			}
		});
	}
	private void invalidateChildHierarchy (WidgetGroup layout) {
		if (layout != null) {
			layout.invalidate();
			for (Actor actor : layout.getChildren()) {
				if (actor instanceof WidgetGroup)
					invalidateChildHierarchy((WidgetGroup) actor);
				else if (actor instanceof Layout)
					((Layout) actor).invalidate();
			}
		}
	}
	private void setCurrentPathFieldText (String text) {
		currentPath.setText(text);
		currentPath.setCursorAtTextEnd();
	}
	private void createFileTextBox () {
		VisTable table = new VisTable(true);
		VisLabel nameLabel = new VisLabel(FILE_NAME.get());
		selectedFileTextField = new VisTextField();
		selectedFileTextField.setProgrammaticChangeEvents(false);
		fileTypeLabel = new VisLabel(FILE_TYPE.get());
		fileTypeSelectBox = new VisSelectBox<FileTypeFilter.Rule>();
		fileTypeSelectBox.getSelection().setProgrammaticChangeEvents(false);
		fileTypeSelectBox.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				activeFileTypeRule = fileTypeSelectBox.getSelected();
				rebuildFileList();
			}
		});
		table.defaults().left();
		table.add(nameLabel).spaceBottom(new ConstantIfVisibleValue(fileTypeSelectBox, 5f));
		table.add(selectedFileTextField).expandX().fillX()
				.spaceBottom(new ConstantIfVisibleValue(fileTypeSelectBox, 5f)).row();
		table.add(fileTypeLabel).height(PrefHeightIfVisibleValue.INSTANCE)
				.spaceBottom(new ConstantIfVisibleValue(sizes.spacingBottom));
		table.add(fileTypeSelectBox).height(PrefHeightIfVisibleValue.INSTANCE)
				.spaceBottom(new ConstantIfVisibleValue(sizes.spacingBottom)).expand().fill();
		selectedFileTextField.addListener(new InputListener() {
			@Override
			public boolean keyDown (InputEvent event, int keycode) {
				if (keycode == Keys.ENTER) {
					selectionFinished();
					return true;
				}
				return false;
			}
		});
		selectedFileTextField.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				deselectAll(false);
				fileNameSuggestionPopup.pathFieldKeyTyped(getChooserStage(), currentFiles, selectedFileTextField);
				FileHandle enteredFile = currentDirectory.child(selectedFileTextField.getText());
				if (currentFiles.contains(enteredFile, false)) {
					highlightFiles(enteredFile);
				}
			}
		});
		add(table).expandX().fillX().pad(3f).padRight(2f).padBottom(2f);
		row();
	}
	private void updateFileTypeSelectBox () {
		if (fileTypeFilter == null || selectionMode == SelectionMode.DIRECTORIES) {
			fileTypeLabel.setVisible(false);
			fileTypeSelectBox.setVisible(false);
			fileTypeSelectBox.invalidateHierarchy();
			return;
		} else {
			fileTypeLabel.setVisible(true);
			fileTypeSelectBox.setVisible(true);
			fileTypeSelectBox.invalidateHierarchy();
		}
		Array<FileTypeFilter.Rule> rules = new Array<FileTypeFilter.Rule>(fileTypeFilter.getRules());
		if (fileTypeFilter.isAllTypesAllowed()) {
			FileTypeFilter.Rule allTypesRule = new FileTypeFilter.Rule(ALL_FILES.get());
			rules.add(allTypesRule);
		}
		fileTypeSelectBox.setItems(rules);
		fileTypeSelectBox.setSelected(activeFileTypeRule);
	}
	private void createBottomButtons () {
		VisTextButton cancelButton = new VisTextButton(CANCEL.get());
		confirmButton = new VisTextButton(mode == Mode.OPEN ? OPEN.get() : SAVE.get());
		VisTable buttonTable = new VisTable(true);
		buttonTable.defaults().minWidth(70).right();
		add(buttonTable).padTop(3).padBottom(3).padRight(2).fillX().expandX();
		ButtonBar buttonBar = new ButtonBar();
		buttonBar.setIgnoreSpacing(true);
		buttonBar.setButton(ButtonType.CANCEL, cancelButton);
		buttonBar.setButton(ButtonType.OK, confirmButton);
		buttonTable.add(buttonBar.createTable()).expand().right();
		cancelButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				fadeOut();
				listener.canceled();
			}
		});
		confirmButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				selectionFinished();
			}
		});
	}
	private void createShortcutsMainPanel () {
		shortcutsMainPanel = new VerticalGroup();
		String userHome = System.getProperty("user.home");
		String userName = System.getProperty("user.name");
		File userDesktop = new File(userHome + "/Desktop");
		if (userDesktop.exists())
			shortcutsMainPanel.addActor(new ShortcutItem(userDesktop, DESKTOP.get(), style.iconFolder));
		shortcutsMainPanel.addActor(new ShortcutItem(new File(userHome), userName, style.iconFolder));
	}
	private void createListeners () {
		addListener(new InputListener() {
			@Override
			public boolean keyDown (InputEvent event, int keycode) {
				if (keycode == Keys.A && UIUtils.ctrl() && getChooserStage().getKeyboardFocus() instanceof VisTextField == false) {
					selectAll();
					return true;
				}
				return false;
			}
			@Override
			public boolean keyTyped (InputEvent event, char character) {
				if (getChooserStage().getKeyboardFocus() instanceof VisTextField) return false;
				if (Character.isLetterOrDigit(character) == false) return false;
				String name = String.valueOf(character);
				for (FileHandle file : currentFiles) {
					if (file.name().toLowerCase().startsWith(name)) {
						deselectAll();
						highlightFiles(file);
						return true;
					}
				}
				return false;
			}
		});
	}
	private void selectionFinished () {
		if (selectedItems.size == 1) {
			// only files allowed but directory is selected?
			// navigate to that directory!
			if (selectionMode == SelectionMode.FILES) {
				FileHandle selected = selectedItems.get(0).getFile();
				if (selected.isDirectory()) {
					setDirectory(selected, HistoryPolicy.ADD);
					return;
				}
			}
			// only directories allowed but file is selected?
			// display dialog :(
			if (selectionMode == SelectionMode.DIRECTORIES) {
				FileHandle selected = selectedItems.get(0).getFile();
				if (selected.isDirectory() == false) {
					showDialog(POPUP_ONLY_DIRECTORIES.get());
					return;
				}
			}
		}
		if (selectedItems.size > 0 || mode == Mode.SAVE) {
			Array<FileHandle> files = getFileListFromSelected();
			notifyListenerAndCloseDialog(files);
		} else {
			if (selectionMode == SelectionMode.FILES) {
				showDialog(POPUP_CHOOSE_FILE.get());
			} else {
				Array<FileHandle> files = new Array<FileHandle>();
				if (selectedFileTextField.getText().length() != 0) {
					files.add(currentDirectory.child(selectedFileTextField.getText()));
				} else {
					// this part is executed when nothing is selected but selection mode is `directories` or `files and directories`
					// it is perfectly valid, nothing is selected so that means the current chooser directory have to be
					// selected and passed to listener
					files.add(currentDirectory);
				}
				notifyListenerAndCloseDialog(files);
			}
		}
	}
	@Override
	protected void close () {
		listener.canceled();
		super.close();
	}
	private void notifyListenerAndCloseDialog (Array<FileHandle> files) {
		if (files == null) return;
		if (mode == Mode.OPEN) {
			for (FileHandle file : files) {
				if (file.exists() == false) {
					showDialog(POPUP_SELECTED_FILE_DOES_NOT_EXIST.get());
					return;
				}
			}
		}
		if (files.size != 0) {
			listener.selected(files);
			if (saveLastDirectory) {
				preferencesIO.saveLastDirectory(currentDirectory);
			}
		}
		fadeOut();
	}
	@Override
	public void fadeOut (float time) {
		super.fadeOut(time);
		fileMenu.remove();
		dirsSuggestionPopup.remove();
		fileNameSuggestionPopup.remove();
		viewModePopupMenu.remove();
	}
	protected VisScrollPane setupDefaultScrollPane (VisScrollPane scrollPane) {
		scrollPane.setOverscroll(false, false);
		scrollPane.setFlickScroll(false);
		scrollPane.setFadeScrollBars(false);
		scrollPane.setScrollingDisabled(true, false);
		return scrollPane;
	}
	private Array<FileHandle> getFileListFromSelected () {
		Array<FileHandle> list = new Array<FileHandle>();
		if (mode == Mode.OPEN) {
			for (FileItem item : selectedItems)
				list.add(item.getFile());
			return list;
		} else if (selectedItems.size > 0) {
			for (FileItem item : selectedItems)
				list.add(item.getFile());
			showOverwriteQuestion(list);
			return null;
		} else {
			String fileName = selectedFileTextField.getText();
			FileHandle file = currentDirectory.child(fileName);
			if (FileUtils.isValidFileName(fileName) == false) {
				showDialog(POPUP_FILENAME_INVALID.get());
				return null;
			}
			if (file.exists()) {
				list.add(file);
				showOverwriteQuestion(list);
				return null;
			} else {
				//if user typed no extension or extension is wrong and there is active file type rule
				//then the first extension rule will be appended/replaced automatically to entered file name
				if (activeFileTypeRule != null) {
					Array<String> ruleExts = activeFileTypeRule.getExtensions();
					if (ruleExts.size > 0 && ruleExts.contains(file.extension(), false) == false) {
						file = file.sibling(file.nameWithoutExtension() + "." + ruleExts.first());
					}
				}
				list.add(file);
				if (file.exists()) {
					showOverwriteQuestion(list);
					return null;
				} else {
					return list;
				}
			}
		}
	}
	private void showDialog (String text) {
		Dialogs.showOKDialog(getChooserStage(), POPUP_TITLE.get(), text);
	}
	private void showOverwriteQuestion (final Array<FileHandle> filesList) {
		String text = filesList.size == 1 ? POPUP_FILE_EXIST_OVERWRITE.get() : POPUP_MULTIPLE_FILE_EXIST_OVERWRITE.get();
		Dialogs.showOptionDialog(getChooserStage(), POPUP_TITLE.get(), text, OptionDialogType.YES_NO, new OptionDialogAdapter() {
			@Override
			public void yes () {
				notifyListenerAndCloseDialog(filesList);
			}
		});
	}
	private void rebuildShortcutsList (boolean rebuildRootCache) {
		shortcutsTable.clear();
		shortcutsTable.add(shortcutsMainPanel).left().row();
		shortcutsTable.addSeparator();
		if (rebuildRootCache) rebuildFileRootsCache();
		shortcutsTable.add(shortcutsRootsPanel).left().row();
		if (shortcutsFavoritesPanel.getChildren().size > 0)
			shortcutsTable.addSeparator();
		shortcutsTable.add(shortcutsFavoritesPanel).left().row();
	}
	private void rebuildShortcutsList () {
		shortcutsListRebuildScheduled = false;
		rebuildShortcutsList(true);
	}
	private void rebuildFileRootsCache () {
		shortcutsRootsPanel.clear();
		File[] roots = File.listRoots();
		driveCheckerListeners.clear();
		for (final File root : roots) {
			DriveCheckerListener listener = new DriveCheckerListener() {
				@Override
				public void rootMode (File root, RootMode mode) {
					if (driveCheckerListeners.removeValue(this, true) == false) return;
					String initialName = root.toString();
					if (initialName.equals("/")) initialName = COMPUTER.get();
					final ShortcutItem item = new ShortcutItem(root, initialName, style.iconDrive);
					if (OsUtils.isWindows()) chooserWinService.addListener(root, item);
					shortcutsRootsPanel.addActor(item);
					shortcutsRootsPanel.getChildren().sort(SHORTCUTS_COMPARATOR);
				}
			};
			driveCheckerListeners.add(listener);
			driveCheckerService.addListener(root, mode == Mode.OPEN ? RootMode.READABLE : RootMode.WRITABLE, listener);
		}
	}
	private void rebuildShortcutsFavoritesPanel () {
		shortcutsFavoritesPanel.clear();
		if (favorites.size > 0) {
			for (FileHandle f : favorites)
				shortcutsFavoritesPanel.addActor(new ShortcutItem(f.file(), f.name(), style.iconFolder));
		}
	}
	private void rebuildFileList () {
		rebuildFileList(false);
	}
	private void rebuildFileList (final boolean stageChanged) {
		filesListRebuildScheduled = false;
		final FileHandle[] selectedFiles = new FileHandle[selectedItems.size];
		for (int i = 0; i < selectedFiles.length; i++) {
			selectedFiles[i] = selectedItems.get(i).getFile();
		}
		deselectAll();
		setCurrentPathFieldText(currentDirectory.path());
		if (showBusyBarTask.isScheduled() == false) {
			Timer.schedule(showBusyBarTask, 0.2f); //quiet period before busy bar is shown
		}
		if (listDirFuture != null) listDirFuture.cancel(true);
		listDirFuture = listDirExecutor.submit(new Runnable() {
			@Override
			public void run () {
				if (currentDirectory.exists() == false || currentDirectory.isDirectory() == false) {
					Gdx.app.postRunnable(new Runnable() {
						@Override
						public void run () {
							setDirectory(getDefaultStartingDirectory(), HistoryPolicy.ADD);
						}
					});
					return;
				}
				final Array<FileHandle> files = FileUtils.sortFiles(listFilteredCurrentDirectory(), sorting.get().comparator, !sortingOrderAscending.get());
				if (Thread.currentThread().isInterrupted()) return;
				final IdentityMap<FileHandle, FileHandleMetadata> metadata = new IdentityMap<FileHandle, FileHandleMetadata>(files.size);
				for (FileHandle file : files) {
					metadata.put(file, FileHandleMetadata.of(file));
				}
				if (Thread.currentThread().isInterrupted()) return;
				Gdx.app.postRunnable(new Runnable() {
					@Override
					public void run () {
						buildFileList(files, metadata, selectedFiles, stageChanged);
					}
				});
			}
		});
	}
	private void buildFileList (Array<FileHandle> files, IdentityMap<FileHandle, FileHandleMetadata> metadata, FileHandle[] selectedFiles, boolean stageChanged) {
		currentFiles.clear();
		currentFilesMetadata.clear();
		showBusyBarTask.cancel();
		fileListBusyBar.setVisible(false);
		if (files.size == 0) {
			fileListAdapter.itemsChanged();
			return;
		}
		maxDateLabelWidth = 0;
		currentFiles.addAll(files);
		currentFilesMetadata = metadata;
		fileListAdapter.itemsChanged();
		fileListView.getScrollPane().setScrollX(0);
		fileListView.getScrollPane().setScrollY(0);
		highlightFiles(selectedFiles);
		if (stageChanged && selectedFiles.length == 0 && defaultFileName != null) {
			selectedFileTextField.setText(defaultFileName);
			FileHandle enteredFile = currentDirectory.child(selectedFileTextField.getText());
			if (currentFiles.contains(enteredFile, false)) {
				highlightFiles(enteredFile);
			}
		}
	}
	/**
	 * Sets chooser selected files. All files that are invalid for current selection won't be selected. Files that doesn't
	 * exist will be ignored.
	 * @param files absolute {@link FileHandle}s of files to be selected
	 */
	public void setSelectedFiles (FileHandle... files) {
		deselectAll(false);
		for (FileHandle file : files) {
			FileItem item = fileListAdapter.getViews().get(file);
			if (item != null) {
				item.select(false);
			}
		}
		removeInvalidSelections();
		updateSelectedFileFieldText();
	}
	/**
	 * Changes default file name that will be displayed in file name text field after chooser is added to stage.
	 * This for example can be used to suggest default file name when chooser is in SAVE mode.
	 * <p>
	 * Note that when chooser is in OPEN mode and file with such name doesn't exist then pressing "Open" button
	 * will still display message that selected file does not exist.
	 * <p>
	 * Default file name is only used after chooser is added to {@link Stage} and no other file was selected by
	 * {@link #setSelectedFiles(FileHandle...)} or user.
	 * <p>
	 * This will automatically highlight matching file in file list (if file already exist).
	 * @param text new default file name, may be null
	 */
	public void setDefaultFileName (String text) {
		defaultFileName = text;
	}
	/** Refresh chooser lists content */
	public void refresh () {
		refresh(false);
	}
	private void refresh (boolean stageChanged) {
		rebuildShortcutsList();
		rebuildFileList(stageChanged);
	}
	/**
	 * Adds favorite to favorite list
	 * @param favourite to be added
	 */
	public void addFavorite (FileHandle favourite) {
		favorites.add(favourite);
		preferencesIO.saveFavorites(favorites);
		rebuildShortcutsFavoritesPanel();
		rebuildShortcutsList(false);
		updateFavoriteFolderButton();
	}
	/**
	 * Removes favorite from current favorite list
	 * @param favorite to be removed (path to favorite)
	 * @return true if favorite was removed, false otherwise
	 */
	public boolean removeFavorite (FileHandle favorite) {
		boolean removed = favorites.removeValue(favorite, false);
		preferencesIO.saveFavorites(favorites);
		rebuildShortcutsFavoritesPanel();
		rebuildShortcutsList(false);
		updateFavoriteFolderButton();
		return removed;
	}
	private void addRecentDirectory (FileHandle file) {
		if (recentDirectories.contains(file, false)) return;
		recentDirectories.insert(0, file);
		if (recentDirectories.size > AbstractSuggestionPopup.MAX_SUGGESTIONS) recentDirectories.pop();
		preferencesIO.saveRecentDirectories(recentDirectories);
	}
	public void clearRecentDirectories () {
		recentDirectories.clear();
		preferencesIO.saveRecentDirectories(recentDirectories);
	}
	@Override
	public void setVisible (boolean visible) {
		if (isVisible() == false && visible)
			deselectAll(); // reset selected item when dialog is changed from invisible to visible
		super.setVisible(visible);
	}
	private void deselectAll () {
		deselectAll(true);
	}
	private void deselectAll (boolean updateTextField) {
		for (FileItem item : selectedItems)
			item.deselect(false);
		selectedItems.clear();
		if (updateTextField) updateSelectedFileFieldText();
	}
	private void selectAll () {
		for (FileItem item : fileListAdapter.getOrderedViews())
			item.select(false);
		removeInvalidSelections();
		updateSelectedFileFieldText();
	}
	/**
	 * Sets chooser selected files. Compared to {@link #setSelectedFiles(FileHandle...)} does not remove invalid files
	 * from selection.
	 */
	public void highlightFiles (FileHandle... files) {
		for (FileHandle file : files) {
			FileItem item = fileListAdapter.getViews().get(file);
			if (item != null) {
				item.select(false);
			}
		}
		if (files.length > 0) {
			FileItem item = fileListAdapter.getViews().get(files[0]);
			if (item != null) {
				if (item.getParent() instanceof Table) { //table at this point may need additional layout to calculate proper target scroll cords
					((Table) item.getParent()).layout();
				}
				item.localToParentCoordinates(tmpVector.setZero());
				fileListView.getScrollPane().scrollTo(tmpVector.x, tmpVector.y, item.getWidth(), item.getHeight(), false, true);
			}
		}
		updateSelectedFileFieldText();
	}
	private void updateSelectedFileFieldText () {
		updateSelectedFileFieldText(false);
	}
	private void updateSelectedFileFieldText (boolean ignoreKeyboardFocus) {
		if (ignoreKeyboardFocus == false && getChooserStage() != null) {
			if (getChooserStage().getKeyboardFocus() == selectedFileTextField) return;
		}
		if (selectedItems.size == 0) {
			selectedFileTextField.setText("");
		} else if (selectedItems.size == 1) {
			selectedFileTextField.setText(selectedItems.get(0).getFile().name());
		} else {
			StringBuilder builder = new StringBuilder();
			for (FileItem item : selectedItems) {
				builder.append('"');
				builder.append(item.file.name());
				builder.append("\" ");
			}
			selectedFileTextField.setText(builder.toString());
		}
		selectedFileTextField.setCursorAtTextEnd();
	}
	private void removeInvalidSelections () {
		if (selectionMode == SelectionMode.FILES) {
			Iterator<FileItem> it = selectedItems.iterator();
			while (it.hasNext()) {
				FileItem item = it.next();
				if (item.file.isDirectory()) {
					item.deselect(false);
					it.remove();
				}
			}
		}
		if (selectionMode == SelectionMode.DIRECTORIES) {
			Iterator<FileItem> it = selectedItems.iterator();
			while (it.hasNext()) {
				FileItem item = it.next();
				if (item.file.isDirectory() == false) {
					item.deselect(false);
					it.remove();
				}
			}
		}
	}
	public Mode getMode () {
		return mode;
	}
	public void setMode (Mode mode) {
		this.mode = mode;
		confirmButton.setText(mode == Mode.OPEN ? OPEN.get() : SAVE.get());
		refresh();
	}
	public ViewMode getViewMode () {
		return viewMode;
	}
	public void setViewMode (ViewMode viewMode) {
		if (this.viewMode == viewMode) return;
		this.viewMode = viewMode;
		iconProvider.viewModeChanged(viewMode);
		rebuildFileList();
	}
	public void setDirectory (String directory) {
		setDirectory(Gdx.files.absolute(directory), HistoryPolicy.CLEAR);
	}
	public void setDirectory (File directory) {
		setDirectory(Gdx.files.absolute(directory.getAbsolutePath()), HistoryPolicy.CLEAR);
	}
	public void setDirectory (FileHandle directory) {
		setDirectory(directory, HistoryPolicy.CLEAR);
	}
	/**
	 * Changes file chooser active directory.
	 * Warning: To avoid hanging listing directory is performed asynchronously. In case of passing invalid file handle
	 * file chooser will fallback to default one.
	 */
	@Override
	public void setDirectory (FileHandle directory, HistoryPolicy historyPolicy) {
		if (directory.equals(currentDirectory)) return;
		if (historyPolicy == HistoryPolicy.ADD) historyManager.historyAdd();
		currentDirectory = directory;
		iconProvider.directoryChanged(directory);
		rebuildFileList();
		if (historyPolicy == HistoryPolicy.CLEAR) historyManager.historyClear();
		updateFavoriteFolderButton();
	}
	@Override
	public FileHandle getCurrentDirectory () {
		return currentDirectory;
	}
	private FileHandle getDefaultStartingDirectory () {
		return Gdx.files.absolute(System.getProperty("user.home"));
	}
	/** List currently set directory with all active filters */
	private FileHandle[] listFilteredCurrentDirectory () {
		FileHandle[] files = currentDirectory.list(fileFilter);
		if (fileTypeFilter == null || activeFileTypeRule == null) return files;
		FileHandle[] filtered = new FileHandle[files.length];
		int count = 0;
		for (FileHandle file : files) {
			if (file.isDirectory() == false && activeFileTypeRule.accept(file) == false) continue;
			filtered[count++] = file;
		}
		if (count == 0) return new FileHandle[0];
		FileHandle[] newFiltered = new FileHandle[count];
		System.arraycopy(filtered, 0, newFiltered, 0, count);
		return newFiltered;
	}
	public FileFilter getFileFilter () {
		return fileFilter;
	}
	public void setFileFilter (FileFilter fileFilter) {
		this.fileFilter = fileFilter;
		rebuildFileList();
	}
	/**
	 * Sets new {@link FileTypeFilter}. Note that if you modify {@link FileTypeFilter} you must call this method again with
	 * modified instance to apply changes. Setting file type filter won't have any effect when selection mode is set to
	 * directories.
	 */
	public void setFileTypeFilter (FileTypeFilter fileTypeFilter) {
		if (fileTypeFilter == null) {
			this.fileTypeFilter = null;
			this.activeFileTypeRule = null;
		} else {
			if (fileTypeFilter.getRules().size == 0)
				throw new IllegalArgumentException("FileTypeFilter doesn't have any rules added");
			this.fileTypeFilter = new FileTypeFilter(fileTypeFilter);
			this.activeFileTypeRule = this.fileTypeFilter.getRules().first();
		}
		updateFileTypeSelectBox();
		rebuildFileList();
	}
	public FileTypeFilter.Rule getActiveFileTypeFilterRule () {
		return activeFileTypeRule;
	}
	public SelectionMode getSelectionMode () {
		return selectionMode;
	}
	/**
	 * Changes selection mode, also updates the title of this file chooser to match current selection mode (eg. Choose file, Choose
	 * directory etc.)
	 */
	public void setSelectionMode (SelectionMode selectionMode) {
		if (selectionMode == null) selectionMode = SelectionMode.FILES;
		this.selectionMode = selectionMode;
		switch (selectionMode) {
			case FILES:
				getTitleLabel().setText(TITLE_CHOOSE_FILES.get());
				break;
			case DIRECTORIES:
				getTitleLabel().setText(TITLE_CHOOSE_DIRECTORIES.get());
				break;
			case FILES_AND_DIRECTORIES:
				getTitleLabel().setText(TITLE_CHOOSE_FILES_AND_DIRECTORIES.get());
				break;
		}
		updateFileTypeSelectBox();
		rebuildFileList();
	}
	public FileSorting getSorting () {
		return sorting.get();
	}
	public void setSorting (FileSorting sorting, boolean sortingOrderAscending) {
		this.sorting.set(sorting);
		this.sortingOrderAscending.set(sortingOrderAscending);
		rebuildFileList();
	}
	public void setSorting (FileSorting sorting) {
		this.sorting.set(sorting);
		rebuildFileList();
	}
	public boolean isSortingOrderAscending () {
		return sortingOrderAscending.get();
	}
	public void setSortingOrderAscending (boolean sortingOrderAscending) {
		this.sortingOrderAscending.set(sortingOrderAscending);
		rebuildFileList();
	}
	public void setFavoriteFolderButtonVisible (boolean favoriteFolderButtonVisible) {
		favoriteFolderButton.setVisible(favoriteFolderButtonVisible);
	}
	public boolean isFavoriteFolderButtonVisible () {
		return favoriteFolderButton.isVisible();
	}
	public void setViewModeButtonVisible (boolean viewModeButtonVisible) {
		viewModeButton.setVisible(viewModeButtonVisible);
	}
	public boolean isViewModeButtonVisible () {
		return viewModeButton.isVisible();
	}
	public boolean isMultiSelectionEnabled () {
		return multiSelectionEnabled;
	}
	public void setMultiSelectionEnabled (boolean multiSelectionEnabled) {
		this.multiSelectionEnabled = multiSelectionEnabled;
	}
	public void setListener (FileChooserListener newListener) {
		this.listener = newListener;
		if (listener == null) listener = new FileChooserAdapter();
	}
	public boolean isShowSelectionCheckboxes () {
		return showSelectionCheckboxes;
	}
	public void setShowSelectionCheckboxes (boolean showSelectionCheckboxes) {
		this.showSelectionCheckboxes = showSelectionCheckboxes;
		rebuildFileList();
	}
	public int getMultiSelectKey () {
		return multiSelectKey;
	}
	/** @param multiSelectKey from {@link Keys} or {@link FileChooser#DEFAULT_KEY} to restore default */
	public void setMultiSelectKey (int multiSelectKey) {
		this.multiSelectKey = multiSelectKey;
	}
	public int getGroupMultiSelectKey () {
		return groupMultiSelectKey;
	}
	/** @param groupMultiSelectKey from {@link Keys} or {@link FileChooser#DEFAULT_KEY} to restore default */
	public void setGroupMultiSelectKey (int groupMultiSelectKey) {
		this.groupMultiSelectKey = groupMultiSelectKey;
	}
	private boolean isMultiSelectKeyPressed () {
		if (multiSelectKey == DEFAULT_KEY)
			return UIUtils.ctrl();
		else
			return Gdx.input.isKeyPressed(multiSelectKey);
	}
	private boolean isGroupMultiSelectKeyPressed () {
		if (groupMultiSelectKey == DEFAULT_KEY)
			return UIUtils.shift();
		else
			return Gdx.input.isKeyPressed(groupMultiSelectKey);
	}
	public FileChooserStyle getChooserStyle () {
		return style;
	}
	public Sizes getSizes () {
		return sizes;
	}
	private Stage getChooserStage () {
		return getStage();
	}
	/**
	 * If false file chooser won't pool directories for changes, adding new files or connecting new drive won't refresh file list.
	 * This must be called when file chooser is not added to Stage
	 */
	public void setWatchingFilesEnabled (boolean watchingFilesEnabled) {
		if (getChooserStage() != null)
			throw new IllegalStateException("Pooling setting cannot be changed when file chooser is added to Stage!");
		this.watchingFilesEnabled = watchingFilesEnabled;
	}
	public void setPrefsName (String prefsName) {
		preferencesIO = new PreferencesIO(prefsName);
		reloadPreferences(true);
	}
	private void reloadPreferences (boolean rebuildUI) {
		favorites = preferencesIO.loadFavorites();
		recentDirectories = preferencesIO.loadRecentDirectories();
		if (rebuildUI) rebuildShortcutsFavoritesPanel();
	}
	@Override
	public void draw (Batch batch, float parentAlpha) {
		super.draw(batch, parentAlpha);
		if (shortcutsListRebuildScheduled) rebuildShortcutsList();
		if (filesListRebuildScheduled) rebuildFileList();
	}
	@Override
	protected void setStage (Stage stage) {
		super.setStage(stage);
		if (stage != null) {
			refresh(true);
			rebuildShortcutsFavoritesPanel(); //if by any chance multiple choosers changed favorites
			deselectAll();
			if (focusFileScrollPaneOnShow) {
				stage.setScrollFocus(fileListView.getScrollPane());
			}
			if (focusSelectedFileTextFieldOnShow) {
				FocusManager.switchFocus(stage, selectedFileTextField);
				stage.setKeyboardFocus(selectedFileTextField);
			}
		}
		if (watchingFilesEnabled) {
			if (stage != null) {
				startFileWatcher();
			} else {
				stopFileWatcher();
			}
		}
	}
	private void startFileWatcher () {
		if (fileWatcherThread != null) return;
		fileWatcherThread = new Thread(new Runnable() {
			File[] lastRoots;
			FileHandle lastCurrentDirectory;
			FileHandle[] lastCurrentFiles;
			@Override
			public void run () {
				lastRoots = File.listRoots();
				lastCurrentDirectory = currentDirectory;
				lastCurrentFiles = currentDirectory.list();
				while (fileWatcherThread != null) {
					File[] roots = File.listRoots();
					if (roots.length != lastRoots.length || Arrays.equals(lastRoots, roots) == false)
						shortcutsListRebuildScheduled = true;
					lastRoots = roots;
					// if current directory changed during pools then our lastCurrentDirectoryFiles list is outdated and we shouldn't
					// schedule files list rebuild
					if (lastCurrentDirectory.equals(currentDirectory) == true) {
						FileHandle[] currentFiles = currentDirectory.list();
						if (lastCurrentFiles.length != currentFiles.length || Arrays.equals(lastCurrentFiles, currentFiles) == false)
							filesListRebuildScheduled = true;
						lastCurrentFiles = currentFiles;
					} else
						lastCurrentFiles = currentDirectory.list(); // if list is outdated, refresh it
					lastCurrentDirectory = currentDirectory;
					try {
						Thread.sleep(FILE_WATCHER_CHECK_DELAY_MILLIS);
					} catch (InterruptedException ignored) {
					}
				}
			}
		}, "FileWatcherThread");
		fileWatcherThread.setDaemon(true);
		fileWatcherThread.start();
	}
	private void stopFileWatcher () {
		if (fileWatcherThread == null) return;
		fileWatcherThread.interrupt();
		fileWatcherThread = null;
	}
	private void showNewDirectoryDialog () {
		Dialogs.showInputDialog(getChooserStage(), NEW_DIRECTORY_DIALOG_TITLE.get(), NEW_DIRECTORY_DIALOG_TEXT.get(), true, new InputDialogAdapter() {
			@Override
			public void finished (String input) {
				if (FileUtils.isValidFileName(input) == false) {
					Dialogs.showErrorDialog(getChooserStage(), NEW_DIRECTORY_DIALOG_ILLEGAL_CHARACTERS.get());
					return;
				}
				for (FileHandle file : currentDirectory.list()) {
					if (file.name().equals(input)) {
						Dialogs.showErrorDialog(getChooserStage(), NEW_DIRECTORY_DIALOG_ALREADY_EXISTS.get());
						return;
					}
				}
				FileHandle newDir = currentDirectory.child(input);
				newDir.mkdirs();
				refresh();
				highlightFiles(newDir);
			}
		});
	}
	private void showFileDeleteDialog (final FileHandle fileToDelete) {
		Dialogs.showOptionDialog(getChooserStage(), POPUP_TITLE.get(),
				fileDeleter.hasTrash() ? CONTEXT_MENU_MOVE_TO_TRASH_WARNING.get() : CONTEXT_MENU_DELETE_WARNING.get(),
				OptionDialogType.YES_NO, new OptionDialogAdapter() {
					@Override
					public void yes () {
						try {
							boolean success = fileDeleter.delete(fileToDelete);
							if (success == false) {
								Dialogs.showErrorDialog(getChooserStage(), POPUP_DELETE_FILE_FAILED.get());
							}
						} catch (IOException e) {
							Dialogs.showErrorDialog(getChooserStage(), POPUP_DELETE_FILE_FAILED.get(), e);
							e.printStackTrace();
						}
						refresh();
					}
				});
	}
	/**
	 * Sets {@link FileChooser.FileDeleter} that will be used for deleting files. You SHOULD NOT set your own file deleter.
	 * You should use either {@link DefaultFileDeleter} or JNAFileDeleter from vis-ui-contrib project. JNAFileDeleter
	 * supports moving file to system trash instead of deleting it permanently, however it requires JNA library in your
	 * project classpath.
	 */
	public void setFileDeleter (FileDeleter fileDeleter) {
		if (fileDeleter == null) throw new IllegalStateException("fileDeleter can't be null");
		this.fileDeleter = fileDeleter;
		fileMenu.fileDeleterChanged(fileDeleter.hasTrash());
	}
	public void setIconProvider (FileIconProvider iconProvider) {
		this.iconProvider = iconProvider;
		rebuildViewModePopupMenu();
	}
	public FileIconProvider getIconProvider () {
		return iconProvider;
	}
	public static boolean isSaveLastDirectory () {
		return saveLastDirectory;
	}
	/**
	 * @param saveLastDirectory if true then chooser will store last directory user browsed in preferences file. Note that
	 * this only applies to using chooser between separate app launches. When single instance of chooser is reused in single
	 * app session then last directory is always remembered. Default is false. This must be called before creating FileChooser.
	 */
	public static void setSaveLastDirectory (boolean saveLastDirectory) {
		FileChooser.saveLastDirectory = saveLastDirectory;
	}
	public enum Mode {
		OPEN, SAVE
	}
	public enum SelectionMode {
		FILES, DIRECTORIES, FILES_AND_DIRECTORIES
	}
	public enum FileSorting {
		NAME(FileUtils.FILE_NAME_COMPARATOR),
		MODIFIED_DATE(FileUtils.FILE_MODIFIED_DATE_COMPARATOR),
		SIZE(FileUtils.FILE_SIZE_COMPARATOR);
		private final Comparator<FileHandle> comparator;
		FileSorting (Comparator<FileHandle> comparator) {
			this.comparator = comparator;
		}
	}
	public enum HistoryPolicy {
		ADD, CLEAR, IGNORE
	}
	public enum ViewMode {
		DETAILS(false, VIEW_MODE_DETAILS),
		BIG_ICONS(true, VIEW_MODE_BIG_ICONS),
		MEDIUM_ICONS(true, VIEW_MODE_MEDIUM_ICONS),
		SMALL_ICONS(true, VIEW_MODE_SMALL_ICONS),
		LIST(false, VIEW_MODE_LIST);
		private final FileChooserText bundleText;
		private final boolean thumbnailMode;
		ViewMode (boolean thumbnailMode, FileChooserText bundleText) {
			this.thumbnailMode = thumbnailMode;
			this.bundleText = bundleText;
		}
		public String getBundleText () {
			return bundleText.get();
		}
		public void setupGridGroup (Sizes sizes, GridGroup group) {
			if (isGridMode() == false) return;
			float gridSize = getGridSize(sizes);
			if (gridSize < 0) {
				throw new IllegalStateException("FileChooser's ViewMode " + this.toString() + " has invalid size defined in Sizes. " +
						"Expected value greater than 0, got: " + gridSize + ". Check your skin Sizes definition.");
			}
			if (this == LIST) {
				group.setItemSize(gridSize, 22 * sizes.scaleFactor);
				return;
			}
			group.setItemSize(gridSize);
		}
		public boolean isGridMode () {
			return isThumbnailMode() || this == LIST;
		}
		public boolean isThumbnailMode () {
			return thumbnailMode;
		}
		public float getGridSize (Sizes sizes) {
			switch (this) {
				case DETAILS:
					return -1;
				case BIG_ICONS:
					return sizes.fileChooserViewModeBigIconsSize;
				case MEDIUM_ICONS:
					return sizes.fileChooserViewModeMediumIconsSize;
				case SMALL_ICONS:
					return sizes.fileChooserViewModeSmallIconsSize;
				case LIST:
					return sizes.fileChooserViewModeListWidthSize;
				default:
					return -1;
			}
		}
	}
	/**
	 * Provides icons that will be used for file thumbnail on file list. If not set default is used that supports
	 * directories and few basic file types. If you want to add your custom icon your should extend {@link DefaultFileIconProvider}
	 */
	public interface FileIconProvider {
		/** @return icon that will be used for this file or null if no icon should be displayed */
		Drawable provideIcon (FileItem item);
		/**
		 * @return true if this icon provider can supply proper icons for {@link ViewMode#BIG_ICONS}, {@link ViewMode#MEDIUM_ICONS}
		 * and {@link ViewMode#SMALL_ICONS} view modes, false otherwise. If false thumbnail view modes won't be available for selection.
		 */
		boolean isThumbnailModesSupported ();
		void directoryChanged (FileHandle newDirectory);
		void viewModeChanged (ViewMode newViewMode);
	}
	public static class DefaultFileIconProvider implements FileIconProvider {
		protected FileChooser chooser;
		protected FileChooserStyle style;
		public DefaultFileIconProvider (FileChooser chooser) {
			this.chooser = chooser;
			this.style = chooser.style;
		}
		@Override
		public Drawable provideIcon (FileItem item) {
			if (item.isDirectory()) return getDirIcon(item);
			String ext = item.getFile().extension().toLowerCase();
			if (ext.equals("jpg") || ext.equals("jpeg") || ext.equals("png") || ext.equals("bmp"))
				return getImageIcon(item);
			if (ext.equals("wav") || ext.equals("ogg") || ext.equals("mp3")) return getAudioIcon(item);
			if (ext.equals("pdf")) return getPdfIcon(item);
			if (ext.equals("txt")) return getTextIcon(item);
			return getDefaultIcon(item);
		}
		protected Drawable getDirIcon (FileItem item) {
			return style.iconFolder;
		}
		protected Drawable getImageIcon (FileItem item) {
			return style.iconFileImage;
		}
		protected Drawable getAudioIcon (FileItem item) {
			return style.iconFileAudio;
		}
		protected Drawable getPdfIcon (FileItem item) {
			return style.iconFilePdf;
		}
		protected Drawable getTextIcon (FileItem item) {
			return style.iconFileText;
		}
		protected Drawable getDefaultIcon (FileItem item) {
			return null;
		}
		@Override
		public boolean isThumbnailModesSupported () {
			return false;
		}
		@Override
		public void directoryChanged (FileHandle newDirectory) {
		}
		@Override
		public void viewModeChanged (ViewMode newViewMode) {
		}
	}
	public static class DefaultFileFilter implements FileFilter {
		private FileChooser chooser;
		private boolean ignoreChooserSelectionMode = false;
		public DefaultFileFilter (FileChooser chooser) {
			this.chooser = chooser;
		}
		@Override
		public boolean accept (File f) {
			if (f.isHidden()) return false;
			if (chooser.getMode() == Mode.OPEN ? f.canRead() == false : f.canWrite() == false) return false;
			if (ignoreChooserSelectionMode == false && f.isDirectory() == false &&
					chooser.getSelectionMode() == SelectionMode.DIRECTORIES) {
				return false;
			}
			return true;
		}
		public boolean isIgnoreChooserSelectionMode () {
			return ignoreChooserSelectionMode;
		}
		public void setIgnoreChooserSelectionMode (boolean ignoreChooserSelectionMode) {
			this.ignoreChooserSelectionMode = ignoreChooserSelectionMode;
		}
	}
	public interface FileDeleter {
		boolean hasTrash ();
		boolean delete (FileHandle file) throws IOException;
	}
	public static final class DefaultFileDeleter implements FileDeleter {
		@Override
		public boolean hasTrash () {
			return false;
		}
		@Override
		public boolean delete (FileHandle file) {
			return file.deleteDirectory();
		}
	}
	private class ShowBusyBarTask extends Timer.Task {
		@Override
		public void run () {
			fileListBusyBar.resetSegment();
			fileListBusyBar.setVisible(true);
			currentFiles.clear();
			currentFilesMetadata.clear();
			fileListAdapter.itemsChanged();
		}
		@Override
		public synchronized void cancel () {
			super.cancel();
			fileListBusyBar.setVisible(false);
		}
	}
	/** Internal FileChooser API. */
	public class FileItem extends Table implements Focusable {
		private FileHandle file;
		private FileHandleMetadata metadata;
		private VisCheckBox selectCheckBox;
		private VisImage iconImage;
		public FileItem (final FileHandle file, ViewMode viewMode) {
			this.file = file;
			this.metadata = currentFilesMetadata.get(file);
			if (metadata == null) metadata = FileHandleMetadata.of(file); //fallback, should not ever happen
			setTouchable(Touchable.enabled);
			VisLabel name = new VisLabel(metadata.name(), viewMode == ViewMode.SMALL_ICONS ? "small" : "default");
			name.setEllipsis(true);
			Drawable icon = iconProvider.provideIcon(this);
			selectCheckBox = new VisCheckBox("");
			selectCheckBox.setFocusBorderEnabled(false);
			selectCheckBox.setProgrammaticChangeEvents(false);
			boolean shouldShowItemShowCheckBox = showSelectionCheckboxes && (
					(selectionMode == SelectionMode.FILES_AND_DIRECTORIES)
							|| (selectionMode == SelectionMode.FILES && metadata.isDirectory() == false)
							|| (selectionMode == SelectionMode.DIRECTORIES && metadata.isDirectory())
			);
			left();
			if (viewMode.isThumbnailMode()) {
				if (shouldShowItemShowCheckBox) {
					IconStack stack = new IconStack(iconImage = new VisImage(icon, Scaling.none), selectCheckBox);
					add(stack).padTop(3).grow().row();
					add(name).minWidth(1);
				} else {
					add(iconImage = new VisImage(icon, Scaling.none)).padTop(3).grow().row();
					add(name).minWidth(1);
				}
			} else {
				if (shouldShowItemShowCheckBox) add(selectCheckBox).padLeft(3);
				add(iconImage = new VisImage(icon)).padTop(3).minWidth(22 * sizes.scaleFactor);
				add(name).minWidth(1).growX().padRight(10);
				VisLabel size = new VisLabel(isDirectory() ? "" : metadata.readableFileSize(), "small");
				VisLabel dateLabel = new VisLabel(dateFormat.format(metadata.lastModified()), "small");
				size.setAlignment(Align.right);
				if (viewMode == ViewMode.DETAILS) {
					maxDateLabelWidth = Math.max(dateLabel.getWidth(), maxDateLabelWidth);
					add(size).right().padRight(isDirectory() ? 0 : 10);
					add(dateLabel).padRight(6).width(new Value() {
						@Override
						public float get (Actor context) {
							return maxDateLabelWidth;
						}
					});
				}
			}
			addListeners();
		}
		/**
		 * Updates file item icon, can be used for asynchronous icon loading. Note that icon provided must not return null
		 * even if this item icon will be loaded later.
		 */
		public void setIcon (Drawable icon, Scaling scaling) {
			iconImage.setDrawable(icon);
			iconImage.setScaling(scaling);
			iconImage.invalidateHierarchy();
		}
		private void addListeners () {
			addListener(new InputListener() {
				@Override
				public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
					FocusManager.switchFocus(getChooserStage(), FileItem.this);
					getChooserStage().setKeyboardFocus(FileItem.this);
					return true;
				}
				@Override
				public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
					if (event.getButton() == Buttons.RIGHT) {
						fileMenu.build(favorites, file);
						fileMenu.showMenu(getChooserStage(), event.getStageX(), event.getStageY());
					}
				}
				@Override
				public boolean keyDown (InputEvent event, int keycode) {
					if (keycode == Keys.FORWARD_DEL) {
						showFileDeleteDialog(file);
						return true;
					}
					return false;
				}
			});
			addListener(new ClickListener() {
				@Override
				public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
					// very fast selecting and deselecting folder would navigate to that folder
					// return false will protect against that (tap count won't be increased)
					if (handleSelectClick(false) == false) return false;
					return super.touchDown(event, x, y, pointer, button);
				}
				@Override
				public void clicked (InputEvent event, float x, float y) {
					super.clicked(event, x, y);
					if (getTapCount() == 2 && selectedItems.contains(FileItem.this, true)) {
						if (file.isDirectory()) {
							setDirectory(file, HistoryPolicy.ADD);
						} else
							selectionFinished();
					}
				}
			});
			selectCheckBox.addListener(new InputListener() {
				@Override
				public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
					event.stop();
					return true;
				}
			});
			selectCheckBox.addListener(new ChangeListener() {
				@Override
				public void changed (ChangeEvent event, Actor actor) {
					event.stop();
					handleSelectClick(true);
				}
			});
		}
		private boolean handleSelectClick (boolean checkboxClicked) {
			if (selectedShortcut != null) selectedShortcut.deselect();
			if (checkboxClicked) {
				if (multiSelectionEnabled == false && selectedItems.contains(FileItem.this, true) == false)
					deselectAll();
			} else {
				if (multiSelectionEnabled == false || (isMultiSelectKeyPressed() == false && isGroupMultiSelectKeyPressed() == false))
					deselectAll();
			}
			boolean itemSelected = select();
			if (selectedItems.size > 1 && multiSelectionEnabled && isGroupMultiSelectKeyPressed())
				selectGroup();
			if (selectedItems.size > 1) removeInvalidSelections();
			updateSelectedFileFieldText();
			return itemSelected;
		}
		private void selectGroup () {
			Array<FileItem> actors = fileListAdapter.getOrderedViews();
			int thisSelectionIndex = getItemId(actors, FileItem.this);
			int lastSelectionIndex = getItemId(actors, selectedItems.get(selectedItems.size - 2));
			int start;
			int end;
			if (thisSelectionIndex > lastSelectionIndex) {
				start = lastSelectionIndex;
				end = thisSelectionIndex;
			} else {
				start = thisSelectionIndex;
				end = lastSelectionIndex;
			}
			for (int i = start; i < end; i++) {
				FileItem item = actors.get(i);
				item.select(false);
			}
		}
		private int getItemId (Array<FileItem> actors, FileItem item) {
			for (int i = 0; i < actors.size; i++) {
				if (actors.get(i) == item) return i;
			}
			throw new IllegalStateException("Item not found in cells");
		}
		/** Selects this items, if item is already in selectedList it will be deselected */
		private boolean select () {
			return select(true);
		}
		private boolean select (boolean deselectIfAlreadySelected) {
			if (deselectIfAlreadySelected && selectedItems.contains(this, true)) {
				deselect();
				return false;
			}
			setBackground(style.highlight);
			selectCheckBox.setChecked(true);
			if (selectedItems.contains(this, true) == false) selectedItems.add(this);
			return true;
		}
		private void deselect () {
			deselect(true);
		}
		private void deselect (boolean removeFromList) {
			setBackground((Drawable) null);
			selectCheckBox.setChecked(false);
			if (removeFromList) selectedItems.removeValue(this, true);
		}
		@Override
		public void focusLost () {
		}
		@Override
		public void focusGained () {
		}
		public FileHandle getFile () {
			return file;
		}
		public boolean isDirectory () {
			return metadata.isDirectory();
		}
	}
	private class ShortcutItem extends Table implements RootNameListener, Focusable {
		public File file;
		private VisLabel name;
		/** Used only by shortcuts panel */
		public ShortcutItem (final File file, String customName, Drawable icon) {
			this.file = file;
			name = new VisLabel(customName);
			name.setEllipsis(true);
			add(new Image(icon)).padTop(3);
			Cell<VisLabel> labelCell = add(name).padRight(6);
			labelCell.width(new Value() {
				@Override
				public float get (Actor context) {
					return mainSplitPane.getFirstWidgetBounds().width - 30;
				}
			});
			addListener();
		}
		private void addListener () {
			addListener(new InputListener() {
				@Override
				public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
					FocusManager.switchFocus(getChooserStage(), ShortcutItem.this);
					getChooserStage().setKeyboardFocus(ShortcutItem.this);
					return true;
				}
				@Override
				public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
					if (event.getButton() == Buttons.RIGHT) {
						fileMenu.buildForFavorite(favorites, file);
						fileMenu.showMenu(getChooserStage(), event.getStageX(), event.getStageY());
					}
				}
				@Override
				public boolean keyDown (InputEvent event, int keycode) {
					if (keycode == Keys.FORWARD_DEL) {
						FileHandle gdxFile = Gdx.files.absolute(file.getAbsolutePath());
						if (favorites.contains(gdxFile, false)) {
							removeFavorite(gdxFile);
						}
						return true;
					}
					return false;
				}
			});
			addListener(new ClickListener() {
				@Override
				public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
					deselectAll();
					updateSelectedFileFieldText();
					select();
					return super.touchDown(event, x, y, pointer, button);
				}
				@Override
				public void clicked (InputEvent event, float x, float y) {
					super.clicked(event, x, y);
					if (getTapCount() == 1) {
						File file = ShortcutItem.this.file;
						if (file.exists() == false) {
							showDialog(POPUP_DIRECTORY_DOES_NOT_EXIST.get());
							refresh();
							return;
						}
						if (file.isDirectory()) {
							setDirectory(Gdx.files.absolute(file.getAbsolutePath()), HistoryPolicy.ADD);
							getChooserStage().setScrollFocus(fileListView.getScrollPane());
						}
					}
				}
			});
		}
		public void setLabelText (String text) {
			name.setText(text);
		}
		public String getLabelText () {
			return name.getText().toString();
		}
		private void select () {
			if (selectedShortcut != null) selectedShortcut.deselect();
			selectedShortcut = ShortcutItem.this;
			setBackground(style.highlight);
		}
		private void deselect () {
			setBackground((Drawable) null);
		}
		@Override
		public void setRootName (String newName) {
			setLabelText(newName);
		}
		@Override
		public void focusGained () {
		}
		@Override
		public void focusLost () {
		}
	}
	private static class ShortcutsComparator implements Comparator<Actor> {
		@Override
		public int compare (Actor o1, Actor o2) {
			ShortcutItem s1 = (ShortcutItem) o1;
			ShortcutItem s2 = (ShortcutItem) o2;
			return s1.getLabelText().compareTo(s2.getLabelText());
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.file.internal;
import com.badlogic.gdx.Input.Buttons;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.Array;
import com.kotcrab.vis.ui.util.dialog.Dialogs;
import com.kotcrab.vis.ui.widget.VisImageButton;
import com.kotcrab.vis.ui.widget.VisTable;
import com.kotcrab.vis.ui.widget.file.FileChooser;
import com.kotcrab.vis.ui.widget.file.FileChooser.HistoryPolicy;
import com.kotcrab.vis.ui.widget.file.FileChooserStyle;
import static com.kotcrab.vis.ui.widget.file.internal.FileChooserText.*;
/**
 * Manages {@link FileChooser} history of directories that user navigated into. This is internal VisUI API however this class
 * is also reused by VisEditor.
 * @author Kotcrab
 */
public class FileHistoryManager {
	private final FileHistoryCallback callback;
	private Array<FileHandle> history = new Array<FileHandle>();
	private Array<FileHandle> historyForward = new Array<FileHandle>();
	private VisTable buttonsTable;
	private VisImageButton backButton;
	private VisImageButton forwardButton;
	public FileHistoryManager (FileChooserStyle style, FileHistoryCallback callback) {
		this.callback = callback;
		backButton = new VisImageButton(style.iconArrowLeft, BACK.get());
		backButton.setGenerateDisabledImage(true);
		backButton.setDisabled(true);
		forwardButton = new VisImageButton(style.iconArrowRight, FORWARD.get());
		forwardButton.setGenerateDisabledImage(true);
		forwardButton.setDisabled(true);
		buttonsTable = new VisTable(true);
		buttonsTable.add(backButton);
		buttonsTable.add(forwardButton);
		backButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				historyBack();
			}
		});
		forwardButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				historyForward();
			}
		});
	}
	public ClickListener getDefaultClickListener () {
		return new ClickListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				if (button == Buttons.BACK || button == Buttons.FORWARD) {
					return true;
				}
				return super.touchDown(event, x, y, pointer, button);
			}
			@Override
			public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
				if (button == Buttons.BACK && hasHistoryBack()) {
					historyBack();
				} else if (button == Buttons.FORWARD && hasHistoryForward()) {
					historyForward();
				} else {
					super.touchUp(event, x, y, pointer, button);
				}
			}
		};
	}
	public VisTable getButtonsTable () {
		return buttonsTable;
	}
	public void historyClear () {
		history.clear();
		historyForward.clear();
		forwardButton.setDisabled(true);
		backButton.setDisabled(true);
	}
	public void historyAdd () {
		history.add(callback.getCurrentDirectory());
		historyForward.clear();
		backButton.setDisabled(false);
		forwardButton.setDisabled(true);
	}
	public void historyBack () {
		FileHandle dir = history.pop();
		historyForward.add(callback.getCurrentDirectory());
		if (setDirectoryFromHistory(dir) == false)
			historyForward.pop();
		if (!hasHistoryBack()) backButton.setDisabled(true);
		forwardButton.setDisabled(false);
	}
	public void historyForward () {
		FileHandle dir = historyForward.pop();
		history.add(callback.getCurrentDirectory());
		if (setDirectoryFromHistory(dir) == false)
			history.pop();
		if (!hasHistoryForward()) forwardButton.setDisabled(true);
		backButton.setDisabled(false);
	}
	private boolean setDirectoryFromHistory (FileHandle dir) {
		if (dir.exists()) {
			callback.setDirectory(dir, HistoryPolicy.IGNORE);
			return true;
		} else {
			Dialogs.showErrorDialog(callback.getStage(), DIRECTORY_NO_LONGER_EXISTS.get());
			return false;
		}
	}
	/** @return returns {@code true} if a forward-history is available */
	private boolean hasHistoryForward () {
		return historyForward.size != 0;
	}
	/** @return returns {@code true} if a back-history is available */
	private boolean hasHistoryBack () {
		return history.size != 0;
	}
	public interface FileHistoryCallback {
		FileHandle getCurrentDirectory ();
		void setDirectory (FileHandle directory, HistoryPolicy policy);
		Stage getStage ();
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.toast;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.scenes.scene2d.Action;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.util.ToastManager;
import com.kotcrab.vis.ui.widget.VisImageButton;
import com.kotcrab.vis.ui.widget.VisImageButton.VisImageButtonStyle;
import com.kotcrab.vis.ui.widget.VisTable;
import com.kotcrab.vis.ui.widget.VisWindow;
/**
 * Base class for all toasts. Toast is a wrapper around actual toast content table. It has close button and reference to
 * {@link ToastManager}. To create your own toast you should generally extend {@link ToastTable} class.
 * <p>
 * If you want further customization and modify other aspects of toast (such as close button) override
 * {@link #createMainTable()}.
 * @author Kotcrab
 * @see MessageToast
 * @see ToastTable
 * @since 1.1.0
 */
public class Toast {
	private ToastStyle style;
	private ToastManager toastManager;
	private Table mainTable;
	private Table contentTable;
	/** @param content table content, preferably instance of {@link ToastTable} */
	public Toast (Table content) {
		this("default", content);
	}
	/** @param content table content, preferably instance of {@link ToastTable} */
	public Toast (String styleName, Table content) {
		this(VisUI.getSkin().get(styleName, ToastStyle.class), content);
	}
	/** @param content table content, preferably instance of {@link ToastTable} */
	public Toast (ToastStyle style, Table content) {
		this.style = style;
		this.contentTable = content;
		if (content instanceof ToastTable) {
			((ToastTable) content).setToast(this);
		}
		createMainTable();
	}
	protected void createMainTable () {
		mainTable = new VisTable();
		mainTable.setBackground(style.background);
		VisImageButton closeButton = new VisImageButton(style.closeButtonStyle);
		closeButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				close();
			}
		});
		mainTable.add(contentTable).pad(3).fill().expand();
		mainTable.add(closeButton).top();
	}
	/** Called when close button was pressed by default call {@link #fadeOut()} */
	protected void close () {
		fadeOut();
	}
	public void fadeOut () {
		mainTable.addAction(Actions.sequence(Actions.fadeOut(VisWindow.FADE_TIME, Interpolation.fade), new Action() {
			@Override
			public boolean act (float delta) {
				toastManager.remove(Toast.this);
				return true;
			}
		}));
	}
	public Table fadeIn () {
		mainTable.setColor(1, 1, 1, 0);
		mainTable.addAction(Actions.fadeIn(VisWindow.FADE_TIME, Interpolation.fade));
		return mainTable;
	}
	public Table getContentTable () {
		return contentTable;
	}
	public Table getMainTable () {
		return mainTable;
	}
	public void setToastManager (ToastManager toastManager) {
		this.toastManager = toastManager;
	}
	public ToastManager getToastManager () {
		return toastManager;
	}
	public static class ToastStyle {
		public Drawable background;
		public VisImageButtonStyle closeButtonStyle;
		public ToastStyle () {
		}
		public ToastStyle (ToastStyle style) {
			this.background = style.background;
			this.closeButtonStyle = style.closeButtonStyle;
		}
		public ToastStyle (Drawable background, VisImageButtonStyle closeButtonStyle) {
			this.background = background;
			this.closeButtonStyle = closeButtonStyle;
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.ui.Button;
import com.badlogic.gdx.scenes.scene2d.ui.Cell;
import com.badlogic.gdx.scenes.scene2d.ui.Image;
import com.badlogic.gdx.scenes.scene2d.ui.ImageButton;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.utils.Scaling;
import com.kotcrab.vis.ui.FocusManager;
import com.kotcrab.vis.ui.Focusable;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.util.BorderOwner;
/**
 * Due to scope of changes made this widget is not compatible with standard {@link ImageButton}.
 * <p>
 * When listening for button press {@link ChangeListener} should be always preferred (instead of {@link ClickListener}).
 * {@link ClickListener} does not support disabling button and will still report button presses.
 * @author Kotcrab
 * @see ImageButton
 */
public class VisImageButton extends Button implements Focusable, BorderOwner {
	private Image image;
	private VisImageButtonStyle style;
	private boolean drawBorder;
	private boolean focusBorderEnabled = true;
	private boolean generateDisabledImage = false;
	public VisImageButton (Drawable imageUp) {
		this(imageUp, null, null);
	}
	public VisImageButton (Drawable imageUp, String tooltipText) {
		this(imageUp, null, null);
		if (tooltipText != null) new Tooltip.Builder(tooltipText).target(this).build();
	}
	public VisImageButton (Drawable imageUp, Drawable imageDown) {
		this(imageUp, imageDown, null);
	}
	public VisImageButton (Drawable imageUp, Drawable imageDown, Drawable imageChecked) {
		this(imageUp, imageDown, imageChecked, "default");
	}
	public VisImageButton (Drawable imageUp, Drawable imageDown, Drawable imageChecked, String styleName) {
		super(new VisImageButtonStyle(VisUI.getSkin().get(styleName, VisImageButtonStyle.class)));
		style.imageUp = imageUp;
		style.imageDown = imageDown;
		style.imageChecked = imageChecked;
		init();
	}
	public VisImageButton (String styleName) {
		super(new VisImageButtonStyle(VisUI.getSkin().get(styleName, VisImageButtonStyle.class)));
		init();
	}
	public VisImageButton (VisImageButtonStyle style) {
		super(style);
		init();
	}
	private void init () {
		image = new Image();
		image.setScaling(Scaling.fit);
		add(image);
		setSize(getPrefWidth(), getPrefHeight());
		addListener(new InputListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				if (isDisabled() == false) FocusManager.switchFocus(getStage(), VisImageButton.this);
				return false;
			}
		});
		updateImage();
	}
	@Override
	public VisImageButtonStyle getStyle () {
		return style;
	}
	@Override
	public void setStyle (ButtonStyle style) {
		if (!(style instanceof VisImageButtonStyle))
			throw new IllegalArgumentException("style must be an ImageButtonStyle.");
		super.setStyle(style);
		this.style = (VisImageButtonStyle) style;
		if (image != null) updateImage();
	}
	private void updateImage () {
		Drawable drawable = null;
		if (isDisabled() && style.imageDisabled != null)
			drawable = style.imageDisabled;
		else if (isPressed() && style.imageDown != null)
			drawable = style.imageDown;
		else if (isChecked() && style.imageChecked != null)
			drawable = (style.imageCheckedOver != null && isOver()) ? style.imageCheckedOver : style.imageChecked;
		else if (isOver() && style.imageOver != null)
			drawable = style.imageOver;
		else if (style.imageUp != null)
			drawable = style.imageUp;
		image.setDrawable(drawable);
		if (generateDisabledImage && style.imageDisabled == null) {
			if (isDisabled()) {
				image.setColor(Color.GRAY);
			} else {
				image.setColor(Color.WHITE);
			}
		}
	}
	@Override
	public void draw (Batch batch, float parentAlpha) {
		updateImage();
		super.draw(batch, parentAlpha);
		if (focusBorderEnabled && drawBorder && style.focusBorder != null)
			style.focusBorder.draw(batch, getX(), getY(), getWidth(), getHeight());
	}
	public Image getImage () {
		return image;
	}
	public Cell<?> getImageCell () {
		return getCell(image);
	}
	@Override
	public void setDisabled (boolean disabled) {
		super.setDisabled(disabled);
		if (disabled) FocusManager.resetFocus(getStage(), this);
	}
	@Override
	public void focusLost () {
		drawBorder = false;
	}
	@Override
	public void focusGained () {
		drawBorder = true;
	}
	@Override
	public boolean isFocusBorderEnabled () {
		return focusBorderEnabled;
	}
	@Override
	public void setFocusBorderEnabled (boolean focusBorderEnabled) {
		this.focusBorderEnabled = focusBorderEnabled;
	}
	public boolean isGenerateDisabledImage () {
		return generateDisabledImage;
	}
	/**
	 * @param generate when set to true and button state is set to disabled then button image will be tinted with gray
	 * color to better symbolize that button is disabled. This works best for white images.
	 */
	public void setGenerateDisabledImage (boolean generate) {
		generateDisabledImage = generate;
	}
	/**
	 * The style for an image button, see {@link ImageButton}.
	 * @author Nathan Sweet
	 */
	static public class VisImageButtonStyle extends ButtonStyle {
		/** Optional. */
		public Drawable imageUp, imageDown, imageOver, imageChecked, imageCheckedOver, imageDisabled;
		public Drawable focusBorder;
		public VisImageButtonStyle () {
		}
		public VisImageButtonStyle (Drawable up, Drawable down, Drawable checked, Drawable imageUp, Drawable imageDown,
									Drawable imageChecked) {
			super(up, down, checked);
			this.imageUp = imageUp;
			this.imageDown = imageDown;
			this.imageChecked = imageChecked;
		}
		public VisImageButtonStyle (VisImageButtonStyle style) {
			super(style);
			this.imageUp = style.imageUp;
			this.imageDown = style.imageDown;
			this.imageOver = style.imageOver;
			this.imageChecked = style.imageChecked;
			this.imageCheckedOver = style.imageCheckedOver;
			this.imageDisabled = style.imageDisabled;
			this.focusBorder = style.focusBorder;
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.spinner;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.ui.Cell;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.Disableable;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.FocusListener;
import com.badlogic.gdx.utils.Pools;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.Timer.Task;
import com.kotcrab.vis.ui.Sizes;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.widget.*;
/**
 * Spinner can be used to select number or object using up and down buttons or by entering value into text field.
 * Supports custom models that allows selecting either int, floats or even custom objects.
 * <p>
 * Fires {@link ChangeListener.ChangeEvent} when value has changed however unlike some other widgets canceling the event
 * won't undo value change.
 * @author Kotcrab
 * @see SimpleFloatSpinnerModel
 * @see FloatSpinnerModel
 * @see IntSpinnerModel
 * @see ArraySpinnerModel
 * @since 1.0.2
 */
public class Spinner extends VisTable implements Disableable {
	private final Sizes sizes;
	private SpinnerModel model;
	//task is shared between two buttons
	private ButtonRepeatTask buttonRepeatTask = new ButtonRepeatTask();
	private VisImageButton upButton;
	private VisImageButton downButton;
	private Cell<VisValidatableTextField> textFieldCell;
	private Cell<VisLabel> labelCell;
	private TextFieldEventPolicy textFieldEventPolicy = TextFieldEventPolicy.ON_FOCUS_LOST;
	private boolean programmaticChangeEvents = true;
	private boolean disabled;
	public Spinner (String name, SpinnerModel model) {
		this("default", name, model);
	}
	public Spinner (String styleName, String name, SpinnerModel model) {
		this(VisUI.getSkin().get(styleName, SpinnerStyle.class), VisUI.getSizes(), name, model);
	}
	public Spinner (SpinnerStyle style, Sizes sizes, String name, SpinnerModel model) {
		this.sizes = sizes;
		this.model = model;
		VisTable buttonsTable = new VisTable();
		VisValidatableTextField textField = createTextField();
		upButton = new VisImageButton(style.up);
		downButton = new VisImageButton(style.down);
		buttonsTable.add(upButton).height(sizes.spinnerButtonHeight).row();
		buttonsTable.add(downButton).height(sizes.spinnerButtonHeight);
		labelCell = add(new VisLabel(""));
		setSelectorName(name);
		textFieldCell = add(textField).height(sizes.spinnerButtonHeight * 2).growX();
		add(buttonsTable);
		addButtonsListeners(upButton, downButton);
		model.bind(this);
	}
	private VisValidatableTextField createTextField () {
		VisValidatableTextField textField = new VisValidatableTextField() {
			@Override
			public float getPrefWidth () {
				return sizes.spinnerFieldSize;
			}
		};
		textField.setRestoreLastValid(true);
		textField.setProgrammaticChangeEvents(false);
		addTextFieldListeners(textField);
		return textField;
	}
	public void setModel (SpinnerModel model) {
		this.model = model;
		textFieldCell.setActor(createTextField());
		model.bind(this);
	}
	private void addButtonsListeners (VisImageButton upButton, VisImageButton downButton) {
		upButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				event.stop();
				getStage().setScrollFocus(getTextField());
				increment(true);
			}
		});
		downButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				event.stop();
				getStage().setScrollFocus(getTextField());
				decrement(true);
			}
		});
		upButton.addListener(new ButtonInputListener(true));
		downButton.addListener(new ButtonInputListener(false));
	}
	private void addTextFieldListeners (final VisTextField textField) {
		textField.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				event.stop();
				model.textChanged();
				if (textField.isInputValid() && textFieldEventPolicy == TextFieldEventPolicy.ON_KEY_TYPED) {
					notifyValueChanged(true);
				}
			}
		});
		textField.addListener(new FocusListener() {
			@Override
			public void keyboardFocusChanged (FocusEvent event, Actor actor, boolean focused) {
				if (focused == false) {
					getStage().setScrollFocus(null);
					if (textFieldEventPolicy == TextFieldEventPolicy.ON_FOCUS_LOST) {
						notifyValueChanged(true);
					}
				}
			}
		});
		textField.addListener(new InputListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				getStage().setScrollFocus(getTextField());
				return true;
			}
			@Override
			public boolean scrolled (InputEvent event, float x, float y, float amountX, float amountY) {
				if (disabled) {
					return false;
				}
				if (amountY >= 1) {
					decrement(true);
				} else if (amountY <= -1) {
					increment(true);
				}
				return true;
			}
			@Override
			public boolean keyDown (InputEvent event, int keycode) {
				if (keycode == Keys.ENTER) {
					notifyValueChanged(true);
					return true;
				}
				return false;
			}
		});
	}
	@Override
	public void setDisabled (boolean disabled) {
		this.disabled = disabled;
		upButton.setDisabled(disabled);
		downButton.setDisabled(disabled);
		getTextField().setDisabled(disabled);
	}
	@Override
	public boolean isDisabled () {
		return disabled;
	}
	public void setSelectorName (String name) {
		labelCell.getActor().setText(name);
		if (name == null || name.length() == 0) {
			labelCell.padRight(0);
		} else {
			labelCell.padRight(6);
		}
	}
	public String getSelectorName () {
		return labelCell.getActor().getText().toString();
	}
	public void increment () {
		model.increment(programmaticChangeEvents);
	}
	private void increment (boolean fireEvent) {
		model.increment(fireEvent);
	}
	public void decrement () {
		model.decrement(programmaticChangeEvents);
	}
	private void decrement (boolean fireEvent) {
		model.decrement(fireEvent);
	}
	/** If false, methods changing spinner value form code won't trigger change event, it will be fired only when user has changed value. */
	public void setProgrammaticChangeEvents (boolean programmaticChangeEvents) {
		this.programmaticChangeEvents = programmaticChangeEvents;
	}
	public boolean isProgrammaticChangeEvents () {
		return programmaticChangeEvents;
	}
	public void setTextFieldEventPolicy (TextFieldEventPolicy textFieldEventPolicy) {
		this.textFieldEventPolicy = textFieldEventPolicy;
	}
	public TextFieldEventPolicy getTextFieldEventPolicy () {
		return textFieldEventPolicy;
	}
	public int getMaxLength () {
		return getTextField().getMaxLength();
	}
	public void setMaxLength (int maxLength) {
		getTextField().setMaxLength(maxLength);
	}
	public SpinnerModel getModel () {
		return model;
	}
	/**
	 * Called by {@link SpinnerModel}. Notifies when underlying model value has changed and spinner text field must updated.
	 * Typically there is no need to call this method manually.
	 * @param fireEvent if true then {@link ChangeListener.ChangeEvent} will be fired
	 */
	public void notifyValueChanged (boolean fireEvent) {
		VisValidatableTextField textField = getTextField();
		int cursor = textField.getCursorPosition();
		textField.setCursorPosition(0);
		textField.setText(model.getText());
		textField.setCursorPosition(cursor);
		if (fireEvent) {
			ChangeListener.ChangeEvent changeEvent = Pools.obtain(ChangeListener.ChangeEvent.class);
			fire(changeEvent);
			Pools.free(changeEvent);
		}
	}
	public VisValidatableTextField getTextField () {
		return textFieldCell.getActor();
	}
	public static class SpinnerStyle {
		public Drawable up;
		public Drawable down;
		public SpinnerStyle () {
		}
		public SpinnerStyle (SpinnerStyle style) {
			this.up = style.up;
			this.down = style.down;
		}
		public SpinnerStyle (Drawable up, Drawable down) {
			this.up = up;
			this.down = down;
		}
	}
	private class ButtonRepeatTask extends Task {
		boolean advance;
		@Override
		public void run () {
			if (advance) {
				increment(true);
			} else {
				decrement(true);
			}
		}
	}
	/**
	 * Allows to configure how {@link Spinner} will fire {@link ChangeListener.ChangeEvent} after user interaction with
	 * Spinner text field.
	 * @since 1.1.6
	 */
	public enum TextFieldEventPolicy {
		/**
		 * Spinner change event will be only fired after user has pressed enter in text field. This mode is the default
		 * one prior to VisUI 1.1.6
		 */
		ON_ENTER_ONLY,
		/**
		 * Spinner change event will be always fired after text field has lost focus and entered value is valid. Note
		 * that event will be fired even if user has not changed actual value of spinner. Event won't be fired
		 * if current model determined that entered value is invalid. This mode is the default one.
		 */
		ON_FOCUS_LOST,
		/**
		 * Spinner change event will be fired right after user has typed something in the text field and model has
		 * determined that entered value is valid. Event won't be fired if entered value is invalid.
		 */
		ON_KEY_TYPED
	}
	private class ButtonInputListener extends InputListener {
		private float buttonRepeatInitialTime = 0.4f;
		private float buttonRepeatTime = 0.08f;
		private boolean advance;
		public ButtonInputListener (boolean advance) {
			this.advance = advance;
		}
		@Override
		public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
			if (buttonRepeatTask.isScheduled() == false) {
				buttonRepeatTask.advance = advance;
				buttonRepeatTask.cancel();
				Timer.schedule(buttonRepeatTask, buttonRepeatInitialTime, buttonRepeatTime);
			}
			return true;
		}
		@Override
		public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
			buttonRepeatTask.cancel();
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Version;
import com.badlogic.gdx.assets.AssetManager;
import com.badlogic.gdx.files.FileHandle;
import com.badlogic.gdx.scenes.scene2d.ui.Skin;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.GdxRuntimeException;
/**
 * Allows to easily load VisUI skin and change default title alignment and I18N bundles.
 * Contains static field with VisUI version.
 * @author Kotcrab
 */
public class VisUI {
	private static final String TARGET_GDX_VERSION = "1.13.1";
	private static boolean skipGdxVersionCheck = false;
	private static int defaultTitleAlign = Align.left;
	private static SkinScale scale;
	private static Skin skin;
	/** Defines possible built-in skin scales. */
	public enum SkinScale {
		/** Standard VisUI skin */
		X1("com/kotcrab/vis/ui/skin/x1/uiskin.json", "default"),
		/** VisUI skin 2x upscaled */
		X2("com/kotcrab/vis/ui/skin/x2/uiskin.json", "x2");
		private final String classpath;
		private final String sizesName;
		SkinScale (String classpath, String sizesName) {
			this.classpath = classpath;
			this.sizesName = sizesName;
		}
		public FileHandle getSkinFile () {
			return Gdx.files.classpath(classpath);
		}
		public String getSizesName () {
			return sizesName;
		}
	}
	/** Loads default VisUI skin with {@link SkinScale#X1}. */
	public static void load () {
		load(SkinScale.X1);
	}
	/** Loads default VisUI skin for given {@link SkinScale}. */
	public static void load (SkinScale scale) {
		VisUI.scale = scale;
		load(scale.getSkinFile());
	}
	/** Loads skin from provided internal file path. Skin must be compatible with default VisUI skin. */
	public static void load (String internalVisSkinPath) {
		load(Gdx.files.internal(internalVisSkinPath));
	}
	/** Loads skin from provided file. Skin must be compatible with default VisUI skin. */
	public static void load (FileHandle visSkinFile) {
		checkBeforeLoad();
		VisUI.skin = new Skin(visSkinFile);
	}
	/**
	 * Sets provided skin as default for every VisUI widget. Skin must be compatible with default VisUI skin. This
	 * can be used if you prefer to load skin manually for example by using {@link AssetManager}.
	 */
	public static void load (Skin skin) {
		checkBeforeLoad();
		VisUI.skin = skin;
	}
	private static void checkBeforeLoad () {
		if (skin != null) throw new GdxRuntimeException("VisUI cannot be loaded twice");
		if (!skipGdxVersionCheck && !Version.VERSION.equals(TARGET_GDX_VERSION)) {
			Gdx.app.log("VisUI", "Warning, using invalid libGDX version.\n" +
					"You are using libGDX " + Version.VERSION + " but you need " + TARGET_GDX_VERSION + ". This may cause " +
					"unexpected problems and runtime exceptions.");
		}
	}
	/** Unloads VisUI. */
	public static void dispose () {
		dispose(true);
	}
	/**
	 * Unloads VisUI.
	 * @param disposeSkin if true then internal skin instance will be disposed
	 */
	public static void dispose (boolean disposeSkin) {
		if (skin != null) {
			if (disposeSkin) skin.dispose();
			skin = null;
		}
	}
	public static Skin getSkin () {
		if (skin == null) throw new IllegalStateException("VisUI is not loaded!");
		return skin;
	}
	public static boolean isLoaded () {
		return skin != null;
	}
	public static Sizes getSizes () {
		if (scale == null)
			return getSkin().get(Sizes.class);
		else
			return getSkin().get(scale.getSizesName(), Sizes.class);
	}
	/** @return int value from {@link Align} */
	public static int getDefaultTitleAlign () {
		return defaultTitleAlign;
	}
	/**
	 * Sets default title align user for VisWindow and VisDialog
	 * @param defaultTitleAlign int value from {@link Align}
	 */
	public static void setDefaultTitleAlign (int defaultTitleAlign) {
		VisUI.defaultTitleAlign = defaultTitleAlign;
	}
	/**
	 * @param setSkipGdxVersionCheck if true VisUI won't check if provided libGDX version is compatible for current version of VisUI.
	 * If false, before loading VisUI, a libGDX version check will be performed, in case of version mismatch warning
	 * will be printed to console
	 * @see <a href="https://github.com/kotcrab/vis-ui#libgdx-compatibility">Version compatiblity table (online)</a>
	 */
	public static void setSkipGdxVersionCheck (boolean setSkipGdxVersionCheck) {
		VisUI.skipGdxVersionCheck = setSkipGdxVersionCheck;
	}

}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.scenes.scene2d.*;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.Label;
import com.badlogic.gdx.scenes.scene2d.ui.Table;
import com.badlogic.gdx.scenes.scene2d.ui.Window;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.ClickListener;
import com.badlogic.gdx.utils.Align;
import com.kotcrab.vis.ui.FocusManager;
import com.kotcrab.vis.ui.VisUI;
/**
 * Extends functionality of standard scene2d.ui {@link Window}.
 * @author Kotcrab
 * @see Window
 */
public class VisWindow extends Window {
	public static float FADE_TIME = 0.3f;
	private boolean centerOnAdd;
	private boolean keepWithinParent = false;
	private boolean fadeOutActionRunning;
	public VisWindow (String title) {
		this(title, true);
		getTitleLabel().setAlignment(VisUI.getDefaultTitleAlign());
	}
	public VisWindow (String title, boolean showWindowBorder) {
		super(title, VisUI.getSkin(), showWindowBorder ? "default" : "noborder");
		getTitleLabel().setAlignment(VisUI.getDefaultTitleAlign());
	}
	public VisWindow (String title, String styleName) {
		super(title, VisUI.getSkin(), styleName);
		getTitleLabel().setAlignment(VisUI.getDefaultTitleAlign());
	}
	public VisWindow (String title, WindowStyle style) {
		super(title, style);
		getTitleLabel().setAlignment(VisUI.getDefaultTitleAlign());
	}
	@Override
	public void setPosition (float x, float y) {
		super.setPosition((int) x, (int) y);
	}
	/**
	 * Centers this window, if it has parent it will be done instantly, if it does not have parent it will be centered when it will
	 * be added to stage
	 * @return true when window was centered, false when window will be centered when added to stage
	 */
	public boolean centerWindow () {
		Group parent = getParent();
		if (parent == null) {
			centerOnAdd = true;
			return false;
		} else {
			moveToCenter();
			return true;
		}
	}
	/**
	 * @param centerOnAdd if true window position will be centered on screen after adding to stage
	 * @see #centerWindow()
	 */
	public void setCenterOnAdd (boolean centerOnAdd) {
		this.centerOnAdd = centerOnAdd;
	}
	@Override
	protected void setStage (Stage stage) {
		super.setStage(stage);
		if (stage != null) {
			stage.setKeyboardFocus(this); //issue #10, newly created window does not acquire keyboard focus
			if (centerOnAdd) {
				centerOnAdd = false;
				moveToCenter();
			}
		}
	}
	private void moveToCenter () {
		Stage parent = getStage();
		if (parent != null) setPosition((parent.getWidth() - getWidth()) / 2, (parent.getHeight() - getHeight()) / 2);
	}
	/**
	 * Fade outs this window, when fade out animation is completed, window is removed from Stage. Calling this for the
	 * second time won't have any effect if previous animation is still running.
	 */
	public void fadeOut (float time) {
		if (fadeOutActionRunning) return;
		fadeOutActionRunning = true;
		final Touchable previousTouchable = getTouchable();
		setTouchable(Touchable.disabled);
		Stage stage = getStage();
		if (stage != null && stage.getKeyboardFocus() != null && stage.getKeyboardFocus().isDescendantOf(this)) {
			FocusManager.resetFocus(stage);
		}
		addAction(Actions.sequence(Actions.fadeOut(time, Interpolation.fade), new Action() {
			@Override
			public boolean act (float delta) {
				setTouchable(previousTouchable);
				remove();
				getColor().a = 1f;
				fadeOutActionRunning = false;
				return true;
			}
		}));
	}
	/** @return this window for the purpose of chaining methods eg. stage.addActor(new MyWindow(stage).fadeIn(0.3f)); */
	public VisWindow fadeIn (float time) {
		setColor(1, 1, 1, 0);
		addAction(Actions.fadeIn(time, Interpolation.fade));
		return this;
	}
	/** Fade outs this window, when fade out animation is completed, window is removed from Stage */
	public void fadeOut () {
		fadeOut(FADE_TIME);
	}
	/** @return this window for the purpose of chaining methods eg. stage.addActor(new MyWindow(stage).fadeIn()); */
	public VisWindow fadeIn () {
		return fadeIn(FADE_TIME);
	}
	/**
	 * Called by window when close button was pressed (added using {@link #addCloseButton()})
	 * or escape key was pressed (for close on escape {@link #closeOnEscape()} have to be called).
	 * Default close behaviour is to fade out window, this can be changed by overriding this function.
	 */
	protected void close () {
		fadeOut();
	}
	/**
	 * Adds close button to window, next to window title. After pressing that button, {@link #close()} is called. If nothing
	 * else was added to title table, and current title alignment is center then the title will be automatically centered.
	 */
	public void addCloseButton () {
		Label titleLabel = getTitleLabel();
		Table titleTable = getTitleTable();
		VisImageButton closeButton = new VisImageButton("close-window");
		titleTable.add(closeButton).padRight(-getPadRight() + 0.7f);
		closeButton.addListener(new ChangeListener() {
			@Override
			public void changed (ChangeEvent event, Actor actor) {
				close();
			}
		});
		closeButton.addListener(new ClickListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				event.cancel();
				return true;
			}
		});
		if (titleLabel.getLabelAlign() == Align.center && titleTable.getChildren().size == 2)
			titleTable.getCell(titleLabel).padLeft(closeButton.getWidth() * 2);
	}
	/**
	 * Will make this window close when escape key or back key was pressed. After pressing escape or back, {@link #close()} is called.
	 * Back key is Android and iOS only
	 */
	public void closeOnEscape () {
		addListener(new InputListener() {
			@Override
			public boolean keyDown (InputEvent event, int keycode) {
				if (keycode == Keys.ESCAPE) {
					close();
					return true;
				}
				return false;
			}
			@Override
			public boolean keyUp (InputEvent event, int keycode) {
				if (keycode == Keys.BACK) {
					close();
					return true;
				}
				return false;
			}
		});
	}
	public boolean isKeepWithinParent () {
		return keepWithinParent;
	}
	public void setKeepWithinParent (boolean keepWithinParent) {
		this.keepWithinParent = keepWithinParent;
	}
	@Override
	public void draw (Batch batch, float parentAlpha) {
		if (keepWithinParent && getParent() != null) {
			float parentWidth = getParent().getWidth();
			float parentHeight = getParent().getHeight();
			if (getX() < 0) setX(0);
			if (getRight() > parentWidth) setX(parentWidth - getWidth());
			if (getY() < 0) setY(0);
			if (getTop() > parentHeight) setY(parentHeight - getHeight());
		}
		super.draw(batch, parentAlpha);
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.Stage;
/**
 * Manages focus of VisUI components. This is different from stage2d.ui focus management. In scene2d widgets can only
 * acquire keyboard and scroll focus. VisUI focus managers allows any widget to acquire general user focus, this is used
 * mainly to manage rendering focus borders around widgets. Generally there is no need to call those method manually.
 * @author Kotcrab
 * @see Focusable
 */
public class FocusManager {
	private static Focusable focusedWidget;
	/**
	 * Takes focus from current focused widget (if any), and sets focus to provided widget
	 * @param stage if passed stage is not null then stage keyboard focus will be set to null
	 * @param widget that will acquire focus
	 */
	public static void switchFocus (Stage stage, Focusable widget) {
		if (focusedWidget == widget) return;
		if (focusedWidget != null) focusedWidget.focusLost();
		focusedWidget = null;
		if (stage != null) stage.setKeyboardFocus(null);
		focusedWidget = widget;
		focusedWidget.focusGained();
	}
	/**
	 * Takes focus from current focused widget (if any), and sets current focused widget to null. If widgets owns
	 * keyboard focus {@link #resetFocus(Stage, Actor)} should be always preferred.
	 * @param stage if passed stage is not null then stage keyboard focus will be set to null
	 */
	public static void resetFocus (Stage stage) {
		if (focusedWidget != null) focusedWidget.focusLost();
		if (stage != null) stage.setKeyboardFocus(null);
		focusedWidget = null;
	}
	/**
	 * Takes focus from current focused widget (if any), and sets current focused widget to null
	 * @param stage if passed stage is not null then stage keyboard focus will be set to null only if current
	 * focus owner is passed actor
	 */
	public static void resetFocus (Stage stage, Actor caller) {
		if (focusedWidget != null) focusedWidget.focusLost();
		if (stage != null && stage.getKeyboardFocus() == caller) stage.setKeyboardFocus(null);
		focusedWidget = null;
	}
	public static Focusable getFocusedWidget () {
		return focusedWidget;
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget.tabbedpane;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Buttons;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.Touchable;
import com.badlogic.gdx.scenes.scene2d.ui.Button;
import com.badlogic.gdx.scenes.scene2d.ui.ButtonGroup;
import com.badlogic.gdx.scenes.scene2d.ui.Cell;
import com.badlogic.gdx.scenes.scene2d.ui.Image;
import com.badlogic.gdx.scenes.scene2d.utils.ChangeListener;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.scenes.scene2d.utils.UIUtils;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.I18NBundle;
import com.badlogic.gdx.utils.IdentityMap;
import com.badlogic.gdx.utils.ObjectMap.Entry;
import com.badlogic.gdx.utils.Scaling;
import com.kotcrab.vis.ui.Locales;
import com.kotcrab.vis.ui.Sizes;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.i18n.BundleText;
import com.kotcrab.vis.ui.layout.DragPane;
import com.kotcrab.vis.ui.layout.HorizontalFlowGroup;
import com.kotcrab.vis.ui.layout.VerticalFlowGroup;
import com.kotcrab.vis.ui.util.dialog.Dialogs;
import com.kotcrab.vis.ui.util.dialog.Dialogs.OptionDialogType;
import com.kotcrab.vis.ui.util.dialog.OptionDialogAdapter;
import com.kotcrab.vis.ui.widget.Draggable;
import com.kotcrab.vis.ui.widget.VisImageButton;
import com.kotcrab.vis.ui.widget.VisImageButton.VisImageButtonStyle;
import com.kotcrab.vis.ui.widget.VisTable;
import com.kotcrab.vis.ui.widget.VisTextButton;
import com.kotcrab.vis.ui.widget.VisTextButton.VisTextButtonStyle;
/**
 * A tabbed pane, allows to have multiple tabs open and switch between them. TabbedPane does not handle displaying tab content,
 * you have to do that manually using tabbed pane listener to get tab content table (see {@link Tab#getContentTable()} and
 * {@link TabbedPaneListener}). All tabs must extend {@link Tab} class.
 * <p>
 * Since 0.9.3, tabbed pane uses an internal {@link DragPane} to make the tabs draggable. You can completely turn off this
 * functionality by setting {@link TabbedPaneStyle#draggable} to false. To turn off the drag listener at runtime, use
 * {@link #getTabsPane()} method to get a reference of {@link DragPane}, and invoke {@link DragPane#setDraggable(Draggable)} with
 * null argument - this will clear draggable listener from all tabs' buttons; naturally, setting this value to non-null
 * {@link Draggable} listener will also add it to all buttons.
 * @author Kotcrab
 * @author MJ
 * @since 0.7.0
 */
public class TabbedPane {
	private static final Vector2 tmpVector = new Vector2();
	private static final Rectangle tmpRect = new Rectangle();
	private TabbedPaneStyle style;
	private Sizes sizes;
	private VisImageButtonStyle sharedCloseActiveButtonStyle;
	private DragPane tabsPane;
	private TabbedPaneTable mainTable;
	private Array<Tab> tabs;
	private IdentityMap<Tab, TabButtonTable> tabsButtonMap;
	private ButtonGroup<Button> group;
	private Tab activeTab;
	private Array<TabbedPaneListener> listeners;
	private boolean allowTabDeselect;
	public TabbedPane () {
		this(VisUI.getSkin().get(TabbedPaneStyle.class));
	}
	public TabbedPane (String styleName) {
		this(VisUI.getSkin().get(styleName, TabbedPaneStyle.class));
	}
	public TabbedPane (TabbedPaneStyle style) {
		this(style, VisUI.getSizes());
	}
	public TabbedPane (TabbedPaneStyle style, Sizes sizes) {
		this.style = style;
		this.sizes = sizes;
		listeners = new Array<TabbedPaneListener>();
		sharedCloseActiveButtonStyle = VisUI.getSkin().get("close-active-tab", VisImageButtonStyle.class);
		group = new ButtonGroup<Button>();
		mainTable = new TabbedPaneTable(this);
		tabsPane = new DragPane(style.vertical ? new VerticalFlowGroup() : new HorizontalFlowGroup());
		configureDragPane(style);
		mainTable.setBackground(style.background);
		tabs = new Array<Tab>();
		tabsButtonMap = new IdentityMap<Tab, TabButtonTable>();
		Cell<DragPane> tabsPaneCell = mainTable.add(tabsPane);
		Cell<Image> separatorCell = null;
		if (style.vertical) {
			tabsPaneCell.top().growY().minSize(0, 0);
		} else {
			tabsPaneCell.left().growX().minSize(0, 0);
		}
		//note: if separatorBar height/width is not set explicitly it may sometimes disappear
		if (style.separatorBar != null) {
			if (style.vertical) {
				separatorCell = mainTable.add(new Image(style.separatorBar)).growY().width(style.separatorBar.getMinWidth());
			} else {
				mainTable.row();
				separatorCell = mainTable.add(new Image(style.separatorBar)).growX().height(style.separatorBar.getMinHeight());
			}
		} else {
			//make sure that tab will fill available space even when there is no separatorBar image set
			if (style.vertical) {
				mainTable.add().growY();
			} else {
				mainTable.add().growX();
			}
		}
		mainTable.setPaneCells(tabsPaneCell, separatorCell);
	}
	private void configureDragPane (TabbedPaneStyle style) {
		tabsPane.setTouchable(Touchable.childrenOnly);
		tabsPane.setListener(new DragPane.DragPaneListener.AcceptOwnChildren());
		if (style.draggable) {
			Draggable draggable = new Draggable();
			draggable.setInvisibleWhenDragged(true);
			draggable.setKeepWithinParent(true);
			draggable.setBlockInput(true);
			draggable.setFadingTime(0f);
			draggable.setListener(new DragPane.DefaultDragListener() {
				public boolean dragged;
				@Override
				public boolean onStart (Draggable draggable, Actor actor, float stageX, float stageY) {
					dragged = false;
					if (actor instanceof TabButtonTable) {
						if (((TabButtonTable) actor).closeButton.isOver()) return CANCEL;
					}
					return super.onStart(draggable, actor, stageX, stageY);
				}
				@Override
				public void onDrag (Draggable draggable, Actor actor, float stageX, float stageY) {
					super.onDrag(draggable, actor, stageX, stageY);
					dragged = true;
				}
				@Override
				public boolean onEnd (Draggable draggable, Actor actor, float stageX, float stageY) {
					boolean result = super.onEnd(draggable, actor, stageX, stageY);
					if (result == APPROVE) return APPROVE;
					if (dragged == false) return CANCEL;
					// check if any actor corner is over some other tab
					tabsPane.stageToLocalCoordinates(tmpVector.set(stageX, stageY));
					if (tabsPane.hit(tmpVector.x, tmpVector.y, true) != null) return CANCEL;
					if (tabsPane.hit(tmpVector.x + actor.getWidth(), tmpVector.y, true) != null) return CANCEL;
					if (tabsPane.hit(tmpVector.x, tmpVector.y - actor.getHeight(), true) != null) return CANCEL;
					if (tabsPane.hit(tmpVector.x + actor.getWidth(), tmpVector.y - actor.getHeight(), true) != null)
						return CANCEL;
					Vector2 stagePos = tabsPane.localToStageCoordinates(tmpVector.setZero());
					tmpRect.set(stagePos.x, stagePos.y, tabsPane.getGroup().getWidth(), tabsPane.getGroup().getHeight());
					if (tmpRect.contains(stageX, stageY) == false) return CANCEL;
					if (tabsPane.isHorizontalFlow() || tabsPane.isVerticalFlow()) {
						DRAG_POSITION.set(stageX, stageY);
						tabsPane.addActor(actor);
						return APPROVE;
					}
					return CANCEL;
				}
			});
			tabsPane.setDraggable(draggable);
		}
	}
	/** @return a direct reference to internal {@link DragPane}. Allows to manage {@link Draggable} settings. */
	public DragPane getTabsPane () {
		return tabsPane;
	}
	/**
	 * @param allowTabDeselect if true user may deselect tab, meaning that there won't be any active tab. Allows to create similar
	 * behaviour like in Intellij IDEA bottom quick access bar
	 */
	public void setAllowTabDeselect (boolean allowTabDeselect) {
		this.allowTabDeselect = allowTabDeselect;
		if (allowTabDeselect) {
			group.setMinCheckCount(0);
		} else {
			group.setMinCheckCount(1);
		}
	}
	public boolean isAllowTabDeselect () {
		return allowTabDeselect;
	}
	public void add (Tab tab) {
		tab.setPane(this);
		tabs.add(tab);
		addTab(tab, tabsPane.getChildren().size);
		switchTab(tab);
	}
	public void insert (int index, Tab tab) {
		tab.setPane(this);
		tabs.insert(index, tab);
		addTab(tab, index);
	}
	/**
	 * @param tab will be added in the selected index.
	 * @param index index of the tab, starting from zero.
	 */
	protected void addTab (Tab tab, int index) {
		TabButtonTable buttonTable = tabsButtonMap.get(tab);
		if (buttonTable == null) {
			buttonTable = new TabButtonTable(tab);
			tabsButtonMap.put(tab, buttonTable);
		}
		buttonTable.setTouchable(Touchable.enabled);
		if (index >= tabsPane.getChildren().size) {
			tabsPane.addActor(buttonTable);
		} else {
			tabsPane.addActorAt(index, buttonTable);
		}
		group.add(buttonTable.button);
		if (tabs.size == 1 && activeTab != null) {
			buttonTable.select();
			notifyListenersSwitched(tab);
		} else if (tab == activeTab) {
			buttonTable.select(); // maintains currently selected tab while rebuilding
		}
	}
	/**
	 * Disables or enables given tab.
	 * <p>
	 * When disabling, if tab is currently selected, TabbedPane will switch to first available enabled Tab. If there is no any
	 * other enabled Tab, listener {@link TabbedPaneListener#switchedTab(Tab)} with null Tab will be called.
	 * <p>
	 * When enabling Tab and there isn't any others Tab enabled and {@link #setAllowTabDeselect(boolean)} was set to false, passed
	 * Tab will be selected. If {@link #setAllowTabDeselect(boolean)} is set to true nothing will be selected, all tabs will remain
	 * unselected.
	 * @param tab tab to change its state
	 * @param disable controls whether to disable or enable this tab
	 * @throws IllegalArgumentException if tab does not belong to this TabbedPane
	 */
	public void disableTab (Tab tab, boolean disable) {
		checkIfTabsBelongsToThisPane(tab);
		TabButtonTable buttonTable = tabsButtonMap.get(tab);
		buttonTable.button.setDisabled(disable);
		if (activeTab == tab && disable) {
			if (selectFirstEnabledTab()) {
				return;
			}
			// there isn't any tab we can switch to
			activeTab = null;
			notifyListenersSwitched(null);
		}
		if (activeTab == null && allowTabDeselect == false) {
			selectFirstEnabledTab();
		}
	}
	public boolean isTabDisabled (Tab tab) {
		TabButtonTable table = tabsButtonMap.get(tab);
		if (table == null) {
			throwNotBelongingTabException(tab);
		}
		return table.button.isDisabled();
	}
	private boolean selectFirstEnabledTab () {
		for (Entry<Tab, TabButtonTable> entry : tabsButtonMap) {
			if (entry.value.button.isDisabled() == false) {
				switchTab(entry.key);
				return true;
			}
		}
		return false;
	}
	private void checkIfTabsBelongsToThisPane (Tab tab) {
		if (tabs.contains(tab, true) == false) {
			throwNotBelongingTabException(tab);
		}
	}
	protected void throwNotBelongingTabException (Tab tab) {
		throw new IllegalArgumentException("Tab '" + tab.getTabTitle() + "' does not belong to this TabbedPane");
	}
	/**
	 * Removes tab from pane, if tab is dirty this won't cause to display "Unsaved changes" dialog!
	 * @param tab to be removed
	 * @return true if tab was removed, false if that tab wasn't added to this pane
	 */
	public boolean remove (Tab tab) {
		return remove(tab, true);
	}
	/**
	 * Removes tab from pane, if tab is dirty and 'ignoreTabDirty == false' this will cause to display "Unsaved changes" dialog!
	 * @return true if tab was removed, false if that tab wasn't added to this pane or "Unsaved changes" dialog was started
	 */
	public boolean remove (final Tab tab, boolean ignoreTabDirty) {
		checkIfTabsBelongsToThisPane(tab);
		if (ignoreTabDirty) {
			return removeTab(tab);
		}
		if (tab.isDirty() && mainTable.getStage() != null) {
			Dialogs.showOptionDialog(mainTable.getStage(), Text.UNSAVED_DIALOG_TITLE.get(), Text.UNSAVED_DIALOG_TEXT.get(),
					OptionDialogType.YES_NO_CANCEL, new OptionDialogAdapter() {
						@Override
						public void yes () {
							tab.save();
							removeTab(tab);
						}
						@Override
						public void no () {
							removeTab(tab);
						}
					});
		} else {
			return removeTab(tab);
		}
		return false;
	}
	private boolean removeTab (Tab tab) {
		int index = tabs.indexOf(tab, true);
		boolean success = tabs.removeValue(tab, true);
		if (success) {
			TabButtonTable buttonTable = tabsButtonMap.get(tab);
			tabsPane.removeActor(buttonTable, true);
			tabsPane.invalidateHierarchy();
			tabsButtonMap.remove(tab);
			group.remove(buttonTable.button);
			tab.setPane(null);
			tab.onHide();
			tab.dispose();
			notifyListenersRemoved(tab);
			if (tabs.size == 0) {
				// all tabs were removed so notify listener
				activeTab = null;
				notifyListenersRemovedAll();
			} else if (activeTab == tab) {
				if (index > 0) {
					// switch to previous tab
					switchTab(--index);
				} else {
					// Switching to the next tab, currently having our removed tab index.
					switchTab(index);
				}
			}
		}
		return success;
	}
	/** Removes all tabs, ignores if tab is dirty */
	public void removeAll () {
		for (Tab tab : tabs) {
			tab.setPane(null);
			tab.onHide();
			tab.dispose();
		}
		tabs.clear();
		tabsButtonMap.clear();
		tabsPane.clear();
		activeTab = null;
		notifyListenersRemovedAll();
	}
	public void switchTab (int index) {
		tabsButtonMap.get(tabs.get(index)).select();
	}
	public void switchTab (Tab tab) {
		TabButtonTable table = tabsButtonMap.get(tab);
		if (table == null) {
			throwNotBelongingTabException(tab);
		}
		table.select();
	}
	/**
	 * Must be called when you want to update tab title. If tab is dirty an '*' is added before title. This is called automatically
	 * if using {@link Tab#setDirty(boolean)}
	 * @param tab that title will be updated
	 */
	public void updateTabTitle (Tab tab) {
		TabButtonTable table = tabsButtonMap.get(tab);
		if (table == null) {
			throwNotBelongingTabException(tab);
		}
		table.button.setText(getTabTitle(tab));
	}
	protected String getTabTitle (Tab tab) {
		return tab.isDirty() ? "*" + tab.getTabTitle() : tab.getTabTitle();
	}
	public TabbedPaneTable getTable () {
		return mainTable;
	}
	/** @return active tab or null if no tab is selected. */
	public Tab getActiveTab () {
		return activeTab;
	}
	public void addListener (TabbedPaneListener listener) {
		listeners.add(listener);
	}
	public boolean removeListener (TabbedPaneListener listener) {
		return listeners.removeValue(listener, true);
	}
	private void notifyListenersSwitched (Tab tab) {
		for (TabbedPaneListener listener : listeners) {
			listener.switchedTab(tab);
		}
	}
	private void notifyListenersRemoved (Tab tab) {
		for (TabbedPaneListener listener : listeners) {
			listener.removedTab(tab);
		}
	}
	private void notifyListenersRemovedAll () {
		for (TabbedPaneListener listener : listeners) {
			listener.removedAllTabs();
		}
	}
	/** Returns tabs in order in which they are stored in tabbed pane, sorted by their index and ignoring their order in UI. */
	public Array<Tab> getTabs () {
		return tabs;
	}
	/**
	 * Returns tabs in order in which they are displayed in the UI - user may drag and move tabs which DOES NOT affect
	 * their index. Use {@link #getTabs()} if you don't care about UI order. This creates new array every time it's called!
	 */
	public Array<Tab> getUIOrderedTabs () {
		Array<Tab> tabs = new Array<Tab>();
		for (Actor actor : getTabsPane().getChildren()) {
			if (actor instanceof TabButtonTable) {
				tabs.add(((TabButtonTable) actor).tab);
			}
		}
		return tabs;
	}
	public static class TabbedPaneStyle {
		public Drawable background;
		public VisTextButtonStyle buttonStyle;
		/** Optional. */
		public Drawable separatorBar;
		/** Optional, defaults to false. */
		public boolean vertical = false;
		/** Optional, defaults to true. */
		public boolean draggable = true;
		public TabbedPaneStyle () {
		}
		public TabbedPaneStyle (TabbedPaneStyle style) {
			this.background = style.background;
			this.buttonStyle = style.buttonStyle;
			this.separatorBar = style.separatorBar;
			this.vertical = style.vertical;
			this.draggable = style.draggable;
		}
		public TabbedPaneStyle (Drawable background, Drawable separatorBar, VisTextButtonStyle buttonStyle) {
			this.background = background;
			this.separatorBar = separatorBar;
			this.buttonStyle = buttonStyle;
		}
		public TabbedPaneStyle (Drawable separatorBar, Drawable background, VisTextButtonStyle buttonStyle, boolean vertical, boolean draggable) {
			this.separatorBar = separatorBar;
			this.background = background;
			this.buttonStyle = buttonStyle;
			this.vertical = vertical;
			this.draggable = draggable;
		}
	}
	public static class TabbedPaneTable extends VisTable {
		private TabbedPane tabbedPane;
		private Cell<DragPane> tabsPaneCell;
		private Cell<Image> separatorCell;
		public TabbedPaneTable (TabbedPane tabbedPane) {
			this.tabbedPane = tabbedPane;
		}
		private void setPaneCells (Cell<DragPane> tabsPaneCell, Cell<Image> separatorCell) {
			this.tabsPaneCell = tabsPaneCell;
			this.separatorCell = separatorCell;
		}
		public Cell<DragPane> getTabsPaneCell () {
			return tabsPaneCell;
		}
		/** @return separator cell or null if separator is not used */
		public Cell<Image> getSeparatorCell () {
			return separatorCell;
		}
		public TabbedPane getTabbedPane () {
			return tabbedPane;
		}
	}
	private class TabButtonTable extends VisTable {
		public VisTextButton button;
		public VisImageButton closeButton;
		private Tab tab;
		private VisTextButtonStyle buttonStyle;
		private VisImageButtonStyle closeButtonStyle;
		private Drawable up;
		public TabButtonTable (Tab tab) {
			this.tab = tab;
			button = new VisTextButton(getTabTitle(tab), style.buttonStyle) {
				@Override
				public void setDisabled (boolean isDisabled) {
					super.setDisabled(isDisabled);
					closeButton.setDisabled(isDisabled);
					deselect();
				}
			};
			button.setFocusBorderEnabled(false);
			button.setProgrammaticChangeEvents(false);
			closeButtonStyle = new VisImageButtonStyle(VisUI.getSkin().get("close", VisImageButtonStyle.class));
			closeButton = new VisImageButton(closeButtonStyle);
			closeButton.setGenerateDisabledImage(true);
			closeButton.getImage().setScaling(Scaling.fill);
			closeButton.getImage().setColor(Color.RED);
			addListeners();
			buttonStyle = new VisTextButtonStyle((VisTextButtonStyle) button.getStyle());
			button.setStyle(buttonStyle);
			closeButtonStyle = closeButton.getStyle();
			up = buttonStyle.up;
			add(button);
			if (tab.isCloseableByUser()) {
				add(closeButton).size(14 * sizes.scaleFactor, button.getHeight());
			}
		}
		private void addListeners () {
			closeButton.addListener(new ChangeListener() {
				@Override
				public void changed (ChangeEvent event, Actor actor) {
					closeTabAsUser();
				}
			});
			button.addListener(new InputListener() {
				private boolean isDown;
				@Override
				public boolean touchDown (InputEvent event, float x, float y, int pointer, int mouseButton) {
					if (button.isDisabled()) {
						return false;
					}
					isDown = true;
					if (UIUtils.left()) {
						setDraggedUpImage();
					}
					if (mouseButton == Buttons.MIDDLE) {
						closeTabAsUser();
					}
					return true;
				}
				@Override
				public void touchUp (InputEvent event, float x, float y, int pointer, int button) {
					setDefaultUpImage();
					isDown = false;
				}
				@Override
				public boolean mouseMoved (InputEvent event, float x, float y) {
					if (!button.isDisabled() && activeTab != tab) {
						setCloseButtonOnMouseMove();
					}
					return false;
				}
				@Override
				public void exit (InputEvent event, float x, float y, int pointer, Actor toActor) {
					if (!button.isDisabled() && !isDown && activeTab != tab && pointer == -1) {
						setDefaultUpImage();
					}
				}
				@Override
				public void enter (InputEvent event, float x, float y, int pointer, Actor fromActor) {
					if (!button.isDisabled() && activeTab != tab && Gdx.input.justTouched() == false && pointer == -1) {
						setCloseButtonOnMouseMove();
					}
				}
				private void setCloseButtonOnMouseMove () {
					if (isDown) {
						closeButtonStyle.up = buttonStyle.down;
					} else {
						closeButtonStyle.up = buttonStyle.over;
					}
				}
				private void setDraggedUpImage () {
					closeButtonStyle.up = buttonStyle.down;
					buttonStyle.up = buttonStyle.down;
				}
				private void setDefaultUpImage () {
					closeButtonStyle.up = up;
					buttonStyle.up = up;
				}
			});
			button.addListener(new ChangeListener() {
				@Override
				public void changed (ChangeEvent event, Actor actor) {
					switchToNewTab();
				}
			});
		}
		private void switchToNewTab () {
			// there was some previous tab, deselect it
			if (activeTab != null && activeTab != tab) {
				TabButtonTable table = tabsButtonMap.get(activeTab);
				// table may no longer exists if tab was removed, no big deal since this only changes
				// button style, tab.onHide() will be already called by remove() method
				if (table != null) {
					table.deselect();
					activeTab.onHide();
				}
			}
			if (button.isChecked() && tab != activeTab) { // switch to new tab
				activeTab = tab;
				notifyListenersSwitched(tab);
				tab.onShow();
				closeButton.setStyle(sharedCloseActiveButtonStyle);
			} else if (group.getCheckedIndex() == -1) { // no tab selected (allowTabDeselect == true)
				activeTab = null;
				notifyListenersSwitched(null);
			}
		}
		/** Closes tab, does nothing if Tab is not closeable by user */
		private void closeTabAsUser () {
			if (tab.isCloseableByUser()) {
				TabbedPane.this.remove(tab, false);
			}
		}
		private void select () {
			button.setChecked(true);
			switchToNewTab();
		}
		private void deselect () {
			closeButton.setStyle(closeButtonStyle);
		}
	}
	private enum Text implements BundleText {
		UNSAVED_DIALOG_TITLE("unsavedDialogTitle"), UNSAVED_DIALOG_TEXT("unsavedDialogText");
		private final String name;
		Text (final String name) {
			this.name = name;
		}
		private static I18NBundle getBundle () {
			return Locales.getTabbedPaneBundle();
		}
		@Override
		public final String getName () {
			return name;
		}
		@Override
		public final String get () {
			return getBundle().get(name);
		}
		@Override
		public final String format () {
			return getBundle().format(name);
		}
		@Override
		public final String format (final Object... arguments) {
			return getBundle().format(name, arguments);
		}
		@Override
		public final String toString () {
			return get();
		}
	}
}
/*
 * Copyright 2014-2017 See AUTHORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.kotcrab.vis.ui.widget;
import com.badlogic.gdx.math.Interpolation;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.EventListener;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.actions.Actions;
import com.badlogic.gdx.scenes.scene2d.ui.Cell;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.utils.Align;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.Timer;
import com.badlogic.gdx.utils.Timer.Task;
import com.kotcrab.vis.ui.VisUI;
import com.kotcrab.vis.ui.util.ActorUtils;
/**
 * Tooltips are widgets that appear below other widget on mouse pointer hover. Each actor can have only one tooltip.
 * <p>
 * libGDX 1.6.4 introduced it's own systems of tooltips. VisUI tooltips existed before that and are unrelated and
 * incompatible with libGDX tooltips. VisUI tooltips will remain supported.
 * @author Kotcrab
 * @since 0.5.0
 */
public class Tooltip extends VisTable {
	public static float DEFAULT_FADE_TIME = 0.3f;
	public static float DEFAULT_APPEAR_DELAY_TIME = 0.6f;
	/**
	 * Controls whether to fade out tooltip when mouse was moved. Changing this will not affect already existing tooltips.
	 * @see #setMouseMoveFadeOut(boolean)
	 */
	public static boolean MOUSE_MOVED_FADEOUT = false;
	private Actor target;
	private Actor content;
	private Cell<Actor> contentCell;
	private boolean mouseMoveFadeOut = MOUSE_MOVED_FADEOUT;
	private TooltipInputListener listener;
	private DisplayTask displayTask;
	private float fadeTime = DEFAULT_FADE_TIME;
	private float appearDelayTime = DEFAULT_APPEAR_DELAY_TIME;
	private Tooltip (Builder builder) {
		super(true);
		TooltipStyle style = builder.style;
		if (style == null) style = VisUI.getSkin().get("default", TooltipStyle.class);
		init(style, builder.target, builder.content);
		if (builder.width != -1) {
			contentCell.width(builder.width);
			pack();
		}
	}
	public Tooltip () {
		this("default");
	}
	public Tooltip (String styleName) {
		super(true);
		init(VisUI.getSkin().get(styleName, TooltipStyle.class), null, null);
	}
	public Tooltip (TooltipStyle style) {
		super(true);
		init(style, null, null);
	}
	/**
	 * Remove any attached tooltip from target actor
	 * @param target that tooltips will be removed
	 */
	public static void removeTooltip (Actor target) {
		Array<EventListener> listeners = target.getListeners();
		for (EventListener listener : listeners) {
			if (listener instanceof TooltipInputListener) target.removeListener(listener);
		}
	}
	private void init (TooltipStyle style, Actor target, Actor content) {
		this.target = target;
		this.content = content;
		this.listener = new TooltipInputListener();
		this.displayTask = new DisplayTask();
		setBackground(style.background);
		contentCell = add(content).padLeft(3).padRight(3).padBottom(2);
		pack();
		if (target != null) attach();
		addListener(new InputListener() {
			@Override
			public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
				toFront();
				return true;
			}
			@Override
			public void enter (InputEvent event, float x, float y, int pointer, Actor fromActor) {
				if (pointer == -1) {
					clearActions();
					addAction(Actions.sequence(Actions.fadeIn(fadeTime, Interpolation.fade)));
				}
			}
			@Override
			public void exit (InputEvent event, float x, float y, int pointer, Actor toActor) {
				if (pointer == -1) {
					fadeOut();
				}
			}
		});
	}
	/**
	 * Attaches tooltip to current target, must be called if tooltip listener was removed from target (for example by
	 * calling target.clearListeners() )
	 */
	public void attach () {
		if (target == null) return;
		Array<EventListener> listeners = target.getListeners();
		for (EventListener listener : listeners) {
			if (listener instanceof TooltipInputListener) {
				throw new IllegalStateException("More than one tooltip cannot be added to the same target!");
			}
		}
		target.addListener(listener);
	}
	/**
	 * Detaches tooltip form current target, does not change tooltip target meaning that this tooltip can be reattached to
	 * same target by calling {@link Tooltip#attach()}
	 */
	public void detach () {
		if (target == null) return;
		target.removeListener(listener);
	}
	/** Sets new target for this tooltip, tooltip will be automatically detached from old target. */
	public void setTarget (Actor newTarget) {
		detach();
		target = newTarget;
		attach();
	}
	public Actor getTarget () {
		return target;
	}
	private void fadeOut () {
		clearActions();
		addAction(Actions.sequence(Actions.fadeOut(fadeTime, Interpolation.fade), Actions.removeActor()));
	}
	private VisTable fadeIn () {
		clearActions();
		setColor(1, 1, 1, 0);
		addAction(Actions.sequence(Actions.fadeIn(fadeTime, Interpolation.fade)));
		return this;
	}
	public Actor getContent () {
		return content;
	}
	public void setContent (Actor content) {
		this.content = content;
		contentCell.setActor(content);
		pack();
	}
	public Cell<Actor> getContentCell () {
		return contentCell;
	}
	/**
	 * Changes text tooltip to specified text. If tooltip content is not instance of VisLabel then previous tooltip content
	 * will be replaced by VisLabel instance.
	 * @param text next tooltip text
	 */
	public void setText (String text) {
		if (content instanceof VisLabel) {
			((VisLabel) content).setText(text);
		} else {
			setContent(new VisLabel(text));
		}
		pack();
	}
	@Override
	public void setPosition (float x, float y) {
		super.setPosition((int) x, (int) y);
	}
	public float getAppearDelayTime () {
		return appearDelayTime;
	}
	public void setAppearDelayTime (float appearDelayTime) {
		this.appearDelayTime = appearDelayTime;
	}
	public float getFadeTime () {
		return fadeTime;
	}
	public void setFadeTime (float fadeTime) {
		this.fadeTime = fadeTime;
	}
	public boolean isMouseMoveFadeOut () {
		return mouseMoveFadeOut;
	}
	/**
	 * @param mouseMoveFadeOut if true tooltip fill fade out when mouse was moved. If false tooltip will only fadeout on
	 * mouse click or when mouse has exited target widget. Default is {@link Tooltip#MOUSE_MOVED_FADEOUT}.
	 */
	public void setMouseMoveFadeOut (boolean mouseMoveFadeOut) {
		this.mouseMoveFadeOut = mouseMoveFadeOut;
	}
	private class DisplayTask extends Task {
		@Override
		public void run () {
			if (target.getStage() == null) return;
			target.getStage().addActor(fadeIn());
			ActorUtils.keepWithinStage(getStage(), Tooltip.this);
		}
	}
	private class TooltipInputListener extends InputListener {
		@Override
		public boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {
			displayTask.cancel();
			Tooltip.this.toFront();
			fadeOut();
			return true;
		}
		@Override
		public void enter (InputEvent event, float x, float y, int pointer, Actor fromActor) {
			if (pointer == -1) {
				Vector2 targetPos = target.localToStageCoordinates(new Vector2());
				setX(targetPos.x + (target.getWidth() - getWidth()) / 2);
				float tooltipY = targetPos.y - getHeight() - 6;
				float stageHeight = target.getStage().getHeight();
				//is there enough space to display above widget?
				if (stageHeight - tooltipY > stageHeight)
					setY(targetPos.y + target.getHeight() + 6); //display above widget
				else
					setY(tooltipY); //display below
				displayTask.cancel();
				Timer.schedule(displayTask, appearDelayTime);
			}
		}
		@Override
		public void exit (InputEvent event, float x, float y, int pointer, Actor toActor) {
			if (pointer == -1) {
				displayTask.cancel();
				fadeOut();
			}
		}
		@Override
		public boolean mouseMoved (InputEvent event, float x, float y) {
			if (mouseMoveFadeOut && isVisible() && getActions().size == 0) fadeOut();
			return false;
		}
	}
	public static class TooltipStyle {
		public Drawable background;
		public TooltipStyle () {
		}
		public TooltipStyle (TooltipStyle style) {
			this.background = style.background;
		}
		public TooltipStyle (Drawable background) {
			this.background = background;
		}
	}
	public static class Builder {
		private final Actor content;
		private Actor target = null;
		private TooltipStyle style = null;
		private float width = -1;
		public Builder (Actor content) {
			this.content = content;
		}
		public Builder (String text) {
			this(text, Align.center);
		}
		public Builder (String text, int textAlign) {
			VisLabel label = new VisLabel(text);
			label.setAlignment(textAlign);
			this.content = label;
		}
		public Builder target (Actor target) {
			this.target = target;
			return this;
		}
		public Builder style (String styleName) {
			return style(VisUI.getSkin().get(styleName, TooltipStyle.class));
		}
		public Builder style (TooltipStyle style) {
			this.style = style;
			return this;
		}
		/** Sets tooltip width. If tooltip content is text only then calling this will automatically enable label wrapping. */
		public Builder width (float width) {
			if (width < 0) throw new IllegalArgumentException("width must be > 0");
			this.width = width;
			if (content instanceof VisLabel) {
				((VisLabel) content).setWrap(true);
			}
			return this;
		}
		public Tooltip build () {
			return new Tooltip(this);
		}
	}
}