/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class AddOperatorNode extends AbstractArithmeticOperatorNode {
  protected static final int PRIORITY = 50;
  public AddOperatorNode(ExpressionLocation location, String operator) {
    super(location, operator, PRIORITY);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitAddOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public interface ExpressionNodeVisitor<R, P> {
  R visitAndOperatorNode(AndOperatorNode node, P p);
  R visitOrOperatorNode(OrOperatorNode node, P p);
  R visitNotOperatorNode(NotOperatorNode node, P p);
  R visitNewOperatorNode(NewOperatorNode node, P p);
  R visitMethodOperatorNode(MethodOperatorNode node, P p);
  R visitStaticMethodOperatorNode(StaticMethodOperatorNode node, P p);
  R visitFunctionOperatorNode(FunctionOperatorNode node, P p);
  R visitFieldOperatorNode(FieldOperatorNode node, P p);
  R visitStaticFieldOperatorNode(StaticFieldOperatorNode node, P p);
  R visitCommaOperatorNode(CommaOperatorNode node, P p);
  R visitEqOperatorNode(EqOperatorNode node, P p);
  R visitNeOperatorNode(NeOperatorNode node, P p);
  R visitGeOperatorNode(GeOperatorNode node, P p);
  R visitLeOperatorNode(LeOperatorNode node, P p);
  R visitGtOperatorNode(GtOperatorNode node, P p);
  R visitLtOperatorNode(LtOperatorNode node, P p);
  R visitAddOperatorNode(AddOperatorNode node, P p);
  R visitSubtractOperatorNode(SubtractOperatorNode node, P p);
  R visitMultiplyOperatorNode(MultiplyOperatorNode node, P p);
  R visitDivideOperatorNode(DivideOperatorNode node, P p);
  R visitModOperatorNode(ModOperatorNode node, P p);
  R visitParensNode(ParensNode node, P p);
  R visitLiteralNode(LiteralNode node, P p);
  R visitVariableNode(VariableNode node, P p);
  R visitEmptyNode(EmptyNode node, P p);
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class NotOperatorNode implements LogicalOperatorNode {
  protected static final int PRIORITY = 30;
  protected final ExpressionLocation location;
  protected final String expression;
  protected ExpressionNode node;
  public NotOperatorNode(ExpressionLocation location, String expression) {
    assertNotNull(location, expression);
    this.location = location;
    this.expression = expression;
  }
  public ExpressionNode getNode() {
    return node;
  }
  public void setNode(ExpressionNode node) {
    this.node = node;
  }
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitNotOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return expression + node;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public interface ExpressionNode {
  ExpressionLocation getLocation();
  String getExpression();
  <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p);
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class MultiplyOperatorNode extends AbstractArithmeticOperatorNode {
  protected static final int PRIORITY = 60;
  public MultiplyOperatorNode(ExpressionLocation location, String operator) {
    super(location, operator, PRIORITY);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitMultiplyOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class DivideOperatorNode extends AbstractArithmeticOperatorNode {
  protected static final int PRIORITY = 60;
  public DivideOperatorNode(ExpressionLocation location, String operator) {
    super(location, operator, PRIORITY);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitDivideOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class GtOperatorNode extends AbstractComparisonOperatorNode {
  public GtOperatorNode(ExpressionLocation location, String opCode) {
    super(location, opCode);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitGtOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class LiteralNode implements ExpressionNode {
  protected final ExpressionLocation location;
  protected final String expression;
  protected final Object value;
  protected final Class<?> valueClass;
  public <T> LiteralNode(
      ExpressionLocation location, String expression, T value, Class<T> valueClass) {
    assertNotNull(location, expression, valueClass);
    this.location = location;
    this.expression = expression;
    this.value = value;
    this.valueClass = valueClass;
  }
  public Object getValue() {
    return value;
  }
  public Class<?> getValueClass() {
    return valueClass;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitLiteralNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return expression;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class StaticMethodOperatorNode implements OperatorNode {
  protected static final int PRIORITY = 0;
  protected final ExpressionLocation location;
  protected final String expression;
  protected final String className;
  protected final String methodName;
  protected ExpressionNode parametersNode;
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  public StaticMethodOperatorNode(
      ExpressionLocation location, String expression, String className, String methodName) {
    assertNotNull(location, className, methodName);
    this.location = location;
    this.expression = expression;
    this.className = className;
    this.methodName = methodName;
  }
  public String getClassName() {
    return className;
  }
  public String getMethodName() {
    return methodName;
  }
  public ExpressionNode getParametersNode() {
    return parametersNode;
  }
  public void setParametersNode(ExpressionNode parametersNode) {
    this.parametersNode = parametersNode;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitStaticMethodOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return expression + parametersNode;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class FunctionOperatorNode implements OperatorNode {
  protected static final int PRIORITY = 0;
  protected final ExpressionLocation location;
  protected final String expression;
  protected final String methodName;
  protected ExpressionNode parametersNode;
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  public FunctionOperatorNode(ExpressionLocation location, String expression, String methodName) {
    assertNotNull(location, methodName);
    this.location = location;
    this.expression = expression;
    this.methodName = methodName;
  }
  public String getMethodName() {
    return methodName;
  }
  public ExpressionNode getParametersNode() {
    return parametersNode;
  }
  public void setParametersNode(ExpressionNode parametersNode) {
    this.parametersNode = parametersNode;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitFunctionOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return "@" + expression + parametersNode;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class EqOperatorNode extends AbstractComparisonOperatorNode {
  public EqOperatorNode(ExpressionLocation location, String opCode) {
    super(location, opCode);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitEqOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class NewOperatorNode implements OperatorNode {
  protected static final int PRIORITY = 0;
  protected final ExpressionLocation location;
  protected final String expression;
  protected final String className;
  protected ExpressionNode parametersNode;
  public NewOperatorNode(ExpressionLocation location, String expression, String className) {
    assertNotNull(location, expression, className);
    this.location = location;
    this.expression = expression;
    this.className = className;
  }
  public String getClassName() {
    return className;
  }
  public ExpressionNode getParametersNode() {
    return parametersNode;
  }
  public void setParametersNode(ExpressionNode parametersNode) {
    this.parametersNode = parametersNode;
  }
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitNewOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return expression + " " + className + parametersNode;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
import java.util.ArrayList;
import java.util.List;
public class CommaOperatorNode implements OperatorNode {
  protected static final int PRIORITY = 0;
  protected final List<ExpressionNode> expressionNodes = new ArrayList<>();
  protected final ExpressionLocation location;
  protected final String expression;
  public CommaOperatorNode(ExpressionLocation location, String expression) {
    assertNotNull(location, expression);
    this.location = location;
    this.expression = expression;
  }
  public void addNode(ExpressionNode expressionNode) {
    expressionNodes.add(expressionNode);
  }
  public List<ExpressionNode> getNodes() {
    return expressionNodes;
  }
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitCommaOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    StringBuilder buf = new StringBuilder();
    for (ExpressionNode node : expressionNodes) {
      buf.append(node.toString());
      buf.append(expression);
      buf.append(" ");
    }
    if (buf.length() > 2) {
      buf.setLength(buf.length() - (expression.length() + 1));
    }
    return buf.toString();
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class FieldOperatorNode implements OperatorNode {
  protected static final int PRIORITY = 0;
  protected final ExpressionLocation location;
  protected final String expression;
  protected final String fieldName;
  protected ExpressionNode targetObjectNode;
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  public FieldOperatorNode(ExpressionLocation location, String expression, String fieldName) {
    assertNotNull(location, fieldName);
    this.location = location;
    this.expression = expression;
    this.fieldName = fieldName;
  }
  public String getFieldName() {
    return fieldName;
  }
  public ExpressionNode getTargetObjectNode() {
    return targetObjectNode;
  }
  public void setTargetObjectNode(ExpressionNode targetObjectNode) {
    this.targetObjectNode = targetObjectNode;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitFieldOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return targetObjectNode + expression;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class GeOperatorNode extends AbstractComparisonOperatorNode {
  public GeOperatorNode(ExpressionLocation location, String opCode) {
    super(location, opCode);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitGeOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class ModOperatorNode extends AbstractArithmeticOperatorNode {
  protected static final int PRIORITY = 60;
  public ModOperatorNode(ExpressionLocation location, String operator) {
    super(location, operator, PRIORITY);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitModOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class NeOperatorNode extends AbstractComparisonOperatorNode {
  public NeOperatorNode(ExpressionLocation location, String opCode) {
    super(location, opCode);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitNeOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class EmptyNode implements ExpressionNode {
  protected final ExpressionLocation location;
  public EmptyNode(ExpressionLocation location) {
    this.location = location;
  }
  @Override
  public String getExpression() {
    return "";
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitEmptyNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String toString() {
    return "";
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class LeOperatorNode extends AbstractComparisonOperatorNode {
  public LeOperatorNode(ExpressionLocation location, String opCode) {
    super(location, opCode);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitLeOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class SubtractOperatorNode extends AbstractArithmeticOperatorNode {
  protected static final int PRIORITY = 50;
  public SubtractOperatorNode(ExpressionLocation location, String operator) {
    super(location, operator, PRIORITY);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitSubtractOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class AndOperatorNode implements LogicalBinaryOperatorNode {
  protected static final int PRIORITY = 20;
  protected final ExpressionLocation location;
  protected final String expression;
  protected ExpressionNode leftNode;
  protected ExpressionNode rightNode;
  public AndOperatorNode(ExpressionLocation location, String expression) {
    assertNotNull(location, expression);
    this.location = location;
    this.expression = expression;
  }
  @Override
  public ExpressionNode getLeftNode() {
    return leftNode;
  }
  public void setLeftNode(ExpressionNode leftNode) {
    this.leftNode = leftNode;
  }
  @Override
  public ExpressionNode getRightNode() {
    return rightNode;
  }
  public void setRightNode(ExpressionNode rightNode) {
    this.rightNode = rightNode;
  }
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitAndOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return String.format("%s %s %s", leftNode, expression, rightNode);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class LtOperatorNode extends AbstractComparisonOperatorNode {
  public LtOperatorNode(ExpressionLocation location, String opCode) {
    super(location, opCode);
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitLtOperatorNode(this, p);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class MethodOperatorNode implements OperatorNode {
  protected static final int PRIORITY = 0;
  protected final ExpressionLocation location;
  protected final String expression;
  protected final String methodName;
  protected ExpressionNode targetObjectNode;
  protected ExpressionNode parametersNode;
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  public MethodOperatorNode(ExpressionLocation location, String expression, String methodName) {
    assertNotNull(location, methodName);
    this.location = location;
    this.expression = expression;
    this.methodName = methodName;
  }
  public String getMethodName() {
    return methodName;
  }
  public ExpressionNode getTargetObjectNode() {
    return targetObjectNode;
  }
  public void setTargetObjectNode(ExpressionNode targetObjectNode) {
    this.targetObjectNode = targetObjectNode;
  }
  public ExpressionNode getParametersNode() {
    return parametersNode;
  }
  public void setParametersNode(ExpressionNode parametersNode) {
    this.parametersNode = parametersNode;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitMethodOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return targetObjectNode + expression + parametersNode;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class ParensNode implements ExpressionNode {
  protected final ExpressionLocation location;
  protected final ExpressionNode node;
  public ParensNode(ExpressionLocation location, ExpressionNode node) {
    assertNotNull(location);
    this.location = location;
    this.node = node;
  }
  public ExpressionNode getNode() {
    return node;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitParensNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return "(";
  }
  @Override
  public String toString() {
    return "(" + node + ")";
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class OrOperatorNode implements LogicalBinaryOperatorNode {
  protected static final int PRIORITY = 10;
  protected final ExpressionLocation location;
  protected final String expression;
  protected ExpressionNode leftNode;
  protected ExpressionNode rightNode;
  public OrOperatorNode(ExpressionLocation location, String expression) {
    assertNotNull(location, expression);
    this.location = location;
    this.expression = expression;
  }
  @Override
  public ExpressionNode getLeftNode() {
    return leftNode;
  }
  public void setLeftNode(ExpressionNode leftNode) {
    this.leftNode = leftNode;
  }
  @Override
  public ExpressionNode getRightNode() {
    return rightNode;
  }
  public void setRightNode(ExpressionNode rightNode) {
    this.rightNode = rightNode;
  }
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitOrOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return String.format("%s %s %s", leftNode, expression, rightNode);
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
public class VariableNode implements ExpressionNode {
  protected final ExpressionLocation location;
  protected final String expression;
  public VariableNode(ExpressionLocation location, String expression) {
    this.location = location;
    this.expression = expression;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitVariableNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String toString() {
    return expression;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr.node;
import static org.seasar.doma.internal.util.AssertionUtil.*;
public class StaticFieldOperatorNode implements OperatorNode {
  protected static final int PRIORITY = 0;
  protected final ExpressionLocation location;
  protected final String expression;
  protected final String className;
  protected final String fieldName;
  @Override
  public int getPriority() {
    return PRIORITY;
  }
  public StaticFieldOperatorNode(
      ExpressionLocation location, String expression, String className, String fieldName) {
    assertNotNull(location, fieldName);
    this.location = location;
    this.expression = expression;
    this.className = className;
    this.fieldName = fieldName;
  }
  public String getClassName() {
    return className;
  }
  public String getFieldName() {
    return fieldName;
  }
  @Override
  public <R, P> R accept(ExpressionNodeVisitor<R, P> visitor, P p) {
    return visitor.visitStaticFieldOperatorNode(this, p);
  }
  @Override
  public ExpressionLocation getLocation() {
    return location;
  }
  @Override
  public String getExpression() {
    return expression;
  }
  @Override
  public String toString() {
    return expression;
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.apt.validator;
import static org.seasar.doma.internal.util.AssertionUtil.assertNotNull;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Set;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.TypeMirror;
import org.seasar.doma.expr.ExpressionFunctions;
import org.seasar.doma.internal.apt.AptException;
import org.seasar.doma.internal.apt.AptIllegalStateException;
import org.seasar.doma.internal.apt.Context;
import org.seasar.doma.internal.apt.decl.ConstructorDeclaration;
import org.seasar.doma.internal.apt.decl.FieldDeclaration;
import org.seasar.doma.internal.apt.decl.MethodDeclaration;
import org.seasar.doma.internal.apt.decl.TypeDeclaration;
import org.seasar.doma.internal.apt.decl.TypeParameterDeclaration;
import org.seasar.doma.internal.expr.node.AddOperatorNode;
import org.seasar.doma.internal.expr.node.AndOperatorNode;
import org.seasar.doma.internal.expr.node.ArithmeticOperatorNode;
import org.seasar.doma.internal.expr.node.CommaOperatorNode;
import org.seasar.doma.internal.expr.node.ComparisonOperatorNode;
import org.seasar.doma.internal.expr.node.DivideOperatorNode;
import org.seasar.doma.internal.expr.node.EmptyNode;
import org.seasar.doma.internal.expr.node.EqOperatorNode;
import org.seasar.doma.internal.expr.node.ExpressionLocation;
import org.seasar.doma.internal.expr.node.ExpressionNode;
import org.seasar.doma.internal.expr.node.ExpressionNodeVisitor;
import org.seasar.doma.internal.expr.node.FieldOperatorNode;
import org.seasar.doma.internal.expr.node.FunctionOperatorNode;
import org.seasar.doma.internal.expr.node.GeOperatorNode;
import org.seasar.doma.internal.expr.node.GtOperatorNode;
import org.seasar.doma.internal.expr.node.LeOperatorNode;
import org.seasar.doma.internal.expr.node.LiteralNode;
import org.seasar.doma.internal.expr.node.LogicalBinaryOperatorNode;
import org.seasar.doma.internal.expr.node.LtOperatorNode;
import org.seasar.doma.internal.expr.node.MethodOperatorNode;
import org.seasar.doma.internal.expr.node.ModOperatorNode;
import org.seasar.doma.internal.expr.node.MultiplyOperatorNode;
import org.seasar.doma.internal.expr.node.NeOperatorNode;
import org.seasar.doma.internal.expr.node.NewOperatorNode;
import org.seasar.doma.internal.expr.node.NotOperatorNode;
import org.seasar.doma.internal.expr.node.OrOperatorNode;
import org.seasar.doma.internal.expr.node.ParensNode;
import org.seasar.doma.internal.expr.node.StaticFieldOperatorNode;
import org.seasar.doma.internal.expr.node.StaticMethodOperatorNode;
import org.seasar.doma.internal.expr.node.SubtractOperatorNode;
import org.seasar.doma.internal.expr.node.VariableNode;
import org.seasar.doma.message.Message;
public class ExpressionValidator implements ExpressionNodeVisitor<TypeDeclaration, Void> {
  private final Context ctx;
  private final ExecutableElement methodElement;
  private final Map<String, TypeMirror> parameterTypeMap;
  private final Set<String> validatedParameterNames;
  private final TypeDeclaration unknownTypeDeclaration;
  private final String exprFunctionsClassName;
  ExpressionValidator(
      Context ctx, ExecutableElement methodElement, Map<String, TypeMirror> parameterTypeMap) {
    this(ctx, methodElement, parameterTypeMap, ctx.getOptions().getExprFunctions());
  }
  ExpressionValidator(
      Context ctx,
      ExecutableElement methodElement,
      Map<String, TypeMirror> parameterTypeMap,
      String exprFunctionsClassName) {
    assertNotNull(ctx, methodElement, parameterTypeMap);
    this.ctx = ctx;
    this.methodElement = methodElement;
    this.parameterTypeMap = new HashMap<>(parameterTypeMap);
    this.validatedParameterNames = new HashSet<>();
    this.unknownTypeDeclaration = ctx.getDeclarations().newUnknownTypeDeclaration();
    this.exprFunctionsClassName = exprFunctionsClassName;
  }
  TypeMirror removeParameterType(String parameterName) {
    return parameterTypeMap.remove(parameterName);
  }
  void putParameterType(String parameterName, TypeMirror parameterType) {
    parameterTypeMap.put(parameterName, parameterType);
  }
  void addValidatedParameterName(String name) {
    validatedParameterNames.add(name);
  }
  Set<String> getValidatedParameterNames() {
    return validatedParameterNames;
  }
  TypeDeclaration validate(ExpressionNode node) {
    return validateInternal(node);
  }
  private TypeDeclaration validateInternal(ExpressionNode node) {
    return node.accept(this, null);
  }
  @Override
  public TypeDeclaration visitEqOperatorNode(EqOperatorNode node, Void p) {
    return handleNullAvailableComparisonOperation(node, p);
  }
  @Override
  public TypeDeclaration visitNeOperatorNode(NeOperatorNode node, Void p) {
    return handleNullAvailableComparisonOperation(node, p);
  }
  @Override
  public TypeDeclaration visitGeOperatorNode(GeOperatorNode node, Void p) {
    return handleNullUnavailableComparisonOperation(node, p);
  }
  @Override
  public TypeDeclaration visitGtOperatorNode(GtOperatorNode node, Void p) {
    return handleNullUnavailableComparisonOperation(node, p);
  }
  @Override
  public TypeDeclaration visitLeOperatorNode(LeOperatorNode node, Void p) {
    return handleNullUnavailableComparisonOperation(node, p);
  }
  @Override
  public TypeDeclaration visitLtOperatorNode(LtOperatorNode node, Void p) {
    return handleNullUnavailableComparisonOperation(node, p);
  }
  private TypeDeclaration handleNullAvailableComparisonOperation(
      ComparisonOperatorNode node, Void p) {
    TypeDeclaration left = node.getLeftNode().accept(this, p);
    TypeDeclaration right = node.getRightNode().accept(this, p);
    if (left.isNullType() || right.isNullType() || left.isSameType(right)) {
      return ctx.getDeclarations().newPrimitiveBooleanTypeDeclaration();
    }
    ExpressionLocation location = node.getLocation();
    throw new AptException(
        Message.DOMA4116,
        methodElement,
        new Object[] {
          location.getExpression(),
          location.getPosition(),
          node.getExpression(),
          node.getLeftNode().toString(),
          left.getBinaryName(),
          node.getRightNode().toString(),
          right.getBinaryName()
        });
  }
  private TypeDeclaration handleNullUnavailableComparisonOperation(
      ComparisonOperatorNode node, Void p) {
    TypeDeclaration left = node.getLeftNode().accept(this, p);
    TypeDeclaration right = node.getRightNode().accept(this, p);
    if (left.isNullType() || right.isNullType()) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4139,
          methodElement,
          new Object[] {location.getExpression(), location.getPosition(), node.getExpression()});
    }
    if (left.isSameType(right)) {
      return ctx.getDeclarations().newPrimitiveBooleanTypeDeclaration();
    }
    ExpressionLocation location = node.getLocation();
    throw new AptException(
        Message.DOMA4116,
        methodElement,
        new Object[] {
          location.getExpression(),
          location.getPosition(),
          node.getExpression(),
          node.getLeftNode().toString(),
          left.getBinaryName(),
          node.getRightNode().toString(),
          right.getBinaryName()
        });
  }
  @Override
  public TypeDeclaration visitAndOperatorNode(AndOperatorNode node, Void p) {
    return handleLogicalBinaryOperatorNode(node, p);
  }
  @Override
  public TypeDeclaration visitOrOperatorNode(OrOperatorNode node, Void p) {
    return handleLogicalBinaryOperatorNode(node, p);
  }
  private TypeDeclaration handleLogicalBinaryOperatorNode(LogicalBinaryOperatorNode node, Void p) {
    TypeDeclaration left = node.getLeftNode().accept(this, p);
    TypeDeclaration right = node.getRightNode().accept(this, p);
    if (!left.isBooleanType()) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4117,
          methodElement,
          new Object[] {
            location.getExpression(),
            location.getPosition(),
            node.getExpression(),
            node.getLeftNode().toString(),
            left.getBinaryName()
          });
    }
    if (!right.isBooleanType()) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4118,
          methodElement,
          new Object[] {
            location.getExpression(),
            location.getPosition(),
            node.getExpression(),
            node.getRightNode().toString(),
            right.getBinaryName()
          });
    }
    return ctx.getDeclarations().newPrimitiveBooleanTypeDeclaration();
  }
  @Override
  public TypeDeclaration visitNotOperatorNode(NotOperatorNode node, Void p) {
    TypeDeclaration result = node.getNode().accept(this, p);
    if (result.isBooleanType()) {
      return ctx.getDeclarations().newPrimitiveBooleanTypeDeclaration();
    }
    ExpressionLocation location = node.getLocation();
    throw new AptException(
        Message.DOMA4119,
        methodElement,
        new Object[] {
          location.getExpression(),
          location.getPosition(),
          node.getExpression(),
          node.getNode().toString(),
          result.getBinaryName()
        });
  }
  @Override
  public TypeDeclaration visitAddOperatorNode(AddOperatorNode node, Void p) {
    TypeDeclaration left = node.getLeftNode().accept(this, p);
    TypeDeclaration right = node.getRightNode().accept(this, p);
    if (left.isTextType()) {
      if (right.isTextType()) {
        return left.emulateConcatOperation(right);
      }
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4126,
          methodElement,
          new Object[] {
            location.getExpression(),
            location.getPosition(),
            node.getExpression(),
            node.getLeftNode().toString(),
            left.getBinaryName()
          });
    }
    return handleArithmeticOperatorNode(node, left, right);
  }
  @Override
  public TypeDeclaration visitSubtractOperatorNode(SubtractOperatorNode node, Void p) {
    TypeDeclaration left = node.getLeftNode().accept(this, p);
    TypeDeclaration right = node.getRightNode().accept(this, p);
    return handleArithmeticOperatorNode(node, left, right);
  }
  @Override
  public TypeDeclaration visitMultiplyOperatorNode(MultiplyOperatorNode node, Void p) {
    TypeDeclaration left = node.getLeftNode().accept(this, p);
    TypeDeclaration right = node.getRightNode().accept(this, p);
    return handleArithmeticOperatorNode(node, left, right);
  }
  @Override
  public TypeDeclaration visitDivideOperatorNode(DivideOperatorNode node, Void p) {
    TypeDeclaration left = node.getLeftNode().accept(this, p);
    TypeDeclaration right = node.getRightNode().accept(this, p);
    return handleArithmeticOperatorNode(node, left, right);
  }
  @Override
  public TypeDeclaration visitModOperatorNode(ModOperatorNode node, Void p) {
    TypeDeclaration left = node.getLeftNode().accept(this, p);
    TypeDeclaration right = node.getRightNode().accept(this, p);
    return handleArithmeticOperatorNode(node, left, right);
  }
  private TypeDeclaration handleArithmeticOperatorNode(
      ArithmeticOperatorNode node, TypeDeclaration left, TypeDeclaration right) {
    if (!left.isNumberType()) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4120,
          methodElement,
          new Object[] {
            location.getExpression(),
            location.getPosition(),
            node.getExpression(),
            node.getLeftNode().toString(),
            left.getBinaryName()
          });
    }
    if (!right.isNumberType()) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4121,
          methodElement,
          new Object[] {
            location.getExpression(),
            location.getPosition(),
            node.getExpression(),
            node.getRightNode().toString(),
            right.getBinaryName()
          });
    }
    return left.emulateArithmeticOperation(right);
  }
  @Override
  public TypeDeclaration visitLiteralNode(LiteralNode node, Void p) {
    TypeMirror type =
        node.getValueClass() == void.class
            ? ctx.getMoreTypes().getNullType()
            : ctx.getMoreTypes().getTypeMirror(node.getValueClass());
    return ctx.getDeclarations().newTypeDeclaration(type);
  }
  @Override
  public TypeDeclaration visitParensNode(ParensNode node, Void p) {
    return node.getNode().accept(this, p);
  }
  @Override
  public TypeDeclaration visitNewOperatorNode(NewOperatorNode node, Void p) {
    node.getParametersNode().accept(this, p);
    List<TypeDeclaration> parameterTypeDeclarations =
        new ParameterCollector().collect(node.getParametersNode());
    String className = node.getClassName();
    TypeElement typeElement = ctx.getMoreElements().getTypeElementFromBinaryName(className);
    if (typeElement == null) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4138,
          methodElement,
          new Object[] {location.getExpression(), location.getPosition(), className});
    }
    TypeDeclaration typeDeclaration = ctx.getDeclarations().newTypeDeclaration(typeElement);
    Optional<ConstructorDeclaration> constructorDeclaration =
        typeDeclaration.getConstructorDeclaration(parameterTypeDeclarations);
    if (constructorDeclaration.isEmpty()) {
      ExpressionLocation location = node.getLocation();
      String signature = createConstructorSignature(className, parameterTypeDeclarations);
      throw new AptException(
          Message.DOMA4115,
          methodElement,
          new Object[] {location.getExpression(), location.getPosition(), signature});
    }
    return typeDeclaration;
  }
  private String createConstructorSignature(
      String className, List<TypeDeclaration> parameterTypeDeclarations) {
    StringBuilder buf = new StringBuilder();
    buf.append(className);
    buf.append("(");
    if (parameterTypeDeclarations.size() > 0) {
      for (TypeDeclaration declaration : parameterTypeDeclarations) {
        buf.append(declaration.getType());
        buf.append(", ");
      }
      buf.setLength(buf.length() - 2);
    }
    buf.append(")");
    return buf.toString();
  }
  @Override
  public TypeDeclaration visitCommaOperatorNode(CommaOperatorNode node, Void p) {
    return unknownTypeDeclaration;
  }
  @Override
  public TypeDeclaration visitEmptyNode(EmptyNode node, Void p) {
    return unknownTypeDeclaration;
  }
  @Override
  public TypeDeclaration visitMethodOperatorNode(MethodOperatorNode node, Void p) {
    TypeDeclaration typeDeclaration = node.getTargetObjectNode().accept(this, p);
    List<TypeDeclaration> parameterTypeDeclarations =
        new ParameterCollector().collect(node.getParametersNode());
    String methodName = node.getMethodName();
    Optional<MethodDeclaration> methodDeclaration =
        typeDeclaration.getMethodDeclaration(methodName, parameterTypeDeclarations);
    if (methodDeclaration.isPresent()) {
      TypeDeclaration returnTypeDeclaration = methodDeclaration.get().getReturnTypeDeclaration();
      if (returnTypeDeclaration != null) {
        return convertIfOptional(returnTypeDeclaration);
      }
    }
    ExpressionLocation location = node.getLocation();
    String methodSignature = createMethodSignature(methodName, parameterTypeDeclarations);
    throw new AptException(
        Message.DOMA4071,
        methodElement,
        new Object[] {
          location.getExpression(),
          location.getPosition(),
          node.getTargetObjectNode().getExpression(),
          typeDeclaration.getBinaryName(),
          methodSignature
        });
  }
  @Override
  public TypeDeclaration visitStaticMethodOperatorNode(StaticMethodOperatorNode node, Void p) {
    String className = node.getClassName();
    TypeElement typeElement =
        ctx.getMoreElements().getTypeElementFromBinaryName(node.getClassName());
    if (typeElement == null) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4145,
          methodElement,
          new Object[] {location.getExpression(), location.getPosition(), className});
    }
    TypeDeclaration typeDeclaration = ctx.getDeclarations().newTypeDeclaration(typeElement);
    List<TypeDeclaration> parameterTypeDeclarations =
        new ParameterCollector().collect(node.getParametersNode());
    String methodName = node.getMethodName();
    Optional<MethodDeclaration> methodDeclaration =
        typeDeclaration.getStaticMethodDeclaration(methodName, parameterTypeDeclarations);
    if (methodDeclaration.isPresent()) {
      TypeDeclaration returnTypeDeclaration = methodDeclaration.get().getReturnTypeDeclaration();
      if (returnTypeDeclaration != null) {
        return convertIfOptional(returnTypeDeclaration);
      }
    }
    ExpressionLocation location = node.getLocation();
    String methodSignature = createMethodSignature(methodName, parameterTypeDeclarations);
    throw new AptException(
        Message.DOMA4146,
        methodElement,
        new Object[] {
          location.getExpression(), location.getPosition(), className, methodSignature
        });
  }
  @Override
  public TypeDeclaration visitFunctionOperatorNode(FunctionOperatorNode node, Void p) {
    TypeDeclaration typeDeclaration = getExpressionFunctionsDeclaration(node);
    List<TypeDeclaration> parameterTypeDeclarations =
        new ParameterCollector().collect(node.getParametersNode());
    String methodName = node.getMethodName();
    Optional<MethodDeclaration> methodDeclaration =
        typeDeclaration.getMethodDeclaration(methodName, parameterTypeDeclarations);
    if (methodDeclaration.isPresent()) {
      TypeDeclaration returnTypeDeclaration = methodDeclaration.get().getReturnTypeDeclaration();
      if (returnTypeDeclaration != null) {
        return returnTypeDeclaration;
      }
    }
    ExpressionLocation location = node.getLocation();
    String methodSignature = createMethodSignature(methodName, parameterTypeDeclarations);
    throw new AptException(
        Message.DOMA4072,
        methodElement,
        new Object[] {location.getExpression(), location.getPosition(), methodSignature});
  }
  private TypeDeclaration getExpressionFunctionsDeclaration(FunctionOperatorNode node) {
    if (exprFunctionsClassName == null) {
      return ctx.getDeclarations().newTypeDeclaration(ExpressionFunctions.class);
    }
    TypeElement element =
        ctx.getMoreElements().getTypeElementFromBinaryName(exprFunctionsClassName);
    if (element == null) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4189,
          methodElement,
          new Object[] {
            location.getExpression(),
            location.getPosition(),
            node.getMethodName(),
            exprFunctionsClassName
          });
    }
    TypeMirror type = element.asType();
    if (!ctx.getMoreTypes().isAssignableWithErasure(type, ExpressionFunctions.class)) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4190,
          methodElement,
          new Object[] {
            location.getExpression(),
            location.getPosition(),
            node.getMethodName(),
            exprFunctionsClassName
          });
    }
    return ctx.getDeclarations().newTypeDeclaration(type);
  }
  private String createMethodSignature(
      String methodName, List<TypeDeclaration> parameterTypeDeclarations) {
    StringBuilder buf = new StringBuilder();
    buf.append(methodName);
    buf.append("(");
    if (parameterTypeDeclarations.size() > 0) {
      for (TypeDeclaration declaration : parameterTypeDeclarations) {
        buf.append(declaration.getType());
        buf.append(", ");
      }
      buf.setLength(buf.length() - 2);
    }
    buf.append(")");
    return buf.toString();
  }
  @Override
  public TypeDeclaration visitFieldOperatorNode(FieldOperatorNode node, Void p) {
    TypeDeclaration typeDeclaration = node.getTargetObjectNode().accept(this, p);
    String fieldName = node.getFieldName();
    Optional<FieldDeclaration> fieldDeclaration = typeDeclaration.getFieldDeclaration(fieldName);
    if (fieldDeclaration.isPresent()) {
      TypeDeclaration fieldTypeDeclaration = fieldDeclaration.get().getTypeDeclaration();
      if (fieldTypeDeclaration != null) {
        return convertIfOptional(fieldTypeDeclaration);
      }
    }
    ExpressionLocation location = node.getLocation();
    throw new AptException(
        Message.DOMA4114,
        methodElement,
        new Object[] {
          location.getExpression(),
          location.getPosition(),
          node.getTargetObjectNode().getExpression(),
          typeDeclaration.getBinaryName(),
          fieldName
        });
  }
  @Override
  public TypeDeclaration visitStaticFieldOperatorNode(StaticFieldOperatorNode node, Void p) {
    String className = node.getClassName();
    TypeElement typeElement =
        ctx.getMoreElements().getTypeElementFromBinaryName(node.getClassName());
    if (typeElement == null) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4145,
          methodElement,
          new Object[] {location.getExpression(), location.getPosition(), className});
    }
    TypeDeclaration typeDeclaration = ctx.getDeclarations().newTypeDeclaration(typeElement);
    String fieldName = node.getFieldName();
    Optional<FieldDeclaration> fieldDeclaration =
        typeDeclaration.getStaticFieldDeclaration(fieldName);
    if (fieldDeclaration.isPresent()) {
      TypeDeclaration fieldTypeDeclaration = fieldDeclaration.get().getTypeDeclaration();
      if (fieldTypeDeclaration != null) {
        return convertIfOptional(fieldTypeDeclaration);
      }
    }
    ExpressionLocation location = node.getLocation();
    throw new AptException(
        Message.DOMA4148,
        methodElement,
        new Object[] {location.getExpression(), location.getPosition(), className, fieldName});
  }
  private TypeDeclaration convertIfOptional(TypeDeclaration typeDeclaration) {
    if (typeDeclaration.is(Optional.class)) {
      TypeParameterDeclaration typeParameterDeclaration =
          typeDeclaration.getTypeParameterDeclarations().stream()
              .findFirst()
              .orElseThrow(() -> new AptIllegalStateException(typeDeclaration.toString()));
      return ctx.getDeclarations().newTypeDeclaration(typeParameterDeclaration.getActualType());
    } else if (typeDeclaration.is(OptionalInt.class)) {
      return ctx.getDeclarations().newTypeDeclaration(Integer.class);
    } else if (typeDeclaration.is(OptionalLong.class)) {
      return ctx.getDeclarations().newTypeDeclaration(Long.class);
    } else if (typeDeclaration.is(OptionalDouble.class)) {
      return ctx.getDeclarations().newTypeDeclaration(Double.class);
    }
    return typeDeclaration;
  }
  @Override
  public TypeDeclaration visitVariableNode(VariableNode node, Void p) {
    String variableName = node.getExpression();
    TypeMirror type = parameterTypeMap.get(variableName);
    if (type == null) {
      ExpressionLocation location = node.getLocation();
      throw new AptException(
          Message.DOMA4067, methodElement, new Object[] {variableName, location.getPosition()});
    }
    validatedParameterNames.add(variableName);
    return ctx.getDeclarations().newTypeDeclaration(type);
  }
  protected class ParameterCollector implements ExpressionNodeVisitor<Void, List<TypeDeclaration>> {
    public List<TypeDeclaration> collect(ExpressionNode node) {
      List<TypeDeclaration> results = new ArrayList<>();
      node.accept(this, results);
      return results;
    }
    @Override
    public Void visitEqOperatorNode(EqOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitNeOperatorNode(NeOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitGeOperatorNode(GeOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitGtOperatorNode(GtOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitLeOperatorNode(LeOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitLtOperatorNode(LtOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitCommaOperatorNode(CommaOperatorNode node, List<TypeDeclaration> p) {
      for (ExpressionNode expressionNode : node.getNodes()) {
        expressionNode.accept(this, p);
      }
      return null;
    }
    @Override
    public Void visitLiteralNode(LiteralNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitVariableNode(VariableNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitOrOperatorNode(OrOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitAndOperatorNode(AndOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitNotOperatorNode(NotOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitAddOperatorNode(AddOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitSubtractOperatorNode(SubtractOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitMultiplyOperatorNode(MultiplyOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitDivideOperatorNode(DivideOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitModOperatorNode(ModOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitNewOperatorNode(NewOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitMethodOperatorNode(MethodOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitStaticMethodOperatorNode(
        StaticMethodOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitFunctionOperatorNode(FunctionOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitFieldOperatorNode(FieldOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitStaticFieldOperatorNode(
        StaticFieldOperatorNode node, List<TypeDeclaration> p) {
      validate(node, p);
      return null;
    }
    @Override
    public Void visitParensNode(ParensNode node, List<TypeDeclaration> p) {
      node.getNode().accept(this, p);
      return null;
    }
    @Override
    public Void visitEmptyNode(EmptyNode node, List<TypeDeclaration> p) {
      return null;
    }
    protected void validate(ExpressionNode node, List<TypeDeclaration> p) {
      TypeDeclaration result = ExpressionValidator.this.validateInternal(node);
      p.add(result);
    }
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr;
import static org.seasar.doma.internal.util.AssertionUtil.*;
import java.util.Deque;
import java.util.Iterator;
import org.seasar.doma.internal.expr.node.AddOperatorNode;
import org.seasar.doma.internal.expr.node.AndOperatorNode;
import org.seasar.doma.internal.expr.node.CommaOperatorNode;
import org.seasar.doma.internal.expr.node.DivideOperatorNode;
import org.seasar.doma.internal.expr.node.EmptyNode;
import org.seasar.doma.internal.expr.node.EqOperatorNode;
import org.seasar.doma.internal.expr.node.ExpressionLocation;
import org.seasar.doma.internal.expr.node.ExpressionNode;
import org.seasar.doma.internal.expr.node.ExpressionNodeVisitor;
import org.seasar.doma.internal.expr.node.FieldOperatorNode;
import org.seasar.doma.internal.expr.node.FunctionOperatorNode;
import org.seasar.doma.internal.expr.node.GeOperatorNode;
import org.seasar.doma.internal.expr.node.GtOperatorNode;
import org.seasar.doma.internal.expr.node.LeOperatorNode;
import org.seasar.doma.internal.expr.node.LiteralNode;
import org.seasar.doma.internal.expr.node.LtOperatorNode;
import org.seasar.doma.internal.expr.node.MethodOperatorNode;
import org.seasar.doma.internal.expr.node.ModOperatorNode;
import org.seasar.doma.internal.expr.node.MultiplyOperatorNode;
import org.seasar.doma.internal.expr.node.NeOperatorNode;
import org.seasar.doma.internal.expr.node.NewOperatorNode;
import org.seasar.doma.internal.expr.node.NotOperatorNode;
import org.seasar.doma.internal.expr.node.OperatorNode;
import org.seasar.doma.internal.expr.node.OrOperatorNode;
import org.seasar.doma.internal.expr.node.ParensNode;
import org.seasar.doma.internal.expr.node.StaticFieldOperatorNode;
import org.seasar.doma.internal.expr.node.StaticMethodOperatorNode;
import org.seasar.doma.internal.expr.node.SubtractOperatorNode;
import org.seasar.doma.internal.expr.node.VariableNode;
import org.seasar.doma.message.Message;
public class ExpressionReducer implements ExpressionNodeVisitor<Void, Deque<ExpressionNode>> {
  public void reduce(OperatorNode operator, Deque<ExpressionNode> operands) {
    operator.accept(this, operands);
  }
  @Override
  public Void visitEqOperatorNode(EqOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitNeOperatorNode(NeOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitGeOperatorNode(GeOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitGtOperatorNode(GtOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitLeOperatorNode(LeOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitLtOperatorNode(LtOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitOrOperatorNode(OrOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitAndOperatorNode(AndOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitNotOperatorNode(NotOperatorNode node, Deque<ExpressionNode> p) {
    node.setNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitAddOperatorNode(AddOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitSubtractOperatorNode(SubtractOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitMultiplyOperatorNode(MultiplyOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitDivideOperatorNode(DivideOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitModOperatorNode(ModOperatorNode node, Deque<ExpressionNode> p) {
    node.setRightNode(pop(node, p));
    node.setLeftNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitNewOperatorNode(NewOperatorNode node, Deque<ExpressionNode> p) {
    node.setParametersNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitMethodOperatorNode(MethodOperatorNode node, Deque<ExpressionNode> p) {
    node.setParametersNode(pop(node, p));
    node.setTargetObjectNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitStaticMethodOperatorNode(
      StaticMethodOperatorNode node, Deque<ExpressionNode> p) {
    node.setParametersNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitFunctionOperatorNode(FunctionOperatorNode node, Deque<ExpressionNode> p) {
    node.setParametersNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitFieldOperatorNode(FieldOperatorNode node, Deque<ExpressionNode> p) {
    node.setTargetObjectNode(pop(node, p));
    return null;
  }
  @Override
  public Void visitStaticFieldOperatorNode(StaticFieldOperatorNode node, Deque<ExpressionNode> p) {
    return null;
  }
  @Override
  public Void visitCommaOperatorNode(CommaOperatorNode node, Deque<ExpressionNode> p) {
    for (Iterator<ExpressionNode> it = p.descendingIterator(); it.hasNext(); ) {
      node.addNode(it.next());
      it.remove();
    }
    return null;
  }
  @Override
  public Void visitLiteralNode(LiteralNode node, Deque<ExpressionNode> p) {
    assertUnreachable();
    return null;
  }
  @Override
  public Void visitVariableNode(VariableNode node, Deque<ExpressionNode> p) {
    assertUnreachable();
    return null;
  }
  @Override
  public Void visitEmptyNode(EmptyNode node, Deque<ExpressionNode> p) {
    assertUnreachable();
    return null;
  }
  @Override
  public Void visitParensNode(ParensNode node, Deque<ExpressionNode> p) {
    assertUnreachable();
    return null;
  }
  protected ExpressionNode pop(OperatorNode node, Deque<ExpressionNode> p) {
    if (p.peek() == null) {
      ExpressionLocation location = node.getLocation();
      throw new ExpressionException(
          Message.DOMA3010, location.getExpression(), location.getPosition(), node.getExpression());
    }
    return p.pop();
  }
}
/*
 * Copyright Doma Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.seasar.doma.internal.expr;
import static org.seasar.doma.internal.util.AssertionUtil.assertNotNull;
import static org.seasar.doma.internal.util.AssertionUtil.assertTrue;
import static org.seasar.doma.internal.util.AssertionUtil.assertUnreachable;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import org.seasar.doma.expr.ExpressionFunctions;
import org.seasar.doma.internal.WrapException;
import org.seasar.doma.internal.expr.node.AddOperatorNode;
import org.seasar.doma.internal.expr.node.AndOperatorNode;
import org.seasar.doma.internal.expr.node.ArithmeticOperatorNode;
import org.seasar.doma.internal.expr.node.CommaOperatorNode;
import org.seasar.doma.internal.expr.node.ComparisonOperatorNode;
import org.seasar.doma.internal.expr.node.DivideOperatorNode;
import org.seasar.doma.internal.expr.node.EmptyNode;
import org.seasar.doma.internal.expr.node.EqOperatorNode;
import org.seasar.doma.internal.expr.node.ExpressionLocation;
import org.seasar.doma.internal.expr.node.ExpressionNode;
import org.seasar.doma.internal.expr.node.ExpressionNodeVisitor;
import org.seasar.doma.internal.expr.node.FieldOperatorNode;
import org.seasar.doma.internal.expr.node.FunctionOperatorNode;
import org.seasar.doma.internal.expr.node.GeOperatorNode;
import org.seasar.doma.internal.expr.node.GtOperatorNode;
import org.seasar.doma.internal.expr.node.LeOperatorNode;
import org.seasar.doma.internal.expr.node.LiteralNode;
import org.seasar.doma.internal.expr.node.LtOperatorNode;
import org.seasar.doma.internal.expr.node.MethodOperatorNode;
import org.seasar.doma.internal.expr.node.ModOperatorNode;
import org.seasar.doma.internal.expr.node.MultiplyOperatorNode;
import org.seasar.doma.internal.expr.node.NeOperatorNode;
import org.seasar.doma.internal.expr.node.NewOperatorNode;
import org.seasar.doma.internal.expr.node.NotOperatorNode;
import org.seasar.doma.internal.expr.node.OperatorNode;
import org.seasar.doma.internal.expr.node.OrOperatorNode;
import org.seasar.doma.internal.expr.node.ParensNode;
import org.seasar.doma.internal.expr.node.StaticFieldOperatorNode;
import org.seasar.doma.internal.expr.node.StaticMethodOperatorNode;
import org.seasar.doma.internal.expr.node.SubtractOperatorNode;
import org.seasar.doma.internal.expr.node.VariableNode;
import org.seasar.doma.internal.util.ClassUtil;
import org.seasar.doma.internal.util.ConstructorUtil;
import org.seasar.doma.internal.util.FieldUtil;
import org.seasar.doma.internal.util.GenericsUtil;
import org.seasar.doma.internal.util.MethodUtil;
import org.seasar.doma.jdbc.ClassHelper;
import org.seasar.doma.message.Message;
public class ExpressionEvaluator implements ExpressionNodeVisitor<EvaluationResult, Void> {
  protected final Map<String, Value> variableValues;
  protected final ExpressionFunctions expressionFunctions;
  protected final ClassHelper classHelper;
  public ExpressionEvaluator() {
    this(new NullExpressionFunctions(), new ClassHelper() {});
  }
  public ExpressionEvaluator(ExpressionFunctions expressionFunctions, ClassHelper classHelper) {
    this(Collections.emptyMap(), expressionFunctions, classHelper);
  }
  public ExpressionEvaluator(
      Map<String, Value> variableValues,
      ExpressionFunctions expressionFunctions,
      ClassHelper classHelper) {
    assertNotNull(variableValues, expressionFunctions, classHelper);
    this.variableValues = new HashMap<>(variableValues);
    this.expressionFunctions = expressionFunctions;
    this.classHelper = classHelper;
  }
  public void putValue(String variableName, Value value) {
    assertNotNull(variableName, value);
    variableValues.put(variableName, value);
  }
  public Value removeValue(String variableName) {
    assertNotNull(variableName);
    return variableValues.remove(variableName);
  }
  public void add(String variableName, Value value) {
    assertNotNull(variableName, value);
    variableValues.put(variableName, value);
  }
  public EvaluationResult evaluate(ExpressionNode node) {
    assertNotNull(node);
    return evaluateInternal(node);
  }
  protected EvaluationResult evaluateInternal(ExpressionNode node) {
    return node.accept(this, null);
  }
  @Override
  public EvaluationResult visitEqOperatorNode(EqOperatorNode node, Void p) {
    Object left = node.getLeftNode().accept(this, p).getValue();
    Object right = node.getRightNode().accept(this, p).getValue();
    if (left == null && right == null) {
      return new EvaluationResult(true, boolean.class);
    }
    if (left == null || right == null) {
      return new EvaluationResult(false, boolean.class);
    }
    try {
      @SuppressWarnings("unchecked")
      Comparable<Object> c1 = (Comparable<Object>) left;
      @SuppressWarnings("unchecked")
      Comparable<Object> c2 = (Comparable<Object>) right;
      return new EvaluationResult(c1.compareTo(c2) == 0, boolean.class);
    } catch (ClassCastException e) {
      ExpressionLocation location = node.getLocation();
      throw new ExpressionException(
          Message.DOMA3008, e, location.getExpression(), node.getExpression(), e);
    }
  }
  @Override
  public EvaluationResult visitNeOperatorNode(NeOperatorNode node, Void p) {
    Object left = node.getLeftNode().accept(this, p).getValue();
    Object right = node.getRightNode().accept(this, p).getValue();
    if (left == null && right == null) {
      return new EvaluationResult(false, boolean.class);
    }
    if (left == null || right == null) {
      return new EvaluationResult(true, boolean.class);
    }
    try {
      @SuppressWarnings("unchecked")
      Comparable<Object> c1 = (Comparable<Object>) left;
      @SuppressWarnings("unchecked")
      Comparable<Object> c2 = (Comparable<Object>) right;
      return new EvaluationResult(c1.compareTo(c2) != 0, boolean.class);
    } catch (ClassCastException e) {
      ExpressionLocation location = node.getLocation();
      throw new ExpressionException(
          Message.DOMA3008, e, location.getExpression(), node.getExpression(), e);
    }
  }
  @Override
  public EvaluationResult visitGeOperatorNode(GeOperatorNode node, Void p) {
    Object left = node.getLeftNode().accept(this, p).getValue();
    Object right = node.getRightNode().accept(this, p).getValue();
    return new EvaluationResult(compare(node, left, right) >= 0, boolean.class);
  }
  @Override
  public EvaluationResult visitGtOperatorNode(GtOperatorNode node, Void p) {
    Object left = node.getLeftNode().accept(this, p).getValue();
    Object right = node.getRightNode().accept(this, p).getValue();
    return new EvaluationResult(compare(node, left, right) > 0, boolean.class);
  }
  @Override
  public EvaluationResult visitLeOperatorNode(LeOperatorNode node, Void p) {
    Object left = node.getLeftNode().accept(this, p).getValue();
    Object right = node.getRightNode().accept(this, p).getValue();
    return new EvaluationResult(compare(node, left, right) <= 0, boolean.class);
  }
  @Override
  public EvaluationResult visitLtOperatorNode(LtOperatorNode node, Void p) {
    Object left = node.getLeftNode().accept(this, p).getValue();
    Object right = node.getRightNode().accept(this, p).getValue();
    return new EvaluationResult(compare(node, left, right) < 0, boolean.class);
  }
  protected int compare(ComparisonOperatorNode node, Object left, Object right)
      throws ClassCastException {
    if (left == null || right == null) {
      ExpressionLocation location = node.getLocation();
      throw new ExpressionException(
          Message.DOMA3009, location.getExpression(), location.getPosition(), node.getExpression());
    }
    try {
      @SuppressWarnings("unchecked")
      Comparable<Object> c1 = (Comparable<Object>) left;
      @SuppressWarnings("unchecked")
      Comparable<Object> c2 = (Comparable<Object>) right;
      return c1.compareTo(c2);
    } catch (ClassCastException e) {
      ExpressionLocation location = node.getLocation();
      throw new ExpressionException(
          Message.DOMA3008,
          e,
          location.getExpression(),
          location.getPosition(),
          node.getExpression(),
          e);
    }
  }
  @Override
  public EvaluationResult visitAndOperatorNode(AndOperatorNode node, Void p) {
    boolean result =
        node.getLeftNode().accept(this, p).getBooleanValue()
            && node.getRightNode().accept(this, p).getBooleanValue();
    return new EvaluationResult(result, boolean.class);
  }
  @Override
  public EvaluationResult visitOrOperatorNode(OrOperatorNode node, Void p) {
    boolean result =
        node.getLeftNode().accept(this, p).getBooleanValue()
            || node.getRightNode().accept(this, p).getBooleanValue();
    return new EvaluationResult(result, boolean.class);
  }
  @Override
  public EvaluationResult visitNotOperatorNode(NotOperatorNode node, Void p) {
    boolean result = node.getNode().accept(this, p).getBooleanValue();
    return new EvaluationResult(!result, boolean.class);
  }
  @Override
  public EvaluationResult visitAddOperatorNode(AddOperatorNode node, Void p) {
    ExpressionNode leftNode = node.getLeftNode();
    EvaluationResult leftResult = evaluateNotNullableOperandNode(node, leftNode, p);
    ExpressionNode rightNode = node.getRightNode();
    EvaluationResult rightResult = evaluateNotNullableOperandNode(node, rightNode, p);
    Text leftText = createText(node, leftNode, leftResult);
    if (leftText != null) {
      Text rightText = createText(node, rightNode, rightResult);
      if (rightText != null) {
        return leftText.concat(rightText);
      }
      throwNotTextException(node, rightNode, rightResult);
    }
    Number leftNumber = createNumber(node, leftNode, leftResult);
    if (leftNumber == null) {
      throw newNotNumberException(node, leftNode, leftResult);
    }
    Number rightNumber = createNumber(node, rightNode, rightResult);
    if (rightNumber == null) {
      throw newNotNumberException(node, rightNode, rightResult);
    }
    return leftNumber.add(rightNumber);
  }
  protected Text createText(
      OperatorNode operatorNode, ExpressionNode operandNode, EvaluationResult evaluationResult) {
    if (!Text.isAcceptable(evaluationResult.getValueClass())) {
      return null;
    }
    return new Text(operatorNode, evaluationResult.getValue(), evaluationResult.getValueClass());
  }
  protected void throwNotTextException(
      OperatorNode operatorNode, ExpressionNode operandNode, EvaluationResult evaluationResult) {
    ExpressionLocation location = operandNode.getLocation();
    throw new ExpressionException(
        Message.DOMA3020,
        location.getExpression(),
        location.getPosition(),
        operatorNode.getExpression(),
        evaluationResult.getValue(),
        evaluationResult.getValueClass().getName());
  }
  @Override
  public EvaluationResult visitSubtractOperatorNode(SubtractOperatorNode node, Void p) {
    ExpressionNode leftNode = node.getLeftNode();
    EvaluationResult leftResult = evaluateNotNullableOperandNode(node, leftNode, p);
    ExpressionNode rightNode = node.getRightNode();
    EvaluationResult rightResult = evaluateNotNullableOperandNode(node, rightNode, p);
    Number leftNumber = createNumber(node, leftNode, leftResult);
    if (leftNumber == null) {
      throw newNotNumberException(node, leftNode, leftResult);
    }
    Number rightNumber = createNumber(node, rightNode, rightResult);
    if (rightNumber == null) {
      throw newNotNumberException(node, rightNode, rightResult);
    }
    return leftNumber.subtract(rightNumber);
  }
  @Override
  public EvaluationResult visitMultiplyOperatorNode(MultiplyOperatorNode node, Void p) {
    ExpressionNode leftNode = node.getLeftNode();
    EvaluationResult leftResult = evaluateNotNullableOperandNode(node, leftNode, p);
    ExpressionNode rightNode = node.getRightNode();
    EvaluationResult rightResult = evaluateNotNullableOperandNode(node, rightNode, p);
    Number leftNumber = createNumber(node, leftNode, leftResult);
    if (leftNumber == null) {
      throw newNotNumberException(node, leftNode, leftResult);
    }
    Number rightNumber = createNumber(node, rightNode, rightResult);
    if (rightNumber == null) {
      throw newNotNumberException(node, rightNode, rightResult);
    }
    return leftNumber.multiply(rightNumber);
  }
  @Override
  public EvaluationResult visitDivideOperatorNode(DivideOperatorNode node, Void p) {
    ExpressionNode leftNode = node.getLeftNode();
    EvaluationResult leftResult = evaluateNotNullableOperandNode(node, leftNode, p);
    ExpressionNode rightNode = node.getRightNode();
    EvaluationResult rightResult = evaluateNotNullableOperandNode(node, rightNode, p);
    Number leftNumber = createNumber(node, leftNode, leftResult);
    if (leftNumber == null) {
      throw newNotNumberException(node, leftNode, leftResult);
    }
    Number rightNumber = createNumber(node, rightNode, rightResult);
    if (rightNumber == null) {
      throw newNotNumberException(node, rightNode, rightResult);
    }
    return leftNumber.divide(rightNumber);
  }
  @Override
  public EvaluationResult visitModOperatorNode(ModOperatorNode node, Void p) {
    ExpressionNode leftNode = node.getLeftNode();
    EvaluationResult leftResult = evaluateNotNullableOperandNode(node, leftNode, p);
    ExpressionNode rightNode = node.getRightNode();
    EvaluationResult rightResult = evaluateNotNullableOperandNode(node, rightNode, p);
    Number leftNumber = createNumber(node, leftNode, leftResult);
    if (leftNumber == null) {
      throw newNotNumberException(node, leftNode, leftResult);
    }
    Number rightNumber = createNumber(node, rightNode, rightResult);
    if (rightNumber == null) {
      throw newNotNumberException(node, rightNode, rightResult);
    }
    return leftNumber.mod(rightNumber);
  }
  protected Number createNumber(
      ArithmeticOperatorNode operatorNode,
      ExpressionNode operandNode,
      EvaluationResult evaluationResult) {
    if (!Number.isAcceptable(evaluationResult.getValueClass())) {
      return null;
    }
    return new Number(operatorNode, evaluationResult.getValue(), evaluationResult.getValueClass());
  }
  protected ExpressionException newNotNumberException(
      ArithmeticOperatorNode operatorNode,
      ExpressionNode operandNode,
      EvaluationResult evaluationResult) {
    ExpressionLocation location = operandNode.getLocation();
    return new ExpressionException(
        Message.DOMA3013,
        location.getExpression(),
        location.getPosition(),
        operatorNode.getExpression(),
        evaluationResult.getValue(),
        evaluationResult.getValueClass().getName());
  }
  protected EvaluationResult evaluateNotNullableOperandNode(
      ExpressionNode operatorNode, ExpressionNode operandNode, Void p) {
    EvaluationResult evaluationResult = operandNode.accept(this, p);
    if (evaluationResult.getValue() == null) {
      ExpressionLocation location = operandNode.getLocation();
      throw new ExpressionException(
          Message.DOMA3015,
          location.getExpression(),
          location.getPosition(),
          operatorNode.getExpression());
    }
    return evaluationResult;
  }
  @Override
  public EvaluationResult visitLiteralNode(LiteralNode node, Void p) {
    return new EvaluationResult(node.getValue(), node.getValueClass());
  }
  @Override
  public EvaluationResult visitParensNode(ParensNode node, Void p) {
    return node.getNode().accept(this, p);
  }
  @Override
  public EvaluationResult visitNewOperatorNode(NewOperatorNode node, Void p) {
    ParameterCollector collector = new ParameterCollector();
    ParameterCollection collection = collector.collect(node.getParametersNode());
    ExpressionLocation location = node.getLocation();
    String className = node.getClassName();
    Class<?> clazz = forClassName(location, className);
    Constructor<?> constructor = findConstructor(location, clazz, collection.getParamTypes());
    if (constructor == null) {
      String signature = ConstructorUtil.createSignature(clazz, collection.getParamTypes());
      throw new ExpressionException(
          Message.DOMA3006, location.getExpression(), location.getPosition(), signature);
    }
    return invokeConstructor(location, clazz, constructor, collection.getParams());
  }
  protected Class<?> forClassName(ExpressionLocation location, String className) {
    try {
      return classHelper.forName(className);
    } catch (WrapException e) {
      throw new ExpressionException(
          Message.DOMA3005,
          e.getCause(),
          location.getExpression(),
          location.getPosition(),
          className);
    } catch (Exception e) {
      throw new ExpressionException(
          Message.DOMA3005, e, location.getExpression(), location.getPosition(), className);
    }
  }
  protected Constructor<?> findConstructor(
      ExpressionLocation location, Class<?> clazz, Class<?>... paramTypes) {
    outer:
    for (Constructor<?> constructor : clazz.getConstructors()) {
      Class<?>[] types = constructor.getParameterTypes();
      if (types.length == paramTypes.length) {
        for (int i = 0; i < types.length; i++) {
          if (!types[i].isAssignableFrom(paramTypes[i])) {
            continue outer;
          }
        }
        return constructor;
      }
    }
    return null;
  }
  protected EvaluationResult invokeConstructor(
      ExpressionLocation location, Class<?> clazz, Constructor<?> constructor, Object... params) {
    Object value;
    try {
      value = ConstructorUtil.newInstance(constructor, params);
    } catch (WrapException e) {
      Throwable cause = e.getCause();
      throw new ExpressionException(
          Message.DOMA3007,
          cause,
          location.getExpression(),
          location.getPosition(),
          ConstructorUtil.createSignature(constructor),
          cause);
    }
    return new EvaluationResult(value, clazz);
  }
  @Override
  public EvaluationResult visitMethodOperatorNode(MethodOperatorNode node, Void p) {
    ExpressionNode targetObjectNode = node.getTargetObjectNode();
    EvaluationResult targetResult = targetObjectNode.accept(this, p);
    Object target = targetResult.getValue();
    if (target == null) {
      ExpressionLocation location = node.getLocation();
      throw new ExpressionException(
          Message.DOMA3027,
          location.getExpression(),
          location.getPosition(),
          targetObjectNode.getExpression(),
          node.getMethodName());
    }
    Class<?> targetClass = target.getClass();
    ParameterCollector collector = new ParameterCollector();
    ParameterCollection collection = collector.collect(node.getParametersNode());
    ExpressionLocation location = node.getLocation();
    Method method =
        findMethod(node.getMethodName(), target, targetClass, collection.getParamTypes());
    if (method == null) {
      String signature =
          MethodUtil.createSignature(node.getMethodName(), collection.getParamTypes());
      throw new ExpressionException(
          Message.DOMA3002,
          location.getExpression(),
          location.getPosition(),
          targetClass.getName(),
          signature);
    }
    return invokeMethod(
        location, method, target, targetClass, collection.getParamTypes(), collection.getParams());
  }
  @Override
  public EvaluationResult visitStaticMethodOperatorNode(StaticMethodOperatorNode node, Void p) {
    Class<?> targetClass = forClassName(node.getLocation(), node.getClassName());
    ParameterCollector collector = new ParameterCollector();
    ParameterCollection collection = collector.collect(node.getParametersNode());
    ExpressionLocation location = node.getLocation();
    Method method = findMethod(node.getMethodName(), null, targetClass, collection.getParamTypes());
    if (method == null) {
      String signature =
          MethodUtil.createSignature(node.getMethodName(), collection.getParamTypes());
      throw new ExpressionException(
          Message.DOMA3002,
          location.getExpression(),
          location.getPosition(),
          targetClass.getName(),
          signature);
    }
    return invokeMethod(
        location, method, null, targetClass, collection.getParamTypes(), collection.getParams());
  }
  protected Method findMethod(
      String methodName, Object target, Class<?> targetClass, Class<?>[] paramTypes) {
    Method result = findMethodFromInterfaces(methodName, target, targetClass, paramTypes);
    if (result != null) {
      return result;
    }
    return findMethodFromClasses(methodName, target, targetClass, paramTypes);
  }
  protected Method findMethodFromInterfaces(
      String methodName, Object target, Class<?> targetClass, Class<?>[] paramTypes) {
    LinkedList<Method> methods = new LinkedList<>();
    for (Class<?> clazz = targetClass;
        clazz != null && clazz != Object.class;
        clazz = clazz.getSuperclass()) {
      for (Class<?> interfaze : clazz.getInterfaces()) {
        for (Method method : interfaze.getMethods()) {
          if (method.getName().equals(methodName)) {
            methods.addFirst(method);
          }
        }
      }
    }
    return findSuiteMethod(methods, target, targetClass, paramTypes);
  }
  protected Method findMethodFromClasses(
      String methodName, Object target, Class<?> targetClass, Class<?>[] paramTypes) {
    LinkedList<Method> methods = new LinkedList<>();
    for (Class<?> clazz = targetClass;
        clazz != null && clazz != Object.class;
        clazz = clazz.getSuperclass()) {
      for (Method method : clazz.getMethods()) {
        if (method.getName().equals(methodName)) {
          methods.addFirst(method);
        }
      }
    }
    return findSuiteMethod(methods, target, targetClass, paramTypes);
  }
  @SuppressWarnings("CStyleArrayDeclaration")
  protected Method findSuiteMethod(
      List<Method> methods, Object target, Class<?> targetClass, Class<?>[] argTypes) {
    CandidateMethod candidate = null;
    outer:
    for (Method method : methods) {
      Class<?> paramTypes[] = method.getParameterTypes();
      if (paramTypes.length == argTypes.length) {
        int degreeOfCoincidence = 0;
        for (int i = 0; i < paramTypes.length; i++) {
          int difference = calculateHierarchyDifference(paramTypes[i], argTypes[i], 0);
          if (difference == -1) {
            continue outer;
          }
          degreeOfCoincidence += difference;
        }
        if (degreeOfCoincidence == 0) {
          return method;
        }
        if (candidate == null || degreeOfCoincidence < candidate.degreeOfCoincidence) {
          candidate = new CandidateMethod(degreeOfCoincidence, method);
        }
      }
    }
    return candidate != null ? candidate.method : null;
  }
  protected int calculateHierarchyDifference(
      Class<?> paramType, Class<?> argType, int initDifference) {
    int difference = initDifference;
    if (paramType.equals(Object.class) && argType.isInterface()) {
      return Integer.MAX_VALUE;
    }
    for (Class<?> type = argType; type != null; type = type.getSuperclass()) {
      if (paramType.equals(type)
          || paramType.equals(ClassUtil.toBoxedPrimitiveTypeIfPossible(type))) {
        return difference;
      }
      difference++;
      if (paramType.isInterface()) {
        for (Class<?> interfaceClass : type.getInterfaces()) {
          int result = calculateHierarchyDifference(paramType, interfaceClass, difference);
          if (result != -1) {
            return result;
          }
        }
      }
    }
    return -1;
  }
  protected Method findStaticMethod(
      String methodName, Class<?> targetClass, Class<?>[] paramTypes) {
    Method method = findMethod(methodName, null, targetClass, paramTypes);
    if (method == null) {
      return null;
    }
    if ((method.getModifiers() & Modifier.STATIC) != 0) {
      return method;
    }
    return null;
  }
  protected EvaluationResult invokeMethod(
      ExpressionLocation location,
      Method method,
      Object target,
      Class<?> targetClass,
      Class<?>[] paramTypes,
      Object[] params) {
    Object value;
    try {
      value = MethodUtil.invoke(method, target, params);
    } catch (WrapException e) {
      Throwable cause = e.getCause();
      throw new ExpressionException(
          Message.DOMA3001,
          cause,
          location.getExpression(),
          location.getPosition(),
          targetClass.getName(),
          method.getName(),
          cause);
    }
    return createEvaluationResult(
        target, value, method.getReturnType(), method.getGenericReturnType());
  }
  @Override
  public EvaluationResult visitFunctionOperatorNode(FunctionOperatorNode node, Void p) {
    Class<?> targetClass = expressionFunctions.getClass();
    ParameterCollector collector = new ParameterCollector();
    ParameterCollection collection = collector.collect(node.getParametersNode());
    ExpressionLocation location = node.getLocation();
    Method method =
        findMethod(
            node.getMethodName(), expressionFunctions, targetClass, collection.getParamTypes());
    if (method == null) {
      String signature =
          MethodUtil.createSignature(node.getMethodName(), collection.getParamTypes());
      throw new ExpressionException(
          Message.DOMA3028, location.getExpression(), location.getPosition(), signature);
    }
    return invokeMethod(
        node.getLocation(),
        method,
        expressionFunctions,
        targetClass,
        collection.getParamTypes(),
        collection.getParams());
  }
  @Override
  public EvaluationResult visitFieldOperatorNode(FieldOperatorNode node, Void p) {
    EvaluationResult targetResult = node.getTargetObjectNode().accept(this, p);
    Object target = targetResult.getValue();
    ExpressionLocation location = node.getLocation();
    Field field = findField(node.getFieldName(), target.getClass());
    if (field == null) {
      throw new ExpressionException(
          Message.DOMA3018,
          location.getExpression(),
          location.getPosition(),
          target.getClass().getName(),
          node.getFieldName());
    }
    return getFieldValue(location, field, target);
  }
  @Override
  public EvaluationResult visitStaticFieldOperatorNode(StaticFieldOperatorNode node, Void p) {
    Class<?> targetClass = forClassName(node.getLocation(), node.getClassName());
    ExpressionLocation location = node.getLocation();
    Field field = findStaticField(node.getFieldName(), targetClass);
    if (field == null) {
      throw new ExpressionException(
          Message.DOMA3033,
          location.getExpression(),
          location.getPosition(),
          targetClass.getName(),
          node.getFieldName());
    }
    return getFieldValue(location, field, null);
  }
  protected Field findField(String fieldName, Class<?> targetClass) {
    for (Class<?> clazz = targetClass; clazz != Object.class; clazz = clazz.getSuperclass()) {
      try {
        Field field = clazz.getDeclaredField(fieldName);
        field.setAccessible(true);
        return field;
      } catch (NoSuchFieldException ignored) {
      }
    }
    return null;
  }
  protected Field findStaticField(String fieldName, Class<?> targetClass) {
    Field field = findField(fieldName, targetClass);
    if (field != null && (field.getModifiers() & Modifier.STATIC) != 0) {
      return field;
    }
    return null;
  }
  protected EvaluationResult getFieldValue(
      ExpressionLocation location, Field field, Object target) {
    Object value;
    try {
      value = FieldUtil.get(field, target);
    } catch (WrapException e) {
      Throwable cause = e.getCause();
      throw new ExpressionException(
          Message.DOMA3019,
          cause,
          location.getExpression(),
          location.getPosition(),
          target.getClass().getName(),
          field.getName(),
          cause);
    }
    return createEvaluationResult(target, value, field.getType(), field.getGenericType());
  }
  protected EvaluationResult createEvaluationResult(
      Object target, Object value, Class<?> valueClass, Type genericType) {
    if (value instanceof Optional<?>) {
      Optional<?> optional = (Optional<?>) value;
      if (genericType instanceof ParameterizedType) {
        ParameterizedType parameterizedType = (ParameterizedType) genericType;
        Type[] typeArguments = parameterizedType.getActualTypeArguments();
        if (typeArguments.length > 0 && typeArguments[0] instanceof Class) {
          Object elementValue = optional.orElse(null);
          return new EvaluationResult(elementValue, (Class<?>) typeArguments[0]);
        }
      }
    } else if (value instanceof OptionalInt) {
      OptionalInt optional = (OptionalInt) value;
      Integer nullable = optional.isPresent() ? optional.getAsInt() : null;
      return new EvaluationResult(nullable, Integer.class);
    } else if (value instanceof OptionalLong) {
      OptionalLong optional = (OptionalLong) value;
      Long nullable = optional.isPresent() ? optional.getAsLong() : null;
      return new EvaluationResult(nullable, Long.class);
    } else if (value instanceof OptionalDouble) {
      OptionalDouble optional = (OptionalDouble) value;
      Double nullable = optional.isPresent() ? optional.getAsDouble() : null;
      return new EvaluationResult(nullable, Double.class);
    }
    if (target != null) {
      if (genericType instanceof TypeVariable) {
        Class<?> typeArgument =
            GenericsUtil.inferTypeArgument(target.getClass(), (TypeVariable<?>) genericType);
        if (typeArgument != null) {
          return new EvaluationResult(value, typeArgument);
        }
      }
    }
    return new EvaluationResult(value, valueClass);
  }
  @Override
  public EvaluationResult visitVariableNode(VariableNode node, Void p) {
    String variableName = node.getExpression();
    Value value = variableValues.get(node.getExpression());
    if (value == null) {
      ExpressionLocation location = node.getLocation();
      throw new ExpressionException(
          Message.DOMA3003, location.getExpression(), location.getPosition(), variableName);
    }
    return new EvaluationResult(value.getValue(), value.getType());
  }
  @Override
  public EvaluationResult visitCommaOperatorNode(CommaOperatorNode node, Void p) {
    return new EvaluationResult(null, Void.class);
  }
  @Override
  public EvaluationResult visitEmptyNode(EmptyNode node, Void p) {
    return new EvaluationResult(null, Void.class);
  }
  protected static class Text {
    protected final OperatorNode operatorNode;
    protected final String stringValue;
    protected Text(OperatorNode operatorNode, Object value, Class<?> valueClass) {
      assertNotNull(operatorNode);
      assertNotNull(value);
      assertNotNull(isAcceptable(valueClass));
      this.operatorNode = operatorNode;
      this.stringValue = value.toString();
    }
    protected static boolean isAcceptable(Class<?> valueClass) {
      return valueClass == String.class
          || valueClass == Character.class
          || valueClass == char.class;
    }
    protected EvaluationResult concat(Text other) {
      String newValue = stringValue.concat(other.stringValue);
      return new EvaluationResult(newValue, String.class);
    }
  }
  protected static class Number {
    protected static final Map<Class<?>, Integer> priorityMap = new HashMap<>();
    static {
      priorityMap.put(BigDecimal.class, 80);
      priorityMap.put(BigInteger.class, 70);
      priorityMap.put(double.class, 60);
      priorityMap.put(Double.class, 60);
      priorityMap.put(float.class, 50);
      priorityMap.put(Float.class, 50);
      priorityMap.put(long.class, 40);
      priorityMap.put(Long.class, 40);
      priorityMap.put(int.class, 30);
      priorityMap.put(Integer.class, 30);
      priorityMap.put(short.class, 20);
      priorityMap.put(Short.class, 20);
      priorityMap.put(byte.class, 10);
      priorityMap.put(Byte.class, 10);
    }
    protected final ArithmeticOperatorNode operatorNode;
    protected final BigDecimal numberValue;
    protected final Class<?> realClass;
    protected final Integer priority;
    protected Number(ArithmeticOperatorNode operatorNode, Object value, Class<?> valueClass) {
      assertNotNull(operatorNode);
      assertNotNull(value);
      assertTrue(isAcceptable(valueClass));
      this.priority = priorityMap.get(valueClass);
      this.operatorNode = operatorNode;
      this.numberValue = widenValue(value, valueClass);
      this.realClass = valueClass;
    }
    protected static boolean isAcceptable(Class<?> valueClass) {
      return priorityMap.containsKey(valueClass);
    }
    protected BigDecimal widenValue(Object value, Class<?> clazz) {
      if (clazz == BigDecimal.class) {
        return (BigDecimal) value;
      } else if (clazz == BigInteger.class) {
        BigInteger v = (BigInteger) value;
        return new BigDecimal(v);
      } else if (clazz == Double.class || clazz == double.class) {
        Double v = (Double) value;
        return new BigDecimal(v);
      } else if (clazz == Float.class || clazz == float.class) {
        Float v = (Float) value;
        return new BigDecimal(v);
      } else if (clazz == Long.class || clazz == long.class) {
        Long v = (Long) value;
        return new BigDecimal(v);
      } else if (clazz == Integer.class || clazz == int.class) {
        Integer v = (Integer) value;
        return new BigDecimal(v);
      } else if (clazz == Short.class || clazz == short.class) {
        Short v = (Short) value;
        return new BigDecimal(v);
      } else if (clazz == Byte.class || clazz == byte.class) {
        Byte v = (Byte) value;
        return new BigDecimal(v);
      }
      return assertUnreachable();
    }
    protected Object narrowValue(BigDecimal value, Class<?> clazz) {
      if (clazz == BigDecimal.class) {
        return value;
      } else if (clazz == BigInteger.class) {
        return value.toBigInteger();
      } else if (clazz == Double.class || clazz == double.class) {
        return value.doubleValue();
      } else if (clazz == Float.class || clazz == float.class) {
        return value.floatValue();
      } else if (clazz == Long.class || clazz == long.class) {
        return value.longValue();
      } else if (clazz == Integer.class || clazz == int.class) {
        return value.intValue();
      } else if (clazz == Short.class || clazz == short.class) {
        return value.shortValue();
      } else if (clazz == Byte.class || clazz == byte.class) {
        return value.byteValue();
      }
      return assertUnreachable();
    }
    protected EvaluationResult add(Number other) {
      BigDecimal newValue = null;
      try {
        newValue = numberValue.add(other.numberValue);
      } catch (ArithmeticException e) {
        handleArithmeticException(e);
      }
      return createEvaluationResult(other, newValue);
    }
    protected EvaluationResult subtract(Number other) {
      BigDecimal newValue = null;
      try {
        newValue = numberValue.subtract(other.numberValue);
      } catch (ArithmeticException e) {
        handleArithmeticException(e);
      }
      return createEvaluationResult(other, newValue);
    }
    protected EvaluationResult multiply(Number other) {
      BigDecimal newValue = null;
      try {
        newValue = numberValue.multiply(other.numberValue);
      } catch (ArithmeticException e) {
        handleArithmeticException(e);
      }
      return createEvaluationResult(other, newValue);
    }
    protected EvaluationResult divide(Number other) {
      BigDecimal newValue = null;
      try {
        //noinspection BigDecimalMethodWithoutRoundingCalled
        newValue = numberValue.divide(other.numberValue);
      } catch (ArithmeticException e) {
        handleArithmeticException(e);
      }
      return createEvaluationResult(other, newValue);
    }
    protected EvaluationResult mod(Number other) {
      BigDecimal newValue = null;
      try {
        newValue = numberValue.remainder(other.numberValue);
      } catch (ArithmeticException e) {
        handleArithmeticException(e);
      }
      return createEvaluationResult(other, newValue);
    }
    protected void handleArithmeticException(ArithmeticException e) {
      ExpressionLocation location = operatorNode.getLocation();
      throw new ExpressionException(
          Message.DOMA3014,
          e,
          location.getExpression(),
          operatorNode.getExpression(),
          location.getPosition(),
          e);
    }
    protected EvaluationResult createEvaluationResult(Number other, BigDecimal newValue) {
      Class<?> realClass = this.priority >= other.priority ? this.realClass : other.realClass;
      Object narrowedValue = narrowValue(newValue, realClass);
      return new EvaluationResult(narrowedValue, realClass);
    }
  }
  protected class ParameterCollector
      implements ExpressionNodeVisitor<Void, List<EvaluationResult>> {
    public ParameterCollection collect(ExpressionNode node) {
      List<EvaluationResult> evaluationResults = new ArrayList<>();
      node.accept(this, evaluationResults);
      return new ParameterCollection(evaluationResults);
    }
    @Override
    public Void visitEqOperatorNode(EqOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitNeOperatorNode(NeOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitGeOperatorNode(GeOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitGtOperatorNode(GtOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitLeOperatorNode(LeOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitLtOperatorNode(LtOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitCommaOperatorNode(CommaOperatorNode node, List<EvaluationResult> p) {
      for (ExpressionNode expressionNode : node.getNodes()) {
        expressionNode.accept(this, p);
      }
      return null;
    }
    @Override
    public Void visitLiteralNode(LiteralNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitVariableNode(VariableNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitOrOperatorNode(OrOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitAndOperatorNode(AndOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitNotOperatorNode(NotOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitAddOperatorNode(AddOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitSubtractOperatorNode(SubtractOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitMultiplyOperatorNode(MultiplyOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitDivideOperatorNode(DivideOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitModOperatorNode(ModOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitNewOperatorNode(NewOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitMethodOperatorNode(MethodOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitStaticMethodOperatorNode(
        StaticMethodOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitFunctionOperatorNode(FunctionOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitFieldOperatorNode(FieldOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitStaticFieldOperatorNode(
        StaticFieldOperatorNode node, List<EvaluationResult> p) {
      evaluate(node, p);
      return null;
    }
    @Override
    public Void visitParensNode(ParensNode node, List<EvaluationResult> p) {
      node.getNode().accept(this, p);
      return null;
    }
    @Override
    public Void visitEmptyNode(EmptyNode node, List<EvaluationResult> p) {
      return null;
    }
    protected void evaluate(ExpressionNode node, List<EvaluationResult> p) {
      EvaluationResult evaluationResult = ExpressionEvaluator.this.evaluateInternal(node);
      p.add(evaluationResult);
    }
  }
  protected static class ParameterCollection {
    protected final Object[] params;
    protected final Class<?>[] paramTypes;
    public ParameterCollection(List<EvaluationResult> evaluationResults) {
      assertNotNull(evaluationResults);
      int size = evaluationResults.size();
      params = new Object[size];
      paramTypes = new Class<?>[size];
      int i = 0;
      for (EvaluationResult result : evaluationResults) {
        params[i] = result.getValue();
        paramTypes[i] = result.getValueClass();
        i++;
      }
    }
    public Object[] getParams() {
      return params;
    }
    public Class<?>[] getParamTypes() {
      return paramTypes;
    }
  }
  protected static class CandidateMethod {
    final int degreeOfCoincidence;
    final Method method;
    CandidateMethod(int degreeOfCoincidence, Method method) {
      this.degreeOfCoincidence = degreeOfCoincidence;
      this.method = method;
    }
  }
}