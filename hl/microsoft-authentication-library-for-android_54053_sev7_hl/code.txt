package com.microsoft.identity.client.testapp;
import android.app.Activity;
import android.content.Context;
import android.util.Log;
import androidx.annotation.NonNull;
import com.microsoft.identity.client.AcquireTokenParameters;
import com.microsoft.identity.client.AcquireTokenSilentParameters;
import com.microsoft.identity.client.AuthenticationCallback;
import com.microsoft.identity.client.AuthenticationResult;
import com.microsoft.identity.client.HttpMethod;
import com.microsoft.identity.client.IAccount;
import com.microsoft.identity.client.IAuthenticationResult;
import com.microsoft.identity.client.IMultipleAccountPublicClientApplication;
import com.microsoft.identity.client.IPublicClientApplication;
import com.microsoft.identity.client.ISingleAccountPublicClientApplication;
import com.microsoft.identity.client.PoPAuthenticationScheme;
import com.microsoft.identity.client.PublicClientApplication;
import com.microsoft.identity.client.claims.ClaimsRequest;
import com.microsoft.identity.client.exception.MsalArgumentException;
import com.microsoft.identity.client.exception.MsalClientException;
import com.microsoft.identity.client.exception.MsalDeclinedScopeException;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.client.exception.MsalServiceException;
import com.microsoft.identity.client.exception.MsalUiRequiredException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
/// Acting as a bridge between the result of MsalWrapper's results and the outside world.
interface INotifyOperationResultCallback<T> {
    void onSuccess(T result);
    void showMessage(String message);
}
abstract class MsalWrapper {
    public static void create(@NonNull final Context context,
                              @NonNull final int configFileResourceId,
                              @NonNull final INotifyOperationResultCallback<MsalWrapper> callback) {
        PublicClientApplication.create(context,
                configFileResourceId,
                new PublicClientApplication.ApplicationCreatedListener() {
                    @Override
                    public void onCreated(IPublicClientApplication application) {
                        if (application instanceof ISingleAccountPublicClientApplication) {
                            callback.onSuccess(new SingleAccountModeWrapper((ISingleAccountPublicClientApplication) application));
                        } else {
                            callback.onSuccess(new MultipleAccountModeWrapper((IMultipleAccountPublicClientApplication) application));
                        }
                    }
                    @Override
                    public void onError(MsalException exception) {
                        callback.showMessage("Failed to load MSAL Application: " + exception.getMessage());
                    }
                });
    }
    public abstract String getDefaultBrowser();
    public abstract String getMode();
    public abstract void loadAccounts(@NonNull final INotifyOperationResultCallback<List<IAccount>> callback);
    public abstract void removeAccount(@NonNull IAccount account,
                                       @NonNull final INotifyOperationResultCallback<Void> callback);
    public void acquireToken(@NonNull final Activity activity,
                             @NonNull final RequestOptions requestOptions,
                             @NonNull final INotifyOperationResultCallback<IAuthenticationResult> callback) {
        final AcquireTokenParameters.Builder builder = getAcquireTokenParametersBuilder(activity, requestOptions, callback);
        builder.withScopes(Arrays.asList(requestOptions.getScopes().toLowerCase().split(" ")));
        builder.withOtherScopesToAuthorize(
                Arrays.asList(
                        requestOptions
                                .getExtraScope()
                                .toLowerCase()
                                .split(" ")
                )
        );
        final AcquireTokenParameters parameters = builder.build();
        acquireTokenAsyncInternal(parameters);
    }
    public void acquireTokenWithResource(@NonNull final Activity activity,
                                         @NonNull final RequestOptions requestOptions,
                                         @NonNull final INotifyOperationResultCallback<IAuthenticationResult> callback) {
        final AcquireTokenParameters.Builder builder = getAcquireTokenParametersBuilder(activity, requestOptions, callback);
        builder.withAuthorizationQueryStringParameters(null);
        builder.withResource(requestOptions.getScopes().trim());
        final AcquireTokenParameters parameters = builder.build();
        acquireTokenAsyncInternal(parameters);
    }
    private AcquireTokenParameters.Builder getAcquireTokenParametersBuilder(@NonNull Activity activity,
                                                                            @NonNull RequestOptions requestOptions,
                                                                            @NonNull INotifyOperationResultCallback<IAuthenticationResult> callback) {
        final AcquireTokenParameters.Builder builder = new AcquireTokenParameters.Builder();
        builder.startAuthorizationFromActivity(activity)
                .withLoginHint(requestOptions.getLoginHint())
                .forAccount(requestOptions.getAccount())
                .withPrompt(requestOptions.getPrompt())
                .withCallback(getAuthenticationCallback(callback));
        if (requestOptions.getAuthority() != null && !requestOptions.getAuthority().isEmpty()) {
            builder.fromAuthority(requestOptions.getAuthority());
        }
        if (requestOptions.getClaims() != null && !requestOptions.getClaims().isEmpty()) {
            builder.withClaims(ClaimsRequest.getClaimsRequestFromJsonString(requestOptions.getClaims()));
        }
        if (requestOptions.getAuthScheme() == Constants.AuthScheme.POP) {
            try {
                builder.withAuthenticationScheme(
                        PoPAuthenticationScheme.builder()
                                .withHttpMethod(requestOptions.getPopHttpMethod())
                                .withClientClaims(requestOptions.getPoPClientClaims())
                                .withUrl(new URL(requestOptions.getPopResourceUrl()))
                                .build()
                );
            } catch (MalformedURLException e) {
                callback.showMessage("Unexpected error." + e.getMessage());
            }
        }
        return builder;
    }
    abstract void acquireTokenAsyncInternal(@NonNull final AcquireTokenParameters parameters);
    public void acquireTokenSilent(@NonNull RequestOptions requestOptions,
                                   @NonNull INotifyOperationResultCallback<IAuthenticationResult> callback) {
        if (requestOptions.getAccount() == null) {
            callback.showMessage("Account is null.");
            return;
        }
        final AcquireTokenSilentParameters.Builder builder = getAcquireTokenSilentParametersBuilder(requestOptions, callback);
        builder.withScopes(Arrays.asList(requestOptions.getScopes().toLowerCase().split(" ")));
        final AcquireTokenSilentParameters parameters = builder.build();
        acquireTokenSilentAsyncInternal(parameters);
    }
    public void acquireTokenSilentWithResource(@NonNull RequestOptions requestOptions,
                                               @NonNull INotifyOperationResultCallback<IAuthenticationResult> callback) {
        if (requestOptions.getAccount() == null) {
            callback.showMessage("Account is null.");
            return;
        }
        final AcquireTokenSilentParameters.Builder builder = getAcquireTokenSilentParametersBuilder(requestOptions, callback);
        builder.withResource(requestOptions.getScopes().toLowerCase().trim());
        final AcquireTokenSilentParameters parameters = builder.build();
        acquireTokenSilentAsyncInternal(parameters);
    }
    private AcquireTokenSilentParameters.Builder getAcquireTokenSilentParametersBuilder(@NonNull RequestOptions requestOptions,
                                                                                        @NonNull INotifyOperationResultCallback<IAuthenticationResult> callback) {
        final AcquireTokenSilentParameters.Builder builder = new AcquireTokenSilentParameters.Builder();
        builder.forAccount(requestOptions.getAccount())
                .forceRefresh(requestOptions.isForceRefresh())
                .withCallback(getAuthenticationCallback(callback));
        if (requestOptions.getAuthority() != null && !requestOptions.getAuthority().isEmpty()) {
            builder.fromAuthority(requestOptions.getAuthority());
        } else {
            builder.fromAuthority(requestOptions.getAccount().getAuthority());
        }
        if (requestOptions.getAuthScheme() == Constants.AuthScheme.POP) {
            try {
                builder.withAuthenticationScheme(
                        PoPAuthenticationScheme.builder()
                                .withHttpMethod(requestOptions.getPopHttpMethod())
                                .withClientClaims(requestOptions.getPoPClientClaims())
                                .withUrl(new URL(requestOptions.getPopResourceUrl())).build()
                );
            } catch (MalformedURLException e) {
                callback.showMessage("Unexpected error." + e.getMessage());
                return null;
            }
        }
        return builder;
    }
    abstract void acquireTokenSilentAsyncInternal(@NonNull final AcquireTokenSilentParameters parameters);
    public void acquireTokenWithDeviceCodeFlow(@NonNull RequestOptions requestOptions,
                                               @NonNull final INotifyOperationResultCallback<IAuthenticationResult> callback) {
        acquireTokenWithDeviceCodeFlowInternal(
                requestOptions.getScopes().toLowerCase().split(" "),
                new IPublicClientApplication.DeviceCodeFlowCallback() {
                    @Override
                    public void onUserCodeReceived(@NonNull String vUri,
                                                   @NonNull String userCode,
                                                   @NonNull String message,
                                                   @NonNull Date sessionExpirationDate) {
                        callback.showMessage(
                                "Uri: " + vUri + "\n" +
                                        "UserCode: " + userCode + "\n" +
                                        "Message: " + message + "\n" +
                                        "sessionExpirationDate: " + sessionExpirationDate);
                    }
                    @Override
                    public void onTokenReceived(@NonNull AuthenticationResult authResult) {
                        callback.onSuccess(authResult);
                    }
                    @Override
                    public void onError(@NonNull MsalException e) {
                        callback.showMessage("Unexpected error." + e.getMessage());
                    }
                });
    }
    abstract void acquireTokenWithDeviceCodeFlowInternal(@NonNull String[] scopes, @NonNull final IPublicClientApplication.DeviceCodeFlowCallback callback);
    AuthenticationCallback getAuthenticationCallback(@NonNull final INotifyOperationResultCallback<IAuthenticationResult> callback) {
        return new AuthenticationCallback() {
            @Override
            public void onSuccess(IAuthenticationResult authenticationResult) {
                callback.onSuccess(authenticationResult);
            }
            @Override
            public void onError(MsalException exception) {
                String message = "CorrelationID: " + exception.getCorrelationId() + "\n";
                // Check the exception type.
                if (exception instanceof MsalClientException) {
                    // This means errors happened in the sdk itself, could be network, Json parse, etc. Check MsalError.java
                    // for detailed list of the errors.
                    message += "MsalClientException.\n" + exception.getMessage();
                } else if (exception instanceof MsalServiceException) {
                    // This means something is wrong when the sdk is communication to the service, mostly likely it's the client
                    // configuration.
                    message += "MsalServiceException.\n" + exception.getMessage();
                } else if (exception instanceof MsalArgumentException) {
                    message += "MsalArgumentException.\n" + exception.getMessage();
                } else if (exception instanceof MsalUiRequiredException) {
                    // This explicitly indicates that developer needs to prompt the user, it could be refresh token is expired, revoked
                    // or user changes the password; or it could be that no token was found in the token cache.
                    message += "MsalUiRequiredException.\n" + exception.getMessage();
                } else if (exception instanceof MsalDeclinedScopeException) {
                    // Declined scope implies that not all scopes requested have been granted.
                    // Developer can either continue with Authentication by calling acquireTokenSilent
                    message += "MsalDeclinedScopeException.\n" +
                            "Granted Scope:" + ((MsalDeclinedScopeException) exception).getGrantedScopes() + "\n" +
                            "Declined Scope:" + ((MsalDeclinedScopeException) exception).getDeclinedScopes();
                }
                callback.showMessage(message);
            }
            @Override
            public void onCancel() {
                callback.showMessage("User cancelled the flow.");
            }
        };
    }
    public void generateSignedHttpRequest(@NonNull final RequestOptions currentRequestOptions,
                                          @NonNull final INotifyOperationResultCallback<String> generateShrCallback) {
        // Build up the params we want/need
        final IAccount currentAccount = currentRequestOptions.getAccount();
        final HttpMethod popHttpMethod = currentRequestOptions.getPopHttpMethod();
        final String resourceUrl = currentRequestOptions.getPopResourceUrl();
        final String clientClaims = currentRequestOptions.getPoPClientClaims();
        if (null == currentAccount) {
            // User must first sign-in
            generateShrCallback.showMessage("No user signed-in or selected.");
            return;
        }
        try {
            final PoPAuthenticationScheme popParams =
                    PoPAuthenticationScheme.builder()
                            .withHttpMethod(popHttpMethod)
                            .withUrl(new URL(resourceUrl))
                            .withClientClaims(clientClaims)
                            .build();
            Log.d(
                    MsalWrapper.class.getSimpleName() + ":generateSHR",
                    "Account: " + currentAccount.getUsername()
                            + "\n"
                            + "HttpMethod: " + popHttpMethod
                            + "\n"
                            + "Resource URL: " + resourceUrl
                            + "\n"
                            + "Client Claims: " + clientClaims
            );
            generateSignedHttpRequestInternal(
                    currentAccount,
                    popParams,
                    generateShrCallback
            );
        } catch (MalformedURLException e) {
            generateShrCallback.showMessage("Invalid URL.");
        }
    }
    public abstract void generateSignedHttpRequestInternal(@NonNull final IAccount account,
                                                           @NonNull final PoPAuthenticationScheme params,
                                                           @NonNull final INotifyOperationResultCallback<String> generateShrCallback
    );
}
//   Copyright (c) Microsoft Corporation.
//   All rights reserved.
//
//   This code is licensed under the MIT License.
//
//   Permission is hereby granted, free of charge, to any person obtaining a copy
//   of this software and associated documentation files(the "Software"), to deal
//   in the Software without restriction, including without limitation the rights
//   to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//   copies of the Software, and to permit persons to whom the Software is
//   furnished to do so, subject to the following conditions :
//
//   The above copyright notice and this permission notice shall be included in
//   all copies or substantial portions of the Software.
//
//   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//   THE SOFTWARE.
package com.microsoft.identity.client.testapp;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.microsoft.identity.client.AcquireTokenParameters;
import com.microsoft.identity.client.AcquireTokenSilentParameters;
import com.microsoft.identity.client.IAccount;
import com.microsoft.identity.client.IPublicClientApplication;
import com.microsoft.identity.client.ISingleAccountPublicClientApplication;
import com.microsoft.identity.client.PoPAuthenticationScheme;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.common.exception.ClientException;
import com.microsoft.identity.common.internal.ui.browser.BrowserSelector;
import java.util.ArrayList;
import java.util.List;
public class SingleAccountModeWrapper extends MsalWrapper {
    private ISingleAccountPublicClientApplication mApp;
    public SingleAccountModeWrapper(ISingleAccountPublicClientApplication app) {
        mApp = app;
    }
    @Override
    public String getMode() {
        if (mApp.isSharedDevice()) {
            return "Single Account - Shared device";
        }
        return "Single Account - Non-shared device";
    }
    @Override
    public String getDefaultBrowser() {
        try {
            return BrowserSelector.select(mApp.getConfiguration().getAppContext(), mApp.getConfiguration().getBrowserSafeList()).getPackageName();
        } catch (ClientException e) {
            return "Unknown";
        }
    }
    @Override
    public void loadAccounts(final @NonNull INotifyOperationResultCallback<List<IAccount>> callback) {
        mApp.getCurrentAccountAsync(new ISingleAccountPublicClientApplication.CurrentAccountCallback() {
            @Override
            public void onAccountLoaded(@Nullable IAccount activeAccount) {
                List<IAccount> accountList = new ArrayList<>();
                if (activeAccount != null) {
                    accountList.add(activeAccount);
                }
                callback.onSuccess(accountList);
            }
            @Override
            public void onAccountChanged(@Nullable IAccount priorAccount, @Nullable IAccount currentAccount) {
                callback.showMessage(
                        "signed-in account is changed from "
                                + (null == priorAccount ? "null" : priorAccount.getUsername())
                                + " to "
                                + (null == currentAccount ? "null" : currentAccount.getUsername()));
            }
            @Override
            public void onError(MsalException exception) {
                callback.showMessage(
                        "Failed to load account from broker. "
                                + "Error code: " + exception.getErrorCode()
                                + " Error Message: " + exception.getMessage()
                );
            }
        });
    }
    @Override
    public void removeAccount(@NonNull IAccount account,
                              @NonNull final INotifyOperationResultCallback<Void> callback) {
        mApp.signOut(new ISingleAccountPublicClientApplication.SignOutCallback() {
            @Override
            public void onSignOut() {
                callback.showMessage("The account is successfully signed out.");
                callback.onSuccess(null);
            }
            @Override
            public void onError(@NonNull MsalException exception) {
                callback.showMessage("Failed to sign out: " + exception.getMessage());
            }
        });
    }
    @Override
    void acquireTokenAsyncInternal(@NonNull AcquireTokenParameters parameters) {
        mApp.acquireToken(parameters);
    }
    @Override
    void acquireTokenSilentAsyncInternal(@NonNull AcquireTokenSilentParameters parameters) {
        mApp.acquireTokenSilentAsync(parameters);
    }
    @Override
    void acquireTokenWithDeviceCodeFlowInternal(@NonNull String[] scopes,
                                                @NonNull final IPublicClientApplication.DeviceCodeFlowCallback callback) {
        mApp.acquireTokenWithDeviceCode(scopes, callback);
    }
    @Override
    public void generateSignedHttpRequestInternal(@NonNull final IAccount account,
                                                  @NonNull final PoPAuthenticationScheme params,
                                                  @NonNull final INotifyOperationResultCallback<String> generateShrCallback) {
        mApp.generateSignedHttpRequest(
                account,
                params,
                new IPublicClientApplication.SignedHttpRequestRequestCallback() {
                    @Override
                    public void onTaskCompleted(String result) {
                        generateShrCallback.onSuccess(result);
                    }
                    @Override
                    public void onError(MsalException exception) {
                        generateShrCallback.showMessage(exception.getMessage());
                    }
                }
        );
    }
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import android.app.Activity;
import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Handler;
import android.os.Looper;
import android.text.TextUtils;
import android.util.Pair;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.WorkerThread;
import androidx.fragment.app.Fragment;
import com.microsoft.identity.client.claims.ClaimsRequest;
import com.microsoft.identity.client.configuration.AccountMode;
import com.microsoft.identity.client.configuration.HttpConfiguration;
import com.microsoft.identity.client.configuration.LoggerConfiguration;
import com.microsoft.identity.client.exception.MsalArgumentException;
import com.microsoft.identity.client.exception.MsalClientException;
import com.microsoft.identity.client.exception.MsalDeclinedScopeException;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.client.exception.MsalServiceException;
import com.microsoft.identity.client.exception.MsalUiRequiredException;
import com.microsoft.identity.client.helper.BrokerHelperActivity;
import com.microsoft.identity.client.internal.AsyncResult;
import com.microsoft.identity.client.internal.CommandParametersAdapter;
import com.microsoft.identity.client.internal.controllers.MSALControllerFactory;
import com.microsoft.identity.client.internal.controllers.MsalExceptionAdapter;
import com.microsoft.identity.common.adal.internal.cache.IStorageHelper;
import com.microsoft.identity.common.adal.internal.cache.StorageHelper;
import com.microsoft.identity.common.adal.internal.tokensharing.ITokenShareResultInternal;
import com.microsoft.identity.common.adal.internal.tokensharing.TokenShareUtility;
import com.microsoft.identity.common.exception.BaseException;
import com.microsoft.identity.common.exception.ClientException;
import com.microsoft.identity.common.exception.ErrorStrings;
import com.microsoft.identity.common.exception.ServiceException;
import com.microsoft.identity.common.internal.authorities.Authority;
import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAuthority;
import com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryB2CAuthority;
import com.microsoft.identity.common.internal.cache.ICacheRecord;
import com.microsoft.identity.common.internal.cache.IShareSingleSignOnState;
import com.microsoft.identity.common.internal.cache.ISharedPreferencesFileManager;
import com.microsoft.identity.common.internal.cache.MsalOAuth2TokenCache;
import com.microsoft.identity.common.internal.cache.SchemaUtil;
import com.microsoft.identity.common.internal.cache.SharedPreferencesFileManager;
import com.microsoft.identity.common.internal.commands.CommandCallback;
import com.microsoft.identity.common.internal.commands.DeviceCodeFlowCommand;
import com.microsoft.identity.common.internal.commands.DeviceCodeFlowCommandCallback;
import com.microsoft.identity.common.internal.commands.GenerateShrCommand;
import com.microsoft.identity.common.internal.commands.GetDeviceModeCommand;
import com.microsoft.identity.common.internal.commands.InteractiveTokenCommand;
import com.microsoft.identity.common.internal.commands.SilentTokenCommand;
import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;
import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;
import com.microsoft.identity.common.internal.commands.parameters.GenerateShrCommandParameters;
import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;
import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;
import com.microsoft.identity.common.internal.controllers.BaseController;
import com.microsoft.identity.common.internal.controllers.CommandDispatcher;
import com.microsoft.identity.common.internal.controllers.ExceptionAdapter;
import com.microsoft.identity.common.internal.controllers.LocalMSALController;
import com.microsoft.identity.common.internal.dto.AccountRecord;
import com.microsoft.identity.common.internal.eststelemetry.PublicApiId;
import com.microsoft.identity.common.internal.logging.Logger;
import com.microsoft.identity.common.internal.migration.AdalMigrationAdapter;
import com.microsoft.identity.common.internal.migration.TokenMigrationCallback;
import com.microsoft.identity.common.internal.migration.TokenMigrationUtility;
import com.microsoft.identity.common.internal.net.HttpRequest;
import com.microsoft.identity.common.internal.net.cache.HttpCache;
import com.microsoft.identity.common.internal.providers.microsoft.MicrosoftAccount;
import com.microsoft.identity.common.internal.providers.microsoft.MicrosoftRefreshToken;
import com.microsoft.identity.common.internal.providers.microsoft.azureactivedirectory.AzureActiveDirectory;
import com.microsoft.identity.common.internal.providers.oauth2.OAuth2TokenCache;
import com.microsoft.identity.common.internal.result.GenerateShrResult;
import com.microsoft.identity.common.internal.result.ILocalAuthenticationResult;
import com.microsoft.identity.common.internal.result.LocalAuthenticationResult;
import com.microsoft.identity.common.internal.result.ResultFuture;
import com.microsoft.identity.msal.BuildConfig;
import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import static com.microsoft.identity.client.PublicClientApplicationConfigurationFactory.initializeConfiguration;
import static com.microsoft.identity.client.exception.MsalClientException.SAPCA_USE_WITH_MULTI_POLICY_B2C;
import static com.microsoft.identity.client.exception.MsalClientException.UNKNOWN_ERROR;
import static com.microsoft.identity.client.internal.CommandParametersAdapter.createGenerateShrCommandParameters;
import static com.microsoft.identity.client.internal.MsalUtils.throwOnMainThread;
import static com.microsoft.identity.client.internal.MsalUtils.validateNonNullArg;
import static com.microsoft.identity.client.internal.MsalUtils.validateNonNullArgument;
import static com.microsoft.identity.client.internal.controllers.MsalExceptionAdapter.msalExceptionFromBaseException;
import static com.microsoft.identity.common.exception.ClientException.TOKEN_CACHE_ITEM_NOT_FOUND;
import static com.microsoft.identity.common.exception.ClientException.TOKEN_SHARING_DESERIALIZATION_ERROR;
import static com.microsoft.identity.common.exception.ClientException.TOKEN_SHARING_MSA_PERSISTENCE_ERROR;
import static com.microsoft.identity.common.exception.ErrorStrings.MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_CODE;
import static com.microsoft.identity.common.exception.ErrorStrings.MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_MESSAGE;
import static com.microsoft.identity.common.exception.ErrorStrings.MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ON_SHARED_DEVICE_ERROR_CODE;
import static com.microsoft.identity.common.exception.ErrorStrings.MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ON_SHARED_DEVICE_ERROR_MESSAGE;
import static com.microsoft.identity.common.exception.ErrorStrings.MULTIPLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_CODE;
import static com.microsoft.identity.common.exception.ErrorStrings.MULTIPLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_MESSAGE;
import static com.microsoft.identity.common.exception.ErrorStrings.SINGLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_CODE;
import static com.microsoft.identity.common.exception.ErrorStrings.SINGLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_MESSAGE;
import static com.microsoft.identity.common.exception.ErrorStrings.SINGLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_CODE;
import static com.microsoft.identity.common.exception.ErrorStrings.SINGLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_MESSAGE;
import static com.microsoft.identity.common.internal.authorities.AzureActiveDirectoryAudience.isHomeTenantAlias;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.PCA_GENERATE_SIGNED_HTTP_REQUEST;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.PCA_GENERATE_SIGNED_HTTP_REQUEST_ASYNC;
import static com.microsoft.identity.common.internal.providers.microsoft.MicrosoftIdToken.TENANT_ID;
import static com.microsoft.identity.common.internal.util.StringUtil.isUuid;
/**
 * <p>
 * This is the entry point for developer to create public native applications and make API calls to
 * acquire tokens.
 * <p><b>Client ID:</b> The clientID of your application is a unique identifier which can be
 * obtained from the app registration portal.</p>
 * <p><b>AuthorityMetadata:</b> A URL indicating a directory that MSAL can use to obtain tokens.
 * In Azure AD it is of the form https://<[nstance]/[tenant], where [instance] is the directory
 * host (e.g. https://login.microsoftonline.com) and [tenant] is an identifier within the directory
 * itself (e.g. a domain associated to the tenant, such as contoso.onmicrosoft.com, or the GUID
 * representing the  TenantID property of the directory)
 * <p>
 * For B2C, it is of the form https://[instance]/tfp/[tenant]/[policy] where instance and tenant
 * are same as Azure AD, and [policy] is a string like signup</p>
 * MSAL {@link PublicClientApplication} provides three constructors allowing the client id to be
 * set either via AndroidManifest.xml metadata or using constructor parameters.
 * Similarly, if developer chooses not to use the default authority
 * https://login.microsoftonline.com, an alternate can also be configured using the manifest,
 * constructor parameters, or in acquire token calls.
 * </p>
 * <p>
 * Redirect is auto-generated in the library in the format of msal<client-id>://auth, and it cannot
 * be overridden.
 * </p>
 * <p>
 * Developer <b>MUST</b> have {@link BrowserTabActivity} declared in their manifest, which must
 * have the correct intent-filter configured. If the wrong scheme and host is provided, the sdk
 * will fail the {@link PublicClientApplication} creation.
 * <p>
 * Expected format will be:
 * <pre>
 * &lt;activity
 *     android:name="com.microsoft.identity.client.BrowserTabActivity"&gt;
 *     &lt;intent-filter&gt;
 *         &lt;action android:name="android.intent.action.VIEW" /&gt;
 *         &lt;category android:name="android.intent.category.DEFAULT" /&gt;
 *         &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
 *         &lt;data android:scheme="msal&lt;AppClientId&gt;"
 *              android:host="auth" /&gt;
 *     &lt;/intent-filter&gt;
 * &lt;/activity&gt;
 * </pre>
 * </p>
 * <p>Other Terminology:</p>
 * <p>
 * <p><b>Scopes:</b>Permissions that the developers wants included in the access token received .
 * Not all scopes are guaranteed to be included in the access token returned.
 * </p>
 * <p>
 * <b>Login Hint:</b> Usually an email, to pass to the service at the beginning of the
 * interactive authentication flow.
 * </p>
 * <p>
 * <b>Extra Scopes to Consent:</b>  Permissions you want the user to consent to in the same
 * authentication flow,
 * but won't be included in the returned access token.
 * </p>
 * </p>
 */
public class PublicClientApplication implements IPublicClientApplication, ITokenShare {
    private static final String TAG = PublicClientApplication.class.getSimpleName();
    private static final String INTERNET_PERMISSION = "android.permission.INTERNET";
    private static final String ACCESS_NETWORK_STATE_PERMISSION = "android.permission.ACCESS_NETWORK_STATE";
    private static final ExecutorService sBackgroundExecutor = Executors.newCachedThreadPool();
    static class NONNULL_CONSTANTS {
        static final String CONTEXT = "context";
        static final String LISTENER = "listener";
        static final String CALLBACK = "callback";
        static final String CLIENT_ID = "client_id";
        static final String AUTHORITY = "authority";
        static final String REDIRECT_URI = "redirect_uri";
        static final String CONFIG_FILE = "config_file";
        static final String ACTIVITY = "activity";
        static final String SCOPES = "scopes";
        static final String ACCOUNT = "account";
        static final String NULL_ERROR_SUFFIX = " cannot be null or empty";
    }
    /**
     * Constant used to signal a home account's tenant id should be used when performing cache
     * lookups relative to creating OperationParams.
     */
    private static final String TSL_MSG_FAILED_TO_SAVE
            = "Failed to save FRT - see getCause() for additional Exception info";
    private static final String TSM_MSG_FAILED_TO_RETRIEVE
            = "Failed to retrieve FRT - see getCause() for additional Exception info";
    protected PublicClientApplicationConfiguration mPublicClientConfiguration;
    protected TokenShareUtility mTokenShareUtility;
    //region PCA factory methods
    /**
     * {@link PublicClientApplication#create(Context, int, ApplicationCreatedListener)} will read
     * the client id and other configuration settings from the
     * file included in your application resources.
     *
     * @param context              Application's {@link Context}. The sdk requires the application
     *                             context to be passed in
     *                             {@link PublicClientApplication}. Cannot be null.
     *                             <p>
     *                             Note: The {@link Context} should be the application context
     *                             instead of the running activity's context, which could
     *                             potentially make the sdk hold a
     *                             strong reference to the activity, thus preventing correct
     *                             garbage collection and causing bugs.
     *                             </p>
     * @param configFileResourceId The resource ID of the raw file containing the JSON
     *                             configuration for the PublicClientApplication.
     *                             <p>
     *                             For more information on the schema of the MSAL config json,
     *                             please see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                             and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                             </p>
     * @param listener             a callback to be invoked when the object is successfully created.
     *                             Cannot be null.
     * @see PublicClientApplication#create(Context, File, ApplicationCreatedListener)
     * @see PublicClientApplication#create(Context, String, String, String, ApplicationCreatedListener)
     * @see PublicClientApplication#create(Context, int)
     */
    public static void create(@NonNull final Context context,
                              final int configFileResourceId,
                              @NonNull final ApplicationCreatedListener listener) {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        validateNonNullArgument(listener, NONNULL_CONSTANTS.LISTENER);
        runOnBackground(new Runnable() {
            @Override
            public void run() {
                create(
                        initializeConfiguration(context, configFileResourceId),
                        null, // client id
                        null, // authority
                        null, // redirect uri
                        listener
                );
            }
        });
    }
    /**
     * {@link PublicClientApplication#create(Context, File, ApplicationCreatedListener)}
     * will read the client id and other configuration settings from the specified file.
     *
     * @param context    Application's {@link Context}. The sdk requires the application context to
     *                   be passed in {@link PublicClientApplication}. Cannot be null.
     *                   <p>
     *                   Note: The {@link Context} should be the application context instead of the
     *                   running activity's context, which could potentially make the sdk hold a
     *                   strong reference to the activity, thus preventing correct garbage
     *                   collection and causing bugs.
     *                   </p>
     * @param configFile The file containing the JSON configuration for the PublicClientApplication.
     *                   Cannot be null.
     *                   <p>
     *                   For more information on the schema of the MSAL configuration file, please
     *                   see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                   and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                   </p>
     * @param listener   a callback to be invoked when the object is successfully created. Cannot be null.
     * @see PublicClientApplication#create(Context, int, ApplicationCreatedListener)
     * @see PublicClientApplication#create(Context, String, String, String, ApplicationCreatedListener)
     * @see PublicClientApplication#create(Context, int)
     */
    public static void create(@NonNull final Context context,
                              @NonNull final File configFile,
                              @NonNull final ApplicationCreatedListener listener) {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        validateNonNullArgument(listener, NONNULL_CONSTANTS.LISTENER);
        runOnBackground(new Runnable() {
            @Override
            public void run() {
                create(
                        initializeConfiguration(context, configFile),
                        null, // client id
                        null, // authority
                        null, // redirect uri
                        listener
                );
            }
        });
    }
    /**
     * {@link PublicClientApplication#create(Context, String, String, ApplicationCreatedListener)}
     * allows the client id and authority to be passed instead of providing them through metadata.
     *
     * @param context     Application's {@link Context}. The sdk requires the application context to
     *                    be passed in
     *                    {@link PublicClientApplication}. Cannot be null.
     *                    <p>
     *                    Note: The {@link Context} should be the application context instead of
     *                    an running activity's context, which could potentially make the sdk hold a
     *                    strong reference to the activity, thus preventing correct garbage
     *                    collection and causing bugs.
     *                    </p>
     * @param clientId    The application client id. Cannot be null.
     * @param authority   The default authority to be used for the authority. If this is null, the default authority will be used.
     * @param redirectUri The redirect URI of the application.
     * @param listener    a callback to be invoked when the object is successfully created.
     *                    Cannot be null.
     * @see PublicClientApplication#create(Context, int, ApplicationCreatedListener)
     * @see PublicClientApplication#create(Context, File, ApplicationCreatedListener)
     * @see PublicClientApplication#create(Context, int)
     */
    public static void create(@NonNull final Context context,
                              @NonNull final String clientId,
                              @Nullable final String authority,
                              @NonNull final String redirectUri,
                              @NonNull final ApplicationCreatedListener listener) {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        validateNonNullArgument(clientId, NONNULL_CONSTANTS.CLIENT_ID);
        validateNonNullArgument(redirectUri, NONNULL_CONSTANTS.REDIRECT_URI);
        validateNonNullArgument(listener, NONNULL_CONSTANTS.LISTENER);
        runOnBackground(new Runnable() {
            @Override
            public void run() {
                create(
                        initializeConfiguration(context),
                        clientId,
                        authority,
                        redirectUri,
                        listener
                );
            }
        });
    }
    /**
     * {@link PublicClientApplication#create(Context, int, ApplicationCreatedListener)}
     * will read the client id and other configuration settings from the file included in your
     * application's resources.
     *
     * @param context              Application's {@link Context}. The sdk requires the application
     *                             context to be passed in
     *                             {@link PublicClientApplication}. Cannot be null.
     *                             <p>
     *                             Note: The {@link Context} should be the application context
     *                             instead of the running activity's context, which could
     *                             potentially make the sdk hold a
     *                             strong reference to the activity, thus preventing correct
     *                             garbage collection and causing bugs.
     *                             </p>
     * @param configFileResourceId The resource ID of the raw file containing the JSON
     *                             configuration for the PublicClientApplication
     *                             <p>
     *                             For more information on the schema of the MSAL config json,
     *                             please see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                             and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                             </p>
     * @return An instance of IPublicClientApplication.
     * @throws IllegalStateException if this function is invoked on the main thread.
     * @see PublicClientApplication#create(Context, int, ApplicationCreatedListener)
     * @see PublicClientApplication#create(Context, File, ApplicationCreatedListener)
     * @see PublicClientApplication#create(Context, String, String, String, ApplicationCreatedListener)
     */
    @WorkerThread
    @NonNull
    public static IPublicClientApplication create(@NonNull final Context context,
                                                  final int configFileResourceId) throws InterruptedException, MsalException {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        return create(initializeConfiguration(context, configFileResourceId));
    }
    //endregion
    //region Multiple Account PCA factory methods.
    /**
     * {@link PublicClientApplication#createMultipleAccountPublicClientApplication(Context, int, IMultipleAccountApplicationCreatedListener)}
     * will read the client id and other configuration settings from the file included in your
     * application's resources.
     *
     * <p><p>This function will pass back an {@link MsalClientException} object if it is unable to
     * return {@link IMultipleAccountPublicClientApplication}.
     * For example, when the device is marked as 'shared'
     * ({@link PublicClientApplication#isSharedDevice()} is set to true) </p></p>
     *
     * @param context              Application's {@link Context}. The sdk requires the application
     *                             context to be passed in {@link PublicClientApplication}.
     *                             Cannot be null.
     *                             <p>
     *                             Note: The {@link Context} should be the application context
     *                             instead of the running activity's context, which could
     *                             potentially make the sdk hold a
     *                             strong reference to the activity, thus preventing correct
     *                             garbage collection and causing bugs.
     *                             </p>
     * @param configFileResourceId The resource ID of the raw file containing the JSON
     *                             configuration for the PublicClientApplication.
     *                             <p>
     *                             For more information on the schema of the MSAL config json,
     *                             please see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                             and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                             </p>
     * @param listener             a callback to be invoked when the object is successfully created. Cannot be null.
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, File, IMultipleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, int)
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, File)
     */
    public static void createMultipleAccountPublicClientApplication(@NonNull final Context context,
                                                                    final int configFileResourceId,
                                                                    @NonNull final IMultipleAccountApplicationCreatedListener listener) {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        validateNonNullArgument(listener, NONNULL_CONSTANTS.LISTENER);
        runOnBackground(new Runnable() {
            @Override
            public void run() {
                createMultipleAccountPublicClientApplication(
                        initializeConfiguration(context, configFileResourceId),
                        listener
                );
            }
        });
    }
    /**
     * {@link PublicClientApplication#createMultipleAccountPublicClientApplication(Context, File, IMultipleAccountApplicationCreatedListener)}
     * will read the client id and other configuration settings from the
     * file included in your application resources.
     *
     * <p><p>This function will pass back an {@link MsalClientException} object if it is unable to
     * return {@link IMultipleAccountPublicClientApplication}. For example, when the device is
     * marked as 'shared' ({@link PublicClientApplication#isSharedDevice()} is set to true) </p></p>
     *
     * @param context    Application's {@link Context}. The sdk requires the application context to
     *                   be passed in {@link PublicClientApplication}. Cannot be null.
     *                   <p>
     *                   Note: The {@link Context} should be the application context instead of the
     *                   running activity's context, which could potentially make the sdk hold a
     *                   strong reference to the activity, thus preventing correct garbage
     *                   collection and causing bugs.
     *                   </p>
     * @param configFile The file containing the JSON configuration for the PublicClientApplication.
     *                   Cannot be null.
     *                   <p>
     *                   For more information on the schema of the MSAL config json, please see
     *                   <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                   and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                   </p>
     * @param listener   a callback to be invoked when the object is successfully created. Cannot be null.
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, int, IMultipleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, int)
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, File)
     */
    public static void createMultipleAccountPublicClientApplication(@NonNull final Context context,
                                                                    @NonNull final File configFile,
                                                                    @NonNull final IMultipleAccountApplicationCreatedListener listener) {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        validateNonNullArgument(listener, NONNULL_CONSTANTS.LISTENER);
        runOnBackground(new Runnable() {
            @Override
            public void run() {
                createMultipleAccountPublicClientApplication(
                        initializeConfiguration(context, configFile),
                        listener
                );
            }
        });
    }
    /**
     * {@link PublicClientApplication#createMultipleAccountPublicClientApplication(Context, int)}
     * will read the client id and other configuration settings from the file included in your
     * application's resources.
     *
     * <p><p>This function will pass back an {@link MsalClientException} object if it is unable to
     * return {@link IMultipleAccountPublicClientApplication}. For example, when the device is
     * marked as 'shared' ({@link PublicClientApplication#isSharedDevice()} is set to true) </p></p>
     *
     * @param context              Application's {@link Context}. The sdk requires the application
     *                             context to be passed in
     *                             {@link PublicClientApplication}. Cannot be null.
     *                             <p>
     *                             Note: The {@link Context} should be the application context
     *                             instead of the running activity's context, which could
     *                             potentially make the sdk hold a
     *                             strong reference to the activity, thus preventing correct
     *                             garbage collection and causing bugs.
     *                             </p>
     * @param configFileResourceId The resource ID of the raw file containing the JSON
     *                             configuration for the PublicClientApplication.
     *                             <p>
     *                             For more information on the schema of the MSAL config json,
     *                             please see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                             and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                             </p>
     * @return An instance of IMultipleAccountPublicClientApplication.
     * @throws IllegalStateException if this function is invoked on the main thread.
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, int, IMultipleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, File, IMultipleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, File)
     */
    @WorkerThread
    @NonNull
    public static IMultipleAccountPublicClientApplication createMultipleAccountPublicClientApplication(@NonNull final Context context,
                                                                                                       @NonNull final int configFileResourceId) throws MsalException, InterruptedException {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        return createMultipleAccountPublicClientApplication(
                initializeConfiguration(context, configFileResourceId)
        );
    }
    /**
     * {@link PublicClientApplication#createMultipleAccountPublicClientApplication(Context, File)}
     * will read the client id and other configuration settings from the
     * file included in your application resources.
     *
     * <p><p>This function will pass back an {@link MsalClientException} object if it is unable
     * to return {@link IMultipleAccountPublicClientApplication}. For example, when the device is
     * marked as 'shared' ({@link PublicClientApplication#isSharedDevice()} is set to true) </p></p>
     *
     * @param context    Application's {@link Context}. The sdk requires the application context
     *                   to be passed in {@link PublicClientApplication}. Cannot be null.
     *                   <p>
     *                   Note: The {@link Context} should be the application context instead of
     *                   the running activity's context, which could potentially make the sdk hold a
     *                   strong reference to the activity, thus preventing correct garbage
     *                   collection and causing bugs.
     *                   </p>
     * @param configFile The file containing the JSON configuration for the PublicClientApplication.
     *                   Cannot be null.
     *                   <p>
     *                   For more information on the schema of the MSAL configuration file, please
     *                   see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                   and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                   </p>
     * @throws IllegalStateException if this function is invoked on the main thread.
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, int, IMultipleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, File, IMultipleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createMultipleAccountPublicClientApplication(Context, int)
     */
    @WorkerThread
    @NonNull
    public static IMultipleAccountPublicClientApplication createMultipleAccountPublicClientApplication(@NonNull final Context context,
                                                                                                       @NonNull final File configFile) throws InterruptedException, MsalException {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        validateNonNullArgument(configFile, "configFile");
        return createMultipleAccountPublicClientApplication(
                initializeConfiguration(context, configFile)
        );
    }
    //endregion
    //region Single Account PCA factory methods.
    /**
     * {@link PublicClientApplication#createSingleAccountPublicClientApplication(Context, int, ISingleAccountApplicationCreatedListener)}
     * will read the client id and other configuration settings from the file included in your
     * application's resources.
     *
     * <p><p>This function will pass back an {@link MsalClientException} object if it is unable to
     * return {@link ISingleAccountApplicationCreatedListener}. For example, AccountMode in
     * configuration is not set to single. </p></p>
     *
     * @param context              Application's {@link Context}. The sdk requires the application
     *                             context to be passed in {@link PublicClientApplication}.
     *                             Cannot be null.
     *                             <p>
     *                             Note: The {@link Context} should be the application context
     *                             instead of the running activity's context, which could
     *                             potentially make the sdk hold a
     *                             strong reference to the activity, thus preventing correct
     *                             garbage collection and causing bugs.
     *                             </p>
     * @param configFileResourceId The resource ID of the raw file containing the JSON
     *                             configuration for the PublicClientApplication.
     *                             <p>
     *                             For more information on the schema of the MSAL config json,
     *                             please see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                             and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                             </p>
     * @param listener             a callback to be invoked when the object is successfully created.
     *                             Cannot be null.
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, File, ISingleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, int)
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, File)
     */
    public static void createSingleAccountPublicClientApplication(@NonNull final Context context,
                                                                  final int configFileResourceId,
                                                                  @NonNull final ISingleAccountApplicationCreatedListener listener) {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        validateNonNullArgument(listener, NONNULL_CONSTANTS.LISTENER);
        runOnBackground(new Runnable() {
            @Override
            public void run() {
                createSingleAccountPublicClientApplication(
                        initializeConfiguration(context, configFileResourceId),
                        listener
                );
            }
        });
    }
    /**
     * {@link PublicClientApplication#createSingleAccountPublicClientApplication(Context, int, ISingleAccountApplicationCreatedListener)}
     * will read the client id and other configuration settings from the file included in your
     * application resources.
     *
     * <p><p>This function will pass back an {@link MsalClientException} object if it is unable to
     * return {@link ISingleAccountApplicationCreatedListener}. For example, AccountMode in
     * configuration is not set to single. </p></p>
     *
     * @param context    Application's {@link Context}. The sdk requires the application context
     *                   to be passed in {@link PublicClientApplication}. Cannot be null.
     *                   <p>
     *                   Note: The {@link Context} should be the application context instead of the
     *                   running activity's context, which could potentially make the sdk hold a
     *                   strong reference to the activity, thus preventing correct garbage
     *                   collection and causing bugs.
     *                   </p>
     * @param configFile The file containing the JSON configuration for the PublicClientApplication.
     *                   Cannot be null.
     *                   <p>
     *                   For more information on the schema of the MSAL configuration file, please
     *                   see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                   and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                   </p>
     * @param listener   a callback to be invoked when the object is successfully created. Cannot be null.
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, int, ISingleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, int)
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, File)
     */
    public static void createSingleAccountPublicClientApplication(@NonNull final Context context,
                                                                  @NonNull final File configFile,
                                                                  @NonNull final ISingleAccountApplicationCreatedListener listener) {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        validateNonNullArgument(configFile, NONNULL_CONSTANTS.CONFIG_FILE);
        validateNonNullArgument(listener, NONNULL_CONSTANTS.LISTENER);
        runOnBackground(new Runnable() {
            @Override
            public void run() {
                createSingleAccountPublicClientApplication(
                        initializeConfiguration(context, configFile),
                        listener
                );
            }
        });
    }
    /**
     * {@link PublicClientApplication#createSingleAccountPublicClientApplication(Context, int)}
     * will read the client id and other configuration settings from the file included in your
     * application's resources.
     *
     * <p><p>This function will pass back an {@link MsalClientException} object if it is unable
     * to return {@link ISingleAccountApplicationCreatedListener}. For example, AccountMode in
     * configuration is not set to single. </p></p>
     *
     * @param context              Application's {@link Context}. The sdk requires the application
     *                             context to be passed in {@link PublicClientApplication}.
     *                             Cannot be null.
     *                             <p>
     *                             Note: The {@link Context} should be the application context
     *                             instead of the running activity's context, which could
     *                             potentially make the sdk hold a strong reference to the activity,
     *                             thus preventing correct garbage collection and causing bugs.
     *                             </p>
     * @param configFileResourceId The resource ID of the raw file containing the JSON configuration
     *                             for the PublicClientApplication.
     *                             <p>
     *                             For more information on the schema of the MSAL config json,
     *                             please see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                             and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                             </p>
     * @return An instance of ISingleAccountPublicClientApplication.
     * @throws IllegalStateException if this function is invoked on the main thread.
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, File, ISingleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, int, ISingleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, File)
     */
    @WorkerThread
    @NonNull
    public static ISingleAccountPublicClientApplication createSingleAccountPublicClientApplication(
            @NonNull final Context context,
            final int configFileResourceId) throws InterruptedException, MsalException {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        return createSingleAccountPublicClientApplication(
                initializeConfiguration(context, configFileResourceId)
        );
    }
    /**
     * {@link PublicClientApplication#createSingleAccountPublicClientApplication(Context, int)}
     * will read the client id and other configuration settings from the file included in your
     * applications resources.
     *
     * <p><p>This function will pass back an {@link MsalClientException} object if it is unable
     * to return {@link ISingleAccountApplicationCreatedListener}. For example, AccountMode in
     * configuration is not set to single. </p></p>
     *
     * @param context    Application's {@link Context}. The sdk requires the application context
     *                   to be passed in {@link PublicClientApplication}. Cannot be null.
     *                   <p>
     *                   Note: The {@link Context} should be the application context instead of
     *                   the running activity's context, which could potentially make the sdk hold a
     *                   strong reference to the activity, thus preventing correct garbage
     *                   collection and causing bugs.
     *                   </p>
     * @param configFile The file containing the JSON configuration for the PublicClientApplication.
     *                   Cannot be null.
     *                   <p>
     *                   For more information on the schema of the MSAL configuration file,
     *                   please see <a href="https://developer.android.com/guide/topics/resources/providing-resources">Android app resource overview</a>
     *                   and <a href="https://github.com/AzureAD/microsoft-authentication-library-for-android/wiki">MSAL Github Wiki</a>
     *                   </p>
     * @return An instance of ISingleAccountPublicClientApplication.
     * @throws IllegalStateException if this function is invoked on the main thread.
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, File, ISingleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, int, ISingleAccountApplicationCreatedListener)
     * @see PublicClientApplication#createSingleAccountPublicClientApplication(Context, int)
     */
    @WorkerThread
    @NonNull
    public static ISingleAccountPublicClientApplication createSingleAccountPublicClientApplication(
            @NonNull final Context context,
            @Nullable final File configFile) throws InterruptedException, MsalException {
        validateNonNullArgument(context, NONNULL_CONSTANTS.CONTEXT);
        return createSingleAccountPublicClientApplication(
                initializeConfiguration(context, configFile)
        );
    }
    //endregion
    //region internal factory methods.
    @WorkerThread
    private static IPublicClientApplication create(
            @NonNull final PublicClientApplicationConfiguration configuration)
            throws MsalException, InterruptedException {
        validateNonNullArgument(configuration, "configuration");
        throwOnMainThread("createPublicClientApplication");
        final ResultFuture<AsyncResult<IPublicClientApplication>> future = new ResultFuture<>();
        create(configuration,
                null, // client id
                null, // authority
                null, // redirectUri
                new ApplicationCreatedListener() {
                    @Override
                    public void onCreated(final IPublicClientApplication application) {
                        future.setResult(new AsyncResult<>(application, null));
                    }
                    @Override
                    public void onError(final MsalException exception) {
                        future.setResult(new AsyncResult<IPublicClientApplication>(null, exception));
                    }
                }
        );
        //Blocking Call
        try {
            AsyncResult<IPublicClientApplication> result = future.get();
            if (!result.getSuccess()) {
                //Exception thrown
                MsalException ex = result.getException();
                throw ex;
            }
            return result.getResult();
        } catch (final ExecutionException e) {
            // Shouldn't be thrown.
            throw new MsalClientException(
                    UNKNOWN_ERROR,
                    "Unexpected error while initializing PCA.",
                    e
            );
        }
    }
    @WorkerThread
    private static IMultipleAccountPublicClientApplication createMultipleAccountPublicClientApplication(
            @NonNull final PublicClientApplicationConfiguration configuration)
            throws InterruptedException, MsalException {
        if (configuration.getAccountMode() != AccountMode.MULTIPLE) {
            throw new MsalClientException(
                    MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_CODE,
                    MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_MESSAGE
            );
        }
        final IPublicClientApplication application = create(configuration);
        if (application instanceof IMultipleAccountPublicClientApplication) {
            return (IMultipleAccountPublicClientApplication) application;
        } else {
            if (configuration.getAccountMode() == AccountMode.MULTIPLE && application.isSharedDevice()) {
                throw new MsalClientException(
                        MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ON_SHARED_DEVICE_ERROR_CODE,
                        MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ON_SHARED_DEVICE_ERROR_MESSAGE
                );
            }
            throw new MsalClientException(
                    MULTIPLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_CODE,
                    MULTIPLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_MESSAGE
            );
        }
    }
    @WorkerThread
    private static ISingleAccountPublicClientApplication createSingleAccountPublicClientApplication(
            @Nullable final PublicClientApplicationConfiguration configuration)
            throws InterruptedException, MsalException {
        final IPublicClientApplication application = create(configuration);
        if (application instanceof ISingleAccountPublicClientApplication) {
            return (ISingleAccountPublicClientApplication) application;
        } else {
            if (configuration.getAccountMode() != AccountMode.SINGLE) {
                throw new MsalClientException(
                        SINGLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_CODE,
                        SINGLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_MESSAGE
                );
            }
            throw new MsalClientException(
                    SINGLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_CODE,
                    SINGLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_MESSAGE
            );
        }
    }
    private static void create(@NonNull final PublicClientApplicationConfiguration config,
                               @Nullable final String clientId,
                               @Nullable final String authority,
                               @Nullable final String redirectUri,
                               @NonNull final ApplicationCreatedListener listener) {
        if (clientId != null) {
            config.setClientId(clientId);
        }
        if (authority != null) {
            config.getAuthorities().clear();
            final Authority authorityObject = Authority.getAuthorityFromAuthorityUrl(authority);
            authorityObject.setDefault(true);
            config.getAuthorities().add(authorityObject);
        }
        if (redirectUri != null) {
            config.setRedirectUri(redirectUri);
        }
        try {
            validateAccountModeConfiguration(config);
        } catch (final MsalClientException e) {
            listener.onError(e);
            return;
        }
        final CommandParameters params = CommandParametersAdapter.createCommandParameters(config, config.getOAuth2TokenCache());
        final BaseController controller;
        try {
            controller = MSALControllerFactory.getDefaultController(
                    config.getAppContext(),
                    config.getDefaultAuthority(),
                    config);
        } catch (MsalClientException e) {
            listener.onError(e);
            return;
        }
        final GetDeviceModeCommand command = new GetDeviceModeCommand(
                params,
                controller,
                new CommandCallback<Boolean, BaseException>() {
                    @Override
                    public void onError(BaseException error) {
                        listener.onError(MsalExceptionAdapter.msalExceptionFromBaseException(error));
                    }
                    @Override
                    public void onTaskCompleted(Boolean isSharedDevice) {
                        config.setIsSharedDevice(isSharedDevice);
                        try {
                            if (config.getAccountMode() == AccountMode.SINGLE || isSharedDevice) {
                                listener.onCreated(new SingleAccountPublicClientApplication(config));
                            } else {
                                listener.onCreated(new MultipleAccountPublicClientApplication(config));
                            }
                        } catch (final MsalClientException e) {
                            listener.onError(e);
                        }
                    }
                    @Override
                    public void onCancel() {
                        // Should not be reached.
                    }
                },
                null
        );
        CommandDispatcher.submitSilent(command);
    }
    private static void validateAccountModeConfiguration(@NonNull final PublicClientApplicationConfiguration config) throws MsalClientException {
        if (config.getAccountMode() == AccountMode.SINGLE
                && null != config.getDefaultAuthority()
                && config.getDefaultAuthority() instanceof AzureActiveDirectoryB2CAuthority) {
            Logger.warn(
                    TAG,
                    "Warning! B2C applications should use MultipleAccountPublicClientApplication. "
                            + "Use of SingleAccount mode with multiple IEF policies is unsupported."
            );
            if (config.getAuthorities().size() > 1) {
                throw new MsalClientException(SAPCA_USE_WITH_MULTI_POLICY_B2C);
            }
        }
    }
    private static void createMultipleAccountPublicClientApplication(
            @NonNull final PublicClientApplicationConfiguration configuration,
            @NonNull final IMultipleAccountApplicationCreatedListener listener) {
        create(configuration,
                null, // client id
                null, // authority
                null, // redirect uri
                new ApplicationCreatedListener() {
                    @Override
                    public void onCreated(@NonNull final IPublicClientApplication application) {
                        if (application instanceof IMultipleAccountPublicClientApplication) {
                            listener.onCreated((IMultipleAccountPublicClientApplication) application);
                        } else {
                            if (application.getConfiguration().getAccountMode() == AccountMode.MULTIPLE
                                    && application.isSharedDevice()) {
                                listener.onError(
                                        new MsalClientException(
                                                MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ON_SHARED_DEVICE_ERROR_CODE,
                                                MULTIPLE_ACCOUNT_PCA_INIT_FAIL_ON_SHARED_DEVICE_ERROR_MESSAGE
                                        )
                                );
                                return;
                            }
                            listener.onError(
                                    new MsalClientException(
                                            MULTIPLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_CODE,
                                            MULTIPLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_MESSAGE
                                    )
                            );
                        }
                    }
                    @Override
                    public void onError(final MsalException exception) {
                        listener.onError(exception);
                    }
                }
        );
    }
    private static void createSingleAccountPublicClientApplication(
            @NonNull final PublicClientApplicationConfiguration configuration,
            @NonNull final ISingleAccountApplicationCreatedListener listener) {
        create(
                configuration,
                null, // client id
                null, // authority
                null, // redirect uri
                new ApplicationCreatedListener() {
                    @Override
                    public void onCreated(final IPublicClientApplication application) {
                        if (application instanceof ISingleAccountPublicClientApplication) {
                            listener.onCreated((ISingleAccountPublicClientApplication) application);
                        } else {
                            if (application.getConfiguration().getAccountMode() != AccountMode.SINGLE) {
                                listener.onError(
                                        new MsalClientException(
                                                SINGLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_CODE,
                                                SINGLE_ACCOUNT_PCA_INIT_FAIL_ACCOUNT_MODE_ERROR_MESSAGE
                                        )
                                );
                                return;
                            }
                            listener.onError(
                                    new MsalClientException(
                                            SINGLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_CODE,
                                            SINGLE_ACCOUNT_PCA_INIT_FAIL_UNKNOWN_REASON_ERROR_MESSAGE
                                    )
                            );
                        }
                    }
                    @Override
                    public void onError(final MsalException exception) {
                        listener.onError(exception);
                    }
                }
        );
    }
    //endregion
    protected PublicClientApplication(@NonNull final PublicClientApplicationConfiguration configFile) throws MsalClientException {
        mPublicClientConfiguration = configFile;
        initializeApplication();
    }
    private void initializeApplication() throws MsalClientException {
        final String methodName = ":initializeApplication";
        final Context context = mPublicClientConfiguration.getAppContext();
        setupTelemetry(context, mPublicClientConfiguration);
        AzureActiveDirectory.setEnvironment(mPublicClientConfiguration.getEnvironment());
        Authority.addKnownAuthorities(mPublicClientConfiguration.getAuthorities());
        initializeHttpSettings(mPublicClientConfiguration.getHttpConfiguration());
        initializeLoggerSettings(mPublicClientConfiguration.getLoggerConfiguration());
        initializeTokenSharingLibrary();
        mPublicClientConfiguration.checkIntentFilterAddedToAppManifestForBrokerFlow();
        // Since network request is sent from the sdk, if calling app doesn't declare the internet
        // permission in the manifest, we cannot make the network call.
        checkInternetPermission();
        // Init HTTP cache
        HttpCache.initialize(context.getCacheDir());
        com.microsoft.identity.common.internal.logging.Logger.info(
                TAG + methodName,
                "Create new public client application."
        );
    }
    private void initializeLoggerSettings(@Nullable final LoggerConfiguration loggerConfig) {
        if (null != loggerConfig) {
            final com.microsoft.identity.client.Logger.LogLevel configLogLevel = loggerConfig.getLogLevel();
            final boolean configPiiState = loggerConfig.isPiiEnabled();
            final boolean configLogcatState = loggerConfig.isLogcatEnabled();
            final com.microsoft.identity.client.Logger logger = com.microsoft.identity.client.Logger.getInstance();
            if (null != configLogLevel) {
                logger.setLogLevel(configLogLevel);
            }
            logger.setEnablePII(configPiiState);
            logger.setEnableLogcatLog(configLogcatState);
        }
    }
    private void initializeHttpSettings(@Nullable final HttpConfiguration httpConfiguration) {
        final String methodName = ":initializeHttpSettings";
        if (null == httpConfiguration) {
            Logger.info(
                    TAG + methodName,
                    "HttpConfiguration not provided - using defaults."
            );
            return;
        }
        final int readTimeout = httpConfiguration.getReadTimeout();
        final int connectTimeout = httpConfiguration.getConnectTimeout();
        // Configured values must be >= 0
        if (readTimeout >= 0) {
            HttpRequest.READ_TIMEOUT = readTimeout;
        }
        if (connectTimeout >= 0) {
            HttpRequest.CONNECT_TIMEOUT = connectTimeout;
        }
    }
    private void initializeTokenSharingLibrary() {
        if (mPublicClientConfiguration.getOAuth2TokenCache() instanceof MsalOAuth2TokenCache) {
            mTokenShareUtility = new TokenShareUtility(
                    mPublicClientConfiguration.getClientId(),
                    mPublicClientConfiguration.getRedirectUri(),
                    (MsalOAuth2TokenCache) mPublicClientConfiguration.getOAuth2TokenCache()
            );
        } else {
            throw new IllegalStateException("TSL support mandates use of the MsalOAuth2TokenCache");
        }
    }
    private void setupTelemetry(@NonNull final Context context,
                                @NonNull final PublicClientApplicationConfiguration developerConfig) {
        if (null != developerConfig.getTelemetryConfiguration()) {
            com.microsoft.identity.common.internal.logging.Logger.verbose(
                    TAG,
                    "Telemetry configuration is set. Telemetry is enabled."
            );
        } else {
            com.microsoft.identity.common.internal.logging.Logger.verbose(
                    TAG,
                    "Telemetry configuration is null. Telemetry is disabled."
            );
        }
        new com.microsoft.identity.common.internal.telemetry.Telemetry.Builder()
                .withContext(context)
                .defaultConfiguration(developerConfig.getTelemetryConfiguration())
                .build();
    }
    @Override
    public TokenShareResult getOrgIdFamilyRefreshTokenWithMetadata(@NonNull final String identifier) throws MsalClientException {
        validateNonNullArgument(identifier, "identifier");
        validateBrokerNotInUse();
        try {
            final ITokenShareResultInternal resultInternal = mTokenShareUtility.getOrgIdFamilyRefreshTokenWithMetadata(identifier);
            return new TokenShareResult(resultInternal);
        } catch (final Exception e) {
            throw new MsalClientException(
                    TOKEN_CACHE_ITEM_NOT_FOUND,
                    TSM_MSG_FAILED_TO_RETRIEVE,
                    e
            );
        }
    }
    @Override
    public String getOrgIdFamilyRefreshToken(@NonNull final String identifier) throws MsalClientException {
        return getOrgIdFamilyRefreshTokenWithMetadata(identifier).getRefreshToken();
    }
    @Override
    public void saveOrgIdFamilyRefreshToken(@NonNull final String ssoStateSerializerBlob) throws MsalClientException {
        validateNonNullArgument(ssoStateSerializerBlob, "SsoStateSerializerBlob");
        validateBrokerNotInUse();
        try {
            mTokenShareUtility.saveOrgIdFamilyRefreshToken(ssoStateSerializerBlob);
        } catch (final Exception e) {
            throw new MsalClientException(
                    TOKEN_SHARING_DESERIALIZATION_ERROR,
                    TSL_MSG_FAILED_TO_SAVE,
                    e
            );
        }
    }
    @Override
    public TokenShareResult getMsaFamilyRefreshTokenWithMetadata(@NonNull final String identifier) throws MsalClientException {
        validateNonNullArgument(identifier, "identifier");
        validateBrokerNotInUse();
        try {
            final ITokenShareResultInternal resultInternal = mTokenShareUtility.getMsaFamilyRefreshTokenWithMetadata(identifier);
            return new TokenShareResult(resultInternal);
        } catch (final Exception e) {
            throw new MsalClientException(
                    TOKEN_CACHE_ITEM_NOT_FOUND,
                    TSM_MSG_FAILED_TO_RETRIEVE,
                    e
            );
        }
    }
    @Override
    public String getMsaFamilyRefreshToken(@NonNull final String identifier) throws MsalClientException {
        return getMsaFamilyRefreshTokenWithMetadata(identifier).getRefreshToken();
    }
    @Override
    public void saveMsaFamilyRefreshToken(@NonNull final String refreshToken) throws MsalClientException {
        validateNonNullArgument(refreshToken, "refreshToken");
        // todo: Re-enable this when MSA SSO is fully supported by Broker (PRTv3)
        //validateBrokerNotInUse();
        try {
            mTokenShareUtility.saveMsaFamilyRefreshToken(refreshToken);
        } catch (final Exception e) {
            throw new MsalClientException(
                    TOKEN_SHARING_MSA_PERSISTENCE_ERROR,
                    TSL_MSG_FAILED_TO_SAVE,
                    e
            );
        }
    }
    private void validateBrokerNotInUse() throws MsalClientException {
        if (MSALControllerFactory.brokerEligible(
                mPublicClientConfiguration.getAppContext(),
                mPublicClientConfiguration.getDefaultAuthority(),
                mPublicClientConfiguration
        )) {
            throw new MsalClientException(
                    "Cannot perform this action - broker is enabled."
            );
        }
    }
    /**
     * Listener callback for asynchronous loading of MSAL mode retrieval.
     */
    public interface BrokerDeviceModeCallback {
        /**
         * Called once MSAL mode is retrieved from Broker.
         * If Broker is not installed, this will fall back to the BROKER_ACCOUNT_MODE_MULTIPLE_ACCOUNT mode.
         */
        void onGetMode(final boolean isSharedDevice);
        /**
         * Called once MSAL mode can't be retrieved from Broker.
         */
        void onError(final MsalException exception);
    }
    /**
     * @return The current version for the sdk.
     */
    public static String getSdkVersion() {
        return BuildConfig.VERSION_NAME;
    }
    /**
     * Presents an activity that includes the package name, signature, redirect URI and manifest entry required for your application
     *
     * @param activity
     */
    public static void showExpectedMsalRedirectUriInfo(Activity activity) {
        activity.startActivity(BrokerHelperActivity.createStartIntent(activity.getApplicationContext()));
    }
    @Override
    public PublicClientApplicationConfiguration getConfiguration() {
        return mPublicClientConfiguration;
    }
    @Override
    public boolean isSharedDevice() {
        return mPublicClientConfiguration.getIsSharedDevice();
    }
    @Override
    public String generateSignedHttpRequest(@NonNull final IAccount account,
                                            @NonNull final PoPAuthenticationScheme popParameters) throws MsalException {
        final ResultFuture<AsyncResult<GenerateShrResult>> future = new ResultFuture<>();
        final GenerateShrCommand generateShrCommand = createGenerateShrCommand(
                account,
                popParameters,
                new CommandCallback<GenerateShrResult, BaseException>() {
                    @Override
                    public void onCancel() {
                        // Not cancellable
                    }
                    @Override
                    public void onError(@NonNull final BaseException error) {
                        future.setResult(
                                new AsyncResult<GenerateShrResult>(
                                        null,
                                        baseExceptionToMsalException(error)
                                )
                        );
                    }
                    @Override
                    public void onTaskCompleted(@NonNull final GenerateShrResult generateShrResult) {
                        future.setResult(new AsyncResult<>(generateShrResult, null));
                    }
                },
                PCA_GENERATE_SIGNED_HTTP_REQUEST
        );
        // Execute this command silently...
        CommandDispatcher.submitSilent(generateShrCommand);
        try {
            final AsyncResult<GenerateShrResult> asyncResult = future.get();
            if (asyncResult.getSuccess()) {
                return asyncResult.getResult().getShr();
            } else {
                throw asyncResult.getException();
            }
        } catch (ExecutionException | InterruptedException e) {
            throw new MsalClientException(
                    UNKNOWN_ERROR,
                    "Unexpected error while generating SHR.",
                    e
            );
        }
    }
    @Override
    public void generateSignedHttpRequest(@NonNull final IAccount account,
                                          @NonNull final PoPAuthenticationScheme popParameters,
                                          @NonNull final SignedHttpRequestRequestCallback callback) {
        try {
            final GenerateShrCommand generateShrCommand = createGenerateShrCommand(
                    account,
                    popParameters,
                    new CommandCallback<GenerateShrResult, BaseException>() {
                        @Override
                        public void onCancel() {
                            // Not cancellable
                        }
                        @Override
                        public void onError(@NonNull final BaseException error) {
                            callback.onError(baseExceptionToMsalException(error));
                        }
                        @Override
                        public void onTaskCompleted(@NonNull final GenerateShrResult generateShrResult) {
                            callback.onTaskCompleted(generateShrResult.getShr());
                        }
                    },
                    PCA_GENERATE_SIGNED_HTTP_REQUEST_ASYNC
            );
            // Execute this command silently...
            CommandDispatcher.submitSilent(generateShrCommand);
        } catch (final MsalClientException e) {
            final MsalClientException clientException = new MsalClientException(
                    UNKNOWN_ERROR,
                    "Unexpected error while generating SHR.",
                    e
            );
            callback.onError(clientException);
        }
    }
    private GenerateShrCommand createGenerateShrCommand(@NonNull final IAccount account,
                                                        @NonNull final PoPAuthenticationScheme popParams,
                                                        @NonNull final CommandCallback<GenerateShrResult, BaseException> cmdCallback,
                                                        @NonNull final String publicApiId) throws MsalClientException {
        final GenerateShrCommandParameters cmdParams = createGenerateShrCommandParameters(
                mPublicClientConfiguration,
                mPublicClientConfiguration.getOAuth2TokenCache(),
                ((Account) account).getHomeAccountId(),
                popParams
        );
        return new GenerateShrCommand(
                cmdParams,
                MSALControllerFactory.getAllControllers(
                        mPublicClientConfiguration.getAppContext(),
                        mPublicClientConfiguration.getDefaultAuthority(),
                        mPublicClientConfiguration
                ),
                cmdCallback,
                publicApiId
        );
    }
    private MsalException baseExceptionToMsalException(@NonNull final BaseException exception) {
        if (GenerateShrResult.Errors.NO_ACCOUNT_FOUND.equalsIgnoreCase(exception.getErrorCode())) {
            return new MsalUiRequiredException(
                    GenerateShrResult.Errors.NO_ACCOUNT_FOUND,
                    "The supplied account could not be located."
            );
        }
        return new MsalClientException(exception.getErrorCode(), exception.getMessage());
    }
    @Override
    public void acquireToken(@NonNull final Activity activity,
                             @NonNull final String[] scopes,
                             @NonNull final AuthenticationCallback callback) {
        AcquireTokenParameters acquireTokenParameters = buildAcquireTokenParameters(
                activity,
                null,
                scopes,
                null, // account
                null, // uiBehavior
                null, // extraQueryParams
                null, // extraScopes
                null, // authority
                callback,
                null, // loginHint
                null // claimsRequest
        );
        acquireTokenInternal(acquireTokenParameters, PublicApiId.PCA_ACQUIRE_TOKEN_WITH_ACTIVITY_SCOPES_CALLBACK);
    }
    AcquireTokenParameters buildAcquireTokenParameters(
            @NonNull final Activity activity,
            @Nullable final Fragment fragment,
            @NonNull final String[] scopes,
            @Nullable final IAccount account,
            @Nullable final Prompt uiBehavior,
            @Nullable final List<Pair<String, String>> extraQueryParameters,
            @Nullable final String[] extraScopesToConsent,
            @Nullable final String authority,
            @NonNull final AuthenticationCallback callback,
            @Nullable final String loginHint,
            @Nullable final ClaimsRequest claimsRequest) {
        validateNonNullArgument(activity, NONNULL_CONSTANTS.ACTIVITY);
        validateNonNullArgument(scopes, NONNULL_CONSTANTS.SCOPES);
        validateNonNullArgument(callback, NONNULL_CONSTANTS.CALLBACK);
        AcquireTokenParameters.Builder builder = new AcquireTokenParameters.Builder();
        AcquireTokenParameters acquireTokenParameters = builder.startAuthorizationFromActivity(activity)
                .withFragment(fragment)
                .forAccount(account)
                .withScopes(Arrays.asList(scopes))
                .withPrompt(uiBehavior)
                .withAuthorizationQueryStringParameters(extraQueryParameters)
                .withOtherScopesToAuthorize(
                        Arrays.asList(
                                null == extraScopesToConsent
                                        ? new String[]{}
                                        : extraScopesToConsent
                        )
                )
                .fromAuthority(authority)
                .withCallback(callback)
                .withLoginHint(loginHint)
                .withClaims(claimsRequest)
                .build();
        return acquireTokenParameters;
    }
    protected void validateAcquireTokenParameters(AcquireTokenParameters parameters) throws MsalArgumentException {
        final Activity activity = parameters.getActivity();
        final List scopes = parameters.getScopes();
        final AuthenticationCallback callback = parameters.getCallback();
        validateNonNullArg(activity, NONNULL_CONSTANTS.ACTIVITY);
        validateNonNullArg(scopes, NONNULL_CONSTANTS.SCOPES);
        validateNonNullArg(callback, NONNULL_CONSTANTS.CALLBACK);
    }
    protected void validateAcquireTokenSilentParameters(AcquireTokenSilentParameters parameters) throws MsalArgumentException {
        final String authority = parameters.getAuthority();
        final IAccount account = parameters.getAccount();
        final List scopes = parameters.getScopes();
        final SilentAuthenticationCallback callback = parameters.getCallback();
        validateNonNullArg(authority, NONNULL_CONSTANTS.AUTHORITY);
        validateNonNullArg(account, NONNULL_CONSTANTS.ACCOUNT);
        validateNonNullArg(callback, NONNULL_CONSTANTS.CALLBACK);
        validateNonNullArg(scopes, NONNULL_CONSTANTS.SCOPES);
    }
    public void acquireToken(@NonNull final AcquireTokenParameters acquireTokenParameters) {
        acquireTokenInternal(acquireTokenParameters, PublicApiId.PCA_ACQUIRE_TOKEN_WITH_PARAMETERS);
    }
    void acquireTokenInternal(@NonNull final AcquireTokenParameters acquireTokenParameters, @NonNull final String publicApiId) {
        // In order to support use of named tenants (such as contoso.onmicrosoft.com), we need
        // to be able to query OpenId Provider Configuration Metadata - for this reason, we will
        // build-up the acquireTokenOperationParams on a background thread.
        sBackgroundExecutor.submit(new Runnable() {
            @Override
            public void run() {
                final CommandCallback localAuthenticationCallback =
                        getCommandCallback(
                                acquireTokenParameters.getCallback(),
                                acquireTokenParameters
                        );
                try {
                    validateAcquireTokenParameters(acquireTokenParameters);
                    acquireTokenParameters.setAccountRecord(
                            selectAccountRecordForTokenRequest(
                                    mPublicClientConfiguration,
                                    acquireTokenParameters
                            )
                    );
                    final InteractiveTokenCommandParameters params = CommandParametersAdapter.
                            createInteractiveTokenCommandParameters(
                                    mPublicClientConfiguration,
                                    mPublicClientConfiguration.getOAuth2TokenCache(),
                                    acquireTokenParameters
                            );
                    final InteractiveTokenCommand command = new InteractiveTokenCommand(
                            params,
                            MSALControllerFactory.getDefaultController(
                                    mPublicClientConfiguration.getAppContext(),
                                    params.getAuthority(),
                                    mPublicClientConfiguration
                            ),
                            localAuthenticationCallback,
                            publicApiId
                    );
                    CommandDispatcher.beginInteractive(command);
                } catch (final Exception exception) {
                    // convert exception to BaseException
                    final BaseException baseException = ExceptionAdapter.baseExceptionFromException(exception);
                    // If there is an Exception, post it to the main thread...
                    final Handler handler = new Handler(Looper.getMainLooper());
                    handler.post(new Runnable() {
                        @Override
                        public void run() {
                            localAuthenticationCallback.onError(baseException);
                        }
                    });
                }
            }
        });
    }
    protected AcquireTokenSilentParameters buildAcquireTokenSilentParameters(@NonNull final String[] scopes,
                                                                             @NonNull final IAccount account,
                                                                             @NonNull final String authority,
                                                                             final boolean forceRefresh,
                                                                             @Nullable final ClaimsRequest claimsRequest,
                                                                             @NonNull final SilentAuthenticationCallback callback) {
        validateNonNullArgument(account, NONNULL_CONSTANTS.ACCOUNT);
        validateNonNullArgument(callback, NONNULL_CONSTANTS.CALLBACK);
        AcquireTokenSilentParameters.Builder builder = new AcquireTokenSilentParameters.Builder();
        AcquireTokenSilentParameters acquireTokenSilentParameters =
                builder.withScopes(Arrays.asList(scopes))
                        .forAccount(account)
                        .fromAuthority(authority)
                        .forceRefresh(forceRefresh)
                        .withClaims(claimsRequest)
                        .withCallback(callback)
                        .build();
        return acquireTokenSilentParameters;
    }
    @Override
    public void acquireTokenSilentAsync(
            @NonNull final AcquireTokenSilentParameters acquireTokenSilentParameters) {
        acquireTokenSilentAsyncInternal(acquireTokenSilentParameters, PublicApiId.PCA_ACQUIRE_TOKEN_SILENT_ASYNC_WITH_PARAMETERS);
    }
    void acquireTokenSilentAsyncInternal(
            @NonNull final AcquireTokenSilentParameters acquireTokenSilentParameters,
            @NonNull final String publicApiId) {
        sBackgroundExecutor.submit(new Runnable() {
            @Override
            public void run() {
                final CommandCallback callback = getCommandCallback(
                        acquireTokenSilentParameters.getCallback(),
                        acquireTokenSilentParameters
                );
                try {
                    validateAcquireTokenSilentParameters(acquireTokenSilentParameters);
                    acquireTokenSilentParameters.setAccountRecord(
                            selectAccountRecordForTokenRequest(
                                    mPublicClientConfiguration,
                                    acquireTokenSilentParameters
                            )
                    );
                    final SilentTokenCommandParameters params =
                            CommandParametersAdapter.createSilentTokenCommandParameters(
                                    mPublicClientConfiguration,
                                    mPublicClientConfiguration.getOAuth2TokenCache(),
                                    acquireTokenSilentParameters
                            );
                    final SilentTokenCommand silentTokenCommand = new SilentTokenCommand(
                            params,
                            MSALControllerFactory.getAllControllers(
                                    mPublicClientConfiguration.getAppContext(),
                                    params.getAuthority(),
                                    mPublicClientConfiguration
                            ),
                            callback,
                            publicApiId
                    );
                    CommandDispatcher.submitSilent(silentTokenCommand);
                } catch (final Exception exception) {
                    // convert exception to BaseException
                    final BaseException baseException = ExceptionAdapter.baseExceptionFromException(exception);
                    // There was an error, shuttle it back to the main thread...
                    new Handler(Looper.getMainLooper()).post(new Runnable() {
                        @Override
                        public void run() {
                            callback.onError(baseException);
                        }
                    });
                }
            }
        });
    }
    private AccountRecord selectAccountRecordForTokenRequest(
            @NonNull final PublicClientApplicationConfiguration pcaConfig,
            @NonNull final TokenParameters tokenParameters)
            throws ServiceException, ClientException {
        // If not authority was provided in the request, fallback to the default authority...
        if (TextUtils.isEmpty(tokenParameters.getAuthority())) {
            tokenParameters.setAuthority(
                    pcaConfig
                            .getDefaultAuthority()
                            .getAuthorityUri()
                            .toString()
            );
        }
        if (null == tokenParameters.getAccount()) {
            return null; // No account was set!
        }
        // The root account we'll be fetching tokens for...
        final IAccount rootAccount = tokenParameters.getAccount();
        final MultiTenantAccount multiTenantAccount = (MultiTenantAccount) rootAccount;
        final String requestAuthority = tokenParameters.getAuthority();
        final Authority authority = Authority.getAuthorityFromAuthorityUrl(requestAuthority);
        if (authority instanceof AzureActiveDirectoryB2CAuthority) {
            // use home account - b2c is not compatible with broker, so no need to construct
            // the account used in the request...
            return AccountAdapter.getAccountInternal(
                    mPublicClientConfiguration.getClientId(),
                    mPublicClientConfiguration.getOAuth2TokenCache(),
                    multiTenantAccount.getHomeAccountId(),
                    multiTenantAccount.getTenantId()
            );
        } else if (authority instanceof AzureActiveDirectoryAuthority) {
            final AzureActiveDirectoryAuthority aadAuthority = (AzureActiveDirectoryAuthority) authority;
            // Although the below call implies the returned value will be a tenantId, this isn't
            // strictly true: it can also be an alias such as 'common', 'consumers', or
            // 'organizations'. Additionally, if the developer has used a named tenant it could end
            // up being something like <tenant_name>.onmicrosoft.com
            //
            // If the tenant is a GUID, we need to choose the account/profile that corresponds to it
            //
            // If the tenant is named 'common', 'consumers', or 'organizations' we need to use the
            // home account
            //
            // If the account is named like <tenant_name>.onmicrosoft.com we need to query the OpenId
            // Provider Configuration Metadata in order to get the tenant id. Once we have the
            // tenant id, we must then select the appropriate home or profile.
            String tenantId = aadAuthority.getAudience().getTenantId();
            // The AccountRecord we'll use to request a token...
            final AccountRecord accountRecord = new AccountRecord();
            accountRecord.setEnvironment(multiTenantAccount.getEnvironment());
            accountRecord.setHomeAccountId(multiTenantAccount.getHomeAccountId());
            final boolean isUuid = isUuid(tenantId);
            if (!isUuid && !isHomeTenantAlias(tenantId)) {
                tenantId = ((AzureActiveDirectoryAuthority) authority)
                        .getAudience()
                        .getTenantUuidForAlias(
                                authority.getAuthorityURL().toString()
                        );
            }
            // Set the tenant id obtained for the accountRecord
            accountRecord.setRealm(tenantId);
            IAccount accountForRequest;
            if (isHomeTenantAlias(tenantId)
                    || isAccountHomeTenant(multiTenantAccount.getClaims(), tenantId)) {
                accountForRequest = (multiTenantAccount.getClaims() != null) ? multiTenantAccount : null;
            } else {
                accountForRequest = multiTenantAccount.getTenantProfiles().get(tenantId);
            }
            // If we are not able to get the AccountRecord for the requested tenanted authority,
            // it means the user is attempting to get a token for a new tenant for the existing IAccount.
            // For silent request, use home account if available or any of the tenant profiles and pass it
            // along as accountForRequest. Controllers will use this account to get refresh token and acquire
            // a new access token for the requested tenant.
            if (null == accountForRequest) { // We did not find a profile to use
                final boolean isSilent = tokenParameters instanceof AcquireTokenSilentParameters;
                if (isSilent) {
                    if (rootAccount.getClaims() != null) {
                        accountForRequest = rootAccount;
                    } else {
                        for (ITenantProfile tenantProfile : multiTenantAccount.getTenantProfiles().values()) {
                            if (tenantProfile.getClaims() != null) {
                                accountForRequest = tenantProfile;
                                break;
                            }
                        }
                    }
                }
            }
            // We should never hit this flow as IAccount should always have a home profile or at least one tenant profile on it.
            if (accountForRequest == null) {
                Logger.warnPII(TAG,
                        "No account record found for IAccount with request tenantId: " + tenantId
                );
                throw new ClientException(
                        ErrorStrings.NO_ACCOUNT_FOUND,
                        "No account record found for IAccount"
                );
            }
            accountRecord.setLocalAccountId(accountForRequest.getId());
            accountRecord.setUsername(accountForRequest.getUsername());
            return accountRecord;
        } else {
            // Unrecognized authority type
            throw new UnsupportedOperationException(
                    "Unsupported Authority type: "
                            + authority
                            .getClass()
                            .getSimpleName()
            );
        }
    }
    @Override
    public IAuthenticationResult acquireTokenSilent(
            @NonNull final AcquireTokenSilentParameters acquireTokenSilentParameters)
            throws InterruptedException, MsalException {
        return acquireTokenSilentInternal(acquireTokenSilentParameters, PublicApiId.PCA_ACQUIRE_TOKEN_SILENT_WITH_PARAMETERS);
    }
    IAuthenticationResult acquireTokenSilentInternal(
            @NonNull final AcquireTokenSilentParameters acquireTokenSilentParameters,
            @NonNull final String publicApiId)
            throws InterruptedException, MsalException {
        if (acquireTokenSilentParameters.getCallback() != null) {
            throw new IllegalArgumentException("Do not provide callback for synchronous methods");
        }
        final ResultFuture<AsyncResult<IAuthenticationResult>> future = new ResultFuture<>();
        acquireTokenSilentParameters.setCallback(new SilentAuthenticationCallback() {
            @Override
            public void onSuccess(IAuthenticationResult authenticationResult) {
                future.setResult(new AsyncResult<>(authenticationResult, null));
            }
            @Override
            public void onError(MsalException exception) {
                future.setResult(new AsyncResult<IAuthenticationResult>(null, exception));
            }
        });
        acquireTokenSilentAsyncInternal(acquireTokenSilentParameters, publicApiId);
        try {
            AsyncResult<IAuthenticationResult> result = future.get();
            if (result.getSuccess()) {
                return result.getResult();
            } else {
                throw result.getException();
            }
        } catch (final ExecutionException e) {
            // Shouldn't be thrown.
            throw new MsalClientException(
                    UNKNOWN_ERROR,
                    "Unexpected error while acquiring token.",
                    e
            );
        }
    }
    public void acquireTokenWithDeviceCode(@Nullable String[] scopes, @NonNull final DeviceCodeFlowCallback callback) {
        // Create a DeviceCodeFlowCommandParameters object that takes in the desired scopes and the callback object
        // Use CommandParametersAdapter
        final DeviceCodeFlowCommandParameters commandParameters = CommandParametersAdapter
                .createDeviceCodeFlowCommandParameters(
                        mPublicClientConfiguration,
                        mPublicClientConfiguration.getOAuth2TokenCache(),
                        scopes);
        // Create a CommandCallback object from the DeviceCodeFlowCallback object
        final DeviceCodeFlowCommandCallback deviceCodeFlowCommandCallback = getDeviceCodeFlowCommandCallback(callback);
        // Create a DeviceCodeFlowCommand object
        // Pass the command parameters, default controller, and command callback
        // Telemetry with DEVICE_CODE_FLOW_CALLBACK
        final DeviceCodeFlowCommand deviceCodeFlowCommand = new DeviceCodeFlowCommand(
                commandParameters,
                new LocalMSALController(),
                deviceCodeFlowCommandCallback,
                PublicApiId.DEVICE_CODE_FLOW_WITH_CALLBACK
        );
        CommandDispatcher.submitSilent(deviceCodeFlowCommand);
    }
    private void checkInternetPermission() {
        final PackageManager packageManager = mPublicClientConfiguration.getAppContext().getPackageManager();
        if (packageManager.checkPermission(INTERNET_PERMISSION, mPublicClientConfiguration.getAppContext().getPackageName())
                != PackageManager.PERMISSION_GRANTED
                || packageManager.checkPermission(ACCESS_NETWORK_STATE_PERMISSION, mPublicClientConfiguration.getAppContext().getPackageName())
                != PackageManager.PERMISSION_GRANTED) {
            throw new IllegalStateException("android.permission.Internet or android.permission.ACCESS_NETWORK_STATE is missing");
        }
    }
    static CommandCallback<List<ICacheRecord>, BaseException> getLoadAccountsCallback(
            final LoadAccountsCallback loadAccountsCallback) {
        return new CommandCallback<List<ICacheRecord>, BaseException>() {
            @Override
            public void onTaskCompleted(final List<ICacheRecord> result) {
                if (null == result) {
                    loadAccountsCallback.onTaskCompleted(null);
                } else {
                    loadAccountsCallback.onTaskCompleted(
                            AccountAdapter.adapt(result)
                    );
                }
            }
            @Override
            public void onError(final BaseException exception) {
                loadAccountsCallback.onError(msalExceptionFromBaseException(exception));
            }
            @Override
            public void onCancel() {
                //Do nothing
            }
        };
    }
    protected CommandCallback getCommandCallback(
            @NonNull final SilentAuthenticationCallback authenticationCallback,
            @NonNull final TokenParameters tokenParameters) {
        return new CommandCallback<ILocalAuthenticationResult, BaseException>() {
            @Override
            public void onTaskCompleted(ILocalAuthenticationResult localAuthenticationResult) {
                postAuthResult(localAuthenticationResult, tokenParameters, authenticationCallback);
            }
            @Override
            public void onError(BaseException exception) {
                MsalException msalException = msalExceptionFromBaseException(exception);
                if (authenticationCallback == null) {
                    throw new IllegalStateException(NONNULL_CONSTANTS.CALLBACK + NONNULL_CONSTANTS.NULL_ERROR_SUFFIX);
                } else {
                    authenticationCallback.onError(msalException);
                }
            }
            @Override
            public void onCancel() {
                if (authenticationCallback instanceof AuthenticationCallback) {
                    ((AuthenticationCallback) authenticationCallback).onCancel();
                } else {
                    throw new IllegalStateException("Silent requests cannot be cancelled.");
                }
            }
        };
    }
    private DeviceCodeFlowCommandCallback getDeviceCodeFlowCommandCallback(@NonNull final DeviceCodeFlowCallback callback) {
        return new DeviceCodeFlowCommandCallback<LocalAuthenticationResult, BaseException>() {
            @Override
            public void onUserCodeReceived(@NonNull final String vUri,
                                           @NonNull final String userCode,
                                           @NonNull final String message,
                                           @NonNull final Date sessionExpirationDate) {
                callback.onUserCodeReceived(vUri, userCode, message, sessionExpirationDate);
            }
            @Override
            public void onTaskCompleted(LocalAuthenticationResult tokenResult) {
                // Convert tokenResult to an AuthenticationResult object
                final IAuthenticationResult convertedResult = AuthenticationResultAdapter.adapt(
                        tokenResult);
                // Type cast the interface object
                final AuthenticationResult authResult = (AuthenticationResult) convertedResult;
                callback.onTokenReceived(authResult);
            }
            @Override
            public void onError(BaseException error) {
                final MsalException msalException;
                if (error instanceof ServiceException) {
                    msalException = new MsalServiceException(
                            error.getErrorCode(),
                            error.getMessage(),
                            ((ServiceException) error).getHttpStatusCode(),
                            error
                    );
                } else {
                    msalException = new MsalClientException(
                            error.getErrorCode(),
                            error.getMessage(),
                            error
                    );
                }
                callback.onError(msalException);
            }
            @Override
            public void onCancel() {
                // Do nothing
                // No current plans for allowing cancellation of DCF
            }
        };
    }
    /**
     * Helper method to post authentication result.
     */
    protected void postAuthResult(@NonNull final ILocalAuthenticationResult localAuthenticationResult,
                                  @NonNull final TokenParameters requestParameters,
                                  @NonNull final SilentAuthenticationCallback authenticationCallback) {
        if (authenticationCallback == null) {
            throw new IllegalStateException(NONNULL_CONSTANTS.CALLBACK + NONNULL_CONSTANTS.NULL_ERROR_SUFFIX);
        }
        // Check if any of the requested scopes are declined by the server, if yes throw a MsalDeclinedScope exception
        final List<String> declinedScopes = AuthenticationResultAdapter.getDeclinedScopes(
                Arrays.asList(localAuthenticationResult.getScope()),
                requestParameters.getScopes()
        );
        if (!declinedScopes.isEmpty()) {
            final MsalDeclinedScopeException declinedScopeException =
                    AuthenticationResultAdapter.declinedScopeExceptionFromResult(
                            localAuthenticationResult,
                            declinedScopes,
                            requestParameters
                    );
            authenticationCallback.onError(declinedScopeException);
        } else {
            IAuthenticationResult authenticationResult = AuthenticationResultAdapter.adapt(localAuthenticationResult);
            authenticationCallback.onSuccess(authenticationResult);
        }
    }
    private OAuth2TokenCache<?, ?, ?> getOAuth2TokenCache() {
        return MsalOAuth2TokenCache.create(mPublicClientConfiguration.getAppContext());
    }
    protected class AccountMatcher {
        private final AccountMatcher[] mDelegateMatchers;
        AccountMatcher() {
            // Intentionally blank...
            mDelegateMatchers = new AccountMatcher[]{};
        }
        AccountMatcher(@NonNull final AccountMatcher... delegateMatchers) {
            mDelegateMatchers = delegateMatchers;
        }
        boolean matches(@NonNull final String identifier,
                        @NonNull final IAccount account) {
            boolean matches = false;
            for (final AccountMatcher matcher : mDelegateMatchers) {
                matches = matcher.matches(identifier, account);
                if (matches) {
                    break;
                }
            }
            return matches;
        }
    }
    protected AccountMatcher homeAccountMatcher = new AccountMatcher() {
        @Override
        boolean matches(@NonNull final String homeAccountId,
                        @NonNull final IAccount account) {
            return homeAccountId.contains(account.getId());
        }
    };
    protected AccountMatcher localAccountMatcher = new AccountMatcher() {
        @Override
        boolean matches(@NonNull final String localAccountId,
                        @NonNull final IAccount account) {
            // First, inspect the root account...
            if (localAccountId.contains(account.getId())) {
                return true;
            } else if (account instanceof MultiTenantAccount) {
                // We need to look at the profiles...
                final MultiTenantAccount multiTenantAccount = (MultiTenantAccount) account;
                final Map<String, ITenantProfile> tenantProfiles = multiTenantAccount.getTenantProfiles();
                if (null != tenantProfiles && !tenantProfiles.isEmpty()) {
                    for (final Map.Entry<String, ITenantProfile> profileEntry : tenantProfiles.entrySet()) {
                        if (!TextUtils.isEmpty(profileEntry.getValue().getId()) &&
                                localAccountId.contains(profileEntry.getValue().getId())) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
    };
    protected AccountMatcher usernameMatcher = new AccountMatcher() {
        @Override
        boolean matches(@NonNull final String username,
                        @NonNull final IAccount account) {
            // Put all of the IdToken we can inspect in a List...
            final List<IClaimable> thingsWithClaims
                    = new ArrayList<>();
            if (null != account.getClaims()) {
                thingsWithClaims.add(account);
            }
            if (account instanceof MultiTenantAccount) {
                final MultiTenantAccount multiTenantAccount = (MultiTenantAccount) account;
                final Map<String, ITenantProfile> profiles = multiTenantAccount.getTenantProfiles();
                for (final Map.Entry<String, ITenantProfile> profileEntry : profiles.entrySet()) {
                    if (null != profileEntry.getValue().getClaims()) {
                        thingsWithClaims.add(profileEntry.getValue());
                    }
                }
            }
            for (final IClaimable thingWithClaims : thingsWithClaims) {
                if (null != thingWithClaims.getClaims()
                        && username.equalsIgnoreCase(
                        SchemaUtil.getDisplayableId(
                                thingWithClaims.getClaims()
                        )
                )) {
                    return true;
                }
            }
            return false;
        }
    };
    IAuthenticationResult acquireTokenSilentSyncInternal(@NonNull final String[] scopes,
                                                         @NonNull final String authority,
                                                         @NonNull final IAccount account,
                                                         final boolean forceRefresh,
                                                         @NonNull final String publicApiId) throws MsalException, InterruptedException {
        throwOnMainThread("acquireTokenSilent");
        final ResultFuture<AsyncResult<IAuthenticationResult>> future = new ResultFuture<>();
        final AcquireTokenSilentParameters acquireTokenSilentParameters = buildAcquireTokenSilentParameters(
                scopes,
                account,
                authority, // authority
                forceRefresh, // forceRefresh
                null, // claimsRequest
                new SilentAuthenticationCallback() {
                    @Override
                    public void onSuccess(IAuthenticationResult authenticationResult) {
                        future.setResult(new AsyncResult<>(authenticationResult, null));
                    }
                    @Override
                    public void onError(MsalException exception) {
                        future.setResult(new AsyncResult<IAuthenticationResult>(null, exception));
                    }
                }
        );
        acquireTokenSilentAsyncInternal(acquireTokenSilentParameters, publicApiId);
        try {
            final AsyncResult<IAuthenticationResult> result = future.get();
            if (result.getSuccess()) {
                return result.getResult();
            } else {
                throw result.getException();
            }
        } catch (final ExecutionException e) {
            throw new MsalClientException(
                    UNKNOWN_ERROR,
                    "Unexpected error while acquiring token.",
                    e
            );
        }
    }
    void performMigration(@NonNull final TokenMigrationCallback callback) {
        final Map<String, String> redirects = new HashMap<>();
        redirects.put(
                mPublicClientConfiguration.getClientId(), // Our client id
                mPublicClientConfiguration.getRedirectUri() // Our redirect uri
        );
        final AdalMigrationAdapter adalMigrationAdapter = new AdalMigrationAdapter(
                mPublicClientConfiguration.getAppContext(),
                redirects,
                false
        );
        if (adalMigrationAdapter.getMigrationStatus()) {
            callback.onMigrationFinished(0);
        } else {
            // Create the SharedPreferencesFileManager for the legacy accounts/credentials
            final IStorageHelper storageHelper = new StorageHelper(mPublicClientConfiguration.getAppContext());
            final ISharedPreferencesFileManager sharedPreferencesFileManager =
                    new SharedPreferencesFileManager(
                            mPublicClientConfiguration.getAppContext(),
                            "com.microsoft.aad.adal.cache",
                            storageHelper
                    );
            // Load the old TokenCacheItems as key/value JSON
            final Map<String, String> credentials = sharedPreferencesFileManager.getAll();
            new TokenMigrationUtility<MicrosoftAccount, MicrosoftRefreshToken>()._import(
                    adalMigrationAdapter,
                    credentials,
                    (IShareSingleSignOnState<MicrosoftAccount, MicrosoftRefreshToken>) mPublicClientConfiguration.getOAuth2TokenCache(),
                    callback
            );
        }
    }
    private static void runOnBackground(@NonNull final Runnable runnable) {
        new Thread(runnable).start();
    }
    private static boolean isAccountHomeTenant(@Nullable final Map<String, ?> claims,
                                               @NonNull final String tenantId) {
        boolean isAccountHomeTenant = false;
        if (null != claims && !claims.isEmpty()) {
            isAccountHomeTenant = claims.get(TENANT_ID).equals(tenantId);
        }
        return isAccountHomeTenant;
    }
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import com.microsoft.identity.client.exception.MsalClientException;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.client.exception.MsalServiceException;
import com.microsoft.identity.client.exception.MsalUiRequiredException;
public interface SilentAuthenticationCallback {
    /**
     * Authentication finishes successfully.
     *
     * @param authenticationResult {@link IAuthenticationResult} that contains the success response.
     */
    void onSuccess(final IAuthenticationResult authenticationResult);
    /**
     * Error occurs during the authentication.
     *
     * @param exception The {@link MsalException} contains the error code, error message and cause if applicable. The exception
     *                  returned in the callback could be {@link MsalClientException}, {@link MsalServiceException} or
     *                  {@link MsalUiRequiredException}.
     */
    void onError(final MsalException exception);
}
// Copyright (c) Microsoft Corporation.
// All rights reserved.
//
// This code is licensed under the MIT License.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
package com.microsoft.identity.client.exception;
import com.microsoft.identity.client.internal.MsalUtils;
import com.microsoft.identity.common.exception.BaseException;
/**
 * {@link MsalException} thrown or sent back via callback, representing the detailed exception
 * thrown by the sdk. It will contain the error code, error description (could be null) or
 * throwable (could be null).
 */
public class MsalException extends BaseException {
    /**
     * Default constructor.
     */
    MsalException() {
        super();
    }
    /**
     * Initiates the detailed error code.
     *
     * @param errorCode The error code contained in the exception.
     */
    MsalException(final String errorCode) {
        super(errorCode);
    }
    /**
     * Initiates the {@link MsalException} with error code and error message.
     *
     * @param errorCode    The error code contained in the exception.
     * @param errorMessage The error message contained in the exception.
     */
    MsalException(final String errorCode, final String errorMessage) {
        super(errorCode, errorMessage);
    }
    /**
     * Initiates the {@link MsalException} with error code, error message and throwable.
     *
     * @param errorCode    The error code contained in the exception.
     * @param errorMessage The error message contained in the exception.
     * @param throwable    The {@link Throwable} contains the cause for the exception.
     */
    MsalException(final String errorCode, final String errorMessage,
                         final Throwable throwable) {
        super(errorCode, errorMessage, throwable);
    }
    /**
     * @return The error code for the exception, could be null. {@link MsalException} is the top level base exception, for the
     * constants value of all the error code.
     */
    @Override
    public String getErrorCode() {
        return super.getErrorCode();
    }
    /**
     * {@inheritDoc}
     * Return the detailed description explaining why the exception is returned back.
     */
    @Override
    public String getMessage() {
        if (!MsalUtils.isEmpty(super.getMessage())) {
            return super.getMessage();
        }
        return "";
    }
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client.msal.automationapp.sdk;
import android.app.Activity;
import android.content.Context;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.microsoft.identity.client.AcquireTokenParameters;
import com.microsoft.identity.client.AcquireTokenSilentParameters;
import com.microsoft.identity.client.AuthenticationCallback;
import com.microsoft.identity.client.IAccount;
import com.microsoft.identity.client.IAuthenticationResult;
import com.microsoft.identity.client.IMultipleAccountPublicClientApplication;
import com.microsoft.identity.client.IPublicClientApplication;
import com.microsoft.identity.client.ISingleAccountPublicClientApplication;
import com.microsoft.identity.client.MultipleAccountPublicClientApplication;
import com.microsoft.identity.client.PublicClientApplication;
import com.microsoft.identity.client.SingleAccountPublicClientApplication;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.client.exception.MsalUserCancelException;
import com.microsoft.identity.client.ui.automation.TokenRequestTimeout;
import com.microsoft.identity.client.ui.automation.interaction.OnInteractionRequired;
import com.microsoft.identity.client.ui.automation.sdk.ResultFuture;
import com.microsoft.identity.client.ui.automation.sdk.IAuthSdk;
import java.util.ArrayList;
/**
 * A Sdk wrapper for Microsoft Authentication Library (MSAL) which implements
 * both the methods of acquire token interactively and silently and returns back the
 * AuthResult, MSAL tests can leverage this sdk for acquiring token with specific
 * parameters and get back the final result.
 */
public class MsalSdk implements IAuthSdk<MsalAuthTestParams> {
    
    @Override
    public MsalAuthResult acquireTokenInteractive(@NonNull MsalAuthTestParams authTestParams, final OnInteractionRequired interactionRequiredCallback, @NonNull final TokenRequestTimeout tokenRequestTimeout) throws Throwable {
        final IPublicClientApplication pca = setupPCA(
                authTestParams.getActivity(),
                authTestParams.getMsalConfigResourceId()
        );
        final ResultFuture<IAuthenticationResult, Exception> future = new ResultFuture<>();
        final AcquireTokenParameters.Builder acquireTokenParametersBuilder = new AcquireTokenParameters.Builder()
                .startAuthorizationFromActivity(authTestParams.getActivity())
                .withLoginHint(authTestParams.getLoginHint())
                .withPrompt(authTestParams.getPromptParameter())
                .fromAuthority(authTestParams.getAuthority())
                .withCallback(getAuthCallback(future));
        if (authTestParams.getScopes() == null || authTestParams.getScopes().isEmpty()) {
            acquireTokenParametersBuilder.withResource(authTestParams.getResource());
        } else {
            acquireTokenParametersBuilder.withScopes(new ArrayList<>(authTestParams.getScopes()));
        }
        if (authTestParams.getClaims() != null) {
            acquireTokenParametersBuilder.withClaims(authTestParams.getClaims());
        }
        final AcquireTokenParameters acquireTokenParameters = acquireTokenParametersBuilder.build();
        pca.acquireToken(acquireTokenParameters);
        interactionRequiredCallback.handleUserInteraction();
        try {
            final IAuthenticationResult result = future.get(tokenRequestTimeout.getTime(), tokenRequestTimeout.getTimeUnit());
            return new MsalAuthResult(result);
        } catch (Exception exception) {
            return new MsalAuthResult(exception);
        }
    }
    @Override
    public MsalAuthResult acquireTokenSilent(@NonNull MsalAuthTestParams authTestParams, @NonNull final TokenRequestTimeout tokenRequestTimeout) throws Throwable {
        final IPublicClientApplication pca = setupPCA(
            authTestParams.getActivity(),
            authTestParams.getMsalConfigResourceId()
        );
        final ResultFuture<IAuthenticationResult, Exception> future = new ResultFuture<>();
        final IAccount account = getAccount(
                authTestParams.getActivity(),
                authTestParams.getMsalConfigResourceId(),
                authTestParams.getLoginHint()
        );
        final AcquireTokenSilentParameters.Builder acquireTokenParametersBuilder = new AcquireTokenSilentParameters.Builder()
                .forAccount(account)
                .forceRefresh(authTestParams.isForceRefresh())
                .fromAuthority(authTestParams.getAuthority())
                .withCallback(getAuthCallback(future));
        if (authTestParams.getScopes() == null || authTestParams.getScopes().isEmpty()) {
            acquireTokenParametersBuilder.withResource(authTestParams.getResource());
        } else {
            acquireTokenParametersBuilder.withScopes(new ArrayList<>(authTestParams.getScopes()));
        }
        if (authTestParams.getClaims() != null) {
            acquireTokenParametersBuilder.withClaims(authTestParams.getClaims());
        }
        final AcquireTokenSilentParameters acquireTokenParameters = acquireTokenParametersBuilder.build();
        pca.acquireTokenSilentAsync(acquireTokenParameters);
        try {
            final IAuthenticationResult result = future.get(tokenRequestTimeout.getTime(), tokenRequestTimeout.getTimeUnit());
            return new MsalAuthResult(result);
        } catch (final Exception exception) {
            return new MsalAuthResult(exception);
        }
    }
    private IPublicClientApplication setupPCA(@NonNull final Context context,
                                              final int msalConfigResourceId) {
        try {
            return PublicClientApplication.create(context, msalConfigResourceId);
        } catch (InterruptedException | MsalException e) {
            throw new AssertionError(e);
        }
    }
    private AuthenticationCallback getAuthCallback(final ResultFuture<IAuthenticationResult, Exception> future) {
        return new AuthenticationCallback() {
            @Override
            public void onSuccess(IAuthenticationResult authenticationResult) {
                future.setResult(authenticationResult);
            }
            @Override
            public void onError(MsalException exception) {
                future.setException(exception);
            }
            @Override
            public void onCancel() {
                future.setException(new MsalUserCancelException());
            }
        };
    }
    public IAccount getAccount(@NonNull final Activity activity,
                                final int msalConfigResourceId,
                                @NonNull final String username) {
        final IPublicClientApplication pca = setupPCA(
                activity,
                msalConfigResourceId
        );
        if (pca instanceof SingleAccountPublicClientApplication) {
            return getAccountForSingleAccountPca((SingleAccountPublicClientApplication) pca);
        } else if (pca instanceof MultipleAccountPublicClientApplication) {
            return getAccountForMultipleAccountPca((MultipleAccountPublicClientApplication) pca, username);
        } else {
            throw new AssertionError("Weird");
        }
    }
    private IAccount getAccountForSingleAccountPca(@NonNull final SingleAccountPublicClientApplication pca) {
        final ResultFuture<IAccount, Exception> future = new ResultFuture<>();
        pca.getCurrentAccountAsync(new ISingleAccountPublicClientApplication.CurrentAccountCallback() {
            @Override
            public void onAccountLoaded(@Nullable IAccount activeAccount) {
                future.setResult(activeAccount);
            }
            @Override
            public void onAccountChanged(@Nullable IAccount priorAccount, @Nullable IAccount currentAccount) {
                future.setResult(currentAccount);
            }
            @Override
            public void onError(@NonNull MsalException exception) {
                future.setException(exception);
            }
        });
        try {
            return future.get();
        } catch (final Exception exception) {
            throw new AssertionError(exception);
        }
    }
    private IAccount getAccountForMultipleAccountPca(@NonNull final MultipleAccountPublicClientApplication pca,
                                                     final String username) {
        final ResultFuture<IAccount, Exception> future = new ResultFuture<>();
        pca.getAccount(username, new IMultipleAccountPublicClientApplication.GetAccountCallback() {
            @Override
            public void onTaskCompleted(IAccount result) {
                future.setResult(result);
            }
            @Override
            public void onError(MsalException exception) {
                future.setException(exception);
            }
        });
        try {
            return future.get();
        } catch (final Exception exception) {
            throw new AssertionError(exception);
        }
    }
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import android.app.Activity;
import android.content.Context;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.WorkerThread;
import com.microsoft.identity.client.exception.MsalClientException;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.client.internal.AsyncResult;
import com.microsoft.identity.client.internal.CommandParametersAdapter;
import com.microsoft.identity.client.internal.controllers.MSALControllerFactory;
import com.microsoft.identity.client.internal.controllers.MsalExceptionAdapter;
import com.microsoft.identity.common.adal.internal.cache.StorageHelper;
import com.microsoft.identity.common.adal.internal.util.JsonExtensions;
import com.microsoft.identity.common.adal.internal.util.StringExtensions;
import com.microsoft.identity.common.exception.BaseException;
import com.microsoft.identity.common.internal.cache.ICacheRecord;
import com.microsoft.identity.common.internal.cache.SharedPreferencesFileManager;
import com.microsoft.identity.common.internal.commands.CommandCallback;
import com.microsoft.identity.common.internal.commands.GetCurrentAccountCommand;
import com.microsoft.identity.common.internal.commands.RemoveCurrentAccountCommand;
import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;
import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;
import com.microsoft.identity.common.internal.controllers.BaseController;
import com.microsoft.identity.common.internal.controllers.CommandDispatcher;
import com.microsoft.identity.common.internal.dto.AccountRecord;
import com.microsoft.identity.common.internal.migration.TokenMigrationCallback;
import com.microsoft.identity.common.internal.result.ILocalAuthenticationResult;
import com.microsoft.identity.common.internal.result.ResultFuture;
import java.util.List;
import java.util.concurrent.ExecutionException;
import static com.microsoft.identity.client.exception.MsalClientException.UNKNOWN_ERROR;
import static com.microsoft.identity.client.internal.MsalUtils.throwOnMainThread;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_SILENT_ASYNC_WITH_PARAMETERS;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_SILENT_ASYNC_WITH_SCOPES_AUTHORITY_CALLBACK;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_SILENT_WITH_PARAMETERS;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_SILENT_WITH_SCOPES_AUTHORITY;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_WITH_ACTIVITY_SCOPES_CALLBACK;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_WITH_PARAMETERS;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_EXISTING_SIGN_IN_WITH_PROMPT;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_GET_CURRENT_ACCOUNT;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_GET_CURRENT_ACCOUNT_ASYNC;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_SIGN_IN;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_SIGN_IN_WITH_PROMPT;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_SIGN_OUT;
import static com.microsoft.identity.common.internal.eststelemetry.PublicApiId.SINGLE_ACCOUNT_PCA_SIGN_OUT_WITH_CALLBACK;
public class SingleAccountPublicClientApplication
        extends PublicClientApplication
        implements ISingleAccountPublicClientApplication {
    private static final String TAG = SingleAccountPublicClientApplication.class.getSimpleName();
    /**
     * Name of the shared preference cache for storing SingleAccountPublicClientApplication data.
     */
    public static final String SINGLE_ACCOUNT_CREDENTIAL_SHARED_PREFERENCES =
            "com.microsoft.identity.client.single_account_credential_cache";
    /**
     * SharedPreference key for storing current account.
     */
    public static final String CURRENT_ACCOUNT_SHARED_PREFERENCE_KEY =
            "com.microsoft.identity.client.single_account_credential_cache.current_account";
    private SharedPreferencesFileManager sharedPreferencesFileManager;
    protected SingleAccountPublicClientApplication(@NonNull final PublicClientApplicationConfiguration config) throws MsalClientException {
        super(config);
        initializeSharedPreferenceFileManager(config.getAppContext());
    }
    private void initializeSharedPreferenceFileManager(@NonNull final Context context) {
        sharedPreferencesFileManager = new SharedPreferencesFileManager(
                context,
                SINGLE_ACCOUNT_CREDENTIAL_SHARED_PREFERENCES,
                new StorageHelper(context)
        );
    }
    @Override
    public void getCurrentAccountAsync(@NonNull final CurrentAccountCallback callback) {
        getCurrentAccountAsyncInternal(callback, SINGLE_ACCOUNT_PCA_GET_CURRENT_ACCOUNT_ASYNC);
    }
    private void getCurrentAccountAsyncInternal(@NonNull final CurrentAccountCallback callback,
                                                @NonNull final String publicApiId) {
        TokenMigrationCallback migrationCallback = new TokenMigrationCallback() {
            @Override
            public void onMigrationFinished(int numberOfAccountsMigrated) {
                final CommandParameters params = CommandParametersAdapter.createCommandParameters(mPublicClientConfiguration, mPublicClientConfiguration.getOAuth2TokenCache());
                final List<BaseController> controllers;
                try {
                    controllers = MSALControllerFactory.getAllControllers(
                            mPublicClientConfiguration.getAppContext(),
                            mPublicClientConfiguration.getDefaultAuthority(),
                            mPublicClientConfiguration);
                } catch (MsalClientException e) {
                    callback.onError(e);
                    return;
                }
                final GetCurrentAccountCommand command = new GetCurrentAccountCommand(
                        params,
                        controllers,
                        new CommandCallback<List<ICacheRecord>, BaseException>() {
                            @Override
                            public void onTaskCompleted(final List<ICacheRecord> result) {
                                // To simplify the logic, if more than one account is returned, the first account will be picked.
                                // We do not support switching from MULTIPLE to SINGLE.
                                // See getAccountFromICacheRecordList() for more details.
                                checkCurrentAccountNotifyCallback(callback, result);
                                persistCurrentAccount(result);
                            }
                            @Override
                            public void onError(final BaseException exception) {
                                callback.onError(MsalExceptionAdapter.msalExceptionFromBaseException(exception));
                            }
                            @Override
                            public void onCancel() {
                                //Do nothing
                            }
                        },
                        publicApiId
                );
                CommandDispatcher.submitSilent(command);
            }
        };
        performMigration(migrationCallback);
    }
    @Override
    public ICurrentAccountResult getCurrentAccount() throws InterruptedException, MsalException {
        throwOnMainThread("getCurrentAccount");
        final ResultFuture<AsyncResult<CurrentAccountResult>> future = new ResultFuture<>();
        getCurrentAccountAsyncInternal(
                new CurrentAccountCallback() {
                    @Override
                    public void onAccountLoaded(@Nullable final IAccount activeAccount) {
                        final CurrentAccountResult currentAccountResult = new CurrentAccountResult(
                                activeAccount,
                                null,
                                false
                        );
                        future.setResult(new AsyncResult<>(currentAccountResult, null));
                    }
                    @Override
                    public void onAccountChanged(@Nullable final IAccount priorAccount,
                                                 @Nullable final IAccount currentAccount) {
                        final CurrentAccountResult currentAccountResult = new CurrentAccountResult(
                                currentAccount,
                                priorAccount,
                                false
                        );
                        future.setResult(new AsyncResult<>(currentAccountResult, null));
                    }
                    @Override
                    public void onError(@NonNull final MsalException exception) {
                        future.setResult(new AsyncResult<CurrentAccountResult>(null, exception));
                    }
                },
                SINGLE_ACCOUNT_PCA_GET_CURRENT_ACCOUNT
        );
        try {
            final AsyncResult<CurrentAccountResult> result = future.get();
            if (result.getSuccess()) {
                return result.getResult();
            } else {
                throw result.getException();
            }
        } catch (final ExecutionException e) {
            // Shouldn't be thrown.
            throw new MsalClientException(
                    UNKNOWN_ERROR,
                    "Unknown exception while fetching current account.",
                    e
            );
        }
    }
    private void checkCurrentAccountNotifyCallback(@NonNull final CurrentAccountCallback callback,
                                                   @Nullable final List<ICacheRecord> newAccountRecords) {
        final MultiTenantAccount localAccount = getPersistedCurrentAccount();
        final MultiTenantAccount newAccount = newAccountRecords == null
                ? null
                : getAccountFromICacheRecordList(newAccountRecords);
        if (!isHomeAccountIdMatching(localAccount, newAccount)) {
            callback.onAccountChanged(localAccount, newAccount);
        }
        callback.onAccountLoaded(newAccount);
    }
    @Override
    public void signIn(@NonNull final Activity activity,
                       @Nullable final String loginHint,
                       @NonNull final String[] scopes,
                       @NonNull final AuthenticationCallback callback) {
        final IAccount persistedAccount = getPersistedCurrentAccount();
        if (persistedAccount != null) {
            callback.onError(
                    new MsalClientException(
                            MsalClientException.INVALID_PARAMETER,
                            "An account is already signed in."
                    )
            );
            return;
        }
        final AcquireTokenParameters acquireTokenParameters = buildAcquireTokenParameters(
                activity,
                null,
                scopes,
                null, // account
                null, // uiBehavior
                null, // extraQueryParams
                null,
                null, // authority
                callback,
                loginHint, // loginHint
                null // claimsRequest
        );
        acquireTokenInternal(acquireTokenParameters, SINGLE_ACCOUNT_PCA_SIGN_IN);
    }
    @Override
    public void signIn(@NonNull final Activity activity,
                       @Nullable final String loginHint,
                       @NonNull final String[] scopes,
                       @Nullable final Prompt prompt,
                       @NonNull final AuthenticationCallback callback) {
        final IAccount persistedAccount = getPersistedCurrentAccount();
        if (persistedAccount != null) {
            callback.onError(
                    new MsalClientException(
                            MsalClientException.INVALID_PARAMETER,
                            "An account is already signed in."
                    )
            );
            return;
        }
        final AcquireTokenParameters acquireTokenParameters = buildAcquireTokenParameters(
                activity,
                null,
                scopes,
                null, // account
                prompt, // prompt
                null, // extraQueryParams
                null,
                null, // authority
                callback,
                loginHint, // loginHint
                null // claimsRequest
        );
        acquireTokenInternal(acquireTokenParameters, SINGLE_ACCOUNT_PCA_SIGN_IN_WITH_PROMPT);
    }
    @Override
    public void signInAgain(@NonNull final Activity activity,
                            @NonNull final String[] scopes,
                            @Nullable final Prompt prompt,
                            @NonNull final AuthenticationCallback callback) {
        final MultiTenantAccount persistedCurrentAccount = getPersistedCurrentAccount();
        if (persistedCurrentAccount == null) {
            callback.onError(new MsalClientException(MsalClientException.NO_CURRENT_ACCOUNT,
                    MsalClientException.NO_CURRENT_ACCOUNT_ERROR_MESSAGE));
            return;
        }
        final AcquireTokenParameters acquireTokenParameters = buildAcquireTokenParameters(
                activity,
                null,
                scopes,
                persistedCurrentAccount, // account
                prompt, // prompt
                null, // extraQueryParams
                null,
                null, // authority
                callback,
                null, // loginHint
                null // claimsRequest
        );
        acquireTokenInternal(acquireTokenParameters, SINGLE_ACCOUNT_PCA_EXISTING_SIGN_IN_WITH_PROMPT);
    }
    @Override
    protected CommandCallback<ILocalAuthenticationResult, BaseException> getCommandCallback(
            @NonNull final SilentAuthenticationCallback authenticationCallback,
            @NonNull final TokenParameters tokenParameters) {
        return new CommandCallback<ILocalAuthenticationResult, BaseException>() {
            @Override
            public void onTaskCompleted(@NonNull final ILocalAuthenticationResult localAuthenticationResult) {
                if (authenticationCallback == null) {
                    throw new IllegalStateException(NONNULL_CONSTANTS.CALLBACK + NONNULL_CONSTANTS.NULL_ERROR_SUFFIX);
                }
                persistCurrentAccount(localAuthenticationResult.getCacheRecordWithTenantProfileData());
                postAuthResult(localAuthenticationResult, tokenParameters, authenticationCallback);
            }
            @Override
            public void onError(final BaseException exception) {
                final MsalException msalException = MsalExceptionAdapter.msalExceptionFromBaseException(exception);
                if (authenticationCallback == null) {
                    throw new IllegalStateException(NONNULL_CONSTANTS.CALLBACK + NONNULL_CONSTANTS.NULL_ERROR_SUFFIX);
                } else {
                    authenticationCallback.onError(msalException);
                }
            }
            @Override
            public void onCancel() {
                if (authenticationCallback instanceof AuthenticationCallback) {
                    ((AuthenticationCallback) authenticationCallback).onCancel();
                } else {
                    throw new IllegalStateException("Silent requests cannot be cancelled.");
                }
            }
        };
    }
    /**
     * Returns true if the account ID of both account matches (or both accounts are null).
     * */
    private boolean isHomeAccountIdMatching(@Nullable final IAccount firstAccount, @Nullable final IAccount secondAccount) {
        final MultiTenantAccount firstMultiTenantAccount = firstAccount instanceof MultiTenantAccount ? (MultiTenantAccount) firstAccount : null;
        final MultiTenantAccount secondMultiTenantAccount = secondAccount instanceof MultiTenantAccount ? (MultiTenantAccount) secondAccount : null;
        final String firstMultiTenantAccountId = firstMultiTenantAccount == null ? "" : firstMultiTenantAccount.getHomeAccountId();
        final String secondMultiTenantAccountId = secondMultiTenantAccount == null ? "" : secondMultiTenantAccount.getHomeAccountId();
        return firstMultiTenantAccountId.equalsIgnoreCase(secondMultiTenantAccountId);
    }
    @Override
    public void signOut(@NonNull final SignOutCallback callback) {
        signOutInternal(callback, SINGLE_ACCOUNT_PCA_SIGN_OUT_WITH_CALLBACK);
    }
    void signOutInternal(@NonNull final SignOutCallback callback,
                         @NonNull final String publicApiId) {
        final MultiTenantAccount persistedCurrentAccount = getPersistedCurrentAccount();
        if (persistedCurrentAccount == null) {
            callback.onError(new MsalClientException(MsalClientException.NO_CURRENT_ACCOUNT,
                    MsalClientException.NO_CURRENT_ACCOUNT_ERROR_MESSAGE));
            return;
        }
        final AccountRecord requestAccountRecord = new AccountRecord();
        requestAccountRecord.setEnvironment(persistedCurrentAccount.getEnvironment());
        requestAccountRecord.setHomeAccountId(persistedCurrentAccount.getHomeAccountId());
        final RemoveAccountCommandParameters params =
                CommandParametersAdapter.createRemoveAccountCommandParameters(
                        mPublicClientConfiguration,
                        mPublicClientConfiguration.getOAuth2TokenCache(),
                        requestAccountRecord
                );
        final List<BaseController> controllers;
        try {
            controllers = MSALControllerFactory.getAllControllers(
                    mPublicClientConfiguration.getAppContext(),
                    mPublicClientConfiguration.getDefaultAuthority(),
                    mPublicClientConfiguration);
        } catch (MsalClientException e) {
            callback.onError(e);
            return;
        }
        final RemoveCurrentAccountCommand command = new RemoveCurrentAccountCommand(
                params,
                controllers,
                new CommandCallback<Boolean, BaseException>() {
                    @Override
                    public void onError(BaseException error) {
                        callback.onError(MsalExceptionAdapter.msalExceptionFromBaseException(error));
                    }
                    @Override
                    public void onTaskCompleted(Boolean result) {
                        persistCurrentAccount(null);
                        callback.onSignOut();
                    }
                    @Override
                    public void onCancel() {
                        //Do nothing
                    }
                },
                publicApiId
        );
        CommandDispatcher.submitSilent(command);
    }
    @Override
    public boolean signOut() throws MsalException, InterruptedException {
        throwOnMainThread("signOut");
        final ResultFuture<AsyncResult<Boolean>> future = new ResultFuture<>();
        signOutInternal(
                new SignOutCallback() {
                    @Override
                    public void onSignOut() {
                        future.setResult(new AsyncResult<>(true, null));
                    }
                    @Override
                    public void onError(@NonNull final MsalException exception) {
                        future.setResult(new AsyncResult<>(false, exception));
                    }
                },
                SINGLE_ACCOUNT_PCA_SIGN_OUT
        );
        try {
            final AsyncResult<Boolean> result = future.get();
            if (result.getSuccess()) {
                return result.getResult();
            } else {
                throw result.getException();
            }
        } catch (final ExecutionException e) {
            // Shouldn't be thrown.
            throw new MsalClientException(
                    UNKNOWN_ERROR,
                    "Unexpected error during signOut.",
                    e
            );
        }
    }
    /**
     * Get current account that is persisted in shared preference.
     *
     * @return a persisted MultiTenantAccount. This could be null.
     */
    private MultiTenantAccount getPersistedCurrentAccount() {
        synchronized(SingleAccountPublicClientApplication.class) {
            final String currentAccountJsonString = sharedPreferencesFileManager.getString(CURRENT_ACCOUNT_SHARED_PREFERENCE_KEY);
            if (StringExtensions.isNullOrBlank(currentAccountJsonString)) {
                return null;
            }
            final List<ICacheRecord> cacheRecordList = JsonExtensions.getICacheRecordListFromJsonString(currentAccountJsonString);
            return getAccountFromICacheRecordList(cacheRecordList);
        }
    }
    /**
     * Persists current account to shared preference.
     *
     * @param cacheRecords list of cache record that belongs to an account.
     *                     Please note that this layer will not verify if the list belongs to a single account or not.
     */
    private void persistCurrentAccount(@Nullable final List<ICacheRecord> cacheRecords) {
        synchronized(SingleAccountPublicClientApplication.class) {
            if (cacheRecords == null || cacheRecords.size() == 0) {
                sharedPreferencesFileManager.clear();
                return;
            }
            final String currentAccountJsonString = JsonExtensions.getJsonStringFromICacheRecordList(cacheRecords);
            sharedPreferencesFileManager.putString(CURRENT_ACCOUNT_SHARED_PREFERENCE_KEY, currentAccountJsonString);
        }
    }
    /**
     * Get a MultiTenantAccount from a list of ICacheRecord.
     *
     * @param cacheRecords list of cache record that belongs to an account.
     *                     If the list can be converted to multiple accounts, only the first one will be returned.
     */
    @Nullable
    private MultiTenantAccount getAccountFromICacheRecordList(@NonNull final List<ICacheRecord> cacheRecords) {
        final String methodName = ":getAccountFromICacheRecords";
        if (cacheRecords == null || cacheRecords.size() == 0) {
            return null;
        }
        final List<IAccount> account = AccountAdapter.adapt(cacheRecords);
        if (account.size() != 1) {
            com.microsoft.identity.common.internal.logging.Logger.verbose(
                    TAG + methodName,
                    "Returned cacheRecords were adapted into multiple IAccount. " +
                            "This is unexpected in Single account mode." +
                            "Returning the first adapted account.");
        }
        return (MultiTenantAccount) account.get(0);
    }
    @Override
    public void acquireToken(@NonNull final Activity activity,
                             @NonNull final String[] scopes,
                             @NonNull final AuthenticationCallback callback) {
        final IAccount persistedAccount = getPersistedCurrentAccount();
        if (persistedAccount == null) {
            callback.onError(new MsalClientException(MsalClientException.NO_CURRENT_ACCOUNT,
                    MsalClientException.NO_CURRENT_ACCOUNT_ERROR_MESSAGE));
            return;
        }
        final AcquireTokenParameters acquireTokenParameters = buildAcquireTokenParameters(
                activity,
                null,
                scopes,
                getPersistedCurrentAccount(), // account, could be null.
                null, // uiBehavior
                null, // extraQueryParams
                null, // extraScopes
                null, // authority
                callback,
                null, // loginHint
                null // claimsRequest
        );
        acquireTokenInternal(
                acquireTokenParameters,
                SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_WITH_ACTIVITY_SCOPES_CALLBACK
        );
    }
    @Override
    public void acquireToken(@NonNull final AcquireTokenParameters acquireTokenParameters) {
        final IAccount persistedAccount = getPersistedCurrentAccount();
        // If persistedAccount exists, a matching account or login hint is expected.
        if (persistedAccount != null) {
            // Nothing is provided.
            if (acquireTokenParameters.getAccount() == null &&
                    StringExtensions.isNullOrBlank(acquireTokenParameters.getLoginHint())){
                acquireTokenParameters
                        .getCallback()
                        .onError(new MsalClientException(MsalClientException.CURRENT_ACCOUNT_MISMATCH,
                                MsalClientException.CURRENT_ACCOUNT_MISMATCH_ERROR_MESSAGE));
                return;
            }
            // If account is provided, check if the account's homeAccountId matches with the persisted account's.
            if (acquireTokenParameters.getAccount() != null &&
                    !isHomeAccountIdMatching(persistedAccount, acquireTokenParameters.getAccount())) {
                acquireTokenParameters
                        .getCallback()
                        .onError(new MsalClientException(MsalClientException.CURRENT_ACCOUNT_MISMATCH,
                                MsalClientException.CURRENT_ACCOUNT_MISMATCH_ERROR_MESSAGE));
                return;
            }
            // If login hint is provided, check if the login hint matches with the persisted account's.
            if (!StringExtensions.isNullOrBlank(acquireTokenParameters.getLoginHint()) &&
                    !persistedAccount.getUsername().equalsIgnoreCase(acquireTokenParameters.getLoginHint())){
                acquireTokenParameters
                        .getCallback()
                        .onError(new MsalClientException(MsalClientException.CURRENT_ACCOUNT_MISMATCH,
                                MsalClientException.CURRENT_ACCOUNT_MISMATCH_ERROR_MESSAGE));
                return;
            }
        }
        acquireTokenInternal(acquireTokenParameters, SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_WITH_PARAMETERS);
    }
    @Override
    public void acquireTokenSilentAsync(@NonNull final String[] scopes,
                                        @NonNull final String authority,
                                        @NonNull final SilentAuthenticationCallback callback) {
        final IAccount persistedAccount = getPersistedCurrentAccount();
        if (persistedAccount == null) {
            callback.onError(new MsalClientException(MsalClientException.NO_CURRENT_ACCOUNT,
                    MsalClientException.NO_CURRENT_ACCOUNT_ERROR_MESSAGE));
            return;
        }
        final AcquireTokenSilentParameters acquireTokenSilentParameters = buildAcquireTokenSilentParameters(
                scopes,
                persistedAccount,
                authority,
                false,
                null, // claimsRequest
                callback
        );
        acquireTokenSilentAsyncInternal(
                acquireTokenSilentParameters,
                SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_SILENT_ASYNC_WITH_SCOPES_AUTHORITY_CALLBACK
        );
    }
    @WorkerThread
    public IAuthenticationResult acquireTokenSilent(@NonNull final String[] scopes,
                                                    @NonNull final String authority) throws MsalException, InterruptedException {
        final IAccount persistedAccount = getPersistedCurrentAccount();
        if (persistedAccount == null) {
            throw new MsalClientException(MsalClientException.NO_CURRENT_ACCOUNT,
                    MsalClientException.NO_CURRENT_ACCOUNT_ERROR_MESSAGE);
        }
        return acquireTokenSilentSyncInternal(
                scopes,
                authority,
                persistedAccount,
                false,
                SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_SILENT_WITH_SCOPES_AUTHORITY
        );
    }
    @Override
    public void acquireTokenSilentAsync(@NonNull final AcquireTokenSilentParameters acquireTokenSilentParameters) {
        final IAccount persistedAccount = getPersistedCurrentAccount();
        if (persistedAccount == null) {
            acquireTokenSilentParameters
                    .getCallback()
                    .onError(new MsalClientException(MsalClientException.NO_CURRENT_ACCOUNT,
                            MsalClientException.NO_CURRENT_ACCOUNT_ERROR_MESSAGE));
            return;
        }
        if (!isHomeAccountIdMatching(persistedAccount, acquireTokenSilentParameters.getAccount())) {
            acquireTokenSilentParameters
                    .getCallback()
                    .onError(new MsalClientException(MsalClientException.CURRENT_ACCOUNT_MISMATCH,
                            MsalClientException.CURRENT_ACCOUNT_MISMATCH_ERROR_MESSAGE));
            return;
        }
        acquireTokenSilentAsyncInternal(
                acquireTokenSilentParameters,
                SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_SILENT_ASYNC_WITH_PARAMETERS
        );
    }
    @Override
    public IAuthenticationResult acquireTokenSilent(@NonNull final AcquireTokenSilentParameters acquireTokenSilentParameters) throws InterruptedException, MsalException {
        final IAccount persistedAccount = getPersistedCurrentAccount();
        if (persistedAccount == null) {
            throw new MsalClientException(MsalClientException.NO_CURRENT_ACCOUNT,
                    MsalClientException.NO_CURRENT_ACCOUNT_ERROR_MESSAGE);
        }
        if (!isHomeAccountIdMatching(persistedAccount, acquireTokenSilentParameters.getAccount())) {
            throw new MsalClientException(MsalClientException.CURRENT_ACCOUNT_MISMATCH,
                    MsalClientException.CURRENT_ACCOUNT_MISMATCH_ERROR_MESSAGE);
        }
        return acquireTokenSilentInternal(
                acquireTokenSilentParameters,
                SINGLE_ACCOUNT_PCA_ACQUIRE_TOKEN_SILENT_WITH_PARAMETERS
        );
    }
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import android.app.Activity;
import androidx.annotation.NonNull;
import androidx.annotation.WorkerThread;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.common.internal.controllers.TaskCompletedCallbackWithError;
import java.util.Date;
import java.util.List;
public interface IPublicClientApplication {
    /**
     * Acquire token interactively, will pop-up webUI. Interactive flow will skip the cache lookup.
     * Default value for {@link Prompt} is {@link Prompt#SELECT_ACCOUNT}.
     *
     * @param activity Non-null {@link Activity} that is used as the parent activity for launching the {@link com.microsoft.identity.common.internal.providers.oauth2.AuthorizationActivity}.
     * @param scopes   The non-null array of scopes to be requested for the access token.
     *                 MSAL always sends the scopes 'openid profile offline_access'.  Do not include any of these scopes in the scope parameter.
     * @param callback The {@link AuthenticationCallback} to receive the result back.
     *                 1) If user cancels the flow by pressing the device back button, the result will be sent
     *                 back via {@link AuthenticationCallback#onCancel()}.
     *                 2) If the sdk successfully receives the token back, result will be sent back via
     *                 {@link AuthenticationCallback#onSuccess(IAuthenticationResult)}
     *                 3) All the other errors will be sent back via
     *                 {@link AuthenticationCallback#onError(MsalException)}.
     */
    void acquireToken(@NonNull final Activity activity,
                      @NonNull final String[] scopes,
                      @NonNull final AuthenticationCallback callback
    );
    /**
     * Acquire token interactively, will pop-up webUI. Interactive flow will skip the cache lookup.
     * Default value for {@link Prompt} is {@link Prompt#SELECT_ACCOUNT}.
     * <p>
     * Convey parameters via the AquireTokenParameters object
     *
     * @param acquireTokenParameters
     */
    void acquireToken(@NonNull final AcquireTokenParameters acquireTokenParameters);
    /**
     * Perform acquire token silent call. If there is a valid access token in the cache, the sdk will return the access token; If
     * no valid access token exists, the sdk will try to find a refresh token and use the refresh token to get a new access token. If refresh token does not exist
     * or it fails the refresh, exception will be sent back via callback.
     *
     * @param acquireTokenSilentParameters
     */
    void acquireTokenSilentAsync(@NonNull final AcquireTokenSilentParameters acquireTokenSilentParameters);
    /**
     * Perform acquire token silent call. If there is a valid access token in the cache, the sdk will return the access token; If
     * no valid access token exists, the sdk will try to find a refresh token and use the refresh token to get a new access token. If refresh token does not exist
     * or it fails the refresh, exception will be sent back via callback.
     *
     * @param acquireTokenSilentParameters
     */
    @WorkerThread
    IAuthenticationResult acquireTokenSilent(@NonNull final AcquireTokenSilentParameters acquireTokenSilentParameters) throws InterruptedException, MsalException;
    /**
     * Perform the Device Code Flow (DCF) protocol to allow a device without input capability to authenticate and get a new access token.
     * Currently, flow is only supported in local MSAL. No Broker support.
     *
     * @param scopes   the desired access scopes
     * @param callback callback object used to communicate with the API throughout the protocol
     */
    void acquireTokenWithDeviceCode(@NonNull String[] scopes, @NonNull final DeviceCodeFlowCallback callback);
    /**
     * Returns the PublicClientConfiguration for this instance of PublicClientApplication.
     *
     * @return The PublicClientApplicationConfiguration.
     */
    PublicClientApplicationConfiguration getConfiguration();
    /**
     * Returns whether the application is being run on a device that is marked as a shared.
     * Only SingleAccountPublicClientApplications may be used on shared devices
     *
     * @return
     */
    boolean isSharedDevice();
    /**
     * Signs the provided {@link PoPAuthenticationScheme} parameters into a JWT on behalf of the
     * provided {@link IAccount}.
     * <p>
     * Important: Use of this API requires setting the minimum_required_broker_protocol_version to
     * "6.0" or higher.
     *
     * @param account       The account for whom signing shall occur.
     * @param popParameters The input parameters.
     * @return The resulting SHR.
     */
    @NonNull
    String generateSignedHttpRequest(@NonNull final IAccount account,
                                     @NonNull final PoPAuthenticationScheme popParameters
    ) throws MsalException;
    /**
     * Signs the provided {@link PoPAuthenticationScheme} parameters into a JWT on behalf of the
     * provided {@link IAccount}.
     * <p>
     * Important: Use of this API requires setting the minimum_required_broker_protocol_version to
     * "6.0" or higher.
     *
     * @param account       The account for whom signing shall occur.
     * @param popParameters The input parameters.
     * @param callback      The callback object to receive the result (or error).
     * @return The resulting SHR.
     */
    void generateSignedHttpRequest(@NonNull final IAccount account,
                                   @NonNull final PoPAuthenticationScheme popParameters,
                                   @NonNull final SignedHttpRequestRequestCallback callback
    );
    /**
     * Callback used to receive the result of {@link #generateSignedHttpRequest(IAccount, PoPAuthenticationScheme)}.
     */
    interface SignedHttpRequestRequestCallback extends TaskCompletedCallbackWithError<String, MsalException> {
        /**
         * Called after signing of the supplied properties has finished.
         *
         * @param result The resulting SHR.
         */
        void onTaskCompleted(String result);
        /**
         * Called if an error occurs during signing.
         *
         * @param exception
         */
        void onError(MsalException exception);
    }
    interface LoadAccountsCallback extends TaskCompletedCallbackWithError<List<IAccount>, MsalException> {
        /**
         * Called once succeed and pass the result object.
         *
         * @param result the success result.
         */
        void onTaskCompleted(List<IAccount> result);
        /**
         * Called once exception thrown.
         *
         * @param exception
         */
        void onError(MsalException exception);
    }
    /**
     * Listener callback for asynchronous initialization of IPublicClientApplication object.
     */
    interface ApplicationCreatedListener {
        /**
         * Called once an IPublicClientApplication is successfully created.
         */
        void onCreated(final IPublicClientApplication application);
        /**
         * Called once IPublicClientApplication can't be created.
         */
        void onError(final MsalException exception);
    }
    /**
     * Listener callback for asynchronous initialization of ISingleAccountPublicClientApplication object.
     */
    interface ISingleAccountApplicationCreatedListener {
        /**
         * Called once an ISingleAccountPublicClientApplication is successfully created.
         */
        void onCreated(final ISingleAccountPublicClientApplication application);
        /**
         * Called once ISingleAccountPublicClientApplication can't be created.
         */
        void onError(final MsalException exception);
    }
    /**
     * Listener callback for asynchronous initialization of IMultipleAccountPublicClientApplication object.
     */
    interface IMultipleAccountApplicationCreatedListener {
        /**
         * Called once an IMultipleAccountPublicClientApplication is successfully created.
         */
        void onCreated(final IMultipleAccountPublicClientApplication application);
        /**
         * Called once IMultipleAccountPublicClientApplication can't be created.
         */
        void onError(final MsalException exception);
    }
    /**
     * Callback object used in Device Code Flow.
     * This callback provides the following methods for communicating with the protocol.
     * 1). Receiving authentication information (user_code, verification_uri, and instruction message)
     * via {@link DeviceCodeFlowCallback#onUserCodeReceived(String, String, String, Date)}.
     * 2). Receiving a successful authentication result containing a fresh access token
     * via {@link DeviceCodeFlowCallback#onTokenReceived(AuthenticationResult)}.
     * 3). Receiving an exception detailing what went wrong in the protocol
     * via {@link DeviceCodeFlowCallback#onError(MsalException)}.
     * <p>
     * Refer to {@link PublicClientApplication#acquireTokenWithDeviceCode(String[], DeviceCodeFlowCallback)}.
     */
    interface DeviceCodeFlowCallback {
        /**
         * Invoked to display verification uri, user code, and instruction message during device code flow.
         *
         * @param vUri                  verification uri
         * @param userCode              user code
         * @param message               instruction message
         * @param sessionExpirationDate the expiration date of DCF session to be displayed to the user ONLY.
         *                              When the session expires, onError() will return an exception with DEVICE_CODE_FLOW_EXPIRED_TOKEN_ERROR_CODE.
         *                              Please rely on that exception for non-UX purposes.
         */
        void onUserCodeReceived(@NonNull final String vUri,
                                @NonNull final String userCode,
                                @NonNull final String message,
                                @NonNull final Date sessionExpirationDate);
        /**
         * Invoked once token is received and passes the {@link AuthenticationResult} object.
         *
         * @param authResult the authentication result
         */
        void onTokenReceived(@NonNull final AuthenticationResult authResult);
        /**
         * Invoked if an error is encountered during the device code flow and passes the exception object.
         *
         * @param error error exception
         */
        void onError(@NonNull final MsalException error);
    }
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.Date;
import java.util.UUID;
public interface IAuthenticationResult {
    /**
     * @return The access token requested.
     */
    @NonNull
    String getAccessToken();
    /**
     * Gets the fully-formed Authorization header value. Includes the Authentication scheme.
     * <p>
     * Example: Bearer eyJ1aWQiOiJj.......
     *
     * @return The Authorization header value.
     */
    @NonNull
    String getAuthorizationHeader();
    /**
     * Gets the authentication scheme (Bearer, PoP, etc)....
     *
     * @return The authentication scheme name.
     */
    @NonNull
    String getAuthenticationScheme();
    /**
     * @return The expiration time of the access token returned in the Token property.
     * This value is calculated based on current UTC time measured locally and the value expiresIn returned from the
     * service.
     */
    @NonNull
    Date getExpiresOn();
    /**
     * @return A unique tenant identifier that was used in token acquisition. Could be null if tenant information is not
     * returned by the service.
     */
    @Nullable
    String getTenantId();
    /**
     * Gets the Account.
     *
     * @return The Account to get.
     */
    @NonNull
    IAccount getAccount();
    /**
     * @return The scopes returned from the service.
     */
    @NonNull
    String[] getScope();
    /**
     * Gets the correlation id used during the acquire token request. Could be null if an error
     * occurs when parsing from String or if not set.
     *
     * @return a UUID representing a correlation id
     */
    @Nullable
    UUID getCorrelationId(); // this should never actually be null for MSAL
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import com.microsoft.identity.client.exception.MsalException;
/**
 * Callback passed with token acquisition. {@link IAuthenticationResult} or
 * {@link MsalException} will be returned back via callback.
 */
public interface AuthenticationCallback extends SilentAuthenticationCallback {
    /**
     * Will be called if user cancels the flow.
     */
    void onCancel();
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
public interface ICurrentAccountResult {
    /**
     * Returns the current account signed into the app or in the case of shared device mode.  Signed into the device
     * @return IAccount
     */
    IAccount getCurrentAccount();
    /**
     * If the current signed in account changed as a result of being removed from the device, returns
     * the prior account signed into the app  or in the case of shared device mode.  Signed into the device
     * @return IAccount
     */
    IAccount getPriorAccount();
    /**
     * Indicates whether the current account has changed since last checked.  If changed you can access the prior and current acocunts
     * to perform necessary clean up within the UX.
     * @return
     */
    boolean didAccountChange();
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import androidx.annotation.NonNull;
import java.io.Serializable;
public interface IAccount extends Serializable, IClaimable {
    /**
     * Gets the id of the account.
     * <p>
     * For the Microsoft Identity Platform: the OID of the account in its home tenant.
     *
     * @return The id.
     */
    @NonNull
    String getId();
    @NonNull
    String getAuthority();
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import android.app.Activity;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.annotation.WorkerThread;
import com.microsoft.identity.client.exception.MsalException;
/**
 * An interface that contains list of operations that are available when MSAL is in 'single account' mode.
 * - In this mode, one account can be signed-in to the app.
 * - If the user wants to acquire a token for another account, the previous account must be signed out first.
 * <p>
 * When the device is registered as 'shared', this will be the only available PublicClientApplication the app can obtain.
 * The calling app has to support ISingleAccountPublicClientApplication if it is planning to support shared device mode.
 * <p>
 * In the shared device mode,
 * - 'Sign-in' means that the user will be signed in to the device - not just this app.
 * - Once an account is 'signed-in', every MSAL app on the device that support shared device mode will be able to retrieve this account, and use them to silently perform API calls.
 * - 'Sign-out' means that user will be signed out from the device - every MSAL apps and the default browser.
 */
public interface ISingleAccountPublicClientApplication extends IPublicClientApplication {
    /**
     * Gets the current account and notify if the current account changes.
     * This method must be called whenever the application is resumed or prior to running a scheduled background operation.
     *
     * @param callback a callback to be invoked when the operation finishes.
     */
    void getCurrentAccountAsync(final CurrentAccountCallback callback);
    /**
     * Gets the current account and notify if the current account changes.
     * This method must be called whenever the application is resumed or prior to running a scheduled background operation.
     *
     * @return CurrentAccountResult
     */
    @WorkerThread
    ICurrentAccountResult getCurrentAccount() throws InterruptedException, MsalException;
    /**
     * Allows a user to sign in to your application with one of their accounts. This method may only
     * be called once: once a user is signed in, they must first be signed out before another user
     * may sign in. If you wish to prompt the existing user for credentials use
     * {@link #signInAgain(Activity, String[], Prompt, AuthenticationCallback)} or
     * {@link #acquireToken(AcquireTokenParameters)}.
     * <p>
     * Note: The authority used to make the sign in request will be either the MSAL default: https://login.microsoftonline.com/common
     * or the default authority specified by you in your configuration
     *
     * @param activity  Non-null {@link Activity} that is used as the parent activity for launching the {@link com.microsoft.identity.common.internal.providers.oauth2.AuthorizationActivity}.
     * @param loginHint Optional. If provided, will be used as the query parameter sent for authenticating the user,
     *                  which will have the UPN pre-populated.
     * @param scopes    The non-null array of scopes to be consented to during sign in.
     *                  MSAL always sends the scopes 'openid profile offline_access'.  Do not include any of these scopes in the scope parameter.
     *                  The access token returned is for MS Graph and will allow you to query for additional information about the signed in account.
     * @param callback  {@link AuthenticationCallback} that is used to send the result back. The success result will be
     *                  sent back via {@link AuthenticationCallback#onSuccess(IAuthenticationResult)}.
     *                  Failure case will be sent back via {
     * @link AuthenticationCallback#onError(MsalException)}.
     */
    void signIn(@NonNull final Activity activity,
                @Nullable final String loginHint,
                @NonNull final String[] scopes,
                @NonNull final AuthenticationCallback callback
    );
    /**
     * Allows a user to sign in to your application with one of their accounts. This method may only
     * be called once: once a user is signed in, they must first be signed out before another user
     * may sign in. If you wish to prompt the existing user for credentials use
     * {@link #signInAgain(Activity, String[], Prompt, AuthenticationCallback)} or
     * {@link #acquireToken(AcquireTokenParameters)}.
     * <p>
     * Note: The authority used to make the sign in request will be either the MSAL default: https://login.microsoftonline.com/common
     * or the default authority specified by you in your configuration
     *
     * @param activity  Non-null {@link Activity} that is used as the parent activity for launching the {@link com.microsoft.identity.common.internal.providers.oauth2.AuthorizationActivity}.
     * @param loginHint Optional. If provided, will be used as the query parameter sent for authenticating the user,
     *                  which will have the UPN pre-populated.
     * @param scopes    The non-null array of scopes to be consented to during sign in.
     *                  MSAL always sends the scopes 'openid profile offline_access'.  Do not include any of these scopes in the scope parameter.
     *                  The access token returned is for MS Graph and will allow you to query for additional information about the signed in account.
     * @param callback  {@link AuthenticationCallback} that is used to send the result back. The success result will be
     *                  sent back via {@link AuthenticationCallback#onSuccess(IAuthenticationResult)}.
     *                  Failure case will be sent back via {
     * @link AuthenticationCallback#onError(MsalException)}.
     */
    void signIn(@NonNull final Activity activity,
                @Nullable final String loginHint,
                @NonNull final String[] scopes,
                @Nullable final Prompt prompt,
                @NonNull final AuthenticationCallback callback
    );
    /**
     * Reauthorizes the current account according to the supplied scopes and prompt behavior.
     * <p>
     * Note: The authority used to make the sign in request will be either the MSAL default:
     * https://login.microsoftonline.com/common or the default authority specified by you in your
     * configuration.
     *
     * @param activity Non-null {@link Activity} that is used as the parent activity for
     *                 launching the {@link com.microsoft.identity.common.internal.providers.oauth2.AuthorizationActivity}.
     * @param scopes   The non-null array of scopes to be consented to during sign in.
     *                 MSAL always sends the scopes 'openid profile offline_access'. Do
     *                 not include any of these scopes in the scope parameter. The access
     *                 token returned is for MS Graph and will allow you to query for
     *                 additional information about the signed in account.
     * @param prompt   Nullable. Indicates the type of user interaction that is required.
     *                 If no argument is supplied the default behavior will be used.
     * @param callback {@link AuthenticationCallback} that is used to send the result back.
     *                 The success result will be sent back via
     *                 {@link AuthenticationCallback#onSuccess(IAuthenticationResult)}.
     *                 Failure case will be sent back via {@link AuthenticationCallback#onError(MsalException)}.
     */
    void signInAgain(@NonNull final Activity activity,
                     @NonNull final String[] scopes,
                     @Nullable final Prompt prompt,
                     @NonNull final AuthenticationCallback callback
    );
    /**
     * Signs out the current the Account and Credentials (tokens).
     * NOTE: If a device is marked as a shared device within broker signout will be device wide.
     *
     * @param callback a callback to be invoked when the operation finishes.
     */
    void signOut(@NonNull final SignOutCallback callback);
    /**
     * Signs out the current the Account and Credentials (tokens).
     * NOTE: If a device is marked as a shared device within broker signout will be device wide.
     *
     * @return boolean indicating whether the account was removed successfully
     */
    @WorkerThread
    boolean signOut() throws MsalException, InterruptedException;
    /**
     * Perform acquire token silent call. If there is a valid access token in the cache, the sdk will return the access token; If
     * no valid access token exists, the sdk will try to find a refresh token and use the refresh token to get a new access token. If refresh token does not exist
     * or it fails the refresh, exception will be sent back via callback.
     *
     * @param scopes    The non-null array of scopes to be requested for the access token.
     *                  MSAL always sends the scopes 'openid profile offline_access'.  Do not include any of these scopes in the scope parameter.
     * @param authority Authority to issue the token.
     * @param callback  {@link SilentAuthenticationCallback} that is used to send the result back. The success result will be
     *                  sent back via {@link SilentAuthenticationCallback#onSuccess(IAuthenticationResult)}.
     *                  Failure case will be sent back via {
     * @link AuthenticationCallback#onError(MsalException)}.
     */
    void acquireTokenSilentAsync(@NonNull final String[] scopes,
                                 @NonNull final String authority,
                                 @NonNull final SilentAuthenticationCallback callback
    );
    /**
     * Perform acquire token silent call. If there is a valid access token in the cache, the sdk will return the access token; If
     * no valid access token exists, the sdk will try to find a refresh token and use the refresh token to get a new access token. If refresh token does not exist
     * or it fails the refresh, exception will be sent back via callback.
     *
     * @param scopes    The non-null array of scopes to be requested for the access token.
     *                  MSAL always sends the scopes 'openid profile offline_access'.  Do not include any of these scopes in the scope parameter.
     * @param authority Authority to issue the token.
     */
    @WorkerThread
    IAuthenticationResult acquireTokenSilent(@NonNull final String[] scopes,
                                             @NonNull final String authority) throws MsalException, InterruptedException;
    /**
     * Callback for asynchronous loading of the msal IAccount account.
     */
    interface CurrentAccountCallback {
        /**
         * Invoked when the account is loaded.
         *
         * @param activeAccount the signed-in account. This could be null.
         */
        void onAccountLoaded(@Nullable final IAccount activeAccount);
        /**
         * Invoked when signed-in account is changed after the application resumes, or prior to running a scheduled background operation.
         * The calling app is responsible for keeping track of this account and cleaning its states if the account changes.
         *
         * @param priorAccount   the previous signed-in account. This could be null.
         * @param currentAccount the current signed-in account. This could be null.
         */
        void onAccountChanged(@Nullable final IAccount priorAccount, @Nullable final IAccount currentAccount);
        /**
         * Invoked when the account failed to load.
         *
         * @param exception the exception object.
         */
        void onError(@NonNull final MsalException exception);
    }
    interface SignOutCallback {
        /**
         * Invoked when account successfully signed out
         */
        void onSignOut();
        /**
         * Invoked when the account failed to load.
         *
         * @param exception the exception object.
         */
        void onError(@NonNull final MsalException exception);
    }
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client.msal.automationapp.testpass.broker;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.microsoft.identity.client.AcquireTokenSilentParameters;
import com.microsoft.identity.client.IAccount;
import com.microsoft.identity.client.ISingleAccountPublicClientApplication;
import com.microsoft.identity.client.MultipleAccountPublicClientApplication;
import com.microsoft.identity.client.PublicClientApplication;
import com.microsoft.identity.client.SingleAccountPublicClientApplication;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.client.msal.automationapp.R;
import com.microsoft.identity.client.ui.automation.TokenRequestLatch;
import com.microsoft.identity.client.ui.automation.TokenRequestTimeout;
import com.microsoft.identity.client.ui.automation.annotations.SupportedBrokers;
import com.microsoft.identity.client.ui.automation.app.AzureSampleApp;
import com.microsoft.identity.client.ui.automation.broker.BrokerHost;
import com.microsoft.identity.client.ui.automation.broker.BrokerMicrosoftAuthenticator;
import com.microsoft.identity.client.ui.automation.interaction.PromptParameter;
import com.microsoft.identity.client.ui.automation.interaction.microsoftsts.MicrosoftStsPromptHandlerParameters;
import com.microsoft.identity.internal.testutils.labutils.LabConfig;
import com.microsoft.identity.internal.testutils.labutils.LabConstants;
import com.microsoft.identity.internal.testutils.labutils.LabUserHelper;
import com.microsoft.identity.internal.testutils.labutils.LabUserQuery;
import org.junit.Assert;
import org.junit.Test;
import java.util.Arrays;
// End My Shift - In Shared device mode, an account signed in through App A can be used by App B.
// https://identitydivision.visualstudio.com/DevEx/_workitems/edit/833514
@SupportedBrokers(brokers = {BrokerMicrosoftAuthenticator.class, BrokerHost.class})
public class TestCase833514 extends AbstractMsalBrokerTest {
    @Test
    public void test_833514() throws MsalException, InterruptedException {
        // pca should be in MULTIPLE account mode starting out
        Assert.assertTrue(mApplication instanceof MultipleAccountPublicClientApplication);
        //we should NOT be in shared device mode
        Assert.assertFalse(mApplication.isSharedDevice());
        // perform shared device registration
        mBroker.performSharedDeviceRegistration(
                mLoginHint, LabConfig.getCurrentLabConfig().getLabUserPassword()
        );
        // re-create PCA after device registration
        mApplication = PublicClientApplication.create(mContext, getConfigFileResourceId());
        // pca should now be in SINGLE account mode
        Assert.assertTrue(mApplication instanceof SingleAccountPublicClientApplication);
        // we should be in shared device mode
        Assert.assertTrue(mApplication.isSharedDevice());
        // query to load a user from the same tenant that was used for WPJ
        final LabUserQuery query = new LabUserQuery();
        query.userType = LabConstants.UserType.CLOUD;
        // get username and password for this account
        final String username = LabUserHelper.loadUserForTest(query);
        String password = LabConfig.getCurrentLabConfig().getLabUserPassword();
        // use azure sample app and make sure we do a fresh install
        final AzureSampleApp azureSampleApp = new AzureSampleApp();
        azureSampleApp.uninstall();
        azureSampleApp.install();
        azureSampleApp.launch();
        azureSampleApp.handleFirstRun();
        final MicrosoftStsPromptHandlerParameters microsoftStsPromptHandlerParameters =
                MicrosoftStsPromptHandlerParameters.builder()
                        .prompt(PromptParameter.SELECT_ACCOUNT)
                        .broker(mBroker)
                        .loginHint(null)
                        .consentPageExpected(false)
                        .speedBumpExpected(false)
                        .enrollPageExpected(false)
                        .registerPageExpected(false)
                        .expectingBrokerAccountChooserActivity(false)
                        .expectingLoginPageAccountPicker(false)
                        .isFederated(false)
                        .sessionExpected(false)
                        .build();
        // sign in into Azure Sample App
        azureSampleApp.signInWithSingleAccountFragment(username, password, getBrowser(), false, microsoftStsPromptHandlerParameters);
        // make sure we have successfully signed in
        azureSampleApp.confirmSignedIn(username);
        final SingleAccountPublicClientApplication singleAccountPCA =
                (SingleAccountPublicClientApplication) mApplication;
        final TokenRequestLatch getAccountLatch = new TokenRequestLatch(1);
        final IAccount[] accounts = new IAccount[1];
        // perform get account from MSAL Automation App
        ((SingleAccountPublicClientApplication) mApplication).getCurrentAccountAsync(new ISingleAccountPublicClientApplication.CurrentAccountCallback() {
            @Override
            public void onAccountLoaded(@Nullable IAccount activeAccount) {
                assert activeAccount != null;
                Assert.assertEquals(activeAccount.getUsername(), username);
                accounts[0] = activeAccount;
                getAccountLatch.countDown();
            }
            @Override
            public void onAccountChanged(@Nullable IAccount priorAccount, @Nullable IAccount currentAccount) {
                assert currentAccount != null;
                Assert.assertEquals(currentAccount.getUsername(), username);
                accounts[0] = currentAccount;
                getAccountLatch.countDown();
            }
            @Override
            public void onError(@NonNull MsalException exception) {
                Assert.fail(exception.getMessage());
                getAccountLatch.countDown();
            }
        });
        getAccountLatch.await(TokenRequestTimeout.SILENT);
        final TokenRequestLatch silentLatch = new TokenRequestLatch(1);
        // perform acquire token silent with account used for get account
        final AcquireTokenSilentParameters silentParameters = new AcquireTokenSilentParameters.Builder()
                .fromAuthority(getAuthority())
                .forAccount(accounts[0])
                .withScopes(Arrays.asList(mScopes))
                .withCallback(successfulSilentCallback(silentLatch))
                .build();
        singleAccountPCA.acquireTokenSilentAsync(silentParameters);
        silentLatch.await(TokenRequestTimeout.SILENT);
    }
    @Override
    public LabUserQuery getLabUserQuery() {
        final LabUserQuery query = new LabUserQuery();
        query.userRole = LabConstants.UserRole.CLOUD_DEVICE_ADMINISTRATOR;
        return query;
    }
    @Override
    public String getTempUserType() {
        return null;
    }
    @Override
    public String[] getScopes() {
        return new String[]{"User.read"};
    }
    @Override
    public String getAuthority() {
        return mApplication.getConfiguration().getDefaultAuthority().getAuthorityURL().toString();
    }
    @Override
    public int getConfigFileResourceId() {
        return R.raw.msal_config_default;
    }
}
//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
package com.microsoft.identity.client;
import android.app.Activity;
import android.content.Context;
import android.content.ContextWrapper;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.os.Bundle;
import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import com.microsoft.identity.client.exception.MsalClientException;
import com.microsoft.identity.client.exception.MsalException;
import com.microsoft.identity.client.internal.MsalUtils;
import com.microsoft.identity.common.adal.internal.AuthenticationSettings;
import com.microsoft.identity.common.internal.net.HttpUrlConnectionFactory;
import com.microsoft.identity.msal.test.R;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Matchers;
import org.mockito.Mockito;
import java.io.IOException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.List;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import static junit.framework.TestCase.assertEquals;
import static junit.framework.TestCase.fail;
/**
 * Tests for {@link PublicClientApplication}.
 */
@RunWith(AndroidJUnit4.class)
public final class PublicClientApplicationTest {
    private Context mAppContext;
    private static final String CLIENT_ID = "client-id";
    private static final String[] SCOPE = {"scope1", "scope2"};
    public static final String TEST_REDIRECT_URI = "msauth://com.microsoft.identity.client.sample.local/signature";
    @Before
    public void setUp() {
        System.setProperty(
                "dexmaker.dexcache",
                androidx.test.platform.app.InstrumentationRegistry
                        .getInstrumentation()
                        .getTargetContext()
                        .getCacheDir()
                        .getPath()
        );
        System.setProperty(
                "org.mockito.android.target",
                ApplicationProvider
                        .getApplicationContext()
                        .getCacheDir()
                        .getPath()
        );
        mAppContext = androidx.test.platform.app.InstrumentationRegistry.getInstrumentation().getContext().getApplicationContext();
    }
    @After
    public void tearDown() {
        HttpUrlConnectionFactory.clearMockedConnectionQueue();
        AndroidTestUtil.removeAllTokens(mAppContext);
    }
    @Test(expected = IllegalArgumentException.class)
    public void testConfigValidationFailsOnEmptyRedirect() throws MsalException, InterruptedException {
        final Context context = new PublicClientApplicationTest.MockContext(mAppContext);
        mockPackageManagerWithDefaultFlag(context);
        mockHasCustomTabRedirect(context);
        final IMultipleAccountPublicClientApplication app = PublicClientApplication.createMultipleAccountPublicClientApplication(
                context,
                R.raw.test_pcaconfig_empty_redirect
        );
    }
    @Test(expected = IllegalArgumentException.class)
    public void testConfigValidationFailsOnEmptyClientId() throws MsalException, InterruptedException {
        final Context context = new PublicClientApplicationTest.MockContext(mAppContext);
        mockPackageManagerWithDefaultFlag(context);
        mockHasCustomTabRedirect(context);
        final IMultipleAccountPublicClientApplication app = PublicClientApplication.createMultipleAccountPublicClientApplication(
                context,
                R.raw.test_pcaconfig_empty_clientid
        );
    }
    @Test
    public void testSingleAccountConstructor() {
        final Context context = new PublicClientApplicationTest.MockContext(mAppContext);
        mockPackageManagerWithDefaultFlag(context);
        mockHasCustomTabRedirect(context);
        try {
            final ISingleAccountPublicClientApplication app = PublicClientApplication.createSingleAccountPublicClientApplication(
                    context,
                    R.raw.test_msal_config_single_account
            );
            Assert.assertTrue(app instanceof ISingleAccountPublicClientApplication);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (MsalException e) {
            e.printStackTrace();
        }
    }
    @Test
    public void testMultipleAccountConstructor() {
        final Context context = new PublicClientApplicationTest.MockContext(mAppContext);
        mockPackageManagerWithDefaultFlag(context);
        mockHasCustomTabRedirect(context);
        try {
            final IMultipleAccountPublicClientApplication app = PublicClientApplication.createMultipleAccountPublicClientApplication(
                    context,
                    R.raw.test_msal_config_multiple_account
            );
            Assert.assertTrue(app instanceof IMultipleAccountPublicClientApplication);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (MsalException e) {
            e.printStackTrace();
        }
    }
    @Test
    public void testMultipleAccountAsyncConstructor() {
        final Context context = new PublicClientApplicationTest.MockContext(mAppContext);
        mockPackageManagerWithDefaultFlag(context);
        mockHasCustomTabRedirect(context);
        PublicClientApplication.createMultipleAccountPublicClientApplication(
                context,
                R.raw.test_msal_config_multiple_account,
                new PublicClientApplication.IMultipleAccountApplicationCreatedListener() {
                    @Override
                    public void onCreated(IMultipleAccountPublicClientApplication application) {
                        Assert.assertTrue(application instanceof IMultipleAccountPublicClientApplication);
                    }
                    @Override
                    public void onError(MsalException exception) {
                        Assert.assertTrue(false);
                    }
                });
    }
    @Test
    public void testFailingMultipleAccountAsyncConstructor() {
        final Context context = new PublicClientApplicationTest.MockContext(mAppContext);
        mockPackageManagerWithDefaultFlag(context);
        mockHasCustomTabRedirect(context);
        PublicClientApplication.createMultipleAccountPublicClientApplication(
                context,
                R.raw.test_msal_config_single_account,
                new PublicClientApplication.IMultipleAccountApplicationCreatedListener() {
                    @Override
                    public void onCreated(IMultipleAccountPublicClientApplication application) {
                        Assert.assertTrue(false);
                    }
                    @Override
                    public void onError(MsalException exception) {
                        Assert.assertTrue("Expecting error.", true);
                    }
                });
    }
    @Test
    public void testSingleAccountAsyncConstructor() {
        final Context context = new PublicClientApplicationTest.MockContext(mAppContext);
        mockPackageManagerWithDefaultFlag(context);
        mockHasCustomTabRedirect(context);
        PublicClientApplication.createSingleAccountPublicClientApplication(
                context,
                R.raw.test_msal_config_single_account,
                new PublicClientApplication.ISingleAccountApplicationCreatedListener() {
                    @Override
                    public void onCreated(ISingleAccountPublicClientApplication application) {
                        Assert.assertTrue(application instanceof ISingleAccountPublicClientApplication);
                    }
                    @Override
                    public void onError(MsalException exception) {
                    }
                });
    }
    @Test
    public void testFailingSingleAccountAsyncConstructor() {
        final Context context = new PublicClientApplicationTest.MockContext(mAppContext);
        mockPackageManagerWithDefaultFlag(context);
        mockHasCustomTabRedirect(context);
        PublicClientApplication.createSingleAccountPublicClientApplication(
                context,
                R.raw.test_msal_config_multiple_account,
                new PublicClientApplication.ISingleAccountApplicationCreatedListener() {
                    @Override
                    public void onCreated(ISingleAccountPublicClientApplication application) {
                        Assert.assertTrue(false);
                    }
                    @Override
                    public void onError(MsalException exception) {
                        Assert.assertTrue("Expecting error.", true);
                    }
                });
    }
    /**
     * Verify correct exception is thrown if callback is not provided.
     */
    @Ignore
    @Test(expected = IllegalArgumentException.class)
    public void testCallBackEmpty() throws PackageManager.NameNotFoundException, MsalClientException {
        final Context context = new MockContext(mAppContext);
        mockPackageManagerWithClientId(context, null, CLIENT_ID);
        mockHasCustomTabRedirect(context);
        mockPackageManagerWithDefaultFlag(context);
        final PublicClientApplicationConfiguration config = PublicClientApplicationConfigurationFactory.initializeConfiguration(context);
        config.setRedirectUri(TEST_REDIRECT_URI);
        config.setClientId(CLIENT_ID);
        final PublicClientApplication application = new PublicClientApplication(config);
        application.acquireToken(getActivity(context), SCOPE, null);
    }
    @Test(expected = IllegalStateException.class)
    public void testInternetPermissionMissing() throws PackageManager.NameNotFoundException, MsalClientException {
        final Context context = new MockContext(mAppContext);
        final PackageManager packageManager = context.getPackageManager();
        mockPackageManagerWithClientId(context, null, CLIENT_ID);
        mockHasCustomTabRedirect(context);
        mockPackageManagerWithDefaultFlag(context);
        Mockito.when(packageManager.checkPermission(Mockito.refEq("android.permission.INTERNET"),
                Mockito.refEq(mAppContext.getPackageName()))).thenReturn(PackageManager.PERMISSION_DENIED);
        PublicClientApplicationConfiguration config = PublicClientApplicationConfigurationFactory.initializeConfiguration(context);
        config.setRedirectUri(TEST_REDIRECT_URI);
        config.setClientId(CLIENT_ID);
        new PublicClientApplication(config);
    }
    @Test
    @Ignore
    public void testUnknownAuthorityException() throws PackageManager.NameNotFoundException, IOException,
            InterruptedException {
        //TODO: to be replaced with Robolectric
    }
    @Test(expected = IllegalArgumentException.class)
    @Ignore
    public void testAcquireTokenInteractiveScopeWithEmptyString() throws PackageManager.NameNotFoundException, IOException,
            InterruptedException {
        //TODO: to be replaced with Robolectric
    }
    @Test
    @Ignore
    public void testClientInfoNotReturned() throws PackageManager.NameNotFoundException, IOException,
            InterruptedException {
        //TODO: to be replaced with Robolectric
    }
    /**
     * Verify {@link PublicClientApplication#acquireToken(Activity, String[], String, UiBehavior, List, String[],
     * String, AuthenticationCallback)}. Also check if authority is set on the manifest, we read the authority
     * from manifest meta-data.
     * <p>
     * NOTE: Ignoring until we've updated the code to do authority validation per the new design.  Currently setting an authority other than the default will fail.
     */
    @Test
    @Ignore
    public void testAuthoritySetInManifestGetTokenFailed() {
        //TODO: to be replaced with Robolectric
    }
    /**
     * Verify {@link PublicClientApplication#acquireToken(Activity, String[], String, UiBehavior, List, String[], String, AuthenticationCallback)}.
     */
    // TODO: suppress the test. The purpose is that the API call will eventually send back the cancel to caller.
    @Ignore
    @Test
    public void testGetTokenWithExtraQueryParam()
            throws PackageManager.NameNotFoundException, IOException, InterruptedException {
        //TODO: to be replaced with Robolectric
    }
    @Test
    @Ignore
    public void testB2cAuthorityNotInTrustedList() throws PackageManager.NameNotFoundException, IOException, InterruptedException {
        //TODO: to be replaced with Robolectric
    }
    @Test
    public void testSecretKeysAreSet() throws NoSuchAlgorithmException, InvalidKeySpecException, MsalClientException {
        final Context context = new MockContext(mAppContext);
        mockHasCustomTabRedirect(context);
        mockPackageManagerWithDefaultFlag(context);
        final PublicClientApplicationConfiguration config = PublicClientApplicationConfigurationFactory.initializeConfiguration(context);
        config.setRedirectUri(TEST_REDIRECT_URI);
        config.setClientId(CLIENT_ID);
        final PublicClientApplication pca = new PublicClientApplication(config);
        final PublicClientApplicationConfiguration appConfig = pca.getConfiguration();
        SecretKeyFactory keyFactory = SecretKeyFactory
                .getInstance("PBEWithSHA256And256BitAES-CBC-BC");
        SecretKey generatedSecretKey = keyFactory.generateSecret(
                new PBEKeySpec(
                        "test_password".toCharArray(),
                        "byte-code-for-your-salt".getBytes(),
                        100,
                        256
                )
        );
        SecretKey secretKey = new SecretKeySpec(generatedSecretKey.getEncoded(), "AES");
        final byte[] encodedSecretKey = secretKey.getEncoded();
        appConfig.setTokenCacheSecretKeys(encodedSecretKey);
        // Check that the AuthenticationSettings.INSTANCE.secretKey matches the value configured
        assertEquals(
                encodedSecretKey,
                AuthenticationSettings.INSTANCE.getSecretKeyData()
        );
    }
    private void mockPackageManagerWithClientId(final Context context, final String alternateAuthorityInManifest,
                                                final String clientId)
            throws PackageManager.NameNotFoundException {
        final PackageManager mockedPackageManager = context.getPackageManager();
        final ApplicationInfo applicationInfo = Mockito.mock(ApplicationInfo.class);
        // meta data is empty, no client id there.
        applicationInfo.metaData = new Bundle();
        if (!MsalUtils.isEmpty(clientId)) {
            applicationInfo.metaData.putString("com.microsoft.identity.client.ClientId", clientId);
        }
        if (!MsalUtils.isEmpty(alternateAuthorityInManifest)) {
            applicationInfo.metaData.putString("com.microsoft.identity.client.AuthorityMetadata", alternateAuthorityInManifest);
        }
        Mockito.when(mockedPackageManager.getApplicationInfo(
                Mockito.refEq(mAppContext.getPackageName()), Mockito.eq(
                        PackageManager.GET_META_DATA))).thenReturn(applicationInfo);
        final PackageInfo mockedPackageInfo = Mockito.mock(PackageInfo.class);
        Mockito.when(mockedPackageManager.getPackageInfo(Mockito.anyString(), Mockito.anyInt())).thenReturn(mockedPackageInfo);
    }
    private void mockPackageManagerWithDefaultFlag(final Context context) {
        // This is to bypass telemetry initialization code.
        try {
            final ApplicationInfo applicationInfo = Mockito.mock(ApplicationInfo.class);
            Mockito.when(context.getPackageManager().getApplicationInfo(mAppContext.getPackageName(), 0))
                    .thenReturn(applicationInfo);
            final PackageInfo packageInfo = Mockito.mock(PackageInfo.class);
            Mockito.when(context.getPackageManager().getPackageInfo(mAppContext.getPackageName(), 0))
                    .thenReturn(packageInfo);
        } catch (Exception e) {
            fail();
        }
    }
    private void mockHasCustomTabRedirect(final Context context) {
        final PackageManager packageManager = context.getPackageManager();
        final List<ResolveInfo> resolveInfos = new ArrayList<>();
        Mockito.when(packageManager.queryIntentActivities(Matchers.any(Intent.class),
                Matchers.eq(PackageManager.GET_RESOLVED_FILTER))).thenReturn(resolveInfos);
        final ResolveInfo mockedResolveInfo1 = Mockito.mock(ResolveInfo.class);
        final ActivityInfo mockedActivityInfo1 = Mockito.mock(ActivityInfo.class);
        mockedActivityInfo1.name = BrowserTabActivity.class.getName();
        mockedResolveInfo1.activityInfo = mockedActivityInfo1;
        resolveInfos.add(mockedResolveInfo1);
    }
    private Activity getActivity(final Context context) {
        final Activity mockedActivity = Mockito.mock(Activity.class);
        Mockito.when(mockedActivity.getApplicationContext()).thenReturn(context);
        return mockedActivity;
    }
    public static class MockContext extends ContextWrapper {
        private final PackageManager mPackageManager;
        private final ConnectivityManager mConnectivityManager;
        MockContext(final Context context) {
            super(context);
            mPackageManager = Mockito.mock(PackageManager.class);
            mConnectivityManager = Mockito.mock(ConnectivityManager.class);
        }
        @Override
        public PackageManager getPackageManager() {
            return mPackageManager;
        }
        @Override
        public Object getSystemService(String name) {
            if (Context.CONNECTIVITY_SERVICE.equals(name)) {
                return mConnectivityManager;
            }
            return super.getSystemService(name);
        }
    }
}