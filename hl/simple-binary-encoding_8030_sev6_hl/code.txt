/*
 * Copyright 2013-2025 Real Logic Limited.
 * Copyright 2017 MarketFactory Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.csharp;
import uk.co.real_logic.sbe.generation.CodeGenerator;
import uk.co.real_logic.sbe.generation.TargetCodeGenerator;
import uk.co.real_logic.sbe.generation.TargetCodeGeneratorLoader;
import uk.co.real_logic.sbe.ir.Ir;
import static uk.co.real_logic.sbe.SbeTool.TYPES_PACKAGE_OVERRIDE;
/**
 * {@link CodeGenerator} factory for the CSharp target programming language.
 */
public class CSharp implements TargetCodeGenerator
{
    private static final boolean GENERATE_DTOS = Boolean.getBoolean("sbe.csharp.generate.dtos");
    /**
     * {@inheritDoc}
     */
    public CodeGenerator newInstance(final Ir ir, final String outputDir)
    {
        final boolean shouldSupportTypesPackageNames = Boolean.getBoolean(TYPES_PACKAGE_OVERRIDE);
        final CSharpGenerator flyweightGenerator = new CSharpGenerator(
            ir,
            TargetCodeGeneratorLoader.precedenceChecks(),
            shouldSupportTypesPackageNames,
            new CSharpNamespaceOutputManager(outputDir, ir.applicableNamespace()));
        if (GENERATE_DTOS)
        {
            final CSharpDtoGenerator dtoGenerator = new CSharpDtoGenerator(
                ir,
                shouldSupportTypesPackageNames,
                new CSharpNamespaceOutputManager(outputDir, ir.applicableNamespace()));
            return () ->
            {
                flyweightGenerator.generate();
                dtoGenerator.generate();
            };
        }
        return flyweightGenerator;
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation;
import uk.co.real_logic.sbe.ir.Ir;
/**
 * Target a code generator for a given language.
 */
public interface TargetCodeGenerator
{
    /**
     * Get a new {@link CodeGenerator} for the given target language.
     *
     * @param ir        describing the message schemas from which code should be generated.
     * @param outputDir to which the generated code with be written.
     * @return a new instance of a {@link CodeGenerator} for the given target language.
     */
    CodeGenerator newInstance(Ir ir, String outputDir);
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 * Copyright (C) 2017 MarketFactory, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.csharp;
import org.agrona.generation.OutputManager;
import org.agrona.Verify;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import static java.io.File.separatorChar;
import static uk.co.real_logic.sbe.SbeTool.CSHARP_GENERATE_NAMESPACE_DIR;
/**
 * {@link OutputManager} for managing the creation of C# source files as the target of code generation.
 * <p>
 * The character encoding for the {@link java.io.Writer} is UTF-8.
 */
public class CSharpNamespaceOutputManager implements OutputManager
{
    private final File outputDir;
    /**
     * Create a new {@link OutputManager} for generating C# source
     * files into a given package.
     *
     * @param baseDirName for the generated source code.
     * @param packageName for the generated source code relative to the baseDirName.
     */
    public CSharpNamespaceOutputManager(final String baseDirName, final String packageName)
    {
        Verify.notNull(baseDirName, "baseDirName");
        Verify.notNull(packageName, "packageName");
        final String dirName = baseDirName.endsWith("" + separatorChar) ? baseDirName : baseDirName + separatorChar;
        final boolean genNamespace = Boolean.parseBoolean(System.getProperty(CSHARP_GENERATE_NAMESPACE_DIR, "true"));
        final String packageComponent = genNamespace ? packageName.replace('.', '_') : "";
        final String packageDirName = dirName + packageComponent;
        outputDir = new File(packageDirName);
        if (!outputDir.exists() && !outputDir.mkdirs())
        {
            throw new IllegalStateException("Unable to create directory: " + packageDirName);
        }
    }
    /**
     * Create a new output which will be a C# source file in the given package.
     * <p>
     * The {@link java.io.Writer} should be closed once the caller has finished with it. The Writer is
     * buffered for efficient IO operations.
     *
     * @param name the name of the C# class.
     * @return a {@link java.io.Writer} to which the source code should be written.
     * @throws IOException if an issue occurs when creating the file.
     */
    public Writer createOutput(final String name) throws IOException
    {
        final File targetFile = new File(outputDir, name + ".g.cs");
        return Files.newBufferedWriter(targetFile.toPath(), StandardCharsets.UTF_8);
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.ir;
import org.agrona.Verify;
import uk.co.real_logic.sbe.SbeTool;
import java.nio.ByteOrder;
import java.util.*;
import java.util.regex.Pattern;
/**
 * Intermediate Representation (IR) of SBE messages to be used for the generation of encoders and decoders
 * as stubs in various languages.
 */
public class Ir
{
    private final String packageName;
    private final String namespaceName;
    private final int id;
    private final int version;
    private final String description;
    private final String semanticVersion;
    private final ByteOrder byteOrder;
    private final HeaderStructure headerStructure;
    private final Map<Long, List<Token>> messagesByIdMap = new HashMap<>();
    private final Map<String, List<Token>> typesByNameMap = new HashMap<>();
    private final String[] namespaces;
    /**
     * Create a new IR container taking a defensive copy of the headerStructure {@link Token}s passed.
     *
     * @param packageName     that should be applied to generated code.
     * @param namespaceName   that should be applied to generated code.
     * @param id              identifier for the schema.
     * @param version         of the schema.
     * @param description     of the schema.
     * @param semanticVersion semantic version for mapping to the application domain.
     * @param byteOrder       byte order for all types in the schema.
     * @param headerTokens    representing the message headerStructure.
     */
    public Ir(
        final String packageName,
        final String namespaceName,
        final int id,
        final int version,
        final String description,
        final String semanticVersion,
        final ByteOrder byteOrder,
        final List<Token> headerTokens)
    {
        Verify.notNull(packageName, "packageName");
        Verify.notNull(headerTokens, "headerTokens");
        this.packageName = packageName;
        this.namespaceName = namespaceName;
        this.id = id;
        this.version = version;
        this.description = description;
        this.semanticVersion = semanticVersion;
        this.byteOrder = byteOrder;
        this.headerStructure = new HeaderStructure(new ArrayList<>(headerTokens));
        captureTypes(headerTokens, 0, headerTokens.size() - 1);
        this.namespaces = Ir.getNamespaces(namespaceName == null ? packageName : namespaceName);
    }
    /**
     * Return the {@link HeaderStructure} description for all messages.
     *
     * @return the {@link HeaderStructure} description for all messages.
     */
    public HeaderStructure headerStructure()
    {
        return headerStructure;
    }
    /**
     * Add a List of {@link Token}s for a given message id.
     *
     * @param messageId     to identify the list of tokens for the message.
     * @param messageTokens the List of {@link Token}s representing the message.
     */
    public void addMessage(final long messageId, final List<Token> messageTokens)
    {
        Verify.notNull(messageTokens, "messageTokens");
        captureTypes(messageTokens, 0, messageTokens.size() - 1);
        updateComponentTokenCounts(messageTokens);
        messagesByIdMap.put(messageId, new ArrayList<>(messageTokens));
    }
    /**
     * Get the getMessage for a given identifier.
     *
     * @param messageId to get.
     * @return the List of {@link Token}s representing the message or null if the id is not found.
     */
    public List<Token> getMessage(final long messageId)
    {
        return messagesByIdMap.get(messageId);
    }
    /**
     * Get the type representation for a given type name.
     *
     * @param name of type to get.
     * @return the List of {@link Token}s representing the type or null if the name is not found.
     */
    public List<Token> getType(final String name)
    {
        return typesByNameMap.get(name);
    }
    /**
     * Get the {@link Collection} of types in for this schema.
     *
     * @return the {@link Collection} of types in for this schema.
     */
    public Collection<List<Token>> types()
    {
        return typesByNameMap.values();
    }
    /**
     * The {@link Collection} of messages in this schema.
     *
     * @return the {@link Collection} of messages in this schema.
     */
    public Collection<List<Token>> messages()
    {
        return messagesByIdMap.values();
    }
    /**
     * Get the package name to be used for generated code.
     *
     * @return the package name to be used for generated code.
     */
    public String packageName()
    {
        return packageName;
    }
    /**
     * Get the namespaceName to be used for generated code.
     *
     * @return the namespaceName to be used for generated code.
     */
    public String namespaceName()
    {
        return namespaceName;
    }
    /**
     * Get the namespaces array to be used for generated code.
     *
     * @return the namespaces array to be used for generated code.
     */
    public String[] namespaces()
    {
        return namespaces;
    }
    /**
     * Get the id number of the schema.
     *
     * @return id number of the schema.
     */
    public int id()
    {
        return id;
    }
    /**
     * Get the version of the schema.
     *
     * @return version number.
     */
    public int version()
    {
        return version;
    }
    /**
     * Get the description for the schema.
     *
     * @return the description for the schema.
     */
    public String description()
    {
        return description;
    }
    /**
     * Get the semantic version of the schema.
     *
     * @return the semantic version of the schema as applicable to the layer 7 application.
     */
    public String semanticVersion()
    {
        return semanticVersion;
    }
    /**
     * {@link ByteOrder} for all types in the schema.
     *
     * @return {@link ByteOrder} for all types in the schema.
     */
    public ByteOrder byteOrder()
    {
        return byteOrder;
    }
    /**
     * Get the namespaceName to be used for generated code.
     * <p>
     * If {@link #namespaceName} is null then {@link #packageName} is used.
     *
     * @return the namespaceName to be used for generated code.
     */
    public String applicableNamespace()
    {
        return namespaceName == null ? packageName : namespaceName;
    }
    /**
     * Iterate over a list of {@link Token}s and update their counts of how many tokens make up each component.
     *
     * @param tokens not be updated.
     */
    public static void updateComponentTokenCounts(final List<Token> tokens)
    {
        final Map<String, Deque<Integer>> map = new HashMap<>();
        for (int i = 0, size = tokens.size(); i < size; i++)
        {
            final Token token = tokens.get(i);
            final Signal signal = token.signal();
            if (signal.name().startsWith("BEGIN_"))
            {
                final String componentType = signal.name().substring(6);
                map.computeIfAbsent(componentType, (key) -> new LinkedList<>()).push(i);
            }
            else if (signal.name().startsWith("END_"))
            {
                final String componentType = signal.name().substring(4);
                final int beginIndex = map.get(componentType).pop();
                final int componentTokenCount = (i - beginIndex) + 1;
                tokens.get(beginIndex).componentTokenCount(componentTokenCount);
                token.componentTokenCount(componentTokenCount);
            }
        }
    }
    /**
     * Construct an array of namespace strings based on the supplied namespaceName,
     * accounting for the CPP_NAMESPACES_COLLAPSE option.
     *
     * @param namespaceName a namespace name that may contain period-separated nested namespaces
     * @return an array of nested namespace strings
     */
    public static String[] getNamespaces(final String namespaceName)
    {
        if ("true".equals(System.getProperty(SbeTool.CPP_NAMESPACES_COLLAPSE)))
        {
            return new String[]{ namespaceName.replace(".", "_") };
        }
        else
        {
            return Pattern.compile("\\.").split(namespaceName);
        }
    }
    private void captureTypes(final List<Token> tokens, final int beginIndex, final int endIndex)
    {
        for (int i = beginIndex; i <= endIndex; i++)
        {
            final Token token = tokens.get(i);
            final int typeBeginIndex = i;
            switch (token.signal())
            {
                case BEGIN_COMPOSITE:
                    i = captureType(tokens, i, Signal.END_COMPOSITE, token.name(), token.referencedName());
                    captureTypes(tokens, typeBeginIndex + 1, i - 1);
                    break;
                case BEGIN_ENUM:
                    i = captureType(tokens, i, Signal.END_ENUM, token.name(), token.referencedName());
                    break;
                case BEGIN_SET:
                    i = captureType(tokens, i, Signal.END_SET, token.name(), token.referencedName());
                    break;
                default:
                    break;
            }
        }
    }
    private int captureType(
        final List<Token> tokens,
        final int index,
        final Signal endSignal,
        final String name,
        final String referencedName)
    {
        final List<Token> typeTokens = new ArrayList<>();
        int i = index;
        Token token = tokens.get(i);
        typeTokens.add(token);
        do
        {
            token = tokens.get(++i);
            typeTokens.add(token);
        }
        while (endSignal != token.signal() || !name.equals(token.name()));
        updateComponentTokenCounts(typeTokens);
        final String typeName = null == referencedName ? name : referencedName;
        final List<Token> existingTypeTokens = typesByNameMap.get(typeName);
        if (null == existingTypeTokens || existingTypeTokens.get(0).version() > typeTokens.get(0).version())
        {
            typesByNameMap.put(typeName, typeTokens);
        }
        return i;
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.xml;
import java.util.HashMap;
import java.util.Map;
/**
 * Entry point for schema transformations, will check all incoming configuration/properties and create the appropriate
 * transformers as required.
 */
public class SchemaTransformerFactory implements SchemaTransformer
{
    private final SchemaTransformer transformer;
    /**
     * Construct the SchemaTransformerFactory with the specified configuration for filtering the messages and types by
     * version.
     *
     * @param schemaTransformConfig configuration for the sinceVersion transformation
     * @see uk.co.real_logic.sbe.SbeTool#SCHEMA_TRANSFORM_VERSION
     */
    public SchemaTransformerFactory(final String schemaTransformConfig)
    {
        transformer = parse(schemaTransformConfig);
    }
    /**
     * {@inheritDoc}
     */
    public MessageSchema transform(final MessageSchema originalSchema)
    {
        return transformer.transform(originalSchema);
    }
    static SchemaTransformer parse(final String configuration)
    {
        if (null == configuration || configuration.isEmpty())
        {
            return IDENTITY_TRANSFORMER;
        }
        final String[] split = configuration.split(",");
        if (0 == split.length)
        {
            return IDENTITY_TRANSFORMER;
        }
        final HashMap<Integer, SchemaTransformer> transformerBySchemaId = new HashMap<>();
        parseComponents(split, transformerBySchemaId);
        SchemaTransformer defaultTransformer = transformerBySchemaId.remove(-1);
        defaultTransformer = null != defaultTransformer ? defaultTransformer : IDENTITY_TRANSFORMER;
        return transformerBySchemaId.isEmpty() ?
            defaultTransformer : new IdKeyedSchemaTransformer(transformerBySchemaId, defaultTransformer);
    }
    private static void parseComponents(
        final String[] configuration,
        final Map<Integer, SchemaTransformer> transformerBySchemaId)
    {
        for (final String field : configuration)
        {
            final String[] fieldParts = field.split(":");
            if (2 != fieldParts.length)
            {
                throw new IllegalArgumentException("version transformation property part '" + field + "' is invalid");
            }
            final int schemaId = "*".equals(fieldParts[0]) ? -1 : Integer.parseInt(fieldParts[0].trim());
            final int sinceVersion = Integer.parseInt(fieldParts[1].trim());
            transformerBySchemaId.put(schemaId, new SinceVersionSchemaTransformer(sinceVersion));
        }
    }
    SchemaTransformer delegate()
    {
        return transformer;
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.xml;
/**
 * An abstraction that allows for general transformations of the IR.
 */
public interface SchemaTransformer
{
    /**
     * Does an identity transform of the incoming schema.
     */
    SchemaTransformer IDENTITY_TRANSFORMER = originalSchema -> originalSchema;
    /**
     * Return a new MessageSchema that has been transformed from the original.
     *
     * @param originalSchema to be transformed
     * @return resulting transformed schema.
     */
    MessageSchema transform(MessageSchema originalSchema);
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.xml;
import org.agrona.Verify;
import org.w3c.dom.Node;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.nio.ByteOrder;
import java.util.ArrayDeque;
import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Map;
import static uk.co.real_logic.sbe.xml.XmlSchemaParser.getAttributeValue;
import static uk.co.real_logic.sbe.xml.XmlSchemaParser.getAttributeValueOrNull;
import static uk.co.real_logic.sbe.xml.XmlSchemaParser.getByteOrder;
/**
 * Message schema aggregate for schema attributes, messageHeader, and reference for multiple {@link Message} objects.
 */
public class MessageSchema
{
    /**
     * Default message header type name for the SBE spec.
     */
    public static final String HEADER_TYPE_DEFAULT = "messageHeader";
    private final String packageName;                 // package (required)
    private final String description;                 // description (optional)
    private final int id;                             // identifier for the schema (required)
    private final int version;                        // version (optional - default is 0)
    private final String semanticVersion;             // semanticVersion (optional)
    private final ByteOrder byteOrder;                // byteOrder (optional - default is littleEndian)
    private final String headerType;                  // headerType (optional - default to messageHeader)
    private final Map<String, Type> typeByNameMap;
    private final Map<Long, Message> messageByIdMap;
    MessageSchema(final Node schemaNode, final Map<String, Type> typeByNameMap, final Map<Long, Message> messageByIdMap)
    {
        this.packageName = getAttributeValue(schemaNode, "package");
        this.description = getAttributeValueOrNull(schemaNode, "description");
        this.id = Integer.parseInt(getAttributeValue(schemaNode, "id"));
        this.version = Integer.parseInt(getAttributeValue(schemaNode, "version", "0"));
        this.semanticVersion = getAttributeValueOrNull(schemaNode, "semanticVersion");
        this.byteOrder = getByteOrder(getAttributeValue(schemaNode, "byteOrder", "littleEndian"));
        this.typeByNameMap = typeByNameMap;
        this.messageByIdMap = messageByIdMap;
        final String configuredHeaderType = getAttributeValueOrNull(schemaNode, "headerType");
        headerType = null == configuredHeaderType ? HEADER_TYPE_DEFAULT : configuredHeaderType;
        Verify.present(typeByNameMap, this.headerType, "Message header");
        final Node messageHeaderNode = findNode(schemaNode, "types/composite[@name='" + this.headerType + "']");
        ((CompositeType)typeByNameMap.get(this.headerType)).checkForWellFormedMessageHeader(messageHeaderNode);
    }
    MessageSchema(
        final String packageName,
        final String description,
        final int id,
        final int version,
        final String semanticVersion,
        final ByteOrder byteOrder,
        final String headerType,
        final Map<String, Type> typeByNameMap,
        final Map<Long, Message> messageByIdMap)
    {
        this.packageName = packageName;
        this.description = description;
        this.id = id;
        this.version = version;
        this.semanticVersion = semanticVersion;
        this.byteOrder = byteOrder;
        this.headerType = headerType;
        this.typeByNameMap = typeByNameMap;
        this.messageByIdMap = messageByIdMap;
    }
    /**
     * The Schema headerType for message headers. This should be a {@link CompositeType}.
     *
     * @return the Schema headerType for message headers.
     */
    public CompositeType messageHeader()
    {
        return (CompositeType)typeByNameMap.get(headerType);
    }
    /**
     * The package name for the schema.
     *
     * @return he package name for the schema.
     */
    public String packageName()
    {
        return packageName;
    }
    /**
     * The description of the schema.
     *
     * @return the description of the schema.
     */
    public String description()
    {
        return description;
    }
    /**
     * The id number of the schema.
     *
     * @return the id number of the schema.
     */
    public int id()
    {
        return id;
    }
    /**
     * The version number of the schema.
     *
     * @return the version number of the schema.
     */
    public int version()
    {
        return version;
    }
    /**
     * The semantic version number of the schema. Typically, used to reference a third party standard such as FIX.
     *
     * @return the semantic version number of the schema.
     */
    public String semanticVersion()
    {
        return semanticVersion;
    }
    /**
     * Return a given {@link Message} object with the given messageId.
     *
     * @param messageId of the message to return.
     * @return a given {@link Message} for the messageId.
     */
    public Message getMessage(final long messageId)
    {
        return messageByIdMap.get(messageId);
    }
    /**
     * Get the {@link Type} for a given name.
     *
     * @param typeName to lookup.
     * @return the type if found otherwise null.
     */
    public Type getType(final String typeName)
    {
        return typeByNameMap.get(typeName);
    }
    /**
     * Get the {@link Collection} of {@link Message}s for this Schema.
     *
     * @return the {@link Collection} of {@link Message}s for this Schema.
     */
    public Collection<Message> messages()
    {
        return messageByIdMap.values();
    }
    /**
     * Get the {@link Collection} of {@link Type}s for this Schema.
     *
     * @return the {@link Collection} of {@link Type}s for this Schema.
     */
    public Collection<Type> types()
    {
        return typeByNameMap.values();
    }
    /**
     * Return the byte order specified by the messageSchema.
     *
     * @return {@link ByteOrder} of the message encoding.
     */
    public ByteOrder byteOrder()
    {
        return byteOrder;
    }
    /**
     * Validate the message schema and delegate warnings and errors to the supplied {@link ErrorHandler}.
     *
     * @param errorHandler for delegating warnings and errors.
     */
    public void validate(final ErrorHandler errorHandler)
    {
        final Deque<String> path = new ArrayDeque<>();
        for (final Type type : typeByNameMap.values())
        {
            validateType(errorHandler, path, type);
        }
        for (final Message message : messageByIdMap.values())
        {
            if (message.sinceVersion() > version)
            {
                errorHandler.error(message.name() + ".sinceVersion=" + message.sinceVersion() +
                    " > messageSchema.version=" + version);
            }
            path.addLast(message.name());
            for (final Field field : message.fields())
            {
                validateField(errorHandler, path, field);
            }
            path.removeLast();
        }
    }
    private void validateType(final ErrorHandler errorHandler, final Deque<String> path, final Type type)
    {
        if (type instanceof EncodedDataType)
        {
            validateEncodedType(errorHandler, path, (EncodedDataType)type);
        }
        else if (type instanceof EnumType)
        {
            validateEnumType(errorHandler, path, (EnumType)type);
        }
        else if (type instanceof SetType)
        {
            validateSetType(errorHandler, path, (SetType)type);
        }
        else if (type instanceof CompositeType)
        {
            validateCompositeType(errorHandler, path, (CompositeType)type);
        }
    }
    private void validateEncodedType(
        final ErrorHandler errorHandler, final Deque<String> path, final EncodedDataType type)
    {
        if (type.sinceVersion() > version)
        {
            reportError(errorHandler, path, type.name(), type.sinceVersion());
        }
    }
    private void validateEnumType(final ErrorHandler errorHandler, final Deque<String> path, final EnumType type)
    {
        if (type.sinceVersion() > version)
        {
            reportError(errorHandler, path, type.name(), type.sinceVersion());
        }
        path.addLast(type.name());
        for (final EnumType.ValidValue validValue : type.validValues())
        {
            if (validValue.sinceVersion() > version)
            {
                reportError(errorHandler, path, validValue.name(), validValue.sinceVersion());
            }
        }
        path.removeLast();
    }
    private void validateSetType(final ErrorHandler errorHandler, final Deque<String> path, final SetType type)
    {
        if (type.sinceVersion() > version)
        {
            reportError(errorHandler, path, type.name(), type.sinceVersion());
        }
        path.addLast(type.name());
        for (final SetType.Choice choice : type.choices())
        {
            if (choice.sinceVersion() > version)
            {
                reportError(errorHandler, path, choice.name(), choice.sinceVersion());
            }
        }
        path.removeLast();
    }
    private void validateCompositeType(
        final ErrorHandler errorHandler, final Deque<String> path, final CompositeType type)
    {
        if (type.sinceVersion() > version)
        {
            reportError(errorHandler, path, type.name(), type.sinceVersion());
        }
        path.addLast(type.name());
        for (final Type subType : type.getTypeList())
        {
            validateType(errorHandler, path, subType);
        }
        path.removeLast();
    }
    private void validateField(final ErrorHandler errorHandler, final Deque<String> path, final Field field)
    {
        if (field.sinceVersion() > version)
        {
            reportError(errorHandler, path, field.name(), field.sinceVersion());
        }
        final List<Field> groupFields = field.groupFields();
        if (null != groupFields)
        {
            path.addLast(field.name());
            for (final Field groupField : groupFields)
            {
                validateField(errorHandler, path, groupField);
            }
            path.removeLast();
        }
    }
    private void reportError(
        final ErrorHandler errorHandler, final Deque<String> path, final String name, final int sinceVersion)
    {
        final StringBuilder sb = new StringBuilder();
        for (final String step : path)
        {
            sb.append(step).append('.');
        }
        sb.append(name)
            .append(".sinceVersion=").append(sinceVersion)
            .append(" > messageSchema.version=").append(version);
        errorHandler.error(sb.toString());
    }
    private static Node findNode(final Node contextNode, final String path)
    {
        try
        {
            return (Node)XPathFactory.newInstance().newXPath()
                .evaluate(path, contextNode, XPathConstants.NODE);
        }
        catch (final XPathExpressionException ex)
        {
            throw new IllegalArgumentException("Unable to locate node with path=" + path, ex);
        }
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe;
import org.agrona.DirectBuffer;
import org.agrona.MutableDirectBuffer;
import org.xml.sax.InputSource;
import uk.co.real_logic.sbe.generation.CodeGenerator;
import uk.co.real_logic.sbe.generation.TargetCodeGenerator;
import uk.co.real_logic.sbe.generation.TargetCodeGeneratorLoader;
import uk.co.real_logic.sbe.ir.Ir;
import uk.co.real_logic.sbe.ir.IrDecoder;
import uk.co.real_logic.sbe.ir.IrEncoder;
import uk.co.real_logic.sbe.xml.*;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
/**
 * A tool for running the SBE parser, validator, and code generator.
 * <p>
 * Usage:
 * <pre>
 *     $ java -jar sbe.jar &lt;filename.xml&gt;
 *     $ java -Doption=value -jar sbe.jar &lt;filename.xml&gt;
 *     $ java -Doption=value -jar sbe.jar &lt;filename.sbeir&gt;
 * </pre>
 * <p>
 * System Properties:
 * <ul>
 * <li><b>sbe.validation.xsd</b>: Use XSD to validate or not.</li>
 * <li><b>sbe.validation.stop.on.error</b>: Should the parser stop on first error encountered? Defaults to false.</li>
 * <li><b>sbe.validation.warnings.fatal</b>: Are warnings in parsing considered fatal? Defaults to false.</li>
 * <li>
 *     <b>sbe.validation.suppress.output</b>: Should the parser suppress output during validation? Defaults to false.
 * </li>
 * <li><b>sbe.generate.stubs</b>: Generate stubs or not. Defaults to true.</li>
 * <li><b>sbe.target.language</b>: Target language for code generation, defaults to Java.</li>
 * <li><b>sbe.generate.ir</b>: Generate IR or not. Defaults to false.</li>
 * <li><b>sbe.output.dir</b>: Target directory for code generation, defaults to current directory.</li>
 * <li><b>sbe.java.generate.interfaces</b>: Generate interface hierarchy or not. Defaults to false.</li>
 * <li><b>sbe.java.encoding.buffer.type</b>: Type of the Java interface for the encoding buffer to wrap.</li>
 * <li><b>sbe.java.decoding.buffer.type</b>: Type of the Java interface for the decoding buffer to wrap.</li>
 * <li><b>sbe.target.namespace</b>: Namespace for the generated code to override schema package.</li>
 * <li><b>sbe.cpp.namespaces.collapse</b>: Namespace for the generated code to override schema package.</li>
 * <li>
 *     <b>sbe.java.generate.group-order.annotation</b>: Should the GroupOrder annotation be added to generated stubs.
 * </li>
 * <li><b>sbe.csharp.generate.namespace.dir</b>: Should a directory be created for the namespace under
 * the output directory? Defaults to true</li>
 * <li><b>sbe.keyword.append.token</b>: Token to be appended to keywords.</li>
 * <li><b>sbe.decode.unknown.enum.values</b>: Support unknown decoded enum values. Defaults to false.</li>
 * <li><b>sbe.xinclude.aware</b>: Is XInclude supported for the schema. Defaults to false.</li>
 * <li><b>sbe.type.package.override</b>: Is package attribute for types element supported (only for JAVA). Defaults to
 * false.</li>
 * </ul>
 */
public class SbeTool
{
    /**
     * Package in which the generated Java interfaces will be placed.
     */
    public static final String JAVA_INTERFACE_PACKAGE = "org.agrona.sbe";
    /**
     * Default class to use as the buffer mutable implementation in generated code.
     */
    public static final String JAVA_DEFAULT_ENCODING_BUFFER_TYPE = MutableDirectBuffer.class.getName();
    /**
     * Default class to use as the buffer read only implementation in generated code.
     */
    public static final String JAVA_DEFAULT_DECODING_BUFFER_TYPE = DirectBuffer.class.getName();
    /**
     * Boolean system property to control throwing exceptions on all errors.
     */
    public static final String VALIDATION_STOP_ON_ERROR = "sbe.validation.stop.on.error";
    /**
     * Boolean system property to control whether to consider warnings fatal and treat them as errors.
     */
    public static final String VALIDATION_WARNINGS_FATAL = "sbe.validation.warnings.fatal";
    /**
     * System property to hold XSD to validate message specification against.
     */
    public static final String VALIDATION_XSD = "sbe.validation.xsd";
    /**
     * Boolean system property to control suppressing output on all errors and warnings.
     */
    public static final String VALIDATION_SUPPRESS_OUTPUT = "sbe.validation.suppress.output";
    /**
     * Boolean system property to turn on or off generation of stubs. Defaults to true.
     */
    public static final String GENERATE_STUBS = "sbe.generate.stubs";
    /**
     * Boolean system property to control is XInclude is supported. Defaults to false.
     */
    public static final String XINCLUDE_AWARE = "sbe.xinclude.aware";
    /**
     * Boolean system property to control the support of package names in {@code <types>} elements.
     * Part of SBE v2-rc3. Defaults to false.
     */
    public static final String TYPES_PACKAGE_OVERRIDE = "sbe.types.package.override";
    /**
     * Target language for generated code.
     */
    public static final String TARGET_LANGUAGE = "sbe.target.language";
    /**
     * Boolean system property to turn on or off generation of IR. Defaults to false.
     */
    public static final String GENERATE_IR = "sbe.generate.ir";
    /**
     * Output directory for generated code.
     */
    public static final String OUTPUT_DIR = "sbe.output.dir";
    /**
     * String system property of the namespace for generated code.
     */
    public static final String TARGET_NAMESPACE = "sbe.target.namespace";
    /**
     * Boolean system property to toggle collapsing of nested namespaces in generated C++ stubs. Defaults to false.
     */
    public static final String CPP_NAMESPACES_COLLAPSE = "sbe.cpp.namespaces.collapse";
    /**
     * Version of the Rust crate to generate.
     */
    public static final String RUST_CRATE_VERSION = "sbe.rust.crate.version";
    /**
     * The default version of the Rust crate to generate, when not specified via the system property.
     */
    public static final String RUST_DEFAULT_CRATE_VERSION = "0.1.0";
    /**
     * Boolean system property to turn on or off generation of the interface hierarchy. Defaults to false.
     */
    public static final String JAVA_GENERATE_INTERFACES = "sbe.java.generate.interfaces";
    /**
     * Specifies the name of the Java mutable buffer to wrap.
     */
    public static final String JAVA_ENCODING_BUFFER_TYPE = "sbe.java.encoding.buffer.type";
    /**
     * Specifies the name of the Java read only buffer to wrap.
     */
    public static final String JAVA_DECODING_BUFFER_TYPE = "sbe.java.decoding.buffer.type";
    /**
     * Should the {@link uk.co.real_logic.sbe.codec.java.GroupOrder} annotation be added to generated stubs.
     */
    public static final String JAVA_GROUP_ORDER_ANNOTATION = "sbe.java.generate.group-order.annotation";
    /**
     * Boolean system property to turn on or off generation of namespace directories during csharp code generation.
     * Defaults to true
     */
    public static final String CSHARP_GENERATE_NAMESPACE_DIR = "sbe.csharp.generate.namespace.dir";
    /**
     * Specifies token that should be appended to keywords to avoid compilation errors.
     * <p>
     * If none is supplied then use of keywords results in an error during schema parsing. The
     * underscore character is a good example of a token to use.
     */
    public static final String KEYWORD_APPEND_TOKEN = "sbe.keyword.append.token";
    /**
     * Should unknown enum values be decoded to support extension. Defaults to false.
     * <p>
     * If an unknown enum value is decoded then a language specific SBE_UNKNOWN enum value will be returned
     * rather than throwing an error.
     */
    public static final String DECODE_UNKNOWN_ENUM_VALUES = "sbe.decode.unknown.enum.values";
    /**
     * Should generate C++ DTOs. Defaults to false.
     */
    public static final String CPP_GENERATE_DTOS = "sbe.cpp.generate.dtos";
    /**
     * Should generate Java DTOs. Defaults to false.
     */
    public static final String JAVA_GENERATE_DTOS = "sbe.java.generate.dtos";
    /**
     * Configuration option used to manage sinceVersion based transformations. When set, parsed schemas will be
     * transformed to discard messages and types higher than the specified version. This can be useful when needing
     * to generate older versions of a schema to do version compatibility testing.
     * <p>
     * This field can contain a list of ordered pairs in the form:
     * <code>((&lt;schema id&gt; | '*') ':' &lt;schema id&gt;)(',' ((&lt;schema id&gt; | '*') ':' &lt;schema id&gt;))*
     * </code>.
     * E.g. <code>123:5,*:6</code> which means transform schema with id = 123 to version 5, all others to version 6.
     */
    public static final String SCHEMA_TRANSFORM_VERSION = "sbe.schema.transform.version";
    /**
     * Whether to generate field precedence checks. For example, whether to check that repeating groups are encoded
     * in schema order.
     */
    public static final String GENERATE_PRECEDENCE_CHECKS = "sbe.generate.precedence.checks";
    /**
     * The name of the symbol or macro that enables access order checks when building
     * generated C# or C++ code.
     */
    public static final String PRECEDENCE_CHECKS_FLAG_NAME = "sbe.precedence.checks.flag.name";
    /**
     * The name of the system property that enables access order checks at runtime
     * in generated Java code.
     */
    public static final String JAVA_PRECEDENCE_CHECKS_PROPERTY_NAME = "sbe.java.precedence.checks.property.name";
    /**
     * Boolean system property to generate flyweights instead of structs in generated Go code.
     * Defaults to false
     */
    public static final String GO_GENERATE_FLYWEIGHTS = "sbe.go.generate.generate.flyweights";
    /**
     * Main entry point for the SBE Tool.
     *
     * @param args command line arguments. A single filename is expected.
     * @throws Exception if an error occurs during process of the message schema.
     */
    public static void main(final String[] args) throws Exception
    {
        if (args.length == 0)
        {
            System.err.format("Usage: %s <filenames>...%n", SbeTool.class.getName());
            System.exit(-1);
        }
        for (final String fileName : args)
        {
            final Ir ir;
            if (fileName.endsWith(".xml"))
            {
                final String xsdFilename = System.getProperty(SbeTool.VALIDATION_XSD);
                if (xsdFilename != null)
                {
                    validateAgainstSchema(fileName, xsdFilename);
                }
                final MessageSchema schema = parseSchema(fileName);
                final SchemaTransformer transformer = new SchemaTransformerFactory(
                    System.getProperty(SCHEMA_TRANSFORM_VERSION));
                ir = new IrGenerator().generate(transformer.transform(schema), System.getProperty(TARGET_NAMESPACE));
            }
            else if (fileName.endsWith(".sbeir"))
            {
                try (IrDecoder irDecoder = new IrDecoder(fileName))
                {
                    ir = irDecoder.decode();
                }
            }
            else
            {
                System.err.println("Input file format not supported: " + fileName);
                System.exit(-1);
                return;
            }
            final String outputDirName = System.getProperty(OUTPUT_DIR, ".");
            if (Boolean.parseBoolean(System.getProperty(GENERATE_STUBS, "true")))
            {
                final String targetLanguage = System.getProperty(TARGET_LANGUAGE, "Java");
                generate(ir, outputDirName, targetLanguage);
            }
            if (Boolean.parseBoolean(System.getProperty(GENERATE_IR, "false")))
            {
                final File inputFile = new File(fileName);
                final String inputFilename = inputFile.getName();
                final int nameEnd = inputFilename.lastIndexOf('.');
                final String namePart = inputFilename.substring(0, nameEnd);
                final File fullPath = new File(outputDirName, namePart + ".sbeir");
                try (IrEncoder irEncoder = new IrEncoder(fullPath.getAbsolutePath(), ir))
                {
                    irEncoder.encode();
                }
            }
        }
    }
    /**
     * Validate the SBE Schema against the XSD.
     *
     * @param sbeSchemaFilename to be validated.
     * @param xsdFilename       XSD against which to validate.
     * @throws Exception if an error occurs while validating.
     */
    public static void validateAgainstSchema(final String sbeSchemaFilename, final String xsdFilename)
        throws Exception
    {
        final ParserOptions.Builder optionsBuilder = ParserOptions.builder()
            .xsdFilename(System.getProperty(VALIDATION_XSD))
            .xIncludeAware(Boolean.parseBoolean(System.getProperty(XINCLUDE_AWARE)))
            .stopOnError(Boolean.parseBoolean(System.getProperty(VALIDATION_STOP_ON_ERROR)))
            .warningsFatal(Boolean.parseBoolean(System.getProperty(VALIDATION_WARNINGS_FATAL)))
            .suppressOutput(Boolean.parseBoolean(System.getProperty(VALIDATION_SUPPRESS_OUTPUT)));
        final Path path = Paths.get(sbeSchemaFilename);
        try (InputStream in = new BufferedInputStream(Files.newInputStream(path)))
        {
            final InputSource inputSource = new InputSource(in);
            if (path.toAbsolutePath().getParent() != null)
            {
                inputSource.setSystemId(path.toUri().toString());
            }
            XmlSchemaParser.validate(xsdFilename, inputSource, optionsBuilder.build());
        }
    }
    /**
     * Parse the message schema specification.
     *
     * @param sbeSchemaFilename file containing the SBE specification to be parsed.
     * @return the parsed {@link MessageSchema} for the specification found in the file.
     * @throws Exception if an error occurs when parsing the specification.
     */
    public static MessageSchema parseSchema(final String sbeSchemaFilename)
        throws Exception
    {
        final ParserOptions.Builder optionsBuilder = ParserOptions.builder()
            .xsdFilename(System.getProperty(VALIDATION_XSD))
            .xIncludeAware(Boolean.parseBoolean(System.getProperty(XINCLUDE_AWARE)))
            .stopOnError(Boolean.parseBoolean(System.getProperty(VALIDATION_STOP_ON_ERROR)))
            .warningsFatal(Boolean.parseBoolean(System.getProperty(VALIDATION_WARNINGS_FATAL)))
            .suppressOutput(Boolean.parseBoolean(System.getProperty(VALIDATION_SUPPRESS_OUTPUT)));
        final Path path = Paths.get(sbeSchemaFilename);
        try (InputStream in = new BufferedInputStream(Files.newInputStream(path)))
        {
            final InputSource inputSource = new InputSource(in);
            if (path.toAbsolutePath().getParent() != null)
            {
                inputSource.setSystemId(path.toUri().toString());
            }
            return XmlSchemaParser.parse(inputSource, optionsBuilder.build());
        }
    }
    /**
     * Generate SBE encoding and decoding stubs for a target language.
     *
     * @param ir             for the parsed specification.
     * @param outputDirName  directory into which code will be generated.
     * @param targetLanguage for the generated code.
     * @throws Exception if an error occurs while generating the code.
     */
    public static void generate(final Ir ir, final String outputDirName, final String targetLanguage)
        throws Exception
    {
        final TargetCodeGenerator targetCodeGenerator = TargetCodeGeneratorLoader.get(targetLanguage);
        final CodeGenerator codeGenerator = targetCodeGenerator.newInstance(ir, outputDirName);
        codeGenerator.generate();
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation;
import uk.co.real_logic.sbe.generation.c.CGenerator;
import uk.co.real_logic.sbe.generation.c.COutputManager;
import uk.co.real_logic.sbe.generation.common.PrecedenceChecks;
import uk.co.real_logic.sbe.generation.cpp.CppDtoGenerator;
import uk.co.real_logic.sbe.generation.cpp.CppGenerator;
import uk.co.real_logic.sbe.generation.cpp.NamespaceOutputManager;
import uk.co.real_logic.sbe.generation.golang.struct.GolangGenerator;
import uk.co.real_logic.sbe.generation.golang.struct.GolangOutputManager;
import uk.co.real_logic.sbe.generation.golang.flyweight.GolangFlyweightGenerator;
import uk.co.real_logic.sbe.generation.golang.flyweight.GolangFlyweightOutputManager;
import uk.co.real_logic.sbe.generation.java.JavaDtoGenerator;
import uk.co.real_logic.sbe.generation.java.JavaGenerator;
import uk.co.real_logic.sbe.generation.java.JavaOutputManager;
import uk.co.real_logic.sbe.generation.rust.RustGenerator;
import uk.co.real_logic.sbe.generation.rust.RustOutputManager;
import uk.co.real_logic.sbe.ir.Ir;
import static uk.co.real_logic.sbe.SbeTool.*;
/**
 * Loader for {@link CodeGenerator}s which target a language. This provides convenient short names rather than the
 * fully qualified class name of the generator.
 */
public enum TargetCodeGeneratorLoader implements TargetCodeGenerator
{
    /**
     * Generates codecs for the Java 8 programming language.
     */
    JAVA()
    {
        /**
         * {@inheritDoc}
         */
        public CodeGenerator newInstance(final Ir ir, final String outputDir)
        {
            final JavaOutputManager outputManager = new JavaOutputManager(outputDir, ir.applicableNamespace());
            final boolean shouldSupportTypesPackageNames = Boolean.getBoolean(TYPES_PACKAGE_OVERRIDE);
            final JavaGenerator codecGenerator = new JavaGenerator(
                ir,
                System.getProperty(JAVA_ENCODING_BUFFER_TYPE, JAVA_DEFAULT_ENCODING_BUFFER_TYPE),
                System.getProperty(JAVA_DECODING_BUFFER_TYPE, JAVA_DEFAULT_DECODING_BUFFER_TYPE),
                Boolean.getBoolean(JAVA_GROUP_ORDER_ANNOTATION),
                Boolean.getBoolean(JAVA_GENERATE_INTERFACES),
                Boolean.getBoolean(DECODE_UNKNOWN_ENUM_VALUES),
                shouldSupportTypesPackageNames,
                precedenceChecks(),
                outputManager);
            if (Boolean.getBoolean(JAVA_GENERATE_DTOS))
            {
                final JavaDtoGenerator dtoGenerator = new JavaDtoGenerator(
                    ir,
                    shouldSupportTypesPackageNames,
                    outputManager);
                return () ->
                {
                    codecGenerator.generate();
                    dtoGenerator.generate();
                };
            }
            return codecGenerator;
        }
    },
    /**
     * Generates codecs for the C11 programming language.
     */
    C()
    {
        /**
         * {@inheritDoc}
         */
        public CodeGenerator newInstance(final Ir ir, final String outputDir)
        {
            return new CGenerator(ir, new COutputManager(outputDir, ir.applicableNamespace()));
        }
    },
    /**
     * Generates codecs for the C++11 programming language with some conditional includes for C++14 and C++17.
     */
    CPP()
    {
        /**
         * {@inheritDoc}
         */
        public CodeGenerator newInstance(final Ir ir, final String outputDir)
        {
            final NamespaceOutputManager outputManager = new NamespaceOutputManager(
                outputDir, ir.applicableNamespace());
            final boolean decodeUnknownEnumValues = Boolean.getBoolean(DECODE_UNKNOWN_ENUM_VALUES);
            final boolean shouldSupportTypesPackageNames = Boolean.getBoolean(TYPES_PACKAGE_OVERRIDE);
            final CodeGenerator codecGenerator = new CppGenerator(
                ir,
                decodeUnknownEnumValues,
                precedenceChecks(),
                shouldSupportTypesPackageNames,
                outputManager);
            if (Boolean.getBoolean(CPP_GENERATE_DTOS))
            {
                final CodeGenerator dtoGenerator = new CppDtoGenerator(
                    ir,
                    shouldSupportTypesPackageNames,
                    outputManager);
                return () ->
                {
                    codecGenerator.generate();
                    dtoGenerator.generate();
                };
            }
            return codecGenerator;
        }
    },
    /**
     * Generates codecs for the Go programming language.
     */
    GOLANG()
    {
        /**
         * {@inheritDoc}
         */
        public CodeGenerator newInstance(final Ir ir, final String outputDir)
        {
            if ("true".equals(System.getProperty(GO_GENERATE_FLYWEIGHTS)))
            {
                return new GolangFlyweightGenerator(
                    ir,
                    "true".equals(System.getProperty(DECODE_UNKNOWN_ENUM_VALUES)),
                    new GolangFlyweightOutputManager(outputDir, ir.applicableNamespace()));
            }
            else
            {
                return new GolangGenerator(
                    ir,
                    new GolangOutputManager(outputDir, ir.applicableNamespace()));
            }
        }
    },
    /**
     * Generates codecs for the Rust programming language.
     */
    RUST()
    {
        /**
         * {@inheritDoc}
         */
        public CodeGenerator newInstance(final Ir ir, final String outputDir)
        {
            return new RustGenerator(
                ir,
                System.getProperty(RUST_CRATE_VERSION, RUST_DEFAULT_CRATE_VERSION),
                new RustOutputManager(outputDir, ir.packageName()));
        }
    };
    /**
     * Returns the precedence checks to run, configured from system properties.
     *
     * @return the precedence checks to run, configured from system properties.
     */
    public static PrecedenceChecks precedenceChecks()
    {
        final PrecedenceChecks.Context context = new PrecedenceChecks.Context();
        final String shouldGeneratePrecedenceChecks = System.getProperty(GENERATE_PRECEDENCE_CHECKS);
        if (shouldGeneratePrecedenceChecks != null)
        {
            context.shouldGeneratePrecedenceChecks(Boolean.parseBoolean(shouldGeneratePrecedenceChecks));
        }
        final String precedenceChecksFlagName = System.getProperty(PRECEDENCE_CHECKS_FLAG_NAME);
        if (precedenceChecksFlagName != null)
        {
            context.precedenceChecksFlagName(precedenceChecksFlagName);
        }
        final String precedenceChecksPropName = System.getProperty(JAVA_PRECEDENCE_CHECKS_PROPERTY_NAME);
        if (precedenceChecksPropName != null)
        {
            context.precedenceChecksPropName(precedenceChecksPropName);
        }
        return PrecedenceChecks.newInstance(context);
    }
    /**
     * Do a case-insensitive lookup of a target language for code generation.
     *
     * @param name of the target language to lookup.
     * @return the {@link TargetCodeGenerator} for the given language name.
     */
    public static TargetCodeGenerator get(final String name)
    {
        for (final TargetCodeGeneratorLoader target : values())
        {
            if (target.name().equalsIgnoreCase(name))
            {
                return target;
            }
        }
        try
        {
            return (TargetCodeGenerator)Class.forName(name).getConstructor().newInstance();
        }
        catch (final Exception ex)
        {
            throw new IllegalArgumentException("No code generator for name: " + name, ex);
        }
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 * Copyright (C) 2016 MarketFactory, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.golang.struct;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.SbeTool;
import uk.co.real_logic.sbe.ValidationUtil;
import java.util.EnumMap;
import java.util.Map;
import static uk.co.real_logic.sbe.generation.Generators.toUpperFirstChar;
/**
 * Utilities for mapping between IR and the Golang language.
 */
public class GolangUtil
{
    private static final Map<PrimitiveType, String> PRIMITIVE_TYPE_STRING_ENUM_MAP = new EnumMap<>(PrimitiveType.class);
    static
    {
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.CHAR, "byte");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT8, "int8");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT16, "int16");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT32, "int32");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT64, "int64");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT8, "uint8");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT16, "uint16");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT32, "uint32");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT64, "uint64");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.FLOAT, "float32");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.DOUBLE, "float64");
    }
    /**
     * Map the name of a {@link uk.co.real_logic.sbe.PrimitiveType} to a Golang primitive type name.
     *
     * @param primitiveType to map.
     * @return the name of the Java primitive that most closely maps.
     */
    public static String golangTypeName(final PrimitiveType primitiveType)
    {
        return PRIMITIVE_TYPE_STRING_ENUM_MAP.get(primitiveType);
    }
    private static final Map<PrimitiveType, String> MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP =
        new EnumMap<>(PrimitiveType.class);
    static
    {
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.CHAR, "Bytes");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT8, "Int8");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT16, "Int16");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT32, "Int32");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT64, "Int64");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT8, "Uint8");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT16, "Uint16");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT32, "Uint32");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT64, "Uint64");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.FLOAT, "Float32");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.DOUBLE, "Float64");
    }
    /**
     * Map the name of a {@link uk.co.real_logic.sbe.PrimitiveType} to a Golang marhsalling function name.
     *
     * @param primitiveType to map.
     * @return the name of the Java primitive that most closely maps.
     */
    public static String golangMarshalType(final PrimitiveType primitiveType)
    {
        return MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.get(primitiveType);
    }
    /**
     * Format a String as a property name.
     *
     * @param value to be formatted.
     * @return the string formatted as a property name.
     */
    public static String formatPropertyName(final String value)
    {
        String formattedValue = toUpperFirstChar(value);
        if (ValidationUtil.isGolangKeyword(formattedValue))
        {
            final String keywordAppendToken = System.getProperty(SbeTool.KEYWORD_APPEND_TOKEN);
            if (null == keywordAppendToken)
            {
                throw new IllegalStateException(
                    "Invalid property name='" + formattedValue +
                    "' please correct the schema or consider setting system property: " + SbeTool.KEYWORD_APPEND_TOKEN);
            }
            formattedValue += keywordAppendToken;
        }
        return formattedValue;
    }
    /**
     * Format a String as a type name.
     *
     * @param value to be formatted.
     * @return the string formatted as an exported type name.
     */
    public static String formatTypeName(final String value)
    {
        return toUpperFirstChar(value);
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.c;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.SbeTool;
import uk.co.real_logic.sbe.ValidationUtil;
import java.nio.ByteOrder;
import java.util.EnumMap;
import java.util.Map;
import static uk.co.real_logic.sbe.generation.Generators.toLowerFirstChar;
/**
 * Utilities for mapping between IR and the C language.
 */
public class CUtil
{
    private static final Map<PrimitiveType, String> PRIMITIVE_TYPE_STRING_ENUM_MAP = new EnumMap<>(PrimitiveType.class);
    static
    {
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.CHAR, "char");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT8, "int8_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT16, "int16_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT32, "int32_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT64, "int64_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT8, "uint8_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT16, "uint16_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT32, "uint32_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT64, "uint64_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.FLOAT, "float");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.DOUBLE, "double");
    }
    /**
     * Map the name of a {@link uk.co.real_logic.sbe.PrimitiveType} to a C11 primitive type name.
     *
     * @param primitiveType to map.
     * @return the name of the Java primitive that most closely maps.
     */
    public static String cTypeName(final PrimitiveType primitiveType)
    {
        return PRIMITIVE_TYPE_STRING_ENUM_MAP.get(primitiveType);
    }
    /**
     * Format a String as a property name.
     *
     * @param value to be formatted.
     * @return the string formatted as a property name.
     */
    public static String formatPropertyName(final String value)
    {
        String formattedValue = toLowerFirstChar(value);
        if (ValidationUtil.isCKeyword(formattedValue))
        {
            final String keywordAppendToken = System.getProperty(SbeTool.KEYWORD_APPEND_TOKEN);
            if (null == keywordAppendToken)
            {
                throw new IllegalStateException(
                    "Invalid property name='" + formattedValue +
                    "' please correct the schema or consider setting system property: " + SbeTool.KEYWORD_APPEND_TOKEN);
            }
            formattedValue += keywordAppendToken;
        }
        return formattedValue;
    }
    /**
     * Format a String as a struct name.
     *
     * @param value to be formatted.
     * @return the string formatted as a struct name.
     */
    public static String formatName(final String value)
    {
        return toLowerFirstChar(value);
    }
    /**
     * Format a String as a struct name prepended with a scope.
     *
     * @param scope to be prepended.
     * @param value to be formatted.
     * @return the string formatted as a struct name.
     */
    public static String formatScopedName(final CharSequence[] scope, final String value)
    {
        return String.join("_", scope).toLowerCase() + "_" + formatName(value);
    }
    /**
     * Return the C99 formatted byte order encoding string to use for a given byte order and primitiveType.
     *
     * @param byteOrder     of the {@link uk.co.real_logic.sbe.ir.Token}.
     * @param primitiveType of the {@link uk.co.real_logic.sbe.ir.Token}.
     * @return the string formatted as the byte ordering encoding.
     */
    public static String formatByteOrderEncoding(final ByteOrder byteOrder, final PrimitiveType primitiveType)
    {
        switch (primitiveType.size())
        {
            case 2:
                return "SBE_" + byteOrder + "_ENCODE_16";
            case 4:
                return "SBE_" + byteOrder + "_ENCODE_32";
            case 8:
                return "SBE_" + byteOrder + "_ENCODE_64";
            default:
                return "";
        }
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 * Copyright 2017 MarketFactory Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.csharp;
import uk.co.real_logic.sbe.generation.CodeGenerator;
import uk.co.real_logic.sbe.generation.TargetCodeGenerator;
import uk.co.real_logic.sbe.ir.Ir;
import static uk.co.real_logic.sbe.SbeTool.TYPES_PACKAGE_OVERRIDE;
/**
 * {@link CodeGenerator} factory for CSharp DTOs.
 */
public class CSharpDtos implements TargetCodeGenerator
{
    /**
     * {@inheritDoc}
     */
    public CodeGenerator newInstance(final Ir ir, final String outputDir)
    {
        final boolean shouldSupportTypesPackageNames = Boolean.getBoolean(TYPES_PACKAGE_OVERRIDE);
        return new CSharpDtoGenerator(
            ir,
            shouldSupportTypesPackageNames,
            new CSharpNamespaceOutputManager(outputDir, ir.applicableNamespace())
        );
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.ir;
import org.agrona.CloseHelper;
import org.agrona.MutableDirectBuffer;
import org.agrona.concurrent.UnsafeBuffer;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.ir.generated.FrameCodecDecoder;
import uk.co.real_logic.sbe.ir.generated.TokenCodecDecoder;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import static java.nio.file.StandardOpenOption.READ;
import static uk.co.real_logic.sbe.ir.IrUtil.*;
/**
 * Decoder for encoded {@link Ir} representing an SBE schema which can be read from a buffer or file.
 */
public class IrDecoder implements AutoCloseable
{
    private static final int CAPACITY = 4096;
    private final FileChannel channel;
    private final MutableDirectBuffer directBuffer;
    private final FrameCodecDecoder frameDecoder = new FrameCodecDecoder();
    private final TokenCodecDecoder tokenDecoder = new TokenCodecDecoder();
    private int offset;
    private final int length;
    private String irPackageName = null;
    private String irNamespaceName = null;
    private String semanticVersion = null;
    private List<Token> irHeader = null;
    private int irId;
    private int irVersion = 0;
    private final byte[] valArray = new byte[CAPACITY];
    private final MutableDirectBuffer valBuffer = new UnsafeBuffer(valArray);
    /**
     * Construct a {@link Ir} decoder by opening a file for a given name.
     *
     * @param fileName containing the encoded {@link Ir}.
     */
    public IrDecoder(final String fileName)
    {
        try
        {
            channel = FileChannel.open(Paths.get(fileName), READ);
            final long fileLength = channel.size();
            if (fileLength > Integer.MAX_VALUE)
            {
                throw new IllegalStateException("Invalid IR file: length=" + fileLength + " > Integer.MAX_VALUE");
            }
            final MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, fileLength);
            directBuffer = new UnsafeBuffer(buffer);
            length = (int)fileLength;
            offset = 0;
        }
        catch (final IOException ex)
        {
            throw new RuntimeException(ex);
        }
    }
    /**
     * Construct a {@link Ir} decoder for data encoded in a {@link ByteBuffer}.
     *
     * @param buffer containing the serialised {@link Ir}.
     */
    public IrDecoder(final ByteBuffer buffer)
    {
        channel = null;
        length = buffer.limit();
        directBuffer = new UnsafeBuffer(buffer);
        offset = 0;
    }
    /**
     * {@inheritDoc}
     */
    public void close()
    {
        CloseHelper.quietClose(channel);
    }
    /**
     * Decode the serialised {@link Ir} and return the decoded instance.
     *
     * @return the decoded serialised {@link Ir} instance.
     */
    public Ir decode()
    {
        decodeFrame();
        final List<Token> tokens = new ArrayList<>();
        while (offset < length)
        {
            tokens.add(decodeToken());
        }
        int i = 0;
        if (tokens.get(0).signal() == Signal.BEGIN_COMPOSITE)
        {
            i = captureHeader(tokens);
        }
        ByteOrder byteOrder = null;
        for (int j = 0; j < tokens.size(); j++)
        {
            if (tokens.get(j).signal() == Signal.ENCODING)
            {
                byteOrder = tokens.get(j).encoding().byteOrder();
                break;
            }
        }
        final Ir ir = new Ir(
            irPackageName, irNamespaceName, irId, irVersion, null, semanticVersion, byteOrder, irHeader);
        for (int size = tokens.size(); i < size; i++)
        {
            if (tokens.get(i).signal() == Signal.BEGIN_MESSAGE)
            {
                i = captureMessage(tokens, i, ir);
            }
        }
        return ir;
    }
    private int captureHeader(final List<Token> tokens)
    {
        final List<Token> headerTokens = new ArrayList<>();
        int index = 0;
        Token token = tokens.get(index);
        final String headerName = token.name();
        headerTokens.add(token);
        do
        {
            token = tokens.get(++index);
            headerTokens.add(token);
        }
        while (Signal.END_COMPOSITE != token.signal() || !headerName.equals(token.name()));
        irHeader = headerTokens;
        return index;
    }
    private static int captureMessage(final List<Token> tokens, final int index, final Ir ir)
    {
        final List<Token> messageTokens = new ArrayList<>();
        int i = index;
        Token token = tokens.get(i);
        messageTokens.add(token);
        do
        {
            token = tokens.get(++i);
            messageTokens.add(token);
        }
        while (Signal.END_MESSAGE != token.signal());
        ir.addMessage(tokens.get(i).id(), messageTokens);
        return i;
    }
    private void decodeFrame()
    {
        frameDecoder.wrap(directBuffer, offset, frameDecoder.sbeBlockLength(), FrameCodecDecoder.SCHEMA_VERSION);
        irId = frameDecoder.irId();
        if (frameDecoder.irVersion() != 0)
        {
            throw new IllegalStateException("Unknown SBE version: " + frameDecoder.irVersion());
        }
        irVersion = frameDecoder.schemaVersion();
        irPackageName = frameDecoder.packageName();
        irNamespaceName = frameDecoder.namespaceName();
        if (irNamespaceName.isEmpty())
        {
            irNamespaceName = null;
        }
        semanticVersion = frameDecoder.semanticVersion();
        if (semanticVersion.isEmpty())
        {
            semanticVersion = null;
        }
        offset += frameDecoder.encodedLength();
    }
    private Token decodeToken()
    {
        final Token.Builder tokenBuilder = new Token.Builder();
        final Encoding.Builder encBuilder = new Encoding.Builder();
        tokenDecoder.wrap(directBuffer, offset, tokenDecoder.sbeBlockLength(), TokenCodecDecoder.SCHEMA_VERSION);
        tokenBuilder
            .offset(tokenDecoder.tokenOffset())
            .size(tokenDecoder.tokenSize())
            .id(tokenDecoder.fieldId())
            .version(tokenDecoder.tokenVersion())
            .componentTokenCount(tokenDecoder.componentTokenCount())
            .signal(mapSignal(tokenDecoder.signal()));
        final PrimitiveType type = mapPrimitiveType(tokenDecoder.primitiveType());
        encBuilder
            .primitiveType(mapPrimitiveType(tokenDecoder.primitiveType()))
            .byteOrder(mapByteOrder(tokenDecoder.byteOrder()))
            .presence(mapPresence(tokenDecoder.presence()));
        tokenBuilder.name(tokenDecoder.name());
        encBuilder.constValue(get(valBuffer, type, tokenDecoder.getConstValue(valArray, 0, valArray.length)));
        encBuilder.minValue(get(valBuffer, type, tokenDecoder.getMinValue(valArray, 0, valArray.length)));
        encBuilder.maxValue(get(valBuffer, type, tokenDecoder.getMaxValue(valArray, 0, valArray.length)));
        encBuilder.nullValue(get(valBuffer, type, tokenDecoder.getNullValue(valArray, 0, valArray.length)));
        final String characterEncoding = tokenDecoder.characterEncoding();
        encBuilder.characterEncoding(characterEncoding.isEmpty() ? null : characterEncoding);
        final String epoch = tokenDecoder.epoch();
        encBuilder.epoch(epoch.isEmpty() ? null : epoch);
        final String timeUnit = tokenDecoder.timeUnit();
        encBuilder.timeUnit(timeUnit.isEmpty() ? null : timeUnit);
        final String semanticType = tokenDecoder.semanticType();
        encBuilder.semanticType(semanticType.isEmpty() ? null : semanticType);
        final String description = tokenDecoder.description();
        tokenBuilder.description(description.isEmpty() ? null : description);
        final String referencedName = tokenDecoder.referencedName();
        tokenBuilder.referencedName(referencedName.isEmpty() ? null : referencedName);
        offset += tokenDecoder.encodedLength();
        return tokenBuilder.encoding(encBuilder.build()).build();
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 * Copyright (C) 2017 MarketFactory, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.csharp;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.SbeTool;
import uk.co.real_logic.sbe.ValidationUtil;
import uk.co.real_logic.sbe.generation.Generators;
import uk.co.real_logic.sbe.ir.Token;
import java.util.EnumMap;
import java.util.Map;
import java.util.Set;
/**
 * Utilities for mapping between IR and the C# language.
 */
public class CSharpUtil
{
    static String generateLiteral(final PrimitiveType type, final String value)
    {
        String literal = "";
        final String castType = cSharpTypeName(type);
        switch (type)
        {
            case CHAR:
            case UINT8:
            case INT8:
            case INT16:
            case UINT16:
                literal = "(" + castType + ")" + value;
                break;
            case INT32:
                literal = value;
                break;
            case UINT32:
                literal = value + "U";
                break;
            case FLOAT:
                if (value.endsWith("NaN"))
                {
                    literal = "float.NaN";
                }
                else
                {
                    literal = value + "f";
                }
                break;
            case UINT64:
                literal = "0x" + Long.toHexString(Long.parseLong(value)) + "UL";
                break;
            case INT64:
                literal = value + "L";
                break;
            case DOUBLE:
                if (value.endsWith("NaN"))
                {
                    literal = "double.NaN";
                }
                else
                {
                    literal = value + "d";
                }
                break;
        }
        return literal;
    }
    static CharSequence generateFileHeader(
        final String packageName,
        final Set<String> packageNamesByTypes,
        final String... topLevelStatements)
    {
        final StringBuilder additionalUsingBuilder = new StringBuilder();
        if (packageNamesByTypes != null && !packageNamesByTypes.isEmpty())
        {
            packageNamesByTypes
                .stream()
                .filter(p -> !packageName.equals(p))
                .forEach(p ->
                additionalUsingBuilder
                .append("using ")
                .append(formatNamespace(p))
                .append(";\n"));
            additionalUsingBuilder.append("\n");
        }
        return String.format(
            "// <auto-generated>\n" +
            "//     Generated SBE (Simple Binary Encoding) message codec\n" +
            "// </auto-generated>\n\n" +
            "#pragma warning disable 1591 // disable warning on missing comments\n" +
            "%1$s" +
            "using System;\n" +
            "using System.Text;\n" +
            "using Org.SbeTool.Sbe.Dll;\n\n" +
            "%2$s" +
            "namespace %3$s\n" +
            "{\n",
            String.join("", topLevelStatements),
            additionalUsingBuilder,
            formatNamespace(packageName));
    }
    static String formatNamespace(final String packageName)
    {
        String[] tokens = packageName.split("\\.");
        final StringBuilder sb = new StringBuilder();
        for (final String t : tokens)
        {
            sb.append(Generators.toUpperFirstChar(t)).append(".");
        }
        if (sb.length() > 0)
        {
            sb.setLength(sb.length() - 1);
        }
        tokens = sb.toString().split("-");
        sb.setLength(0);
        for (final String t : tokens)
        {
            sb.append(Generators.toUpperFirstChar(t));
        }
        return sb.toString();
    }
    static String generateDocumentation(final String indent, final Token token)
    {
        final String description = token.description();
        if (null == description || description.isEmpty())
        {
            return "";
        }
        return
            indent + "/// <summary>\n" +
            indent + "/// " + description + "\n" +
            indent + "/// </summary>\n";
    }
    enum Separators
    {
        BEGIN_GROUP('['),
        END_GROUP(']'),
        BEGIN_COMPOSITE('('),
        END_COMPOSITE(')'),
        BEGIN_SET('{'),
        END_SET('}'),
        BEGIN_ARRAY('['),
        END_ARRAY(']'),
        FIELD('|'),
        KEY_VALUE('='),
        ENTRY(',');
        private final char symbol;
        Separators(final char symbol)
        {
            this.symbol = symbol;
        }
        void appendToGeneratedBuilder(final StringBuilder builder, final String indent)
        {
            builder.append(indent).append("builder.Append('").append(symbol).append("');").append('\n');
        }
        /**
         * Returns the string value of this separator.
         *
         * @return  the string value of this separator
         */
        public String toString()
        {
            return String.valueOf(symbol);
        }
    }
    private static final Map<PrimitiveType, String> PRIMITIVE_TYPE_STRING_ENUM_MAP = new EnumMap<>(PrimitiveType.class);
    /*
     * http://msdn.microsoft.com/en-us/library/ms228360(v=vs.90).aspx
     */
    static
    {
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.CHAR, "byte");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT8, "sbyte");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT16, "short");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT32, "int");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT64, "long");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT8, "byte");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT16, "ushort");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT32, "uint");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT64, "ulong");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.FLOAT, "float");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.DOUBLE, "double");
    }
    /**
     * Map the name of a {@link uk.co.real_logic.sbe.PrimitiveType} to a C# primitive type name.
     *
     * @param primitiveType to map.
     * @return the name of the Java primitive that most closely maps.
     */
    static String cSharpTypeName(final PrimitiveType primitiveType)
    {
        return PRIMITIVE_TYPE_STRING_ENUM_MAP.get(primitiveType);
    }
    /**
     * Uppercase the first character of a given String.
     *
     * @param str to have the first character upper-cased.
     * @return a new String with the first character in uppercase.
     */
    public static String toUpperFirstChar(final String str)
    {
        return Character.toUpperCase(str.charAt(0)) + str.substring(1);
    }
    /**
     * Lowercase the first character of a given String.
     *
     * @param str to have the first character upper-cased.
     * @return a new String with the first character in uppercase.
     */
    public static String toLowerFirstChar(final String str)
    {
        return Character.toLowerCase(str.charAt(0)) + str.substring(1);
    }
    /**
     * Format a String as a property name.
     *
     * @param str to be formatted.
     * @return the string formatted as a property name.
     */
    public static String formatPropertyName(final String str)
    {
        return toUpperFirstChar(str);
    }
    /**
     * Format a String with a suffix in case it's a keyword.
     *
     * @param value to be formatted.
     * @return the formatted string.
     */
    public static String formatForCSharpKeyword(final String value)
    {
        if (ValidationUtil.isCSharpKeyword(value))
        {
            final String keywordAppendToken = System.getProperty(SbeTool.KEYWORD_APPEND_TOKEN);
            if (null == keywordAppendToken)
            {
                throw new IllegalStateException(
                    "Invalid property name='" + value +
                    "' please correct the schema or consider setting system property: " + SbeTool.KEYWORD_APPEND_TOKEN);
            }
            return value + keywordAppendToken;
        }
        return value;
    }
    /**
     * Format a String as a variable name.
     *
     * @param str to be formatted.
     * @return the string formatted as a property name.
     */
    public static String formatVariableName(final String str)
    {
        return toLowerFirstChar(str);
    }
    /**
     * Format a String as a class name.
     *
     * @param str to be formatted.
     * @return the string formatted as a class name.
     */
    public static String formatClassName(final String str)
    {
        return toUpperFirstChar(str);
    }
    /**
     * Format a Getter name for generated code.
     *
     * @param propertyName to be formatted.
     * @return the property name formatted as a getter name.
     */
    public static String formatGetterName(final String propertyName)
    {
        return "Get" + toUpperFirstChar(propertyName);
    }
    /**
     * Shortcut to append a line of generated code.
     *
     * @param builder string builder to which to append the line.
     * @param indent  current text indentation.
     * @param line    line to be appended.
     */
    public static void append(final StringBuilder builder, final String indent, final String line)
    {
        builder.append(indent).append(line).append('\n');
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.golang.flyweight;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.SbeTool;
import uk.co.real_logic.sbe.ValidationUtil;
import java.nio.ByteOrder;
import java.util.EnumMap;
import java.util.Map;
import static uk.co.real_logic.sbe.generation.Generators.toUpperFirstChar;
/**
 * Utilities for mapping between IR and the Golang language.
 */
public class GolangFlyweightUtil
{
    private static final Map<PrimitiveType, String> PRIMITIVE_TYPE_STRING_ENUM_MAP = new EnumMap<>(PrimitiveType.class);
    private static final Map<PrimitiveType, String> MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP =
        new EnumMap<>(PrimitiveType.class);
    static
    {
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.CHAR, "byte");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT8, "int8");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT16, "int16");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT32, "int32");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT64, "int64");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT8, "uint8");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT16, "uint16");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT32, "uint32");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT64, "uint64");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.FLOAT, "float32");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.DOUBLE, "float64");
    }
    static
    {
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.CHAR, "Bytes");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT8, "Int8");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT16, "Int16");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT32, "Int32");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT64, "Int64");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT8, "Uint8");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT16, "Uint16");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT32, "Uint32");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT64, "Uint64");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.FLOAT, "Float32");
        MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.DOUBLE, "Float64");
    }
    /**
     * Map the name of a {@link uk.co.real_logic.sbe.PrimitiveType} to a Golang primitive type name.
     *
     * @param primitiveType to map.
     * @return the name of the Java primitive that most closely maps.
     */
    public static String goTypeName(final PrimitiveType primitiveType)
    {
        return PRIMITIVE_TYPE_STRING_ENUM_MAP.get(primitiveType);
    }
    /**
     * Format a String as a class name.
     *
     * @param value to be formatted.
     * @return the string formatted as a class name.
     */
    public static String formatClassName(final String value)
    {
        return toUpperFirstChar(value);
    }
    /**
     * Map the name of a {@link uk.co.real_logic.sbe.PrimitiveType} to a Golang marshalling function name.
     *
     * @param primitiveType to map.
     * @return the name of the Java primitive that most closely maps.
     */
    public static String golangMarshalType(final PrimitiveType primitiveType)
    {
        return MARSHAL_TYPE_BY_PRIMITIVE_TYPE_MAP.get(primitiveType);
    }
    /**
     * Format a String as a property name.
     *
     * @param value to be formatted.
     * @return the string formatted as a property name.
     */
    public static String formatPropertyName(final String value)
    {
        String formattedValue = toUpperFirstChar(value);
        if (ValidationUtil.isGolangKeyword(formattedValue))
        {
            final String keywordAppendToken = System.getProperty(SbeTool.KEYWORD_APPEND_TOKEN);
            if (null == keywordAppendToken)
            {
                throw new IllegalStateException(
                    "Invalid property name='" + formattedValue +
                    "' please correct the schema or consider setting system property: " +
                    SbeTool.KEYWORD_APPEND_TOKEN);
            }
            formattedValue += keywordAppendToken;
        }
        return formattedValue;
    }
    /**
     * Generate a count of closing braces, one on each line.
     *
     * @param count of closing braces.
     * @return A string with count of closing braces.
     */
    public static String closingBraces(final int count)
    {
        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++)
        {
            sb.append("}\n");
        }
        return sb.toString();
    }
    /**
     * Return the Golang formatted byte order encoding string to use to read for a given byte order and primitiveType.
     *
     * @param byteOrder     of the {@link uk.co.real_logic.sbe.ir.Token}.
     * @param primitiveType of the {@link uk.co.real_logic.sbe.ir.Token}.
     * @return the string formatted as the byte ordering encoding.
     */
    public static String formatReadBytes(final ByteOrder byteOrder, final PrimitiveType primitiveType)
    {
        final String suffix = byteOrder == ByteOrder.BIG_ENDIAN ? "BigEndian" : "LittleEndian";
        switch (primitiveType)
        {
            case CHAR:
                return "Byte" + suffix;
            case FLOAT:
                return "Float" + suffix;
            case DOUBLE:
                return "Double" + suffix;
            case INT8:
                return "Int8" + suffix;
            case INT16:
                return "Int16" + suffix;
            case INT32:
                return "Int32" + suffix;
            case INT64:
                return "Int64" + suffix;
            case UINT8:
                return "Uint8" + suffix;
            case UINT16:
                return "Uint16" + suffix;
            case UINT32:
                return "Uint32" + suffix;
            case UINT64:
                return "Uint64" + suffix;
        }
        return "";
    }
    /**
     * Return the Golang formatted byte order encoding string to use to write for a given byte order and primitiveType.
     *
     * @param byteOrder     of the {@link uk.co.real_logic.sbe.ir.Token}.
     * @param primitiveType of the {@link uk.co.real_logic.sbe.ir.Token}.
     * @return the string formatted as the byte ordering encoding.
     */
    public static String formatWriteBytes(final ByteOrder byteOrder, final PrimitiveType primitiveType)
    {
        final String suffix = byteOrder == ByteOrder.BIG_ENDIAN ? "BigEndian" : "LittleEndian";
        switch (primitiveType)
        {
            case CHAR:
                return "PutByte" + suffix;
            case FLOAT:
                return "PutFloat" + suffix;
            case DOUBLE:
                return "PutDouble" + suffix;
            case INT8:
                return "PutInt8" + suffix;
            case INT16:
                return "PutInt16" + suffix;
            case INT32:
                return "PutInt32" + suffix;
            case INT64:
                return "PutInt64" + suffix;
            case UINT8:
                return "PutUint8" + suffix;
            case UINT16:
                return "PutUint16" + suffix;
            case UINT32:
                return "PutUint32" + suffix;
            case UINT64:
                return "PutUint64" + suffix;
        }
        return "";
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.xml;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.PrimitiveValue;
import uk.co.real_logic.sbe.ir.Token;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import static javax.xml.xpath.XPathConstants.NODESET;
import static uk.co.real_logic.sbe.PrimitiveType.*;
import static uk.co.real_logic.sbe.SbeTool.JAVA_GENERATE_INTERFACES;
import static uk.co.real_logic.sbe.xml.XmlSchemaParser.getAttributeValue;
import static uk.co.real_logic.sbe.xml.XmlSchemaParser.getAttributeValueOrNull;
/**
 * SBE compositeType which is a composite of other composites, sets, enums, or simple types.
 */
public class CompositeType extends Type
{
    /**
     * SBE schema composite type.
     */
    public static final String COMPOSITE_TYPE = "composite";
    private static final String SUB_TYPES_EXP = "type|enum|set|composite|ref|data|group";
    private final List<String> compositesPath = new ArrayList<>();
    private final Map<String, Type> containedTypeByNameMap = new LinkedHashMap<>();
    CompositeType(final Node node) throws XPathExpressionException
    {
        this(node, null, null, new ArrayList<>());
    }
    /**
     * Construct a new compositeType from XML Schema.
     *
     * @param node           from the XML Schema parsing.
     * @param givenName      for this node.
     * @param referencedName of the type when created from a ref in a composite.
     * @param compositesPath with the path of composites that represents the levels of composition.
     * @throws XPathExpressionException if the XPath is invalid.
     */
    CompositeType(
        final Node node, final String givenName, final String referencedName, final List<String> compositesPath)
        throws XPathExpressionException
    {
        super(node, givenName, referencedName);
        this.compositesPath.addAll(compositesPath);
        this.compositesPath.add(getAttributeValue(node, "name"));
        final XPath xPath = XPathFactory.newInstance().newXPath();
        final NodeList list = (NodeList)xPath.compile(SUB_TYPES_EXP).evaluate(node, NODESET);
        for (int i = 0, size = list.getLength(); i < size; i++)
        {
            final Node subTypeNode = list.item(i);
            final String subTypeName = XmlSchemaParser.getAttributeValue(subTypeNode, "name");
            processType(subTypeNode, subTypeName, null, null);
        }
        checkForValidOffsets(node);
    }
    /**
     * Return the EncodedDataType within this composite with the given name.
     *
     * @param name of the type to return.
     * @return type requested.
     */
    public Type getType(final String name)
    {
        return containedTypeByNameMap.get(name);
    }
    /**
     * The encodedLength (in octets) of the list of encoded types.
     *
     * @return encodedLength of the compositeType.
     */
    public int encodedLength()
    {
        int length = 0;
        for (final Type t : containedTypeByNameMap.values())
        {
            if (t.isVariableLength())
            {
                return Token.VARIABLE_LENGTH;
            }
            if (t.offsetAttribute() != -1)
            {
                length = t.offsetAttribute();
            }
            if (t.presence() != Presence.CONSTANT)
            {
                length += t.encodedLength();
            }
        }
        return length;
    }
    /**
     * Return list of the {@link Type}s that compose this composite.
     *
     * @return {@link List} that holds the {@link Type}s in this composite.
     */
    public List<Type> getTypeList()
    {
        return new ArrayList<>(containedTypeByNameMap.values());
    }
    /**
     * Make this composite type, if it has a varData member, variable length
     * by making the type with the name "varData" be variable length.
     */
    public void makeDataFieldCompositeType()
    {
        final EncodedDataType edt = (EncodedDataType)containedTypeByNameMap.get("varData");
        if (edt != null)
        {
            edt.variableLength(true);
        }
    }
    /**
     * Check the composite for being a well-formed group encodedLength encoding. This means
     * that there are the fields "blockLength" and "numInGroup" present.
     *
     * @param node of the XML for this composite.
     */
    public void checkForWellFormedGroupSizeEncoding(final Node node)
    {
        final EncodedDataType blockLengthType = (EncodedDataType)containedTypeByNameMap.get("blockLength");
        final EncodedDataType numInGroupType = (EncodedDataType)containedTypeByNameMap.get("numInGroup");
        if (blockLengthType == null)
        {
            XmlSchemaParser.handleError(node, "composite for group encodedLength encoding must have \"blockLength\"");
        }
        else if (!isUnsigned(blockLengthType.primitiveType()))
        {
            XmlSchemaParser.handleError(node, "\"blockLength\" must be unsigned type");
        }
        else
        {
            if (blockLengthType.primitiveType() != UINT8 && blockLengthType.primitiveType() != UINT16)
            {
                XmlSchemaParser.handleWarning(node, "\"blockLength\" should be UINT8 or UINT16");
            }
            final PrimitiveValue blockLengthTypeMaxValue = blockLengthType.maxValue();
            validateGroupMaxValue(node, blockLengthType.primitiveType(), blockLengthTypeMaxValue);
        }
        if (numInGroupType == null)
        {
            XmlSchemaParser.handleError(node, "composite for group encodedLength encoding must have \"numInGroup\"");
        }
        else if (!isUnsigned(numInGroupType.primitiveType()))
        {
            XmlSchemaParser.handleWarning(node, "\"numInGroup\" should be unsigned type");
            final PrimitiveValue numInGroupMinValue = numInGroupType.minValue();
            if (null == numInGroupMinValue)
            {
                XmlSchemaParser.handleError(node, "\"numInGroup\" minValue must be set for signed types");
            }
            else if (numInGroupMinValue.longValue() < 0)
            {
                XmlSchemaParser.handleError(node,
                    "\"numInGroup\" minValue=" + numInGroupMinValue + " must be greater than zero " +
                    "for signed \"numInGroup\" types");
            }
        }
        else
        {
            if (numInGroupType.primitiveType() != UINT8 && numInGroupType.primitiveType() != UINT16)
            {
                XmlSchemaParser.handleWarning(node, "\"numInGroup\" should be UINT8 or UINT16");
            }
            final PrimitiveValue numInGroupMaxValue = numInGroupType.maxValue();
            validateGroupMaxValue(node, numInGroupType.primitiveType(), numInGroupMaxValue);
            final PrimitiveValue numInGroupMinValue = numInGroupType.minValue();
            if (null != numInGroupMinValue)
            {
                final long max = numInGroupMaxValue != null ?
                    numInGroupMaxValue.longValue() : numInGroupType.primitiveType().maxValue().longValue();
                if (numInGroupMinValue.longValue() > max)
                {
                    XmlSchemaParser.handleError(
                        node, "\"numInGroup\" minValue=" + numInGroupMinValue + " greater than maxValue=" + max);
                }
            }
        }
    }
    /**
     * Check the composite for being a well-formed variable length data encoding. This means
     * that there are the fields "length" and "varData" present.
     *
     * @param node of the XML for this composite
     */
    public void checkForWellFormedVariableLengthDataEncoding(final Node node)
    {
        final EncodedDataType lengthType = (EncodedDataType)containedTypeByNameMap.get("length");
        if (lengthType == null)
        {
            XmlSchemaParser.handleError(node, "composite for variable length data encoding must have \"length\"");
        }
        else
        {
            final PrimitiveType primitiveType = lengthType.primitiveType();
            if (!isUnsigned(primitiveType))
            {
                XmlSchemaParser.handleError(node, "\"length\" must be unsigned type");
            }
            else if (primitiveType != UINT8 && primitiveType != UINT16 && primitiveType != UINT32)
            {
                XmlSchemaParser.handleWarning(node, "\"length\" should be UINT8, UINT16, or UINT32");
            }
            validateGroupMaxValue(node, primitiveType, lengthType.maxValue());
        }
        if ("optional".equals(getAttributeValueOrNull(node, "presence")))
        {
            XmlSchemaParser.handleError(
                node, "composite for variable length data encoding cannot have presence=\"optional\"");
        }
        if (containedTypeByNameMap.get("varData") == null)
        {
            XmlSchemaParser.handleError(node, "composite for variable length data encoding must have \"varData\"");
        }
    }
    private static void validateGroupMaxValue(
        final Node node, final PrimitiveType primitiveType, final PrimitiveValue value)
    {
        if (null != value)
        {
            final long longValue = value.longValue();
            final long allowedValue = primitiveType.maxValue().longValue();
            if (longValue > allowedValue)
            {
                XmlSchemaParser.handleError(
                    node, "maxValue greater than allowed for type: maxValue=" + longValue + " allowed=" + allowedValue);
            }
            final long maxInt = INT32.maxValue().longValue();
            if (primitiveType == UINT32 && longValue > maxInt)
            {
                XmlSchemaParser.handleError(
                    node, "maxValue greater than allowed for type: maxValue=" + longValue + " allowed=" + maxInt);
            }
        }
        else if (primitiveType == UINT32)
        {
            final long maxInt = INT32.maxValue().longValue();
            XmlSchemaParser.handleError(
                node, "maxValue must be set for varData UINT32 type: max value allowed=" + maxInt);
        }
    }
    /**
     * Check the composite for being a well-formed message headerStructure encoding. This means
     * that there are the fields "blockLength", "templateId" and "version" present.
     *
     * @param node of the XML for this composite
     */
    public void checkForWellFormedMessageHeader(final Node node)
    {
        final boolean shouldGenerateInterfaces = "true".equals(System.getProperty(JAVA_GENERATE_INTERFACES));
        final EncodedDataType blockLengthType = (EncodedDataType)containedTypeByNameMap.get("blockLength");
        final EncodedDataType templateIdType = (EncodedDataType)containedTypeByNameMap.get("templateId");
        final EncodedDataType schemaIdType = (EncodedDataType)containedTypeByNameMap.get("schemaId");
        final EncodedDataType versionType = (EncodedDataType)containedTypeByNameMap.get("version");
        if (blockLengthType == null)
        {
            XmlSchemaParser.handleError(node, "composite for message header must have \"blockLength\"");
        }
        else if (!isUnsigned(blockLengthType.primitiveType()))
        {
            XmlSchemaParser.handleError(node, "\"blockLength\" must be unsigned");
        }
        validateHeaderField(node, "blockLength", blockLengthType, UINT16, shouldGenerateInterfaces);
        validateHeaderField(node, "templateId", templateIdType, UINT16, shouldGenerateInterfaces);
        validateHeaderField(node, "schemaId", schemaIdType, UINT16, shouldGenerateInterfaces);
        validateHeaderField(node, "version", versionType, UINT16, shouldGenerateInterfaces);
    }
    private void validateHeaderField(
        final Node node,
        final String fieldName,
        final EncodedDataType actualType,
        final PrimitiveType expectedType,
        final boolean shouldGenerateInterfaces)
    {
        if (actualType == null)
        {
            XmlSchemaParser.handleError(node, "composite for message header must have \"" + fieldName + "\"");
        }
        else if (actualType.primitiveType() != expectedType)
        {
            XmlSchemaParser.handleWarning(node, "\"" + fieldName + "\" should be " + expectedType.name());
            if (shouldGenerateInterfaces)
            {
                if (actualType.primitiveType().size() > expectedType.size())
                {
                    final String msg = "\"" + fieldName + "\" must be less than " + expectedType.size() +
                        " bytes to use " + JAVA_GENERATE_INTERFACES;
                    XmlSchemaParser.handleError(node, msg);
                }
                else
                {
                    final String msg = "\"" + fieldName + "\" will be cast to " + expectedType.name() +
                        " to use " + JAVA_GENERATE_INTERFACES;
                    XmlSchemaParser.handleWarning(node, msg);
                }
            }
        }
    }
    /**
     * Check the composite for any specified offsets and validate they are correctly specified.
     *
     * @param node of the XML for this composite
     */
    public void checkForValidOffsets(final Node node)
    {
        int offset = 0;
        for (final Type edt : containedTypeByNameMap.values())
        {
            final int offsetAttribute = edt.offsetAttribute();
            if (-1 != offsetAttribute)
            {
                if (offsetAttribute < offset)
                {
                    XmlSchemaParser.handleError(
                        node, "composite element \"" + edt.name() + "\" has incorrect offset specified");
                }
                offset = offsetAttribute;
            }
            offset += edt.encodedLength();
        }
    }
    /**
     * {@inheritDoc}
     */
    public boolean isVariableLength()
    {
        return false;
    }
    private Type processType(
        final Node subTypeNode, final String subTypeName, final String givenName, final String referencedName)
        throws XPathExpressionException
    {
        final String nodeName = subTypeNode.getNodeName();
        Type type = null;
        switch (nodeName)
        {
            case "type":
                type = addType(subTypeNode, subTypeName, new EncodedDataType(subTypeNode, givenName, referencedName));
                break;
            case "enum":
                type = addType(subTypeNode, subTypeName, new EnumType(subTypeNode, givenName, referencedName));
                break;
            case "set":
                type = addType(subTypeNode, subTypeName, new SetType(subTypeNode, givenName, referencedName));
                break;
            case "composite":
                type = addType(
                    subTypeNode,
                    subTypeName,
                    new CompositeType(subTypeNode, givenName, referencedName, compositesPath));
                break;
            case "ref":
            {
                final XPath xPath = XPathFactory.newInstance().newXPath();
                final String refTypeName = XmlSchemaParser.getAttributeValue(subTypeNode, "type");
                final String expression = "/*[local-name() = 'messageSchema']/types/*[@name='" + refTypeName + "']";
                final Node refTypeNode = (Node)xPath.compile(expression)
                    .evaluate(subTypeNode.getOwnerDocument(), XPathConstants.NODE);
                if (refTypeNode == null)
                {
                    XmlSchemaParser.handleError(subTypeNode, "ref type not found: " + refTypeName);
                }
                else
                {
                    if (compositesPath.contains(refTypeName))
                    {
                        XmlSchemaParser.handleError(refTypeNode, "ref types cannot create circular dependencies.");
                        throw new IllegalStateException("ref types cannot create circular dependencies");
                    }
                    final String refName = XmlSchemaParser.getAttributeValue(subTypeNode, "name");
                    type = processType(refTypeNode, refName, refName, refTypeName);
                    final String refOffset = XmlSchemaParser.getAttributeValueOrNull(subTypeNode, "offset");
                    if (null != refOffset)
                    {
                        try
                        {
                            type.offsetAttribute(Integer.parseInt(refOffset));
                        }
                        catch (final NumberFormatException ex)
                        {
                            XmlSchemaParser.handleError(subTypeNode, "invalid number type: " + refOffset);
                        }
                    }
                    final String refVersion = XmlSchemaParser.getAttributeValueOrNull(subTypeNode, "sinceVersion");
                    if (null != refVersion)
                    {
                        try
                        {
                            type.sinceVersion(Integer.parseInt(refVersion));
                        }
                        catch (final NumberFormatException ex)
                        {
                            XmlSchemaParser.handleError(subTypeNode, "invalid number type: " + refVersion);
                        }
                    }
                }
                break;
            }
            case "data":
            case "group":
                XmlSchemaParser.handleError(subTypeNode, nodeName + " not valid within composite");
                break;
            default:
                throw new IllegalStateException("Unknown node type: name=" + nodeName);
        }
        return type;
    }
    private Type addType(final Node subTypeNode, final String name, final Type type)
    {
        if (containedTypeByNameMap.put(name, type) != null)
        {
            XmlSchemaParser.handleError(subTypeNode, "composite already contains a type named: " + name);
        }
        return type;
    }
    /**
     * {@inheritDoc}
     */
    public String toString()
    {
        return "CompositeType{" +
            "compositesPath=" + compositesPath +
            ", containedTypeByNameMap=" + containedTypeByNameMap +
            '}';
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 * Copyright 2017 MarketFactory Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.xml;
import org.agrona.Strings;
import org.agrona.collections.ObjectHashSet;
import org.w3c.dom.*;
import org.xml.sax.InputSource;
import uk.co.real_logic.sbe.ValidationUtil;
import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.validation.SchemaFactory;
import javax.xml.xpath.*;
import java.io.File;
import java.io.InputStream;
import java.nio.ByteOrder;
import java.util.HashMap;
import java.util.Map;
import static uk.co.real_logic.sbe.PrimitiveType.*;
import static uk.co.real_logic.sbe.xml.Presence.REQUIRED;
/**
 * Encapsulate the XML Schema parsing for SBE so that other representations may be
 * used to generate independent representations.
 */
public class XmlSchemaParser
{
    /**
     * Key for storing {@link ErrorHandler} as user data in XML document.
     */
    public static final String ERROR_HANDLER_KEY = "SbeErrorHandler";
    static final String TYPE_XPATH_EXPR =
        "/*[local-name() = 'messageSchema']/types/" + EncodedDataType.ENCODED_DATA_TYPE;
    static final String COMPOSITE_XPATH_EXPR =
        "/*[local-name() = 'messageSchema']/types/" + CompositeType.COMPOSITE_TYPE;
    static final String ENUM_XPATH_EXPR =
        "/*[local-name() = 'messageSchema']/types/" + EnumType.ENUM_TYPE;
    static final String SET_XPATH_EXPR =
        "/*[local-name() = 'messageSchema']/types/" + SetType.SET_TYPE;
    static final String MESSAGE_SCHEMA_XPATH_EXPR =
        "/*[local-name() = 'messageSchema']";
    static final String MESSAGE_XPATH_EXPR =
        "/*[local-name() = 'messageSchema']/*[local-name() = 'message']";
    /**
     * Validate the document against a given schema. Errors will be written to {@link java.lang.System#err}.
     *
     * @param xsdFilename schema to validate against.
     * @param is          source from which schema is read. Ideally it will have the systemId property set to resolve
     *                    relative references.
     * @param options     to be applied during parsing.
     * @throws Exception if an error occurs when parsing the document or schema.
     */
    public static void validate(final String xsdFilename, final InputSource is, final ParserOptions options)
        throws Exception
    {
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        final SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
        factory.setSchema(schemaFactory.newSchema(new File(xsdFilename)));
        factory.setNamespaceAware(true);
        if (options.xIncludeAware())
        {
            factory.setXIncludeAware(true);
            factory.setFeature("http://apache.org/xml/features/xinclude/fixup-base-uris", false);
        }
        factory.newDocumentBuilder().parse(is);
    }
    /**
     * Wraps the {@link InputStream} into an {@link InputSource} and delegates to
     * {@link #validate(String, InputSource, ParserOptions)}.
     * <p>
     * <b>Note:</b> this method does not set the {@link InputSource#setSystemId(java.lang.String)} property.
     * However, it is recommended to use the {@link #validate(String, InputSource, ParserOptions)}  method directly.
     *
     * @param xsdFilename schema to validate against.
     * @param in          document to be validated.
     * @param options     to be applied during parsing.
     * @throws Exception if an error occurs when parsing the document or schema.
     */
    public static void validate(final String xsdFilename, final InputStream in, final ParserOptions options)
        throws Exception
    {
        validate(xsdFilename, new InputSource(in), options);
    }
    /**
     * Take an {@link InputSource} and parse it generating map of template ID to Message objects, types, and schema.
     *
     * @param is      source from which schema is read. Ideally it will have the systemId property set to resolve
     *                relative references.
     * @param options to be applied during parsing.
     * @return {@link MessageSchema} encoding for the schema.
     * @throws Exception on parsing error.
     */
    public static MessageSchema parse(final InputSource is, final ParserOptions options) throws Exception
    {
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        if (options.xIncludeAware())
        {
            factory.setNamespaceAware(true);
            factory.setXIncludeAware(true);
            factory.setFeature("http://apache.org/xml/features/xinclude/fixup-base-uris", false);
        }
        final Document document = factory.newDocumentBuilder().parse(is);
        final ErrorHandler errorHandler = new ErrorHandler(options);
        document.setUserData(ERROR_HANDLER_KEY, errorHandler, null);
        final XPath xPath = XPathFactory.newInstance().newXPath();
        final Map<String, Type> typeByNameMap = findTypes(document, xPath);
        errorHandler.checkIfShouldExit();
        final Map<Long, Message> messageByIdMap = findMessages(document, xPath, typeByNameMap);
        errorHandler.checkIfShouldExit();
        final Node schemaNode = (Node)xPath.compile(MESSAGE_SCHEMA_XPATH_EXPR).evaluate(document, XPathConstants.NODE);
        if (null == schemaNode)
        {
            throw new IllegalStateException("messageSchema element not found in document, schema is not valid for SBE");
        }
        final MessageSchema messageSchema = new MessageSchema(schemaNode, typeByNameMap, messageByIdMap);
        messageSchema.validate(errorHandler);
        errorHandler.checkIfShouldExit();
        return messageSchema;
    }
    /**
     * Wraps the {@link InputStream} into an {@link InputSource} and delegates to
     * {@link #parse(InputSource, ParserOptions)}.
     * <p>
     * <b>Note:</b> this method does not set the {@link InputSource#setSystemId(java.lang.String)} property.
     * However, it is recommended to use the {@link #parse(InputSource, ParserOptions)} method directly.
     *
     * @param in      stream from which schema is read.
     * @param options to be applied during parsing.
     * @return {@link MessageSchema} encoding for the schema.
     * @throws Exception on parsing error.
     */
    public static MessageSchema parse(final InputStream in, final ParserOptions options) throws Exception
    {
        return parse(new InputSource(in), options);
    }
    /**
     * Scan XML for all types (encodedDataType, compositeType, enumType, and setType) and save in a map.
     *
     * @param document for the XML parsing.
     * @param xPath    for XPath expression reuse.
     * @return {@link java.util.Map} of name {@link java.lang.String} to {@link Type}.
     * @throws XPathExpressionException on parsing error.
     */
    public static Map<String, Type> findTypes(final Document document, final XPath xPath)
        throws XPathExpressionException
    {
        final Map<String, Type> typeByNameMap = new HashMap<>();
        typeByNameMap.put("char", new EncodedDataType("char", REQUIRED, null, null, CHAR, 1, false));
        typeByNameMap.put("int8", new EncodedDataType("int8", REQUIRED, null, null, INT8, 1, false));
        typeByNameMap.put("int16", new EncodedDataType("int16", REQUIRED, null, null, INT16, 1, false));
        typeByNameMap.put("int32", new EncodedDataType("int32", REQUIRED, null, null, INT32, 1, false));
        typeByNameMap.put("int64", new EncodedDataType("int64", REQUIRED, null, null, INT64, 1, false));
        typeByNameMap.put("uint8", new EncodedDataType("uint8", REQUIRED, null, null, UINT8, 1, false));
        typeByNameMap.put("uint16", new EncodedDataType("uint16", REQUIRED, null, null, UINT16, 1, false));
        typeByNameMap.put("uint32", new EncodedDataType("uint32", REQUIRED, null, null, UINT32, 1, false));
        typeByNameMap.put("uint64", new EncodedDataType("uint64", REQUIRED, null, null, UINT64, 1, false));
        typeByNameMap.put("float", new EncodedDataType("float", REQUIRED, null, null, FLOAT, 1, false));
        typeByNameMap.put("double", new EncodedDataType("double", REQUIRED, null, null, DOUBLE, 1, false));
        forEach(
            (NodeList)xPath.compile(TYPE_XPATH_EXPR).evaluate(document, XPathConstants.NODESET),
            (node) -> addTypeWithNameCheck(typeByNameMap, new EncodedDataType(node), node));
        forEach(
            (NodeList)xPath.compile(COMPOSITE_XPATH_EXPR).evaluate(document, XPathConstants.NODESET),
            (node) -> addTypeWithNameCheck(typeByNameMap, new CompositeType(node), node));
        forEach(
            (NodeList)xPath.compile(ENUM_XPATH_EXPR).evaluate(document, XPathConstants.NODESET),
            (node) -> addTypeWithNameCheck(typeByNameMap, new EnumType(node), node));
        forEach(
            (NodeList)xPath.compile(SET_XPATH_EXPR).evaluate(document, XPathConstants.NODESET),
            (node) -> addTypeWithNameCheck(typeByNameMap, new SetType(node), node));
        return typeByNameMap;
    }
    /**
     * Scan XML for all message definitions and save in map.
     *
     * @param document      for the XML parsing.
     * @param xPath         for XPath expression reuse.
     * @param typeByNameMap to use for Type objects.
     * @return {@link java.util.Map} of schemaId to {@link Message}.
     * @throws XPathExpressionException on parsing error.
     */
    public static Map<Long, Message> findMessages(
        final Document document, final XPath xPath, final Map<String, Type> typeByNameMap)
        throws XPathExpressionException
    {
        final Map<Long, Message> messageByIdMap = new HashMap<>();
        final ObjectHashSet<String> distinctNames = new ObjectHashSet<>();
        forEach(
            (NodeList)xPath.compile(MESSAGE_XPATH_EXPR).evaluate(document, XPathConstants.NODESET),
            (node) -> addMessageWithIdCheck(distinctNames, messageByIdMap, new Message(node, typeByNameMap), node));
        if (messageByIdMap.isEmpty())
        {
            handleWarning(document.getDocumentElement(), "no messages found in document");
        }
        return messageByIdMap;
    }
    /**
     * Handle an error condition as consequence of parsing.
     *
     * @param node that is the context of the warning.
     * @param msg  associated with the error.
     */
    public static void handleError(final Node node, final String msg)
    {
        final ErrorHandler handler = (ErrorHandler)node.getOwnerDocument().getUserData(ERROR_HANDLER_KEY);
        if (null == handler)
        {
            throw new IllegalStateException("ERROR: " + formatLocationInfo(node) + msg);
        }
        else
        {
            handler.error(formatLocationInfo(node) + msg);
        }
    }
    /**
     * Handle a warning condition as a consequence of parsing.
     *
     * @param node as the context for the warning.
     * @param msg  associated with the warning.
     */
    public static void handleWarning(final Node node, final String msg)
    {
        final ErrorHandler handler = (ErrorHandler)node.getOwnerDocument().getUserData(ERROR_HANDLER_KEY);
        if (null == handler)
        {
            throw new IllegalStateException("WARNING: " + formatLocationInfo(node) + msg);
        }
        else
        {
            handler.warning(formatLocationInfo(node) + msg);
        }
    }
    /**
     * Helper function that throws an exception when the attribute is not set.
     *
     * @param elementNode that should have the attribute.
     * @param attrName    that is to be looked up.
     * @return value of the attribute.
     * @throws IllegalStateException if the attribute is not present.
     */
    public static String getAttributeValue(final Node elementNode, final String attrName)
    {
        if (null == elementNode)
        {
            throw new IllegalStateException(
                "element node is null when looking for attribute: " + attrName);
        }
        final NamedNodeMap attributes = elementNode.getAttributes();
        final Node attrNode = attributes.getNamedItemNS(null, attrName);
        if (null == attrNode)
        {
            throw new IllegalStateException(
                "element '" + elementNode.getNodeName() + "' has missing attribute: " + attrName);
        }
        final String nodeValue = attrNode.getNodeValue();
        if (Strings.isEmpty(nodeValue))
        {
            throw new IllegalStateException(
                "element '" + elementNode.getNodeName() + "' has empty attribute: " + attrName);
        }
        return nodeValue;
    }
    /**
     * Helper function that uses a default value when value not set.
     *
     * @param elementNode that should have the attribute.
     * @param attrName    that is to be looked up.
     * @param defValue    value to return if not set.
     * @return value of the attribute or defValue.
     */
    public static String getAttributeValue(final Node elementNode, final String attrName, final String defValue)
    {
        if (null == elementNode)
        {
            throw new IllegalStateException(
                "element node is null when looking for attribute: " + attrName);
        }
        final NamedNodeMap attributes = elementNode.getAttributes();
        final Node attrNode = attributes.getNamedItemNS(null, attrName);
        if (null == attrNode)
        {
            return defValue;
        }
        return attrNode.getNodeValue();
    }
    /**
     * To be used with descendant elements of {@code <types>} elements. Returns the package attribute value as
     * defined on the ancestor {@code <types>} element.
     *
     * @param elementNode the node inside the {@code <types>} element.
     * @return the package name, or null if not defined.
     */
    public static String getTypesPackageAttribute(final Node elementNode)
    {
        Node parentNode = elementNode.getParentNode();
        while (null != parentNode)
        {
            if ("types".equals(parentNode.getLocalName()) || "types".equals(parentNode.getNodeName()))
            {
                return getAttributeValue(parentNode, "package", null);
            }
            parentNode = parentNode.getParentNode();
        }
        return null;
    }
    /**
     * Helper function that hides the null return from {@link org.w3c.dom.NamedNodeMap#getNamedItem(String)}.
     *
     * @param elementNode that could be null.
     * @param attrName    that is to be looked up.
     * @return null or value of the attribute.
     */
    public static String getAttributeValueOrNull(final Node elementNode, final String attrName)
    {
        if (null == elementNode)
        {
            return null;
        }
        final NamedNodeMap attributes = elementNode.getAttributes();
        if (null == attributes)
        {
            return null;
        }
        final Node attrNode = attributes.getNamedItemNS(null, attrName);
        if (null == attrNode)
        {
            return null;
        }
        return attrNode.getNodeValue();
    }
    /**
     * Helper function to convert a schema byteOrderName into a {@link ByteOrder}.
     *
     * @param byteOrderName specified as a FIX SBE string.
     * @return ByteOrder representation.
     */
    public static ByteOrder getByteOrder(final String byteOrderName)
    {
        if ("bigEndian".equals(byteOrderName))
        {
            return ByteOrder.BIG_ENDIAN;
        }
        return ByteOrder.LITTLE_ENDIAN;
    }
    /**
     * Check name against validity for C++ and Java naming. Warning if not valid.
     *
     * @param node to have the name checked.
     * @param name of the node to be checked.
     */
    public static void checkForValidName(final Node node, final String name)
    {
        if (!ValidationUtil.isSbeCppName(name))
        {
            handleWarning(node, "name is not valid for C++: " + name);
        }
        if (!ValidationUtil.isSbeJavaName(name))
        {
            handleWarning(node, "name is not valid for Java: " + name);
        }
        if (!ValidationUtil.isSbeGolangName(name))
        {
            handleWarning(node, "name is not valid for Golang: " + name);
        }
        if (!ValidationUtil.isSbeCSharpName(name))
        {
            handleWarning(node, "name is not valid for C#: " + name);
        }
    }
    private static void addTypeWithNameCheck(final Map<String, Type> typeByNameMap, final Type type, final Node node)
    {
        if (typeByNameMap.get(type.name()) != null)
        {
            handleWarning(node, "type already exists for name: " + type.name());
        }
        checkForValidName(node, type.name());
        typeByNameMap.put(type.name(), type);
    }
    private static void addMessageWithIdCheck(
        final ObjectHashSet<String> distinctNames,
        final Map<Long, Message> messageByIdMap,
        final Message message,
        final Node node)
    {
        if (messageByIdMap.get((long)message.id()) != null)
        {
            handleError(node, "message template id already exists: " + message.id());
        }
        if (!distinctNames.add(message.name()))
        {
            handleError(node, "message name already exists: " + message.name());
        }
        checkForValidName(node, message.name());
        messageByIdMap.put((long)message.id(), message);
    }
    private static String formatLocationInfo(final Node node)
    {
        final Node parentNode = node.getParentNode();
        return "at " +
            "<" + parentNode.getNodeName() +
            (getAttributeValueOrNull(parentNode, "name") == null ?
                ">" : (" name=\"" + getAttributeValueOrNull(parentNode, "name") + "\"> ")) +
            "<" + node.getNodeName() +
            (getAttributeValueOrNull(node, "name") == null ?
                ">" : (" name=\"" + getAttributeValueOrNull(node, "name") + "\"> "));
    }
    @FunctionalInterface
    interface NodeFunction
    {
        void execute(Node node) throws XPathExpressionException;
    }
    static void forEach(final NodeList nodeList, final NodeFunction func)
        throws XPathExpressionException
    {
        for (int i = 0, size = nodeList.getLength(); i < size; i++)
        {
            func.execute(nodeList.item(i));
        }
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.properties;
import net.jqwik.api.*;
import net.jqwik.api.footnotes.EnableFootnotes;
import net.jqwik.api.footnotes.Footnotes;
import uk.co.real_logic.sbe.generation.common.PrecedenceChecks;
import uk.co.real_logic.sbe.generation.cpp.CppDtoGenerator;
import uk.co.real_logic.sbe.generation.cpp.CppGenerator;
import uk.co.real_logic.sbe.generation.cpp.NamespaceOutputManager;
import uk.co.real_logic.sbe.generation.csharp.CSharpDtoGenerator;
import uk.co.real_logic.sbe.generation.csharp.CSharpGenerator;
import uk.co.real_logic.sbe.generation.csharp.CSharpNamespaceOutputManager;
import uk.co.real_logic.sbe.generation.java.JavaDtoGenerator;
import uk.co.real_logic.sbe.generation.java.JavaGenerator;
import uk.co.real_logic.sbe.ir.generated.MessageHeaderDecoder;
import uk.co.real_logic.sbe.properties.arbitraries.SbeArbitraries;
import uk.co.real_logic.sbe.properties.utils.InMemoryOutputManager;
import org.agrona.*;
import org.agrona.concurrent.UnsafeBuffer;
import org.agrona.io.DirectBufferInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Base64;
import java.util.stream.Stream;
import static org.junit.jupiter.api.Assertions.fail;
import static uk.co.real_logic.sbe.SbeTool.JAVA_DEFAULT_DECODING_BUFFER_TYPE;
import static uk.co.real_logic.sbe.SbeTool.JAVA_DEFAULT_ENCODING_BUFFER_TYPE;
@SuppressWarnings("ReadWriteStringCanBeUsed")
@EnableFootnotes
public class DtosPropertyTest
{
    private static final String DOTNET_EXECUTABLE = System.getProperty("sbe.tests.dotnet.executable", "dotnet");
    private static final String SBE_DLL =
        System.getProperty("sbe.dll", "csharp/sbe-dll/bin/Release/netstandard2.0/SBE.dll");
    private static final String CPP_EXECUTABLE = System.getProperty("sbe.tests.cpp.executable", "g++");
    private final ExpandableArrayBuffer outputBuffer = new ExpandableArrayBuffer();
    @Property
    void javaDtoEncodeShouldBeTheInverseOfDtoDecode(
        @ForAll("encodedMessage") final SbeArbitraries.EncodedMessage encodedMessage,
        final Footnotes footnotes)
        throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException,
        IllegalAccessException
    {
        final String packageName = encodedMessage.ir().applicableNamespace();
        final InMemoryOutputManager outputManager = new InMemoryOutputManager(packageName);
        try
        {
            try
            {
                new JavaGenerator(
                    encodedMessage.ir(),
                    JAVA_DEFAULT_ENCODING_BUFFER_TYPE,
                    JAVA_DEFAULT_DECODING_BUFFER_TYPE,
                    false,
                    false,
                    false,
                    false,
                    PrecedenceChecks.newInstance(new PrecedenceChecks.Context()),
                    outputManager)
                    .generate();
                new JavaDtoGenerator(encodedMessage.ir(), false, outputManager)
                    .generate();
            }
            catch (final Exception generationException)
            {
                fail("Code generation failed.", generationException);
            }
            try (URLClassLoader generatedClassLoader = outputManager.compileGeneratedSources())
            {
                final Class<?> dtoClass =
                    generatedClassLoader.loadClass(packageName + ".TestMessageDto");
                final Method decodeFrom =
                    dtoClass.getMethod("decodeFrom", DirectBuffer.class, int.class, int.class, int.class);
                final Method encodeWith =
                    dtoClass.getMethod("encodeWithHeaderWith", dtoClass, MutableDirectBuffer.class, int.class);
                final int inputLength = encodedMessage.length();
                final ExpandableArrayBuffer inputBuffer = encodedMessage.buffer();
                final MessageHeaderDecoder header = new MessageHeaderDecoder().wrap(inputBuffer, 0);
                final int blockLength = header.blockLength();
                final int actingVersion = header.version();
                final Object dto = decodeFrom.invoke(null,
                    encodedMessage.buffer(), MessageHeaderDecoder.ENCODED_LENGTH, blockLength, actingVersion);
                outputBuffer.setMemory(0, outputBuffer.capacity(), (byte)0);
                final int outputLength = (int)encodeWith.invoke(null, dto, outputBuffer, 0);
                if (!areEqual(inputBuffer, inputLength, outputBuffer, outputLength))
                {
                    fail("Input and output differ");
                }
            }
        }
        catch (final Throwable throwable)
        {
            addInputFootnotes(footnotes, encodedMessage);
            final StringBuilder generatedSources = new StringBuilder();
            outputManager.dumpSources(generatedSources);
            footnotes.addFootnote(generatedSources.toString());
            throw throwable;
        }
    }
    @Property
    void csharpDtoEncodeShouldBeTheInverseOfDtoDecode(
        @ForAll("encodedMessage") final SbeArbitraries.EncodedMessage encodedMessage,
        final Footnotes footnotes)
        throws IOException, InterruptedException
    {
        final Path tempDir = Files.createTempDirectory("sbe-csharp-dto-test");
        try
        {
            final CSharpNamespaceOutputManager outputManager = new CSharpNamespaceOutputManager(
                tempDir.toString(),
                "SbePropertyTest"
            );
            try
            {
                new CSharpGenerator(encodedMessage.ir(), outputManager)
                    .generate();
                new CSharpDtoGenerator(encodedMessage.ir(), false, outputManager)
                    .generate();
            }
            catch (final Exception generationException)
            {
                throw new AssertionError(
                    "Code generation failed.\n\n" +
                        "DIR:" + tempDir + "\n\n" +
                        "SCHEMA:\n" + encodedMessage.schema(),
                    generationException);
            }
            copyResourceToFile("/CSharpDtosPropertyTest/SbePropertyTest.csproj", tempDir);
            copyResourceToFile("/CSharpDtosPropertyTest/Program.cs", tempDir);
            writeInputFile(encodedMessage, tempDir);
            execute(encodedMessage.schema(), tempDir, "test",
                DOTNET_EXECUTABLE, "run",
                "--property:SBE_DLL=" + SBE_DLL,
                "--", "input.dat");
            final byte[] inputBytes = new byte[encodedMessage.length()];
            encodedMessage.buffer().getBytes(0, inputBytes);
            final byte[] outputBytes = Files.readAllBytes(tempDir.resolve("output.dat"));
            if (!Arrays.equals(inputBytes, outputBytes))
            {
                throw new AssertionError(
                    "Input and output files differ\n\n" +
                        "DIR:" + tempDir + "\n\n" +
                        "SCHEMA:\n" + encodedMessage.schema());
            }
        }
        catch (final Throwable throwable)
        {
            addInputFootnotes(footnotes, encodedMessage);
            addGeneratedSourcesFootnotes(footnotes, tempDir, ".cs");
            throw throwable;
        }
        finally
        {
            IoUtil.delete(tempDir.toFile(), true);
        }
    }
    @Property(shrinking = ShrinkingMode.OFF)
    void cppDtoEncodeShouldBeTheInverseOfDtoDecode(
        @ForAll("encodedMessage") final SbeArbitraries.EncodedMessage encodedMessage,
        final Footnotes footnotes) throws IOException, InterruptedException
    {
        final Path tempDir = Files.createTempDirectory("sbe-cpp-dto-test");
        try
        {
            final NamespaceOutputManager outputManager = new NamespaceOutputManager(
                tempDir.toString(), "sbe_property_test");
            try
            {
                new CppGenerator(encodedMessage.ir(), true, outputManager)
                    .generate();
                new CppDtoGenerator(encodedMessage.ir(), false, outputManager)
                    .generate();
            }
            catch (final Exception generationException)
            {
                throw new AssertionError(
                    "Code generation failed.\n\nSCHEMA:\n" + encodedMessage.schema(),
                    generationException);
            }
            copyResourceToFile("/CppDtosPropertyTest/main.cpp", tempDir);
            writeInputFile(encodedMessage, tempDir);
            execute(encodedMessage.schema(), tempDir, "compile",
                CPP_EXECUTABLE, "--std", "c++17", "-o", "round-trip-test", "main.cpp");
            execute(encodedMessage.schema(), tempDir, "test",
                tempDir.resolve("round-trip-test").toString(), "input.dat");
            final byte[] inputBytes = new byte[encodedMessage.length()];
            encodedMessage.buffer().getBytes(0, inputBytes);
            final byte[] outputBytes = Files.readAllBytes(tempDir.resolve("output.dat"));
            if (!Arrays.equals(inputBytes, outputBytes))
            {
                throw new AssertionError(
                    "Input and output files differ\n\n" +
                    "SCHEMA:\n" + encodedMessage.schema());
            }
        }
        catch (final Throwable throwable)
        {
            addInputFootnotes(footnotes, encodedMessage);
            addGeneratedSourcesFootnotes(footnotes, tempDir, ".cpp");
            throw throwable;
        }
        finally
        {
            IoUtil.delete(tempDir.toFile(), true);
        }
    }
    private static void writeInputFile(
        final SbeArbitraries.EncodedMessage encodedMessage,
        final Path tempDir) throws IOException
    {
        try (
            DirectBufferInputStream inputStream = new DirectBufferInputStream(
                encodedMessage.buffer(),
                0,
                encodedMessage.length()
            );
            OutputStream outputStream = Files.newOutputStream(tempDir.resolve("input.dat")))
        {
            final byte[] buffer = new byte[2048];
            int read;
            while ((read = inputStream.read(buffer, 0, buffer.length)) >= 0)
            {
                outputStream.write(buffer, 0, read);
            }
        }
    }
    private static void execute(
        final String schema,
        final Path tempDir,
        final String name,
        final String... args) throws InterruptedException, IOException
    {
        final Path stdout = tempDir.resolve(name + "_stdout.txt");
        final Path stderr = tempDir.resolve(name + "_stderr.txt");
        final ProcessBuilder processBuilder = new ProcessBuilder(args)
            .directory(tempDir.toFile())
            .redirectOutput(stdout.toFile())
            .redirectError(stderr.toFile());
        final Process process = processBuilder.start();
        if (0 != process.waitFor())
        {
            throw new AssertionError(
                "Process failed with exit code: " + process.exitValue() + "\n\n" +
                    "DIR:" + tempDir + "\n\n" +
                    "STDOUT:\n" + new String(Files.readAllBytes(stdout)) + "\n\n" +
                    "STDERR:\n" + new String(Files.readAllBytes(stderr)) + "\n\n" +
                    "SCHEMA:\n" + schema);
        }
        final byte[] errorBytes = Files.readAllBytes(stderr);
        if (errorBytes.length != 0)
        {
            throw new AssertionError(
                "Process wrote to stderr.\n\n" +
                    "DIR:" + tempDir + "\n\n" +
                    "STDOUT:\n" + new String(Files.readAllBytes(stdout)) + "\n\n" +
                    "STDERR:\n" + new String(errorBytes) + "\n\n" +
                    "SCHEMA:\n" + schema + "\n\n"
            );
        }
    }
    @Provide
    Arbitrary<SbeArbitraries.EncodedMessage> encodedMessage()
    {
        final SbeArbitraries.CharGenerationMode mode =
            SbeArbitraries.CharGenerationMode.JSON_PRINTER_COMPATIBLE;
        return SbeArbitraries.encodedMessage(mode);
    }
    private static void copyResourceToFile(
        final String resourcePath,
        final Path outputDir)
    {
        try (InputStream inputStream = DtosPropertyTest.class.getResourceAsStream(resourcePath))
        {
            if (inputStream == null)
            {
                throw new IOException("Resource not found: " + resourcePath);
            }
            final int resourceNameIndex = resourcePath.lastIndexOf('/') + 1;
            final String resourceName = resourcePath.substring(resourceNameIndex);
            final Path outputFilePath = outputDir.resolve(resourceName);
            Files.copy(inputStream, outputFilePath);
        }
        catch (final IOException e)
        {
            throw new RuntimeException(e);
        }
    }
    private boolean areEqual(
        final ExpandableArrayBuffer inputBuffer,
        final int inputLength,
        final ExpandableArrayBuffer outputBuffer,
        final int outputLength)
    {
        return new UnsafeBuffer(inputBuffer, 0, inputLength).equals(new UnsafeBuffer(outputBuffer, 0, outputLength));
    }
    private void addGeneratedSourcesFootnotes(
        final Footnotes footnotes,
        final Path directory,
        final String suffix)
    {
        try (Stream<Path> contents = Files.walk(directory))
        {
            contents
                .filter(path -> path.toString().endsWith(suffix))
                .forEach(path ->
                {
                    try
                    {
                        footnotes.addFootnote(System.lineSeparator() + "File: " + path +
                            System.lineSeparator() +
                            new String(Files.readAllBytes(path), StandardCharsets.UTF_8));
                    }
                    catch (final IOException exn)
                    {
                        LangUtil.rethrowUnchecked(exn);
                    }
                });
        }
        catch (final IOException exn)
        {
            LangUtil.rethrowUnchecked(exn);
        }
    }
    public void addInputFootnotes(final Footnotes footnotes, final SbeArbitraries.EncodedMessage encodedMessage)
    {
        final byte[] messageBytes = new byte[encodedMessage.length()];
        encodedMessage.buffer().getBytes(0, messageBytes);
        final byte[] base64EncodedMessageBytes = Base64.getEncoder().encode(messageBytes);
        footnotes.addFootnote("Schema:" + System.lineSeparator() + encodedMessage.schema());
        footnotes.addFootnote("Input Message:" + System.lineSeparator() +
            new String(base64EncodedMessageBytes, StandardCharsets.UTF_8));
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.java;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.generation.CodeGenerator;
import uk.co.real_logic.sbe.generation.Generators;
import uk.co.real_logic.sbe.generation.common.FieldPrecedenceModel;
import uk.co.real_logic.sbe.generation.common.PrecedenceChecks;
import uk.co.real_logic.sbe.ir.*;
import org.agrona.DirectBuffer;
import org.agrona.MutableDirectBuffer;
import org.agrona.Strings;
import org.agrona.Verify;
import org.agrona.collections.MutableBoolean;
import org.agrona.generation.DynamicPackageOutputManager;
import org.agrona.sbe.*;
import java.io.IOException;
import java.io.Writer;
import java.util.*;
import java.util.function.Function;
import static uk.co.real_logic.sbe.SbeTool.JAVA_INTERFACE_PACKAGE;
import static uk.co.real_logic.sbe.generation.java.JavaGenerator.CodecType.DECODER;
import static uk.co.real_logic.sbe.generation.java.JavaGenerator.CodecType.ENCODER;
import static uk.co.real_logic.sbe.generation.java.JavaUtil.*;
import static uk.co.real_logic.sbe.ir.GenerationUtil.*;
/**
 * Generate codecs for the Java 8 programming language.
 */
@SuppressWarnings("MethodLength")
public class JavaGenerator implements CodeGenerator
{
    static final String MESSAGE_HEADER_ENCODER_TYPE = "MessageHeaderEncoder";
    static final String MESSAGE_HEADER_DECODER_TYPE = "MessageHeaderDecoder";
    enum CodecType
    {
        DECODER,
        ENCODER
    }
    private static final String META_ATTRIBUTE_ENUM = "MetaAttribute";
    private static final String PACKAGE_INFO = "package-info";
    private static final String BASE_INDENT = "";
    private static final String INDENT = "    ";
    private static final Set<String> PACKAGES_EMPTY_SET = Collections.emptySet();
    private final Ir ir;
    private final DynamicPackageOutputManager outputManager;
    private final String fqMutableBuffer;
    private final String mutableBuffer;
    private final String fqReadOnlyBuffer;
    private final String readOnlyBuffer;
    private final boolean shouldGenerateGroupOrderAnnotation;
    private final boolean shouldGenerateInterfaces;
    private final boolean shouldDecodeUnknownEnumValues;
    private final boolean shouldSupportTypesPackageNames;
    private final PrecedenceChecks precedenceChecks;
    private final String precedenceChecksFlagName;
    private final String precedenceChecksPropName;
    private final Set<String> packageNameByTypes = new HashSet<>();
    /**
     * Create a new Java language {@link CodeGenerator}. Generator support for types in their own package is disabled.
     *
     * @param ir                                 for the messages and types.
     * @param mutableBuffer                      implementation used for mutating underlying buffers.
     * @param readOnlyBuffer                     implementation used for reading underlying buffers.
     * @param shouldGenerateGroupOrderAnnotation in the codecs.
     * @param shouldGenerateInterfaces           for common methods.
     * @param shouldDecodeUnknownEnumValues      generate support for unknown enum values when decoding.
     * @param outputManager                      for generating the codecs to.
     */
    public JavaGenerator(
        final Ir ir,
        final String mutableBuffer,
        final String readOnlyBuffer,
        final boolean shouldGenerateGroupOrderAnnotation,
        final boolean shouldGenerateInterfaces,
        final boolean shouldDecodeUnknownEnumValues,
        final DynamicPackageOutputManager outputManager)
    {
        this(ir, mutableBuffer, readOnlyBuffer, shouldGenerateGroupOrderAnnotation, shouldGenerateInterfaces,
            shouldDecodeUnknownEnumValues, false, outputManager);
    }
    /**
     * Create a new Java language {@link CodeGenerator}.
     *
     * @param ir                                 for the messages and types.
     * @param mutableBuffer                      implementation used for mutating underlying buffers.
     * @param readOnlyBuffer                     implementation used for reading underlying buffers.
     * @param shouldGenerateGroupOrderAnnotation in the codecs.
     * @param shouldGenerateInterfaces           for common methods.
     * @param shouldDecodeUnknownEnumValues      generate support for unknown enum values when decoding.
     * @param shouldSupportTypesPackageNames     generator support for types in their own package.
     * @param outputManager                      for generating the codecs to.
     */
    public JavaGenerator(
        final Ir ir,
        final String mutableBuffer,
        final String readOnlyBuffer,
        final boolean shouldGenerateGroupOrderAnnotation,
        final boolean shouldGenerateInterfaces,
        final boolean shouldDecodeUnknownEnumValues,
        final boolean shouldSupportTypesPackageNames,
        final DynamicPackageOutputManager outputManager)
    {
        this(
            ir,
            mutableBuffer,
            readOnlyBuffer,
            shouldGenerateGroupOrderAnnotation,
            shouldGenerateInterfaces,
            shouldDecodeUnknownEnumValues,
            shouldSupportTypesPackageNames,
            PrecedenceChecks.newInstance(new PrecedenceChecks.Context()),
            outputManager);
    }
    /**
     * Create a new Java language {@link CodeGenerator}.
     *
     * @param ir                                 for the messages and types.
     * @param mutableBuffer                      implementation used for mutating underlying buffers.
     * @param readOnlyBuffer                     implementation used for reading underlying buffers.
     * @param shouldGenerateGroupOrderAnnotation in the codecs.
     * @param shouldGenerateInterfaces           for common methods.
     * @param shouldDecodeUnknownEnumValues      generate support for unknown enum values when decoding.
     * @param shouldSupportTypesPackageNames     generator support for types in their own package.
     * @param precedenceChecks                   whether and how to generate field precedence checks.
     * @param outputManager                      for generating the codecs to.
     */
    public JavaGenerator(
        final Ir ir,
        final String mutableBuffer,
        final String readOnlyBuffer,
        final boolean shouldGenerateGroupOrderAnnotation,
        final boolean shouldGenerateInterfaces,
        final boolean shouldDecodeUnknownEnumValues,
        final boolean shouldSupportTypesPackageNames,
        final PrecedenceChecks precedenceChecks,
        final DynamicPackageOutputManager outputManager)
    {
        Verify.notNull(ir, "ir");
        Verify.notNull(outputManager, "outputManager");
        Verify.notNull(precedenceChecks, "precedenceChecks");
        this.ir = ir;
        this.shouldSupportTypesPackageNames = shouldSupportTypesPackageNames;
        this.outputManager = outputManager;
        this.mutableBuffer = validateBufferImplementation(mutableBuffer, MutableDirectBuffer.class);
        this.fqMutableBuffer = mutableBuffer;
        this.readOnlyBuffer = validateBufferImplementation(readOnlyBuffer, DirectBuffer.class);
        this.fqReadOnlyBuffer = readOnlyBuffer;
        this.shouldGenerateGroupOrderAnnotation = shouldGenerateGroupOrderAnnotation;
        this.shouldGenerateInterfaces = shouldGenerateInterfaces;
        this.shouldDecodeUnknownEnumValues = shouldDecodeUnknownEnumValues;
        this.precedenceChecks = precedenceChecks;
        this.precedenceChecksFlagName = precedenceChecks.context().precedenceChecksFlagName();
        this.precedenceChecksPropName = precedenceChecks.context().precedenceChecksPropName();
    }
    /**
     * Generate the composites for dealing with the message header.
     *
     * @throws IOException if an error is encountered when writing the output.
     */
    public void generateMessageHeaderStub() throws IOException
    {
        generateComposite(ir.headerStructure().tokens());
    }
    /**
     * Generate the stubs for the types used as message fields.
     *
     * @throws IOException if an error is encountered when writing the output.
     */
    public void generateTypeStubs() throws IOException
    {
        generateMetaAttributeEnum();
        for (final List<Token> tokens : ir.types())
        {
            switch (tokens.get(0).signal())
            {
                case BEGIN_ENUM:
                    generateEnum(tokens);
                    break;
                case BEGIN_SET:
                    generateBitSet(tokens);
                    break;
                case BEGIN_COMPOSITE:
                    generateComposite(tokens);
                    break;
                default:
                    break;
            }
        }
    }
    /**
     * Register the types explicit package - if set and should be supported.
     *
     * @param token the 0-th token of the type.
     * @param ir    the intermediate representation.
     * @return the overridden package name of the type if set and supported, or {@link Ir#applicableNamespace()}.
     */
    private String registerTypesPackageName(final Token token, final Ir ir)
    {
        if (!shouldSupportTypesPackageNames)
        {
            return ir.applicableNamespace();
        }
        if (token.packageName() != null)
        {
            packageNameByTypes.add(token.packageName());
            outputManager.setPackageName(token.packageName());
            return token.packageName();
        }
        return ir.applicableNamespace();
    }
    /**
     * {@inheritDoc}
     */
    public void generate() throws IOException
    {
        packageNameByTypes.clear();
        generatePackageInfo();
        generateTypeStubs();
        generateMessageHeaderStub();
        for (final List<Token> tokens : ir.messages())
        {
            final Token msgToken = tokens.get(0);
            final List<Token> messageBody = getMessageBody(tokens);
            final boolean hasVarData = -1 != findSignal(messageBody, Signal.BEGIN_VAR_DATA);
            int i = 0;
            final List<Token> fields = new ArrayList<>();
            i = collectFields(messageBody, i, fields);
            final List<Token> groups = new ArrayList<>();
            i = collectGroups(messageBody, i, groups);
            final List<Token> varData = new ArrayList<>();
            collectVarData(messageBody, i, varData);
            final String decoderClassName = formatClassName(decoderName(msgToken.name()));
            final String decoderStateClassName = decoderClassName + "#CodecStates";
            final FieldPrecedenceModel decoderPrecedenceModel = precedenceChecks.createDecoderModel(
                decoderStateClassName, tokens);
            generateDecoder(decoderClassName, msgToken, fields, groups, varData, hasVarData, decoderPrecedenceModel);
            final String encoderClassName = formatClassName(encoderName(msgToken.name()));
            final String encoderStateClassName = encoderClassName + "#CodecStates";
            final FieldPrecedenceModel encoderPrecedenceModel = precedenceChecks.createEncoderModel(
                encoderStateClassName, tokens);
            generateEncoder(encoderClassName, msgToken, fields, groups, varData, hasVarData, encoderPrecedenceModel);
        }
    }
    private void generateEncoder(
        final String className,
        final Token msgToken,
        final List<Token> fields,
        final List<Token> groups,
        final List<Token> varData,
        final boolean hasVarData,
        final FieldPrecedenceModel fieldPrecedenceModel)
        throws IOException
    {
        final String implementsString = implementsInterface(MessageEncoderFlyweight.class.getSimpleName());
        try (Writer out = outputManager.createOutput(className))
        {
            out.append(generateMainHeader(ir.applicableNamespace(), ENCODER, hasVarData));
            if (shouldGenerateGroupOrderAnnotation)
            {
                generateAnnotations(BASE_INDENT, className, groups, out, JavaUtil::encoderName);
            }
            out.append(generateDeclaration(className, implementsString, msgToken));
            out.append(generateFieldOrderStates(fieldPrecedenceModel));
            out.append(generateEncoderFlyweightCode(className, fieldPrecedenceModel, msgToken));
            final StringBuilder sb = new StringBuilder();
            generateEncoderFields(sb, className, fieldPrecedenceModel, fields, BASE_INDENT);
            generateEncoderGroups(sb, className, fieldPrecedenceModel, groups, BASE_INDENT, false);
            generateEncoderVarData(sb, className, fieldPrecedenceModel, varData, BASE_INDENT);
            generateEncoderDisplay(sb, decoderName(msgToken.name()));
            generateFullyEncodedCheck(sb, fieldPrecedenceModel);
            out.append(sb);
            out.append("}\n");
        }
    }
    private static CharSequence qualifiedStateCase(final FieldPrecedenceModel.State state)
    {
        return "CodecStates." + state.name();
    }
    private static CharSequence stateCaseForSwitchCase(final FieldPrecedenceModel.State state)
    {
        return qualifiedStateCase(state);
    }
    private static CharSequence unqualifiedStateCase(final FieldPrecedenceModel.State state)
    {
        return state.name();
    }
    private CharSequence generateFieldOrderStates(final FieldPrecedenceModel fieldPrecedenceModel)
    {
        if (null == fieldPrecedenceModel)
        {
            return "";
        }
        final StringBuilder sb = new StringBuilder();
        sb.append("    private static final boolean ENABLE_BOUNDS_CHECKS = ")
            .append("!Boolean.getBoolean(\"agrona.disable.bounds.checks\");\n\n");
        sb.append("    private static final boolean ")
            .append(precedenceChecksFlagName).append(" = ")
            .append("Boolean.parseBoolean(System.getProperty(\n")
            .append("        \"").append(precedenceChecksPropName).append("\",\n")
            .append("        Boolean.toString(ENABLE_BOUNDS_CHECKS)));\n\n");
        sb.append("    /**\n");
        sb.append("     * The states in which a encoder/decoder/codec can live.\n");
        sb.append("     *\n");
        sb.append("     * <p>The state machine diagram below, encoded in the dot language, describes\n");
        sb.append("     * the valid state transitions according to the order in which fields may be\n");
        sb.append("     * accessed safely. Tools such as PlantUML and Graphviz can render it.\n");
        sb.append("     *\n");
        sb.append("     * <pre>{@code\n");
        fieldPrecedenceModel.generateGraph(sb, "     *   ");
        sb.append("     * }</pre>\n");
        sb.append("     */\n");
        sb.append("    private static class CodecStates\n")
            .append("    {\n");
        fieldPrecedenceModel.forEachStateOrderedByStateNumber((state) ->
            sb.append("        private static final int ")
            .append(unqualifiedStateCase(state))
            .append(" = ").append(state.number())
            .append(";\n"));
        sb.append("\n").append("        private static final String[] STATE_NAME_LOOKUP =\n")
                .append("        {\n");
        fieldPrecedenceModel.forEachStateOrderedByStateNumber((state) ->
            sb.append("            \"").append(state.name()).append("\",\n"));
        sb.append("        };\n\n");
        sb.append("        private static final String[] STATE_TRANSITIONS_LOOKUP =\n")
                .append("        {\n");
        fieldPrecedenceModel.forEachStateOrderedByStateNumber((state) ->
        {
            sb.append("            \"");
            final MutableBoolean isFirst = new MutableBoolean(true);
            final Set<String> transitionDescriptions = new HashSet<>();
            fieldPrecedenceModel.forEachTransitionFrom(state, (transitionGroup) ->
            {
                if (transitionDescriptions.add(transitionGroup.exampleCode()))
                {
                    if (isFirst.get())
                    {
                        isFirst.set(false);
                    }
                    else
                    {
                        sb.append(", ");
                    }
                    sb.append("\\\"").append(transitionGroup.exampleCode()).append("\\\"");
                }
            });
            sb.append("\",\n");
        });
        sb.append("        };\n\n");
        sb.append("        private static String name(final int state)\n")
            .append("        {\n")
            .append("            return STATE_NAME_LOOKUP[state];\n")
            .append("        }\n\n");
        sb.append("        private static String transitions(final int state)\n")
            .append("        {\n")
            .append("            return STATE_TRANSITIONS_LOOKUP[state];\n")
            .append("        }\n");
        sb.append("    }\n\n");
        sb.append("    private int codecState = ")
            .append(qualifiedStateCase(fieldPrecedenceModel.notWrappedState()))
            .append(";\n\n");
        sb.append("    private int codecState()\n")
            .append("    {\n")
            .append("        return codecState;\n")
            .append("    }\n\n");
        sb.append("    private void codecState(int newState)\n")
            .append("    {\n")
            .append("        codecState = newState;\n")
            .append("    }\n\n");
        return sb;
    }
    private void generateFullyEncodedCheck(
        final StringBuilder sb,
        final FieldPrecedenceModel fieldPrecedenceModel)
    {
        if (null == fieldPrecedenceModel)
        {
            return;
        }
        sb.append("\n");
        sb.append("    public void checkEncodingIsComplete()\n")
            .append("    {\n")
            .append("        if (").append(precedenceChecksFlagName).append(")\n")
            .append("        {\n")
            .append("            switch (codecState)\n")
            .append("            {\n");
        fieldPrecedenceModel.forEachTerminalEncoderState((state) ->
            sb.append("                case ").append(stateCaseForSwitchCase(state)).append(":\n")
            .append("                    return;\n"));
        sb.append("                default:\n")
            .append("                    throw new IllegalStateException(\"Not fully encoded, current state: \" +\n")
            .append("                        CodecStates.name(codecState) + \", allowed transitions: \" +\n")
            .append("                        CodecStates.transitions(codecState));\n")
            .append("            }\n")
            .append("        }\n")
            .append("    }\n\n");
    }
    private static String accessOrderListenerMethodName(final Token token)
    {
        return "on" + Generators.toUpperFirstChar(token.name()) + "Accessed";
    }
    private static String accessOrderListenerMethodName(final Token token, final String suffix)
    {
        return "on" + Generators.toUpperFirstChar(token.name()) + suffix + "Accessed";
    }
    private static void generateAccessOrderListenerMethod(
        final StringBuilder sb,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent,
        final Token token)
    {
        if (null == fieldPrecedenceModel)
        {
            return;
        }
        sb.append("\n")
            .append(indent).append("private void ").append(accessOrderListenerMethodName(token)).append("()\n")
            .append(indent).append("{\n");
        final FieldPrecedenceModel.CodecInteraction fieldAccess =
            fieldPrecedenceModel.interactionFactory().accessField(token);
        generateAccessOrderListener(
            sb,
            indent + "    ",
            "access field",
            fieldPrecedenceModel,
            fieldAccess);
        sb.append(indent).append("}\n");
    }
    private CharSequence generateAccessOrderListenerCall(
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent,
        final Token token,
        final String... arguments)
    {
        return generateAccessOrderListenerCall(
            fieldPrecedenceModel,
            indent,
            accessOrderListenerMethodName(token),
            arguments);
    }
    private CharSequence generateAccessOrderListenerCall(
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent,
        final String methodName,
        final String... arguments)
    {
        if (null == fieldPrecedenceModel)
        {
            return "";
        }
        final StringBuilder sb = new StringBuilder();
        sb.append(indent).append("if (").append(precedenceChecksFlagName).append(")\n")
            .append(indent).append("{\n")
            .append(indent).append("    ").append(methodName).append("(");
        for (int i = 0; i < arguments.length; i++)
        {
            if (i > 0)
            {
                sb.append(", ");
            }
            sb.append(arguments[i]);
        }
        sb.append(");\n");
        sb.append(indent).append("}\n\n");
        return sb;
    }
    private static void generateAccessOrderListenerMethodForGroupWrap(
        final StringBuilder sb,
        final String action,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent,
        final Token token)
    {
        if (null == fieldPrecedenceModel)
        {
            return;
        }
        sb.append("\n")
            .append(indent).append("private void ").append(accessOrderListenerMethodName(token))
            .append("(final int count)\n")
            .append(indent).append("{\n")
            .append(indent).append("    if (count == 0)\n")
            .append(indent).append("    {\n");
        final FieldPrecedenceModel.CodecInteraction selectEmptyGroup =
            fieldPrecedenceModel.interactionFactory().determineGroupIsEmpty(token);
        generateAccessOrderListener(
            sb,
            indent + "        ",
            action + " count of repeating group",
            fieldPrecedenceModel,
            selectEmptyGroup);
        sb.append(indent).append("    }\n")
            .append(indent).append("    else\n")
            .append(indent).append("    {\n");
        final FieldPrecedenceModel.CodecInteraction selectNonEmptyGroup =
            fieldPrecedenceModel.interactionFactory().determineGroupHasElements(token);
        generateAccessOrderListener(
            sb,
            indent + "        ",
            action + " count of repeating group",
            fieldPrecedenceModel,
            selectNonEmptyGroup);
        sb.append(indent).append("    }\n")
            .append(indent).append("}\n");
    }
    private static void generateAccessOrderListener(
        final StringBuilder sb,
        final String indent,
        final String action,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final FieldPrecedenceModel.CodecInteraction interaction)
    {
        if (interaction.isTopLevelBlockFieldAccess())
        {
            sb.append(indent).append("if (codecState() == ")
                .append(qualifiedStateCase(fieldPrecedenceModel.notWrappedState()))
                .append(")\n")
                .append(indent).append("{\n");
            generateAccessOrderException(sb, indent + "    ", action, fieldPrecedenceModel, interaction);
            sb.append(indent).append("}\n");
        }
        else
        {
            sb.append(indent).append("switch (codecState())\n")
                .append(indent).append("{\n");
            fieldPrecedenceModel.forEachTransition(interaction, (transitionGroup) ->
            {
                transitionGroup.forEachStartState((startState) ->
                    sb.append(indent).append("    case ").append(stateCaseForSwitchCase(startState)).append(":\n"));
                sb.append(indent).append("        codecState(")
                    .append(qualifiedStateCase(transitionGroup.endState())).append(");\n")
                    .append(indent).append("        break;\n");
            });
            sb.append(indent).append("    default:\n");
            generateAccessOrderException(sb, indent + "        ", action, fieldPrecedenceModel, interaction);
            sb.append(indent).append("}\n");
        }
    }
    private static void generateAccessOrderException(
        final StringBuilder sb,
        final String indent,
        final String action,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final FieldPrecedenceModel.CodecInteraction interaction)
    {
        sb.append(indent).append("throw new IllegalStateException(")
            .append("\"Illegal field access order. \" +\n")
            .append(indent)
            .append("    \"Cannot ").append(action).append(" \\\"").append(interaction.groupQualifiedName())
            .append("\\\" in state: \" + CodecStates.name(codecState()) +\n")
            .append(indent)
            .append("    \". Expected one of these transitions: [\" + CodecStates.transitions(codecState()) +\n")
            .append(indent)
            .append("    \"]. Please see the diagram in the Javadoc of the class ")
            .append(fieldPrecedenceModel.generatedRepresentationClassName()).append(".\");\n");
    }
    private static void generateAccessOrderListenerMethodForNextGroupElement(
        final StringBuilder sb,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent,
        final Token token)
    {
        if (null == fieldPrecedenceModel)
        {
            return;
        }
        sb.append(indent).append("private void onNextElementAccessed()\n")
            .append(indent).append("{\n")
            .append(indent).append("    final int remaining = ").append("count - index").append(";\n")
            .append(indent).append("    if (remaining > 1)\n")
            .append(indent).append("    {\n");
        final FieldPrecedenceModel.CodecInteraction selectNextElementInGroup =
            fieldPrecedenceModel.interactionFactory().moveToNextElement(token);
        generateAccessOrderListener(
            sb,
            indent + "       ",
            "access next element in repeating group",
            fieldPrecedenceModel,
            selectNextElementInGroup);
        sb.append(indent).append("    }\n")
            .append(indent).append("    else if (remaining == 1)\n")
            .append(indent).append("    {\n");
        final FieldPrecedenceModel.CodecInteraction selectLastElementInGroup =
            fieldPrecedenceModel.interactionFactory().moveToLastElement(token);
        generateAccessOrderListener(
            sb,
            indent + "        ",
            "access next element in repeating group",
            fieldPrecedenceModel,
            selectLastElementInGroup);
        sb.append(indent).append("    }\n")
            .append(indent).append("}\n\n");
    }
    private static void generateAccessOrderListenerMethodForResetGroupCount(
        final StringBuilder sb,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent,
        final Token token)
    {
        if (null == fieldPrecedenceModel)
        {
            return;
        }
        sb.append(indent).append("private void onResetCountToIndex()\n")
            .append(indent).append("{\n");
        final FieldPrecedenceModel.CodecInteraction resetCountToIndex =
            fieldPrecedenceModel.interactionFactory().resetCountToIndex(token);
        generateAccessOrderListener(
            sb,
            indent + "   ",
            "reset count of repeating group",
            fieldPrecedenceModel,
            resetCountToIndex);
        sb.append(indent).append("}\n\n");
    }
    private static void generateAccessOrderListenerMethodForVarDataLength(
        final StringBuilder sb,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent,
        final Token token)
    {
        if (null == fieldPrecedenceModel)
        {
            return;
        }
        sb.append("\n")
            .append(indent).append("void ").append(accessOrderListenerMethodName(token, "Length")).append("()\n")
            .append(indent).append("{\n");
        final FieldPrecedenceModel.CodecInteraction accessLength =
            fieldPrecedenceModel.interactionFactory().accessVarDataLength(token);
        generateAccessOrderListener(
            sb,
            indent + INDENT,
            "decode length of var data",
            fieldPrecedenceModel,
            accessLength);
        sb.append(indent).append("}\n");
    }
    private static CharSequence generateDecoderWrapListener(
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent)
    {
        if (null == fieldPrecedenceModel)
        {
            return "";
        }
        final StringBuilder sb = new StringBuilder();
        sb.append(indent).append("private void onWrap(final int actingVersion)\n")
            .append(indent).append("{\n");
        fieldPrecedenceModel.forEachWrappedStateByVersionDesc((version, state) ->
            sb.append(indent).append("    if (actingVersion >= ").append(version).append(")\n")
            .append(indent).append("    {\n")
            .append(indent).append("        codecState(")
            .append(qualifiedStateCase(state)).append(");\n")
            .append(indent).append("        return;\n")
            .append(indent).append("    }\n\n"));
        sb.append(indent)
            .append("    throw new IllegalStateException(\"Unsupported acting version: \" + actingVersion);\n")
            .append(indent).append("}\n\n");
        return sb;
    }
    private CharSequence generateEncoderWrapListener(
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String indent)
    {
        if (null == fieldPrecedenceModel)
        {
            return "";
        }
        final StringBuilder sb = new StringBuilder();
        sb.append(indent).append("if (").append(precedenceChecksFlagName).append(")")
            .append("\n").append(indent).append("{\n")
            .append(indent).append("    codecState(")
            .append(qualifiedStateCase(fieldPrecedenceModel.latestVersionWrappedState()))
            .append(");\n")
            .append(indent).append("}\n\n");
        return sb;
    }
    private void generateDecoder(
        final String className,
        final Token msgToken,
        final List<Token> fields,
        final List<Token> groups,
        final List<Token> varData,
        final boolean hasVarData,
        final FieldPrecedenceModel fieldPrecedenceModel)
        throws IOException
    {
        final String implementsString = implementsInterface(MessageDecoderFlyweight.class.getSimpleName());
        try (Writer out = outputManager.createOutput(className))
        {
            out.append(generateMainHeader(ir.applicableNamespace(), DECODER, hasVarData));
            if (shouldGenerateGroupOrderAnnotation)
            {
                generateAnnotations(BASE_INDENT, className, groups, out, JavaUtil::decoderName);
            }
            out.append(generateDeclaration(className, implementsString, msgToken));
            out.append(generateFieldOrderStates(fieldPrecedenceModel));
            out.append(generateDecoderFlyweightCode(fieldPrecedenceModel, className, msgToken));
            final StringBuilder sb = new StringBuilder();
            generateDecoderFields(sb, fieldPrecedenceModel, fields, BASE_INDENT);
            generateDecoderGroups(sb, fieldPrecedenceModel, className, groups, BASE_INDENT, false);
            generateDecoderVarData(sb, fieldPrecedenceModel, varData, BASE_INDENT);
            generateDecoderDisplay(sb, msgToken.name(), fields, groups, varData);
            generateMessageLength(sb, className, true, groups, varData, BASE_INDENT);
            out.append(sb);
            out.append("}\n");
        }
    }
    private void generateDecoderGroups(
        final StringBuilder sb,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String outerClassName,
        final List<Token> tokens,
        final String indent,
        final boolean isSubGroup) throws IOException
    {
        for (int i = 0, size = tokens.size(); i < size; i++)
        {
            final Token groupToken = tokens.get(i);
            if (groupToken.signal() != Signal.BEGIN_GROUP)
            {
                throw new IllegalStateException("tokens must begin with BEGIN_GROUP: token=" + groupToken);
            }
            final int index = i;
            final String groupName = decoderName(formatClassName(groupToken.name()));
            ++i;
            final int groupHeaderTokenCount = tokens.get(i).componentTokenCount();
            i += groupHeaderTokenCount;
            final List<Token> fields = new ArrayList<>();
            i = collectFields(tokens, i, fields);
            final List<Token> groups = new ArrayList<>();
            i = collectGroups(tokens, i, groups);
            final List<Token> varData = new ArrayList<>();
            i = collectVarData(tokens, i, varData);
            generateGroupDecoderProperty(sb, groupName, fieldPrecedenceModel, groupToken, indent, isSubGroup);
            generateTypeJavadoc(sb, indent + INDENT, groupToken);
            if (shouldGenerateGroupOrderAnnotation)
            {
                generateAnnotations(indent + INDENT, groupName, groups, sb, JavaUtil::decoderName);
            }
            generateGroupDecoderClassHeader(sb, groupName, outerClassName, fieldPrecedenceModel, groupToken,
                tokens, groups, index, indent + INDENT);
            generateDecoderFields(sb, fieldPrecedenceModel, fields, indent + INDENT);
            generateDecoderGroups(sb, fieldPrecedenceModel, outerClassName, groups, indent + INDENT, true);
            generateDecoderVarData(sb, fieldPrecedenceModel, varData, indent + INDENT);
            appendGroupInstanceDecoderDisplay(sb, fields, groups, varData, indent + INDENT);
            generateMessageLength(sb, groupName, false, groups, varData, indent + INDENT);
            sb.append(indent).append("    }\n");
        }
    }
    private void generateEncoderGroups(
        final StringBuilder sb,
        final String outerClassName,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final List<Token> tokens,
        final String indent,
        final boolean isSubGroup) throws IOException
    {
        for (int i = 0, size = tokens.size(); i < size; i++)
        {
            final Token groupToken = tokens.get(i);
            if (groupToken.signal() != Signal.BEGIN_GROUP)
            {
                throw new IllegalStateException("tokens must begin with BEGIN_GROUP: token=" + groupToken);
            }
            final int index = i;
            final String groupName = groupToken.name();
            final String groupClassName = encoderName(groupName);
            ++i;
            final int groupHeaderTokenCount = tokens.get(i).componentTokenCount();
            i += groupHeaderTokenCount;
            final List<Token> fields = new ArrayList<>();
            i = collectFields(tokens, i, fields);
            final List<Token> groups = new ArrayList<>();
            i = collectGroups(tokens, i, groups);
            final List<Token> varData = new ArrayList<>();
            i = collectVarData(tokens, i, varData);
            generateGroupEncoderProperty(sb, groupName, fieldPrecedenceModel, groupToken, indent, isSubGroup);
            generateTypeJavadoc(sb, indent + INDENT, groupToken);
            if (shouldGenerateGroupOrderAnnotation)
            {
                generateAnnotations(indent + INDENT, groupClassName, groups, sb, JavaUtil::encoderName);
            }
            generateGroupEncoderClassHeader(
                sb, groupName, outerClassName, fieldPrecedenceModel, groupToken,
                tokens, groups, index, indent + INDENT);
            generateEncoderFields(sb, groupClassName, fieldPrecedenceModel, fields, indent + INDENT);
            generateEncoderGroups(sb, outerClassName, fieldPrecedenceModel, groups, indent + INDENT, true);
            generateEncoderVarData(sb, groupClassName, fieldPrecedenceModel, varData, indent + INDENT);
            sb.append(indent).append("    }\n");
        }
    }
    private void generateGroupDecoderClassHeader(
        final StringBuilder sb,
        final String groupName,
        final String parentMessageClassName,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final Token groupToken,
        final List<Token> tokens,
        final List<Token> subGroupTokens,
        final int index,
        final String indent)
    {
        final String className = formatClassName(groupName);
        final int dimensionHeaderLen = tokens.get(index + 1).encodedLength();
        final Token blockLengthToken = Generators.findFirst("blockLength", tokens, index);
        final Token numInGroupToken = Generators.findFirst("numInGroup", tokens, index);
        final PrimitiveType blockLengthType = blockLengthToken.encoding().primitiveType();
        final String blockLengthOffset = "limit + " + blockLengthToken.offset();
        final String blockLengthGet = generateGet(
            blockLengthType, blockLengthOffset, byteOrderString(blockLengthToken.encoding()));
        final PrimitiveType numInGroupType = numInGroupToken.encoding().primitiveType();
        final String numInGroupOffset = "limit + " + numInGroupToken.offset();
        final String numInGroupGet = generateGet(
            numInGroupType, numInGroupOffset, byteOrderString(numInGroupToken.encoding()));
        generateGroupDecoderClassDeclaration(
            sb,
            groupName,
            parentMessageClassName,
            findSubGroupNames(subGroupTokens),
            indent,
            dimensionHeaderLen);
        final String blockLenCast = PrimitiveType.UINT32 == blockLengthType ? "(int)" : "";
        final String numInGroupCast = PrimitiveType.UINT32 == numInGroupType ? "(int)" : "";
        sb.append("\n")
            .append(indent).append("    public void wrap(final ").append(readOnlyBuffer).append(" buffer)\n")
            .append(indent).append("    {\n")
            .append(indent).append("        if (buffer != this.buffer)\n")
            .append(indent).append("        {\n")
            .append(indent).append("            this.buffer = buffer;\n")
            .append(indent).append("        }\n\n")
            .append(indent).append("        index = 0;\n")
            .append(indent).append("        final int limit = parentMessage.limit();\n")
            .append(indent).append("        parentMessage.limit(limit + HEADER_SIZE);\n")
            .append(indent).append("        blockLength = ").append(blockLenCast).append(blockLengthGet).append(";\n")
            .append(indent).append("        count = ").append(numInGroupCast).append(numInGroupGet).append(";\n")
            .append(indent).append("    }\n\n");
        generateAccessOrderListenerMethodForNextGroupElement(sb, fieldPrecedenceModel, indent + "    ", groupToken);
        sb.append(indent).append("    public ").append(className).append(" next()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        if (index >= count)\n")
            .append(indent).append("        {\n")
            .append(indent).append("            throw new java.util.NoSuchElementException();\n")
            .append(indent).append("        }\n\n")
            .append(generateAccessOrderListenerCall(fieldPrecedenceModel, indent + "        ", "onNextElementAccessed"))
            .append(indent).append("        offset = parentMessage.limit();\n")
            .append(indent).append("        parentMessage.limit(offset + blockLength);\n")
            .append(indent).append("        ++index;\n\n")
            .append(indent).append("        return this;\n")
            .append(indent).append("    }\n");
        final String numInGroupJavaTypeName = javaTypeName(numInGroupType);
        final String numInGroupMinValue = generateLiteral(
            numInGroupType, numInGroupToken.encoding().applicableMinValue().toString());
        generatePrimitiveFieldMetaMethod(sb, indent, numInGroupJavaTypeName, "count", "Min", numInGroupMinValue);
        final String numInGroupMaxValue = generateLiteral(
            numInGroupType, numInGroupToken.encoding().applicableMaxValue().toString());
        generatePrimitiveFieldMetaMethod(sb, indent, numInGroupJavaTypeName, "count", "Max", numInGroupMaxValue);
        sb.append("\n")
            .append(indent).append("    public static int sbeHeaderSize()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return HEADER_SIZE;\n")
            .append(indent).append("    }\n");
        sb.append("\n")
            .append(indent).append("    public static int sbeBlockLength()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return ").append(tokens.get(index).encodedLength()).append(";\n")
            .append(indent).append("    }\n");
        sb.append("\n")
            .append(indent).append("    public int actingBlockLength()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return blockLength;\n")
            .append(indent).append("    }\n\n")
            .append(indent).append("    public int actingVersion()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return parentMessage.actingVersion;\n")
            .append(indent).append("    }\n\n")
            .append(indent).append("    public int count()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return count;\n")
            .append(indent).append("    }\n\n")
            .append(indent).append("    public java.util.Iterator<").append(className).append("> iterator()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return this;\n")
            .append(indent).append("    }\n\n")
            .append(indent).append("    public void remove()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        throw new UnsupportedOperationException();\n")
            .append(indent).append("    }\n\n")
            .append(indent).append("    public boolean hasNext()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return index < count;\n")
            .append(indent).append("    }\n");
        if (null != fieldPrecedenceModel)
        {
            sb.append("\n")
                .append(indent).append("    private int codecState()\n")
                .append(indent).append("    {\n")
                .append(indent).append("        return parentMessage.codecState();\n")
                .append(indent).append("    }\n");
            sb.append("\n")
                .append(indent).append("    private void codecState(final int newState)\n")
                .append(indent).append("    {\n")
                .append(indent).append("        parentMessage.codecState(newState);\n")
                .append(indent).append("    }\n");
        }
    }
    private void generateGroupEncoderClassHeader(
        final StringBuilder sb,
        final String groupName,
        final String parentMessageClassName,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final Token groupToken,
        final List<Token> tokens,
        final List<Token> subGroupTokens,
        final int index,
        final String ind)
    {
        final int dimensionHeaderSize = tokens.get(index + 1).encodedLength();
        generateGroupEncoderClassDeclaration(
            sb,
            groupName,
            parentMessageClassName,
            findSubGroupNames(subGroupTokens),
            ind,
            dimensionHeaderSize);
        final int blockLength = tokens.get(index).encodedLength();
        final Token blockLengthToken = Generators.findFirst("blockLength", tokens, index);
        final Token numInGroupToken = Generators.findFirst("numInGroup", tokens, index);
        final PrimitiveType blockLengthType = blockLengthToken.encoding().primitiveType();
        final String blockLengthOffset = "limit + " + blockLengthToken.offset();
        final String blockLengthValue = Integer.toString(blockLength);
        final String blockLengthPut = generatePut(
            blockLengthType, blockLengthOffset, blockLengthValue, byteOrderString(blockLengthToken.encoding()));
        final PrimitiveType numInGroupType = numInGroupToken.encoding().primitiveType();
        final PrimitiveType numInGroupTypeCast = PrimitiveType.UINT32 == numInGroupType ?
            PrimitiveType.INT32 : numInGroupType;
        final String numInGroupOffset = "limit + " + numInGroupToken.offset();
        final String numInGroupValue = "count";
        final String numInGroupPut = generatePut(
            numInGroupTypeCast, numInGroupOffset, numInGroupValue, byteOrderString(numInGroupToken.encoding()));
        new Formatter(sb).format("\n" +
            ind + "    public void wrap(final %2$s buffer, final int count)\n" +
            ind + "    {\n" +
            ind + "        if (count < %3$d || count > %4$d)\n" +
            ind + "        {\n" +
            ind + "            throw new IllegalArgumentException(\"count outside allowed range: count=\" + count);\n" +
            ind + "        }\n\n" +
            ind + "        if (buffer != this.buffer)\n" +
            ind + "        {\n" +
            ind + "            this.buffer = buffer;\n" +
            ind + "        }\n\n" +
            ind + "        index = 0;\n" +
            ind + "        this.count = count;\n" +
            ind + "        final int limit = parentMessage.limit();\n" +
            ind + "        initialLimit = limit;\n" +
            ind + "        parentMessage.limit(limit + HEADER_SIZE);\n" +
            ind + "        %5$s;\n" +
            ind + "        %6$s;\n" +
            ind + "    }\n\n",
            parentMessageClassName,
            mutableBuffer,
            numInGroupToken.encoding().applicableMinValue().longValue(),
            numInGroupToken.encoding().applicableMaxValue().longValue(),
            blockLengthPut,
            numInGroupPut);
        generateAccessOrderListenerMethodForNextGroupElement(sb, fieldPrecedenceModel, ind + "    ", groupToken);
        generateAccessOrderListenerMethodForResetGroupCount(sb, fieldPrecedenceModel, ind + "    ", groupToken);
        sb.append(ind).append("    public ").append(encoderName(groupName)).append(" next()\n")
            .append(ind).append("    {\n")
            .append(generateAccessOrderListenerCall(fieldPrecedenceModel, ind + "        ", "onNextElementAccessed"))
            .append(ind).append("        if (index >= count)\n")
            .append(ind).append("        {\n")
            .append(ind).append("            throw new java.util.NoSuchElementException();\n")
            .append(ind).append("        }\n\n")
            .append(ind).append("        offset = parentMessage.limit();\n")
            .append(ind).append("        parentMessage.limit(offset + sbeBlockLength());\n")
            .append(ind).append("        ++index;\n\n")
            .append(ind).append("        return this;\n")
            .append(ind).append("    }\n\n");
        final String countOffset = "initialLimit + " + numInGroupToken.offset();
        final String resetCountPut = generatePut(
            numInGroupTypeCast, countOffset, numInGroupValue, byteOrderString(numInGroupToken.encoding()));
        sb.append(ind).append("    public int resetCountToIndex()\n")
            .append(ind).append("    {\n")
            .append(generateAccessOrderListenerCall(fieldPrecedenceModel, ind + "        ", "onResetCountToIndex"))
            .append(ind).append("        count = index;\n")
            .append(ind).append("        ").append(resetCountPut).append(";\n\n")
            .append(ind).append("        return count;\n")
            .append(ind).append("    }\n");
        final String numInGroupJavaTypeName = javaTypeName(numInGroupType);
        final String numInGroupMinValue = generateLiteral(
            numInGroupType, numInGroupToken.encoding().applicableMinValue().toString());
        generatePrimitiveFieldMetaMethod(sb, ind, numInGroupJavaTypeName, "count", "Min", numInGroupMinValue);
        final String numInGroupMaxValue = generateLiteral(
            numInGroupType, numInGroupToken.encoding().applicableMaxValue().toString());
        generatePrimitiveFieldMetaMethod(sb, ind, numInGroupJavaTypeName, "count", "Max", numInGroupMaxValue);
        sb.append("\n")
            .append(ind).append("    public static int sbeHeaderSize()\n")
            .append(ind).append("    {\n")
            .append(ind).append("        return HEADER_SIZE;\n")
            .append(ind).append("    }\n");
        sb.append("\n")
            .append(ind).append("    public static int sbeBlockLength()\n")
            .append(ind).append("    {\n")
            .append(ind).append("        return ").append(blockLength).append(";\n")
            .append(ind).append("    }\n");
        if (null != fieldPrecedenceModel)
        {
            sb.append("\n")
                .append(ind).append("    private int codecState()\n")
                .append(ind).append("    {\n")
                .append(ind).append("        return parentMessage.codecState();\n")
                .append(ind).append("    }\n");
            sb.append("\n")
                .append(ind).append("    private void codecState(final int newState)\n")
                .append(ind).append("    {\n")
                .append(ind).append("        parentMessage.codecState(newState);\n")
                .append(ind).append("    }\n");
        }
    }
    private static String primitiveTypeName(final Token token)
    {
        return javaTypeName(token.encoding().primitiveType());
    }
    private void generateGroupDecoderClassDeclaration(
        final StringBuilder sb,
        final String groupName,
        final String parentMessageClassName,
        final List<String> subGroupNames,
        final String indent,
        final int dimensionHeaderSize)
    {
        final String className = formatClassName(groupName);
        new Formatter(sb).format("\n" +
            indent + "public static final class %1$s\n" +
            indent + "    implements Iterable<%1$s>, java.util.Iterator<%1$s>\n" +
            indent + "{\n" +
            indent + "    public static final int HEADER_SIZE = %2$d;\n" +
            indent + "    private final %3$s parentMessage;\n" +
            indent + "    private %4$s buffer;\n" +
            indent + "    private int count;\n" +
            indent + "    private int index;\n" +
            indent + "    private int offset;\n" +
            indent + "    private int blockLength;\n",
            className,
            dimensionHeaderSize,
            parentMessageClassName,
            readOnlyBuffer);
        for (final String subGroupName : subGroupNames)
        {
            final String type = formatClassName(decoderName(subGroupName));
            final String field = formatPropertyName(subGroupName);
            sb.append(indent).append("    private final ").append(type).append(" ").append(field).append(";\n");
        }
        sb
            .append("\n")
            .append(indent).append("    ")
            .append(className).append("(final ").append(parentMessageClassName).append(" parentMessage)\n")
            .append(indent).append("    {\n")
            .append(indent).append("        this.parentMessage = parentMessage;\n");
        for (final String subGroupName : subGroupNames)
        {
            final String type = formatClassName(decoderName(subGroupName));
            final String field = formatPropertyName(subGroupName);
            sb
                .append(indent).append("        ")
                .append(field).append(" = new ").append(type).append("(parentMessage);\n");
        }
        sb.append(indent).append("    }\n");
    }
    private void generateGroupEncoderClassDeclaration(
        final StringBuilder sb,
        final String groupName,
        final String parentMessageClassName,
        final List<String> subGroupNames,
        final String indent,
        final int dimensionHeaderSize)
    {
        final String className = encoderName(groupName);
        new Formatter(sb).format("\n" +
            indent + "public static final class %1$s\n" +
            indent + "{\n" +
            indent + "    public static final int HEADER_SIZE = %2$d;\n" +
            indent + "    private final %3$s parentMessage;\n" +
            indent + "    private %4$s buffer;\n" +
            indent + "    private int count;\n" +
            indent + "    private int index;\n" +
            indent + "    private int offset;\n" +
            indent + "    private int initialLimit;\n",
            className,
            dimensionHeaderSize,
            parentMessageClassName,
            mutableBuffer);
        for (final String subGroupName : subGroupNames)
        {
            final String type = encoderName(subGroupName);
            final String field = formatPropertyName(subGroupName);
            sb.append(indent).append("    private final ").append(type).append(" ").append(field).append(";\n");
        }
        sb
            .append("\n")
            .append(indent).append("    ")
            .append(className).append("(final ").append(parentMessageClassName).append(" parentMessage)\n")
            .append(indent).append("    {\n")
            .append(indent).append("        this.parentMessage = parentMessage;\n");
        for (final String subGroupName : subGroupNames)
        {
            final String type = encoderName(subGroupName);
            final String field = formatPropertyName(subGroupName);
            sb
                .append(indent).append("        ")
                .append(field).append(" = new ").append(type).append("(parentMessage);\n");
        }
        sb.append(indent).append("    }\n");
    }
    private void generateGroupDecoderProperty(
        final StringBuilder sb,
        final String groupName,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final Token token,
        final String indent,
        final boolean isSubGroup)
    {
        final String className = formatClassName(groupName);
        final String propertyName = formatPropertyName(token.name());
        if (!isSubGroup)
        {
            new Formatter(sb).format("\n" +
                indent + "    private final %s %s = new %s(this);\n",
                className,
                propertyName,
                className);
        }
        new Formatter(sb).format("\n" +
            indent + "    public static long %sId()\n" +
            indent + "    {\n" +
            indent + "        return %d;\n" +
            indent + "    }\n",
            formatPropertyName(groupName),
            token.id());
        new Formatter(sb).format("\n" +
            indent + "    public static int %sSinceVersion()\n" +
            indent + "    {\n" +
            indent + "        return %d;\n" +
            indent + "    }\n",
            formatPropertyName(groupName),
            token.version());
        final String actingVersionGuard = token.version() == 0 ?
            "" :
            indent + "        if (parentMessage.actingVersion < " + token.version() + ")\n" +
            indent + "        {\n" +
            indent + "            " + propertyName + ".count = 0;\n" +
            indent + "            " + propertyName + ".index = 0;\n" +
            indent + "            return " + propertyName + ";\n" +
            indent + "        }\n\n";
        generateAccessOrderListenerMethodForGroupWrap(sb, "decode", fieldPrecedenceModel, indent + "    ", token);
        generateFlyweightPropertyJavadoc(sb, indent + INDENT, token, className);
        new Formatter(sb).format("\n" +
            indent + "    public %1$s %2$s()\n" +
            indent + "    {\n" +
            "%3$s" +
            indent + "        %2$s.wrap(buffer);\n" +
            "%4$s" +
            indent + "        return %2$s;\n" +
            indent + "    }\n",
            className,
            propertyName,
            actingVersionGuard,
            generateAccessOrderListenerCall(fieldPrecedenceModel, indent + "        ", token, propertyName + ".count"));
    }
    private void generateGroupEncoderProperty(
        final StringBuilder sb,
        final String groupName,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final Token token,
        final String indent,
        final boolean isSubGroup)
    {
        final String className = formatClassName(encoderName(groupName));
        final String propertyName = formatPropertyName(groupName);
        if (!isSubGroup)
        {
            new Formatter(sb).format("\n" +
                indent + "    private final %s %s = new %s(this);\n",
                className,
                propertyName,
                className);
        }
        new Formatter(sb).format("\n" +
            indent + "    public static long %sId()\n" +
            indent + "    {\n" +
            indent + "        return %d;\n" +
            indent + "    }\n",
            formatPropertyName(groupName),
            token.id());
        generateAccessOrderListenerMethodForGroupWrap(sb, "encode", fieldPrecedenceModel, indent + "    ", token);
        generateGroupEncodePropertyJavadoc(sb, indent + INDENT, token, className);
        new Formatter(sb).format("\n" +
            indent + "    public %1$s %2$sCount(final int count)\n" +
            indent + "    {\n" +
            "%3$s" +
            indent + "        %2$s.wrap(buffer, count);\n" +
            indent + "        return %2$s;\n" +
            indent + "    }\n",
            className,
            propertyName,
            generateAccessOrderListenerCall(fieldPrecedenceModel, indent + "        ", token, "count"));
    }
    private void generateDecoderVarData(
        final StringBuilder sb,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final List<Token> tokens,
        final String indent)
    {
        for (int i = 0, size = tokens.size(); i < size;)
        {
            final Token token = tokens.get(i);
            if (token.signal() != Signal.BEGIN_VAR_DATA)
            {
                throw new IllegalStateException("tokens must begin with BEGIN_VAR_DATA: token=" + token);
            }
            generateFieldIdMethod(sb, token, indent);
            generateFieldSinceVersionMethod(sb, token, indent);
            final String characterEncoding = tokens.get(i + 3).encoding().characterEncoding();
            generateCharacterEncodingMethod(sb, token.name(), characterEncoding, indent);
            generateFieldMetaAttributeMethod(sb, token, indent);
            final String propertyName = Generators.toUpperFirstChar(token.name());
            final Token lengthToken = tokens.get(i + 2);
            final int sizeOfLengthField = lengthToken.encodedLength();
            final Encoding lengthEncoding = lengthToken.encoding();
            final PrimitiveType lengthType = lengthEncoding.primitiveType();
            final String byteOrderStr = byteOrderString(lengthEncoding);
            final String methodPropName = Generators.toLowerFirstChar(propertyName);
            sb.append("\n")
                .append(indent).append("    public static int ").append(methodPropName).append("HeaderLength()\n")
                .append(indent).append("    {\n")
                .append(indent).append("        return ").append(sizeOfLengthField).append(";\n")
                .append(indent).append("    }\n");
            generateAccessOrderListenerMethodForVarDataLength(sb, fieldPrecedenceModel, indent + "    ", token);
            final CharSequence lengthAccessOrderListenerCall = generateAccessOrderListenerCall(
                fieldPrecedenceModel, indent + "        ", accessOrderListenerMethodName(token, "Length"));
            generateAccessOrderListenerMethod(sb, fieldPrecedenceModel, indent + "    ", token);
            sb.append("\n")
                .append(indent).append("    public int ").append(methodPropName).append("Length()\n")
                .append(indent).append("    {\n")
                .append(generateArrayFieldNotPresentCondition(false, token.version(), indent))
                .append(lengthAccessOrderListenerCall)
                .append(indent).append("        final int limit = parentMessage.limit();\n")
                .append(indent).append("        return ").append(PrimitiveType.UINT32 == lengthType ? "(int)" : "")
                .append(generateGet(lengthType, "limit", byteOrderStr)).append(";\n")
                .append(indent).append("    }\n");
            final CharSequence accessOrderListenerCall =
                generateAccessOrderListenerCall(fieldPrecedenceModel, indent + "        ", token);
            generateDataDecodeMethods(sb, token, propertyName, sizeOfLengthField, lengthType,
                byteOrderStr, characterEncoding, accessOrderListenerCall, indent);
            i += token.componentTokenCount();
        }
    }
    private void generateEncoderVarData(
        final StringBuilder sb,
        final String className,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final List<Token> tokens,
        final String indent)
    {
        for (int i = 0, size = tokens.size(); i < size;)
        {
            final Token token = tokens.get(i);
            if (token.signal() != Signal.BEGIN_VAR_DATA)
            {
                throw new IllegalStateException("tokens must begin with BEGIN_VAR_DATA: token=" + token);
            }
            generateFieldIdMethod(sb, token, indent);
            final Token varDataToken = Generators.findFirst("varData", tokens, i);
            final String characterEncoding = varDataToken.encoding().characterEncoding();
            generateCharacterEncodingMethod(sb, token.name(), characterEncoding, indent);
            generateFieldMetaAttributeMethod(sb, token, indent);
            final String propertyName = Generators.toUpperFirstChar(token.name());
            final Token lengthToken = Generators.findFirst("length", tokens, i);
            final int sizeOfLengthField = lengthToken.encodedLength();
            final Encoding lengthEncoding = lengthToken.encoding();
            final int maxLengthValue = (int)lengthEncoding.applicableMaxValue().longValue();
            final String byteOrderStr = byteOrderString(lengthEncoding);
            final String methodPropName = Generators.toLowerFirstChar(propertyName);
            sb.append("\n")
                .append(indent).append("    public static int ").append(methodPropName).append("HeaderLength()\n")
                .append(indent).append("    {\n")
                .append(indent).append("        return ")
                .append(sizeOfLengthField).append(";\n")
                .append(indent).append("    }\n");
            generateAccessOrderListenerMethod(sb, fieldPrecedenceModel, indent + "    ", token);
            final CharSequence accessOrderListenerCall =
                generateAccessOrderListenerCall(fieldPrecedenceModel, indent + "        ", token);
            generateDataEncodeMethods(
                sb,
                propertyName,
                accessOrderListenerCall,
                sizeOfLengthField,
                maxLengthValue,
                lengthEncoding.primitiveType(),
                byteOrderStr,
                characterEncoding,
                className,
                indent);
            i += token.componentTokenCount();
        }
    }
    private void generateDataDecodeMethods(
        final StringBuilder sb,
        final Token token,
        final String propertyName,
        final int sizeOfLengthField,
        final PrimitiveType lengthType,
        final String byteOrderStr,
        final String characterEncoding,
        final CharSequence accessOrderListenerCall,
        final String indent)
    {
        new Formatter(sb).format("\n" +
            indent + "    public int skip%1$s()\n" +
            indent + "    {\n" +
            "%2$s" +
            "%6$s" +
            indent + "        final int headerLength = %3$d;\n" +
            indent + "        final int limit = parentMessage.limit();\n" +
            indent + "        final int dataLength = %4$s%5$s;\n" +
            indent + "        final int dataOffset = limit + headerLength;\n" +
            indent + "        parentMessage.limit(dataOffset + dataLength);\n\n" +
            indent + "        return dataLength;\n" +
            indent + "    }\n",
            Generators.toUpperFirstChar(propertyName),
            generateStringNotPresentConditionForAppendable(false, token.version(), indent),
            sizeOfLengthField,
            PrimitiveType.UINT32 == lengthType ? "(int)" : "",
            generateGet(lengthType, "limit", byteOrderStr),
            accessOrderListenerCall);
        generateVarDataTypedDecoder(
            sb,
            token,
            propertyName,
            sizeOfLengthField,
            mutableBuffer,
            lengthType,
            byteOrderStr,
            accessOrderListenerCall,
            indent);
        generateVarDataTypedDecoder(
            sb,
            token,
            propertyName,
            sizeOfLengthField,
            "byte[]",
            lengthType,
            byteOrderStr,
            accessOrderListenerCall,
            indent);
        generateVarDataWrapDecoder(
            sb,
            token,
            propertyName,
            sizeOfLengthField,
            lengthType,
            byteOrderStr,
            accessOrderListenerCall,
            indent);
        if (null != characterEncoding)
        {
            new Formatter(sb).format("\n" +
                indent + "    public String %1$s()\n" +
                indent + "    {\n" +
                "%2$s" +
                "%7$s" +
                indent + "        final int headerLength = %3$d;\n" +
                indent + "        final int limit = parentMessage.limit();\n" +
                indent + "        final int dataLength = %4$s%5$s;\n" +
                indent + "        parentMessage.limit(limit + headerLength + dataLength);\n\n" +
                indent + "        if (0 == dataLength)\n" +
                indent + "        {\n" +
                indent + "            return \"\";\n" +
                indent + "        }\n\n" +
                indent + "        final byte[] tmp = new byte[dataLength];\n" +
                indent + "        buffer.getBytes(limit + headerLength, tmp, 0, dataLength);\n\n" +
                indent + "        return new String(tmp, %6$s);\n" +
                indent + "    }\n",
                formatPropertyName(propertyName),
                generateStringNotPresentCondition(false, token.version(), indent),
                sizeOfLengthField,
                PrimitiveType.UINT32 == lengthType ? "(int)" : "",
                generateGet(lengthType, "limit", byteOrderStr),
                charset(characterEncoding),
                accessOrderListenerCall);
            if (isAsciiEncoding(characterEncoding))
            {
                new Formatter(sb).format("\n" +
                    indent + "    public int get%1$s(final Appendable appendable)\n" +
                    indent + "    {\n" +
                    "%2$s" +
                    "%6$s" +
                    indent + "        final int headerLength = %3$d;\n" +
                    indent + "        final int limit = parentMessage.limit();\n" +
                    indent + "        final int dataLength = %4$s%5$s;\n" +
                    indent + "        final int dataOffset = limit + headerLength;\n\n" +
                    indent + "        parentMessage.limit(dataOffset + dataLength);\n" +
                    indent + "        buffer.getStringWithoutLengthAscii(dataOffset, dataLength, appendable);\n\n" +
                    indent + "        return dataLength;\n" +
                    indent + "    }\n",
                    Generators.toUpperFirstChar(propertyName),
                    generateStringNotPresentConditionForAppendable(false, token.version(), indent),
                    sizeOfLengthField,
                    PrimitiveType.UINT32 == lengthType ? "(int)" : "",
                    generateGet(lengthType, "limit", byteOrderStr),
                    accessOrderListenerCall);
            }
        }
    }
    private void generateVarDataWrapDecoder(
        final StringBuilder sb,
        final Token token,
        final String propertyName,
        final int sizeOfLengthField,
        final PrimitiveType lengthType,
        final String byteOrderStr,
        final CharSequence accessOrderListenerCall,
        final String indent)
    {
        new Formatter(sb).format("\n" +
            indent + "    public void wrap%s(final %s wrapBuffer)\n" +
            indent + "    {\n" +
            "%s" +
            "%s" +
            indent + "        final int headerLength = %d;\n" +
            indent + "        final int limit = parentMessage.limit();\n" +
            indent + "        final int dataLength = %s%s;\n" +
            indent + "        parentMessage.limit(limit + headerLength + dataLength);\n" +
            indent + "        wrapBuffer.wrap(buffer, limit + headerLength, dataLength);\n" +
            indent + "    }\n",
            propertyName,
            readOnlyBuffer,
            generateWrapFieldNotPresentCondition(false, token.version(), indent),
            accessOrderListenerCall,
            sizeOfLengthField,
            PrimitiveType.UINT32 == lengthType ? "(int)" : "",
            generateGet(lengthType, "limit", byteOrderStr));
    }
    private void generateDataEncodeMethods(
        final StringBuilder sb,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final int sizeOfLengthField,
        final int maxLengthValue,
        final PrimitiveType lengthType,
        final String byteOrderStr,
        final String characterEncoding,
        final String className,
        final String indent)
    {
        generateDataTypedEncoder(
            sb,
            className,
            propertyName,
            accessOrderListenerCall,
            sizeOfLengthField,
            maxLengthValue,
            readOnlyBuffer,
            lengthType,
            byteOrderStr,
            indent);
        generateDataTypedEncoder(
            sb,
            className,
            propertyName,
            accessOrderListenerCall,
            sizeOfLengthField,
            maxLengthValue,
            "byte[]",
            lengthType,
            byteOrderStr,
            indent);
        if (null != characterEncoding)
        {
            generateCharArrayEncodeMethods(
                sb,
                propertyName,
                accessOrderListenerCall,
                sizeOfLengthField,
                maxLengthValue,
                lengthType,
                byteOrderStr,
                characterEncoding,
                className,
                indent);
        }
    }
    private void generateCharArrayEncodeMethods(
        final StringBuilder sb,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final int sizeOfLengthField,
        final int maxLengthValue,
        final PrimitiveType lengthType,
        final String byteOrderStr,
        final String characterEncoding,
        final String className,
        final String indent)
    {
        final PrimitiveType lengthPutType = PrimitiveType.UINT32 == lengthType ? PrimitiveType.INT32 : lengthType;
        if (isAsciiEncoding(characterEncoding))
        {
            new Formatter(sb).format("\n" +
                indent + "    public %1$s %2$s(final String value)\n" +
                indent + "    {\n" +
                indent + "        final int length = null == value ? 0 : value.length();\n" +
                indent + "        if (length > %3$d)\n" +
                indent + "        {\n" +
                indent + "            throw new IllegalStateException(\"length > maxValue for type: \" + length);\n" +
                indent + "        }\n\n" +
                "%6$s" +
                indent + "        final int headerLength = %4$d;\n" +
                indent + "        final int limit = parentMessage.limit();\n" +
                indent + "        parentMessage.limit(limit + headerLength + length);\n" +
                indent + "        %5$s;\n" +
                indent + "        buffer.putStringWithoutLengthAscii(limit + headerLength, value);\n\n" +
                indent + "        return this;\n" +
                indent + "    }\n",
                className,
                formatPropertyName(propertyName),
                maxLengthValue,
                sizeOfLengthField,
                generatePut(lengthPutType, "limit", "length", byteOrderStr),
                accessOrderListenerCall);
            new Formatter(sb).format("\n" +
                indent + "    public %1$s %2$s(final CharSequence value)\n" +
                indent + "    {\n" +
                indent + "        final int length = null == value ? 0 : value.length();\n" +
                indent + "        if (length > %3$d)\n" +
                indent + "        {\n" +
                indent + "            throw new IllegalStateException(\"length > maxValue for type: \" + length);\n" +
                indent + "        }\n\n" +
                "%6$s" +
                indent + "        final int headerLength = %4$d;\n" +
                indent + "        final int limit = parentMessage.limit();\n" +
                indent + "        parentMessage.limit(limit + headerLength + length);\n" +
                indent + "        %5$s;\n" +
                indent + "        buffer.putStringWithoutLengthAscii(limit + headerLength, value);\n\n" +
                indent + "        return this;\n" +
                indent + "    }\n",
                className,
                formatPropertyName(propertyName),
                maxLengthValue,
                sizeOfLengthField,
                generatePut(lengthPutType, "limit", "length", byteOrderStr),
                accessOrderListenerCall);
        }
        else
        {
            new Formatter(sb).format("\n" +
                indent + "    public %1$s %2$s(final String value)\n" +
                indent + "    {\n" +
                indent + "        final byte[] bytes = (null == value || value.isEmpty()) ?" +
                " org.agrona.collections.ArrayUtil.EMPTY_BYTE_ARRAY : value.getBytes(%3$s);\n\n" +
                indent + "        final int length = bytes.length;\n" +
                indent + "        if (length > %4$d)\n" +
                indent + "        {\n" +
                indent + "            throw new IllegalStateException(\"length > maxValue for type: \" + length);\n" +
                indent + "        }\n\n" +
                "%7$s" +
                indent + "        final int headerLength = %5$d;\n" +
                indent + "        final int limit = parentMessage.limit();\n" +
                indent + "        parentMessage.limit(limit + headerLength + length);\n" +
                indent + "        %6$s;\n" +
                indent + "        buffer.putBytes(limit + headerLength, bytes, 0, length);\n\n" +
                indent + "        return this;\n" +
                indent + "    }\n",
                className,
                formatPropertyName(propertyName),
                charset(characterEncoding),
                maxLengthValue,
                sizeOfLengthField,
                generatePut(lengthPutType, "limit", "length", byteOrderStr),
                accessOrderListenerCall);
        }
    }
    private void generateVarDataTypedDecoder(
        final StringBuilder sb,
        final Token token,
        final String propertyName,
        final int sizeOfLengthField,
        final String exchangeType,
        final PrimitiveType lengthType,
        final String byteOrderStr,
        final CharSequence accessOrderListenerCall,
        final String indent)
    {
        new Formatter(sb).format("\n" +
            indent + "    public int get%s(final %s dst, final int dstOffset, final int length)\n" +
            indent + "    {\n" +
            "%s" +
            "%s" +
            indent + "        final int headerLength = %d;\n" +
            indent + "        final int limit = parentMessage.limit();\n" +
            indent + "        final int dataLength = %s%s;\n" +
            indent + "        final int bytesCopied = Math.min(length, dataLength);\n" +
            indent + "        parentMessage.limit(limit + headerLength + dataLength);\n" +
            indent + "        buffer.getBytes(limit + headerLength, dst, dstOffset, bytesCopied);\n\n" +
            indent + "        return bytesCopied;\n" +
            indent + "    }\n",
            propertyName,
            exchangeType,
            generateArrayFieldNotPresentCondition(false, token.version(), indent),
            accessOrderListenerCall,
            sizeOfLengthField,
            PrimitiveType.UINT32 == lengthType ? "(int)" : "",
            generateGet(lengthType, "limit", byteOrderStr));
    }
    private void generateDataTypedEncoder(
        final StringBuilder sb,
        final String className,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final int sizeOfLengthField,
        final int maxLengthValue,
        final String exchangeType,
        final PrimitiveType lengthType,
        final String byteOrderStr,
        final String indent)
    {
        final PrimitiveType lengthPutType = PrimitiveType.UINT32 == lengthType ? PrimitiveType.INT32 : lengthType;
        new Formatter(sb).format("\n" +
            indent + "    public %1$s put%2$s(final %3$s src, final int srcOffset, final int length)\n" +
            indent + "    {\n" +
            indent + "        if (length > %4$d)\n" +
            indent + "        {\n" +
            indent + "            throw new IllegalStateException(\"length > maxValue for type: \" + length);\n" +
            indent + "        }\n\n" +
            "%7$s" +
            indent + "        final int headerLength = %5$d;\n" +
            indent + "        final int limit = parentMessage.limit();\n" +
            indent + "        parentMessage.limit(limit + headerLength + length);\n" +
            indent + "        %6$s;\n" +
            indent + "        buffer.putBytes(limit + headerLength, src, srcOffset, length);\n\n" +
            indent + "        return this;\n" +
            indent + "    }\n",
            className,
            propertyName,
            exchangeType,
            maxLengthValue,
            sizeOfLengthField,
            generatePut(lengthPutType, "limit", "length", byteOrderStr),
            accessOrderListenerCall);
    }
    private void generateBitSet(final List<Token> tokens) throws IOException
    {
        final Token token = tokens.get(0);
        final String bitSetName = token.applicableTypeName();
        final String decoderName = decoderName(bitSetName);
        final String encoderName = encoderName(bitSetName);
        final List<Token> choiceList = tokens.subList(1, tokens.size() - 1);
        final String implementsString = implementsInterface(Flyweight.class.getSimpleName());
        registerTypesPackageName(token, ir);
        try (Writer out = outputManager.createOutput(decoderName))
        {
            final Encoding encoding = token.encoding();
            generateFixedFlyweightHeader(
                out, token, decoderName, implementsString, readOnlyBuffer, fqReadOnlyBuffer, PACKAGES_EMPTY_SET);
            out.append(generateChoiceIsEmpty(encoding.primitiveType()));
            new Formatter(out).format(
                "\n" +
                "    public %s getRaw()\n" +
                "    {\n" +
                "        return %s;\n" +
                "    }\n",
                primitiveTypeName(token),
                generateGet(encoding.primitiveType(), "offset", byteOrderString(encoding)));
            generateChoiceDecoders(out, choiceList);
            out.append(generateChoiceDisplay(choiceList));
            out.append("}\n");
        }
        registerTypesPackageName(token, ir);
        try (Writer out = outputManager.createOutput(encoderName))
        {
            generateFixedFlyweightHeader(
                out, token, encoderName, implementsString, mutableBuffer, fqMutableBuffer, PACKAGES_EMPTY_SET);
            generateChoiceClear(out, encoderName, token);
            generateChoiceEncoders(out, encoderName, choiceList);
            out.append("}\n");
        }
    }
    private void generateFixedFlyweightHeader(
        final Writer out,
        final Token token,
        final String typeName,
        final String implementsString,
        final String buffer,
        final String fqBuffer,
        final Set<String> importedTypesPackages) throws IOException
    {
        out.append(generateFileHeader(registerTypesPackageName(token, ir), importedTypesPackages, fqBuffer));
        out.append(generateDeclaration(typeName, implementsString, token));
        out.append(generateFixedFlyweightCode(typeName, token.encodedLength(), buffer));
    }
    private void generateCompositeFlyweightHeader(
        final Token token,
        final String typeName,
        final Writer out,
        final String buffer,
        final String fqBuffer,
        final String implementsString,
        final Set<String> importedTypesPackages) throws IOException
    {
        out.append(generateFileHeader(registerTypesPackageName(token, ir), importedTypesPackages, fqBuffer));
        out.append(generateDeclaration(typeName, implementsString, token));
        out.append(generateFixedFlyweightCode(typeName, token.encodedLength(), buffer));
    }
    private void generateEnum(final List<Token> tokens) throws IOException
    {
        final Token enumToken = tokens.get(0);
        final String enumName = formatClassName(enumToken.applicableTypeName());
        final Encoding encoding = enumToken.encoding();
        final String nullVal = encoding.applicableNullValue().toString();
        final String packageName = registerTypesPackageName(enumToken, ir);
        try (Writer out = outputManager.createOutput(enumName))
        {
            out.append(generateEnumFileHeader(packageName));
            out.append(generateEnumDeclaration(enumName, enumToken));
            final List<Token> valuesList = tokens.subList(1, tokens.size() - 1);
            out.append(generateEnumValues(valuesList, generateLiteral(encoding.primitiveType(), nullVal)));
            out.append(generateEnumBody(enumToken, enumName));
            out.append(generateEnumLookupMethod(valuesList, enumName, nullVal));
            out.append("}\n");
        }
    }
    private void generateComposite(final List<Token> tokens) throws IOException
    {
        final Token token = tokens.get(0);
        final String compositeName = token.applicableTypeName();
        final String decoderName = decoderName(compositeName);
        final String encoderName = encoderName(compositeName);
        registerTypesPackageName(token, ir);
        final Set<String> importedTypesPackages = scanPackagesToImport(tokens);
        try (Writer out = outputManager.createOutput(decoderName))
        {
            final String implementsString = implementsInterface(CompositeDecoderFlyweight.class.getSimpleName());
            generateCompositeFlyweightHeader(
                token, decoderName, out, readOnlyBuffer, fqReadOnlyBuffer, implementsString, importedTypesPackages);
            for (int i = 1, end = tokens.size() - 1; i < end;)
            {
                final Token encodingToken = tokens.get(i);
                final String propertyName = formatPropertyName(encodingToken.name());
                final String typeName = decoderName(encodingToken.applicableTypeName());
                final StringBuilder sb = new StringBuilder();
                generateEncodingOffsetMethod(sb, propertyName, encodingToken.offset(), BASE_INDENT);
                generateEncodingLengthMethod(sb, propertyName, encodingToken.encodedLength(), BASE_INDENT);
                generateFieldSinceVersionMethod(sb, encodingToken, BASE_INDENT);
                final String accessOrderListenerCall = "";
                switch (encodingToken.signal())
                {
                    case ENCODING:
                        generatePrimitiveDecoder(
                            sb, true, encodingToken.name(), "", encodingToken, encodingToken, BASE_INDENT);
                        break;
                    case BEGIN_ENUM:
                        generateEnumDecoder(sb, true, "", encodingToken, propertyName, encodingToken, BASE_INDENT);
                        break;
                    case BEGIN_SET:
                        generateBitSetProperty(
                            sb, true, DECODER, propertyName, accessOrderListenerCall,
                            encodingToken, encodingToken, BASE_INDENT, typeName);
                        break;
                    case BEGIN_COMPOSITE:
                        generateCompositeProperty(
                            sb, true, DECODER, propertyName, accessOrderListenerCall,
                            encodingToken, encodingToken, BASE_INDENT, typeName);
                        break;
                    default:
                        break;
                }
                out.append(sb);
                i += encodingToken.componentTokenCount();
            }
            out.append(generateCompositeDecoderDisplay(tokens));
            out.append("}\n");
        }
        registerTypesPackageName(token, ir);
        try (Writer out = outputManager.createOutput(encoderName))
        {
            final String implementsString = implementsInterface(CompositeEncoderFlyweight.class.getSimpleName());
            generateCompositeFlyweightHeader(
                token, encoderName, out, mutableBuffer, fqMutableBuffer, implementsString, importedTypesPackages);
            for (int i = 1, end = tokens.size() - 1; i < end;)
            {
                final Token encodingToken = tokens.get(i);
                final String propertyName = formatPropertyName(encodingToken.name());
                final String typeName = encoderName(encodingToken.applicableTypeName());
                final StringBuilder sb = new StringBuilder();
                generateEncodingOffsetMethod(sb, propertyName, encodingToken.offset(), BASE_INDENT);
                generateEncodingLengthMethod(sb, propertyName, encodingToken.encodedLength(), BASE_INDENT);
                final String accessOrderListenerCall = "";
                switch (encodingToken.signal())
                {
                    case ENCODING:
                        generatePrimitiveEncoder(sb, encoderName, encodingToken.name(),
                            accessOrderListenerCall, encodingToken, BASE_INDENT);
                        break;
                    case BEGIN_ENUM:
                        generateEnumEncoder(sb, encoderName, accessOrderListenerCall,
                            encodingToken, propertyName, encodingToken, BASE_INDENT);
                        break;
                    case BEGIN_SET:
                        generateBitSetProperty(
                            sb, true, ENCODER, propertyName, accessOrderListenerCall,
                            encodingToken, encodingToken, BASE_INDENT, typeName);
                        break;
                    case BEGIN_COMPOSITE:
                        generateCompositeProperty(
                            sb, true, ENCODER, propertyName, accessOrderListenerCall,
                            encodingToken, encodingToken, BASE_INDENT, typeName);
                        break;
                    default:
                        break;
                }
                out.append(sb);
                i += encodingToken.componentTokenCount();
            }
            out.append(generateCompositeEncoderDisplay(decoderName));
            out.append("}\n");
        }
    }
    private Set<String> scanPackagesToImport(final List<Token> tokens)
    {
        if (!shouldSupportTypesPackageNames)
        {
            return PACKAGES_EMPTY_SET;
        }
        final Set<String> packagesToImport = new HashSet<>();
        for (int i = 1, limit = tokens.size() - 1; i < limit; i++)
        {
            final Token typeToken = tokens.get(i);
            if (typeToken.signal() == Signal.BEGIN_ENUM ||
                typeToken.signal() == Signal.BEGIN_SET ||
                typeToken.signal() == Signal.BEGIN_COMPOSITE)
            {
                if (typeToken.packageName() != null)
                {
                    packagesToImport.add(typeToken.packageName());
                }
            }
        }
        return packagesToImport;
    }
    private void generateChoiceClear(final Appendable out, final String bitSetClassName, final Token token)
        throws IOException
    {
        final Encoding encoding = token.encoding();
        final String literalValue = generateLiteral(encoding.primitiveType(), "0");
        final String byteOrderStr = byteOrderString(encoding);
        final String clearStr = generatePut(encoding.primitiveType(), "offset", literalValue, byteOrderStr);
        out.append("\n")
            .append("    public ").append(bitSetClassName).append(" clear()\n")
            .append("    {\n")
            .append("        ").append(clearStr).append(";\n")
            .append("        return this;\n")
            .append("    }\n");
    }
    private void generateChoiceDecoders(final Appendable out, final List<Token> tokens)
        throws IOException
    {
        for (final Token token : tokens)
        {
            if (token.signal() == Signal.CHOICE)
            {
                final String choiceName = formatPropertyName(token.name());
                final Encoding encoding = token.encoding();
                final String choiceBitIndex = encoding.constValue().toString();
                final String byteOrderStr = byteOrderString(encoding);
                final PrimitiveType primitiveType = encoding.primitiveType();
                final String argType = bitsetArgType(primitiveType);
                generateOptionDecodeJavadoc(out, INDENT, token);
                final String choiceGet = generateChoiceGet(primitiveType, choiceBitIndex, byteOrderStr);
                final String staticChoiceGet = generateStaticChoiceGet(primitiveType, choiceBitIndex);
                out.append("\n")
                    .append("    public boolean ").append(choiceName).append("()\n")
                    .append("    {\n")
                    .append("        return ").append(choiceGet).append(";\n")
                    .append("    }\n\n")
                    .append("    public static boolean ").append(choiceName)
                    .append("(final ").append(argType).append(" value)\n")
                    .append("    {\n").append("        return ").append(staticChoiceGet).append(";\n")
                    .append("    }\n");
            }
        }
    }
    private void generateChoiceEncoders(final Appendable out, final String bitSetClassName, final List<Token> tokens)
        throws IOException
    {
        for (final Token token : tokens)
        {
            if (token.signal() == Signal.CHOICE)
            {
                final String choiceName = formatPropertyName(token.name());
                final Encoding encoding = token.encoding();
                final String choiceBitIndex = encoding.constValue().toString();
                final String byteOrderStr = byteOrderString(encoding);
                final PrimitiveType primitiveType = encoding.primitiveType();
                final String argType = bitsetArgType(primitiveType);
                generateOptionEncodeJavadoc(out, INDENT, token);
                final String choicePut = generateChoicePut(encoding.primitiveType(), choiceBitIndex, byteOrderStr);
                final String staticChoicePut = generateStaticChoicePut(encoding.primitiveType(), choiceBitIndex);
                out.append("\n")
                    .append("    public ").append(bitSetClassName).append(" ").append(choiceName)
                    .append("(final boolean value)\n")
                    .append("    {\n")
                    .append(choicePut).append("\n")
                    .append("        return this;\n")
                    .append("    }\n\n")
                    .append("    public static ").append(argType).append(" ").append(choiceName)
                    .append("(final ").append(argType).append(" bits, final boolean value)\n")
                    .append("    {\n")
                    .append(staticChoicePut)
                    .append("    }\n");
            }
        }
    }
    private String bitsetArgType(final PrimitiveType primitiveType)
    {
        switch (primitiveType)
        {
            case UINT8:
                return "byte";
            case UINT16:
                return "short";
            case UINT32:
                return "int";
            case UINT64:
                return "long";
            default:
                throw new IllegalStateException("Invalid type: " + primitiveType);
        }
    }
    private CharSequence generateEnumValues(final List<Token> tokens, final String nullVal)
    {
        final StringBuilder sb = new StringBuilder();
        for (final Token token : tokens)
        {
            final Encoding encoding = token.encoding();
            final CharSequence constVal = generateLiteral(encoding.primitiveType(), encoding.constValue().toString());
            generateTypeJavadoc(sb, INDENT, token);
            sb.append(INDENT).append(formatForJavaKeyword(token.name())).append('(').append(constVal).append("),\n\n");
        }
        if (shouldDecodeUnknownEnumValues)
        {
            sb.append(INDENT).append("/**\n");
            sb.append(INDENT).append(" * To be used to represent an unknown value from a later version.\n");
            sb.append(INDENT).append(" */\n");
            sb.append(INDENT).append("SBE_UNKNOWN").append('(').append(nullVal).append("),\n\n");
        }
        sb.append(INDENT).append("/**\n");
        sb.append(INDENT).append(" * To be used to represent not present or null.\n");
        sb.append(INDENT).append(" */\n");
        sb.append(INDENT).append("NULL_VAL").append('(').append(nullVal).append(");\n\n");
        return sb;
    }
    private CharSequence generateEnumBody(final Token token, final String enumName)
    {
        final String javaEncodingType = primitiveTypeName(token);
        return
            "    private final " + javaEncodingType + " value;\n\n" +
            "    " + enumName + "(final " + javaEncodingType + " value)\n" +
            "    {\n" +
            "        this.value = value;\n" +
            "    }\n\n" +
            "    /**\n" +
            "     * The raw encoded value in the Java type representation.\n" +
            "     *\n" +
            "     * @return the raw value encoded.\n" +
            "     */\n" +
            "    public " + javaEncodingType + " value()\n" +
            "    {\n" +
            "        return value;\n" +
            "    }\n";
    }
    private CharSequence generateEnumLookupMethod(final List<Token> tokens, final String enumName, final String nullVal)
    {
        final StringBuilder sb = new StringBuilder();
        final PrimitiveType primitiveType = tokens.get(0).encoding().primitiveType();
        sb.append("\n")
            .append("    /**\n")
            .append("     * Lookup the enum value representing the value.\n")
            .append("     *\n")
            .append("     * @param value encoded to be looked up.\n")
            .append("     * @return the enum value representing the value.\n")
            .append("     */\n")
            .append("    public static ").append(enumName)
            .append(" get(final ").append(javaTypeName(primitiveType)).append(" value)\n").append("    {\n")
            .append("        switch (value)\n").append("        {\n");
        for (final Token token : tokens)
        {
            final String constStr = token.encoding().constValue().toString();
            final String name = formatForJavaKeyword(token.name());
            sb.append("            case ").append(constStr).append(": return ").append(name).append(";\n");
        }
        sb.append("            case ").append(nullVal).append(": return NULL_VAL").append(";\n");
        final String handleUnknownLogic = shouldDecodeUnknownEnumValues ?
            INDENT + INDENT + "return SBE_UNKNOWN;\n" :
            INDENT + INDENT + "throw new IllegalArgumentException(\"Unknown value: \" + value);\n";
        sb.append("        }\n\n")
            .append(handleUnknownLogic)
            .append("    }\n");
        return sb;
    }
    private StringBuilder generateImportStatements(final Set<String> packages, final String currentPackage)
    {
        final StringBuilder importStatements = new StringBuilder();
        for (final String candidatePackage : packages)
        {
            if (!candidatePackage.equals(currentPackage))
            {
                importStatements.append("import ").append(candidatePackage).append(".*;\n");
            }
        }
        if (importStatements.length() > 0)
        {
            importStatements.append("\n\n");
        }
        return importStatements;
    }
    private String interfaceImportLine()
    {
        if (!shouldGenerateInterfaces)
        {
            return "\n";
        }
        return "import " + JAVA_INTERFACE_PACKAGE + ".*;\n\n";
    }
    private CharSequence generateFileHeader(
        final String packageName,
        final Set<String> importedTypesPackages,
        final String fqBuffer)
    {
        return "/* Generated SBE (Simple Binary Encoding) message codec. */\n" +
            "package " + packageName + ";\n\n" +
            "import " + fqBuffer + ";\n" +
            interfaceImportLine() +
            generateImportStatements(importedTypesPackages, packageName);
    }
    private CharSequence generateMainHeader(
        final String packageName, final CodecType codecType, final boolean hasVarData)
    {
        final StringBuilder importStatements = generateImportStatements(packageNameByTypes, packageName);
        if (fqMutableBuffer.equals(fqReadOnlyBuffer))
        {
            return
                "/* Generated SBE (Simple Binary Encoding) message codec. */\n" +
                "package " + packageName + ";\n\n" +
                "import " + fqMutableBuffer + ";\n" +
                interfaceImportLine() +
                importStatements;
        }
        else
        {
            final boolean hasMutableBuffer = ENCODER == codecType || hasVarData;
            final boolean hasReadOnlyBuffer = DECODER == codecType || hasVarData;
            return
                "/* Generated SBE (Simple Binary Encoding) message codec. */\n" +
                "package " + packageName + ";\n\n" +
                (hasMutableBuffer ? "import " + fqMutableBuffer + ";\n" : "") +
                (hasReadOnlyBuffer ? "import " + fqReadOnlyBuffer + ";\n" : "") +
                interfaceImportLine() +
                importStatements;
        }
    }
    private static CharSequence generateEnumFileHeader(final String packageName)
    {
        return
            "/* Generated SBE (Simple Binary Encoding) message codec. */\n" +
            "package " + packageName + ";\n\n";
    }
    private void generateAnnotations(
        final String indent,
        final String className,
        final List<Token> tokens,
        final Appendable out,
        final Function<String, String> nameMapping) throws IOException
    {
        final List<String> groupClassNames = new ArrayList<>();
        int level = 0;
        for (final Token token : tokens)
        {
            if (token.signal() == Signal.BEGIN_GROUP)
            {
                if (1 == ++level)
                {
                    groupClassNames.add(formatClassName(nameMapping.apply(token.name())));
                }
            }
            else if (token.signal() == Signal.END_GROUP)
            {
                --level;
            }
        }
        if (!groupClassNames.isEmpty())
        {
            out.append(indent).append("@uk.co.real_logic.sbe.codec.java.GroupOrder({\n");
            int i = 0;
            for (final String name : groupClassNames)
            {
                out.append(indent).append(INDENT).append(className).append('.').append(name).append(".class");
                if (++i < groupClassNames.size())
                {
                    out.append(",\n");
                }
            }
            out.append("})");
        }
    }
    private static CharSequence generateDeclaration(
        final String className, final String implementsString, final Token typeToken)
    {
        final StringBuilder sb = new StringBuilder();
        generateTypeJavadoc(sb, BASE_INDENT, typeToken);
        if (typeToken.deprecated() > 0)
        {
            sb.append("@Deprecated\n");
        }
        sb.append("@SuppressWarnings(\"all\")\n")
            .append("public final class ").append(className).append(implementsString).append('\n')
            .append("{\n");
        return sb;
    }
    private void generatePackageInfo() throws IOException
    {
        try (Writer out = outputManager.createOutput(PACKAGE_INFO))
        {
            out.append(
                "/* Generated SBE (Simple Binary Encoding) message codecs.*/\n" +
                "/**\n" +
                " * ").append(ir.description()).append("\n")
                .append(
                " */\n" +
                "package ").append(ir.applicableNamespace()).append(";\n");
        }
    }
    private void generateMetaAttributeEnum() throws IOException
    {
        try (Writer out = outputManager.createOutput(META_ATTRIBUTE_ENUM))
        {
            out.append(
                "/* Generated SBE (Simple Binary Encoding) message codec. */\n" +
                "package ").append(ir.applicableNamespace()).append(";\n\n")
                .append(
                "/**\n" +
                " * Meta attribute enum for selecting a particular meta attribute value.\n" +
                " */\n" +
                " @SuppressWarnings(\"all\")\n" +
                "public enum MetaAttribute\n" +
                "{\n" +
                "    /**\n" +
                "     * The epoch or start of time. Default is 'UNIX' which is midnight 1st January 1970 UTC.\n" +
                "     */\n" +
                "    EPOCH,\n\n" +
                "    /**\n" +
                "     * Time unit applied to the epoch. Can be second, millisecond, microsecond, or nanosecond.\n" +
                "     */\n" +
                "    TIME_UNIT,\n\n" +
                "    /**\n" +
                "     * The type relationship to a FIX tag value encoded type. For reference only.\n" +
                "     */\n" +
                "    SEMANTIC_TYPE,\n\n" +
                "    /**\n" +
                "     * Field presence indication. Can be optional, required, or constant.\n" +
                "     */\n" +
                "    PRESENCE\n" +
                "}\n");
        }
    }
    private static CharSequence generateEnumDeclaration(final String name, final Token typeToken)
    {
        final StringBuilder sb = new StringBuilder();
        generateTypeJavadoc(sb, BASE_INDENT, typeToken);
        sb.append("@SuppressWarnings(\"all\")\n").append("public enum ").append(name).append("\n{\n");
        return sb;
    }
    private void generatePrimitiveDecoder(
        final StringBuilder sb,
        final boolean inComposite,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token propertyToken,
        final Token encodingToken,
        final String indent)
    {
        final String formattedPropertyName = formatPropertyName(propertyName);
        generatePrimitiveFieldMetaMethod(sb, formattedPropertyName, encodingToken, indent);
        if (encodingToken.isConstantEncoding())
        {
            generateConstPropertyMethods(sb, formattedPropertyName, encodingToken, indent);
        }
        else
        {
            sb.append(generatePrimitivePropertyDecodeMethods(
                inComposite, formattedPropertyName, accessOrderListenerCall, propertyToken, encodingToken, indent));
        }
    }
    private void generatePrimitiveEncoder(
        final StringBuilder sb,
        final String containingClassName,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token typeToken,
        final String indent)
    {
        final String formattedPropertyName = formatPropertyName(propertyName);
        generatePrimitiveFieldMetaMethod(sb, formattedPropertyName, typeToken, indent);
        if (!typeToken.isConstantEncoding())
        {
            sb.append(generatePrimitivePropertyEncodeMethods(
                containingClassName, formattedPropertyName, accessOrderListenerCall, typeToken, indent));
        }
        else
        {
            generateConstPropertyMethods(sb, formattedPropertyName, typeToken, indent);
        }
    }
    private CharSequence generatePrimitivePropertyDecodeMethods(
        final boolean inComposite,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token propertyToken,
        final Token encodingToken,
        final String indent)
    {
        return encodingToken.matchOnLength(
            () -> generatePrimitivePropertyDecode(
                inComposite, propertyName, accessOrderListenerCall, propertyToken, encodingToken, indent),
            () -> generatePrimitiveArrayPropertyDecode(
                inComposite, propertyName, accessOrderListenerCall, propertyToken, encodingToken, indent));
    }
    private CharSequence generatePrimitivePropertyEncodeMethods(
        final String containingClassName,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token typeToken,
        final String indent)
    {
        return typeToken.matchOnLength(
            () -> generatePrimitivePropertyEncode(
                containingClassName, propertyName, accessOrderListenerCall, typeToken, indent),
            () -> generatePrimitiveArrayPropertyEncode(
                containingClassName, propertyName, accessOrderListenerCall, typeToken, indent));
    }
    private void generatePrimitiveFieldMetaMethod(
        final StringBuilder sb, final String propertyName, final Token token, final String indent)
    {
        final PrimitiveType primitiveType = token.encoding().primitiveType();
        final String javaTypeName = javaTypeName(primitiveType);
        final String formattedPropertyName = formatPropertyName(propertyName);
        final String nullValue = generateLiteral(primitiveType, token.encoding().applicableNullValue().toString());
        generatePrimitiveFieldMetaMethod(sb, indent, javaTypeName, formattedPropertyName, "Null", nullValue);
        final String minValue = generateLiteral(primitiveType, token.encoding().applicableMinValue().toString());
        generatePrimitiveFieldMetaMethod(sb, indent, javaTypeName, formattedPropertyName, "Min", minValue);
        final String maxValue = generateLiteral(primitiveType, token.encoding().applicableMaxValue().toString());
        generatePrimitiveFieldMetaMethod(sb, indent, javaTypeName, formattedPropertyName, "Max", maxValue);
    }
    private void generatePrimitiveFieldMetaMethod(
        final StringBuilder sb,
        final String indent,
        final String javaTypeName,
        final String formattedPropertyName,
        final String metaType,
        final String retValue)
    {
        sb.append("\n")
            .append(indent).append("    public static ")
            .append(javaTypeName).append(" ").append(formattedPropertyName).append(metaType).append("Value()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return ").append(retValue).append(";\n")
            .append(indent).append("    }\n");
    }
    private CharSequence generatePrimitivePropertyDecode(
        final boolean inComposite,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token propertyToken,
        final Token encodingToken,
        final String indent)
    {
        final Encoding encoding = encodingToken.encoding();
        final String javaTypeName = javaTypeName(encoding.primitiveType());
        final int offset = encodingToken.offset();
        final String byteOrderStr = byteOrderString(encoding);
        return String.format(
            "\n" +
            indent + "    public %s %s()\n" +
            indent + "    {\n" +
            "%s" +
            "%s" +
            indent + "        return %s;\n" +
            indent + "    }\n\n",
            javaTypeName,
            formatPropertyName(propertyName),
            generateFieldNotPresentCondition(inComposite, propertyToken.version(), encoding, indent),
            accessOrderListenerCall,
            generateGet(encoding.primitiveType(), "offset + " + offset, byteOrderStr));
    }
    private CharSequence generatePrimitivePropertyEncode(
        final String containingClassName,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token typeToken,
        final String indent)
    {
        final Encoding encoding = typeToken.encoding();
        final String javaTypeName = javaTypeName(encoding.primitiveType());
        final int offset = typeToken.offset();
        final String byteOrderStr = byteOrderString(encoding);
        return String.format(
            "\n" +
            indent + "    public %s %s(final %s value)\n" +
            indent + "    {\n" +
            "%s" +
            indent + "        %s;\n" +
            indent + "        return this;\n" +
            indent + "    }\n\n",
            formatClassName(containingClassName),
            formatPropertyName(propertyName),
            javaTypeName,
            accessOrderListenerCall,
            generatePut(encoding.primitiveType(), "offset + " + offset, "value", byteOrderStr));
    }
    private CharSequence generateWrapFieldNotPresentCondition(
        final boolean inComposite,
        final int sinceVersion,
        final String indent)
    {
        if (inComposite || 0 == sinceVersion)
        {
            return "";
        }
        return
            indent + "        if (parentMessage.actingVersion < " + sinceVersion + ")\n" +
            indent + "        {\n" +
            indent + "            wrapBuffer.wrap(buffer, offset, 0);\n" +
            indent + "            return;\n" +
            indent + "        }\n\n";
    }
    private CharSequence generateFieldNotPresentCondition(
        final boolean inComposite, final int sinceVersion, final Encoding encoding, final String indent)
    {
        if (inComposite || 0 == sinceVersion)
        {
            return "";
        }
        final String nullValue = generateLiteral(encoding.primitiveType(), encoding.applicableNullValue().toString());
        return
            indent + "        if (parentMessage.actingVersion < " + sinceVersion + ")\n" +
            indent + "        {\n" +
            indent + "            return " + nullValue + ";\n" +
            indent + "        }\n\n";
    }
    private static CharSequence generateArrayFieldNotPresentCondition(
        final boolean inComposite, final int sinceVersion, final String indent)
    {
        if (inComposite || 0 == sinceVersion)
        {
            return "";
        }
        return
            indent + "        if (parentMessage.actingVersion < " + sinceVersion + ")\n" +
            indent + "        {\n" +
            indent + "            return 0;\n" +
            indent + "        }\n\n";
    }
    private static CharSequence generateStringNotPresentConditionForAppendable(
        final boolean inComposite, final int sinceVersion, final String indent)
    {
        if (inComposite || 0 == sinceVersion)
        {
            return "";
        }
        return
            indent + "        if (parentMessage.actingVersion < " + sinceVersion + ")\n" +
            indent + "        {\n" +
            indent + "            return 0;\n" +
            indent + "        }\n\n";
    }
    private static CharSequence generateStringNotPresentCondition(
        final boolean inComposite, final int sinceVersion, final String indent)
    {
        if (inComposite || 0 == sinceVersion)
        {
            return "";
        }
        return
            indent + "        if (parentMessage.actingVersion < " + sinceVersion + ")\n" +
            indent + "        {\n" +
            indent + "            return \"\";\n" +
            indent + "        }\n\n";
    }
    private static CharSequence generatePropertyNotPresentCondition(
        final boolean inComposite,
        final CodecType codecType,
        final Token propertyToken,
        final String enumName,
        final String indent)
    {
        if (inComposite || codecType == ENCODER || 0 == propertyToken.version())
        {
            return "";
        }
        final String nullValue = enumName == null ? "null" : (enumName + ".NULL_VAL");
        return
            indent + "        if (parentMessage.actingVersion < " + propertyToken.version() + ")\n" +
            indent + "        {\n" +
            indent + "            return " + nullValue + ";\n" +
            indent + "        }\n\n";
    }
    private CharSequence generatePrimitiveArrayPropertyDecode(
        final boolean inComposite,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token propertyToken,
        final Token encodingToken,
        final String indent)
    {
        final Encoding encoding = encodingToken.encoding();
        final String javaTypeName = javaTypeName(encoding.primitiveType());
        final int offset = encodingToken.offset();
        final String byteOrderStr = byteOrderString(encoding);
        final int fieldLength = encodingToken.arrayLength();
        final int typeSize = sizeOfPrimitive(encoding);
        final StringBuilder sb = new StringBuilder();
        generateArrayLengthMethod(propertyName, indent, fieldLength, sb);
        new Formatter(sb).format("\n" +
            indent + "    public %s %s(final int index)\n" +
            indent + "    {\n" +
            indent + "        if (index < 0 || index >= %d)\n" +
            indent + "        {\n" +
            indent + "            throw new IndexOutOfBoundsException(\"index out of range: index=\" + index);\n" +
            indent + "        }\n\n" +
            "%s" +
            "%s" +
            indent + "        final int pos = offset + %d + (index * %d);\n\n" +
            indent + "        return %s;\n" +
            indent + "    }\n\n",
            javaTypeName,
            propertyName,
            fieldLength,
            generateFieldNotPresentCondition(inComposite, propertyToken.version(), encoding, indent),
            accessOrderListenerCall,
            offset,
            typeSize,
            generateGet(encoding.primitiveType(), "pos", byteOrderStr));
        if (encoding.primitiveType() == PrimitiveType.CHAR)
        {
            generateCharacterEncodingMethod(sb, propertyName, encoding.characterEncoding(), indent);
            new Formatter(sb).format("\n" +
                indent + "    public int get%s(final byte[] dst, final int dstOffset)\n" +
                indent + "    {\n" +
                indent + "        final int length = %d;\n" +
                indent + "        if (dstOffset < 0 || dstOffset > (dst.length - length))\n" +
                indent + "        {\n" +
                indent + "            throw new IndexOutOfBoundsException(" +
                "\"Copy will go out of range: offset=\" + dstOffset);\n" +
                indent + "        }\n\n" +
                "%s" +
                "%s" +
                indent + "        buffer.getBytes(offset + %d, dst, dstOffset, length);\n\n" +
                indent + "        return length;\n" +
                indent + "    }\n",
                Generators.toUpperFirstChar(propertyName),
                fieldLength,
                generateArrayFieldNotPresentCondition(inComposite, propertyToken.version(), indent),
                accessOrderListenerCall,
                offset);
            new Formatter(sb).format("\n" +
                indent + "    public String %s()\n" +
                indent + "    {\n" +
                "%s" +
                "%s" +
                indent + "        final byte[] dst = new byte[%d];\n" +
                indent + "        buffer.getBytes(offset + %d, dst, 0, %d);\n\n" +
                indent + "        int end = 0;\n" +
                indent + "        for (; end < %d && dst[end] != 0; ++end);\n\n" +
                indent + "        return new String(dst, 0, end, %s);\n" +
                indent + "    }\n\n",
                propertyName,
                generateStringNotPresentCondition(inComposite, propertyToken.version(), indent),
                accessOrderListenerCall,
                fieldLength,
                offset,
                fieldLength,
                fieldLength,
                charset(encoding.characterEncoding()));
            if (isAsciiEncoding(encoding.characterEncoding()))
            {
                new Formatter(sb).format("\n" +
                    indent + "    public int get%1$s(final Appendable value)\n" +
                    indent + "    {\n" +
                    "%2$s" +
                    "%5$s" +
                    indent + "        for (int i = 0; i < %3$d; ++i)\n" +
                    indent + "        {\n" +
                    indent + "            final int c = buffer.getByte(offset + %4$d + i) & 0xFF;\n" +
                    indent + "            if (c == 0)\n" +
                    indent + "            {\n" +
                    indent + "                return i;\n" +
                    indent + "            }\n\n" +
                    indent + "            try\n" +
                    indent + "            {\n" +
                    indent + "                value.append(c > 127 ? '?' : (char)c);\n" +
                    indent + "            }\n" +
                    indent + "            catch (final java.io.IOException ex)\n" +
                    indent + "            {\n" +
                    indent + "                throw new java.io.UncheckedIOException(ex);\n" +
                    indent + "            }\n" +
                    indent + "        }\n\n" +
                    indent + "        return %3$d;\n" +
                    indent + "    }\n\n",
                    Generators.toUpperFirstChar(propertyName),
                    generateStringNotPresentConditionForAppendable(inComposite, propertyToken.version(), indent),
                    fieldLength,
                    offset,
                    accessOrderListenerCall);
            }
        }
        else if (encoding.primitiveType() == PrimitiveType.UINT8)
        {
            new Formatter(sb).format("\n" +
                indent + "    public int get%s(final byte[] dst, final int dstOffset, final int length)\n" +
                indent + "    {\n" +
                "%s" +
                "%s" +
                indent + "        final int bytesCopied = Math.min(length, %d);\n" +
                indent + "        buffer.getBytes(offset + %d, dst, dstOffset, bytesCopied);\n\n" +
                indent + "        return bytesCopied;\n" +
                indent + "    }\n",
                Generators.toUpperFirstChar(propertyName),
                generateArrayFieldNotPresentCondition(inComposite, propertyToken.version(), indent),
                accessOrderListenerCall,
                fieldLength,
                offset);
            new Formatter(sb).format("\n" +
                indent + "    public int get%s(final %s dst, final int dstOffset, final int length)\n" +
                indent + "    {\n" +
                "%s" +
                "%s" +
                indent + "        final int bytesCopied = Math.min(length, %d);\n" +
                indent + "        buffer.getBytes(offset + %d, dst, dstOffset, bytesCopied);\n\n" +
                indent + "        return bytesCopied;\n" +
                indent + "    }\n",
                Generators.toUpperFirstChar(propertyName),
                fqMutableBuffer,
                generateArrayFieldNotPresentCondition(inComposite, propertyToken.version(), indent),
                accessOrderListenerCall,
                fieldLength,
                offset);
            new Formatter(sb).format("\n" +
                indent + "    public void wrap%s(final %s wrapBuffer)\n" +
                indent + "    {\n" +
                "%s" +
                "%s" +
                indent + "        wrapBuffer.wrap(buffer, offset + %d, %d);\n" +
                indent + "    }\n",
                Generators.toUpperFirstChar(propertyName),
                readOnlyBuffer,
                generateWrapFieldNotPresentCondition(inComposite, propertyToken.version(), indent),
                accessOrderListenerCall,
                offset,
                fieldLength);
        }
        return sb;
    }
    private static void generateArrayLengthMethod(
        final String propertyName, final String indent, final int fieldLength, final StringBuilder sb)
    {
        final String formatPropertyName = formatPropertyName(propertyName);
        sb.append("\n")
            .append(indent).append("    public static int ").append(formatPropertyName).append("Length()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return ").append(fieldLength).append(";\n")
            .append(indent).append("    }\n\n");
    }
    private String byteOrderString(final Encoding encoding)
    {
        return sizeOfPrimitive(encoding) == 1 ? "" : ", BYTE_ORDER";
    }
    private CharSequence generatePrimitiveArrayPropertyEncode(
        final String containingClassName,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token typeToken,
        final String indent)
    {
        final Encoding encoding = typeToken.encoding();
        final PrimitiveType primitiveType = encoding.primitiveType();
        final String javaTypeName = javaTypeName(primitiveType);
        final int offset = typeToken.offset();
        final String byteOrderStr = byteOrderString(encoding);
        final int arrayLength = typeToken.arrayLength();
        final int typeSize = sizeOfPrimitive(encoding);
        final StringBuilder sb = new StringBuilder();
        final String className = formatClassName(containingClassName);
        generateArrayLengthMethod(propertyName, indent, arrayLength, sb);
        new Formatter(sb).format("\n" +
            indent + "    public %s %s(final int index, final %s value)\n" +
            indent + "    {\n" +
            indent + "        if (index < 0 || index >= %d)\n" +
            indent + "        {\n" +
            indent + "            throw new IndexOutOfBoundsException(\"index out of range: index=\" + index);\n" +
            indent + "        }\n\n" +
            "%s" +
            indent + "        final int pos = offset + %d + (index * %d);\n" +
            indent + "        %s;\n\n" +
            indent + "        return this;\n" +
            indent + "    }\n",
            className,
            propertyName,
            javaTypeName,
            arrayLength,
            accessOrderListenerCall,
            offset,
            typeSize,
            generatePut(primitiveType, "pos", "value", byteOrderStr));
        if (arrayLength > 1 && arrayLength <= 4)
        {
            sb.append(indent)
                .append("    public ")
                .append(className)
                .append(" put").append(Generators.toUpperFirstChar(propertyName))
                .append("(final ").append(javaTypeName).append(" value0");
            for (int i = 1; i < arrayLength; i++)
            {
                sb.append(", final ").append(javaTypeName).append(" value").append(i);
            }
            sb.append(")\n");
            sb.append(indent).append("    {\n");
            sb.append(accessOrderListenerCall);
            for (int i = 0; i < arrayLength; i++)
            {
                final String indexStr = "offset + " + (offset + (typeSize * i));
                sb.append(indent).append("        ")
                    .append(generatePut(primitiveType, indexStr, "value" + i, byteOrderStr))
                    .append(";\n");
            }
            sb.append("\n");
            sb.append(indent).append("        return this;\n");
            sb.append(indent).append("    }\n");
        }
        if (primitiveType == PrimitiveType.CHAR)
        {
            generateCharArrayEncodeMethods(
                containingClassName,
                propertyName,
                indent,
                accessOrderListenerCall,
                encoding,
                offset,
                arrayLength,
                sb);
        }
        else if (primitiveType == PrimitiveType.UINT8)
        {
            generateByteArrayEncodeMethods(
                containingClassName,
                propertyName,
                indent,
                accessOrderListenerCall,
                offset,
                arrayLength,
                sb);
        }
        return sb;
    }
    private void generateCharArrayEncodeMethods(
        final String containingClassName,
        final String propertyName,
        final String indent,
        final CharSequence accessOrderListenerCall,
        final Encoding encoding,
        final int offset,
        final int fieldLength,
        final StringBuilder sb)
    {
        generateCharacterEncodingMethod(sb, propertyName, encoding.characterEncoding(), indent);
        new Formatter(sb).format("\n" +
            indent + "    public %s put%s(final byte[] src, final int srcOffset)\n" +
            indent + "    {\n" +
            indent + "        final int length = %d;\n" +
            indent + "        if (srcOffset < 0 || srcOffset > (src.length - length))\n" +
            indent + "        {\n" +
            indent + "            throw new IndexOutOfBoundsException(" +
            "\"Copy will go out of range: offset=\" + srcOffset);\n" +
            indent + "        }\n\n" +
            "%s" +
            indent + "        buffer.putBytes(offset + %d, src, srcOffset, length);\n\n" +
            indent + "        return this;\n" +
            indent + "    }\n",
            formatClassName(containingClassName),
            Generators.toUpperFirstChar(propertyName),
            fieldLength,
            accessOrderListenerCall,
            offset);
        if (isAsciiEncoding(encoding.characterEncoding()))
        {
            new Formatter(sb).format("\n" +
                indent + "    public %1$s %2$s(final String src)\n" +
                indent + "    {\n" +
                indent + "        final int length = %3$d;\n" +
                indent + "        final int srcLength = null == src ? 0 : src.length();\n" +
                indent + "        if (srcLength > length)\n" +
                indent + "        {\n" +
                indent + "            throw new IndexOutOfBoundsException(" +
                "\"String too large for copy: byte length=\" + srcLength);\n" +
                indent + "        }\n\n" +
                "%5$s" +
                indent + "        buffer.putStringWithoutLengthAscii(offset + %4$d, src);\n\n" +
                indent + "        for (int start = srcLength; start < length; ++start)\n" +
                indent + "        {\n" +
                indent + "            buffer.putByte(offset + %4$d + start, (byte)0);\n" +
                indent + "        }\n\n" +
                indent + "        return this;\n" +
                indent + "    }\n",
                formatClassName(containingClassName),
                propertyName,
                fieldLength,
                offset,
                accessOrderListenerCall);
            new Formatter(sb).format("\n" +
                indent + "    public %1$s %2$s(final CharSequence src)\n" +
                indent + "    {\n" +
                indent + "        final int length = %3$d;\n" +
                indent + "        final int srcLength = null == src ? 0 : src.length();\n" +
                indent + "        if (srcLength > length)\n" +
                indent + "        {\n" +
                indent + "            throw new IndexOutOfBoundsException(" +
                "\"CharSequence too large for copy: byte length=\" + srcLength);\n" +
                indent + "        }\n\n" +
                "%5$s" +
                indent + "        buffer.putStringWithoutLengthAscii(offset + %4$d, src);\n\n" +
                indent + "        for (int start = srcLength; start < length; ++start)\n" +
                indent + "        {\n" +
                indent + "            buffer.putByte(offset + %4$d + start, (byte)0);\n" +
                indent + "        }\n\n" +
                indent + "        return this;\n" +
                indent + "    }\n",
                formatClassName(containingClassName),
                propertyName,
                fieldLength,
                offset,
                accessOrderListenerCall);
        }
        else
        {
            new Formatter(sb).format("\n" +
                indent + "    public %s %s(final String src)\n" +
                indent + "    {\n" +
                indent + "        final int length = %d;\n" +
                indent + "        final byte[] bytes = (null == src || src.isEmpty()) ?" +
                " org.agrona.collections.ArrayUtil.EMPTY_BYTE_ARRAY : src.getBytes(%s);\n" +
                indent + "        if (bytes.length > length)\n" +
                indent + "        {\n" +
                indent + "            throw new IndexOutOfBoundsException(" +
                "\"String too large for copy: byte length=\" + bytes.length);\n" +
                indent + "        }\n\n" +
                "%s" +
                indent + "        buffer.putBytes(offset + %d, bytes, 0, bytes.length);\n\n" +
                indent + "        for (int start = bytes.length; start < length; ++start)\n" +
                indent + "        {\n" +
                indent + "            buffer.putByte(offset + %d + start, (byte)0);\n" +
                indent + "        }\n\n" +
                indent + "        return this;\n" +
                indent + "    }\n",
                formatClassName(containingClassName),
                propertyName,
                fieldLength,
                charset(encoding.characterEncoding()),
                accessOrderListenerCall,
                offset,
                offset);
        }
    }
    private void generateByteArrayEncodeMethods(
        final String containingClassName,
        final String propertyName,
        final String indent,
        final CharSequence accessOrderListenerCall,
        final int offset,
        final int fieldLength,
        final StringBuilder sb)
    {
        new Formatter(sb).format("\n" +
            indent + "    public %s put%s(final byte[] src, final int srcOffset, final int length)\n" +
            indent + "    {\n" +
            indent + "        if (length > %d)\n" +
            indent + "        {\n" +
            indent + "            throw new IllegalStateException(" +
            "\"length > maxValue for type: \" + length);\n" +
            indent + "        }\n\n" +
            "%s" +
            indent + "        buffer.putBytes(offset + %d, src, srcOffset, length);\n" +
            indent + "        for (int i = length; i < %d; i++)\n" +
            indent + "        {\n" +
            indent + "            buffer.putByte(offset + %d + i, (byte)0);\n" +
            indent + "        }\n\n" +
            indent + "        return this;\n" +
            indent + "    }\n",
            formatClassName(containingClassName),
            Generators.toUpperFirstChar(propertyName),
            fieldLength,
            accessOrderListenerCall,
            offset,
            fieldLength,
            offset);
        new Formatter(sb).format("\n" +
            indent + "    public %s put%s(final %s src, final int srcOffset, final int length)\n" +
            indent + "    {\n" +
            indent + "        if (length > %d)\n" +
            indent + "        {\n" +
            indent + "            throw new IllegalStateException(" +
            "\"length > maxValue for type: \" + length);\n" +
            indent + "        }\n\n" +
            "%s" +
            indent + "        buffer.putBytes(offset + %d, src, srcOffset, length);\n" +
            indent + "        for (int i = length; i < %d; i++)\n" +
            indent + "        {\n" +
            indent + "            buffer.putByte(offset + %d + i, (byte)0);\n" +
            indent + "        }\n\n" +
            indent + "        return this;\n" +
            indent + "    }\n",
            formatClassName(containingClassName),
            Generators.toUpperFirstChar(propertyName),
            fqReadOnlyBuffer,
            fieldLength,
            accessOrderListenerCall,
            offset,
            fieldLength,
            offset);
    }
    private static int sizeOfPrimitive(final Encoding encoding)
    {
        return encoding.primitiveType().size();
    }
    private static void generateCharacterEncodingMethod(
        final StringBuilder sb, final String propertyName, final String characterEncoding, final String indent)
    {
        if (null != characterEncoding)
        {
            final String propName = formatPropertyName(propertyName);
            sb.append("\n")
                .append(indent).append("    public static String ").append(propName).append("CharacterEncoding()\n")
                .append(indent).append("    {\n")
                .append(indent).append("        return ").append(charsetName(characterEncoding)).append(";\n")
                .append(indent).append("    }\n");
        }
    }
    private void generateConstPropertyMethods(
        final StringBuilder sb, final String propertyName, final Token token, final String indent)
    {
        final String formattedPropertyName = formatPropertyName(propertyName);
        final Encoding encoding = token.encoding();
        if (encoding.primitiveType() != PrimitiveType.CHAR)
        {
            new Formatter(sb).format("\n" +
                indent + "    public %s %s()\n" +
                indent + "    {\n" +
                indent + "        return %s;\n" +
                indent + "    }\n",
                javaTypeName(encoding.primitiveType()),
                formattedPropertyName,
                generateLiteral(encoding.primitiveType(), encoding.constValue().toString()));
            return;
        }
        final String javaTypeName = javaTypeName(encoding.primitiveType());
        final byte[] constBytes = encoding.constValue().byteArrayValue(encoding.primitiveType());
        final CharSequence values = generateByteLiteralList(
            encoding.constValue().byteArrayValue(encoding.primitiveType()));
        new Formatter(sb).format("\n" +
            "\n" +
            indent + "    private static final byte[] %s_VALUE = { %s };\n",
            propertyName.toUpperCase(),
            values);
        generateArrayLengthMethod(formattedPropertyName, indent, constBytes.length, sb);
        new Formatter(sb).format("\n" +
            indent + "    public %s %s(final int index)\n" +
            indent + "    {\n" +
            indent + "        return %s_VALUE[index];\n" +
            indent + "    }\n\n",
            javaTypeName,
            formattedPropertyName,
            propertyName.toUpperCase());
        sb.append(String.format(
            indent + "    public int get%s(final byte[] dst, final int offset, final int length)\n" +
            indent + "    {\n" +
            indent + "        final int bytesCopied = Math.min(length, %d);\n" +
            indent + "        System.arraycopy(%s_VALUE, 0, dst, offset, bytesCopied);\n\n" +
            indent + "        return bytesCopied;\n" +
            indent + "    }\n",
            Generators.toUpperFirstChar(propertyName),
            constBytes.length,
            propertyName.toUpperCase()));
        if (constBytes.length > 1)
        {
            new Formatter(sb).format("\n" +
                indent + "    public String %s()\n" +
                indent + "    {\n" +
                indent + "        return \"%s\";\n" +
                indent + "    }\n\n",
                formattedPropertyName,
                encoding.constValue());
        }
        else
        {
            new Formatter(sb).format("\n" +
                indent + "    public byte %s()\n" +
                indent + "    {\n" +
                indent + "        return (byte)%s;\n" +
                indent + "    }\n\n",
                formattedPropertyName,
                encoding.constValue());
        }
    }
    private static CharSequence generateByteLiteralList(final byte[] bytes)
    {
        final StringBuilder values = new StringBuilder();
        for (final byte b : bytes)
        {
            values.append(b).append(", ");
        }
        if (values.length() > 0)
        {
            values.setLength(values.length() - 2);
        }
        return values;
    }
    private CharSequence generateFixedFlyweightCode(
        final String className, final int size, final String bufferImplementation)
    {
        final String schemaIdType = javaTypeName(ir.headerStructure().schemaIdType());
        final String schemaIdAccessorType = shouldGenerateInterfaces ? "int" : schemaIdType;
        final String schemaVersionType = javaTypeName(ir.headerStructure().schemaVersionType());
        final String schemaVersionAccessorType = shouldGenerateInterfaces ? "int" : schemaVersionType;
        final String semanticVersion = ir.semanticVersion() == null ? "" : ir.semanticVersion();
        return String.format(
            "    public static final %5$s SCHEMA_ID = %6$s;\n" +
            "    public static final %7$s SCHEMA_VERSION = %8$s;\n" +
            "    public static final String SEMANTIC_VERSION = \"%11$s\";\n" +
            "    public static final int ENCODED_LENGTH = %2$d;\n" +
            "    public static final java.nio.ByteOrder BYTE_ORDER = java.nio.ByteOrder.%4$s;\n\n" +
            "    private int offset;\n" +
            "    private %3$s buffer;\n\n" +
            "    public %1$s wrap(final %3$s buffer, final int offset)\n" +
            "    {\n" +
            "        if (buffer != this.buffer)\n" +
            "        {\n" +
            "            this.buffer = buffer;\n" +
            "        }\n" +
            "        this.offset = offset;\n\n" +
            "        return this;\n" +
            "    }\n\n" +
            "    public %3$s buffer()\n" +
            "    {\n" +
            "        return buffer;\n" +
            "    }\n\n" +
            "    public int offset()\n" +
            "    {\n" +
            "        return offset;\n" +
            "    }\n\n" +
            "    public int encodedLength()\n" +
            "    {\n" +
            "        return ENCODED_LENGTH;\n" +
            "    }\n\n" +
            "    public %9$s sbeSchemaId()\n" +
            "    {\n" +
            "        return SCHEMA_ID;\n" +
            "    }\n\n" +
            "    public %10$s sbeSchemaVersion()\n" +
            "    {\n" +
            "        return SCHEMA_VERSION;\n" +
            "    }\n",
            className,
            size,
            bufferImplementation,
            ir.byteOrder(),
            schemaIdType,
            generateLiteral(ir.headerStructure().schemaIdType(), Integer.toString(ir.id())),
            schemaVersionType,
            generateLiteral(ir.headerStructure().schemaVersionType(), Integer.toString(ir.version())),
            schemaIdAccessorType,
            schemaVersionAccessorType,
            semanticVersion);
    }
    private CharSequence generateDecoderFlyweightCode(
        final FieldPrecedenceModel fieldPrecedenceModel,
        final String className,
        final Token token)
    {
        final String headerClassName = formatClassName(ir.headerStructure().tokens().get(0).applicableTypeName());
        final StringBuilder methods = new StringBuilder();
        methods.append(generateDecoderWrapListener(fieldPrecedenceModel, "    "));
        methods.append("    public ").append(className).append(" wrap(\n")
            .append("        final ").append(readOnlyBuffer).append(" buffer,\n")
            .append("        final int offset,\n")
            .append("        final int actingBlockLength,\n")
            .append("        final int actingVersion)\n")
            .append("    {\n")
            .append("        if (buffer != this.buffer)\n")
            .append("        {\n")
            .append("            this.buffer = buffer;\n")
            .append("        }\n")
            .append("        this.offset = offset;\n")
            .append("        this.actingBlockLength = actingBlockLength;\n")
            .append("        this.actingVersion = actingVersion;\n")
            .append("        limit(offset + actingBlockLength);\n\n")
            .append(generateAccessOrderListenerCall(fieldPrecedenceModel, "        ", "onWrap", "actingVersion"))
            .append("        return this;\n")
            .append("    }\n\n");
        methods.append("    public ").append(className).append(" wrapAndApplyHeader(\n")
            .append("        final ").append(readOnlyBuffer).append(" buffer,\n")
            .append("        final int offset,\n")
            .append("        final ").append(headerClassName).append("Decoder headerDecoder)\n")
            .append("    {\n")
            .append("        headerDecoder.wrap(buffer, offset);\n\n")
            .append("        final int templateId = headerDecoder.templateId();\n")
            .append("        if (TEMPLATE_ID != templateId)\n")
            .append("        {\n")
            .append("            throw new IllegalStateException(\"Invalid TEMPLATE_ID: \" + templateId);\n")
            .append("        }\n\n")
            .append("        return wrap(\n")
            .append("            buffer,\n")
            .append("            offset + ").append(headerClassName).append("Decoder.ENCODED_LENGTH,\n")
            .append("            headerDecoder.blockLength(),\n")
            .append("            headerDecoder.version());\n")
            .append("    }\n\n");
        methods.append("    public ").append(className).append(" sbeRewind()\n")
            .append("    {\n")
            .append("        return wrap(buffer, offset, actingBlockLength, actingVersion);\n")
            .append("    }\n\n");
        methods.append("    public int sbeDecodedLength()\n")
            .append("    {\n")
            .append("        final int currentLimit = limit();\n");
        if (null != fieldPrecedenceModel)
        {
            methods.append("        final int currentCodecState = codecState();\n");
        }
        methods
            .append("        sbeSkip();\n")
            .append("        final int decodedLength = encodedLength();\n")
            .append("        limit(currentLimit);\n\n");
        if (null != fieldPrecedenceModel)
        {
            methods.append("        if (").append(precedenceChecksFlagName).append(")\n")
                .append("        {\n")
                .append("            codecState(currentCodecState);\n")
                .append("        }\n\n");
        }
        methods.append("        return decodedLength;\n")
            .append("    }\n\n");
        methods.append("    public int actingVersion()\n")
            .append("    {\n")
            .append("        return actingVersion;\n")
            .append("    }\n\n");
        return generateFlyweightCode(DECODER, className, token, methods.toString(), readOnlyBuffer);
    }
    private CharSequence generateFlyweightCode(
        final CodecType codecType,
        final String className,
        final Token token,
        final String wrapMethod,
        final String bufferImplementation)
    {
        final HeaderStructure headerStructure = ir.headerStructure();
        final String blockLengthType = javaTypeName(headerStructure.blockLengthType());
        final String blockLengthAccessorType = shouldGenerateInterfaces ? "int" : blockLengthType;
        final String templateIdType = javaTypeName(headerStructure.templateIdType());
        final String templateIdAccessorType = shouldGenerateInterfaces ? "int" : templateIdType;
        final String schemaIdType = javaTypeName(headerStructure.schemaIdType());
        final String schemaIdAccessorType = shouldGenerateInterfaces ? "int" : schemaIdType;
        final String schemaVersionType = javaTypeName(headerStructure.schemaVersionType());
        final String schemaVersionAccessorType = shouldGenerateInterfaces ? "int" : schemaVersionType;
        final String semanticType = token.encoding().semanticType() == null ? "" : token.encoding().semanticType();
        final String semanticVersion = ir.semanticVersion() == null ? "" : ir.semanticVersion();
        final String actingFields = codecType == CodecType.ENCODER ?
            "" :
            "    int actingBlockLength;\n" +
            "    int actingVersion;\n";
        return String.format(
            "    public static final %1$s BLOCK_LENGTH = %2$s;\n" +
            "    public static final %3$s TEMPLATE_ID = %4$s;\n" +
            "    public static final %5$s SCHEMA_ID = %6$s;\n" +
            "    public static final %7$s SCHEMA_VERSION = %8$s;\n" +
            "    public static final String SEMANTIC_VERSION = \"%19$s\";\n" +
            "    public static final java.nio.ByteOrder BYTE_ORDER = java.nio.ByteOrder.%14$s;\n\n" +
            "    private final %9$s parentMessage = this;\n" +
            "    private %11$s buffer;\n" +
            "    private int offset;\n" +
            "    private int limit;\n" +
            "%13$s" +
            "\n" +
            "    public %15$s sbeBlockLength()\n" +
            "    {\n" +
            "        return BLOCK_LENGTH;\n" +
            "    }\n\n" +
            "    public %16$s sbeTemplateId()\n" +
            "    {\n" +
            "        return TEMPLATE_ID;\n" +
            "    }\n\n" +
            "    public %17$s sbeSchemaId()\n" +
            "    {\n" +
            "        return SCHEMA_ID;\n" +
            "    }\n\n" +
            "    public %18$s sbeSchemaVersion()\n" +
            "    {\n" +
            "        return SCHEMA_VERSION;\n" +
            "    }\n\n" +
            "    public String sbeSemanticType()\n" +
            "    {\n" +
            "        return \"%10$s\";\n" +
            "    }\n\n" +
            "    public %11$s buffer()\n" +
            "    {\n" +
            "        return buffer;\n" +
            "    }\n\n" +
            "    public int offset()\n" +
            "    {\n" +
            "        return offset;\n" +
            "    }\n\n" +
            "%12$s" +
            "    public int encodedLength()\n" +
            "    {\n" +
            "        return limit - offset;\n" +
            "    }\n\n" +
            "    public int limit()\n" +
            "    {\n" +
            "        return limit;\n" +
            "    }\n\n" +
            "    public void limit(final int limit)\n" +
            "    {\n" +
            "        this.limit = limit;\n" +
            "    }\n",
            blockLengthType,
            generateLiteral(headerStructure.blockLengthType(), Integer.toString(token.encodedLength())),
            templateIdType,
            generateLiteral(headerStructure.templateIdType(), Integer.toString(token.id())),
            schemaIdType,
            generateLiteral(headerStructure.schemaIdType(), Integer.toString(ir.id())),
            schemaVersionType,
            generateLiteral(headerStructure.schemaVersionType(), Integer.toString(ir.version())),
            className,
            semanticType,
            bufferImplementation,
            wrapMethod,
            actingFields,
            ir.byteOrder(),
            blockLengthAccessorType,
            templateIdAccessorType,
            schemaIdAccessorType,
            schemaVersionAccessorType,
            semanticVersion);
    }
    private CharSequence generateEncoderFlyweightCode(
        final String className,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final Token token)
    {
        final String wrapMethod =
            "    public " + className + " wrap(final " + mutableBuffer + " buffer, final int offset)\n" +
            "    {\n" +
            "        if (buffer != this.buffer)\n" +
            "        {\n" +
            "            this.buffer = buffer;\n" +
            "        }\n" +
            "        this.offset = offset;\n" +
            "        limit(offset + BLOCK_LENGTH);\n\n" +
            generateEncoderWrapListener(fieldPrecedenceModel, "        ") +
            "        return this;\n" +
            "    }\n\n";
        final StringBuilder builder = new StringBuilder(
            "    public %1$s wrapAndApplyHeader(\n" +
            "        final %2$s buffer, final int offset, final %3$s headerEncoder)\n" +
            "    {\n" +
            "        headerEncoder\n" +
            "            .wrap(buffer, offset)");
        for (final Token headerToken : ir.headerStructure().tokens())
        {
            if (!headerToken.isConstantEncoding())
            {
                switch (headerToken.name())
                {
                    case "blockLength":
                        builder.append("\n            .blockLength(BLOCK_LENGTH)");
                        break;
                    case "templateId":
                        builder.append("\n            .templateId(TEMPLATE_ID)");
                        break;
                    case "schemaId":
                        builder.append("\n            .schemaId(SCHEMA_ID)");
                        break;
                    case "version":
                        builder.append("\n            .version(SCHEMA_VERSION)");
                        break;
                }
            }
        }
        builder.append(";\n\n        return wrap(buffer, offset + %3$s.ENCODED_LENGTH);\n" + "    }\n\n");
        final String wrapAndApplyMethod = String.format(
            builder.toString(),
            className,
            mutableBuffer,
            formatClassName(ir.headerStructure().tokens().get(0).applicableTypeName() + "Encoder"));
        return generateFlyweightCode(
            CodecType.ENCODER, className, token, wrapMethod + wrapAndApplyMethod, mutableBuffer);
    }
    private void generateEncoderFields(
        final StringBuilder sb,
        final String containingClassName,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final List<Token> tokens,
        final String indent)
    {
        Generators.forEachField(
            tokens,
            (fieldToken, typeToken) ->
            {
                final String propertyName = formatPropertyName(fieldToken.name());
                final String typeName = encoderName(typeToken.name());
                generateFieldIdMethod(sb, fieldToken, indent);
                generateFieldSinceVersionMethod(sb, fieldToken, indent);
                generateEncodingOffsetMethod(sb, propertyName, fieldToken.offset(), indent);
                generateEncodingLengthMethod(sb, propertyName, typeToken.encodedLength(), indent);
                generateFieldMetaAttributeMethod(sb, fieldToken, indent);
                generateAccessOrderListenerMethod(sb, fieldPrecedenceModel, indent + "    ", fieldToken);
                final CharSequence accessOrderListenerCall = generateAccessOrderListenerCall(
                    fieldPrecedenceModel, indent + "        ", fieldToken);
                switch (typeToken.signal())
                {
                    case ENCODING:
                        generatePrimitiveEncoder(sb, containingClassName, propertyName,
                            accessOrderListenerCall, typeToken, indent);
                        break;
                    case BEGIN_ENUM:
                        generateEnumEncoder(sb, containingClassName,
                            accessOrderListenerCall, fieldToken, propertyName, typeToken, indent);
                        break;
                    case BEGIN_SET:
                        generateBitSetProperty(
                            sb, false, ENCODER, propertyName, accessOrderListenerCall,
                            fieldToken, typeToken, indent, typeName);
                        break;
                    case BEGIN_COMPOSITE:
                        generateCompositeProperty(
                            sb, false, ENCODER, propertyName, accessOrderListenerCall,
                            fieldToken, typeToken, indent, typeName);
                        break;
                    default:
                        break;
                }
            });
    }
    private void generateDecoderFields(
        final StringBuilder sb,
        final FieldPrecedenceModel fieldPrecedenceModel,
        final List<Token> tokens,
        final String indent)
    {
        Generators.forEachField(
            tokens,
            (fieldToken, typeToken) ->
            {
                final String propertyName = formatPropertyName(fieldToken.name());
                final String typeName = decoderName(typeToken.name());
                generateFieldIdMethod(sb, fieldToken, indent);
                generateFieldSinceVersionMethod(sb, fieldToken, indent);
                generateEncodingOffsetMethod(sb, propertyName, fieldToken.offset(), indent);
                generateEncodingLengthMethod(sb, propertyName, typeToken.encodedLength(), indent);
                generateFieldMetaAttributeMethod(sb, fieldToken, indent);
                generateAccessOrderListenerMethod(sb, fieldPrecedenceModel, indent + "    ", fieldToken);
                final CharSequence accessOrderListenerCall = generateAccessOrderListenerCall(
                    fieldPrecedenceModel, indent + "        ", fieldToken);
                switch (typeToken.signal())
                {
                    case ENCODING:
                        generatePrimitiveDecoder(
                            sb, false, propertyName, accessOrderListenerCall, fieldToken, typeToken, indent);
                        break;
                    case BEGIN_ENUM:
                        generateEnumDecoder(
                            sb, false, accessOrderListenerCall, fieldToken, propertyName, typeToken, indent);
                        break;
                    case BEGIN_SET:
                        generateBitSetProperty(
                            sb, false, DECODER, propertyName, accessOrderListenerCall,
                            fieldToken, typeToken, indent, typeName);
                        break;
                    case BEGIN_COMPOSITE:
                        generateCompositeProperty(
                            sb, false, DECODER, propertyName, accessOrderListenerCall,
                            fieldToken, typeToken, indent, typeName);
                        break;
                    default:
                        break;
                }
            });
    }
    private static void generateFieldIdMethod(final StringBuilder sb, final Token token, final String indent)
    {
        final String propertyName = formatPropertyName(token.name());
        sb.append("\n")
            .append(indent).append("    public static int ").append(propertyName).append("Id()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return ").append(token.id()).append(";\n")
            .append(indent).append("    }\n");
    }
    private static void generateEncodingOffsetMethod(
        final StringBuilder sb, final String name, final int offset, final String indent)
    {
        final String propertyName = formatPropertyName(name);
        sb.append("\n")
            .append(indent).append("    public static int ").append(propertyName).append("EncodingOffset()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return ").append(offset).append(";\n")
            .append(indent).append("    }\n");
    }
    private static void generateEncodingLengthMethod(
        final StringBuilder sb, final String name, final int length, final String indent)
    {
        final String propertyName = formatPropertyName(name);
        sb.append("\n")
            .append(indent).append("    public static int ").append(propertyName).append("EncodingLength()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return ").append(length).append(";\n")
            .append(indent).append("    }\n");
    }
    private static void generateFieldSinceVersionMethod(final StringBuilder sb, final Token token, final String indent)
    {
        final String propertyName = formatPropertyName(token.name());
        sb.append("\n")
            .append(indent).append("    public static int ").append(propertyName).append("SinceVersion()\n")
            .append(indent).append("    {\n")
            .append(indent).append("        return ").append(token.version()).append(";\n")
            .append(indent).append("    }\n");
    }
    private static void generateFieldMetaAttributeMethod(final StringBuilder sb, final Token token, final String indent)
    {
        final Encoding encoding = token.encoding();
        final String epoch = encoding.epoch() == null ? "" : encoding.epoch();
        final String timeUnit = encoding.timeUnit() == null ? "" : encoding.timeUnit();
        final String semanticType = encoding.semanticType() == null ? "" : encoding.semanticType();
        final String presence = encoding.presence().toString().toLowerCase();
        final String propertyName = formatPropertyName(token.name());
        sb.append("\n")
            .append(indent).append("    public static String ")
            .append(propertyName).append("MetaAttribute(final MetaAttribute metaAttribute)\n")
            .append(indent).append("    {\n")
            .append(indent).append("        if (MetaAttribute.PRESENCE == metaAttribute)\n")
            .append(indent).append("        {\n")
            .append(indent).append("            return \"").append(presence).append("\";\n")
            .append(indent).append("        }\n");
        if (!Strings.isEmpty(epoch))
        {
            sb.append(indent).append("        if (MetaAttribute.EPOCH == metaAttribute)\n")
                .append(indent).append("        {\n")
                .append(indent).append("            return \"").append(epoch).append("\";\n")
                .append(indent).append("        }\n");
        }
        if (!Strings.isEmpty(timeUnit))
        {
            sb.append(indent).append("        if (MetaAttribute.TIME_UNIT == metaAttribute)\n")
                .append(indent).append("        {\n")
                .append(indent).append("            return \"").append(timeUnit).append("\";\n")
                .append(indent).append("        }\n");
        }
        if (!Strings.isEmpty(semanticType))
        {
            sb.append(indent).append("        if (MetaAttribute.SEMANTIC_TYPE == metaAttribute)\n")
                .append(indent).append("        {\n")
                .append(indent).append("            return \"").append(semanticType).append("\";\n")
                .append(indent).append("        }\n");
        }
        sb.append("\n")
            .append(indent).append("        return \"\";\n")
            .append(indent).append("    }\n");
    }
    private void generateEnumDecoder(
        final StringBuilder sb,
        final boolean inComposite,
        final CharSequence accessOrderListenerCall,
        final Token fieldToken,
        final String propertyName,
        final Token typeToken,
        final String indent)
    {
        final String enumName = formatClassName(typeToken.applicableTypeName());
        final Encoding encoding = typeToken.encoding();
        final String javaTypeName = javaTypeName(encoding.primitiveType());
        if (fieldToken.isConstantEncoding())
        {
            final String enumValueStr = formatClassName(
                fieldToken.encoding().constValue().toString());
            new Formatter(sb).format(
                "\n" +
                indent + "    public %s %sRaw()\n" +
                indent + "    {\n" +
                indent + "        return %s.value();\n" +
                indent + "    }\n\n",
                javaTypeName,
                propertyName,
                enumValueStr);
            new Formatter(sb).format(
                "\n" +
                indent + "    public %s %s()\n" +
                indent + "    {\n" +
                indent + "        return %s;\n" +
                indent + "    }\n\n",
                enumName,
                propertyName,
                enumValueStr);
        }
        else
        {
            final String rawGetStr = generateGet(
                encoding.primitiveType(), "offset + " + typeToken.offset(), byteOrderString(encoding));
            new Formatter(sb).format(
                "\n" +
                indent + "    public %s %sRaw()\n" +
                indent + "    {\n" +
                "%s" +
                "%s" +
                indent + "        return %s;\n" +
                indent + "    }\n",
                javaTypeName,
                formatPropertyName(propertyName),
                generateFieldNotPresentCondition(inComposite, fieldToken.version(), encoding, indent),
                accessOrderListenerCall,
                rawGetStr);
            new Formatter(sb).format(
                "\n" +
                indent + "    public %s %s()\n" +
                indent + "    {\n" +
                "%s" +
                "%s" +
                indent + "        return %s.get(%s);\n" +
                indent + "    }\n\n",
                enumName,
                propertyName,
                generatePropertyNotPresentCondition(inComposite, DECODER, fieldToken, enumName, indent),
                accessOrderListenerCall,
                enumName,
                rawGetStr);
        }
    }
    private void generateEnumEncoder(
        final StringBuilder sb,
        final String containingClassName,
        final CharSequence accessOrderListenerCall,
        final Token fieldToken,
        final String propertyName,
        final Token typeToken,
        final String indent)
    {
        if (!fieldToken.isConstantEncoding())
        {
            final String enumName = formatClassName(typeToken.applicableTypeName());
            final Encoding encoding = typeToken.encoding();
            final int offset = typeToken.offset();
            final String byteOrderString = byteOrderString(encoding);
            new Formatter(sb).format("\n" +
                indent + "    public %s %s(final %s value)\n" +
                indent + "    {\n" +
                "%s" +
                indent + "        %s;\n" +
                indent + "        return this;\n" +
                indent + "    }\n",
                formatClassName(containingClassName),
                propertyName,
                enumName,
                accessOrderListenerCall,
                generatePut(encoding.primitiveType(), "offset + " + offset, "value.value()", byteOrderString));
        }
    }
    private void generateBitSetProperty(
        final StringBuilder sb,
        final boolean inComposite,
        final CodecType codecType,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token propertyToken,
        final Token bitsetToken,
        final String indent,
        final String bitSetName)
    {
        new Formatter(sb).format("\n" +
            indent + "    private final %s %s = new %s();\n",
            bitSetName,
            propertyName,
            bitSetName);
        generateFlyweightPropertyJavadoc(sb, indent + INDENT, propertyToken, bitSetName);
        new Formatter(sb).format("\n" +
            indent + "    public %s %s()\n" +
            indent + "    {\n" +
            "%s" +
            "%s" +
            indent + "        %s.wrap(buffer, offset + %d);\n" +
            indent + "        return %s;\n" +
            indent + "    }\n",
            bitSetName,
            propertyName,
            generatePropertyNotPresentCondition(inComposite, codecType, propertyToken, null, indent),
            accessOrderListenerCall,
            propertyName,
            bitsetToken.offset(),
            propertyName);
    }
    private void generateCompositeProperty(
        final StringBuilder sb,
        final boolean inComposite,
        final CodecType codecType,
        final String propertyName,
        final CharSequence accessOrderListenerCall,
        final Token propertyToken,
        final Token compositeToken,
        final String indent,
        final String compositeName)
    {
        new Formatter(sb).format("\n" +
            indent + "    private final %s %s = new %s();\n",
            compositeName,
            propertyName,
            compositeName);
        generateFlyweightPropertyJavadoc(sb, indent + INDENT, propertyToken, compositeName);
        new Formatter(sb).format("\n" +
            indent + "    public %s %s()\n" +
            indent + "    {\n" +
            "%s" +
            "%s" +
            indent + "        %s.wrap(buffer, offset + %d);\n" +
            indent + "        return %s;\n" +
            indent + "    }\n",
            compositeName,
            propertyName,
            generatePropertyNotPresentCondition(inComposite, codecType, propertyToken, null, indent),
            accessOrderListenerCall,
            propertyName,
            compositeToken.offset(),
            propertyName);
    }
    private String generateGet(final PrimitiveType type, final String index, final String byteOrder)
    {
        switch (type)
        {
            case CHAR:
            case INT8:
                return "buffer.getByte(" + index + ")";
            case UINT8:
                return "((short)(buffer.getByte(" + index + ") & 0xFF))";
            case INT16:
                return "buffer.getShort(" + index + byteOrder + ")";
            case UINT16:
                return "(buffer.getShort(" + index + byteOrder + ") & 0xFFFF)";
            case INT32:
                return "buffer.getInt(" + index + byteOrder + ")";
            case UINT32:
                return "(buffer.getInt(" + index + byteOrder + ") & 0xFFFF_FFFFL)";
            case FLOAT:
                return "buffer.getFloat(" + index + byteOrder + ")";
            case INT64:
            case UINT64:
                return "buffer.getLong(" + index + byteOrder + ")";
            case DOUBLE:
                return "buffer.getDouble(" + index + byteOrder + ")";
            default:
                break;
        }
        throw new IllegalArgumentException("primitive type not supported: " + type);
    }
    private String generatePut(
        final PrimitiveType type, final String index, final String value, final String byteOrder)
    {
        switch (type)
        {
            case CHAR:
            case INT8:
                return "buffer.putByte(" + index + ", " + value + ")";
            case UINT8:
                return "buffer.putByte(" + index + ", (byte)" + value + ")";
            case INT16:
                return "buffer.putShort(" + index + ", " + value + byteOrder + ")";
            case UINT16:
                return "buffer.putShort(" + index + ", (short)" + value + byteOrder + ")";
            case INT32:
                return "buffer.putInt(" + index + ", " + value + byteOrder + ")";
            case UINT32:
                return "buffer.putInt(" + index + ", (int)" + value + byteOrder + ")";
            case FLOAT:
                return "buffer.putFloat(" + index + ", " + value + byteOrder + ")";
            case INT64:
            case UINT64:
                return "buffer.putLong(" + index + ", " + value + byteOrder + ")";
            case DOUBLE:
                return "buffer.putDouble(" + index + ", " + value + byteOrder + ")";
            default:
                break;
        }
        throw new IllegalArgumentException("primitive type not supported: " + type);
    }
    private String generateChoiceIsEmpty(final PrimitiveType type)
    {
        return "\n" +
            "    public boolean isEmpty()\n" +
            "    {\n" +
            "        return " + generateChoiceIsEmptyInner(type) + ";\n" +
            "    }\n";
    }
    private String generateChoiceIsEmptyInner(final PrimitiveType type)
    {
        switch (type)
        {
            case UINT8:
                return "0 == buffer.getByte(offset)";
            case UINT16:
                return "0 == buffer.getShort(offset)";
            case UINT32:
                return "0 == buffer.getInt(offset)";
            case UINT64:
                return "0 == buffer.getLong(offset)";
            default:
                break;
        }
        throw new IllegalArgumentException("primitive type not supported: " + type);
    }
    private String generateChoiceGet(final PrimitiveType type, final String bitIndex, final String byteOrder)
    {
        switch (type)
        {
            case UINT8:
                return "0 != (buffer.getByte(offset) & (1 << " + bitIndex + "))";
            case UINT16:
                return "0 != (buffer.getShort(offset" + byteOrder + ") & (1 << " + bitIndex + "))";
            case UINT32:
                return "0 != (buffer.getInt(offset" + byteOrder + ") & (1 << " + bitIndex + "))";
            case UINT64:
                return "0 != (buffer.getLong(offset" + byteOrder + ") & (1L << " + bitIndex + "))";
            default:
                break;
        }
        throw new IllegalArgumentException("primitive type not supported: " + type);
    }
    private String generateStaticChoiceGet(final PrimitiveType type, final String bitIndex)
    {
        switch (type)
        {
            case UINT8:
            case UINT16:
            case UINT32:
                return "0 != (value & (1 << " + bitIndex + "))";
            case UINT64:
                return "0 != (value & (1L << " + bitIndex + "))";
            default:
                break;
        }
        throw new IllegalArgumentException("primitive type not supported: " + type);
    }
    private String generateChoicePut(final PrimitiveType type, final String bitIdx, final String byteOrder)
    {
        switch (type)
        {
            case UINT8:
                return
                    "        byte bits = buffer.getByte(offset);\n" +
                    "        bits = (byte)(value ? bits | (1 << " + bitIdx + ") : bits & ~(1 << " + bitIdx + "));\n" +
                    "        buffer.putByte(offset, bits);";
            case UINT16:
                return
                    "        short bits = buffer.getShort(offset" + byteOrder + ");\n" +
                    "        bits = (short)(value ? bits | (1 << " + bitIdx + ") : bits & ~(1 << " + bitIdx + "));\n" +
                    "        buffer.putShort(offset, bits" + byteOrder + ");";
            case UINT32:
                return
                    "        int bits = buffer.getInt(offset" + byteOrder + ");\n" +
                    "        bits = value ? bits | (1 << " + bitIdx + ") : bits & ~(1 << " + bitIdx + ");\n" +
                    "        buffer.putInt(offset, bits" + byteOrder + ");";
            case UINT64:
                return
                    "        long bits = buffer.getLong(offset" + byteOrder + ");\n" +
                    "        bits = value ? bits | (1L << " + bitIdx + ") : bits & ~(1L << " + bitIdx + ");\n" +
                    "        buffer.putLong(offset, bits" + byteOrder + ");";
            default:
                break;
        }
        throw new IllegalArgumentException("primitive type not supported: " + type);
    }
    private String generateStaticChoicePut(final PrimitiveType type, final String bitIdx)
    {
        switch (type)
        {
            case UINT8:
                return
                    "        return (byte)(value ? bits | (1 << " + bitIdx + ") : bits & ~(1 << " + bitIdx + "));\n";
            case UINT16:
                return
                    "        return (short)(value ? bits | (1 << " + bitIdx + ") : bits & ~(1 << " + bitIdx + "));\n";
            case UINT32:
                return
                    "        return value ? bits | (1 << " + bitIdx + ") : bits & ~(1 << " + bitIdx + ");\n";
            case UINT64:
                return
                    "        return value ? bits | (1L << " + bitIdx + ") : bits & ~(1L << " + bitIdx + ");\n";
            default:
                break;
        }
        throw new IllegalArgumentException("primitive type not supported: " + type);
    }
    private void generateEncoderDisplay(final StringBuilder sb, final String decoderName)
    {
        appendToString(sb);
        sb.append('\n');
        append(sb, INDENT, "public StringBuilder appendTo(final StringBuilder builder)");
        append(sb, INDENT, "{");
        append(sb, INDENT, "    if (null == buffer)");
        append(sb, INDENT, "    {");
        append(sb, INDENT, "        return builder;");
        append(sb, INDENT, "    }");
        sb.append('\n');
        append(sb, INDENT, "    final " + decoderName + " decoder = new " + decoderName + "();");
        append(sb, INDENT, "    decoder.wrap(buffer, offset, BLOCK_LENGTH, SCHEMA_VERSION);");
        sb.append('\n');
        append(sb, INDENT, "    return decoder.appendTo(builder);");
        append(sb, INDENT, "}");
    }
    private CharSequence generateCompositeEncoderDisplay(final String decoderName)
    {
        final StringBuilder sb = new StringBuilder();
        appendToString(sb);
        sb.append('\n');
        append(sb, INDENT, "public StringBuilder appendTo(final StringBuilder builder)");
        append(sb, INDENT, "{");
        append(sb, INDENT, "    if (null == buffer)");
        append(sb, INDENT, "    {");
        append(sb, INDENT, "        return builder;");
        append(sb, INDENT, "    }");
        sb.append('\n');
        append(sb, INDENT, "    final " + decoderName + " decoder = new " + decoderName + "();");
        append(sb, INDENT, "    decoder.wrap(buffer, offset);");
        sb.append('\n');
        append(sb, INDENT, "    return decoder.appendTo(builder);");
        append(sb, INDENT, "}");
        return sb;
    }
    private CharSequence generateCompositeDecoderDisplay(final List<Token> tokens)
    {
        final StringBuilder sb = new StringBuilder();
        appendToString(sb);
        sb.append('\n');
        append(sb, INDENT, "public StringBuilder appendTo(final StringBuilder builder)");
        append(sb, INDENT, "{");
        append(sb, INDENT, "    if (null == buffer)");
        append(sb, INDENT, "    {");
        append(sb, INDENT, "        return builder;");
        append(sb, INDENT, "    }");
        sb.append('\n');
        Separator.BEGIN_COMPOSITE.appendToGeneratedBuilder(sb, INDENT + INDENT);
        int lengthBeforeLastGeneratedSeparator = -1;
        for (int i = 1, end = tokens.size() - 1; i < end;)
        {
            final Token encodingToken = tokens.get(i);
            final String propertyName = formatPropertyName(encodingToken.name());
            lengthBeforeLastGeneratedSeparator = writeTokenDisplay(propertyName, encodingToken, sb, INDENT + INDENT);
            i += encodingToken.componentTokenCount();
        }
        if (-1 != lengthBeforeLastGeneratedSeparator)
        {
            sb.setLength(lengthBeforeLastGeneratedSeparator);
        }
        Separator.END_COMPOSITE.appendToGeneratedBuilder(sb, INDENT + INDENT);
        sb.append('\n');
        append(sb, INDENT, "    return builder;");
        append(sb, INDENT, "}");
        return sb;
    }
    private CharSequence generateChoiceDisplay(final List<Token> tokens)
    {
        final StringBuilder sb = new StringBuilder();
        appendToString(sb);
        sb.append('\n');
        append(sb, INDENT, "public StringBuilder appendTo(final StringBuilder builder)");
        append(sb, INDENT, "{");
        Separator.BEGIN_SET.appendToGeneratedBuilder(sb, INDENT + INDENT);
        append(sb, INDENT, "    boolean atLeastOne = false;");
        for (final Token token : tokens)
        {
            if (token.signal() == Signal.CHOICE)
            {
                final String choiceName = formatPropertyName(token.name());
                append(sb, INDENT, "    if (" + choiceName + "())");
                append(sb, INDENT, "    {");
                append(sb, INDENT, "        if (atLeastOne)");
                append(sb, INDENT, "        {");
                Separator.ENTRY.appendToGeneratedBuilder(sb, INDENT + INDENT + INDENT + INDENT);
                append(sb, INDENT, "        }");
                append(sb, INDENT, "        builder.append(\"" + choiceName + "\");");
                append(sb, INDENT, "        atLeastOne = true;");
                append(sb, INDENT, "    }");
            }
        }
        Separator.END_SET.appendToGeneratedBuilder(sb, INDENT + INDENT);
        sb.append('\n');
        append(sb, INDENT, "    return builder;");
        append(sb, INDENT, "}");
        return sb;
    }
    private void generateDecoderDisplay(
        final StringBuilder sb,
        final String name,
        final List<Token> tokens,
        final List<Token> groups,
        final List<Token> varData)
    {
        appendMessageToString(sb, decoderName(name));
        sb.append('\n');
        append(sb, INDENT, "public StringBuilder appendTo(final StringBuilder builder)");
        append(sb, INDENT, "{");
        append(sb, INDENT, "    if (null == buffer)");
        append(sb, INDENT, "    {");
        append(sb, INDENT, "        return builder;");
        append(sb, INDENT, "    }");
        sb.append('\n');
        append(sb, INDENT, "    final int originalLimit = limit();");
        append(sb, INDENT, "    limit(offset + actingBlockLength);");
        append(sb, INDENT, "    builder.append(\"[" + name + "](sbeTemplateId=\");");
        append(sb, INDENT, "    builder.append(TEMPLATE_ID);");
        append(sb, INDENT, "    builder.append(\"|sbeSchemaId=\");");
        append(sb, INDENT, "    builder.append(SCHEMA_ID);");
        append(sb, INDENT, "    builder.append(\"|sbeSchemaVersion=\");");
        append(sb, INDENT, "    if (parentMessage.actingVersion != SCHEMA_VERSION)");
        append(sb, INDENT, "    {");
        append(sb, INDENT, "        builder.append(parentMessage.actingVersion);");
        append(sb, INDENT, "        builder.append('/');");
        append(sb, INDENT, "    }");
        append(sb, INDENT, "    builder.append(SCHEMA_VERSION);");
        append(sb, INDENT, "    builder.append(\"|sbeBlockLength=\");");
        append(sb, INDENT, "    if (actingBlockLength != BLOCK_LENGTH)");
        append(sb, INDENT, "    {");
        append(sb, INDENT, "        builder.append(actingBlockLength);");
        append(sb, INDENT, "        builder.append('/');");
        append(sb, INDENT, "    }");
        append(sb, INDENT, "    builder.append(BLOCK_LENGTH);");
        append(sb, INDENT, "    builder.append(\"):\");");
        appendDecoderDisplay(sb, tokens, groups, varData, INDENT + INDENT);
        sb.append('\n');
        append(sb, INDENT, "    limit(originalLimit);");
        sb.append('\n');
        append(sb, INDENT, "    return builder;");
        append(sb, INDENT, "}");
    }
    private void appendGroupInstanceDecoderDisplay(
        final StringBuilder sb,
        final List<Token> fields,
        final List<Token> groups,
        final List<Token> varData,
        final String baseIndent)
    {
        final String indent = baseIndent + INDENT;
        sb.append('\n');
        append(sb, indent, "public StringBuilder appendTo(final StringBuilder builder)");
        append(sb, indent, "{");
        append(sb, indent, "    if (null == buffer)");
        append(sb, indent, "    {");
        append(sb, indent, "        return builder;");
        append(sb, indent, "    }");
        sb.append('\n');
        Separator.BEGIN_COMPOSITE.appendToGeneratedBuilder(sb, indent + INDENT);
        appendDecoderDisplay(sb, fields, groups, varData, indent + INDENT);
        Separator.END_COMPOSITE.appendToGeneratedBuilder(sb, indent + INDENT);
        sb.append('\n');
        append(sb, indent, "    return builder;");
        append(sb, indent, "}");
    }
    private void appendDecoderDisplay(
        final StringBuilder sb,
        final List<Token> fields,
        final List<Token> groups,
        final List<Token> varData,
        final String indent)
    {
        int lengthBeforeLastGeneratedSeparator = -1;
        for (int i = 0, size = fields.size(); i < size;)
        {
            final Token fieldToken = fields.get(i);
            if (fieldToken.signal() == Signal.BEGIN_FIELD)
            {
                final Token encodingToken = fields.get(i + 1);
                final String fieldName = formatPropertyName(fieldToken.name());
                lengthBeforeLastGeneratedSeparator = writeTokenDisplay(fieldName, encodingToken, sb, indent);
                i += fieldToken.componentTokenCount();
            }
            else
            {
                ++i;
            }
        }
        for (int i = 0, size = groups.size(); i < size; i++)
        {
            final Token groupToken = groups.get(i);
            if (groupToken.signal() != Signal.BEGIN_GROUP)
            {
                throw new IllegalStateException("tokens must begin with BEGIN_GROUP: token=" + groupToken);
            }
            final String groupName = formatPropertyName(groupToken.name());
            final String groupDecoderName = decoderName(groupToken.name());
            append(
                sb, indent, "builder.append(\"" + groupName + Separator.KEY_VALUE + Separator.BEGIN_GROUP + "\");");
            append(sb, indent, "final int " + groupName + "OriginalOffset = " + groupName + ".offset;");
            append(sb, indent, "final int " + groupName + "OriginalIndex = " + groupName + ".index;");
            append(sb, indent, "final " + groupDecoderName + " " + groupName + " = this." + groupName + "();");
            append(sb, indent, "if (" + groupName + ".count() > 0)");
            append(sb, indent, "{");
            append(sb, indent, "    while (" + groupName + ".hasNext())");
            append(sb, indent, "    {");
            append(sb, indent, "        " + groupName + ".next().appendTo(builder);");
            Separator.ENTRY.appendToGeneratedBuilder(sb, indent + INDENT + INDENT);
            append(sb, indent, "    }");
            append(sb, indent, "    builder.setLength(builder.length() - 1);");
            append(sb, indent, "}");
            append(sb, indent, groupName + ".offset = " + groupName + "OriginalOffset;");
            append(sb, indent, groupName + ".index = " + groupName + "OriginalIndex;");
            Separator.END_GROUP.appendToGeneratedBuilder(sb, indent);
            lengthBeforeLastGeneratedSeparator = sb.length();
            Separator.FIELD.appendToGeneratedBuilder(sb, indent);
            i = findEndSignal(groups, i, Signal.END_GROUP, groupToken.name());
        }
        for (int i = 0, size = varData.size(); i < size;)
        {
            final Token varDataToken = varData.get(i);
            if (varDataToken.signal() != Signal.BEGIN_VAR_DATA)
            {
                throw new IllegalStateException("tokens must begin with BEGIN_VAR_DATA: token=" + varDataToken);
            }
            final String characterEncoding = varData.get(i + 3).encoding().characterEncoding();
            final String varDataName = formatPropertyName(varDataToken.name());
            append(sb, indent, "builder.append(\"" + varDataName + Separator.KEY_VALUE + "\");");
            if (null == characterEncoding)
            {
                final String name = Generators.toUpperFirstChar(varDataToken.name());
                append(sb, indent, "builder.append(skip" + name + "()).append(\" bytes of raw data\");");
            }
            else
            {
                if (isAsciiEncoding(characterEncoding))
                {
                    append(sb, indent, "builder.append('\\'');");
                    append(sb, indent, formatGetterName(varDataToken.name()) + "(builder);");
                    append(sb, indent, "builder.append('\\'');");
                }
                else
                {
                    append(sb, indent, "builder.append('\\'').append(" + varDataName + "()).append('\\'');");
                }
            }
            lengthBeforeLastGeneratedSeparator = sb.length();
            Separator.FIELD.appendToGeneratedBuilder(sb, indent);
            i += varDataToken.componentTokenCount();
        }
        if (-1 != lengthBeforeLastGeneratedSeparator)
        {
            sb.setLength(lengthBeforeLastGeneratedSeparator);
        }
    }
    private int writeTokenDisplay(
        final String fieldName, final Token typeToken, final StringBuilder sb, final String indent)
    {
        if (typeToken.encodedLength() <= 0 || typeToken.isConstantEncoding())
        {
            return -1;
        }
        append(sb, indent, "builder.append(\"" + fieldName + Separator.KEY_VALUE + "\");");
        switch (typeToken.signal())
        {
            case ENCODING:
                if (typeToken.arrayLength() > 1)
                {
                    if (typeToken.encoding().primitiveType() == PrimitiveType.CHAR)
                    {
                        append(sb, indent,
                            "for (int i = 0; i < " + fieldName + "Length() && this." + fieldName + "(i) > 0; i++)");
                        append(sb, indent, "{");
                        append(sb, indent, "    builder.append((char)this." + fieldName + "(i));");
                        append(sb, indent, "}");
                    }
                    else
                    {
                        Separator.BEGIN_ARRAY.appendToGeneratedBuilder(sb, indent);
                        append(sb, indent, "if (" + fieldName + "Length() > 0)");
                        append(sb, indent, "{");
                        append(sb, indent, "    for (int i = 0; i < " + fieldName + "Length(); i++)");
                        append(sb, indent, "    {");
                        append(sb, indent, "        builder.append(this." + fieldName + "(i));");
                        Separator.ENTRY.appendToGeneratedBuilder(sb, indent + INDENT + INDENT);
                        append(sb, indent, "    }");
                        append(sb, indent, "    builder.setLength(builder.length() - 1);");
                        append(sb, indent, "}");
                        Separator.END_ARRAY.appendToGeneratedBuilder(sb, indent);
                    }
                }
                else
                {
                    // have to duplicate because of checkstyle :/
                    append(sb, indent, "builder.append(this." + fieldName + "());");
                }
                break;
            case BEGIN_ENUM:
                append(sb, indent, "builder.append(this." + fieldName + "());");
                break;
            case BEGIN_SET:
            case BEGIN_COMPOSITE:
            {
                final String typeName = formatClassName(decoderName(typeToken.applicableTypeName()));
                append(sb, indent, "final " + typeName + " " + fieldName + " = this." + fieldName + "();");
                append(sb, indent, "if (null != " + fieldName + ")");
                append(sb, indent, "{");
                append(sb, indent, "    " + fieldName + ".appendTo(builder);");
                append(sb, indent, "}");
                append(sb, indent, "else");
                append(sb, indent, "{");
                append(sb, indent, "    builder.append(\"null\");");
                append(sb, indent, "}");
                break;
            }
            default:
                break;
        }
        final int lengthBeforeFieldSeparator = sb.length();
        Separator.FIELD.appendToGeneratedBuilder(sb, indent);
        return lengthBeforeFieldSeparator;
    }
    private void appendToString(final StringBuilder sb)
    {
        sb.append('\n');
        append(sb, INDENT, "public String toString()");
        append(sb, INDENT, "{");
        append(sb, INDENT, "    if (null == buffer)");
        append(sb, INDENT, "    {");
        append(sb, INDENT, "        return \"\";");
        append(sb, INDENT, "    }");
        sb.append('\n');
        append(sb, INDENT, "    return appendTo(new StringBuilder()).toString();");
        append(sb, INDENT, "}");
    }
    private void appendMessageToString(final StringBuilder sb, final String decoderName)
    {
        sb.append('\n');
        append(sb, INDENT, "public String toString()");
        append(sb, INDENT, "{");
        append(sb, INDENT, "    if (null == buffer)");
        append(sb, INDENT, "    {");
        append(sb, INDENT, "        return \"\";");
        append(sb, INDENT, "    }");
        sb.append('\n');
        append(sb, INDENT, "    final " + decoderName + " decoder = new " + decoderName + "();");
        append(sb, INDENT, "    decoder.wrap(buffer, offset, actingBlockLength, actingVersion);");
        sb.append('\n');
        append(sb, INDENT, "    return decoder.appendTo(new StringBuilder()).toString();");
        append(sb, INDENT, "}");
    }
    private void generateMessageLength(
        final StringBuilder sb,
        final String className,
        final boolean isParent,
        final List<Token> groups,
        final List<Token> varData,
        final String baseIndent)
    {
        final String methodIndent = baseIndent + INDENT;
        final String bodyIndent = methodIndent + INDENT;
        append(sb, methodIndent, "");
        append(sb, methodIndent, "public " + className + " sbeSkip()");
        append(sb, methodIndent, "{");
        if (isParent)
        {
            append(sb, bodyIndent, "sbeRewind();");
        }
        for (int i = 0, size = groups.size(); i < size; i++)
        {
            final Token groupToken = groups.get(i);
            if (groupToken.signal() != Signal.BEGIN_GROUP)
            {
                throw new IllegalStateException("tokens must begin with BEGIN_GROUP: token=" + groupToken);
            }
            final String groupName = formatPropertyName(groupToken.name());
            final String groupDecoderName = decoderName(groupToken.name());
            append(sb, bodyIndent, groupDecoderName + " " + groupName + " = this." + groupName + "();");
            append(sb, bodyIndent, "if (" + groupName + ".count() > 0)");
            append(sb, bodyIndent, "{");
            append(sb, bodyIndent, "    while (" + groupName + ".hasNext())");
            append(sb, bodyIndent, "    {");
            append(sb, bodyIndent, "        " + groupName + ".next();");
            append(sb, bodyIndent, "        " + groupName + ".sbeSkip();");
            append(sb, bodyIndent, "    }");
            append(sb, bodyIndent, "}");
            i = findEndSignal(groups, i, Signal.END_GROUP, groupToken.name());
        }
        for (int i = 0, size = varData.size(); i < size;)
        {
            final Token varDataToken = varData.get(i);
            if (varDataToken.signal() != Signal.BEGIN_VAR_DATA)
            {
                throw new IllegalStateException("tokens must begin with BEGIN_VAR_DATA: token=" + varDataToken);
            }
            final String varDataName = formatPropertyName(varDataToken.name());
            append(sb, bodyIndent, "skip" + Generators.toUpperFirstChar(varDataName) + "();");
            i += varDataToken.componentTokenCount();
        }
        sb.append('\n');
        append(sb, bodyIndent, "return this;");
        append(sb, methodIndent, "}");
    }
    private static String validateBufferImplementation(
        final String fullyQualifiedBufferImplementation, final Class<?> bufferClass)
    {
        Verify.notNull(fullyQualifiedBufferImplementation, "fullyQualifiedBufferImplementation");
        try
        {
            final Class<?> clazz = Class.forName(fullyQualifiedBufferImplementation);
            if (!bufferClass.isAssignableFrom(clazz))
            {
                throw new IllegalArgumentException(
                    fullyQualifiedBufferImplementation + " doesn't implement " + bufferClass.getName());
            }
            return clazz.getSimpleName();
        }
        catch (final ClassNotFoundException ex)
        {
            throw new IllegalArgumentException("Unable to find " + fullyQualifiedBufferImplementation, ex);
        }
    }
    private String implementsInterface(final String interfaceName)
    {
        return shouldGenerateInterfaces ? " implements " + interfaceName : "";
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.cpp;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.SbeTool;
import uk.co.real_logic.sbe.ValidationUtil;
import java.nio.ByteOrder;
import java.util.EnumMap;
import java.util.Map;
import static uk.co.real_logic.sbe.generation.Generators.toLowerFirstChar;
import static uk.co.real_logic.sbe.generation.Generators.toUpperFirstChar;
/**
 * Utilities for mapping between IR and the C++ language.
 */
public class CppUtil
{
    private static final Map<PrimitiveType, String> PRIMITIVE_TYPE_STRING_ENUM_MAP = new EnumMap<>(PrimitiveType.class);
    static
    {
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.CHAR, "char");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT8, "std::int8_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT16, "std::int16_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT32, "std::int32_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.INT64, "std::int64_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT8, "std::uint8_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT16, "std::uint16_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT32, "std::uint32_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.UINT64, "std::uint64_t");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.FLOAT, "float");
        PRIMITIVE_TYPE_STRING_ENUM_MAP.put(PrimitiveType.DOUBLE, "double");
    }
    /**
     * Map the name of a {@link uk.co.real_logic.sbe.PrimitiveType} to a C++98 primitive type name.
     *
     * @param primitiveType to map.
     * @return the name of the Java primitive that most closely maps.
     */
    public static String cppTypeName(final PrimitiveType primitiveType)
    {
        return PRIMITIVE_TYPE_STRING_ENUM_MAP.get(primitiveType);
    }
    /**
     * Format a String as a property name.
     *
     * @param value to be formatted.
     * @return the string formatted as a property name.
     */
    public static String formatPropertyName(final String value)
    {
        return formatForCppKeyword(toLowerFirstChar(value));
    }
    /**
     * Format a String with a suffix in case it's a keyword.
     *
     * @param value to be formatted.
     * @return the formatted string.
     */
    public static String formatForCppKeyword(final String value)
    {
        if (ValidationUtil.isCppKeyword(value))
        {
            final String keywordAppendToken = System.getProperty(SbeTool.KEYWORD_APPEND_TOKEN);
            if (null == keywordAppendToken)
            {
                throw new IllegalStateException(
                    "Invalid property name='" + value +
                    "' please correct the schema or consider setting system property: " + SbeTool.KEYWORD_APPEND_TOKEN);
            }
            return value + keywordAppendToken;
        }
        return value;
    }
    /**
     * Format a String as a class name.
     *
     * @param value to be formatted.
     * @return the string formatted as a class name.
     */
    public static String formatClassName(final String value)
    {
        return toUpperFirstChar(value);
    }
    /**
     * Return the Cpp98 formatted byte order encoding string to use for a given byte order and primitiveType.
     *
     * @param byteOrder     of the {@link uk.co.real_logic.sbe.ir.Token}.
     * @param primitiveType of the {@link uk.co.real_logic.sbe.ir.Token}.
     * @return the string formatted as the byte ordering encoding.
     */
    public static String formatByteOrderEncoding(final ByteOrder byteOrder, final PrimitiveType primitiveType)
    {
        switch (primitiveType.size())
        {
            case 2:
                return "SBE_" + byteOrder + "_ENCODE_16";
            case 4:
                return "SBE_" + byteOrder + "_ENCODE_32";
            case 8:
                return "SBE_" + byteOrder + "_ENCODE_64";
            default:
                return "";
        }
    }
    /**
     * Generate a count of closing braces, one on each line.
     *
     * @param count of closing braces.
     * @return A string with count of closing braces.
     */
    public static String closingBraces(final int count)
    {
        final StringBuilder sb = new StringBuilder();
        for (int i = 0; i < count; i++)
        {
            sb.append("}\n");
        }
        return sb.toString();
    }
    static CharSequence generateLiteral(final PrimitiveType type, final String value)
    {
        String literal = "";
        switch (type)
        {
            case CHAR:
            case UINT8:
            case UINT16:
            case INT8:
            case INT16:
                literal = "static_cast<" + cppTypeName(type) + ">(" + value + ")";
                break;
            case UINT32:
                literal = "UINT32_C(0x" + Integer.toHexString((int)Long.parseLong(value)) + ")";
                break;
            case INT32:
                final long intValue = Long.parseLong(value);
                if (intValue == Integer.MIN_VALUE)
                {
                    literal = "INT32_MIN";
                }
                else
                {
                    literal = "INT32_C(" + value + ")";
                }
                break;
            case FLOAT:
                literal = value.endsWith("NaN") ? "SBE_FLOAT_NAN" : value + "f";
                break;
            case INT64:
                final long longValue = Long.parseLong(value);
                if (longValue == Long.MIN_VALUE)
                {
                    literal = "INT64_MIN";
                }
                else
                {
                    literal = "INT64_C(" + value + ")";
                }
                break;
            case UINT64:
                literal = "UINT64_C(0x" + Long.toHexString(Long.parseLong(value)) + ")";
                break;
            case DOUBLE:
                literal = value.endsWith("NaN") ? "SBE_DOUBLE_NAN" : value;
                break;
        }
        return literal;
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.java;
import org.agrona.Strings;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.SbeTool;
import uk.co.real_logic.sbe.ValidationUtil;
import uk.co.real_logic.sbe.generation.Generators;
import uk.co.real_logic.sbe.ir.Token;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
/**
 * Utilities for mapping between {@link uk.co.real_logic.sbe.ir.Ir} and the Java language.
 */
public class JavaUtil
{
    /**
     * Separator symbols for {@link Object#toString()} implementations on codecs.
     */
    enum Separator
    {
        BEGIN_GROUP('['),
        END_GROUP(']'),
        BEGIN_COMPOSITE('('),
        END_COMPOSITE(')'),
        BEGIN_SET('{'),
        END_SET('}'),
        BEGIN_ARRAY('['),
        END_ARRAY(']'),
        FIELD('|'),
        KEY_VALUE('='),
        ENTRY(',');
        private final char symbol;
        Separator(final char symbol)
        {
            this.symbol = symbol;
        }
        void appendToGeneratedBuilder(final StringBuilder builder, final String indent)
        {
            builder.append(indent).append("builder.append('").append(symbol).append("');").append('\n');
        }
        /**
         * {@inheritDoc}
         */
        public String toString()
        {
            return String.valueOf(symbol);
        }
    }
    private static final Map<PrimitiveType, String> TYPE_NAME_BY_PRIMITIVE_TYPE_MAP =
        new EnumMap<>(PrimitiveType.class);
    static
    {
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.CHAR, "byte");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT8, "byte");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT16, "short");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT32, "int");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.INT64, "long");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT8, "short");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT16, "int");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT32, "long");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.UINT64, "long");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.FLOAT, "float");
        TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.put(PrimitiveType.DOUBLE, "double");
    }
    /**
     * Indexes known charset aliases to the name of the instance in {@link StandardCharsets}.
     */
    static final HashMap<String, String> STD_CHARSETS = new HashMap<>();
    static
    {
        try
        {
            for (final Field field : StandardCharsets.class.getDeclaredFields())
            {
                if (Charset.class.isAssignableFrom(field.getType()) && Modifier.isStatic(field.getModifiers()) &&
                    Modifier.isPublic(field.getModifiers()))
                {
                    final Charset charset = (Charset)field.get(null);
                    final String name = field.getName();
                    String oldName = STD_CHARSETS.put(charset.name(), name);
                    if (null != oldName)
                    {
                        throw new IllegalStateException("Duplicate charset alias: old=" + oldName + ", new=" + name);
                    }
                    for (final String alias : charset.aliases())
                    {
                        oldName = STD_CHARSETS.put(alias, name);
                        if (null != oldName)
                        {
                            throw new IllegalStateException(
                                "Duplicate charset alias: old=" + oldName + ", new=" + alias);
                        }
                    }
                }
            }
        }
        catch (final IllegalAccessException ex)
        {
            throw new RuntimeException(ex);
        }
    }
    /**
     * Map the name of a {@link uk.co.real_logic.sbe.PrimitiveType} to a Java primitive type name.
     *
     * @param primitiveType to map.
     * @return the name of the Java primitive that most closely maps.
     */
    public static String javaTypeName(final PrimitiveType primitiveType)
    {
        return TYPE_NAME_BY_PRIMITIVE_TYPE_MAP.get(primitiveType);
    }
    /**
     * Format a property name for generated code.
     * <p>
     * If the formatted property name is a keyword then {@link SbeTool#KEYWORD_APPEND_TOKEN} is appended if set.
     *
     * @param value to be formatted.
     * @return the string formatted as a property name.
     * @throws IllegalStateException if a keyword and {@link SbeTool#KEYWORD_APPEND_TOKEN} is not set.
     */
    public static String formatPropertyName(final String value)
    {
        return formatForJavaKeyword(Generators.toLowerFirstChar(value));
    }
    /**
     * Format a name for generated code.
     * <p>
     * If the formatted name is a keyword then {@link SbeTool#KEYWORD_APPEND_TOKEN} is appended if set.
     *
     * @param value to be formatted.
     * @return the string formatted as a valid name.
     * @throws IllegalStateException if a keyword and {@link SbeTool#KEYWORD_APPEND_TOKEN} is not set.
     */
    public static String formatForJavaKeyword(final String value)
    {
        if (ValidationUtil.isJavaKeyword(value))
        {
            final String keywordAppendToken = System.getProperty(SbeTool.KEYWORD_APPEND_TOKEN);
            if (null == keywordAppendToken)
            {
                throw new IllegalStateException(
                    "Invalid property name='" + value +
                    "' please correct the schema or consider setting system property: " + SbeTool.KEYWORD_APPEND_TOKEN);
            }
            return value + keywordAppendToken;
        }
        return value;
    }
    /**
     * Format a Getter name for generated code.
     *
     * @param propertyName to be formatted.
     * @return the property name formatted as a getter name.
     */
    public static String formatGetterName(final String propertyName)
    {
        return "get" + Generators.toUpperFirstChar(propertyName);
    }
    /**
     * Format a class name for the generated code.
     *
     * @param className to be formatted.
     * @return the formatted class name.
     */
    public static String formatClassName(final String className)
    {
        return Generators.toUpperFirstChar(className);
    }
    /**
     * Shortcut to append a line of generated code.
     *
     * @param builder string builder to which to append the line.
     * @param indent  current text indentation.
     * @param line    line to be appended.
     */
    public static void append(final StringBuilder builder, final String indent, final String line)
    {
        builder.append(indent).append(line).append('\n');
    }
    /**
     * Code to fetch an instance of {@link java.nio.charset.Charset} corresponding to the given encoding.
     *
     * @param encoding as a string name (eg. UTF-8).
     * @return the code to fetch the associated Charset.
     */
    public static String charset(final String encoding)
    {
        final String charsetName = STD_CHARSETS.get(encoding);
        if (null != charsetName)
        {
            return "java.nio.charset.StandardCharsets." + charsetName;
        }
        else
        {
            final String canonicalName = Charset.isSupported(encoding) ? Charset.forName(encoding).name() : encoding;
            return "java.nio.charset.Charset.forName(\"" + canonicalName + "\")";
        }
    }
    /**
     * Code to fetch the name of the {@link Charset} given the encoding.
     *
     * @param encoding as a string name (eg. UTF-8).
     * @return the code to fetch the associated Charset name.
     */
    public static String charsetName(final String encoding)
    {
        final String charsetName = STD_CHARSETS.get(encoding);
        if (null != charsetName)
        {
            return "java.nio.charset.StandardCharsets." + charsetName + ".name()";
        }
        else
        {
            return "\"" + (Charset.isSupported(encoding) ? Charset.forName(encoding).name() : encoding) + "\"";
        }
    }
    /**
     * Checks if the given encoding represents an ASCII charset.
     *
     * @param encoding as a string name (e.g. ASCII).
     * @return {@code true} if the encoding denotes an ASCII charset.
     */
    public static boolean isAsciiEncoding(final String encoding)
    {
        return "US_ASCII".equals(STD_CHARSETS.get(encoding));
    }
    /**
     * Checks if the given encoding represents a UTF-8 charset.
     *
     * @param encoding as a string name (e.g. unicode-1-1-utf-8).
     * @return {@code true} if the encoding denotes a UTF-8 charset.
     */
    public static boolean isUtf8Encoding(final String encoding)
    {
        return "UTF_8".equals(STD_CHARSETS.get(encoding));
    }
    /**
     * Generate a literal value to be used in code generation.
     *
     * @param type  of the lateral value.
     * @param value of the lateral.
     * @return a String representation of the Java literal.
     */
    public static String generateLiteral(final PrimitiveType type, final String value)
    {
        String literal = "";
        final String castType = javaTypeName(type);
        switch (type)
        {
            case CHAR:
            case UINT8:
            case INT8:
            case INT16:
                literal = "(" + castType + ")" + value;
                break;
            case UINT16:
            case INT32:
                literal = value;
                break;
            case UINT32:
                literal = value + "L";
                break;
            case FLOAT:
                literal = value.endsWith("NaN") ? "Float.NaN" : value + "f";
                break;
            case INT64:
                literal = value + "L";
                break;
            case UINT64:
                literal = "0x" + Long.toHexString(Long.parseLong(value)) + "L";
                break;
            case DOUBLE:
                literal = value.endsWith("NaN") ? "Double.NaN" : value + "d";
                break;
        }
        return literal;
    }
    /**
     * Generate the Javadoc comment header for a type.
     *
     * @param sb        to append to.
     * @param indent    level for the comment.
     * @param typeToken for the type.
     */
    public static void generateTypeJavadoc(final StringBuilder sb, final String indent, final Token typeToken)
    {
        final String description = typeToken.description();
        if (Strings.isEmpty(description))
        {
            return;
        }
        sb.append('\n')
            .append(indent).append("/**\n")
            .append(indent).append(" * ");
        escapeJavadoc(sb, description);
        sb.append('\n')
            .append(indent).append(" */\n");
    }
    /**
     * Generate the Javadoc comment header for a bitset choice option decode method.
     *
     * @param out         to append to.
     * @param indent      level for the comment.
     * @param optionToken for the type.
     * @throws IOException on failing to write to output.
     */
    public static void generateOptionDecodeJavadoc(final Appendable out, final String indent, final Token optionToken)
        throws IOException
    {
        final String description = optionToken.description();
        if (Strings.isEmpty(description))
        {
            return;
        }
        out.append(indent).append("/**\n")
            .append(indent).append(" * ");
        escapeJavadoc(out, description);
        out.append('\n')
            .append(indent).append(" *\n")
            .append(indent).append(" * @return true if ").append(optionToken.name()).append(" set or false if not.\n")
            .append(indent).append(" */\n");
    }
    /**
     * Generate the Javadoc comment header for a bitset choice option encode method.
     *
     * @param out         to append to.
     * @param indent      level for the comment.
     * @param optionToken for the type.
     * @throws IOException on failing to write to output.
     */
    public static void generateOptionEncodeJavadoc(final Appendable out, final String indent, final Token optionToken)
        throws IOException
    {
        final String description = optionToken.description();
        if (Strings.isEmpty(description))
        {
            return;
        }
        out.append(indent).append("/**\n")
            .append(indent).append(" * ");
        escapeJavadoc(out, description);
        final String name = optionToken.name();
        out.append('\n')
            .append(indent).append(" *\n")
            .append(indent).append(" * @param value true if ").append(name).append(" is set or false if not.\n")
            .append(indent).append(" * @return this for a fluent API.\n")
            .append(indent).append(" */\n");
    }
    /**
     * Generate the Javadoc comment header for flyweight property.
     *
     * @param sb            to append to.
     * @param indent        level for the comment.
     * @param propertyToken for the property name.
     * @param typeName      for the property type.
     */
    public static void generateFlyweightPropertyJavadoc(
        final StringBuilder sb, final String indent, final Token propertyToken, final String typeName)
    {
        final String description = propertyToken.description();
        if (Strings.isEmpty(description))
        {
            return;
        }
        sb.append('\n')
            .append(indent).append("/**\n")
            .append(indent).append(" * ");
        escapeJavadoc(sb, description);
        sb.append('\n')
            .append(indent).append(" *\n")
            .append(indent).append(" * @return ").append(typeName).append(" : ");
        escapeJavadoc(sb, description);
        sb.append("\n")
            .append(indent).append(" */");
    }
    /**
     * Generate the Javadoc comment header for group encode property.
     *
     * @param sb            to append to.
     * @param indent        level for the comment.
     * @param propertyToken for the property name.
     * @param typeName      for the property type.
     */
    public static void generateGroupEncodePropertyJavadoc(
        final StringBuilder sb, final String indent, final Token propertyToken, final String typeName)
    {
        final String description = propertyToken.description();
        if (Strings.isEmpty(description))
        {
            return;
        }
        sb.append('\n')
            .append(indent).append("/**\n")
            .append(indent).append(" * ");
        escapeJavadoc(sb, description);
        sb.append("\n")
            .append(indent).append(" *\n")
            .append(indent).append(" * @param count of times the group will be encoded.\n")
            .append(indent).append(" * @return ").append(typeName).append(" : encoder for the group.\n")
            .append(indent).append(" */");
    }
    static String encoderName(final String className)
    {
        return formatClassName(className) + "Encoder";
    }
    static String decoderName(final String className)
    {
        return formatClassName(className) + "Decoder";
    }
    private static void escapeJavadoc(final Appendable out, final String doc) throws IOException
    {
        for (int i = 0, length = doc.length(); i < length; i++)
        {
            final char c = doc.charAt(i);
            switch (c)
            {
                case '<':
                    out.append("&lt;");
                    break;
                case '>':
                    out.append("&gt;");
                    break;
                default:
                    out.append(c);
                    break;
            }
        }
    }
    private static void escapeJavadoc(final StringBuilder sb, final String doc)
    {
        for (int i = 0, length = doc.length(); i < length; i++)
        {
            final char c = doc.charAt(i);
            switch (c)
            {
                case '<':
                    sb.append("&lt;");
                    break;
                case '>':
                    sb.append("&gt;");
                    break;
                case '&':
                    sb.append("&amp;");
                    break;
                default:
                    sb.append(c);
                    break;
            }
        }
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.xml;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.PrimitiveValue;
import uk.co.real_logic.sbe.ir.Encoding;
import uk.co.real_logic.sbe.ir.Ir;
import uk.co.real_logic.sbe.ir.Signal;
import uk.co.real_logic.sbe.ir.Token;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
/**
 * Class to hold the state while generating the {@link uk.co.real_logic.sbe.ir.Ir}.
 */
public class IrGenerator
{
    private final List<Token> tokenList = new ArrayList<>();
    private MessageSchema schema;
    /**
     * Generate a complete {@link uk.co.real_logic.sbe.ir.Ir} for a given schema.
     *
     * @param schema    from which the {@link uk.co.real_logic.sbe.ir.Ir} should be generated.
     * @param namespace for the generated code.
     * @return complete {@link uk.co.real_logic.sbe.ir.Ir} for a given schema.
     */
    public Ir generate(final MessageSchema schema, final String namespace)
    {
        this.schema = schema;
        final List<Token> headerTokens = generateForHeader(schema);
        final Ir ir = new Ir(
            schema.packageName(),
            namespace,
            schema.id(),
            schema.version(),
            schema.description(),
            schema.semanticVersion(),
            schema.byteOrder(),
            headerTokens);
        for (final Message message : schema.messages())
        {
            final long msgId = message.id();
            ir.addMessage(msgId, generateForMessage(schema, msgId));
        }
        return ir;
    }
    /**
     * Generate a complete {@link uk.co.real_logic.sbe.ir.Ir} for a given schema.
     *
     * @param schema from which the {@link uk.co.real_logic.sbe.ir.Ir} should be generated.
     * @return complete {@link uk.co.real_logic.sbe.ir.Ir} for a given schema.
     */
    public Ir generate(final MessageSchema schema)
    {
        return generate(schema, null);
    }
    private List<Token> generateForMessage(final MessageSchema schema, final long messageId)
    {
        tokenList.clear();
        final Message msg = schema.getMessage(messageId);
        addMessageSignal(msg, Signal.BEGIN_MESSAGE);
        addAllFields(msg.fields());
        addMessageSignal(msg, Signal.END_MESSAGE);
        return tokenList;
    }
    private List<Token> generateForHeader(final MessageSchema schema)
    {
        tokenList.clear();
        add(schema.messageHeader(), 0, null);
        return tokenList;
    }
    private void addMessageSignal(final Message msg, final Signal signal)
    {
        final Encoding encoding = new Encoding.Builder()
            .semanticType(msg.semanticType())
            .build();
        final Token token = new Token.Builder()
            .signal(signal)
            .name(msg.name())
            .description(msg.description())
            .size(msg.blockLength())
            .id(msg.id())
            .version(msg.sinceVersion())
            .deprecated(msg.deprecated())
            .encoding(encoding)
            .build();
        tokenList.add(token);
    }
    private void addFieldSignal(final Field field, final Signal signal, final int typeSinceVersion)
    {
        final Encoding.Builder encodingBuilder = new Encoding.Builder()
            .epoch(field.epoch())
            .timeUnit(field.timeUnit())
            .presence(mapPresence(field.presence()))
            .semanticType(semanticTypeOf(null, field));
        if (field.presence() == Presence.CONSTANT && null != field.valueRef())
        {
            final String valueRef = field.valueRef();
            final byte[] bytes;
            bytes = valueRef.getBytes(StandardCharsets.UTF_8);
            encodingBuilder.constValue(new PrimitiveValue(bytes, "UTF-8", valueRef.length()));
            encodingBuilder.primitiveType(PrimitiveType.CHAR);
        }
        final Token token = new Token.Builder()
            .signal(signal)
            .size(field.computedBlockLength())
            .name(field.name())
            .description(field.description())
            .id(field.id())
            .offset(field.computedOffset())
            .version(Math.max(field.sinceVersion(), typeSinceVersion))
            .deprecated(field.deprecated())
            .encoding(encodingBuilder.build())
            .build();
        tokenList.add(token);
    }
    private void addAllFields(final List<Field> fieldList)
    {
        for (final Field field : fieldList)
        {
            final Type type = field.type();
            if (null == type)
            {
                addFieldSignal(field, Signal.BEGIN_GROUP, 0);
                add(field.dimensionType(), 0, field);
                addAllFields(field.groupFields());
                addFieldSignal(field, Signal.END_GROUP, 0);
            }
            else if (type instanceof CompositeType && field.isVariableLength())
            {
                addFieldSignal(field, Signal.BEGIN_VAR_DATA, 0);
                add((CompositeType)type, field.computedOffset(), field);
                addFieldSignal(field, Signal.END_VAR_DATA, 0);
            }
            else
            {
                final int typeSinceVersion = type.sinceVersion();
                addFieldSignal(field, Signal.BEGIN_FIELD, typeSinceVersion);
                if (type instanceof EncodedDataType)
                {
                    add((EncodedDataType)type, field.computedOffset(), field);
                }
                else if (type instanceof CompositeType)
                {
                    add((CompositeType)type, field.computedOffset(), field);
                }
                else if (type instanceof EnumType)
                {
                    add((EnumType)type, field.computedOffset(), field);
                }
                else if (type instanceof SetType)
                {
                    add((SetType)type, field.computedOffset(), field);
                }
                else
                {
                    throw new IllegalStateException("Unknown type: " + type);
                }
                addFieldSignal(field, Signal.END_FIELD, typeSinceVersion);
            }
        }
    }
    private void add(final CompositeType type, final int currOffset, final Field field)
    {
        final Encoding encoding = new Encoding.Builder()
            .semanticType(semanticTypeOf(type, field))
            .build();
        final int version = null != field ? Math.max(field.sinceVersion(), type.sinceVersion()) : type.sinceVersion();
        final Token.Builder builder = new Token.Builder()
            .signal(Signal.BEGIN_COMPOSITE)
            .name(type.name())
            .packageName(type.packageName())
            .referencedName(type.referencedName())
            .offset(currOffset)
            .size(type.encodedLength())
            .version(version)
            .deprecated(type.deprecated())
            .description(type.description())
            .encoding(encoding);
        tokenList.add(builder.build());
        int offset = 0;
        for (final Type elementType : type.getTypeList())
        {
            if (elementType.offsetAttribute() != -1)
            {
                offset = elementType.offsetAttribute();
            }
            if (elementType instanceof EncodedDataType)
            {
                add((EncodedDataType)elementType,
                    offset,
                    null != field ? Math.max(field.sinceVersion(), type.sinceVersion()) : elementType.sinceVersion());
            }
            else if (elementType instanceof EnumType)
            {
                add((EnumType)elementType, offset, field);
            }
            else if (elementType instanceof SetType)
            {
                add((SetType)elementType, offset, field);
            }
            else if (elementType instanceof CompositeType)
            {
                add((CompositeType)elementType, offset, field);
            }
            offset += elementType.encodedLength();
        }
        tokenList.add(builder.signal(Signal.END_COMPOSITE).build());
    }
    private void add(final EnumType type, final int offset, final Field field)
    {
        final PrimitiveType encodingType = type.encodingType();
        final Encoding.Builder encodingBuilder = new Encoding.Builder()
            .primitiveType(encodingType)
            .semanticType(semanticTypeOf(type, field))
            .nullValue(type.nullValue())
            .byteOrder(schema.byteOrder());
        final int version = null != field ? Math.max(field.sinceVersion(), type.sinceVersion()) : type.sinceVersion();
        final Token.Builder builder = new Token.Builder()
            .signal(Signal.BEGIN_ENUM)
            .name(type.name())
            .packageName(type.packageName())
            .referencedName(type.referencedName())
            .size(encodingType.size())
            .offset(offset)
            .version(version)
            .deprecated(type.deprecated())
            .description(type.description())
            .encoding(encodingBuilder.build());
        tokenList.add(builder.build());
        for (final EnumType.ValidValue validValue : type.validValues())
        {
            add(validValue, encodingType);
        }
        builder.signal(Signal.END_ENUM);
        tokenList.add(builder.build());
    }
    private void add(final EnumType.ValidValue value, final PrimitiveType encodingType)
    {
        final Encoding encoding = new Encoding.Builder()
            .byteOrder(schema.byteOrder())
            .primitiveType(encodingType)
            .constValue(value.primitiveValue())
            .build();
        final Token.Builder builder = new Token.Builder()
            .signal(Signal.VALID_VALUE)
            .name(value.name())
            .version(value.sinceVersion())
            .deprecated(value.deprecated())
            .description(value.description())
            .encoding(encoding);
        tokenList.add(builder.build());
    }
    private void add(final SetType type, final int offset, final Field field)
    {
        final PrimitiveType encodingType = type.encodingType();
        final Encoding encoding = new Encoding.Builder()
            .semanticType(semanticTypeOf(type, field))
            .primitiveType(encodingType)
            .build();
        final int version = null != field ? Math.max(field.sinceVersion(), type.sinceVersion()) : type.sinceVersion();
        final Token.Builder builder = new Token.Builder()
            .signal(Signal.BEGIN_SET)
            .name(type.name())
            .packageName(type.packageName())
            .referencedName(type.referencedName())
            .size(encodingType.size())
            .offset(offset)
            .version(version)
            .deprecated(type.deprecated())
            .description(type.description())
            .encoding(encoding);
        tokenList.add(builder.build());
        for (final SetType.Choice choice : type.choices())
        {
            add(choice, encodingType);
        }
        builder.signal(Signal.END_SET);
        tokenList.add(builder.build());
    }
    private void add(final SetType.Choice value, final PrimitiveType encodingType)
    {
        final Encoding encoding = new Encoding.Builder()
            .constValue(value.primitiveValue())
            .byteOrder(schema.byteOrder())
            .primitiveType(encodingType)
            .build();
        final Token.Builder builder = new Token.Builder()
            .signal(Signal.CHOICE)
            .name(value.name())
            .description(value.description())
            .version(value.sinceVersion())
            .deprecated(value.deprecated())
            .encoding(encoding);
        tokenList.add(builder.build());
    }
    private void add(final EncodedDataType type, final int offset, final int sinceVersion)
    {
        final Encoding.Builder encodingBuilder = new Encoding.Builder()
            .primitiveType(type.primitiveType())
            .byteOrder(schema.byteOrder())
            .characterEncoding(type.characterEncoding());
        final Token.Builder tokenBuilder = new Token.Builder()
            .signal(Signal.ENCODING)
            .name(type.name())
            .packageName(type.packageName())
            .referencedName(type.referencedName())
            .size(type.encodedLength())
            .description(type.description())
            .version(sinceVersion)
            .deprecated(type.deprecated())
            .offset(offset);
        switch (type.presence())
        {
            case REQUIRED:
                encodingBuilder
                    .presence(Encoding.Presence.REQUIRED)
                    .minValue(type.minValue())
                    .maxValue(type.maxValue());
                break;
            case OPTIONAL:
                encodingBuilder
                    .presence(Encoding.Presence.OPTIONAL)
                    .minValue(type.minValue())
                    .maxValue(type.maxValue())
                    .nullValue(type.nullValue());
                break;
            case CONSTANT:
                tokenBuilder.size(0);
                encodingBuilder
                    .presence(Encoding.Presence.CONSTANT)
                    .constValue(type.constVal());
                break;
        }
        final Token token = tokenBuilder.encoding(encodingBuilder.build()).build();
        tokenList.add(token);
    }
    private void add(final EncodedDataType type, final int offset, final Field field)
    {
        final Encoding.Builder encodingBuilder = new Encoding.Builder()
            .primitiveType(type.primitiveType())
            .byteOrder(schema.byteOrder())
            .semanticType(semanticTypeOf(type, field))
            .characterEncoding(type.characterEncoding())
            .timeUnit(field.timeUnit())
            .epoch(field.epoch());
        final int version = Math.max(field.sinceVersion(), type.sinceVersion());
        final Token.Builder tokenBuilder = new Token.Builder()
            .signal(Signal.ENCODING)
            .name(type.name())
            .packageName(type.packageName())
            .referencedName(type.referencedName())
            .size(type.encodedLength())
            .description(type.description())
            .version(version)
            .deprecated(type.deprecated())
            .offset(offset);
        switch (field.presence())
        {
            case REQUIRED:
                encodingBuilder
                    .presence(Encoding.Presence.REQUIRED)
                    .minValue(type.minValue())
                    .maxValue(type.maxValue());
                break;
            case OPTIONAL:
                encodingBuilder
                    .presence(Encoding.Presence.OPTIONAL)
                    .minValue(type.minValue())
                    .maxValue(type.maxValue())
                    .nullValue(type.nullValue());
                break;
            case CONSTANT:
                final String valueRef = field.valueRef();
                tokenBuilder.size(0);
                encodingBuilder
                    .presence(Encoding.Presence.CONSTANT)
                    .constValue(valueRef != null ? lookupValueRef(valueRef) : type.constVal());
                break;
        }
        final Token token = tokenBuilder.encoding(encodingBuilder.build()).build();
        tokenList.add(token);
    }
    private PrimitiveValue lookupValueRef(final String valueRef)
    {
        final int periodIndex = valueRef.indexOf('.');
        final String valueRefType = valueRef.substring(0, periodIndex);
        final String validValueName = valueRef.substring(periodIndex + 1);
        final EnumType enumType = (EnumType)schema.getType(valueRefType);
        final EnumType.ValidValue validValue = enumType.getValidValue(validValueName);
        return validValue.primitiveValue();
    }
    private static String semanticTypeOf(final Type type, final Field field)
    {
        final String typeSemanticType = null != type ? type.semanticType() : null;
        if (typeSemanticType != null)
        {
            return typeSemanticType;
        }
        return null != field ? field.semanticType() : null;
    }
    private Encoding.Presence mapPresence(final Presence presence)
    {
        Encoding.Presence encodingPresence = Encoding.Presence.REQUIRED;
        if (null != presence)
        {
            switch (presence)
            {
                case OPTIONAL:
                    encodingPresence = Encoding.Presence.OPTIONAL;
                    break;
                case CONSTANT:
                    encodingPresence = Encoding.Presence.CONSTANT;
                    break;
                default:
                    break;
            }
        }
        return encodingPresence;
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.ir;
import org.agrona.CloseHelper;
import org.agrona.LangUtil;
import org.agrona.MutableDirectBuffer;
import org.agrona.concurrent.UnsafeBuffer;
import uk.co.real_logic.sbe.PrimitiveType;
import uk.co.real_logic.sbe.ir.generated.FrameCodecEncoder;
import uk.co.real_logic.sbe.ir.generated.TokenCodecEncoder;
import org.agrona.Verify;
import java.io.*;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Paths;
import java.util.List;
import static java.nio.file.StandardOpenOption.*;
import static uk.co.real_logic.sbe.ir.IrUtil.*;
import static uk.co.real_logic.sbe.ir.generated.FrameCodecEncoder.namespaceNameCharacterEncoding;
import static uk.co.real_logic.sbe.ir.generated.FrameCodecEncoder.packageNameCharacterEncoding;
import static uk.co.real_logic.sbe.ir.generated.FrameCodecEncoder.semanticVersionCharacterEncoding;
import static uk.co.real_logic.sbe.ir.generated.TokenCodecEncoder.*;
/**
 * Encoder for {@link Ir} representing an SBE schema which can be written to a buffer or file.
 */
public class IrEncoder implements AutoCloseable
{
    private static final int CAPACITY = 4096;
    private final FileChannel channel;
    private final ByteBuffer resultBuffer;
    private final ByteBuffer buffer;
    private final MutableDirectBuffer directBuffer;
    private final Ir ir;
    private final FrameCodecEncoder frameEncoder = new FrameCodecEncoder();
    private final TokenCodecEncoder tokenEncoder = new TokenCodecEncoder();
    private final byte[] valArray = new byte[CAPACITY];
    private final UnsafeBuffer valBuffer = new UnsafeBuffer(valArray);
    private int totalLength = 0;
    /**
     * Construct an encoder for {@link Ir} to a file. An existing file will be overwritten.
     *
     * @param fileName into which the {@link Ir} will be encoded.
     * @param ir       to be encoded into the file.
     */
    public IrEncoder(final String fileName, final Ir ir)
    {
        try
        {
            channel = FileChannel.open(Paths.get(fileName), READ, WRITE, CREATE, TRUNCATE_EXISTING);
            resultBuffer = null;
            buffer = ByteBuffer.allocateDirect(CAPACITY);
            directBuffer = new UnsafeBuffer(buffer);
            this.ir = ir;
        }
        catch (final IOException ex)
        {
            throw new RuntimeException(ex);
        }
    }
    /**
     * Construct an encoder for {@link Ir} to a {@link ByteBuffer}.
     *
     * @param buffer into which the {@link Ir} will be encoded.
     * @param ir     to be encoded into the buffer.
     */
    public IrEncoder(final ByteBuffer buffer, final Ir ir)
    {
        channel = null;
        resultBuffer = buffer;
        this.buffer = ByteBuffer.allocateDirect(CAPACITY);
        directBuffer = new UnsafeBuffer(this.buffer);
        this.ir = ir;
    }
    /**
     * {@inheritDoc}
     */
    public void close()
    {
        CloseHelper.quietClose(channel);
    }
    /**
     * Encode the provided {@link Ir} and return the length in bytes encoded.
     *
     * @return encode the provided {@link Ir} and return the length in bytes encoded.
     */
    public int encode()
    {
        Verify.notNull(ir, "ir");
        write(buffer, encodeFrame());
        encodeTokenList(ir.headerStructure().tokens());
        ir.messages().forEach(this::encodeTokenList);
        return totalLength;
    }
    private void encodeTokenList(final List<Token> tokenList)
    {
        for (final Token token : tokenList)
        {
            write(buffer, encodeToken(token));
        }
    }
    private void write(final ByteBuffer buffer, final int length)
    {
        buffer.position(0);
        buffer.limit(length);
        if (channel != null)
        {
            try
            {
                channel.write(buffer);
            }
            catch (final IOException ex)
            {
                LangUtil.rethrowUnchecked(ex);
            }
        }
        else if (resultBuffer != null)
        {
            resultBuffer.put(buffer);
        }
        totalLength += length;
    }
    private int encodeFrame()
    {
        frameEncoder
            .wrap(directBuffer, 0)
            .irId(ir.id())
            .irVersion(0)
            .schemaVersion(ir.version());
        try
        {
            final byte[] packageBytes = ir.packageName().getBytes(packageNameCharacterEncoding());
            frameEncoder.putPackageName(packageBytes, 0, packageBytes.length);
            final byte[] namespaceBytes = getBytes(ir.namespaceName(), namespaceNameCharacterEncoding());
            frameEncoder.putNamespaceName(namespaceBytes, 0, namespaceBytes.length);
            final byte[] semanticVersionBytes = getBytes(ir.semanticVersion(), semanticVersionCharacterEncoding());
            frameEncoder.putSemanticVersion(semanticVersionBytes, 0, semanticVersionBytes.length);
        }
        catch (final UnsupportedEncodingException ex)
        {
            LangUtil.rethrowUnchecked(ex);
        }
        return frameEncoder.encodedLength();
    }
    private int encodeToken(final Token token)
    {
        final Encoding encoding = token.encoding();
        final PrimitiveType type = encoding.primitiveType();
        tokenEncoder
            .wrap(directBuffer, 0)
            .tokenOffset(token.offset())
            .tokenSize(token.encodedLength())
            .fieldId(token.id())
            .tokenVersion(token.version())
            .componentTokenCount(token.componentTokenCount())
            .signal(mapSignal(token.signal()))
            .primitiveType(mapPrimitiveType(type))
            .byteOrder(mapByteOrder(encoding.byteOrder()))
            .presence(mapPresence(encoding.presence()));
        try
        {
            final byte[] nameBytes = token.name().getBytes(TokenCodecEncoder.nameCharacterEncoding());
            tokenEncoder.putName(nameBytes, 0, nameBytes.length);
            tokenEncoder.putConstValue(valArray, 0, put(valBuffer, encoding.constValue(), type));
            tokenEncoder.putMinValue(valArray, 0, put(valBuffer, encoding.minValue(), type));
            tokenEncoder.putMaxValue(valArray, 0, put(valBuffer, encoding.maxValue(), type));
            tokenEncoder.putNullValue(valArray, 0, put(valBuffer, encoding.nullValue(), type));
            final byte[] charEncodingBytes = getBytes(
                encoding.characterEncoding(), characterEncodingCharacterEncoding());
            tokenEncoder.putCharacterEncoding(charEncodingBytes, 0, charEncodingBytes.length);
            final byte[] epochBytes = getBytes(encoding.epoch(), epochCharacterEncoding());
            tokenEncoder.putEpoch(epochBytes, 0, epochBytes.length);
            final byte[] timeUnitBytes = getBytes(encoding.timeUnit(), timeUnitCharacterEncoding());
            tokenEncoder.putTimeUnit(timeUnitBytes, 0, timeUnitBytes.length);
            final byte[] semanticTypeBytes = getBytes(encoding.semanticType(), semanticTypeCharacterEncoding());
            tokenEncoder.putSemanticType(semanticTypeBytes, 0, semanticTypeBytes.length);
            final byte[] descriptionBytes = getBytes(token.description(), descriptionCharacterEncoding());
            tokenEncoder.putDescription(descriptionBytes, 0, descriptionBytes.length);
            final byte[] referencedNameBytes = getBytes(token.referencedName(), referencedNameCharacterEncoding());
            tokenEncoder.putReferencedName(referencedNameBytes, 0, referencedNameBytes.length);
        }
        catch (final UnsupportedEncodingException ex)
        {
            LangUtil.rethrowUnchecked(ex);
        }
        return tokenEncoder.encodedLength();
    }
}
/*
 * Copyright 2013-2025 Real Logic Limited.
 * Copyright (C) 2017 MarketFactory, Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package uk.co.real_logic.sbe.generation.java;
import uk.co.real_logic.sbe.generation.CodeGenerator;
import uk.co.real_logic.sbe.generation.TargetCodeGenerator;
import uk.co.real_logic.sbe.ir.Ir;
import static uk.co.real_logic.sbe.SbeTool.TYPES_PACKAGE_OVERRIDE;
/**
 * {@link CodeGenerator} factory for Java DTOs.
 */
public class JavaDtos implements TargetCodeGenerator
{
    /**
     * {@inheritDoc}
     */
    public CodeGenerator newInstance(final Ir ir, final String outputDir)
    {
        return new JavaDtoGenerator(
            ir,
            Boolean.getBoolean(TYPES_PACKAGE_OVERRIDE),
            new JavaOutputManager(outputDir, ir.applicableNamespace()));
    }
}