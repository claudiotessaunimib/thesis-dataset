package ly.count.android.sdk;import android.annotation.SuppressLint;import android.app.Activity;import android.app.Application;import android.content.ComponentCallbacks;import android.content.Context;import android.content.res.Configuration;import android.os.Bundle;import androidx.annotation.NonNull;import androidx.lifecycle.Lifecycle;import androidx.lifecycle.ProcessLifecycleOwner;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledFuture;import java.util.concurrent.TimeUnit;public class Countly {    private final String DEFAULT_COUNTLY_SDK_VERSION_STRING = "24.7.8";    private final String DEFAULT_COUNTLY_SDK_NAME = "java-native-android";    public String COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;    public String COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;    protected static final String DEFAULT_APP_VERSION = "1.0";    public static final String TAG = "Countly";    public ModuleLog L = new ModuleLog();    public static final String CONSENT_BROADCAST = "ly.count.android.sdk.Countly.CONSENT_BROADCAST";    int EVENT_QUEUE_SIZE_THRESHOLD = 100;    private static final long TIMER_DELAY_IN_SECONDS = 60;    protected static String[] publicKeyPinCertificates;    protected static String[] certificatePinCertificates;    interface LifecycleObserver {        boolean LifeCycleAtleastStarted();    }    public enum CountlyMessagingMode {        TEST,        PRODUCTION,    }    public enum CountlyMessagingProvider {        FCM,            HMS,        }    final int maxKeyLengthDefault = 128;    final int maxValueSizeDefault = 256;    final int maxSegmentationValuesDefault = 100;    final int maxBreadcrumbCountDefault = 100;    final int maxStackTraceLinesPerThreadDefault = 30;    final int maxStackTraceLineLengthDefault = 200;    final int maxStackTraceThreadCountDefault = 50;    private static class SingletonHolder {        @SuppressLint("StaticFieldLeak")        static final Countly instance = new Countly();    }    ConnectionQueue connectionQueue_;    private ScheduledExecutorService timerService_;    private ScheduledFuture<?> timerFuture = null;    private int activityCount_;    boolean disableUpdateSessionRequests_ = false;    boolean sdkIsInitialised = false;    BaseInfoProvider baseInfoProvider;    RequestQueueProvider requestQueueProvider;    private boolean enableLogging_;    Context context_;    List<ModuleBase> modules = new ArrayList<>();    ModuleCrash moduleCrash = null;    ModuleEvents moduleEvents = null;    ModuleViews moduleViews = null;    ModuleRatings moduleRatings = null;    ModuleSessions moduleSessions = null;    ModuleRemoteConfig moduleRemoteConfig = null;    ModuleAPM moduleAPM = null;    ModuleConsent moduleConsent = null;    ModuleDeviceId moduleDeviceId = null;    ModuleLocation moduleLocation = null;    ModuleFeedback moduleFeedback = null;    ModuleRequestQueue moduleRequestQueue = null;    ModuleAttribution moduleAttribution = null;    ModuleUserProfile moduleUserProfile = null;    ModuleConfiguration moduleConfiguration = null;    ModuleHealthCheck moduleHealthCheck = null;    ModuleContent moduleContent = null;    CountlyStore countlyStore;    boolean isHttpPostForced = false;    private boolean addMetadataToPushIntents = false;    private boolean calledAtLeastOnceOnStart = false;    protected boolean isBeginSessionSent = false;    Map<String, String> requestHeaderCustomValues;    static long applicationStart = System.currentTimeMillis();    String[] locationFallback;    protected CountlyConfig config_ = null;    final static long lastRegistrationCallDebounceDuration = 60 * 1000;    long lastRegistrationCallTs = 0;    String lastRegistrationCallID = null;    CountlyMessagingProvider lastRegistrationCallProvider = null;    boolean applicationClassProvided = false;    public static class CountlyFeatureNames {        public static final String sessions = "sessions";        public static final String events = "events";        public static final String views = "views";        public static final String scrolls = "scrolls";        public static final String clicks = "clicks";        public static final String location = "location";        public static final String crashes = "crashes";        public static final String attribution = "attribution";        public static final String users = "users";        public static final String push = "push";        public static final String starRating = "star-rating";        public static final String apm = "apm";        public static final String feedback = "feedback";        public static final String remoteConfig = "remote-config";        public static final String content = "content";    }    public static Countly sharedInstance() {        return SingletonHolder.instance;    }    Countly() {        connectionQueue_ = new ConnectionQueue();        timerService_ = Executors.newSingleThreadScheduledExecutor();    }    private void startTimerService(ScheduledExecutorService service, ScheduledFuture<?> previousTimer, long timerDelay) {        if (previousTimer != null && !previousTimer.isCancelled()) {            previousTimer.cancel(false);        }        if (timerDelay < 1) {            timerDelay = 1;        }        timerFuture = service.scheduleWithFixedDelay(this::onTimer, timerDelay, timerDelay, TimeUnit.SECONDS);    }    public synchronized Countly init(CountlyConfig config) {        if (config == null) {            throw new IllegalArgumentException("Can't init SDK with 'null' config");        }        if (config.loggingEnabled) {            setLoggingEnabled(true);        }        L.SetListener(config.providedLogCallback);        if (COUNTLY_SDK_NAME.equals(DEFAULT_COUNTLY_SDK_NAME) && COUNTLY_SDK_VERSION_STRING.equals(DEFAULT_COUNTLY_SDK_VERSION_STRING)) {            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "]");        } else {            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "] default name[" + DEFAULT_COUNTLY_SDK_NAME + "] default version[" + DEFAULT_COUNTLY_SDK_VERSION_STRING + "]");        }        if (config.context == null) {            if (config.application != null) {                L.d("[Init] No explicit context provided. Using context from the provided application class");                config.context = config.application;            } else {                throw new IllegalArgumentException("valid context is required in Countly init, but was provided 'null'");            }        } else {            L.d("[Init] Using explicitly provided context");        }        if (!UtilsNetworking.isValidURL(config.serverURL)) {            throw new IllegalArgumentException("valid serverURL is required");        }        if (config.serverURL.charAt(config.serverURL.length() - 1) == '/') {            L.v("[Init] Removing trailing '/' from provided server url");            config.serverURL = config.serverURL.substring(0, config.serverURL.length() - 1);        }        if (config.appKey == null || config.appKey.isEmpty()) {            throw new IllegalArgumentException("valid appKey is required, but was provided either 'null' or empty String");        }        if (config.application == null) {            L.w("[Init] Initialising the SDK without providing the application class. Some functionality will not work.");        }        applicationClassProvided = config.application != null;        if (config.deviceID != null && config.deviceID.isEmpty()) {            L.w("[Countly] init, Provided device ID is an empty string. It will be ignored. And a new one will be generated by the SDK.");            config.setDeviceId(null);        }        L.d("[Init] SDK initialised with the URL:[" + config.serverURL + "] and the appKey:[" + config.appKey + "]");        if (L.logEnabled()) {            L.i("[Init] Checking init parameters");            Class contextClass = config.context.getClass();            Class contextSuperClass = contextClass.getSuperclass();            String contextText = "[Init] Provided Context [" + config.context.getClass().getSimpleName() + "]";            if (contextSuperClass != null) {                contextText += ", it's superclass: [" + contextSuperClass.getSimpleName() + "]";            }            L.i(contextText);        }        context_ = config.context.getApplicationContext();        if (!sdkIsInitialised) {            L.d("[Init] About to init internal systems");            config_ = config;            if (config.sdkInternalLimits.maxKeyLength != null) {                if (config.sdkInternalLimits.maxKeyLength < 1) {                    config.sdkInternalLimits.maxKeyLength = 1;                    L.w("[Init] provided 'maxKeyLength' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxKeyLength' override:[" + config.sdkInternalLimits.maxKeyLength + "]");            } else {                config.sdkInternalLimits.maxKeyLength = maxKeyLengthDefault;            }            if (config.sdkInternalLimits.maxValueSize != null) {                if (config.sdkInternalLimits.maxValueSize < 1) {                    config.sdkInternalLimits.maxValueSize = 1;                    L.w("[Init] provided 'maxValueSize' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxValueSize' override:[" + config.sdkInternalLimits.maxValueSize + "]");            } else {                config.sdkInternalLimits.maxValueSize = maxValueSizeDefault;            }            if (config.sdkInternalLimits.maxSegmentationValues != null) {                if (config.sdkInternalLimits.maxSegmentationValues < 1) {                    config.sdkInternalLimits.maxSegmentationValues = 1;                    L.w("[Init] provided 'maxSegmentationValues' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxSegmentationValues' override:[" + config.sdkInternalLimits.maxSegmentationValues + "]");            } else {                config.sdkInternalLimits.maxSegmentationValues = maxSegmentationValuesDefault;            }            if (config.sdkInternalLimits.maxBreadcrumbCount != null) {                if (config.sdkInternalLimits.maxBreadcrumbCount < 1) {                    config.sdkInternalLimits.maxBreadcrumbCount = 1;                    L.w("[Init] provided 'maxBreadcrumbCount' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxBreadcrumbCount' override:[" + config.sdkInternalLimits.maxBreadcrumbCount + "]");            } else {                config.sdkInternalLimits.maxBreadcrumbCount = maxBreadcrumbCountDefault;            }            if (config.sdkInternalLimits.maxStackTraceLinesPerThread != null) {                if (config.sdkInternalLimits.maxStackTraceLinesPerThread < 1) {                    config.sdkInternalLimits.maxStackTraceLinesPerThread = 1;                    L.w("[Init] provided 'maxStackTraceLinesPerThread' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxStackTraceLinesPerThread' override:[" + config.sdkInternalLimits.maxStackTraceLinesPerThread + "]");            } else {                config.sdkInternalLimits.maxStackTraceLinesPerThread = maxStackTraceLinesPerThreadDefault;            }            if (config.sdkInternalLimits.maxStackTraceLineLength != null) {                if (config.sdkInternalLimits.maxStackTraceLineLength < 1) {                    config.sdkInternalLimits.maxStackTraceLineLength = 1;                    L.w("[Init] provided 'maxStackTraceLineLength' is less than '1'. Setting it to '1'.");                }                L.i("[Init] provided 'maxStackTraceLineLength' override:[" + config.sdkInternalLimits.maxStackTraceLineLength + "]");            } else {                config.sdkInternalLimits.maxStackTraceLineLength = maxStackTraceLineLengthDefault;            }            long timerDelay = TIMER_DELAY_IN_SECONDS;            if (config.sessionUpdateTimerDelay != null) {                L.d("[Init] Setting custom session update timer delay, [" + config.sessionUpdateTimerDelay + "]");                timerDelay = config.sessionUpdateTimerDelay;            }            startTimerService(timerService_, timerFuture, timerDelay);            if (config.explicitStorageModeEnabled) {                L.i("[Init] Explicit storage mode is being enabled");            }            if (config.countlyStore != null) {                countlyStore = config.countlyStore;            } else {                countlyStore = new CountlyStore(config.context, L, config.explicitStorageModeEnabled);                config.setCountlyStore(countlyStore);            }            if (config.pcc != null) {                L.i("[Init] Attaching a performance counter collector");                countlyStore.pcc = config.pcc;            }            if (config.maxRequestQueueSize < 1) {                L.e("[Init] provided request queue size is less than 1. Replacing it with 1.");                config.maxRequestQueueSize = 1;            }            L.d("[Init] request queue size set to [" + config.maxRequestQueueSize + "]");            countlyStore.setLimits(config.maxRequestQueueSize);            if (config.storageProvider == null) {                config.storageProvider = config.countlyStore;            } else {                L.d("[Init] Custom event storage provider was provided");            }            if (config.eventQueueProvider == null) {                config.eventQueueProvider = countlyStore;            } else {                L.d("[Init] Custom event queue provider was provided");            }            if (config.requestQueueProvider == null) {                config.requestQueueProvider = connectionQueue_;            } else {                L.d("[Init] Custom request queue provider was provided");            }            if (config.safeViewIDGenerator == null) {                config.safeViewIDGenerator = new SafeIDGenerator() {                    @NonNull @Override public String GenerateValue() {                        return Utils.safeRandomVal();                    }                };            }            if (config.safeEventIDGenerator == null) {                config.safeEventIDGenerator = new SafeIDGenerator() {                    @NonNull @Override public String GenerateValue() {                        return Utils.safeRandomVal();                    }                };            }            if (config.immediateRequestGenerator == null) {                config.immediateRequestGenerator = new ImmediateRequestGenerator() {                    @Override public ImmediateRequestI CreateImmediateRequestMaker() {                        return (new ImmediateRequestMaker());                    }                };            }            if (config.lifecycleObserver == null) {                config.lifecycleObserver = new LifecycleObserver() {                    @Override public boolean LifeCycleAtleastStarted() {                        return lifecycleStateAtLeastStartedInternal();                    }                };            }            if (config.metricProviderOverride != null) {                L.d("[Init] Custom metric provider was provided");            }            config.deviceInfo = new DeviceInfo(config.metricProviderOverride);            if (config.tamperingProtectionSalt != null) {                L.d("[Init] Parameter tampering protection salt set");            }            if (config.dropAgeHours < 0) {                config.dropAgeHours = 0;                L.d("[Init] Drop older requests threshold can not be negative. No threshold will be set.");            }            if (config.dropAgeHours > 0) {                L.d("[Init] Drop older requests threshold set to:[" + config.dropAgeHours + "] hours");            }            if (connectionQueue_ == null) {                L.e("[Init] SDK failed to initialize because the connection queue failed to be created");                return this;            }            if (locationFallback != null && config.locationCountyCode == null && config.locationCity == null && config.locationLocation == null && config.locationIpAddress == null) {                config.locationCountyCode = locationFallback[0];                config.locationCity = locationFallback[1];                config.locationLocation = locationFallback[2];                config.locationIpAddress = locationFallback[3];            }            try {                Map<String, Object> migrationParams = new HashMap<>();                migrationParams.put(MigrationHelper.key_from_0_to_1_custom_id_set, config.deviceID != null);                MigrationHelper mHelper = new MigrationHelper(config.storageProvider, L, context_);                mHelper.doWork(migrationParams);            } catch (Exception ex) {                L.e("[Init] SDK failed while performing data migration. SDK is not capable to initialize.");                return this;            }            moduleHealthCheck = new ModuleHealthCheck(this, config);            moduleConfiguration = new ModuleConfiguration(this, config);            moduleRequestQueue = new ModuleRequestQueue(this, config);            moduleConsent = new ModuleConsent(this, config);            moduleDeviceId = new ModuleDeviceId(this, config);            moduleCrash = new ModuleCrash(this, config);            moduleEvents = new ModuleEvents(this, config);            moduleUserProfile = new ModuleUserProfile(this, config);            moduleViews = new ModuleViews(this, config);            moduleRatings = new ModuleRatings(this, config);            moduleSessions = new ModuleSessions(this, config);            moduleRemoteConfig = new ModuleRemoteConfig(this, config);            moduleAPM = new ModuleAPM(this, config);            moduleLocation = new ModuleLocation(this, config);            moduleFeedback = new ModuleFeedback(this, config);            moduleAttribution = new ModuleAttribution(this, config);            moduleContent = new ModuleContent(this, config);            modules.clear();            modules.add(moduleConfiguration);            modules.add(moduleRequestQueue);            modules.add(moduleConsent);            modules.add(moduleDeviceId);            modules.add(moduleCrash);            modules.add(moduleEvents);            modules.add(moduleUserProfile);            modules.add(moduleViews);            modules.add(moduleRatings);            modules.add(moduleSessions);            modules.add(moduleRemoteConfig);            modules.add(moduleAPM);            modules.add(moduleLocation);            modules.add(moduleFeedback);            modules.add(moduleAttribution);            modules.add(moduleContent);            modules.add(moduleHealthCheck);            if (config.testModuleListener != null) {                modules.add(config.testModuleListener);            }            moduleConfiguration.consentProvider = config.consentProvider;            moduleRequestQueue.consentProvider = config.consentProvider;            moduleHealthCheck.consentProvider = config.consentProvider;            moduleRequestQueue.deviceIdProvider = config.deviceIdProvider;            moduleConsent.eventProvider = config.eventProvider;            moduleConsent.deviceIdProvider = config.deviceIdProvider;            moduleDeviceId.eventProvider = config.eventProvider;            moduleCrash.eventProvider = config.eventProvider;            moduleEvents.viewIdProvider = config.viewIdProvider;            baseInfoProvider = config.baseInfoProvider;            requestQueueProvider = config.requestQueueProvider;            L.setHealthChecker(config.healthTracker);            L.i("[Init] Finished initialising modules");            if (config.customNetworkRequestHeaders != null) {                L.i("[Countly] Calling addCustomNetworkRequestHeaders");                requestHeaderCustomValues = config.customNetworkRequestHeaders;                connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);            }            if (config.httpPostForced) {                L.d("[Init] Setting HTTP POST to be forced");                isHttpPostForced = config.httpPostForced;            }            if (config.tamperingProtectionSalt != null) {                L.d("[Init] Enabling tamper protection");            }            if (config.dropAgeHours > 0) {                L.d("[Init] Enabling drop older request threshold");                countlyStore.setRequestAgeLimit(config.dropAgeHours);            }            if (config.pushIntentAddMetadata) {                L.d("[Init] Enabling push intent metadata");                addMetadataToPushIntents = config.pushIntentAddMetadata;            }            if (config.eventQueueSizeThreshold != null) {                L.d("[Init] Setting event queue size: [" + config.eventQueueSizeThreshold + "]");                if (config.eventQueueSizeThreshold < 1) {                    L.d("[Init] queue size can't be less than zero");                    config.eventQueueSizeThreshold = 1;                }                EVENT_QUEUE_SIZE_THRESHOLD = config.eventQueueSizeThreshold;            }            if (config.publicKeyPinningCertificates != null) {                sharedInstance().L.i("[Init] Enabling public key pinning");                publicKeyPinCertificates = config.publicKeyPinningCertificates;            }            if (config.certificatePinningCertificates != null) {                Countly.sharedInstance().L.i("[Init] Enabling certificate pinning");                certificatePinCertificates = config.certificatePinningCertificates;            }            connectionQueue_.L = L;            connectionQueue_.healthTracker = config.healthTracker;            connectionQueue_.configProvider = config.configProvider;            connectionQueue_.consentProvider = moduleConsent;            connectionQueue_.moduleRequestQueue = moduleRequestQueue;            connectionQueue_.deviceInfo = config.deviceInfo;            connectionQueue_.pcc = config.pcc;            connectionQueue_.setStorageProvider(config.storageProvider);            connectionQueue_.setupSSLContext();            connectionQueue_.setBaseInfoProvider(config.baseInfoProvider);            connectionQueue_.setDeviceId(config.deviceIdProvider);            connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);            connectionQueue_.setMetricOverride(config.metricOverride);            connectionQueue_.setContext(context_);            connectionQueue_.requestInfoProvider = new RequestInfoProvider() {                @Override public boolean isHttpPostForced() {                    return requestQueue().isHttpPostForced();                }                @Override public boolean isDeviceAppCrawler() {                    return requestQueue().isDeviceAppCrawler();                }                @Override public boolean ifShouldIgnoreCrawlers() {                    return requestQueue().ifShouldIgnoreCrawlers();                }                @Override public int getRequestDropAgeHours() {                    return config.dropAgeHours;                }                @Override public String getRequestSalt() {                    return config.tamperingProtectionSalt;                }            };            sdkIsInitialised = true;            if (config.application != null) {                L.d("[Countly] Calling registerActivityLifecycleCallbacks");                config.application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() {                    @Override                    public void onActivityCreated(Activity activity, Bundle bundle) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityCreated, " + activity.getClass().getSimpleName());                        }                    }                    @Override                    public void onActivityStarted(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityStarted, " + activity.getClass().getSimpleName());                        }                        onStartInternal(activity);                    }                    @Override                    public void onActivityResumed(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityResumed, " + activity.getClass().getSimpleName());                        }                        for (ModuleBase module : modules) {                            module.callbackOnActivityResumed(activity);                        }                    }                    @Override                    public void onActivityPaused(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityPaused, " + activity.getClass().getSimpleName());                        }                    }                    @Override                    public void onActivityStopped(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityStopped, " + activity.getClass().getSimpleName());                        }                        onStopInternal();                        for (ModuleBase module : modules) {                            module.callbackOnActivityStopped(activity);                        }                    }                    @Override                    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivitySaveInstanceState, " + activity.getClass().getSimpleName());                        }                    }                    @Override                    public void onActivityDestroyed(Activity activity) {                        if (L.logEnabled()) {                            L.d("[Countly] onActivityDestroyed, " + activity.getClass().getSimpleName());                        }                    }                });                config.application.registerComponentCallbacks(new ComponentCallbacks() {                    @Override                    public void onConfigurationChanged(Configuration configuration) {                        L.d("[Countly] ComponentCallbacks, onConfigurationChanged");                        onConfigurationChangedInternal(configuration);                    }                    @Override                    public void onLowMemory() {                        L.d("[Countly] ComponentCallbacks, onLowMemory");                    }                });            } else {                L.d("[Countly] Global activity listeners not registred due to no Application class");            }            if (config_.lifecycleObserver.LifeCycleAtleastStarted()) {                L.d("[Countly] SDK detects that the app is in the foreground. Increasing the activity counter and setting the foreground state.");                activityCount_++;                config.deviceInfo.inForeground();            }            L.i("[Init] About to call module 'initFinished'");            for (ModuleBase module : modules) {                module.initFinished(config);            }            L.i("[Init] Finished initialising SDK");        } else {            L.i("[Init] Getting in the 'else' block");            connectionQueue_.setContext(context_);        }        return this;    }    @SuppressWarnings("BooleanMethodIsAlwaysInverted")    public boolean isInitialized() {        return sdkIsInitialised;    }    boolean lifecycleStateAtLeastStartedInternal() {        return ProcessLifecycleOwner.get().getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED);    }    private void stopTimer() {        L.i("[Countly] stopTimer, Stopping global timer");        if (timerService_ != null) {            try {                timerService_.shutdown();                if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {                    timerService_.shutdownNow();                    if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {                        L.e("[Countly] stopTimer, Global timer must be locked");                    }                }            } catch (Throwable t) {                L.e("[Countly] stopTimer, Error while stopping global timer " + t);            }        }    }    public synchronized void halt() {        L.i("Halting Countly!");        sdkIsInitialised = false;        L.SetListener(null);        stopTimer();        if (connectionQueue_ != null) {            if (countlyStore != null) {                countlyStore.clear();            }            connectionQueue_.setContext(null);            connectionQueue_ = null;        }        activityCount_ = 0;        for (ModuleBase module : modules) {            module.halt();        }        modules.clear();        moduleCrash = null;        moduleViews = null;        moduleEvents = null;        moduleRatings = null;        moduleSessions = null;        moduleRemoteConfig = null;        moduleConsent = null;        moduleAPM = null;        moduleDeviceId = null;        moduleLocation = null;        moduleFeedback = null;        moduleRequestQueue = null;        moduleConfiguration = null;        moduleHealthCheck = null;        moduleContent = null;        COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;        COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;        connectionQueue_ = new ConnectionQueue();        timerService_ = Executors.newSingleThreadScheduledExecutor();    }    synchronized void notifyDeviceIdChange(boolean withoutMerge) {        L.d("Notifying modules that device ID changed");        for (ModuleBase module : modules) {            module.deviceIdChanged(withoutMerge);        }    }    void onStartInternal(Activity activity) {        if (L.logEnabled()) {            String activityName = "NULL ACTIVITY PROVIDED";            if (activity != null) {                activityName = activity.getClass().getSimpleName();            }            L.d("Countly onStartInternal called, name:[" + activityName + "], [" + activityCount_ + "] -> [" + (activityCount_ + 1) + "] activities now open");        }        ++activityCount_;        if (activityCount_ == 1 && !moduleSessions.manualSessionControlEnabled) {            moduleSessions.beginSessionInternal();        }        config_.deviceInfo.inForeground();        for (ModuleBase module : modules) {            module.onActivityStarted(activity, activityCount_);        }        calledAtLeastOnceOnStart = true;    }    void onStopInternal() {        L.d("Countly onStopInternal called, [" + activityCount_ + "] -> [" + (activityCount_ - 1) + "] activities now open");        if (activityCount_ == 0) {            L.e("must call onStart before onStop");            return;        }        --activityCount_;        if (activityCount_ == 0 && !moduleSessions.manualSessionControlEnabled) {            moduleSessions.endSessionInternal();        }        config_.deviceInfo.inBackground();        for (ModuleBase module : modules) {            module.onActivityStopped(activityCount_);        }    }    public synchronized void onConfigurationChangedInternal(Configuration newConfig) {        L.i("Calling [onConfigurationChangedInternal]");        for (ModuleBase module : modules) {            module.onConfigurationChanged(newConfig);        }    }    public synchronized void onStart(Activity activity) {        if (!isInitialized()) {            L.e("init must be called before onStart");            return;        }        if (applicationClassProvided) {            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");            return;        }        onStartInternal(activity);    }    public synchronized void onStop() {        if (!isInitialized()) {            L.e("init must be called before onStop");            return;        }        if (applicationClassProvided) {            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");            return;        }        onStopInternal();    }    public synchronized void onConfigurationChanged(Configuration newConfig) {        if (!isInitialized()) {            L.e("init must be called before onConfigurationChanged");            return;        }        if (applicationClassProvided) {            L.w("Manual calls to 'onConfigurationChanged' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");            return;        }        onConfigurationChangedInternal(newConfig);    }    synchronized void onTimer() {        L.v("[onTimer] Calling heartbeat, Activity count:[" + activityCount_ + "]");        if (isInitialized()) {            final boolean appIsInForeground = activityCount_ > 0;            if (appIsInForeground && !moduleSessions.manualSessionControlEnabled) {                moduleSessions.updateSessionInternal();            } else if (moduleSessions.manualSessionControlEnabled && moduleSessions.manualSessionControlHybridModeEnabled && moduleSessions.sessionIsRunning()) {                moduleSessions.updateSessionInternal();            }            moduleRequestQueue.sendEventsIfNeeded(true);            moduleUserProfile.saveInternal();            requestQueueProvider.tick();        }    }    public void onRegistrationId(String registrationId, CountlyMessagingProvider provider) {        if (!config_.consentProvider.getConsent(CountlyFeatureNames.push)) {            return;        }        if (!isInitialized()) {            L.w("[onRegistrationId] Calling this before the SDK is initialized.");        }        long currentTs = UtilsTime.currentTimestampMs();        long timeDelta = currentTs - lastRegistrationCallTs;        if (lastRegistrationCallID != null && lastRegistrationCallID.equals(registrationId) &&            lastRegistrationCallProvider != null && lastRegistrationCallProvider == provider &&            timeDelta < lastRegistrationCallDebounceDuration) {            L.w("[onRegistrationId] Calling this with the same values within the debounce interval. elapsedT:[" + timeDelta + "] ms");            return;        }        lastRegistrationCallTs = currentTs;        lastRegistrationCallID = registrationId;        lastRegistrationCallProvider = provider;        connectionQueue_.tokenSession(registrationId, provider);    }    public void setLoggingEnabled(final boolean enableLogging) {        enableLogging_ = enableLogging;        L.d("Enabling logging");    }    public boolean isLoggingEnabled() {        return enableLogging_;    }    public boolean hasBeenCalledOnStart() {        return calledAtLeastOnceOnStart;    }    public ModuleCrash.Crashes crashes() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing crashes");            return null;        }        return moduleCrash.crashesInterface;    }    public ModuleEvents.Events events() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing events");            return null;        }        return moduleEvents.eventsInterface;    }    public ModuleViews.Views views() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing views");            return null;        }        return moduleViews.viewsInterface;    }    public ModuleRatings.Ratings ratings() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing ratings");            return null;        }        return moduleRatings.ratingsInterface;    }    public ModuleSessions.Sessions sessions() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing sessions");            return null;        }        return moduleSessions.sessionInterface;    }    public ModuleRemoteConfig.RemoteConfig remoteConfig() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing remote config");            return null;        }        return moduleRemoteConfig.remoteConfigInterface;    }    public ModuleAPM.Apm apm() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing apm");            return null;        }        return moduleAPM.apmInterface;    }    public ModuleConsent.Consent consent() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing consent");            return null;        }        return moduleConsent.consentInterface;    }    public ModuleLocation.Location location() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing location");            return null;        }        return moduleLocation.locationInterface;    }    public ModuleFeedback.Feedback feedback() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing feedback");            return null;        }        return moduleFeedback.feedbackInterface;    }    public ModuleRequestQueue.RequestQueue requestQueue() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing request queue");            return null;        }        return moduleRequestQueue.requestQueueInterface;    }    public ModuleAttribution.Attribution attribution() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing attribution");            return null;        }        return moduleAttribution.attributionInterface;    }    public ModuleDeviceId.DeviceId deviceId() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing deviceId");            return null;        }        return moduleDeviceId.deviceIdInterface;    }    public ModuleUserProfile.UserProfile userProfile() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing user profile");            return null;        }        return moduleUserProfile.userProfileInterface;    }    public ModuleContent.Content contents() {        if (!isInitialized()) {            L.e("Countly.sharedInstance().init must be called before accessing content");            return null;        }        return moduleContent.contentInterface;    }    public static void applicationOnCreate() {    }    ConnectionQueue getConnectionQueue() {        return connectionQueue_;    }    ExecutorService getTimerService() {        return timerService_;    }    long getPrevSessionDurationStartTime() {        return moduleSessions.prevSessionDurationStartTime_;    }    void setPrevSessionDurationStartTime(final long prevSessionDurationStartTime) {        moduleSessions.prevSessionDurationStartTime_ = prevSessionDurationStartTime;    }    int getActivityCount() {        return activityCount_;    }    synchronized boolean getDisableUpdateSessionRequests() {        return disableUpdateSessionRequests_;    }}package ly.count.android.sdk;import android.app.Activity;import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.net.Uri;import android.os.Handler;import android.os.Looper;import android.view.LayoutInflater;import android.view.View;import android.webkit.WebResourceRequest;import android.webkit.WebResourceResponse;import android.webkit.WebSettings;import android.webkit.WebView;import android.webkit.WebViewClient;import android.widget.RatingBar;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.HashMap;import java.util.Map;import org.json.JSONException;import org.json.JSONObject;public class ModuleRatings extends ModuleBase {    StarRatingCallback starRatingCallback_;    boolean showStarRatingDialogOnFirstActivity = false;    final Ratings ratingsInterface;    ModuleRatings(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleRatings] Initialising");        starRatingCallback_ = config.starRatingCallback;        setStarRatingInitConfig(config.starRatingSessionLimit, config.starRatingTextTitle, config.starRatingTextMessage, config.starRatingTextDismiss);        setIfRatingDialogIsCancellableInternal(config.starRatingDialogIsCancellable);        setShowDialogAutomatically(config.starRatingShownAutomatically);        setStarRatingDisableAskingForEachAppVersion(config.starRatingDisableAskingForEachAppVersion);        ratingsInterface = new Ratings();    }    void recordManualRatingInternal(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {        L.d("[ModuleRatings] Calling recordManualRatingInternal");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {            return;        }        if (widgetId == null) {            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is null, returning");            return;        }        if (widgetId.isEmpty()) {            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is empty, returning");            return;        }        if (rating < 1) {            rating = 1;            L.d("[ModuleRatings] recordManualRatingInternal, given rating too low, defaulting to 1");        }        if (rating > 5) {            rating = 5;            L.d("[ModuleRatings] recordManualRatingInternal, given rating too high, defaulting to 5");        }        String truncatedEmail = UtilsInternalLimits.truncateValueSize(email, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");        String truncatedComment = UtilsInternalLimits.truncateValueSize(comment, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");        Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", deviceInfo.mp.getAppVersion(_cly.context_));        segm.put("rating", "" + rating);        segm.put("widget_id", widgetId);        segm.put("contactMe", userCanBeContacted);        if (truncatedEmail != null && !truncatedEmail.isEmpty()) {            segm.put("email", truncatedEmail);        }        if (truncatedComment != null && !truncatedComment.isEmpty()) {            segm.put("comment", truncatedComment);        }        eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);    }    private void saveStarRatingPreferences(final StarRatingPreferences srp) {        storageProvider.setStarRatingPreferences(srp.toJSON().toString());    }    void setStarRatingInitConfig(final int limit, final String starRatingTextTitle, final String starRatingTextMessage, final String starRatingTextDismiss) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        if (limit >= 0) {            srp.sessionLimit = limit;        }        if (starRatingTextTitle != null) {            srp.dialogTextTitle = starRatingTextTitle;        }        if (starRatingTextMessage != null) {            srp.dialogTextMessage = starRatingTextMessage;        }        if (starRatingTextDismiss != null) {            srp.dialogTextDismiss = starRatingTextDismiss;        }        saveStarRatingPreferences(srp);    }    void setShowDialogAutomatically(final boolean shouldShow) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        srp.automaticRatingShouldBeShown = shouldShow;        saveStarRatingPreferences(srp);    }    boolean getIfStarRatingShouldBeShownAutomatically() {        StarRatingPreferences srp = loadStarRatingPreferences(_cly.countlyStore);        return srp.automaticRatingShouldBeShown;    }    void setStarRatingDisableAskingForEachAppVersion(final boolean disableAsking) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        srp.disabledAutomaticForNewVersions = disableAsking;        saveStarRatingPreferences(srp);    }    void registerAppSession(final Context context, final StarRatingCallback starRatingCallback) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        String currentAppVersion = deviceInfo.mp.getAppVersion(context);        if (currentAppVersion != null && !currentAppVersion.equals(srp.appVersion) && !srp.disabledAutomaticForNewVersions) {            srp.appVersion = currentAppVersion;            srp.isShownForCurrentVersion = false;            srp.sessionAmount = 0;        }        srp.sessionAmount++;        if (srp.sessionAmount >= srp.sessionLimit && !srp.isShownForCurrentVersion && srp.automaticRatingShouldBeShown && !(srp.disabledAutomaticForNewVersions && srp.automaticHasBeenShown)) {            showStarRatingDialogOnFirstActivity = true;        }        saveStarRatingPreferences(srp);    }    static int getAutomaticStarRatingSessionLimitInternal(final StorageProvider sp) {        StarRatingPreferences srp = loadStarRatingPreferences(sp);        return srp.sessionLimit;    }    int getCurrentVersionsSessionCountInternal(final StorageProvider sp) {        StarRatingPreferences srp = loadStarRatingPreferences(sp);        return srp.sessionAmount;    }    void clearAutomaticStarRatingSessionCountInternal() {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        srp.sessionAmount = 0;        saveStarRatingPreferences(srp);    }    void setIfRatingDialogIsCancellableInternal(final boolean isCancellable) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        srp.isDialogCancellable = isCancellable;        saveStarRatingPreferences(srp);    }    static class StarRatingPreferences {        String appVersion = "";         int sessionLimit = 5;         int sessionAmount = 0;         boolean isShownForCurrentVersion = false;         boolean automaticRatingShouldBeShown = false;         boolean disabledAutomaticForNewVersions = false;         boolean automaticHasBeenShown = false;         boolean isDialogCancellable = true;         String dialogTextTitle = "App rating";        String dialogTextMessage = "Please rate this app";        String dialogTextDismiss = "Cancel";        private static final String KEY_APP_VERSION = "sr_app_version";        private static final String KEY_SESSION_LIMIT = "sr_session_limit";        private static final String KEY_SESSION_AMOUNT = "sr_session_amount";        private static final String KEY_IS_SHOWN_FOR_CURRENT = "sr_is_shown";        private static final String KEY_AUTOMATIC_RATING_IS_SHOWN = "sr_is_automatic_shown";        private static final String KEY_DISABLE_AUTOMATIC_NEW_VERSIONS = "sr_is_disable_automatic_new";        private static final String KEY_AUTOMATIC_HAS_BEEN_SHOWN = "sr_automatic_has_been_shown";        private static final String KEY_DIALOG_IS_CANCELLABLE = "sr_automatic_dialog_is_cancellable";        private static final String KEY_DIALOG_TEXT_TITLE = "sr_text_title";        private static final String KEY_DIALOG_TEXT_MESSAGE = "sr_text_message";        private static final String KEY_DIALOG_TEXT_DISMISS = "sr_text_dismiss";        JSONObject toJSON() {            final JSONObject json = new JSONObject();            try {                json.put(KEY_APP_VERSION, appVersion);                json.put(KEY_SESSION_LIMIT, sessionLimit);                json.put(KEY_SESSION_AMOUNT, sessionAmount);                json.put(KEY_IS_SHOWN_FOR_CURRENT, isShownForCurrentVersion);                json.put(KEY_AUTOMATIC_RATING_IS_SHOWN, automaticRatingShouldBeShown);                json.put(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, disabledAutomaticForNewVersions);                json.put(KEY_AUTOMATIC_HAS_BEEN_SHOWN, automaticHasBeenShown);                json.put(KEY_DIALOG_IS_CANCELLABLE, isDialogCancellable);                json.put(KEY_DIALOG_TEXT_TITLE, dialogTextTitle);                json.put(KEY_DIALOG_TEXT_MESSAGE, dialogTextMessage);                json.put(KEY_DIALOG_TEXT_DISMISS, dialogTextDismiss);            } catch (JSONException e) {                Countly.sharedInstance().L.w("Got exception converting an StarRatingPreferences to JSON", e);            }            return json;        }        static StarRatingPreferences fromJSON(final JSONObject json) {            StarRatingPreferences srp = new StarRatingPreferences();            if (json != null) {                try {                    srp.appVersion = json.getString(KEY_APP_VERSION);                    srp.sessionLimit = json.optInt(KEY_SESSION_LIMIT, 5);                    srp.sessionAmount = json.optInt(KEY_SESSION_AMOUNT, 0);                    srp.isShownForCurrentVersion = json.optBoolean(KEY_IS_SHOWN_FOR_CURRENT, false);                    srp.automaticRatingShouldBeShown = json.optBoolean(KEY_AUTOMATIC_RATING_IS_SHOWN, true);                    srp.disabledAutomaticForNewVersions = json.optBoolean(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, false);                    srp.automaticHasBeenShown = json.optBoolean(KEY_AUTOMATIC_HAS_BEEN_SHOWN, false);                    srp.isDialogCancellable = json.optBoolean(KEY_DIALOG_IS_CANCELLABLE, true);                    if (!json.isNull(KEY_DIALOG_TEXT_TITLE)) {                        srp.dialogTextTitle = json.getString(KEY_DIALOG_TEXT_TITLE);                    }                    if (!json.isNull(KEY_DIALOG_TEXT_MESSAGE)) {                        srp.dialogTextMessage = json.getString(KEY_DIALOG_TEXT_MESSAGE);                    }                    if (!json.isNull(KEY_DIALOG_TEXT_DISMISS)) {                        srp.dialogTextDismiss = json.getString(KEY_DIALOG_TEXT_DISMISS);                    }                } catch (JSONException e) {                    Countly.sharedInstance().L.w("Got exception converting JSON to a StarRatingPreferences", e);                }            }            return srp;        }    }    void showStarRatingInternal(final Context context, final StarRatingCallback callback) {        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);        showStarRatingCustom(context, srp.dialogTextTitle, srp.dialogTextMessage, srp.dialogTextDismiss, srp.isDialogCancellable, callback);    }    static StarRatingPreferences loadStarRatingPreferences(final StorageProvider sp) {        String srpString = sp.getStarRatingPreferences();        StarRatingPreferences srp;        if (!srpString.equals("")) {            JSONObject srJSON;            try {                srJSON = new JSONObject(srpString);                srp = StarRatingPreferences.fromJSON(srJSON);            } catch (JSONException e) {                e.printStackTrace();                srp = new StarRatingPreferences();            }        } else {            srp = new StarRatingPreferences();        }        return srp;    }    void showStarRatingCustom(@NonNull final Context context, final String title, final String message, final String cancelText, final boolean isCancellable, @Nullable final StarRatingCallback callback) {        if (!(context instanceof Activity)) {            L.e("[ModuleRatings] Can't show star rating dialog, the provided context is not based off a activity");            return;        }        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);        View dialogLayout = inflater.inflate(R.layout.star_rating_layout, null);        RatingBar ratingBar = dialogLayout.findViewById(R.id.ratingBar);        final AlertDialog.Builder builder = new AlertDialog.Builder(context)            .setTitle(title)            .setMessage(message)            .setCancelable(isCancellable)            .setView(dialogLayout)            .setOnCancelListener(new DialogInterface.OnCancelListener() {                @Override                public void onCancel(DialogInterface dialogInterface) {                    if (callback != null) {                        callback.onDismiss();                    }                }            })            .setPositiveButton(cancelText, new DialogInterface.OnClickListener() {                @Override                public void onClick(DialogInterface dialogInterface, int i) {                    if (callback != null) {                        callback.onDismiss();                    }                }            });        final AlertDialog dialog = builder.show();        ratingBar.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener() {            @Override            public void onRatingChanged(RatingBar ratingBar, float v, boolean b) {                int rating = (int) v;                if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {                    Map<String, Object> segm = new HashMap<>();                    segm.put("platform", "android");                    segm.put("app_version", deviceInfo.mp.getAppVersion(context));                    segm.put("rating", "" + rating);                    eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);                }                dialog.dismiss();                if (callback != null) {                    callback.onRate(rating);                }            }        });    }    synchronized void showFeedbackPopupInternal(@Nullable final String widgetId, @Nullable final String closeButtonText, @Nullable final Activity activity, @Nullable final FeedbackRatingCallback devCallback) {        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");        if (widgetId == null || widgetId.isEmpty()) {            if (devCallback != null) {                devCallback.callback("Countly widgetId cannot be null or empty");            }            L.e("[ModuleRatings] Countly widgetId cannot be null or empty");            return;        }        if (activity == null) {            if (devCallback != null) {                devCallback.callback("When showing feedback popup, Activity can't be null");            }            L.e("[ModuleRatings] When showing feedback popup, Activity can't be null");            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {            if (devCallback != null) {                devCallback.callback("Consent is not granted");            }            return;        }        final boolean deviceIsPhone;        final boolean deviceIsTablet;        final boolean deviceIsTv;        deviceIsTv = Utils.isDeviceTv(activity);        if (!deviceIsTv) {            deviceIsPhone = !Utils.isDeviceTablet(activity);            deviceIsTablet = Utils.isDeviceTablet(activity);        } else {            deviceIsTablet = false;            deviceIsPhone = false;        }        String requestData = requestQueueProvider.prepareRatingWidgetRequest(widgetId);        final String ratingWidgetUrl = baseInfoProvider.getServerURL() + "/feedback?widget_id=" + widgetId +            "&device_id=" + UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()) +            "&app_key=" + UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey());        L.d("[ModuleRatings] rating widget url :[" + ratingWidgetUrl + "]");        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();        (new ImmediateRequestMaker()).doWork(requestData, "/o/feedback/widget", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {            @Override            public void callback(JSONObject checkResponse) {                if (checkResponse == null) {                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably a lack of connection to the server");                    if (devCallback != null) {                        devCallback.callback("Not possible to show Rating popup, probably no internet connection or wrong widget id");                    }                    return;                }                if (!checkResponse.has("target_devices")) {                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably using a widget_id not intended for the rating widget");                    if (devCallback != null) {                        devCallback.callback("Not possible to show Rating popup, probably using a widget_id not intended for the rating widget");                    }                    return;                }                try {                    JSONObject jDevices = checkResponse.getJSONObject("target_devices");                    boolean showOnTv = jDevices.optBoolean("desktop", false);                    boolean showOnPhone = jDevices.optBoolean("phone", false);                    boolean showOnTablet = jDevices.optBoolean("tablet", false);                    if ((deviceIsPhone && showOnPhone) || (deviceIsTablet && showOnTablet) || (deviceIsTv && showOnTv)) {                        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");                        Handler handler = new Handler(Looper.getMainLooper());                        handler.post(new Runnable() {                            public void run() {                                L.d("[ModuleRatings] Calling on main thread");                                RatingDialogWebView webView = new RatingDialogWebView(activity);                                webView.clearCache(true);                                webView.clearHistory();                                webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);                                webView.getSettings().setJavaScriptEnabled(true);                                webView.loadUrl(ratingWidgetUrl);                                AlertDialog.Builder builder = new AlertDialog.Builder(activity);                                builder.setView(webView);                                if (closeButtonText != null && !closeButtonText.isEmpty()) {                                    builder.setNeutralButton(closeButtonText, new DialogInterface.OnClickListener() {                                        @Override public void onClick(DialogInterface dialog, int which) {                                            L.d("[ModuleRatings] Calling callback from 'close' button");                                            if (devCallback != null) {                                                devCallback.callback(null);                                            }                                        }                                    });                                }                                builder.show();                            }                        });                    } else {                        if (devCallback != null) {                            devCallback.callback("Rating dialog is not meant for this form factor");                        }                    }                } catch (JSONException e) {                    L.e("[ModuleRatings] Encountered a issue while trying to parse the results of the widget config", e);                }            }        }, L);    }    static class RatingDialogWebView extends WebView {        public RatingDialogWebView(Context context) {            super(context);        }        @Override        public boolean onCheckIsTextEditor() {            return true;        }    }    static class FeedbackDialogWebViewClient extends WebViewClient {        @Override        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {            String url = request.getUrl().toString();            if (url.endsWith("cly_x_int=1")) {                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));                view.getContext().startActivity(intent);                return true;            }            return false;        }        @Override        public WebResourceResponse shouldInterceptRequest(WebView view, String url) {            return null;        }        @Override        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {            return null;        }    }    @Override    void callbackOnActivityResumed(Activity activity) {        if (showStarRatingDialogOnFirstActivity) {            StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);            srp.isShownForCurrentVersion = true;            srp.automaticHasBeenShown = true;            showStarRatingInternal(activity, starRatingCallback_);            saveStarRatingPreferences(srp);            showStarRatingDialogOnFirstActivity = false;        }    }    @Override    void initFinished(@NonNull CountlyConfig config) {        if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {            registerAppSession(config.context, starRatingCallback_);        }    }    @Override    void halt() {    }    public class Ratings {        public void recordManualRating(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {            L.i("[Ratings] Calling recordManualRating");            recordRatingWidgetWithID(widgetId, rating, email, comment, userCanBeContacted);        }        public void recordRatingWidgetWithID(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {            synchronized (_cly) {                L.i("[Ratings] Calling recordRatingWidgetWithID");                if (widgetId == null || widgetId.isEmpty()) {                    throw new IllegalStateException("A valid widgetID must be provided. The current one is either null or empty");                }                recordManualRatingInternal(widgetId, rating, email, comment, userCanBeContacted);            }        }        public void showFeedbackPopup(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {            L.i("[Ratings] Calling showFeedbackPopup");            presentRatingWidgetWithID(widgetId, closeButtonText, activity, callback);        }        public void presentRatingWidgetWithID(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {            synchronized (_cly) {                L.i("[Ratings] Calling presentRatingWidgetWithID");                showFeedbackPopupInternal(widgetId, closeButtonText, activity, callback);            }        }        public void showStarRating(Activity activity, StarRatingCallback callback) {            synchronized (_cly) {                L.i("[Ratings] Calling showStarRating");                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {                    return;                }                showStarRatingInternal(activity, callback);            }        }        public int getCurrentVersionsSessionCount() {            synchronized (_cly) {                int sessionCount = getCurrentVersionsSessionCountInternal(_cly.countlyStore);                L.i("[Ratings] Getting star rating current version session count: [" + sessionCount + "]");                return sessionCount;            }        }        public void clearAutomaticStarRatingSessionCount() {            synchronized (_cly) {                L.i("[Ratings] Clearing star rating session count");                clearAutomaticStarRatingSessionCountInternal();            }        }        public int getAutomaticStarRatingSessionLimit() {            synchronized (_cly) {                int sessionLimit = ModuleRatings.getAutomaticStarRatingSessionLimitInternal(_cly.countlyStore);                L.i("[Ratings] Getting automatic star rating session limit: [" + sessionLimit + "]");                return sessionLimit;            }        }    }}package ly.count.android.sdk;import android.util.Log;public class ModuleLog {    public interface LogCallback {        void LogHappened(String logMessage, ModuleLog.LogLevel logLevel);    }    public enum LogLevel {Verbose, Debug, Info, Warning, Error}    LogCallback logListener = null;    HealthTracker healthTracker;    int countWarnings = 0;    int countErrors = 0;    void SetListener(LogCallback logListener) {        this.logListener = logListener;    }    void trackWarning() {        if (healthTracker == null) {            countWarnings++;        } else {            healthTracker.logWarning();        }    }    void trackError() {        if (healthTracker == null) {            countErrors++;        } else {            healthTracker.logError();        }    }    void setHealthChecker(HealthTracker healthTracker) {        v("[ModuleLog] Setting healthTracker W:" + countWarnings + " E:" + countErrors);        this.healthTracker = healthTracker;        if (healthTracker == null) {            return;        }        for (int a = 0; a < countErrors; a++) {            healthTracker.logError();        }        for (int a = 0; a < countWarnings; a++) {            healthTracker.logWarning();        }        countWarnings = 0;        countErrors = 0;    }    public void v(String msg) {        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.v(Countly.TAG, msg);        }        informListener(msg, null, LogLevel.Verbose);    }    public void d(String msg) {        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.d(Countly.TAG, msg);        }        informListener(msg, null, LogLevel.Debug);    }    public void i(String msg) {        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.i(Countly.TAG, msg);        }        informListener(msg, null, LogLevel.Info);    }    public void w(String msg) {        w(msg, null);    }    public void w(String msg, Throwable t) {        trackWarning();        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.w(Countly.TAG, msg);        }        informListener(msg, null, LogLevel.Warning);    }    public void e(String msg) {        e(msg, null);    }    public void e(String msg, Throwable t) {        trackError();        if (!logEnabled()) {            return;        }        if (Countly.sharedInstance().isLoggingEnabled()) {            Log.e(Countly.TAG, msg, t);        }        informListener(msg, t, LogLevel.Error);    }    public boolean logEnabled() {        return logListener != null || Countly.sharedInstance().isLoggingEnabled();    }    private void informListener(String msg, final Throwable t, final LogLevel level) {        try {            if (msg == null) {                msg = "";            }            if (t != null) {                msg += Log.getStackTraceString(t);            }            if (logListener != null) {                logListener.LogHappened(msg, level);            }        } catch (Exception ex) {            Log.e(Countly.TAG, "[ModuleLog] Failed to inform listener [" + ex.toString() + "]");        }    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.io.UnsupportedEncodingException;import java.net.MalformedURLException;import java.net.URL;import java.security.MessageDigest;public class UtilsNetworking {    final private static char[] hexArray = "0123456789ABCDEF".toCharArray();    protected static @NonNull String urlEncodeString(@NonNull String givenValue) {        assert Utils.isNotNullOrEmpty(givenValue);        String result = "";        try {            result = java.net.URLEncoder.encode(givenValue, "UTF-8");        } catch (UnsupportedEncodingException ignored) {        }        return result;    }    protected static @NonNull String encodedArrayBuilder(@NonNull String[] args) {        assert args != null && args.length > 0;        StringBuilder encodedUrlBuilder = new StringBuilder();        encodedUrlBuilder.append("[");        for (int i = 0; i < args.length; i++) {            encodedUrlBuilder.append('"').append(args[i]).append('"');            if (i < args.length - 1) {                encodedUrlBuilder.append(", ");            }        }        encodedUrlBuilder.append("]");        return encodedUrlBuilder.toString();    }    protected static @NonNull String urlDecodeString(@NonNull String givenValue) {        assert givenValue != null;        String decodedResult = "";        try {            decodedResult = java.net.URLDecoder.decode(givenValue, "UTF-8");        } catch (UnsupportedEncodingException ignored) {        }        return decodedResult;    }    protected static @NonNull String sha256Hash(@NonNull String toHash) {        assert toHash != null;        String hash;        try {            MessageDigest digest = MessageDigest.getInstance("SHA-256");            byte[] bytes = toHash.getBytes("UTF-8");            digest.update(bytes, 0, bytes.length);            bytes = digest.digest();            hash = bytesToHex(bytes);        } catch (Throwable e) {            hash = "";            Countly.sharedInstance().L.e("Cannot tamper-protect params", e);        }        return hash;    }    public static @NonNull String bytesToHex(@NonNull byte[] bytes) {        assert bytes != null && bytes.length > 0;        char[] hexChars = new char[bytes.length * 2];        for (int j = 0; j < bytes.length; j++) {            int v = bytes[j] & 0xFF;            hexChars[j * 2] = hexArray[v >>> 4];            hexChars[j * 2 + 1] = hexArray[v & 0x0F];        }        return new String(hexChars).toLowerCase();    }    @SuppressWarnings("ConstantConditions")    static boolean isValidURL(@Nullable final String urlStr) {        boolean validURL = false;        if (urlStr != null && urlStr.length() > 0) {            try {                new URL(urlStr);                validURL = true;            } catch (MalformedURLException e) {                validURL = false;            }        }        return validURL;    }}package ly.count.android.sdk;import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.os.Handler;import android.os.Looper;import android.webkit.WebSettings;import android.webkit.WebView;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;public class ModuleFeedback extends ModuleBase {    public enum FeedbackWidgetType {survey, nps, rating}    public static class CountlyFeedbackWidget {        public String widgetId;        public FeedbackWidgetType type;        public String name;        public String[] tags;    }    final static String NPS_EVENT_KEY = "[CLY]_nps";    final static String SURVEY_EVENT_KEY = "[CLY]_survey";    final static String RATING_EVENT_KEY = "[CLY]_star_rating";    final String cachedAppVersion;    Feedback feedbackInterface = null;    ModuleFeedback(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleFeedback] Initialising");        cachedAppVersion = deviceInfo.mp.getAppVersion(config.context);        feedbackInterface = new Feedback();    }    public interface RetrieveFeedbackWidgets {        void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error);    }    public interface RetrieveFeedbackWidgetData {        void onFinished(JSONObject retrievedWidgetData, String error);    }    public interface FeedbackCallback {        void onClosed();        void onFinished(String error);    }    void getAvailableFeedbackWidgetsInternal(final RetrieveFeedbackWidgets devCallback) {        L.d("[ModuleFeedback] calling 'getAvailableFeedbackWidgetsInternal', callback set:[" + (devCallback != null) + "]");        if (devCallback == null) {            L.e("[ModuleFeedback] available feedback widget list can't be retrieved without a callback");            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            devCallback.onFinished(null, "Consent is not granted");            return;        }        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");            devCallback.onFinished(null, "[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");            return;        }        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();        String requestData = requestQueueProvider.prepareFeedbackListRequest();        (new ImmediateRequestMaker()).doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {            @Override public void callback(JSONObject checkResponse) {                if (checkResponse == null) {                    L.d("[ModuleFeedback] Not possible to retrieve widget list. Probably due to lack of connection to the server");                    devCallback.onFinished(null, "Not possible to retrieve widget list. Probably due to lack of connection to the server");                    return;                }                L.d("[ModuleFeedback] Retrieved request: [" + checkResponse.toString() + "]");                List<CountlyFeedbackWidget> feedbackEntries = parseFeedbackList(checkResponse);                devCallback.onFinished(feedbackEntries, null);            }        }, L);    }    static List<CountlyFeedbackWidget> parseFeedbackList(JSONObject requestResponse) {        Countly.sharedInstance().L.d("[ModuleFeedback] calling 'parseFeedbackList'");        List<CountlyFeedbackWidget> parsedRes = new ArrayList<>();        try {            if (requestResponse != null) {                JSONArray jArray = requestResponse.optJSONArray("result");                if (jArray == null) {                    Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, response does not have a valid 'result' entry. No widgets retrieved.");                    return parsedRes;                }                for (int a = 0; a < jArray.length(); a++) {                    try {                        JSONObject jObj = jArray.getJSONObject(a);                        String valId = jObj.optString("_id", "");                        String valType = jObj.optString("type", "");                        String valName = jObj.optString("name", "");                        List<String> valTagsArr = new ArrayList<String>();                        JSONArray jTagArr = jObj.optJSONArray("tg");                        if (jTagArr == null) {                            Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, no tags received");                        } else {                            for (int in = 0; in < jTagArr.length(); in++) {                                valTagsArr.add(jTagArr.getString(in));                            }                        }                        if (valId.isEmpty()) {                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget id, dropping");                            continue;                        }                        if (valType.isEmpty()) {                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget type, dropping");                            continue;                        }                        FeedbackWidgetType plannedType;                        if (valType.equals("survey")) {                            plannedType = FeedbackWidgetType.survey;                        } else if (valType.equals("nps")) {                            plannedType = FeedbackWidgetType.nps;                        } else if (valType.equals("rating")) {                            plannedType = FeedbackWidgetType.rating;                        } else {                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved unknown widget type, dropping");                            continue;                        }                        CountlyFeedbackWidget se = new CountlyFeedbackWidget();                        se.type = plannedType;                        se.widgetId = valId;                        se.name = valName;                        se.tags = valTagsArr.toArray(new String[0]);                        parsedRes.add(se);                    } catch (Exception ex) {                        Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, failed to parse json, [" + ex.toString() + "]");                    }                }            }        } catch (Exception ex) {            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, Encountered exception while parsing feedback list, [" + ex.toString() + "]");        }        return parsedRes;    }    void presentFeedbackWidgetInternal(@Nullable final CountlyFeedbackWidget widgetInfo, @Nullable final Context context, @Nullable final String closeButtonText, @Nullable final FeedbackCallback devCallback) {        if (widgetInfo == null) {            L.e("[ModuleFeedback] Can't present widget with null widget info");            if (devCallback != null) {                devCallback.onFinished("Can't present widget with null widget info");            }            return;        }        L.d("[ModuleFeedback] presentFeedbackWidgetInternal, callback set:[" + (devCallback != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "]");        if (context == null) {            L.e("[ModuleFeedback] Can't show feedback, provided context is null");            if (devCallback != null) {                devCallback.onFinished("Can't show feedback, provided context is null");            }            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            if (devCallback != null) {                devCallback.onFinished("Consent is not granted");            }            return;        }        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");            if (devCallback != null) {                devCallback.onFinished("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");            }            return;        }        StringBuilder widgetListUrl = new StringBuilder();        switch (widgetInfo.type) {            case survey:                widgetListUrl.append(baseInfoProvider.getServerURL());                widgetListUrl.append("/feedback/survey?widget_id=");                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));                break;            case nps:                widgetListUrl.append(baseInfoProvider.getServerURL());                widgetListUrl.append("/feedback/nps?widget_id=");                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));                break;            case rating:                widgetListUrl.append(baseInfoProvider.getServerURL());                widgetListUrl.append("/feedback/rating?widget_id=");                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));                break;        }        widgetListUrl.append("&device_id=");        widgetListUrl.append(UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()));        widgetListUrl.append("&app_key=");        widgetListUrl.append(UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey()));        widgetListUrl.append("&sdk_version=");        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);        widgetListUrl.append("&sdk_name=");        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_NAME);        widgetListUrl.append("&platform=android");        JSONObject customObjectToSendWithTheWidget = new JSONObject();        try {            customObjectToSendWithTheWidget.put("tc", 1);        } catch (JSONException e) {            throw new RuntimeException(e);        }        widgetListUrl.append("&custom=");        widgetListUrl.append(customObjectToSendWithTheWidget.toString());        final String preparedWidgetUrl = widgetListUrl.toString();        L.d("[ModuleFeedback] Using following url for widget:[" + widgetListUrl + "]");        final boolean useAlertDialog = true;        Handler handler = new Handler(Looper.getMainLooper());        handler.post(new Runnable() {            public void run() {                L.d("[ModuleFeedback] Calling on main thread");                try {                    ModuleRatings.RatingDialogWebView webView = new ModuleRatings.RatingDialogWebView(context);                    webView.getSettings().setJavaScriptEnabled(true);                    webView.clearCache(true);                    webView.clearHistory();                    webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);                    webView.setWebViewClient(new ModuleRatings.FeedbackDialogWebViewClient());                    webView.loadUrl(preparedWidgetUrl);                    webView.requestFocus();                    AlertDialog.Builder builder = prepareAlertDialog(context, webView, closeButtonText, widgetInfo, devCallback);                    if (useAlertDialog) {                        L.d("[ModuleFeedback] Creating standalone Alert dialog");                        builder.show();                    } else {                        L.d("[ModuleFeedback] Creating Alert dialog in dialogFragment");                    }                    if (devCallback != null) {                        devCallback.onFinished(null);                    }                } catch (Exception ex) {                    L.e("[ModuleFeedback] Failed at displaying feedback widget dialog, [" + ex.toString() + "]");                    if (devCallback != null) {                        devCallback.onFinished("Failed at displaying feedback widget dialog, [" + ex.toString() + "]");                    }                }            }        });    }    AlertDialog.Builder prepareAlertDialog(@NonNull final Context context, @NonNull WebView webView, @Nullable String closeButtonText, @NonNull final CountlyFeedbackWidget widgetInfo, @Nullable final FeedbackCallback devCallback) {        AlertDialog.Builder builder = new AlertDialog.Builder(context);        builder.setView(webView);        builder.setCancelable(false);        String usedCloseButtonText = closeButtonText;        if (closeButtonText == null || closeButtonText.isEmpty()) {            usedCloseButtonText = "Close";        }        builder.setNeutralButton(usedCloseButtonText, new DialogInterface.OnClickListener() {            @Override public void onClick(DialogInterface dialogInterface, int i) {                L.d("[ModuleFeedback] Cancel button clicked for the feedback widget");                reportFeedbackWidgetCancelButton(widgetInfo, deviceInfo.mp.getAppVersion(context));                if (devCallback != null) {                    devCallback.onClosed();                }            }        });        return builder;    }    void reportFeedbackWidgetCancelButton(@NonNull CountlyFeedbackWidget widgetInfo, @NonNull String appVersion) {        L.d("[reportFeedbackWidgetCancelButton] Cancel button event");        if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            final Map<String, Object> segm = new HashMap<>();            segm.put("platform", "android");            segm.put("app_version", appVersion);            segm.put("widget_id", "" + widgetInfo.widgetId);            segm.put("closed", "1");            final String key;            if (widgetInfo.type == FeedbackWidgetType.survey) {                key = SURVEY_EVENT_KEY;            } else if (widgetInfo.type == FeedbackWidgetType.rating) {                key = RATING_EVENT_KEY;            } else {                key = NPS_EVENT_KEY;            }            eventProvider.recordEventInternal(key, segm, 1, 0, 0, null, null);        }    }    void getFeedbackWidgetDataInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable final RetrieveFeedbackWidgetData devCallback) {        L.d("[ModuleFeedback] calling 'getFeedbackWidgetDataInternal', callback set:[" + (devCallback != null) + "]");        if (devCallback == null) {            L.e("[ModuleFeedback] Feedback widget data can't be retrieved without a callback");            return;        }        if (widgetInfo == null) {            L.e("[ModuleFeedback] Feedback widget data if provided widget is 'null'");            return;        }        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            devCallback.onFinished(null, "Consent is not granted");            return;        }        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.e("[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");            devCallback.onFinished(null, "[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");            return;        }        StringBuilder requestData = new StringBuilder();        String widgetDataEndpoint = "";        switch (widgetInfo.type) {            case survey:                widgetDataEndpoint = "/o/surveys/survey/widget";                break;            case nps:                widgetDataEndpoint = "/o/surveys/nps/widget";                break;            case rating:                widgetDataEndpoint = "/o/surveys/rating/widget";                break;        }        requestData.append("widget_id=");        requestData.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));        requestData.append("&shown=1");        requestData.append("&sdk_version=");        requestData.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);        requestData.append("&sdk_name=");        requestData.append(Countly.sharedInstance().COUNTLY_SDK_NAME);        requestData.append("&platform=android");        requestData.append("&app_version=");        requestData.append(cachedAppVersion);        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();        String requestDataStr = requestData.toString();        L.d("[ModuleFeedback] Using following request params for retrieving widget data:[" + requestDataStr + "]");        (new ImmediateRequestMaker()).doWork(requestDataStr, widgetDataEndpoint, cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {            @Override public void callback(JSONObject checkResponse) {                if (checkResponse == null) {                    L.d("[ModuleFeedback] Not possible to retrieve widget data. Probably due to lack of connection to the server");                    devCallback.onFinished(null, "Not possible to retrieve widget data. Probably due to lack of connection to the server");                    return;                }                L.d("[ModuleFeedback] Retrieved widget data request: [" + checkResponse.toString() + "]");                devCallback.onFinished(checkResponse, null);            }        }, L);    }    void reportFeedbackWidgetManuallyInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {        if (widgetInfo == null) {            L.e("[ModuleFeedback] Can't report feedback widget data manually with 'null' widget info");            return;        }        L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetData set:[" + (widgetData != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "], widget result set:[" + (widgetResult != null) + "]");        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {            L.w("[ModuleFeedback] Can't report feedback widget data, consent is not granted");            return;        }        if (deviceIdProvider.isTemporaryIdEnabled()) {            L.e("[ModuleFeedback] feedback widget result can't be reported when in temporary device ID mode");            return;        }        if (widgetResult != null) {            UtilsInternalLimits.removeUnsupportedDataTypes(widgetResult, L);            Iterator<Map.Entry<String, Object>> iter = widgetResult.entrySet().iterator();            while (iter.hasNext()) {                Map.Entry<String, Object> entry = iter.next();                if (entry.getKey() == null) {                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' key, it will be removed, value[" + entry.getValue() + "]");                    iter.remove();                } else if (entry.getKey().isEmpty()) {                    L.w("[ModuleFeedback] provided feedback widget result contains an empty string key, it will be removed, value[" + entry.getValue() + "]");                    iter.remove();                } else if (entry.getValue() == null) {                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' value, it will be removed, key[" + entry.getKey() + "]");                    iter.remove();                }                if (entry.getValue() instanceof String) {                    String truncatedValue = UtilsInternalLimits.truncateValueSize(entry.getValue().toString(), _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleFeedback] reportFeedbackWidgetManuallyInternal");                    if (!truncatedValue.equals(entry.getValue())) {                        entry.setValue(truncatedValue);                    }                }            }            if (widgetInfo.type == FeedbackWidgetType.nps) {                if (!widgetResult.containsKey("rating")) {                    L.e("Provided NPS widget result does not have a 'rating' field, result can't be reported");                    return;                }                Object ratingValue = widgetResult.get("rating");                if (!(ratingValue instanceof Integer)) {                    L.e("Provided NPS widget 'rating' field is not an integer, result can't be reported");                    return;                }                int ratingValI = (int) ratingValue;                if (ratingValI < 0 || ratingValI > 10) {                    L.e("Provided NPS widget 'rating' value is out of bounds of the required value '[0;10]', it is probably an error");                }                if (!widgetResult.containsKey("comment")) {                    L.w("Provided NPS widget result does not have a 'comment' field");                }            } else if (widgetInfo.type == FeedbackWidgetType.survey) {            } else if (widgetInfo.type == FeedbackWidgetType.rating) {                if (!widgetResult.containsKey("rating")) {                    L.e("Provided Rating widget result does not have a 'rating' field, result can't be reported");                    return;                }                Object ratingValue = widgetResult.get("rating");                if (!(ratingValue instanceof Integer)) {                    L.e("Provided Rating widget 'rating' field is not an integer, result can't be reported");                    return;                }                int ratingValI = (int) ratingValue;                if (ratingValI < 1 || ratingValI > 5) {                    L.e("Provided Rating widget 'rating' value is out of bounds of the required value '[1;5]', it is probably an error");                }            }        }        if (widgetData == null) {            L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetInfo is 'null', no validation will be done");        } else {            String idInData = widgetData.optString("_id");            if (!widgetInfo.widgetId.equals(idInData)) {                L.w("[ModuleFeedback] id in widget info does not match the id in widget data");            }            String typeInData = widgetData.optString("type");            if (widgetInfo.type == FeedbackWidgetType.nps) {                if (!"nps".equals(typeInData)) {                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [nps]");                }            } else if (widgetInfo.type == FeedbackWidgetType.survey) {                if (!"survey".equals(typeInData)) {                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [survey]");                }            } else if (widgetInfo.type == FeedbackWidgetType.rating) {                if (!"rating".equals(typeInData)) {                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [rating]");                }            }        }        final String usedEventKey;        if (widgetInfo.type == FeedbackWidgetType.nps) {            usedEventKey = NPS_EVENT_KEY;        } else if (widgetInfo.type == FeedbackWidgetType.survey) {            usedEventKey = SURVEY_EVENT_KEY;        } else if (widgetInfo.type == FeedbackWidgetType.rating) {            usedEventKey = RATING_EVENT_KEY;        } else {            usedEventKey = "";        }        Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", cachedAppVersion);        segm.put("widget_id", widgetInfo.widgetId);        if (widgetResult == null) {            segm.put("closed", "1");        } else {            segm.putAll(widgetResult);        }        eventProvider.recordEventInternal(usedEventKey, segm, 1, 0, 0, null, null);    }    private void presentFeedbackWidgetNameIDorTag(@NonNull Context context, @NonNull FeedbackWidgetType type, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {        getAvailableFeedbackWidgetsInternal(new RetrieveFeedbackWidgets() {            @Override public void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error) {                if (error != null) {                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, Failed to retrieve feedback widget list, [" + error + "]");                    return;                }                if (retrievedWidgets.isEmpty()) {                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widgets available");                    return;                }                CountlyFeedbackWidget selectedWidget = null;                for (CountlyFeedbackWidget widget : retrievedWidgets) {                    if (widget.type == type) {                        if (!nameIDorTag.isEmpty()) {                            if (widget.widgetId.equals(nameIDorTag) || widget.name.equals(nameIDorTag)) {                                selectedWidget = widget;                                break;                            }                            for (String tag : widget.tags) {                                if (tag.equals(nameIDorTag)) {                                    selectedWidget = widget;                                    break;                                }                            }                        } else {                            selectedWidget = widget;                            break;                        }                    }                }                if (selectedWidget == null) {                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widget found with the provided nameIDorTag or type");                    return;                }                presentFeedbackWidgetInternal(selectedWidget, context, null, devCallback);            }        });    }    @Override    void initFinished(@NonNull CountlyConfig config) {    }    @Override    void halt() {        feedbackInterface = null;    }    public class Feedback {        public void getAvailableFeedbackWidgets(@Nullable RetrieveFeedbackWidgets callback) {            synchronized (_cly) {                L.i("[Feedback] Trying to retrieve feedback widget list");                getAvailableFeedbackWidgetsInternal(callback);            }        }        public void presentFeedbackWidget(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable Context context, @Nullable String closeButtonText, @Nullable FeedbackCallback devCallback) {            synchronized (_cly) {                L.i("[Feedback] Trying to present feedback widget in an alert dialog");                presentFeedbackWidgetInternal(widgetInfo, context, closeButtonText, devCallback);            }        }        public void getFeedbackWidgetData(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable RetrieveFeedbackWidgetData callback) {            synchronized (_cly) {                L.i("[Feedback] Trying to retrieve feedback widget data");                getFeedbackWidgetDataInternal(widgetInfo, callback);            }        }        public void reportFeedbackWidgetManually(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {            synchronized (_cly) {                L.i("[Feedback] Trying to report feedback widget manually");                reportFeedbackWidgetManuallyInternal(widgetInfo, widgetData, widgetResult);            }        }        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag) {            presentNPS(context, nameIDorTag, null);        }        public void presentNPS(@NonNull Context context) {            presentNPS(context, "");        }        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag) {            presentSurvey(context, nameIDorTag, null);        }        public void presentSurvey(@NonNull Context context) {            presentSurvey(context, "");        }        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag) {            presentRating(context, nameIDorTag, null);        }        public void presentRating(@NonNull Context context) {            presentRating(context, "");        }        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {            synchronized (_cly) {                L.i("[Feedback] presentNPS, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.nps, nameIDorTag, devCallback);            }        }        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {            synchronized (_cly) {                L.i("[Feedback] presentSurvey, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.survey, nameIDorTag, devCallback);            }        }        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {            synchronized (_cly) {                L.i("[Feedback] presentRating, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.rating, nameIDorTag, devCallback);            }        }    }}package ly.count.android.sdk;import android.annotation.SuppressLint;import android.annotation.TargetApi;import android.app.ActivityManager;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.content.pm.FeatureInfo;import android.content.pm.PackageManager;import android.content.res.Configuration;import android.media.AudioManager;import android.net.ConnectivityManager;import android.os.BatteryManager;import android.os.Build;import android.os.Environment;import android.os.StatFs;import android.telephony.TelephonyManager;import android.util.DisplayMetrics;import android.view.Display;import android.view.WindowManager;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;import java.io.UnsupportedEncodingException;import java.util.Date;import java.util.Locale;import java.util.Map;import java.util.TimeZone;import java.util.concurrent.ConcurrentHashMap;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.json.JSONObject;class DeviceInfo {    private final static int startTime = UtilsTime.currentTimestampSeconds();    private boolean inBackground = true;    private static long totalMemory = 0;    MetricProvider mp;    public DeviceInfo(MetricProvider mpOverride) {        mp = mpOverride;        if (mp == null) {            mp = new MetricProvider() {                @NonNull                @Override public String getOS() {                    return "Android";                }                @SuppressWarnings("SameReturnValue")                @NonNull                @Override                public String getOSVersion() {                    return android.os.Build.VERSION.RELEASE;                }                @SuppressWarnings("SameReturnValue")                @NonNull                @Override                public String getDevice() {                    return android.os.Build.MODEL;                }                @SuppressWarnings("SameReturnValue")                @NonNull                @Override                public String getManufacturer() {                    return Build.MANUFACTURER;                }                @NonNull                @Override                public String getResolution(@NonNull final Context context) {                    String resolution = "";                    try {                        final DisplayMetrics metrics = getDisplayMetrics(context);                        resolution = metrics.widthPixels + "x" + metrics.heightPixels;                    } catch (Throwable t) {                        Countly.sharedInstance().L.i("[DeviceInfo] Device resolution cannot be determined");                    }                    return resolution;                }                @NonNull                @Override                public DisplayMetrics getDisplayMetrics(@NonNull final Context context) {                    final WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);                    final Display display = wm.getDefaultDisplay();                    final DisplayMetrics metrics = new DisplayMetrics();                    display.getMetrics(metrics);                    return metrics;                }                @NonNull                @Override                public String getDensity(@NonNull final Context context) {                    String densityStr;                    final int density = context.getResources().getDisplayMetrics().densityDpi;                    switch (density) {                        case DisplayMetrics.DENSITY_LOW:                            densityStr = "LDPI";                            break;                        case DisplayMetrics.DENSITY_MEDIUM:                            densityStr = "MDPI";                            break;                        case DisplayMetrics.DENSITY_TV:                            densityStr = "TVDPI";                            break;                        case DisplayMetrics.DENSITY_HIGH:                            densityStr = "HDPI";                            break;                        case DisplayMetrics.DENSITY_260:                        case DisplayMetrics.DENSITY_280:                        case DisplayMetrics.DENSITY_300:                        case DisplayMetrics.DENSITY_XHIGH:                            densityStr = "XHDPI";                            break;                        case DisplayMetrics.DENSITY_340:                        case DisplayMetrics.DENSITY_360:                        case DisplayMetrics.DENSITY_400:                        case DisplayMetrics.DENSITY_420:                        case DisplayMetrics.DENSITY_XXHIGH:                            densityStr = "XXHDPI";                            break;                        case DisplayMetrics.DENSITY_560:                        case DisplayMetrics.DENSITY_XXXHIGH:                            densityStr = "XXXHDPI";                            break;                        default:                            densityStr = "other";                            break;                    }                    return densityStr;                }                @NonNull                @Override                public String getCarrier(@NonNull final Context context) {                    String carrier = "";                    final TelephonyManager manager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);                    if (manager != null) {                        carrier = manager.getNetworkOperatorName();                    }                    if (carrier == null || carrier.length() == 0) {                        carrier = "";                        Countly.sharedInstance().L.i("[DeviceInfo] No carrier found");                    }                    if (carrier.equals("--")) {                        carrier = "";                    }                    return carrier;                }                @Override                public int getTimezoneOffset() {                    return TimeZone.getDefault().getOffset(new Date().getTime()) / 60_000;                }                @NonNull                @Override                public String getLocale() {                    final Locale locale = Locale.getDefault();                    return locale.getLanguage() + "_" + locale.getCountry();                }                @NonNull                @Override                public String getAppVersion(@NonNull final Context context) {                    String result = Countly.DEFAULT_APP_VERSION;                    try {                        String tmpVersion = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;                        if (tmpVersion != null) {                            result = tmpVersion;                        }                    } catch (PackageManager.NameNotFoundException e) {                        Countly.sharedInstance().L.i("[DeviceInfo] No app version found");                    }                    return result;                }                @NonNull                @Override                public String getStore(@NonNull final Context context) {                    String result = "";                    try {                        result = context.getPackageManager().getInstallerPackageName(context.getPackageName());                    } catch (Exception e) {                        Countly.sharedInstance().L.d("[DeviceInfo, getStore] Can't get Installer package ");                    }                    if (result == null || result.length() == 0) {                        result = "";                        Countly.sharedInstance().L.d("[DeviceInfo, getStore] No store found");                    }                    return result;                }                @NonNull                @Override                public String getDeviceType(@NonNull final Context context) {                    if (Utils.isDeviceTv(context)) {                        return "smarttv";                    }                    if (Utils.isDeviceTablet(context)) {                        return "tablet";                    }                    return "mobile";                }                @Override                public long getTotalRAM() {                    if (totalMemory == 0) {                        RandomAccessFile reader = null;                        String load;                        try {                            reader = new RandomAccessFile("/proc/meminfo", "r");                            load = reader.readLine();                            Pattern p = Pattern.compile("(\\d+)");                            Matcher m = p.matcher(load);                            String value = "";                            while (m.find()) {                                value = m.group(1);                            }                            try {                                if (value != null) {                                    totalMemory = Long.parseLong(value) / 1024;                                } else {                                    totalMemory = 0;                                }                            } catch (NumberFormatException ex) {                                totalMemory = 0;                            }                        } catch (IOException ex) {                            try {                                if (reader != null) {                                    reader.close();                                }                            } catch (IOException exc) {                                exc.printStackTrace();                            }                            ex.printStackTrace();                        } finally {                            try {                                if (reader != null) {                                    reader.close();                                }                            } catch (IOException exc) {                                exc.printStackTrace();                            }                        }                    }                    return totalMemory;                }                @NonNull                @Override                public String getRamCurrent(Context context) {                    ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();                    ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);                    activityManager.getMemoryInfo(mi);                    return Long.toString(getTotalRAM() - (mi.availMem / 1_048_576L));                }                @NonNull                @Override                public String getRamTotal() {                    return Long.toString(getTotalRAM());                }                @NonNull                @Override                public String getCpu() {                    return Build.SUPPORTED_ABIS[0];                }                @NonNull                @Override                public String getOpenGL(Context context) {                    PackageManager packageManager = context.getPackageManager();                    FeatureInfo[] featureInfos = packageManager.getSystemAvailableFeatures();                    if (featureInfos != null && featureInfos.length > 0) {                        for (FeatureInfo featureInfo : featureInfos) {                            if (featureInfo.name == null) {                                if (featureInfo.reqGlEsVersion != FeatureInfo.GL_ES_VERSION_UNDEFINED) {                                    return Integer.toString((featureInfo.reqGlEsVersion & 0xffff0000) >> 16);                                } else {                                    return "1";                                 }                            }                        }                    }                    return "1";                }                @TargetApi(18)                @NonNull                @Override                public String getDiskCurrent() {                    if (android.os.Build.VERSION.SDK_INT < 18) {                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());                        long total = (long) statFs.getBlockCount() * (long) statFs.getBlockSize();                        long free = (long) statFs.getAvailableBlocks() * (long) statFs.getBlockSize();                        return Long.toString((total - free) / 1_048_576L);                    } else {                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());                        long total = statFs.getBlockCountLong() * statFs.getBlockSizeLong();                        long free = statFs.getAvailableBlocksLong() * statFs.getBlockSizeLong();                        return Long.toString((total - free) / 1048576L);                    }                }                @TargetApi(18)                @NonNull                @Override                public String getDiskTotal() {                    if (android.os.Build.VERSION.SDK_INT < 18) {                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());                        long total = (long) statFs.getBlockCount() * (long) statFs.getBlockSize();                        return Long.toString(total / 1048576L);                    } else {                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());                        long total = statFs.getBlockCountLong() * statFs.getBlockSizeLong();                        return Long.toString(total / 1048576L);                    }                }                @Nullable                @Override                public String getBatteryLevel(Context context) {                    try {                        Intent batteryIntent;                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {                            batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED), null, null, Context.RECEIVER_NOT_EXPORTED);                        } else {                            batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));                        }                        if (batteryIntent != null) {                            int level = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);                            int scale = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);                            if (level > -1 && scale > 0) {                                return Float.toString(((float) level / (float) scale) * 100.0f);                            }                        }                    } catch (Exception e) {                        Countly.sharedInstance().L.i("Can't get battery level");                    }                    return null;                }                @Nullable                @Override                public String getOrientation(Context context) {                    int orientation = context.getResources().getConfiguration().orientation;                    switch (orientation) {                        case Configuration.ORIENTATION_LANDSCAPE:                            return "Landscape";                        case Configuration.ORIENTATION_PORTRAIT:                            return "Portrait";                        case Configuration.ORIENTATION_SQUARE:                            return "Square";                        case Configuration.ORIENTATION_UNDEFINED:                            return "Unknown";                        default:                            return null;                    }                }                @NonNull                @Override                public String isRooted() {                    String[] paths = {                        "/sbin/su", "/system/bin/su", "/system/xbin/su", "/data/local/xbin/su", "/data/local/bin/su", "/system/sd/xbin/su",                        "/system/bin/failsafe/su", "/data/local/su"                    };                    for (String path : paths) {                        if (new File(path).exists()) return "true";                    }                    return "false";                }                @SuppressLint("MissingPermission")                @Nullable                @Override                public String isOnline(Context context) {                    try {                        ConnectivityManager conMgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);                        if (conMgr != null && conMgr.getActiveNetworkInfo() != null                            && conMgr.getActiveNetworkInfo().isAvailable()                            && conMgr.getActiveNetworkInfo().isConnected()) {                            return "true";                        }                        return "false";                    } catch (Exception e) {                        Countly.sharedInstance().L.w("isOnline, Got exception determining netwprl connectivity", e);                    }                    return null;                }                @NonNull                @Override                public String isMuted(Context context) {                    try {                        AudioManager audio = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);                        switch (audio.getRingerMode()) {                            case AudioManager.RINGER_MODE_SILENT:                            case AudioManager.RINGER_MODE_VIBRATE:                                return "true";                            default:                                return "false";                        }                    } catch (Throwable thr) {                        return "false";                    }                }                @Override                public String hasHinge(Context context) {                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {                        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_SENSOR_HINGE_ANGLE) + "";                    }                    return "false";                }                @Override public String getRunningTime() {                    return Integer.toString(UtilsTime.currentTimestampSeconds() - startTime);                }            };        }    }    @NonNull    Map<String, Object> getCommonMetrics(@NonNull final Context context, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {        final Map<String, Object> map = new ConcurrentHashMap<>();        putIfNotNullAndNotEmpty(map, "_device", mp.getDevice());        putIfNotNullAndNotEmpty(map, "_os", mp.getOS());        putIfNotNullAndNotEmpty(map, "_os_version", mp.getOSVersion());        putIfNotNullAndNotEmpty(map, "_resolution", mp.getResolution(context));        putIfNotNullAndNotEmpty(map, "_app_version", mp.getAppVersion(context));        putIfNotNullAndNotEmpty(map, "_manufacturer", mp.getManufacturer());        putIfNotNullAndNotEmpty(map, "_has_hinge", mp.hasHinge(context));        if (metricOverride != null) {            try {                if (metricOverride.containsKey("_device")) {                    map.put("_device", metricOverride.get("_device"));                }                if (metricOverride.containsKey("_os")) {                    map.put("_os", metricOverride.get("_os"));                }                if (metricOverride.containsKey("_os_version")) {                    map.put("_os_version", metricOverride.get("_os_version"));                }                if (metricOverride.containsKey("_resolution")) {                    map.put("_resolution", metricOverride.get("_resolution"));                }                if (metricOverride.containsKey("_app_version")) {                    map.put("_app_version", metricOverride.get("_app_version"));                }                if (metricOverride.containsKey("_manufacturer")) {                    map.put("_manufacturer", metricOverride.get("_manufacturer"));                }                if (metricOverride.containsKey("_has_hinge")) {                    map.put("_has_hinge", metricOverride.get("_has_hinge"));                }            } catch (Exception e) {                L.e("[DeviceInfo] getCommonMetrics, SDK encountered failure while trying to apply metric override, " + e);            }        }        return map;    }    private void putIfNotNullAndNotEmpty(@NonNull Map<String, Object> metrics, String key, String value) {        if (value != null && !value.isEmpty()) {            metrics.put(key, value);        }    }    @NonNull    String getMetrics(@NonNull final Context context, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {        Map<String, Object> metrics = getCommonMetrics(context, null, L);        putIfNotNullAndNotEmpty(metrics, "_carrier", mp.getCarrier(context));        putIfNotNullAndNotEmpty(metrics, "_density", mp.getDensity(context));        putIfNotNullAndNotEmpty(metrics, "_locale", mp.getLocale());        putIfNotNullAndNotEmpty(metrics, "_store", mp.getStore(context));        putIfNotNullAndNotEmpty(metrics, "_device_type", mp.getDeviceType(context));        if (metricOverride != null) {            for (String k : metricOverride.keySet()) {                if (k == null || k.isEmpty()) {                    L.w("[DeviceInfo] getMetrics, Provided metric override key can't be null or empty");                    continue;                }                String overrideValue = metricOverride.get(k);                if (overrideValue == null) {                    L.w("[DeviceInfo] getMetrics, Provided metric override value can't be null, key:[" + k + "]");                    continue;                }                metrics.put(k, overrideValue);            }        }        String result = new JSONObject(metrics).toString();        try {            result = java.net.URLEncoder.encode(result, "UTF-8");        } catch (UnsupportedEncodingException ex) {            Countly.sharedInstance().L.e("[getMetrics] encode failed, [" + ex + "]");        }        return result;    }    @NonNull    String getMetricsHealthCheck(@NonNull final Context context, @Nullable final Map<String, String> metricOverride) {        Map<String, Object> metrics = new ConcurrentHashMap<>();        String appVersion = mp.getAppVersion(context);        if (metricOverride != null) {            if (metricOverride.containsKey("_app_version")) {                appVersion = metricOverride.get("_app_version");            }        }        metrics.put("_app_version", appVersion);        String result = new JSONObject(metrics).toString();        try {            result = java.net.URLEncoder.encode(result, "UTF-8");        } catch (UnsupportedEncodingException ex) {            Countly.sharedInstance().L.e("[getMetrics] encode failed, [" + ex + "]");        }        return result;    }    @NonNull    JSONObject getCrashDataJSON(@NonNull CrashData crashData, final boolean isNativeCrash) {        Map<String, Object> crashDataMap = crashData.getCrashMetrics();        crashDataMap.put("_ob", crashData.getChangedFieldsAsInt());        putIfNotNullAndNotEmpty(crashDataMap, "_error", crashData.getStackTrace());        putIfNotNullAndNotEmpty(crashDataMap, "_nonfatal", Boolean.toString(!crashData.getFatal()));        if (!isNativeCrash) {            String breadcrumbs = crashData.getBreadcrumbsAsString();            if (!breadcrumbs.isEmpty()) {                crashDataMap.put("_logs", breadcrumbs);            }        }        if (!crashData.getCrashSegmentation().isEmpty()) {            crashDataMap.put("_custom", crashData.getCrashSegmentation());        }        return new JSONObject(crashDataMap);    }    @NonNull    Map<String, Object> getCrashMetrics(@NonNull final Context context, boolean isNativeCrash, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {        Map<String, Object> metrics = getCommonMetrics(context, metricOverride, L);        putIfNotNullAndNotEmpty(metrics, "_cpu", mp.getCpu());        putIfNotNullAndNotEmpty(metrics, "_opengl", mp.getOpenGL(context));        putIfNotNullAndNotEmpty(metrics, "_root", mp.isRooted());        putIfNotNullAndNotEmpty(metrics, "_ram_total", mp.getRamTotal());        putIfNotNullAndNotEmpty(metrics, "_disk_total", mp.getDiskTotal());        if (!isNativeCrash) {            putIfNotNullAndNotEmpty(metrics, "_ram_current", mp.getRamCurrent(context));            putIfNotNullAndNotEmpty(metrics, "_disk_current", mp.getDiskCurrent());            putIfNotNullAndNotEmpty(metrics, "_bat", mp.getBatteryLevel(context));            putIfNotNullAndNotEmpty(metrics, "_run", mp.getRunningTime());            putIfNotNullAndNotEmpty(metrics, "_orientation", mp.getOrientation(context));            putIfNotNullAndNotEmpty(metrics, "_online", mp.isOnline(context));            putIfNotNullAndNotEmpty(metrics, "_muted", mp.isMuted(context));            putIfNotNullAndNotEmpty(metrics, "_background", isInBackground());        } else {            metrics.put("_native_cpp", true);        }        return metrics;    }    @NonNull    public String getAppVersionWithOverride(@NonNull final Context context, @Nullable final Map<String, String> metricOverride) {        String appVersion = mp.getAppVersion(context);        if (metricOverride != null && metricOverride.containsKey("_app_version")) {            String overrideVersion = metricOverride.get("_app_version");            if (overrideVersion != null) {                appVersion = overrideVersion;            }        }        return appVersion;    }    void inForeground() {        inBackground = false;    }    void inBackground() {        inBackground = true;    }    String isInBackground() {        return Boolean.toString(inBackground);    }}package ly.count.android.sdk;import android.app.Activity;import android.content.res.Configuration;import androidx.annotation.NonNull;import java.util.List;abstract class ModuleBase {    final Countly _cly;    ModuleLog L;    ConsentProvider consentProvider;    StorageProvider storageProvider;    EventProvider eventProvider;    RequestQueueProvider requestQueueProvider;    DeviceIdProvider deviceIdProvider;    BaseInfoProvider baseInfoProvider;    ViewIdProvider viewIdProvider;    ConfigurationProvider configProvider;    HealthTracker healthTracker;    DeviceInfo deviceInfo;    PerformanceCounterCollector pcc;    ModuleBase(@NonNull Countly cly, @NonNull CountlyConfig config) {        _cly = cly;        L = cly.L;        consentProvider = config.consentProvider;        storageProvider = config.storageProvider;        eventProvider = config.eventProvider;        requestQueueProvider = config.requestQueueProvider;        deviceIdProvider = config.deviceIdProvider;        baseInfoProvider = config.baseInfoProvider;        viewIdProvider = config.viewIdProvider;        configProvider = config.configProvider;        healthTracker = config.healthTracker;        deviceInfo = config.deviceInfo;        pcc = config.pcc;    }    void halt() {        throw new UnsupportedOperationException();    }    void onConfigurationChanged(Configuration newConfig) {    }    void onActivityStarted(Activity activity, int updatedActivityCount) {    }    void onActivityStopped(int updatedActivityCount) {    }    void callbackOnActivityResumed(Activity activity) {    }    void callbackOnActivityStopped(Activity activity) {    }    void deviceIdChanged(boolean withoutMerge) {    }    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {    }    void consentWillChange(@NonNull List<String> consentThatWillChange, final boolean isConsentGiven) {    }    void sdkConfigurationChanged() {    }    void initFinished(@NonNull CountlyConfig config) {    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import org.json.JSONArray;public class UtilsInternalLimits {    private UtilsInternalLimits() {    }    protected static String truncateKeyLength(@Nullable String key, final int limit, @NonNull ModuleLog L, @NonNull String tag) {        return truncateString(key, limit, L, tag + ": [UtilsSdkInternalLimits] truncateKeyLength");    }    protected static String truncateValueSize(@Nullable String value, final int limit, @NonNull ModuleLog L, @NonNull String tag) {        return truncateString(value, limit, L, tag + ": [UtilsSdkInternalLimits] truncateValueSize");    }    private static String truncateString(@Nullable String value, final int limit, @NonNull ModuleLog L, @NonNull String tag) {        assert limit >= 1;        assert tag != null;        assert L != null;        if (value == null) {            L.w(tag + ", value is null, returning");            return value;        }        if (value.isEmpty()) {            L.w(tag + ", value is empty, returning");            return value;        }        assert value != null;        if (value.length() > limit) {            String truncatedValue = value.substring(0, limit);            L.w(tag + ", Value length exceeds limit of " + limit + " characters. Truncating value to " + limit + " characters. Truncated to " + truncatedValue);            return truncatedValue;        }        return value;    }    protected static <T> void truncateSegmentationKeys(@Nullable Map<String, T> map, final int limit, @NonNull ModuleLog L, @NonNull String tag) {        assert limit >= 1;        assert L != null;        assert tag != null;        if (map == null) {            L.w(tag + ": [UtilsSdkInternalLimits] truncateMapKeys, map is null, returning");            return;        }        if (map.isEmpty()) {            L.w(tag + ": [UtilsSdkInternalLimits] truncateMapKeys, map is empty, returning");            return;        }        assert map != null;        L.w(tag + ": [UtilsSdkInternalLimits] truncateMapKeys, map:[" + map + "]");        Map<String, T> gonnaReplace = new ConcurrentHashMap<>();        List<String> gonnaRemove = new ArrayList<>();        for (Map.Entry<String, T> entry : map.entrySet()) {            String truncatedKey = truncateKeyLength(entry.getKey(), limit, L, tag);            if (!truncatedKey.equals(entry.getKey())) {                gonnaReplace.put(truncatedKey, entry.getValue());                gonnaRemove.add(entry.getKey());            }        }        for (String key : gonnaRemove) {            map.remove(key);        }        map.putAll(gonnaReplace);    }    protected static void truncateSegmentationKeysValues(@NonNull Map<String, Object> segmentation, @NonNull ConfigSdkInternalLimits limitsConfig, @NonNull ModuleLog L, @NonNull String tag) {        assert segmentation != null;        assert limitsConfig != null;        assert L != null;        assert tag != null;        L.w(tag + ": [UtilsSdkInternalLimits] truncateMapKeys, segmentation:[" + segmentation + "]");        Iterator<Map.Entry<String, Object>> iterator = segmentation.entrySet().iterator();        Map<String, Object> gonnaReplace = new ConcurrentHashMap<>();        while (iterator.hasNext()) {            Map.Entry<String, Object> entry = iterator.next();            String truncatedKey = truncateKeyLength(entry.getKey(), limitsConfig.maxKeyLength, L, tag);            Object value = entry.getValue();            if (!isSupportedDataType(value)) {                iterator.remove();                continue;            }            if (value instanceof String) {                value = truncateValueSize((String) value, limitsConfig.maxValueSize, L, tag);            }            if (!truncatedKey.equals(entry.getKey())) {                iterator.remove();                 gonnaReplace.put(truncatedKey, value);             } else if (value instanceof String && !value.equals(entry.getValue())) {                segmentation.put(truncatedKey, value);             }        }        segmentation.putAll(gonnaReplace);    }    protected static void applySdkInternalLimitsToSegmentation(@NonNull Map<String, Object> segmentation, @NonNull ConfigSdkInternalLimits limitsConfig, @NonNull ModuleLog L, @NonNull String tag) {        assert limitsConfig != null;        assert L != null;        assert tag != null;        assert segmentation != null;        if (segmentation.isEmpty()) {            L.w(tag + ": [UtilsSdkInternalLimits] applySdkInternalLimitsToSegmentation, map is empty, returning");            return;        }        truncateSegmentationKeysValues(segmentation, limitsConfig, L, tag);        truncateSegmentationValues(segmentation, limitsConfig.maxSegmentationValues, tag, L);    }    static void applyInternalLimitsToBreadcrumbs(@NonNull List<String> breadcrumbs, @NonNull ConfigSdkInternalLimits limitsConfig, @NonNull ModuleLog L, @NonNull String tag) {        assert breadcrumbs != null;        assert limitsConfig != null;        assert L != null;        assert tag != null;        if (breadcrumbs.isEmpty()) {            L.w(tag + ": [UtilsSdkInternalLimits] applyInternalLimitsToBreadcrumbs, breadcrumbs is empty, returning");            return;        }        Iterator<String> iterator = breadcrumbs.iterator();        while (iterator.hasNext()) {            if (breadcrumbs.size() > limitsConfig.maxBreadcrumbCount) {                String breadcrumb = iterator.next();                L.w(tag + ": [UtilsSdkInternalLimits] applyInternalLimitsToBreadcrumbs, breadcrumb:[" + breadcrumb + "]");                iterator.remove();            } else {                break;            }        }        for (int i = 0; i < breadcrumbs.size(); i++) {            String breadcrumb = breadcrumbs.get(i);            String truncatedBreadcrumb = truncateValueSize(breadcrumb, limitsConfig.maxValueSize, L, tag);            if (!truncatedBreadcrumb.equals(breadcrumb)) {                breadcrumbs.set(i, truncatedBreadcrumb);            }        }    }    static <T> void truncateSegmentationValues(@NonNull final Map<String, T> segmentation, final int maxCount, @NonNull final String messagePrefix, final @NonNull ModuleLog L) {        assert segmentation != null;        assert maxCount >= 1;        assert L != null;        assert messagePrefix != null;        Iterator<Map.Entry<String, T>> iterator = segmentation.entrySet().iterator();        while (iterator.hasNext()) {            if (segmentation.size() > maxCount) {                Map.Entry<String, T> value = iterator.next();                String key = value.getKey();                L.w(messagePrefix + ", Value exceeded the maximum segmentation count key:[" + key + "]");                iterator.remove();            } else {                break;            }        }    }    static void removeReservedKeysFromSegmentation(@NonNull Map<String, Object> segmentation, @NonNull String[] reservedKeys, @NonNull String messagePrefix, @NonNull ModuleLog L) {        assert segmentation != null;        assert reservedKeys != null;        assert L != null;        assert messagePrefix != null;        for (String rKey : reservedKeys) {            if (segmentation.containsKey(rKey)) {                L.w(messagePrefix + " provided segmentation contains protected key [" + rKey + "]");                segmentation.remove(rKey);            }        }    }    static boolean removeUnsupportedDataTypes(@NonNull Map<String, Object> data, @NonNull ModuleLog L) {        assert data != null;        StringBuilder removedKeys = new StringBuilder();        Map<String, Object> gonnaReplace = new ConcurrentHashMap<>();        for (Iterator<Map.Entry<String, Object>> it = data.entrySet().iterator(); it.hasNext(); ) {            Map.Entry<String, Object> entry = it.next();            String key = entry.getKey();            Object value = entry.getValue();            if (key == null || key.isEmpty() || !(isSupportedDataType(value))) {                it.remove();                removedKeys.append("key:[").append(key).append("] value:[").append(value).append("] type:[").append(value == null ? "null" : value.getClass().getSimpleName()).append("] ,");            } else if (value instanceof List) {                List<?> list = (List<?>) value;                list = new ArrayList<>(list);                int a = list.size();                for (int i = 0; i < a; i++) {                    Object element = list.get(i);                    if (!isSupportedDataTypeBasic(element)) {                        removedKeys.append("from_list").append(list).append("index:[").append(i).append("] value:[").append(element).append("] type:[").append(element == null ? "null" : element.getClass().getSimpleName()).append("] ,");                        list.remove(i);                        i--;                        a--;                    }                }                gonnaReplace.put(key, list);            } else if (value instanceof JSONArray) {                JSONArray jsonArray = (JSONArray) value;                int a = jsonArray.length();                for (int i = 0; i < a; i++) {                    Object element = jsonArray.opt(i);                    if (!isSupportedDataTypeBasic(element)) {                        removedKeys.append("from_list").append(jsonArray).append("index:[").append(i).append("] value:[").append(element).append("] type:[").append(element == null ? "null" : element.getClass().getSimpleName()).append("] ,");                        jsonArray.remove(i);                        i--;                        a--;                    }                }                gonnaReplace.put(key, jsonArray);            }        }        String removedKeysStr = removedKeys.toString();        data.putAll(gonnaReplace);        if (!removedKeysStr.isEmpty()) {            L.w("[UtilsInternalLimits] removeUnsupportedDataTypes, removed " + removedKeysStr + " from the provided data map.");        }        return !removedKeysStr.isEmpty();    }    protected static String applyInternalLimitsToStackTraces(@NonNull String stackTrace, final int maxStackTraceLineLength, @NonNull String tag, @NonNull ModuleLog L) {        assert stackTrace != null;        assert maxStackTraceLineLength >= 1;        assert tag != null;        assert L != null;        StringBuilder sb = new StringBuilder(stackTrace.length());        String[] stackTraceLines = stackTrace.split("\n");        for (int i = 0; i < stackTraceLines.length; i++) {            String truncatedLine = UtilsInternalLimits.truncateString(stackTraceLines[i], maxStackTraceLineLength, L, tag);            if (i != 0) {                sb.append('\n');            }            sb.append(truncatedLine);        }        return sb.toString();    }    private static boolean isSupportedDataTypeBasic(@Nullable Object value) {        return value instanceof String || value instanceof Integer || value instanceof Double || value instanceof Boolean || value instanceof Float || value instanceof Long;    }    static boolean isSupportedDataType(@Nullable Object value) {        if (isSupportedDataTypeBasic(value)) {            return true;        } else if (value instanceof List || value instanceof JSONArray) {            return true;        } else if (value != null && value.getClass().isArray()) {            Class<?> componentType = value.getClass().getComponentType();            return componentType == String.class || componentType == Integer.class || componentType == Double.class || componentType == Boolean.class || componentType == Float.class || componentType == Long.class                || componentType == int.class || componentType == double.class || componentType == boolean.class || componentType == float.class || componentType == long.class;        }        return false;    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.test.core.app.ApplicationProvider;import androidx.test.ext.junit.runners.AndroidJUnit4;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.Mockito;import org.mockito.internal.util.collections.Sets;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.isNull;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;@RunWith(AndroidJUnit4.class)public class ModuleFeedbackTests {    Countly mCountly;    @Before    public void setUp() {        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));        countlyStore.clear();        mCountly = new Countly();        mCountly.init(new CountlyConfig(TestUtils.getContext(), "appkey", "http:    }    @After    public void tearDown() {    }    @Test    public void parseFeedbackList_null() throws JSONException {        List<ModuleFeedback.CountlyFeedbackWidget> ret = ModuleFeedback.parseFeedbackList(null);        Assert.assertNotNull(ret);        Assert.assertEquals(0, ret.size());    }    @Test    public void parseFeedbackList_oneGoodWithGarbage() throws JSONException {        String requestJson =            "{\"result\":[{\"_id\":\"asd\",\"type\":\"qwe\",\"name\":\"zxc\",\"tg\":[]},{\"_id\":\"5f97284635935cc338e78200\",\"type\":\"nps\",\"name\":\"fsdfsdf\",\"tg\":[\"/\"]},{\"g4id\":\"asd1\",\"t4type\":\"432\",\"nagdfgme\":\"zxct\",\"tgm\":[\"/\"]}]}";        JSONObject jObj = new JSONObject(requestJson);        List<ModuleFeedback.CountlyFeedbackWidget> ret = ModuleFeedback.parseFeedbackList(jObj);        Assert.assertNotNull(ret);        Assert.assertEquals(1, ret.size());        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "fsdfsdf", "5f97284635935cc338e78200", new String[] { "/" }, ret.get(0));    }    @Test    public void parseFeedbackList() throws JSONException {        String requestJson =            "{\"result\":[{\"_id\":\"5f8c6f959627f99e8e7de746\",\"type\":\"survey\",\"exitPolicy\":\"onAbandon\",\"appearance\":{\"show\":\"uSubmit\",\"position\":\"bLeft\",\"color\":\"#2eb52b\"},\"name\":\"sdfsdfdsf\",\"tg\":[\"/\"]},{\"_id\":\"5f8c6fd81ac8659e8846acf4\",\"type\":\"nps\",\"name\":\"fdsfsd\",\"tg\":[\"a\",\"0\"]},{\"_id\":\"5f97284635935cc338e78200\",\"type\":\"nps\",\"name\":\"fsdfsdf\",\"tg\":[]},{\"_id\":\"614871419f030e44be07d82f\",\"type\":\"rating\",\"appearance\":{\"position\":\"mleft\",\"bg_color\":\"#fff\",\"text_color\":\"#ddd\",\"text\":\"Feedback\"},\"tg\":[\"\\/\"],\"name\":\"ratingName1\"}]}";        JSONObject jObj = new JSONObject(requestJson);        List<ModuleFeedback.CountlyFeedbackWidget> ret = ModuleFeedback.parseFeedbackList(jObj);        Assert.assertNotNull(ret);        Assert.assertEquals(4, ret.size());        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey, "sdfsdfdsf", "5f8c6f959627f99e8e7de746", new String[] { "/" }, ret.get(0));        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "fdsfsd", "5f8c6fd81ac8659e8846acf4", new String[] { "a", "0" }, ret.get(1));        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "fsdfsdf", "5f97284635935cc338e78200", new String[] {}, ret.get(2));        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating, "ratingName1", "614871419f030e44be07d82f", new String[] { "/" }, ret.get(3));    }    @Test    public void parseFaultyFeedbackList() throws JSONException {        String requestJson =            "{\"result\":["                + "{\"_id\":\"survID1\",\"type\":\"survey\",\"exitPolicy\":\"onAbandon\",\"appearance\":{\"show\":\"uSubmit\",\"position\":\"bLeft\",\"color\":\"#2eb52b\"},\"name\":\"surv1\"},"                + "{\"_id\":\"survID2\",\"type\":\"survey\",\"exitPolicy\":\"onAbandon\",\"appearance\":{\"show\":\"uSubmit\",\"position\":\"bLeft\",\"color\":\"#2eb52b\"},\"tg\":[\"/\"]},"                + "{\"type\":\"survey\",\"exitPolicy\":\"onAbandon\",\"appearance\":{\"show\":\"uSubmit\",\"position\":\"bLeft\",\"color\":\"#2eb52b\"},\"name\":\"surv3\",\"tg\":[\"/\"]},"                + "{\"_id\":\"npsID1\",\"type\":\"nps\",\"name\":\"nps1\"},"                + "{\"_id\":\"npsID2\",\"type\":\"nps\",\"tg\":[]},"                + "{\"type\":\"nps\",\"name\":\"nps3\",\"tg\":[]},"                + "{\"_id\":\"ratingID1\",\"type\":\"rating\",\"appearance\":{\"position\":\"mleft\",\"bg_color\":\"#fff\",\"text_color\":\"#ddd\",\"text\":\"Feedback\"},\"name\":\"rating1\"},"                + "{\"_id\":\"ratingID2\",\"type\":\"rating\",\"appearance\":{\"position\":\"mleft\",\"bg_color\":\"#fff\",\"text_color\":\"#ddd\",\"text\":\"Feedback\"},\"tg\":[\"\\/\"]},"                + "{\"type\":\"rating\",\"appearance\":{\"position\":\"mleft\",\"bg_color\":\"#fff\",\"text_color\":\"#ddd\",\"text\":\"Feedback\"},\"tg\":[\"\\/\"],\"name\":\"rating3\"}"                + "]}";        JSONObject jObj = new JSONObject(requestJson);        List<ModuleFeedback.CountlyFeedbackWidget> ret = ModuleFeedback.parseFeedbackList(jObj);        Assert.assertNotNull(ret);        Assert.assertEquals(6, ret.size());        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey, "surv1", "survID1", new String[] {}, ret.get(0));        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey, "", "survID2", new String[] { "/" }, ret.get(1));        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "nps1", "npsID1", new String[] {}, ret.get(2));        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "", "npsID2", new String[] {}, ret.get(3));        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating, "rating1", "ratingID1", new String[] {}, ret.get(4));        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating, "", "ratingID2", new String[] { "/" }, ret.get(5));    }    void ValidateReturnedFeedbackWidget(@NonNull ModuleFeedback.FeedbackWidgetType type, @NonNull String wName, @NonNull String wId, @NonNull String[] wTags, @NonNull ModuleFeedback.CountlyFeedbackWidget fWidget) {        Assert.assertEquals(type, fWidget.type);        Assert.assertEquals(wName, fWidget.name);        Assert.assertEquals(wId, fWidget.widgetId);        Assert.assertArrayEquals(wTags, fWidget.tags);    }    @Test    public void reportFeedbackWidgetManuallyNPSReported() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.nps;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        final Map<String, Object> segmRes = new HashMap<>();        segmRes.put("rating", 4);        segmRes.put("comment", "123456");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        final Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", "1.0");        segm.put("widget_id", widgetInfo.widgetId);        segm.put("rating", 4);        segm.put("comment", "123456");        verify(ep).recordEventInternal(ModuleFeedback.NPS_EVENT_KEY, segm, 1, 0, 0, null, null);        mCountly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);        segmRes.put("rating", 10);        segmRes.put("comment", null);        segm.put("rating", 10);        segm.remove("comment");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep).recordEventInternal(ModuleFeedback.NPS_EVENT_KEY, segm, 1, 0, 0, null, null);    }    @Test    public void reportFeedbackWidgetManuallyRatingReported() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.rating;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        final Map<String, Object> segmRes = new HashMap<>();        segmRes.put("rating", 4);        segmRes.put("comment", "123456");        segmRes.put("email", "123456");        segmRes.put("contactMe", true);        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        final Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", "1.0");        segm.put("widget_id", widgetInfo.widgetId);        segm.put("rating", 4);        segm.put("comment", "123456");        segm.put("email", "123456");        segm.put("contactMe", true);        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);        mCountly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);        segmRes.put("rating", 2);        segmRes.put("comment", null);        segm.put("rating", 2);        segm.remove("comment");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);    }    @Test    public void reportFeedbackWidgetManuallyNPSClosed() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.nps;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, null);        final Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", "1.0");        segm.put("widget_id", widgetInfo.widgetId);        segm.put("closed", "1");        verify(ep).recordEventInternal(ModuleFeedback.NPS_EVENT_KEY, segm, 1, 0, 0, null, null);    }    @Test    public void reportFeedbackWidgetManuallyRatingClosed() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.rating;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, null);        final Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", "1.0");        segm.put("widget_id", widgetInfo.widgetId);        segm.put("closed", "1");        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);    }    @Test    public void reportFeedbackWidgetManuallyNPSBadResult_1() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.nps;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        final Map<String, Object> segmRes = new HashMap<>();        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        JSONObject emptyJObj = new JSONObject();        segmRes.put("bla", "gg");        segmRes.put("11", null);        segmRes.put(null, "gf");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));    }    @Test    public void reportFeedbackWidgetManuallyRatingBadResult_1() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.rating;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        final Map<String, Object> segmRes = new HashMap<>();        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        JSONObject emptyJObj = new JSONObject();        segmRes.put("bla", "gg");        segmRes.put("11", null);        segmRes.put(null, "gf");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));    }    @Test    public void reportFeedbackWidgetManuallyNPSBadResult_2() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.nps;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        final Map<String, Object> segmRes = new HashMap<>();        segmRes.put("rating", "gg");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", null);        segmRes.put("comment", "123456");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "5.5");        JSONObject emptyJObj = new JSONObject();        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "6.0");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "0.0");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "10.0f");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));    }    @Test    public void reportFeedbackWidgetManuallyRatingBadResult_2() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.rating;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        final Map<String, Object> segmRes = new HashMap<>();        segmRes.put("rating", "gg");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", null);        segmRes.put("comment", "123456");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "5.5");        JSONObject emptyJObj = new JSONObject();        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "6.0");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "0.0");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        segmRes.put("rating", "10.0f");        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));    }    @Test    public void reportFeedbackWidgetManuallySurveyClosed() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey);        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, null);        final Map<String, Object> segm = TestUtils.map("closed", "1");        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);        verify(ep).recordEventInternal(ModuleFeedback.SURVEY_EVENT_KEY, segm, 1, 0, 0, null, null);    }    @Test    public void internalLimit_reportFeedbackWidgetManuallySurvey() throws JSONException {        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http:        config.sdkInternalLimits.setMaxKeyLength(2);        Countly countly = new Countly().init(config);        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("key1", "value1", "key2", "value2", "key3", "value3"));        final Map<String, Object> segm = TestUtils.map("key1", "value1", "key2", "value2", "key3", "value3");        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, segm, 0);    }    @Test    public void internalLimit_reportFeedbackWidgetManuallyRating() throws JSONException {        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http:        config.sdkInternalLimits.setMaxKeyLength(2);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("rating", 10));        final Map<String, Object> segm = TestUtils.map("rating", 10);        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, segm, 0);    }    @Test    public void internalLimit_reportFeedbackWidgetManuallyNPS() throws JSONException {        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http:        config.sdkInternalLimits.setMaxKeyLength(2);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("rating", 10, "comment", "huhu"));        final Map<String, Object> segm = TestUtils.map("rating", 10, "comment", "huhu");        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, segm, 0);    }    @Test    public void internalLimit_reportFeedbackWidgetManually_setMaxValueSize() throws JSONException {        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http:        config.sdkInternalLimits.setMaxValueSize(2);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("rating", 10, "comment", "huhu", "extras", "sure_go_on", "map", TestUtils.map("key1", "value1", "key2", "value2"), "omg", Double.MAX_VALUE));        Map<String, Object> segm = TestUtils.map("rating", 10, "comment", "hu", "extras", "su", "omg", Double.MAX_VALUE);        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, segm, 0);        widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("rating", 10, "comment", "zoomzoom", "map", TestUtils.map("key1", "value1", "key2", "value2"), "omg", Double.MIN_VALUE));        segm = TestUtils.map("rating", 10, "comment", "zo", "omg", Double.MIN_VALUE);        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, segm, 1);        widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("key1", "value1", "key2", "value2", "key3", "value3", "map", TestUtils.map("key1", "value1", "key2", "value2"), "int", Integer.MAX_VALUE));        segm = TestUtils.map("key1", "va", "key2", "va", "key3", "va", "int", Integer.MAX_VALUE);        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, segm, 2);    }    @Test    public void reportFeedbackWidgetManually_validateSupportedArrays() throws JSONException {        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };        boolean[] arrB = { true, false, true, false, true, false, true, false, true, false };        String[] arrS = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };        long[] arrL = { Long.MAX_VALUE, Long.MIN_VALUE };        double[] arrD = { Double.MAX_VALUE, Double.MIN_VALUE };        Long[] arrLO = { Long.MAX_VALUE, Long.MIN_VALUE };        Double[] arrDO = { Double.MAX_VALUE, Double.MIN_VALUE };        Boolean[] arrBO = { Boolean.TRUE, Boolean.FALSE };        Integer[] arrIO = { Integer.MAX_VALUE, Integer.MIN_VALUE };        Object[] arrObj = { "1", 1, 1.1d, true, 1.1f, Long.MAX_VALUE };        Object[] arrObjStr = { "1", "1", "1.1d", "true", "1.1f", "Long.MAX_VALUE" };        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "arr", arr,            "arrB", arrB,            "arrS", arrS,            "arrL", arrL,            "arrD", arrD,            "arrLO", arrLO,            "arrDO", arrDO,            "arrBO", arrBO,            "arrIO", arrIO,            "arrObj", arrObj,            "arrObjStr", arrObjStr, "rating", 10, "comment", "huhu"        );        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmentation);        Map<String, Object> expectedSegmentation = TestUtils.map(            "arr", new JSONArray(arr),            "arrB", new JSONArray(arrB),            "arrS", new JSONArray(arrS),            "arrL", new JSONArray(arrL),            "arrD", new JSONArray(arrD),            "arrLO", new JSONArray(arrLO),            "arrDO", new JSONArray(arrDO),            "arrBO", new JSONArray(arrBO),            "arrIO", new JSONArray(arrIO), "rating", 10, "comment", "huhu"        );        fillFeedbackWidgetSegmentationParams(expectedSegmentation, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, expectedSegmentation, 0);    }    @Test    public void reportFeedbackWidgetManually_validateSupportedLists() throws JSONException {        List<Integer> arr = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);        List<Boolean> arrB = Arrays.asList(true, false, true, false, true, false, true, false, true, false);        List<String> arrS = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10");        List<Long> arrLO = Arrays.asList(Long.MAX_VALUE, Long.MIN_VALUE);        List<Double> arrDO = Arrays.asList(Double.MAX_VALUE, Double.MIN_VALUE);        List<Boolean> arrBO = Arrays.asList(Boolean.TRUE, Boolean.FALSE);        List<Integer> arrIO = Arrays.asList(Integer.MAX_VALUE, Integer.MIN_VALUE);        List<Object> arrObj = Arrays.asList("1", 1, 1.1d, true, Long.MAX_VALUE);        List<Object> arrObjStr = Arrays.asList("1", "1", "1.1d", "true", "Long.MAX_VALUE");        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "arr", arr,            "arrB", arrB,            "arrS", arrS,            "arrLO", arrLO,            "arrDO", arrDO,            "arrBO", arrBO,            "arrIO", arrIO,            "arrObj", arrObj,            "arrObjStr", arrObjStr, "rating", 10, "comment", "huhu"        );        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmentation);        Map<String, Object> expectedSegmentation = TestUtils.map(            "arr", new JSONArray(arr),            "arrB", new JSONArray(arrB),            "arrS", new JSONArray(arrS),            "arrLO", new JSONArray(arrLO),            "arrDO", new JSONArray(arrDO),            "arrBO", new JSONArray(arrBO),            "arrIO", new JSONArray(arrIO),            "arrObj", new JSONArray(arrObj),            "arrObjStr", new JSONArray(arrObjStr), "rating", 10, "comment", "huhu"        );        fillFeedbackWidgetSegmentationParams(expectedSegmentation, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, expectedSegmentation, 0);    }    @Test    public void reportFeedbackWidgetManually_validateSupportedJSONArrays() throws JSONException {        JSONArray arr = new JSONArray(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));        JSONArray arrB = new JSONArray(Arrays.asList(true, false, true, false, true, false, true, false, true, false));        JSONArray arrS = new JSONArray(Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10"));        JSONArray arrL = new JSONArray(Arrays.asList(Long.MAX_VALUE, Long.MIN_VALUE));        JSONArray arrD = new JSONArray(Arrays.asList(Double.MAX_VALUE, Double.MIN_VALUE));        JSONArray arrBO = new JSONArray(Arrays.asList(Boolean.TRUE, Boolean.FALSE));        JSONArray arrIO = new JSONArray(Arrays.asList(Integer.MAX_VALUE, Integer.MIN_VALUE));        JSONArray arrObj = new JSONArray(Arrays.asList("1", 1, 1.1d, true, Long.MAX_VALUE));        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "arr", arr,            "arrB", arrB,            "arrS", arrS,            "arrL", arrL,            "arrD", arrD,            "arrBO", arrBO,            "arrIO", arrIO,            "arrObj", arrObj, "rating", 10, "comment", "huhu"        );        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmentation);        Map<String, Object> expectedSegmentation = TestUtils.map(            "arr", arr,            "arrB", arrB,            "arrS", arrS,            "arrL", arrL,            "arrD", arrD,            "arrBO", arrBO,            "arrIO", arrIO, "rating", 10, "comment", "huhu",            "arrObj", arrObj        );        fillFeedbackWidgetSegmentationParams(expectedSegmentation, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, expectedSegmentation, 0);    }    @Test    public void reportFeedbackWidgetManually_unsupportedDataTypesSegmentation() throws JSONException {        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "a", TestUtils.map(),            "b", TestUtils.json(),            "c", new Object(),            "d", Sets.newSet(),            "e", Mockito.mock(ModuleLog.class), "rating", 10, "comment", "huhu"        );        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmentation);        Map<String, Object> expectedSegmentation = TestUtils.map("rating", 10, "comment", "huhu");        fillFeedbackWidgetSegmentationParams(expectedSegmentation, widgetInfo.widgetId);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, expectedSegmentation, 0);    }    private ModuleFeedback.CountlyFeedbackWidget createFeedbackWidget(ModuleFeedback.FeedbackWidgetType type) {        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();        widgetInfo.type = type;        widgetInfo.widgetId = "1234";        widgetInfo.name = "someName";        return widgetInfo;    }    private void fillFeedbackWidgetSegmentationParams(Map<String, Object> segmentation, String widgetId) {        segmentation.put("platform", "android");        segmentation.put("app_version", "1.0");        segmentation.put("widget_id", widgetId);    }}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.util.HashMap;import java.util.Map;import ly.count.android.sdk.messaging.ModulePush;public class ModuleEvents extends ModuleBase implements EventProvider {    static final Map<String, Event> timedEvents = new HashMap<>();    final static String ACTION_EVENT_KEY = "[CLY]_action";    final static String VISIBILITY_KEY = "cly_v";    final static String PREVIOUS_EVENT_NAME_KEY = "cly_pen";    final static String PREVIOUS_VIEW_NAME_KEY = "cly_pvn";    final static String CURRENT_VIEW_NAME_KEY = "cly_cvn";    final Events eventsInterface;    String previousEventId = "";    String previousEventName = "";    EventQueueProvider eventQueueProvider;    ViewIdProvider viewIdProvider;    SafeIDGenerator safeEventIDGenerator;    private final boolean viewNameRecordingEnabled;    private final boolean visibilityTracking;    ModuleEvents(Countly cly, CountlyConfig config) {        super(cly, config);        L.v("[ModuleEvents] Initialising");        eventProvider = this;        config.eventProvider = this;        eventQueueProvider = config.eventQueueProvider;        safeEventIDGenerator = config.safeEventIDGenerator;        viewNameRecordingEnabled = config.experimental.viewNameRecordingEnabled;        visibilityTracking = config.experimental.visibilityTrackingEnabled;        eventsInterface = new Events();    }    void checkCachedPushData(CountlyStore cs) {        L.d("[ModuleEvents] Starting cache call");        String[] cachedData = cs.getCachedPushData();        if (cachedData != null && cachedData[0] != null && cachedData[1] != null) {            L.d("[ModuleEvents] Found cached push event, recording it");            Map<String, Object> map = new HashMap<>();            map.put(ModulePush.PUSH_EVENT_ACTION_PLATFORM_KEY, ModulePush.PUSH_EVENT_ACTION_PLATFORM_VALUE);            map.put(ModulePush.PUSH_EVENT_ACTION_ID_KEY, cachedData[0]);            map.put(ModulePush.PUSH_EVENT_ACTION_INDEX_KEY, cachedData[1]);            recordEventInternal(ModulePush.PUSH_EVENT_ACTION, map, 1, 0, 0, null, null);        }        if (cachedData != null && (cachedData[0] != null || cachedData[1] != null)) {            cs.clearCachedPushData();        }    }    public void recordEventInternal(@Nullable final String key, @Nullable Map<String, Object> segmentation, int count, final double sum, final double dur, UtilsTime.Instant instant, final String eventIdOverride) {        assert count >= 1;        assert _cly.isInitialized();        long pccTsStartRecordEventInternal = 0L;        if (pcc != null) {            pccTsStartRecordEventInternal = UtilsTime.getNanoTime();        }        L.v("[ModuleEvents] calling 'recordEventInternal'");        if (key == null || key.length() == 0) {            L.e("[ModuleEvents] recordEventInternal, Valid Countly event key is required. Event will be ignored.");            return;        }        if (count < 1) {            L.e("[ModuleEvents] recordEventInternal, event count should be greater than zero. Key:[" + key + "] count:[" + count + "]");            count = 1;        }        L.d("[ModuleEvents] recordEventInternal, key:[" + key + "] eventIdOverride:[" + eventIdOverride + "] segmentation:[" + segmentation + "] count:[" + count + "] sum:[" + sum + "] dur:[" + dur + "] instant:[" + instant + "]");        if (segmentation != null) {            UtilsInternalLimits.removeUnsupportedDataTypes(segmentation, L);        }        if (instant == null) {            instant = UtilsTime.getCurrentInstant();        }        String eventId;        if (eventIdOverride == null) {             eventId = safeEventIDGenerator.GenerateValue();        } else if (eventIdOverride.length() == 0) {            L.w("[ModuleEvents] provided event ID override value is empty. Will generate a new one.");            eventId = safeEventIDGenerator.GenerateValue();        } else {             eventId = eventIdOverride;        }        final long timestamp = instant.timestampMs;        final int hour = instant.hour;        final int dow = instant.dow;        String pvid = null;         String cvid = null;         String pvn = null;        String pen = null;        String cvn = null;        if (key.equals(ModuleViews.VIEW_EVENT_KEY)) {            pvid = viewIdProvider.getPreviousViewId();            if (viewNameRecordingEnabled) {                pvn = _cly.moduleViews.previousViewName;                if (pvn == null) {                    pvn = "";                }            }        } else {            cvid = viewIdProvider.getCurrentViewId();            if (viewNameRecordingEnabled) {                pen = previousEventName;                cvn = _cly.moduleViews.currentViewName;                if (pen == null) {                    pen = "";                }                if (cvn == null) {                    cvn = "";                }            }        }        if (pcc != null) {            pcc.TrackCounterTimeNs("ModuleEvents_recordEventInternalGenID", UtilsTime.getNanoTime() - pccTsStartRecordEventInternal);        }        _cly.moduleUserProfile.saveInternal();        if (visibilityTracking) {            if (segmentation == null) {                segmentation = new HashMap<>();            }            if (ModuleViews.VIEW_EVENT_KEY.equals(key) && !segmentation.containsKey("visit")) {                L.d("[ModuleEvents] recordEventInternal, visibility key will not be added to the end view event");            } else {                String appInBackground = deviceInfo.isInBackground();                int state = 1;                 if ("true".equals(appInBackground)) {                    state = 0;                 }                L.d("[ModuleEvents] recordEventInternal, Adding visibility tracking to segmentation app in background:[" + appInBackground + "] cly_v:[" + state + "]");                segmentation.put(VISIBILITY_KEY, state);            }        }        switch (key) {            case ModuleFeedback.NPS_EVENT_KEY:            case ModuleFeedback.SURVEY_EVENT_KEY:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(true);                }                break;            case ModuleFeedback.RATING_EVENT_KEY:                 if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating) || consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;            case ModuleViews.VIEW_EVENT_KEY:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {                    if (segmentation == null) {                        segmentation = new HashMap<>();                    }                    if (viewNameRecordingEnabled) {                        segmentation.put(PREVIOUS_VIEW_NAME_KEY, pvn);                    }                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;            case ModuleViews.ORIENTATION_EVENT_KEY:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.users)) {                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;            case ModulePush.PUSH_EVENT_ACTION:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.push)) {                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(true);                }                break;            case ACTION_EVENT_KEY:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.clicks) || consentProvider.getConsent(Countly.CountlyFeatureNames.scrolls)) {                    if (segmentation != null) {                        UtilsInternalLimits.removeUnsupportedDataTypes(segmentation, L);                    }                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;            default:                if (consentProvider.getConsent(Countly.CountlyFeatureNames.events)) {                    String keyTruncated = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleEvents] recordEventInternal");                    if (segmentation == null) {                        segmentation = new HashMap<>();                    }                    UtilsInternalLimits.applySdkInternalLimitsToSegmentation(segmentation, _cly.config_.sdkInternalLimits, L, "[ModuleEvents] recordEventInternal");                    if (viewNameRecordingEnabled) {                        segmentation.put(CURRENT_VIEW_NAME_KEY, cvn);                        segmentation.put(PREVIOUS_EVENT_NAME_KEY, pen);                    }                    eventQueueProvider.recordEventToEventQueue(keyTruncated, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, previousEventId);                    previousEventId = eventId;                    previousEventName = keyTruncated;                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);                }                break;        }        if (pcc != null) {            pcc.TrackCounterTimeNs("ModuleEvents_recordEventInternal", UtilsTime.getNanoTime() - pccTsStartRecordEventInternal);        }    }    boolean startEventInternal(final String key) {        if (key == null || key.length() == 0) {            L.e("[ModuleEvents] Can't start event with a null or empty key");            return false;        }        if (timedEvents.containsKey(key)) {            return false;        }        L.d("[ModuleEvents] Starting event: [" + key + "]");        UtilsTime.Instant instant = UtilsTime.getCurrentInstant();        timedEvents.put(key, new Event(key, instant.timestampMs, instant.hour, instant.dow));        return true;    }    boolean endEventInternal(@Nullable final String key, @Nullable final Map<String, Object> segmentation, int count, final double sum) {        L.d("[ModuleEvents] Ending event: [" + key + "]");        if (key == null || key.length() == 0) {            L.e("[ModuleEvents] Can't end event with a null or empty key");            return false;        }        Event event = timedEvents.remove(key);        if (event != null) {            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.events)) {                return true;            }            if (count < 1) {                L.e("[ModuleEvents] endEventInternal, event count should be greater than zero, key [" + key + "], dur:[" + count + "]. Count will be reset to '1'.");                count = 1;            }            L.d("[ModuleEvents] Ending event: [" + key + "]");            long currentTimestamp = UtilsTime.currentTimestampMs();            double duration = (currentTimestamp - event.timestamp) / 1000.0;            UtilsTime.Instant instant = new UtilsTime.Instant(event.timestamp, event.hour, event.dow);            eventProvider.recordEventInternal(key, segmentation, count, sum, duration, instant, null);            return true;        } else {            return false;        }    }    boolean cancelEventInternal(final String key) {        if (key == null || key.length() == 0) {            L.e("[ModuleEvents] Can't cancel event with a null or empty key");            return false;        }        Event event = timedEvents.remove(key);        return event != null;    }    @Override    void initFinished(@NonNull CountlyConfig config) {        checkCachedPushData(_cly.countlyStore);    }    @Override    void halt() {        timedEvents.clear();    }    public class Events {        public void recordPastEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, long timestamp) {            synchronized (_cly) {                recordPastEvent(key, segmentation, 1, 0, 0, timestamp);            }        }        public void recordPastEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum, final double dur, long timestamp) {            synchronized (_cly) {                L.i("[Events] Calling recordPastEvent: [" + key + "]");                if (timestamp <= 0) {                    L.e("Provided timestamp has to be greater that zero. Replacing that timestamp with the current time");                    timestamp = UtilsTime.currentTimestampMs();                }                UtilsTime.Instant instant = UtilsTime.Instant.get(timestamp);                recordEventInternal(key, segmentation, count, sum, dur, instant, null);            }        }        public boolean startEvent(@NonNull final String key) {            synchronized (_cly) {                L.i("[Events] Calling startEvent: [" + key + "]");                return startEventInternal(key);            }        }        public boolean endEvent(@NonNull final String key) {            synchronized (_cly) {                return endEvent(key, null, 1, 0);            }        }        public boolean endEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum) {            synchronized (_cly) {                L.i("[Events] Calling endEvent: [" + key + "]");                return endEventInternal(key, segmentation, count, sum);            }        }        public boolean cancelEvent(@NonNull final String key) {            synchronized (_cly) {                L.i("[Events] Calling cancelEvent: [" + key + "]");                return cancelEventInternal(key);            }        }        public void recordEvent(@NonNull final String key) {            synchronized (_cly) {                recordEvent(key, null, 1, 0);            }        }        public void recordEvent(@NonNull final String key, final int count) {            synchronized (_cly) {                recordEvent(key, null, count, 0);            }        }        public void recordEvent(@NonNull final String key, final int count, final double sum) {            synchronized (_cly) {                recordEvent(key, null, count, sum);            }        }        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation) {            synchronized (_cly) {                recordEvent(key, segmentation, 1, 0);            }        }        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count) {            synchronized (_cly) {                recordEvent(key, segmentation, count, 0);            }        }        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum) {            synchronized (_cly) {                recordEvent(key, segmentation, count, sum, 0);            }        }        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum, final double dur) {            synchronized (_cly) {                L.i("[Events] Calling recordEvent: [" + key + "]");                if (segmentation != null) {                    UtilsInternalLimits.truncateSegmentationValues(segmentation, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[Events] recordEvent,", L);                }                eventProvider.recordEventInternal(key, segmentation, count, sum, dur, null, null);            }        }    }}package ly.count.android.sdk;import android.app.Activity;import androidx.test.ext.junit.runners.AndroidJUnit4;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import java.util.regex.Matcher;import java.util.regex.Pattern;import ly.count.android.sdk.messaging.ModulePush;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.ArgumentCaptor;import org.mockito.Mockito;import org.mockito.internal.util.collections.Sets;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.eq;import static org.mockito.ArgumentMatchers.isNull;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;@RunWith(AndroidJUnit4.class)public class ModuleEventsTests {    Countly mCountly;    CountlyConfig config;    String eventKey = "asdf";    EventQueueProvider eventQueueProvider;    @Before    public void setUp() {        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));        countlyStore.clear();        eventQueueProvider = mock(EventQueueProvider.class);        mCountly = new Countly();        config = new CountlyConfig(TestUtils.getContext(), "appkey", "http:        config.eventQueueProvider = eventQueueProvider;        mCountly.init(config);    }    @After    public void tearDown() {    }    @Test    public void recordEvent_1() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        mCountly.events().recordEvent(eventKey);        verify(ep).recordEventInternal(eventKey, null, 1, 0.0, 0.0, null, null);    }    @Test    public void recordEvent_2() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        mCountly.events().recordEvent(eventKey, 657);        verify(ep).recordEventInternal(eventKey, null, 657, 0.0, 0.0, null, null);    }    @Test    public void recordEvent_3() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        mCountly.events().recordEvent(eventKey, 657, 884.213d);        verify(ep).recordEventInternal(eventKey, null, 657, 884.213d, 0.0, null, null);    }    @Test    public void recordEvent_4() {        eventWithSegmentation(null, null, null, null);    }    @Test    public void recordEvent_5() {        eventWithSegmentation(3456, null, null, null);    }    @Test    public void recordEvent_6() {        eventWithSegmentation(7583, 39457.123d, null, null);    }    @Test    public void recordEvent_7() {        eventWithSegmentation(1245, 443.76d, 985.33d, null);    }    void eventWithSegmentation(Integer count, Double sum, Double dur, Long timestamp) {        EventQueueProvider eqp = TestUtils.setEventQueueProviderToMock(mCountly, mock(EventQueueProvider.class));        Map<String, Object> segmUsed = new HashMap<>();        segmUsed.put("aa", "dd");        segmUsed.put("aa1", "dda");        segmUsed.put("1", 1234);        segmUsed.put("2", 1234.55d);        segmUsed.put("3", true);        segmUsed.put("4", 45.4f);        segmUsed.put("41", new Object());        if (timestamp == null) {            if (count == null && sum == null && dur == null) {                 mCountly.events().recordEvent(eventKey, segmUsed);            } else if (count != null && sum == null && dur == null) {                 mCountly.events().recordEvent(eventKey, segmUsed, count);            } else if (count != null && sum != null && dur == null) {                 mCountly.events().recordEvent(eventKey, segmUsed, count, sum);            } else if (count != null && sum != null && dur != null) {                 mCountly.events().recordEvent(eventKey, segmUsed, count, sum, dur);            } else {                Assert.fail("You should not get here");             }        } else {            if (count == null && sum == null && dur == null) {                 mCountly.events().recordPastEvent(eventKey, segmUsed, timestamp);            } else if (count != null && sum != null && dur != null) {                 mCountly.events().recordPastEvent(eventKey, segmUsed, count, sum, dur, timestamp);            } else {                Assert.fail("You should not get here");             }        }        final Map<String, Object> segm = new HashMap<>();        segm.put("aa", "dd");        segm.put("aa1", "dda");        segm.put("1", 1234);        segm.put("2", 1234.55d);        segm.put("3", true);        segm.put("4", 45.4f);        UtilsTime.Instant instant = UtilsTime.getCurrentInstant();        ArgumentCaptor<Integer> arg1 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Double> arg2 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Double> arg3 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Long> arg4 = ArgumentCaptor.forClass(Long.class);        ArgumentCaptor<Integer> arg5 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Integer> arg6 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<String> arg7 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg8 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg9 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg10 = ArgumentCaptor.forClass(String.class);        verify(eqp).recordEventToEventQueue(eq(eventKey), eq(segm), arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture(), arg8.capture(), arg9.capture(), arg10.capture());        if (count != null) {            Assert.assertEquals(count, arg1.getValue());        }        if (sum != null) {            Assert.assertEquals(sum, arg2.getValue());        }        if (dur != null) {            Assert.assertEquals(dur, arg3.getValue());        }        if (timestamp == null) {            Assert.assertNotNull(arg4.getValue());            Assert.assertNotNull(arg5.getValue());            Assert.assertNotNull(arg6.getValue());        } else {            UtilsTime.Instant instantTimestamp = UtilsTime.Instant.get(timestamp);            Assert.assertEquals(instantTimestamp.timestampMs, (long) arg4.getValue());            Assert.assertEquals(instantTimestamp.hour, (int) arg5.getValue());            Assert.assertEquals(instantTimestamp.dow, (int) arg6.getValue());            Assert.assertEquals(timestamp.longValue(), (long) arg4.getValue());        }    }    @Test    public void recordPastEvent_1() {        eventWithSegmentation(null, null, null, 1579463653876L);    }    @Test    public void recordPastEvent_2() {        eventWithSegmentation(76355, 576334.33d, 85664.64d, 1579463653876L);    }    @Test    public void startEndEvent_noSegments() throws InterruptedException {        boolean res = mCountly.events().startEvent(eventKey);        Assert.assertTrue(res);        verify(eventQueueProvider, times(0)).recordEventToEventQueue(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), any(Long.class), any(Integer.class), any(Integer.class), any(String.class), any(String.class), any(String.class), any(String.class));        Assert.assertEquals(1, ModuleEvents.timedEvents.size());        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));        Event startEvent = ModuleEvents.timedEvents.get(eventKey);        Thread.sleep(1000);        res = mCountly.events().endEvent(eventKey);        Assert.assertTrue(res);        Assert.assertEquals(0, ModuleEvents.timedEvents.size());        ArgumentCaptor<Long> arg1 = ArgumentCaptor.forClass(Long.class);        ArgumentCaptor<Integer> arg2 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Integer> arg3 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Double> argD = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Map> argS = ArgumentCaptor.forClass(Map.class);        verify(eventQueueProvider).recordEventToEventQueue(eq(eventKey), argS.capture(), eq(1), eq(0.0d), argD.capture(), arg1.capture(), arg2.capture(), arg3.capture(), any(String.class), isNull(String.class), eq(""), eq(""));        Assert.assertEquals(startEvent.timestamp, (long) arg1.getValue());        Assert.assertEquals(startEvent.hour, (int) arg2.getValue());        Assert.assertEquals(startEvent.dow, (int) arg3.getValue());        Assert.assertTrue(argS.getValue().isEmpty());        Double captD = argD.getValue();        Assert.assertEquals(1, captD, 0.1d);    }    @Test    public void startEndEvent_withSegments() throws InterruptedException {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        boolean res = mCountly.events().startEvent(eventKey);        Assert.assertTrue(res);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        Assert.assertEquals(1, ModuleEvents.timedEvents.size());        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));        Event startEvent = ModuleEvents.timedEvents.get(eventKey);        Thread.sleep(2000);        Map<String, Object> segm = new HashMap<>();        segm.put("aa", "dd");        segm.put("aa1", "dda");        segm.put("1", 1234);        segm.put("2", 1234.55d);        segm.put("3", true);        res = mCountly.events().endEvent(eventKey, segm, 6372, 5856.34d);        Assert.assertTrue(res);        Assert.assertEquals(0, ModuleEvents.timedEvents.size());        final Map<String, Object> segmVals = new HashMap<>();        segmVals.put("aa", "dd");        segmVals.put("aa1", "dda");        segmVals.put("1", 1234);        segmVals.put("2", 1234.55d);        segmVals.put("3", true);        ArgumentCaptor<UtilsTime.Instant> arg = ArgumentCaptor.forClass(UtilsTime.Instant.class);        ArgumentCaptor<Double> argD = ArgumentCaptor.forClass(Double.class);        verify(ep).recordEventInternal(eq(eventKey), eq(segmVals), eq(6372), eq(5856.34d), argD.capture(), arg.capture(), isNull(String.class));        UtilsTime.Instant captV = arg.getValue();        Assert.assertEquals(startEvent.hour, captV.hour);        Assert.assertEquals(startEvent.dow, captV.dow);        Assert.assertEquals(startEvent.timestamp, captV.timestampMs);        Double captD = argD.getValue();        Assert.assertEquals(2, captD, 0.1d);    }    @Test    public void startCancelEndEvent() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        boolean res = mCountly.events().startEvent(eventKey);        Assert.assertTrue(res);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        Assert.assertEquals(1, ModuleEvents.timedEvents.size());        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));        res = mCountly.events().cancelEvent(eventKey);        Assert.assertTrue(res);        Assert.assertEquals(0, ModuleEvents.timedEvents.size());        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), isNull(String.class));        res = mCountly.events().endEvent(eventKey);        Assert.assertFalse(res);        Assert.assertEquals(0, ModuleEvents.timedEvents.size());        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), isNull(String.class));    }    @Test    public void startCancelStartEndEvent() throws InterruptedException {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        boolean res = mCountly.events().startEvent(eventKey);        Assert.assertTrue(res);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        Assert.assertEquals(1, ModuleEvents.timedEvents.size());        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));        res = mCountly.events().cancelEvent(eventKey);        Assert.assertTrue(res);        Assert.assertEquals(0, ModuleEvents.timedEvents.size());        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), isNull(String.class));        res = mCountly.events().startEvent(eventKey);        Assert.assertTrue(res);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), isNull(String.class));        Assert.assertEquals(1, ModuleEvents.timedEvents.size());        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));        Event startEvent = ModuleEvents.timedEvents.get(eventKey);        Thread.sleep(1000);        res = mCountly.events().endEvent(eventKey);        Assert.assertTrue(res);        Assert.assertEquals(0, ModuleEvents.timedEvents.size());        ArgumentCaptor<UtilsTime.Instant> arg = ArgumentCaptor.forClass(UtilsTime.Instant.class);        ArgumentCaptor<Double> argD = ArgumentCaptor.forClass(Double.class);        verify(ep).recordEventInternal(eq(eventKey), isNull(Map.class), eq(1), eq(0.0d), argD.capture(), arg.capture(), isNull(String.class));        UtilsTime.Instant captV = arg.getValue();        Assert.assertEquals(startEvent.hour, captV.hour);        Assert.assertEquals(startEvent.dow, captV.dow);        Assert.assertEquals(startEvent.timestamp, captV.timestampMs);        Double captD = argD.getValue();        Assert.assertEquals(1, captD, 0.1d);    }    @Test    public void recordEventInternalProcessedTest() {        EventQueueProvider eqp = TestUtils.setEventQueueProviderToMock(mCountly, mock(EventQueueProvider.class));        Map<String, Object> segm1 = new HashMap<>();        final Map<String, Object> segm2 = new HashMap<>();        segm1.put("4", 45.4f);        segm1.put("41", new Object());        segm1.put("42", new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });        segm1.put("asd", "123");        segm1.put("1", 1234);        segm1.put("2", 1234.55d);        segm1.put("3", true);        segm2.put("asd", "123");        segm2.put("1", 1234);        segm2.put("2", 1234.55d);        segm2.put("3", true);        segm2.put("4", 45.4f);        Map<String, Object> segm3 = new HashMap<>(segm1);        mCountly.config_.eventProvider.recordEventInternal(eventKey, segm3, 123, 321.22d, 342.32d, null, null);        verify(eqp).recordEventToEventQueue(eq(eventKey), eq(segm2), eq(123), eq(321.22d), eq(342.32d), any(Long.class), any(Integer.class), any(Integer.class), any(String.class), isNull(String.class), eq(""), eq(""));        eqp = TestUtils.setEventQueueProviderToMock(mCountly, mock(EventQueueProvider.class));        segm3.clear();        segm3.putAll(segm1);        mCountly.config_.eventProvider.recordEventInternal(eventKey, segm3, 123, 321.22d, 342.32d, null, null);        verify(eqp).recordEventToEventQueue(eq(eventKey), eq(segm3), eq(123), eq(321.22d), eq(342.32d), any(Long.class), any(Integer.class), any(Integer.class), any(String.class), isNull(String.class), eq(""), any(String.class));    }    @Test    public void eventsForceClearingEQIntoRQ() {        Countly countly = new Countly().init(new CountlyConfig(TestUtils.getContext(), "appkey", "http:        Assert.assertEquals(0, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(0, countly.countlyStore.getRequests().length);        countly.events().recordEvent("rnd_key");        Assert.assertEquals(1, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(0, countly.countlyStore.getRequests().length);        countly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY);        Assert.assertEquals(2, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(0, countly.countlyStore.getRequests().length);        countly.events().recordEvent(ModuleFeedback.NPS_EVENT_KEY);        Assert.assertEquals(0, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(1, countly.countlyStore.getRequests().length);        countly.events().recordEvent(ModuleFeedback.SURVEY_EVENT_KEY);        Assert.assertEquals(0, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(2, countly.countlyStore.getRequests().length);        countly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY);        Assert.assertEquals(1, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(2, countly.countlyStore.getRequests().length);        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY);        Assert.assertEquals(2, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(2, countly.countlyStore.getRequests().length);        countly.events().recordEvent(ModuleViews.ORIENTATION_EVENT_KEY);        Assert.assertEquals(3, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(2, countly.countlyStore.getRequests().length);        countly.events().recordEvent(ModulePush.PUSH_EVENT_ACTION);        Assert.assertEquals(0, countly.countlyStore.getEventQueueSize());        Assert.assertEquals(3, countly.countlyStore.getRequests().length);    }    @Test    public void internalLimits_recordEvent_internalKeys() throws JSONException {        CountlyConfig config = TestUtils.createBaseConfig();        config.sdkInternalLimits.setMaxKeyLength(2);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        countly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY, TestUtils.map("action_event", "ACTION", "no_truncate", 7687));         validateEventInRQ(ModuleEvents.ACTION_EVENT_KEY, TestUtils.map("action_event", "ACTION", "no_truncate", 7687), 0);        countly.events().recordEvent(ModuleFeedback.NPS_EVENT_KEY, TestUtils.map("nps_event", "NPS", "no_truncate", 555));         validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, TestUtils.map("nps_event", "NPS", "no_truncate", 555), 1);        countly.events().recordEvent(ModuleFeedback.SURVEY_EVENT_KEY, TestUtils.map("survey_event", "SURVEY", "no_truncate", 567));         validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, TestUtils.map("survey_event", "SURVEY", "no_truncate", 567), 2);        countly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY, TestUtils.map("rating_event", "RATING", "no_truncate", 7475));        validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, TestUtils.map("rating_event", "RATING", "no_truncate", 7475), 3);        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("view_event", "VIEW", "no_truncate", 124));        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("view_event", "VIEW", "no_truncate", 124), 4);        countly.events().recordEvent(ModuleViews.ORIENTATION_EVENT_KEY, TestUtils.map("orientation_event", "ORIENTATION", "no_truncate", 23_523));        validateEventInRQ(ModuleViews.ORIENTATION_EVENT_KEY, TestUtils.map("orientation_event", "ORIENTATION", "no_truncate", 23_523), 5);        countly.events().recordEvent(ModulePush.PUSH_EVENT_ACTION, TestUtils.map("push_event", "PUSH", "no_truncate", 567));        validateEventInRQ(ModulePush.PUSH_EVENT_ACTION, TestUtils.map("push_event", "PUSH", "no_truncate", 567), 6);        countly.events().recordEvent("ModuleEvents", TestUtils.map("normal_event", "boo", "no_truncate", 567));        validateEventInRQ("Mo", TestUtils.map("no", "boo"), 7);    }    @Test    public void internalLimits_recordEvent_segmentation() throws JSONException {        CountlyConfig config = TestUtils.createBaseConfig();        config.sdkInternalLimits.setMaxKeyLength(2);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        Map<String, Object> segmentation = new ConcurrentHashMap<>();        segmentation.put("ModuleEvents", "ModuleEvents");        segmentation.put("ModuleFeedback", 567);        countly.events().recordEvent("TestMe", segmentation);         segmentation.clear();        segmentation.put("Mo", 567);        validateEventInRQ("Te", segmentation, 0);    }    @Test    public void recordEvent_validateFromRQ() throws JSONException {        int[] arr = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };        List<String> list = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10");        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "int", 1,            "double", 1.2d,            "string", "string",            "boolean", true,            "float", 1.5f,            "long", Long.MAX_VALUE,            "object", new Object(),            "array", arr,            "list", list,            "null", null        );        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);        Map<String, Object> expectedSegmentation = TestUtils.map(            "int", 1,            "double", 1.2,            "string", "string",            "boolean", true,            "float", 1.5,            "long", Long.MAX_VALUE,            "array", new JSONArray(arr),            "list", new JSONArray(list)        );        validateEventInRQ("key", expectedSegmentation, 1, 1.0d, 1.0d, 0);    }    @Test    public void internalLimits_recordEventInternal_maxSegmentationValues() throws JSONException {        CountlyConfig config = TestUtils.createBaseConfig();        config.sdkInternalLimits.setMaxSegmentationValues(2);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        Assert.assertEquals(0, TestUtils.getCurrentRQ().length);        Map<String, Object> threeSegmentation = TestUtils.map("a", 1, "b", 2, "c", 3);        countly.events().recordEvent("rnd_key", TestUtils.map("a", 1, "b", 2, "c", 3, "d", 4, "e", 5, "f", 6, "g", 7), 1, 1.1d, 1.1d);        validateEventInRQ("rnd_key", TestUtils.map("f", 6, "g", 7), 1, 1.1d, 1.1d, 0);        countly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY, threeSegmentation);        validateEventInRQ(ModuleEvents.ACTION_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 1);        countly.events().recordEvent(ModuleFeedback.NPS_EVENT_KEY, threeSegmentation);        validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 2);        countly.events().recordEvent(ModuleFeedback.SURVEY_EVENT_KEY, threeSegmentation);        validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 3);        countly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY, threeSegmentation);        validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 4);        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, threeSegmentation);        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 5);        countly.events().recordEvent(ModuleViews.ORIENTATION_EVENT_KEY, threeSegmentation);        validateEventInRQ(ModuleViews.ORIENTATION_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 6);        countly.events().recordEvent(ModulePush.PUSH_EVENT_ACTION, threeSegmentation);        validateEventInRQ(ModulePush.PUSH_EVENT_ACTION, threeSegmentation, 1, 0.0d, 0.0d, 7);    }    @Test    public void internalLimits_recordEventInternal_maxValueSize() throws JSONException {        CountlyConfig config = TestUtils.createBaseConfig();        config.sdkInternalLimits.setMaxValueSize(2);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        Assert.assertEquals(0, TestUtils.getCurrentRQ().length);        countly.events().recordEvent("rnd_key", TestUtils.map("a", 1, "b", "bbb", "c", "ccc"), 1, 1.1d, 1.1d);        validateEventInRQ("rnd_key", TestUtils.map("a", 1, "b", "bb", "c", "cc"), 1, 1.1d, 1.1d, 0);    }    @Test    public void internalLimits_recordEventInternal_maxValueSizeKeyLength() throws JSONException {        CountlyConfig config = TestUtils.createBaseConfig();        config.sdkInternalLimits.setMaxValueSize(2).setMaxKeyLength(2);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        Assert.assertEquals(0, TestUtils.getCurrentRQ().length);        countly.events().recordEvent("rnd_key", TestUtils.map("a", 1, "bbb", "bbb", "bbc", "ccc", "bbd", "ddd", "bbe", "eee"), 1, 1.1d, 1.1d);        validateEventInRQ("rn", TestUtils.map("a", 1, "bb", "dd"), 1, 1.1d, 1.1d, 0);    }    @Test    public void recordEvent_validateSupportedArrays() throws JSONException {        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };        boolean[] arrB = { true, false, true, false, true, false, true, false, true, false };        String[] arrS = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };        long[] arrL = { Long.MAX_VALUE, Long.MIN_VALUE };        double[] arrD = { Double.MAX_VALUE, Double.MIN_VALUE };        Long[] arrLO = { Long.MAX_VALUE, Long.MIN_VALUE };        Double[] arrDO = { Double.MAX_VALUE, Double.MIN_VALUE };        Boolean[] arrBO = { Boolean.TRUE, Boolean.FALSE };        Integer[] arrIO = { Integer.MAX_VALUE, Integer.MIN_VALUE };        Object[] arrObj = { "1", 1, 1.1d, true, 1.1f, Long.MAX_VALUE };        Object[] arrObjStr = { "1", "1", "1.1d", "true", "1.1f", "Long.MAX_VALUE" };        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "arr", arr,            "arrB", arrB,            "arrS", arrS,            "arrL", arrL,            "arrD", arrD,            "arrLO", arrLO,            "arrDO", arrDO,            "arrBO", arrBO,            "arrIO", arrIO,            "arrObj", arrObj,            "arrObjStr", arrObjStr        );        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);        Map<String, Object> expectedSegmentation = TestUtils.map(            "arr", new JSONArray(arr),            "arrB", new JSONArray(arrB),            "arrS", new JSONArray(arrS),            "arrL", new JSONArray(arrL),            "arrD", new JSONArray(arrD),            "arrLO", new JSONArray(arrLO),            "arrDO", new JSONArray(arrDO),            "arrBO", new JSONArray(arrBO),            "arrIO", new JSONArray(arrIO)        );        validateEventInRQ("key", expectedSegmentation, 1, 1.0d, 1.0d, 0);    }    @Test    public void recordEvent_validateSupportedLists() throws JSONException {        List<Integer> arr = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);        List<Boolean> arrB = Arrays.asList(true, false, true, false, true, false, true, false, true, false);        List<String> arrS = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10");        List<Long> arrLO = Arrays.asList(Long.MAX_VALUE, Long.MIN_VALUE);        List<Double> arrDO = Arrays.asList(Double.MAX_VALUE, Double.MIN_VALUE);        List<Boolean> arrBO = Arrays.asList(Boolean.TRUE, Boolean.FALSE);        List<Integer> arrIO = Arrays.asList(Integer.MAX_VALUE, Integer.MIN_VALUE);        List<Object> arrObj = Arrays.asList("1", 1, 1.1d, true, Long.MAX_VALUE);        List<Object> arrObjStr = Arrays.asList("1", "1", "1.1d", "true", "Long.MAX_VALUE");        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "arr", arr,            "arrB", arrB,            "arrS", arrS,            "arrLO", arrLO,            "arrDO", arrDO,            "arrBO", arrBO,            "arrIO", arrIO,            "arrObj", arrObj,            "arrObjStr", arrObjStr        );        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);        Map<String, Object> expectedSegmentation = TestUtils.map(            "arr", new JSONArray(arr),            "arrB", new JSONArray(arrB),            "arrS", new JSONArray(arrS),            "arrLO", new JSONArray(arrLO),            "arrDO", new JSONArray(arrDO),            "arrBO", new JSONArray(arrBO),            "arrIO", new JSONArray(arrIO),            "arrObjStr", new JSONArray(arrObjStr),            "arrObj", new JSONArray(arrObj)        );        validateEventInRQ("key", expectedSegmentation, 1, 1.0d, 1.0d, 0);    }    @Test    public void recordEvent_validateSupportedJSONArrays() throws JSONException {        JSONArray arr = new JSONArray(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));        JSONArray arrB = new JSONArray(Arrays.asList(true, false, true, false, true, false, true, false, true, false));        JSONArray arrS = new JSONArray(Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10"));        JSONArray arrL = new JSONArray(Arrays.asList(Long.MAX_VALUE, Long.MIN_VALUE));        JSONArray arrD = new JSONArray(Arrays.asList(Double.MAX_VALUE, Double.MIN_VALUE));        JSONArray arrBO = new JSONArray(Arrays.asList(Boolean.TRUE, Boolean.FALSE));        JSONArray arrIO = new JSONArray(Arrays.asList(Integer.MAX_VALUE, Integer.MIN_VALUE));        JSONArray arrObj = new JSONArray(Arrays.asList("1", 1, 1.1d, true, Long.MAX_VALUE));        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "arr", arr,            "arrB", arrB,            "arrS", arrS,            "arrL", arrL,            "arrD", arrD,            "arrBO", arrBO,            "arrIO", arrIO,            "arrObj", arrObj        );        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);        Map<String, Object> expectedSegmentation = TestUtils.map(            "arr", arr,            "arrB", arrB,            "arrS", arrS,            "arrL", arrL,            "arrD", arrD,            "arrBO", arrBO,            "arrIO", arrIO,            "arrObj", arrObj        );        validateEventInRQ("key", expectedSegmentation, 1, 1.0d, 1.0d, 0);    }    @Test    public void recordEvent_unsupportedDataTypesSegmentation() throws JSONException {        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        Map<String, Object> segmentation = TestUtils.map(            "a", TestUtils.map(),            "b", TestUtils.json(),            "c", new Object(),            "d", Sets.newSet(),            "e", Mockito.mock(ModuleLog.class)        );        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);        validateEventInRQ("key", TestUtils.map(), 1, 1.0d, 1.0d, 0);    }    @Test    public void recordEvent_visibilityTracking_onlyAddingItToViewsAndEvents() throws JSONException {        CountlyConfig config = TestUtils.createBaseConfig();        config.experimental.enableVisibilityTracking();        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        Assert.assertEquals(0, TestUtils.getCurrentRQ().length);        countly.events().recordEvent("rnd_key", TestUtils.map());        validateEventInRQ("rnd_key", TestUtils.map("cly_v", 0), 1, 0.0d, 0.0d, 0);        countly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY, TestUtils.map());        validateEventInRQ(ModuleEvents.ACTION_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 1);        countly.events().recordEvent(ModuleFeedback.NPS_EVENT_KEY, TestUtils.map());        validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 2);        countly.events().recordEvent(ModuleFeedback.SURVEY_EVENT_KEY, TestUtils.map());        validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 3);        countly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY, TestUtils.map());        validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 4);        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("cly_v", 0, "visit", 1), 1, 0.0d, 0.0d, 5);        countly.events().recordEvent(ModuleViews.ORIENTATION_EVENT_KEY, TestUtils.map());        validateEventInRQ(ModuleViews.ORIENTATION_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 6);        countly.events().recordEvent(ModulePush.PUSH_EVENT_ACTION, TestUtils.map());        validateEventInRQ(ModulePush.PUSH_EVENT_ACTION, TestUtils.map(), 1, 0.0d, 0.0d, 7);    }    @Test    public void recordEvent_visibilityTracking_bgFgSwitch() throws JSONException {        CountlyConfig config = TestUtils.createBaseConfig(TestUtils.getContext());        config.experimental.enableVisibilityTracking();        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        countly.onStart(Mockito.mock(Activity.class));         countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("cly_v", 1, "visit", 1), 1, 0.0d, 0.0d, 2);        countly.events().recordEvent("fg", TestUtils.map());        validateEventInRQ("fg", TestUtils.map("cly_v", 1), 1, 0.0d, 0.0d, 3);        countly.onStop();         countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("cly_v", 0, "visit", 1), 1, 0.0d, 0.0d, 5);        countly.events().recordEvent("bg", TestUtils.map());        validateEventInRQ("bg", TestUtils.map("cly_v", 0), 1, 0.0d, 0.0d, 6);    }    @Test    public void recordEvent_visibilityTracking_notEnabled() throws JSONException {        CountlyConfig config = TestUtils.createBaseConfig(TestUtils.getContext());        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        countly.onStart(Mockito.mock(Activity.class));         countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1), 1, 0.0d, 0.0d, 2);        countly.events().recordEvent("fg", TestUtils.map());        validateEventInRQ("fg", TestUtils.map(), 1, 0.0d, 0.0d, 3);        countly.onStop();         countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1), 1, 0.0d, 0.0d, 5);        countly.events().recordEvent("bg", TestUtils.map());        validateEventInRQ("bg", TestUtils.map(), 1, 0.0d, 0.0d, 6);    }    @Test    public void recordEventScenario_previous_current_ViewName_disabled() throws JSONException {        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        countly.events().recordEvent("TEST");        validateEventInRQ("TEST", 0, 1, "_CLY_", "_CLY_", null, null);        countly.views().startView("View1");        countly.events().recordEvent("TEST1");        ModuleViewsTests.validateView("View1", 0.0, 1, 3, false, true, TestUtils.map(), "_CLY_", "_CLY_", null);        validateEventInRQ("TEST1", 2, 3, "_CLY_", "_CLY_", null, null);        countly.views().startView("View2");        countly.events().recordEvent("TEST2");        ModuleViewsTests.validateView("View2", 0.0, 3, 5, false, true, TestUtils.map(), "_CLY_", "_CLY_", null);        validateEventInRQ("TEST2", 4, 5, "_CLY_", "_CLY_", null, null);    }    @Test    public void recordEventScenario_previous_current_ViewName() throws JSONException {        CountlyConfig countlyConfig = TestUtils.createBaseConfig();        countlyConfig.experimental.enablePreviousNameRecording();        countlyConfig.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(countlyConfig);        countly.events().recordEvent("TEST");        validateEventInRQ("TEST", 0, 1, "_CLY_", "_CLY_", "", "");        countly.views().startView("View1");        countly.events().recordEvent("TEST1");        ModuleViewsTests.validateView("View1", 0.0, 1, 3, false, true, TestUtils.map(), "_CLY_", "_CLY_", "");        validateEventInRQ("TEST1", 2, 3, "_CLY_", "_CLY_", "TEST", "View1");        countly.views().startView("View2");        countly.events().recordEvent("TEST2");        ModuleViewsTests.validateView("View2", 0.0, 3, 5, false, true, TestUtils.map(), "_CLY_", "_CLY_", "View1");        validateEventInRQ("TEST2", 4, 5, "_CLY_", "_CLY_", "TEST1", "View2");    }    protected static void validateEventInRQ(String eventName, int idx, int rqCount, String previousViewId, String currentViewId, String previousEventName, String currentViewName) throws JSONException {        Map<String, Object> segmentation = TestUtils.map();        if (previousEventName != null) {            segmentation.put("cly_pen", previousEventName);        }        if (currentViewName != null) {            segmentation.put("cly_cvn", currentViewName);        }        validateEventInRQ(TestUtils.commonDeviceId, eventName, segmentation, 1, 0.0, 0.0, "_CLY_", previousViewId, currentViewId, "_CLY_", idx, rqCount, 0, 1);    }    protected static void validateEventInRQ(String eventName, Map<String, Object> expectedSegmentation, int count, double sum, double duration, int idx) throws JSONException {        validateEventInRQ(eventName, expectedSegmentation, count, sum, duration, idx, idx + 1);    }    protected static void validateEventInRQ(String eventName, Map<String, Object> expectedSegmentation, int count, double sum, double duration, int idx, int rqCount) throws JSONException {        validateEventInRQ(TestUtils.commonDeviceId, eventName, expectedSegmentation, count, sum, duration, "_CLY_", "_CLY_", "_CLY_", "_CLY_", idx, rqCount, 0, 1);    }    protected static void validateEventInRQ(String deviceId, String eventName, Map<String, Object> expectedSegmentation, int count, Double sum, Double duration, String id, String pvid, String cvid, String peid, int idx, int rqCount, int eventIdx, int eventCount)        throws JSONException {        Map<String, String>[] RQ = TestUtils.getCurrentRQ();        if (rqCount > -1) {            Assert.assertEquals(rqCount, RQ.length);        }        TestUtils.validateRequiredParams(RQ[idx], deviceId);        if (!RQ[idx].containsKey("events")) {            Assert.fail("Not an event request idx:[" + idx + "], request:[" + RQ[idx] + "]");        }        JSONArray events = new JSONArray(RQ[idx].get("events"));        Assert.assertEquals(eventCount, events.length());        JSONObject event = events.getJSONObject(eventIdx);        Assert.assertEquals(eventName, event.get("key"));        Assert.assertEquals(count, event.getInt("count"));        Assert.assertEquals(sum, event.optDouble("sum", 0.0d), 0.0001);        Assert.assertEquals(duration, event.optDouble("dur", 0.0d), 0.0001);        if (expectedSegmentation != null && !expectedSegmentation.isEmpty()) {            JSONObject segmentation = event.getJSONObject("segmentation");            Assert.assertEquals("Expected segmentation: " + expectedSegmentation + ", got: " + segmentation, expectedSegmentation.size(), segmentation.length());            for (Map.Entry<String, Object> entry : expectedSegmentation.entrySet()) {                Assert.assertEquals(entry.getValue(), segmentation.get(entry.getKey()));            }        }        int dow = event.getInt("dow");        int hour = event.getInt("hour");        long timestamp = event.getLong("timestamp");        Assert.assertTrue(dow >= 0 && dow < 7);        Assert.assertTrue(hour >= 0 && hour < 24);        Assert.assertTrue(timestamp >= 0);        validateId(id, event.optString("id", ""), "Event ID");        validateId(pvid, event.optString("pvid", ""), "Previous View ID");        validateId(cvid, event.optString("cvid", ""), "Current View ID");        validateId(peid, event.optString("peid", ""), "Previous Event ID");    }    private static void validateId(String id, String gonnaValidate, String name) {        if (id != null && id.equals("_CLY_")) {            if (gonnaValidate != null && !gonnaValidate.isEmpty()) {                validateSafeRandomVal(gonnaValidate);            }        } else {            Assert.assertEquals(name + " is not validated", id, gonnaValidate);        }    }    static void validateSafeRandomVal(String val) {        Assert.assertEquals(val, 21, val.length());        Pattern base64Pattern = Pattern.compile("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$");        String timestampStr = val.substring(val.length() - 13);        String base64Str = val.substring(0, val.length() - 13);        Matcher matcher = base64Pattern.matcher(base64Str);        if (matcher.matches()) {            UtilsTime.Instant instant = UtilsTime.Instant.get(Long.parseLong(timestampStr));            Assert.assertTrue(instant.dow >= 0 && instant.dow < 7);            Assert.assertTrue(instant.hour >= 0 && instant.hour < 24);            Assert.assertTrue(instant.timestampMs > 0);        } else {            Assert.fail("No match for " + val);        }    }    protected static void validateEventInRQ(String eventName, Map<String, Object> expectedSegmentation, int idx) throws JSONException {        validateEventInRQ(eventName, expectedSegmentation, 1, 0.0d, 0.0d, idx);    }    protected static void validateEventInRQ(String eventName, int rqIdx, int eventIdx, int eventCount) throws JSONException {        validateEventInRQ(TestUtils.commonDeviceId, eventName, null, 1, 0.0d, 0.0d, "_CLY_", "_CLY_", "_CLY_", "_CLY_", rqIdx, -1, eventIdx, eventCount);    }    protected static void validateEventInRQ(String deviceId, String eventName, int rqIdx, int eventIdx, int eventCount) throws JSONException {        validateEventInRQ(deviceId, eventName, null, 1, 0.0d, 0.0d, "_CLY_", "_CLY_", "_CLY_", "_CLY_", rqIdx, -1, eventIdx, eventCount);    }}package ly.count.android.sdk;import android.os.AsyncTask;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import org.json.JSONObject;class ImmediateRequestMaker extends AsyncTask<Object, Void, JSONObject> implements ImmediateRequestI {    protected interface InternalImmediateRequestCallback {        void callback(JSONObject checkResponse);    }    InternalImmediateRequestCallback callback;    ModuleLog L;    @Override    public void doWork(@NonNull String requestData, @Nullable String customEndpoint, @NonNull ConnectionProcessor cp, boolean requestShouldBeDelayed, boolean networkingIsEnabled, @NonNull InternalImmediateRequestCallback callback, @NonNull ModuleLog log) {        assert Utils.isNotNullOrEmpty(requestData);        assert cp != null;        assert log != null;        assert callback != null;        this.execute(requestData, customEndpoint, cp, requestShouldBeDelayed, networkingIsEnabled, callback, log);    }    protected JSONObject doInBackground(Object... params) {        final String requestData = (String) params[0];        final String customEndpoint = (String) params[1];        final ConnectionProcessor cp = (ConnectionProcessor) params[2];        final boolean requestShouldBeDelayed = (boolean) params[3];        final boolean networkingIsEnabled = (boolean) params[4];        callback = (InternalImmediateRequestCallback) params[5];        L = (ModuleLog) params[6];        if (!networkingIsEnabled) {            L.w("[ImmediateRequestMaker] ImmediateRequestMaker, Networking config is disabled, request cancelled. Endpoint[" + customEndpoint + "] request[" + requestData + "]");            return null;        }        L.v("[ImmediateRequestMaker] Starting request");        HttpURLConnection connection = null;        BufferedReader reader = null;        boolean wasSuccess = true;        try {            L.d("[ImmediateRequestMaker] delayed[" + requestShouldBeDelayed + "] hasCallback[" + (callback != null) + "] endpoint[" + customEndpoint + "] request[" + requestData + "] url[" + cp.getServerURL() + "]");            if (requestShouldBeDelayed) {                L.v("[ImmediateRequestMaker] request should be delayed, waiting for 0.5 seconds");                try {                    Thread.sleep(500);                } catch (InterruptedException e) {                    L.w("[ImmediateRequestMaker] While waiting for 0.5 seconds in ImmediateRequestMaker, sleep was interrupted");                }            }            try {                connection = (HttpURLConnection) cp.urlConnectionForServerRequest(requestData, customEndpoint);            } catch (IOException e) {                L.e("[ImmediateRequestMaker] IOException while preparing remote config update request :[" + e.toString() + "]");                return null;            }            connection.connect();            InputStream stream;            try {                stream = connection.getInputStream();            } catch (Exception ex) {                stream = connection.getErrorStream();                wasSuccess = false;            }            if (stream == null) {                L.e("[ImmediateRequestMaker] Encountered problem while making a immediate server request, received stream was null");                return null;            }            reader = new BufferedReader(new InputStreamReader(stream));            StringBuilder buffer = new StringBuilder();            String line = "";            while ((line = reader.readLine()) != null) {                buffer.append(line).append("\n");            }            final String receivedBuffer = buffer.toString();            if (wasSuccess) {                L.d("[ImmediateRequestMaker] Received the following response, :[" + receivedBuffer + "]");                char firstChar = receivedBuffer.trim().charAt(0);                if (firstChar == '[') {                    return new JSONObject("{\"jsonArray\":" + receivedBuffer + "}");                }                return new JSONObject(receivedBuffer);            } else {                L.e("[ImmediateRequestMaker] Encountered problem while making a immediate server request, :[" + receivedBuffer + "]");                return null;            }        } catch (Exception e) {            L.e("[ImmediateRequestMaker] Received exception while making a immediate server request", e);        } finally {            if (connection != null) {                connection.disconnect();            }            try {                if (reader != null) {                    reader.close();                }            } catch (IOException e) {                L.e("[ImmediateRequestMaker] ", e);            }        }        L.v("[ImmediateRequestMaker] Finished request");        return null;    }    @Override    protected void onPostExecute(JSONObject result) {        super.onPostExecute(result);        L.v("[ImmediateRequestMaker] onPostExecute");        if (callback != null) {            callback.callback(result);        }    }}package ly.count.android.sdk;import android.app.Application;import android.content.Context;import java.util.ArrayList;import java.util.List;import java.util.Map;public class CountlyConfig {    protected CountlyStore countlyStore = null;    protected ConsentProvider consentProvider = null;    protected StorageProvider storageProvider = null;    protected EventProvider eventProvider = null;    protected EventQueueProvider eventQueueProvider = null;    protected RequestQueueProvider requestQueueProvider = null;    protected DeviceIdProvider deviceIdProvider = null;    protected ViewIdProvider viewIdProvider = null;    protected BaseInfoProvider baseInfoProvider = null;    protected ConfigurationProvider configProvider = null;    protected SafeIDGenerator safeViewIDGenerator = null;    protected SafeIDGenerator safeEventIDGenerator = null;    protected ImmediateRequestGenerator immediateRequestGenerator = null;    protected HealthTracker healthTracker;    protected MetricProvider metricProviderOverride = null;    protected DeviceInfo deviceInfo = null;    protected ModuleBase testModuleListener = null;    protected Map<String, Object> providedUserProperties = null;    protected Countly.LifecycleObserver lifecycleObserver = null;    protected Context context = null;    protected String serverURL = null;    protected String appKey = null;    protected String deviceID = null;    protected int starRatingSessionLimit = 5;    protected StarRatingCallback starRatingCallback = null;    protected String starRatingTextTitle = null;    protected String starRatingTextMessage = null;    protected String starRatingTextDismiss = null;    protected boolean loggingEnabled = false;    protected boolean enableAutomaticViewTracking = false;    protected boolean autoTrackingUseShortName = false;    protected Class[] automaticViewTrackingExceptions = null;    protected Map<String, Object> globalViewSegmentation = null;    protected Map<String, String> customNetworkRequestHeaders = null;    protected boolean pushIntentAddMetadata = false;    protected boolean enableRemoteConfigAutomaticDownloadTriggers = false;    protected boolean enableAutoEnrollFlag = false;    boolean enableRemoteConfigValueCaching = false;    protected RemoteConfigCallback remoteConfigCallbackLegacy = null;    protected List<RCDownloadCallback> remoteConfigGlobalCallbackList = new ArrayList<>(2);    protected boolean shouldRequireConsent = false;    protected boolean enableAllConsents = false;    protected String[] enabledFeatureNames = null;    protected boolean httpPostForced = false;    protected boolean temporaryDeviceIdEnabled = false;    protected String tamperingProtectionSalt = null;    protected Integer eventQueueSizeThreshold = null;    protected boolean trackOrientationChange = true;    protected boolean manualSessionControlEnabled = false;    protected boolean manualSessionControlHybridModeEnabled = false;    protected boolean disableUpdateSessionRequests = false;    protected boolean shouldIgnoreAppCrawlers = false;    protected String[] appCrawlerNames = null;    protected String[] publicKeyPinningCertificates = null;    protected String[] certificatePinningCertificates = null;    protected Integer sessionUpdateTimerDelay = null;    protected CrashFilterCallback crashFilterCallback;    protected boolean starRatingDialogIsCancellable = false;    protected boolean starRatingShownAutomatically = false;    protected boolean starRatingDisableAskingForEachAppVersion = false;    protected Application application = null;    boolean disableLocation = false;    String locationCountyCode = null;    String locationCity = null;    String locationLocation = null;    String locationIpAddress = null;    Map<String, String> metricOverride = null;    int maxRequestQueueSize = 1000;    ModuleLog.LogCallback providedLogCallback;    String daCampaignType = null;    String daCampaignData = null;    Map<String, String> iaAttributionValues = null;    boolean explicitStorageModeEnabled = false;    boolean serverConfigurationEnabled = false;    boolean healthCheckEnabled = true;    int dropAgeHours = 0;    public PerformanceCounterCollector pcc;    public synchronized CountlyConfig setMaxSegmentationValues(int maxSegmentationValues) {        sdkInternalLimits.setMaxSegmentationValues(maxSegmentationValues);        return this;    }    public synchronized CountlyConfig setMaxBreadcrumbCount(int maxBreadcrumbCount) {        sdkInternalLimits.setMaxBreadcrumbCount(maxBreadcrumbCount);        return this;    }    public CountlyConfig() {    }    public CountlyConfig(Context context, String appKey, String serverURL) {        setContext(context);        setAppKey(appKey);        setServerURL(serverURL);    }    public CountlyConfig(Application application, String appKey, String serverURL) {        setAppKey(appKey);        setServerURL(serverURL);        setApplication(application);    }    public synchronized CountlyConfig setContext(Context context) {        this.context = context;        return this;    }    public synchronized CountlyConfig setServerURL(String serverURL) {        this.serverURL = serverURL;        return this;    }    public synchronized CountlyConfig setAppKey(String appKey) {        this.appKey = appKey;        return this;    }    public synchronized CountlyConfig setDeviceId(String deviceID) {        this.deviceID = deviceID;        return this;    }    public synchronized CountlyConfig setIdMode(DeviceIdType idMode) {        return this;    }    public synchronized CountlyConfig setStarRatingSessionLimit(int starRatingLimit) {        this.starRatingSessionLimit = starRatingLimit;        return this;    }    public synchronized CountlyConfig setStarRatingCallback(StarRatingCallback starRatingCallback) {        this.starRatingCallback = starRatingCallback;        return this;    }    public synchronized CountlyConfig setStarRatingTextTitle(String starRatingTextTitle) {        this.starRatingTextTitle = starRatingTextTitle;        return this;    }    public synchronized CountlyConfig setStarRatingTextMessage(String starRatingTextMessage) {        this.starRatingTextMessage = starRatingTextMessage;        return this;    }    public synchronized CountlyConfig setStarRatingTextDismiss(String starRatingTextDismiss) {        this.starRatingTextDismiss = starRatingTextDismiss;        return this;    }    public synchronized CountlyConfig setLoggingEnabled(boolean enabled) {        this.loggingEnabled = enabled;        return this;    }    public synchronized CountlyConfig enableCrashReporting() {        crashes.enableCrashReporting();        return this;    }    public synchronized CountlyConfig setViewTracking(boolean enable) {        this.enableAutomaticViewTracking = enable;        return this;    }    public synchronized CountlyConfig enableAutomaticViewTracking() {        this.enableAutomaticViewTracking = true;        return this;    }    public synchronized CountlyConfig enableAutomaticViewShortNames() {        this.autoTrackingUseShortName = true;        return this;    }    public synchronized CountlyConfig setAutoTrackingUseShortName(boolean enable) {        this.autoTrackingUseShortName = enable;        return this;    }    public synchronized CountlyConfig setGlobalViewSegmentation(Map<String, Object> segmentation) {        globalViewSegmentation = segmentation;        return this;    }    public synchronized CountlyConfig setAutomaticViewSegmentation(Map<String, Object> segmentation) {        globalViewSegmentation = segmentation;        return this;    }    public synchronized CountlyConfig setAutomaticViewTrackingExclusions(Class[] exclusions) {        if (exclusions != null) {            for (Class exception : exclusions) {                if (exception == null) {                    throw new IllegalArgumentException("setAutomaticViewTrackingExclusions(...) does not accept 'null' activities");                }            }        }        automaticViewTrackingExceptions = exclusions;        return this;    }    public synchronized CountlyConfig setAutoTrackingExceptions(Class[] exceptions) {        return setAutomaticViewTrackingExclusions(exceptions);    }    public synchronized CountlyConfig addCustomNetworkRequestHeaders(Map<String, String> customHeaderValues) {        this.customNetworkRequestHeaders = customHeaderValues;        return this;    }    public synchronized CountlyConfig setPushIntentAddMetadata(boolean enable) {        pushIntentAddMetadata = enable;        return this;    }    public synchronized CountlyConfig setRemoteConfigAutomaticDownload(boolean enabled, RemoteConfigCallback callback) {        enableRemoteConfigAutomaticDownloadTriggers = enabled;        remoteConfigCallbackLegacy = callback;        return this;    }    public synchronized CountlyConfig enableRemoteConfigAutomaticTriggers() {        enableRemoteConfigAutomaticDownloadTriggers = true;        return this;    }    public synchronized CountlyConfig enrollABOnRCDownload() {        enableAutoEnrollFlag = true;        return this;    }    public synchronized CountlyConfig setRequestDropAgeHours(int dropAgeHours) {        this.dropAgeHours = dropAgeHours;        return this;    }    public synchronized CountlyConfig enableRemoteConfigValueCaching() {        enableRemoteConfigValueCaching = true;        return this;    }    public synchronized CountlyConfig RemoteConfigRegisterGlobalCallback(RCDownloadCallback callback) {        remoteConfigGlobalCallbackList.add(callback);        return this;    }    public synchronized CountlyConfig setRequiresConsent(boolean shouldRequireConsent) {        this.shouldRequireConsent = shouldRequireConsent;        return this;    }    public synchronized CountlyConfig setConsentEnabled(String[] featureNames) {        enabledFeatureNames = featureNames;        return this;    }    public synchronized CountlyConfig giveAllConsents() {        enableAllConsents = true;        return this;    }    public synchronized CountlyConfig setHttpPostForced(boolean isForced) {        httpPostForced = isForced;        return this;    }    public synchronized CountlyConfig enableTemporaryDeviceIdMode() {        temporaryDeviceIdEnabled = true;        return this;    }    public synchronized CountlyConfig setCrashFilterCallback(CrashFilterCallback callback) {        crashFilterCallback = callback;        return this;    }    public synchronized CountlyConfig setParameterTamperingProtectionSalt(String salt) {        tamperingProtectionSalt = salt;        return this;    }    public synchronized CountlyConfig setTrackOrientationChanges(boolean shouldTrackOrientation) {        trackOrientationChange = shouldTrackOrientation;        return this;    }    public synchronized CountlyConfig setRecordAllThreadsWithCrash() {        crashes.enableRecordAllThreadsWithCrash();        return this;    }    public synchronized CountlyConfig setEnableAttribution(boolean enableAttribution) {        return this;    }    public synchronized CountlyConfig enablePublicKeyPinning(String[] certificates) {        publicKeyPinningCertificates = certificates;        return this;    }    public synchronized CountlyConfig enableCertificatePinning(String[] certificates) {        certificatePinningCertificates = certificates;        return this;    }    public synchronized CountlyConfig setShouldIgnoreAppCrawlers(boolean shouldIgnore) {        shouldIgnoreAppCrawlers = shouldIgnore;        return this;    }    public synchronized CountlyConfig setAppCrawlerNames(String[] appCrawlerNames) {        this.appCrawlerNames = appCrawlerNames;        return this;    }    public synchronized CountlyConfig setEventQueueSizeToSend(int threshold) {        eventQueueSizeThreshold = threshold;        return this;    }    public synchronized CountlyConfig enableManualSessionControl() {        manualSessionControlEnabled = true;        return this;    }    public synchronized CountlyConfig enableManualSessionControlHybridMode() {        manualSessionControlHybridModeEnabled = true;        return this;    }    public synchronized CountlyConfig setCustomCrashSegment(Map<String, Object> crashSegment) {        crashes.setCustomCrashSegmentation(crashSegment);        return this;    }    protected synchronized CountlyConfig checkForNativeCrashDumps(boolean checkForDumps) {        return this;    }    public synchronized CountlyConfig setUpdateSessionTimerDelay(int delay) {        sessionUpdateTimerDelay = delay;        return this;    }    protected synchronized CountlyConfig setCountlyStore(CountlyStore store) {        countlyStore = store;        return this;    }    protected synchronized CountlyConfig setDisableUpdateSessionRequests(boolean disable) {        disableUpdateSessionRequests = disable;        return this;    }    public synchronized CountlyConfig setIfStarRatingDialogIsCancellable(boolean isCancellable) {        starRatingDialogIsCancellable = isCancellable;        return this;    }    public synchronized CountlyConfig setIfStarRatingShownAutomatically(boolean isShownAutomatically) {        starRatingShownAutomatically = isShownAutomatically;        return this;    }    public synchronized CountlyConfig setStarRatingDisableAskingForEachAppVersion(boolean disableAsking) {        starRatingDisableAskingForEachAppVersion = disableAsking;        return this;    }    public synchronized CountlyConfig setApplication(Application application) {        this.application = application;        return this;    }    public synchronized CountlyConfig setRecordAppStartTime(boolean recordAppStartTime) {        apm.trackAppStartTime = recordAppStartTime;        return this;    }    public synchronized CountlyConfig setDisableLocation() {        disableLocation = true;        return this;    }    public synchronized CountlyConfig setLocation(String country_code, String city, String gpsCoordinates, String ipAddress) {        locationCountyCode = country_code;        locationCity = city;        locationLocation = gpsCoordinates;        locationIpAddress = ipAddress;        return this;    }    public synchronized CountlyConfig setMetricOverride(Map<String, String> providedMetricOverride) {        metricOverride = providedMetricOverride;        return this;    }    public synchronized CountlyConfig setAppStartTimestampOverride(long appStartTimestampOverride) {        apm.setAppStartTimestampOverride(appStartTimestampOverride);        return this;    }    public synchronized CountlyConfig enableManualAppLoadedTrigger() {        apm.enableManualAppLoadedTrigger();        return this;    }    public synchronized CountlyConfig enableManualForegroundBackgroundTriggerAPM() {        apm.manualForegroundBackgroundTrigger = true;        return this;    }    public synchronized CountlyConfig setLogListener(ModuleLog.LogCallback logCallback) {        providedLogCallback = logCallback;        return this;    }    public synchronized CountlyConfig setMaxRequestQueueSize(int newMaxSize) {        maxRequestQueueSize = newMaxSize;        return this;    }    public synchronized CountlyConfig setDirectAttribution(String campaignType, String campaignData) {        daCampaignType = campaignType;        daCampaignData = campaignData;        return this;    }    public synchronized CountlyConfig setIndirectAttribution(Map<String, String> attributionValues) {        iaAttributionValues = attributionValues;        return this;    }    public synchronized CountlyConfig setUserProperties(Map<String, Object> userProperties) {        providedUserProperties = userProperties;        return this;    }    public synchronized CountlyConfig enableExplicitStorageMode() {        explicitStorageModeEnabled = true;        return this;    }    public synchronized CountlyConfig enableServerConfiguration() {        serverConfigurationEnabled = true;        return this;    }    protected synchronized CountlyConfig disableHealthCheck() {        healthCheckEnabled = false;        return this;    }    public final ConfigApm apm = new ConfigApm();    public final ConfigSdkInternalLimits sdkInternalLimits = new ConfigSdkInternalLimits();    public final ConfigCrashes crashes = new ConfigCrashes();    public final ConfigContent content = new ConfigContent();    public final ConfigExperimental experimental = new ConfigExperimental();}package ly.count.android.sdk;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import java.io.BufferedWriter;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.HttpURLConnection;import java.net.URL;import java.net.URLConnection;import java.util.Map;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.SSLContext;import org.json.JSONException;import org.json.JSONObject;public class ConnectionProcessor implements Runnable {    private static final int CONNECT_TIMEOUT_IN_MILLISECONDS = 30_000;    private static final int READ_TIMEOUT_IN_MILLISECONDS = 30_000;    private static final String CRLF = "\r\n";    private static final String charset = "UTF-8";    private final StorageProvider storageProvider_;    private final DeviceIdProvider deviceIdProvider_;    final ConfigurationProvider configProvider_;    HealthTracker healthTracker;    final RequestInfoProvider requestInfoProvider_;    private final String serverURL_;    private final SSLContext sslContext_;    private final Map<String, String> requestHeaderCustomValues_;    static String endPointOverrideTag = "&new_end_point=";    ModuleLog L;    public PerformanceCounterCollector pcc;    private enum RequestResult {        OK,                 RETRY           }    ConnectionProcessor(final String serverURL, final StorageProvider storageProvider, final DeviceIdProvider deviceIdProvider, final ConfigurationProvider configProvider,        final RequestInfoProvider requestInfoProvider, final SSLContext sslContext, final Map<String, String> requestHeaderCustomValues, ModuleLog logModule,        HealthTracker healthTracker) {        serverURL_ = serverURL;        storageProvider_ = storageProvider;        deviceIdProvider_ = deviceIdProvider;        configProvider_ = configProvider;        sslContext_ = sslContext;        requestHeaderCustomValues_ = requestHeaderCustomValues;        requestInfoProvider_ = requestInfoProvider;        L = logModule;        this.healthTracker = healthTracker;    }    synchronized public @NonNull URLConnection urlConnectionForServerRequest(@NonNull String requestData, @Nullable final String customEndpoint) throws IOException {        String urlEndpoint = "/i";        if (customEndpoint != null) {            urlEndpoint = customEndpoint;        }        boolean hasPicturePath = requestData.contains(ModuleUserProfile.PICTURE_PATH_KEY);        boolean usingHttpPost = requestData.contains("&crash=") || requestData.length() >= 2048 || requestInfoProvider_.isHttpPostForced() || hasPicturePath;        long approximateDateSize = 0L;        String urlStr = serverURL_ + urlEndpoint;        if (usingHttpPost) {            if (!hasPicturePath) {                String checksum = UtilsNetworking.sha256Hash(requestData + requestInfoProvider_.getRequestSalt());                requestData += "&checksum256=" + checksum;                L.v("[ConnectionProcessor] The following checksum was added:[" + checksum + "]");                approximateDateSize += requestData.length();             }        } else {            urlStr += "?" + requestData;            String checksum = UtilsNetworking.sha256Hash(requestData + requestInfoProvider_.getRequestSalt());            urlStr += "&checksum256=" + checksum;            L.v("[ConnectionProcessor] The following checksum was added:[" + checksum + "]");        }        approximateDateSize += urlStr.length();        final URL url = new URL(urlStr);        final HttpURLConnection conn;        long pccTsOpenURLConnection = 0L;        long pccTsConfigureConnection = 0L;        long pccTsStartHeaderFieldSize = 0L;        if (pcc != null) {            pccTsOpenURLConnection = UtilsTime.getNanoTime();        }        if (Countly.publicKeyPinCertificates == null && Countly.certificatePinCertificates == null) {            conn = (HttpURLConnection) url.openConnection();        } else {            HttpsURLConnection c = (HttpsURLConnection) url.openConnection();            c.setSSLSocketFactory(sslContext_.getSocketFactory());            conn = c;        }        if (pcc != null) {            long openUrlConnectionTime = UtilsTime.getNanoTime() - pccTsOpenURLConnection;            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_01_OpenURLConnection", openUrlConnectionTime);            pccTsConfigureConnection = UtilsTime.getNanoTime();        }        conn.setConnectTimeout(CONNECT_TIMEOUT_IN_MILLISECONDS);        conn.setReadTimeout(READ_TIMEOUT_IN_MILLISECONDS);        conn.setUseCaches(false);        conn.setDoInput(true);        conn.setRequestMethod("GET");        if (requestHeaderCustomValues_ != null) {            L.v("[ConnectionProcessor] Adding [" + requestHeaderCustomValues_.size() + "] custom header fields");            for (Map.Entry<String, String> entry : requestHeaderCustomValues_.entrySet()) {                String key = entry.getKey();                String value = entry.getValue();                if (key != null && value != null && !key.isEmpty()) {                    conn.addRequestProperty(key, value);                }            }        }        L.v("[ConnectionProcessor] Has picturePath [" + hasPicturePath + "]");        if (hasPicturePath) {            String boundary = Long.toHexString(System.currentTimeMillis());            conn.setDoOutput(true);            conn.setRequestMethod("POST");            conn.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + boundary);            OutputStream output = conn.getOutputStream();             PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, charset), true);            String[] params = requestData.split("&");             for (String key : params) {                String[] kv = key.split("=");                approximateDateSize += 4 + boundary.length();                 String param = kv[0];                String value = UtilsNetworking.urlDecodeString(kv[1]);                if (param.equals(ModuleUserProfile.PICTURE_PATH_KEY)) {                    approximateDateSize += addFileMultipart(output, writer, value, boundary);                }                approximateDateSize += addTextMultipart(writer, param, value, boundary);            }            approximateDateSize += 4 + boundary.length();             approximateDateSize += addTextMultipart(writer, "checksum256", UtilsNetworking.sha256Hash(UtilsNetworking.urlDecodeString(requestData) + requestInfoProvider_.getRequestSalt()), boundary);            writer.append("--").append(boundary).append("--").append(CRLF).flush();            approximateDateSize += 6 + boundary.length();         } else {            if (usingHttpPost) {                conn.setDoOutput(true);                conn.setRequestMethod("POST");                conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");                OutputStream os = conn.getOutputStream();                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, charset));                writer.write(requestData);                writer.flush();                writer.close();                os.close();            } else {                L.v("[ConnectionProcessor] Using HTTP GET");                conn.setDoOutput(false);            }        }        if (pcc != null) {            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_02_ConfigureConnection", UtilsTime.getNanoTime() - pccTsConfigureConnection);            pccTsStartHeaderFieldSize = UtilsTime.getNanoTime();        }        try {            int headerIndex = 0;            while (true) {                String key = conn.getHeaderFieldKey(headerIndex);                if (key == null) {                    break;                }                String value = conn.getHeaderField(headerIndex++);                approximateDateSize += key.getBytes("US-ASCII").length + value.getBytes("US-ASCII").length + 2L;            }        } catch (Exception e) {            L.e("[Connection Processor] urlConnectionForServerRequest, exception while calculating header field size: " + e);        }        if (pcc != null) {            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_03_HeaderFieldSize", UtilsTime.getNanoTime() - pccTsStartHeaderFieldSize);        }        L.v("[ConnectionProcessor] Using HTTP POST: [" + usingHttpPost + "] forced:[" + requestInfoProvider_.isHttpPostForced()            + "] length:[" + (requestData.length() >= 2048) + "] crash:[" + requestData.contains("&crash=") + "] | Approx data size: [" + approximateDateSize + " B]");        return conn;    }    int addTextMultipart(PrintWriter writer, final String name, final String value, final String boundary) {        writer.append("--").append(boundary).append(CRLF);        writer.append("Content-Disposition: form-data; name=\"").append(name).append("\"").append(CRLF);        writer.append(CRLF).append(value).append(CRLF).flush();        return 49 + boundary.length() + name.length() + value.length();     }    int addFileMultipart(OutputStream output, PrintWriter writer, final String filePath, final String boundary) throws IOException {        if (Utils.isNullOrEmpty(filePath)) {            return 0;        }        writer.append("--").append(boundary).append(CRLF);        File file = new File(filePath);        String contentType = URLConnection.guessContentTypeFromName(file.getName());        int approximateDataSize = 0;        writer.append("Content-Disposition: form-data; name=\"file\"; filename=\"").append(file.getName()).append("\"").append(CRLF);        writer.append("Content-Type: ").append(contentType).append(CRLF);        writer.append(CRLF).flush();        try (FileInputStream fileInputStream = new FileInputStream(file)) {            byte[] buffer = new byte[1024];            int len;            try {                while ((len = fileInputStream.read(buffer)) != -1) {                    output.write(buffer, 0, len);                    approximateDataSize += len;                }            } catch (IOException ex) {                for (StackTraceElement e : ex.getStackTrace()) {                    L.e("[ConnectionProcessor] addMultipart, error: " + e);                }            }        }        output.flush();        writer.append(CRLF).flush();        return 82 + boundary.length() + approximateDataSize + file.getName().length() + contentType.length();     }    @Override    public void run() {        long wholeQueueStart = UtilsTime.getNanoTime();        while (true) {            long pccTsStartWholeQueue = 0L;            long pccTsStartOnlyInternet = 0L;            long pccTsStartTempIdCheck = 0L;            long pccTsStartEndpointCheck = 0L;            long pccTsStartOldRCheck = 0L;            long pccTsStartGetURLConnection;            long pccTsStartRemainingRequests = 0L;            long pccTsReadingStream;            long pccTsStartHandlingResponse;            if (!configProvider_.getNetworkingEnabled()) {                L.w("[ConnectionProcessor] run, Networking config is disabled, request queue skipped");                break;            }            final String[] storedRequests = storageProvider_.getRequests();            int storedRequestCount = storedRequests == null ? 0 : storedRequests.length;            String msg = "[Connection Processor] Starting to run, there are [" + storedRequestCount + "] requests stored";            if (storedRequestCount == 0) {                L.v(msg);            } else {                L.i(msg);            }            if (storedRequests == null || storedRequestCount == 0) {                L.i("[ConnectionProcessor] No requests in the queue, request queue skipped");                break;            }            if (deviceIdProvider_.getDeviceId() == null) {                L.i("[ConnectionProcessor] No Device ID available yet, skipping request " + storedRequests[0]);                break;            }            final String originalRequest = storedRequests[0];            String requestData = originalRequest;            if (pcc != null) {                pcc.TrackCounterTimeNs("ConnectionProcessorRun_01_GetRequest", UtilsTime.getNanoTime() - pccTsStartWholeQueue);            }            if (pcc != null) {                pccTsStartOldRCheck = UtilsTime.getNanoTime();            }            L.i("[ConnectionProcessor] Checking if the request is older than:[" + requestInfoProvider_.getRequestDropAgeHours() + "] hours");            boolean isRequestOld = Utils.isRequestTooOld(requestData, requestInfoProvider_.getRequestDropAgeHours(), "[ConnectionProcessor]", L);            if (pcc != null) {                pcc.TrackCounterTimeNs("ConnectionProcessorRun_02_NetworkOldReq", UtilsTime.getNanoTime() - pccTsStartOldRCheck);            }            if (pcc != null) {                pccTsStartTempIdCheck = UtilsTime.getNanoTime();            }            String temporaryIdTag = "&device_id=" + DeviceId.temporaryCountlyDeviceId;            boolean containsTemporaryId = requestData.contains(temporaryIdTag);            if (containsTemporaryId || deviceIdProvider_.isTemporaryIdEnabled()) {                L.i("[ConnectionProcessor] Temporary ID detected, stalling requests. tmp id tag:[" + containsTemporaryId + "], temp ID set:[" + deviceIdProvider_.isTemporaryIdEnabled() + "]");                break;            }            if (pcc != null) {                pcc.TrackCounterTimeNs("ConnectionProcessorRun_03_NetworkTempID", UtilsTime.getNanoTime() - pccTsStartTempIdCheck);            }            if (pcc != null) {                pccTsStartEndpointCheck = UtilsTime.getNanoTime();            }            String customEndpoint = null;            String[] extractionResult = Utils.extractValueFromString(requestData, endPointOverrideTag, "&");            if (extractionResult[1] != null) {                requestData = extractionResult[0];                if (!extractionResult[1].isEmpty()) {                    customEndpoint = extractionResult[1];                }                L.v("[ConnectionProcessor] Custom end point detected for the request:[" + customEndpoint + "]");            }            if (pcc != null) {                pcc.TrackCounterTimeNs("ConnectionProcessorRun_04_NetworkCustomEndpoint", UtilsTime.getNanoTime() - pccTsStartEndpointCheck);            }            if (pcc != null) {                pccTsStartRemainingRequests = UtilsTime.getNanoTime();            }            requestData = requestData + "&rr=" + (storedRequestCount - 1);            if (pcc != null) {                pcc.TrackCounterTimeNs("ConnectionProcessorRun_06_remainingRequests", UtilsTime.getNanoTime() - pccTsStartRemainingRequests);            }            if (!(requestInfoProvider_.isDeviceAppCrawler() && requestInfoProvider_.ifShouldIgnoreCrawlers()) && !isRequestOld) {                URLConnection conn = null;                InputStream connInputStream = null;                try {                    pccTsStartGetURLConnection = UtilsTime.getNanoTime();                    conn = urlConnectionForServerRequest(requestData, customEndpoint);                    long setupServerRequestTime = UtilsTime.getNanoTime() - pccTsStartGetURLConnection;                    L.d("[ConnectionProcessor] run, TIMING Setup server request took:[" + setupServerRequestTime / 1000000.0d + "] ms");                    if (pcc != null) {                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_07_SetupServerRequest", setupServerRequestTime);                        pccTsStartOnlyInternet = UtilsTime.getNanoTime();                    }                    conn.connect();                    if (pcc != null) {                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_08_NetworkOnlyInternet", UtilsTime.getNanoTime() - pccTsStartOnlyInternet);                    }                    pccTsStartHandlingResponse = UtilsTime.getNanoTime();                    pccTsReadingStream = UtilsTime.getNanoTime();                    int responseCode = 0;                    String responseString = "";                    if (conn instanceof HttpURLConnection) {                        final HttpURLConnection httpConn = (HttpURLConnection) conn;                        try {                            connInputStream = httpConn.getInputStream();                        } catch (Exception ex) {                            connInputStream = httpConn.getErrorStream();                        }                        responseCode = httpConn.getResponseCode();                        responseString = Utils.inputStreamToString(connInputStream);                    }                    long readingStreamTime = UtilsTime.getNanoTime() - pccTsReadingStream;                    L.d("[Connection Processor] code:[" + responseCode + "], response:[" + responseString + "], response size:[" + responseString.length() + " B], request: " + requestData + ", url: " + serverURL_ + ", Reading stream took:[" + readingStreamTime / 1000000.0d + "] ms");                    if (pcc != null) {                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_13_ReadingStream", readingStreamTime);                    }                    final RequestResult rRes;                    if (responseCode >= 200 && responseCode < 300) {                        if (responseString.isEmpty()) {                            L.v("[ConnectionProcessor] Response was empty, will retry");                            rRes = RequestResult.RETRY;                        } else {                            JSONObject jsonObject;                            try {                                jsonObject = new JSONObject(responseString);                            } catch (JSONException ex) {                                jsonObject = null;                                L.e("[ConnectionProcessor] Failed to parse response [" + responseString + "].");                            }                            if (jsonObject == null) {                                L.v("[ConnectionProcessor] Response was a unknown, will retry");                                rRes = RequestResult.RETRY;                            } else {                                if (jsonObject.has("result")) {                                    L.v("[ConnectionProcessor] Response was a success");                                    rRes = RequestResult.OK;                                } else {                                    L.v("[ConnectionProcessor] Response does not contain 'result', will retry");                                    rRes = RequestResult.RETRY;                                }                            }                        }                    } else if (responseCode >= 300 && responseCode < 400) {                        L.d("[ConnectionProcessor] Encountered redirect, will retry");                        rRes = RequestResult.RETRY;                    } else if (responseCode == 400 || responseCode == 404) {                        L.w("[ConnectionProcessor] Bad request, will still retry");                        rRes = RequestResult.RETRY;                    } else if (responseCode > 400) {                        L.d("[ConnectionProcessor] Server is down, will retry");                        rRes = RequestResult.RETRY;                    } else {                        L.d("[ConnectionProcessor] Bad response code, will retry");                        rRes = RequestResult.RETRY;                    }                    if (rRes == RequestResult.OK) {                        storageProvider_.removeRequest(originalRequest);                    } else {                        healthTracker.logFailedNetworkRequest(responseCode, responseString);                        healthTracker.saveState();                        if (pcc != null) {                            pcc.TrackCounterTimeNs("ConnectionProcessorRun_12_FailedRequest", UtilsTime.getNanoTime() - pccTsStartWholeQueue);                        }                        break;                    }                } catch (Exception e) {                    L.d("[ConnectionProcessor] Got exception while trying to submit request data: [" + requestData + "] [" + e + "]");                    if (pcc != null) {                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_11_NetworkWholeQueueException", UtilsTime.getNanoTime() - pccTsStartWholeQueue);                    }                    break;                } finally {                    if (conn instanceof HttpURLConnection) {                        try {                            if (connInputStream != null) {                                connInputStream.close();                            }                        } catch (Throwable ignored) {                        }                        ((HttpURLConnection) conn).disconnect();                    }                }                long handlingResponseTime = UtilsTime.getNanoTime() - pccTsStartHandlingResponse;                L.d("[ConnectionProcessor] run, TIMING Handling response took:[" + handlingResponseTime / 1000000.0d + "] ms");                if (pcc != null) {                    pcc.TrackCounterTimeNs("ConnectionProcessorRun_09_HandlingResponse", handlingResponseTime);                }            } else {                if (isRequestOld) {                    L.i("[ConnectionProcessor] request is too old, removing request " + originalRequest);                } else {                    L.i("[ConnectionProcessor] Device identified as an app crawler, removing request " + originalRequest);                }                storageProvider_.removeRequest(originalRequest);            }            if (pcc != null) {                pcc.TrackCounterTimeNs("ConnectionProcessorRun_10_NetworkWholeQueue", UtilsTime.getNanoTime() - pccTsStartWholeQueue);            }        }        long wholeQueueTime = UtilsTime.getNanoTime() - wholeQueueStart;        L.v("[ConnectionProcessor] run, TIMING Whole queue took:[" + wholeQueueTime / 1000000.0d + "] ms");    }    String getServerURL() {        return serverURL_;    }    StorageProvider getCountlyStore() {        return storageProvider_;    }}package ly.count.android.sdk;import android.app.Activity;import androidx.annotation.NonNull;import androidx.test.ext.junit.runners.AndroidJUnit4;import java.util.Map;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.mockito.ArgumentCaptor;import static org.mockito.Mockito.clearInvocations;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.never;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;@RunWith(AndroidJUnit4.class)public class ScenarioEventIDTests {    int idxV = 0;    int idxE = 0;    String[] idV = TestUtils.viewIDVals;    String[] idE = TestUtils.eventIDVals;    final String[] eKeys = TestUtils.eKeys;    final String[] vNames = TestUtils.vNames;    SafeIDGenerator safeViewIDGenerator;    SafeIDGenerator safeEventIDGenerator;    Activity act;    Activity act2;    @Before    public void setUp() {        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));        countlyStore.clear();        act = mock(Activity.class);        act2 = mock(TestUtils.Activity2.class);        safeViewIDGenerator = new SafeIDGenerator() {            @NonNull @Override public String GenerateValue() {                return idV[idxV++];            }        };        safeEventIDGenerator = new SafeIDGenerator() {            @NonNull @Override public String GenerateValue() {                return idE[idxE++];            }        };    }    @After    public void tearDown() {    }    @Test    public void eventIDScenario_automaticViews() {        CountlyConfig cc = TestUtils.createScenarioEventIDConfig(safeViewIDGenerator, safeEventIDGenerator).enableAutomaticViewTracking();        Countly mCountly = new Countly().init(cc);        EventQueueProvider eqp = TestUtils.setCreateEventQueueProviderMock(mCountly);        verifyRecordEventToEventQueueNotCalled(eqp);        mCountly.onStartInternal(act);        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[0], null, "", null, 1, 2);         clearInvocations(eqp);        mCountly.onStartInternal(act2);        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[0], null, "", null, 0, 2);        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[1], null, idV[0], null, 1, 2);        clearInvocations(eqp);        mCountly.events().recordEvent(eKeys[0]);        verifyRecordEventToEventQueueIDs(eqp, eKeys[0], idE[1], idV[1], null, "", 0, 1);        clearInvocations(eqp);        mCountly.onStopInternal();        verifyRecordEventToEventQueueNotCalled(eqp);        clearInvocations(eqp);        mCountly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY);        verifyRecordEventToEventQueueIDs(eqp, ModuleFeedback.RATING_EVENT_KEY, idE[2], idV[1], null, null, 0, 1);        clearInvocations(eqp);        mCountly.onStopInternal();        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[1], null, idV[0], null, 0, 1);        clearInvocations(eqp);        mCountly.events().recordEvent(eKeys[1]);        verifyRecordEventToEventQueueIDs(eqp, eKeys[1], idE[3], idV[1], null, idE[1], 0, 1);    }    @Test    public void eventIDScenario_manualViews() {        CountlyConfig cc = TestUtils.createScenarioEventIDConfig(safeViewIDGenerator, safeEventIDGenerator);        Countly mCountly = new Countly().init(cc);        EventQueueProvider eqp = TestUtils.setCreateEventQueueProviderMock(mCountly);        verifyRecordEventToEventQueueNotCalled(eqp);        mCountly.views().recordView(vNames[0]);        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[0], null, "", null, 0, 1);        clearInvocations(eqp);        mCountly.views().recordView(vNames[1]);        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[0], null, "", null, 0, 2);        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[1], null, idV[0], null, 1, 2);        clearInvocations(eqp);        mCountly.events().recordEvent(eKeys[0]);        verifyRecordEventToEventQueueIDs(eqp, eKeys[0], idE[0], idV[1], null, "", 0, 1);        clearInvocations(eqp);        mCountly.views().recordView(vNames[2]);        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[1], null, idV[0], null, 0, 2);        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[2], null, idV[1], null, 1, 2);        clearInvocations(eqp);        mCountly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY);        verifyRecordEventToEventQueueIDs(eqp, ModuleEvents.ACTION_EVENT_KEY, idE[1], idV[2], null, null, 0, 1);        clearInvocations(eqp);        mCountly.events().recordEvent(eKeys[1]);        clearInvocations(eqp);    }    public static void verifyRecordEventToEventQueueNotCalled(EventQueueProvider eqp) {        ArgumentCaptor<String> arg01 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<Map> arg02 = ArgumentCaptor.forClass(Map.class);        ArgumentCaptor<Integer> arg1 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Double> arg2 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Double> arg3 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Long> arg4 = ArgumentCaptor.forClass(Long.class);        ArgumentCaptor<Integer> arg5 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Integer> arg6 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<String> arg7 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg8 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg9 = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> arg10 = ArgumentCaptor.forClass(String.class);        verify(eqp, never()).recordEventToEventQueue(arg01.capture(), arg02.capture(), arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture(), arg8.capture(), arg9.capture(), arg10.capture());    }    public static void verifyRecordEventToEventQueueIDs(EventQueueProvider eqp, String eventKey, String eventID, String currentViewID, String previousViewID, String previousEventID, int entryIdx, int entryCount) {        ArgumentCaptor<String> argEventKey = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<Map> arg02 = ArgumentCaptor.forClass(Map.class);        ArgumentCaptor<Integer> arg1 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Double> arg2 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Double> arg3 = ArgumentCaptor.forClass(Double.class);        ArgumentCaptor<Long> arg4 = ArgumentCaptor.forClass(Long.class);        ArgumentCaptor<Integer> arg5 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<Integer> arg6 = ArgumentCaptor.forClass(Integer.class);        ArgumentCaptor<String> argEid = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> argPvid = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> argCvid = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> argPeid = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> argPreviousViewName = ArgumentCaptor.forClass(String.class);        ArgumentCaptor<String> argCurrentViewName = ArgumentCaptor.forClass(String.class);        verify(eqp, times(entryCount)).recordEventToEventQueue(argEventKey.capture(), arg02.capture(), arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), argEid.capture(), argPvid.capture(), argCvid.capture(), argPeid.capture());        Assert.assertEquals(eventKey, argEventKey.getAllValues().get(entryIdx));        Assert.assertEquals(eventID, argEid.getAllValues().get(entryIdx));        Assert.assertEquals(previousViewID, argPvid.getAllValues().get(entryIdx));        Assert.assertEquals(currentViewID, argCvid.getAllValues().get(entryIdx));        Assert.assertEquals(previousEventID, argPeid.getAllValues().get(entryIdx));    }}package ly.count.android.sdk;import androidx.test.core.app.ApplicationProvider;import androidx.test.ext.junit.runners.AndroidJUnit4;import java.util.HashMap;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import org.json.JSONException;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import static org.mockito.ArgumentMatchers.any;import static org.mockito.ArgumentMatchers.isNull;import static org.mockito.Mockito.mock;import static org.mockito.Mockito.times;import static org.mockito.Mockito.verify;@RunWith(AndroidJUnit4.class)public class ModuleRatingsTests {    Countly mCountly;    @Before    public void setUp() {        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));        countlyStore.clear();        mCountly = new Countly();        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http:        mCountly.init(config);    }    @After    public void tearDown() {    }    @Test    public void recordManualRating() {        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        String[] vals = { "aa", "bb", "cc" };        mCountly.ratings().recordManualRating(vals[0], 3, vals[1], vals[2], true);        final Map<String, Object> segm = new HashMap<>();        segm.put("platform", "android");        segm.put("app_version", "1.0");        segm.put("rating", "" + 3);        segm.put("widget_id", vals[0]);        segm.put("email", vals[1]);        segm.put("comment", vals[2]);        segm.put("contactMe", true);        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);        ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        mCountly.ratings().recordManualRating(vals[0], -12, vals[1], vals[2], true);        segm.put("rating", "" + 1);        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);        ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        mCountly.ratings().recordManualRating(vals[0], 12, vals[1], vals[2], true);        segm.put("rating", "" + 5);        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);        ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));        mCountly.moduleRatings.recordManualRatingInternal(null, 12, vals[1], vals[2], true);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));        mCountly.moduleRatings.recordManualRatingInternal("", 12, vals[1], vals[2], true);        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));    }    @Test(expected = IllegalStateException.class)    public void recordManualRatingNullID() {        mCountly.ratings().recordManualRating(null, 3, "ss", "qq", true);    }    @Test(expected = IllegalStateException.class)    public void recordManualRatingEmptyID() {        mCountly.ratings().recordManualRating("", 3, "ss", "qq", true);    }    @Test    public void getAutomaticSessionLimit() {        Countly countly = new Countly();        CountlyConfig config = (new CountlyConfig(TestUtils.getContext(), "appkey", "http:        countly.init(config);        Assert.assertEquals(44, countly.ratings().getAutomaticStarRatingSessionLimit());    }    @Test    public void getCurrentSessionCount() {        mCountly.ratings().clearAutomaticStarRatingSessionCount();        Assert.assertEquals(0, mCountly.ratings().getCurrentVersionsSessionCount());        mCountly.moduleRatings.registerAppSession(TestUtils.getContext(), null);        mCountly.moduleRatings.registerAppSession(TestUtils.getContext(), null);        Assert.assertEquals(2, mCountly.ratings().getCurrentVersionsSessionCount());        mCountly.ratings().clearAutomaticStarRatingSessionCount();        Assert.assertEquals(0, mCountly.ratings().getCurrentVersionsSessionCount());    }    @Test    public void setIfStarRatingShouldBeShownAutomatically() {        Assert.assertFalse(mCountly.moduleRatings.getIfStarRatingShouldBeShownAutomatically());        Countly countly = new Countly();        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http:        countly.init(config);        Assert.assertTrue(countly.moduleRatings.getIfStarRatingShouldBeShownAutomatically());    }    @Test    public void loadRatingPreferencesBadJson() {        StorageProvider cs = mCountly.connectionQueue_.getStorageProvider();        cs.setStarRatingPreferences("./{}23[]d");        Assert.assertEquals("./{}23[]d", cs.getStarRatingPreferences());        ModuleRatings.StarRatingPreferences srp = ModuleRatings.loadStarRatingPreferences(cs);        Assert.assertEquals("", srp.appVersion);        Assert.assertEquals(5, srp.sessionLimit);        Assert.assertEquals(0, srp.sessionAmount);        Assert.assertFalse(srp.isShownForCurrentVersion);        Assert.assertFalse(srp.automaticRatingShouldBeShown);        Assert.assertFalse(srp.disabledAutomaticForNewVersions);        Assert.assertFalse(srp.automaticHasBeenShown);        Assert.assertTrue(srp.isDialogCancellable);        Assert.assertEquals("App rating", srp.dialogTextTitle);        Assert.assertEquals("Please rate this app", srp.dialogTextMessage);        Assert.assertEquals("Cancel", srp.dialogTextDismiss);    }    @Test    public void internalLimits_recordManualRating_maxValueSize() throws JSONException {        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http:        config.sdkInternalLimits.setMaxValueSize(1);        config.setEventQueueSizeToSend(1);        Countly countly = new Countly().init(config);        countly.ratings().recordManualRating("A", 3, "email", "comment", true);        Map<String, Object> ratingSegmentation = prepareRatingSegmentation("3", "A", "e", "c", true);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, ratingSegmentation, 0);        countly.ratings().recordRatingWidgetWithID("B", 5, "aaa@bbb.com", "very_good", false);        ratingSegmentation = prepareRatingSegmentation("5", "B", "a", "v", false);        ModuleEventsTests.validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, ratingSegmentation, 1);    }    private Map<String, Object> prepareRatingSegmentation(String rating, String widgetId, String email, String comment, boolean userCanBeContacted) {        Map<String, Object> segm = new ConcurrentHashMap<>();        segm.put("platform", "android");        segm.put("app_version", "1.0");        segm.put("rating", rating);        segm.put("widget_id", widgetId);        segm.put("contactMe", userCanBeContacted);        if (email != null && !email.isEmpty()) {            segm.put("email", email);        }        if (comment != null && !comment.isEmpty()) {            segm.put("comment", comment);        }        return segm;    }}package ly.count.android.demo;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.Toast;import androidx.appcompat.app.AppCompatActivity;import java.util.List;import java.util.Map;import java.util.Random;import java.util.concurrent.ConcurrentHashMap;import ly.count.android.sdk.Countly;import ly.count.android.sdk.ModuleFeedback;import ly.count.android.sdk.ModuleFeedback.CountlyFeedbackWidget;import ly.count.android.sdk.ModuleFeedback.FeedbackWidgetType;import ly.count.android.sdk.StarRatingCallback;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;public class ActivityExampleFeedback extends AppCompatActivity {    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_example_feedback);        final Button presentSurvey = findViewById(R.id.presentSurvey);        presentSurvey.setOnClickListener(new View.OnClickListener() {            @Override public void onClick(View v) {                Countly.sharedInstance().feedback().presentSurvey(ActivityExampleFeedback.this);            }        });        final Button presentRating = findViewById(R.id.presentRating);        presentRating.setOnClickListener(new View.OnClickListener() {            @Override public void onClick(View v) {                Countly.sharedInstance().feedback().presentRating(ActivityExampleFeedback.this);            }        });        final Button presentNPS = findViewById(R.id.presentNPS);        presentNPS.setOnClickListener(new View.OnClickListener() {            @Override public void onClick(View v) {                Countly.sharedInstance().feedback().presentNPS(ActivityExampleFeedback.this);            }        });    }    public void onClickViewOther02(View v) {        Countly.sharedInstance().ratings().showStarRating(this, new StarRatingCallback() {            @Override            public void onRate(int rating) {                Toast.makeText(ActivityExampleFeedback.this, "onRate called with rating: " + rating, Toast.LENGTH_SHORT).show();            }            @Override            public void onDismiss() {                Toast.makeText(ActivityExampleFeedback.this, "onDismiss called", Toast.LENGTH_SHORT).show();            }        });    }    public void onClickViewOther07(View v) {        String widgetId = "614871419f030e44be07d82f";        Countly.sharedInstance().ratings().presentRatingWidgetWithID(widgetId, "Close", this, error -> {            if (error != null) {                Toast.makeText(this, "Encountered error while showing feedback dialog: [" + error + "]", Toast.LENGTH_LONG).show();            }            Toast.makeText(this, "presentRatingWidgetWithID callback", Toast.LENGTH_LONG).show();        });    }    public void onClickSendManualRating(View v) {        String widgetId = "5f15c01425f83c169c33cb65";        Countly.sharedInstance().ratings().recordRatingWidgetWithID(widgetId, 3, "foo@bar.garr", "Ragnaros should watch out", true);    }    boolean validateRetrievedFeedbackWidgetList(List<CountlyFeedbackWidget> retrievedWidgets, String error) {        if (error != null) {            Toast.makeText(this, "Encountered error while getting a list of available feedback widgets: [" + error + "]", Toast.LENGTH_LONG).show();            return true;        }        if (retrievedWidgets == null) {            Toast.makeText(this, "Got a null widget list", Toast.LENGTH_LONG).show();            return true;        }        return false;    }    CountlyFeedbackWidget widgetPicker(List<CountlyFeedbackWidget> retrievedWidgets, FeedbackWidgetType type) {        for (CountlyFeedbackWidget widget : retrievedWidgets) {            if (widget.type == type) {                return widget;            }        }        return null;    }    void GetAndShowFeedbackWidget(FeedbackWidgetType type) {        Countly.sharedInstance().feedback().getAvailableFeedbackWidgets((retrievedWidgets, error) -> {            if (validateRetrievedFeedbackWidgetList(retrievedWidgets, error)) {                return;            }            CountlyFeedbackWidget chosenWidget = widgetPicker(retrievedWidgets, type);            if (chosenWidget == null) {                Toast.makeText(this, "No available Survey widget", Toast.LENGTH_LONG).show();                return;            }            Countly.sharedInstance().feedback().presentFeedbackWidget(chosenWidget, this, "Close", new ModuleFeedback.FeedbackCallback() {                @Override public void onClosed() {                    Toast.makeText(ActivityExampleFeedback.this, "The feedback widget was closed", Toast.LENGTH_LONG).show();                }                @Override public void onFinished(String error) {                    if (error != null) {                        Toast.makeText(ActivityExampleFeedback.this, "Encountered error while presenting the feedback widget: [" + error + "]", Toast.LENGTH_LONG).show();                    }                }            });        });    }    public void onClickShowSurvey(View v) {        GetAndShowFeedbackWidget(FeedbackWidgetType.survey);    }    public void onClickShowNPS(View v) {        GetAndShowFeedbackWidget(FeedbackWidgetType.nps);    }    public void onClickShowRating(View v) {        GetAndShowFeedbackWidget(FeedbackWidgetType.rating);    }    public void onClickShowAvailableFeedbackWidgets(View v) {        Countly.sharedInstance().feedback().getAvailableFeedbackWidgets((retrievedWidgets, error) -> {            if (validateRetrievedFeedbackWidgetList(retrievedWidgets, error)) {                return;            }            StringBuilder sb = new StringBuilder();            for (CountlyFeedbackWidget widget : retrievedWidgets) {                sb.append('[').append(widget.widgetId).append(' ').append(widget.name).append(' ').append(widget.type).append("]\n");            }            Toast.makeText(this, sb.toString(), Toast.LENGTH_LONG).show();        });    }    public void GetDataForFirstWidgetOfType(FeedbackWidgetType type, FeedbackCallbacks callback) {        Countly.sharedInstance().feedback().getAvailableFeedbackWidgets((retrievedWidgets, error) -> {            if (validateRetrievedFeedbackWidgetList(retrievedWidgets, error)) {                return;            }            CountlyFeedbackWidget chosenWidget = widgetPicker(retrievedWidgets, type);            if (chosenWidget == null) {                Toast.makeText(this, "No available NPS widget for manual reporting", Toast.LENGTH_LONG).show();                return;            }            final CountlyFeedbackWidget widgetToReport = chosenWidget;            Countly.sharedInstance().feedback().getFeedbackWidgetData(chosenWidget, (retrievedWidgetData, error1) -> {                String val;                if (type == FeedbackWidgetType.nps) {                    val = "nps";                } else if (type == FeedbackWidgetType.survey) {                    val = "survey";                } else {                    val = "rating";                }                if (error1 != null) {                    Toast.makeText(this, "Encountered error while reporting " + val + " feedback widget: [" + error1 + "]", Toast.LENGTH_LONG).show();                    return;                }                Log.d(Countly.TAG, "Retrieved " + val + " widget data: " + retrievedWidgetData.toString());                callback.onFinished(widgetToReport, retrievedWidgetData);            });        });    }    public interface FeedbackCallbacks {        void onFinished(CountlyFeedbackWidget widgetToReport, JSONObject retrievedWidgetData);    }    public void onClickReportNPSManually(View v) {        GetDataForFirstWidgetOfType(FeedbackWidgetType.nps, (widgetToReport, retrievedWidgetData) -> {            Map<String, Object> segm = new ConcurrentHashMap<>();            segm.put("rating", 3);            segm.put("comment", "Filled out comment");            Countly.sharedInstance().feedback().reportFeedbackWidgetManually(widgetToReport, retrievedWidgetData, segm);            Toast.makeText(this, "NPS feedback reported manually", Toast.LENGTH_LONG).show();        });    }    public void onClickReportRatingManually(View v) {        GetDataForFirstWidgetOfType(FeedbackWidgetType.rating, (widgetToReport, retrievedWidgetData) -> {            Map<String, Object> segm = new ConcurrentHashMap<>();            segm.put("rating", 3);            segm.put("comment", "Filled out comment");            segm.put("email", "Filled out email");            segm.put("contactMe", true);            Countly.sharedInstance().feedback().reportFeedbackWidgetManually(widgetToReport, retrievedWidgetData, segm);            Toast.makeText(this, "Rating feedback reported manually", Toast.LENGTH_LONG).show();        });    }    public void onClickReportSurveyManually(View v) {        GetDataForFirstWidgetOfType(FeedbackWidgetType.rating, (widgetToReport, retrievedWidgetData) -> {            JSONArray questions = retrievedWidgetData.optJSONArray("questions");            if (questions == null) {                Toast.makeText(this, "No questions found in retrieved survey data", Toast.LENGTH_LONG).show();                return;            }            Map<String, Object> segm = new ConcurrentHashMap<>();            Random rnd = new Random();            StringBuilder sb = new StringBuilder();            for (int a = 0; a < questions.length(); a++) {                JSONObject question;                try {                    question = questions.getJSONObject(a);                } catch (JSONException e) {                    Log.e(Countly.TAG, "Failed to get question from survey data" + e);                    continue;                }                String wType = question.optString("type");                String questionId = question.optString("id");                String answerKey = "answ-" + questionId;                JSONArray choices = question.optJSONArray("choices");                if (choices == null) {                    continue;                }                switch (wType) {                    case "multi":                        for (int b = 0; b < choices.length(); b++) {                            if (b % 2 == 0) {                                String gonnaPick = choices.optJSONObject(b).optString("key");                                if (b != 0) {                                    sb.append(", ");                                }                                sb.append(gonnaPick);                            }                        }                        segm.put(answerKey, sb.toString());                        sb.setLength(0);                        break;                    case "radio":                    case "dropdown":                        int pick = rnd.nextInt(choices.length());                        segm.put(answerKey, choices.optJSONObject(pick).optString("key"));                        break;                    case "text":                        segm.put(answerKey, "Some random text");                        break;                    case "rating":                        segm.put(answerKey, rnd.nextInt(11));                        break;                    default:                        break;                }            }            Countly.sharedInstance().feedback().reportFeedbackWidgetManually(widgetToReport, retrievedWidgetData, segm);            Toast.makeText(this, "Survey feedback reported manually", Toast.LENGTH_LONG).show();        });    }    public void onClickRetrieveSurveyDataManually(View v) {        getAndPrintRetrievedFeedbackWidgetData(FeedbackWidgetType.survey);    }    public void onClickRetrieveNPSDataManually(View v) {        getAndPrintRetrievedFeedbackWidgetData(FeedbackWidgetType.nps);    }    void getAndPrintRetrievedFeedbackWidgetData(final FeedbackWidgetType widgetType) {        Countly.sharedInstance().feedback().getAvailableFeedbackWidgets((retrievedWidgets, error) -> {            if (validateRetrievedFeedbackWidgetList(retrievedWidgets, error)) {                return;            }            CountlyFeedbackWidget chosenWidget = widgetPicker(retrievedWidgets, widgetType);            if (chosenWidget == null) {                Toast.makeText(this, "No available survey widget for manual reporting", Toast.LENGTH_LONG).show();                return;            }            Countly.sharedInstance().feedback().getFeedbackWidgetData(chosenWidget, (retrievedWidgetData, error1) -> {                if (error1 != null) {                    Toast.makeText(this, "Encountered error while reporting survey feedback widget: [" + error1 + "]", Toast.LENGTH_LONG).show();                    return;                }                Log.d(Countly.TAG, "Retrieved survey widget data: " + retrievedWidgetData.toString());                Toast.makeText(this, "Survey data retrieved: " + retrievedWidgetData, Toast.LENGTH_LONG).show();            });        });    }}