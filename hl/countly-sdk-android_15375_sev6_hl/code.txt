/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import android.annotation.SuppressLint;
import android.app.Activity;
import android.app.Application;
import android.content.ComponentCallbacks;
import android.content.Context;
import android.content.res.Configuration;
import android.os.Bundle;
import androidx.annotation.NonNull;
import androidx.lifecycle.Lifecycle;
import androidx.lifecycle.ProcessLifecycleOwner;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
/**
 * This class is the public API for the Countly Android SDK.
 * Get more details <a href="https://github.com/Countly/countly-sdk-android">here</a>.
 */
public class Countly {
    private final String DEFAULT_COUNTLY_SDK_VERSION_STRING = "24.7.8";
    /**
     * Used as request meta data on every request
     */
    private final String DEFAULT_COUNTLY_SDK_NAME = "java-native-android";
    /**
     * Current version of the Count.ly Android SDK as a displayable string.
     */
    public String COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;
    /**
     * Used as request meta data on every request
     */
    public String COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;
    /**
     * Default string used in the begin session metrics if the
     * app version cannot be found.
     */
    protected static final String DEFAULT_APP_VERSION = "1.0";
    /**
     * Tag used in all logging in the Count.ly SDK.
     */
    public static final String TAG = "Countly";
    /**
     * Countly internal logger
     * Should not be used outside of the SDK
     * No guarantees of not breaking functionality
     * Exposed only for the SDK push implementation
     */
    public ModuleLog L = new ModuleLog();
    /**
     * Broadcast sent when consent set is changed
     */
    public static final String CONSENT_BROADCAST = "ly.count.android.sdk.Countly.CONSENT_BROADCAST";
    /**
     * Determines how many custom events can be queued locally before
     * an attempt is made to submit them to a Count.ly server.
     */
    int EVENT_QUEUE_SIZE_THRESHOLD = 100;
    /**
     * How often onTimer() is called. This is the default value.
     */
    private static final long TIMER_DELAY_IN_SECONDS = 60;
    protected static String[] publicKeyPinCertificates;
    protected static String[] certificatePinCertificates;
    interface LifecycleObserver {
        boolean LifeCycleAtleastStarted();
    }
    /**
     * Enum used in Countly.initMessaging() method which controls what kind of
     * app installation it is. Later (in Countly Dashboard or when calling Countly API method),
     * you'll be able to choose whether you want to send a message to test devices,
     * or to production ones.
     */
    public enum CountlyMessagingMode {
        TEST,
        PRODUCTION,
    }
    /**
     * Enum used in Countly.initMessaging() method which controls what kind of
     * messaging provider is in use in current app installation.
     */
    public enum CountlyMessagingProvider {
        FCM,    // Firebase
        HMS,    // Huawei
    }
    //SDK limit defaults
    final int maxKeyLengthDefault = 128;
    final int maxValueSizeDefault = 256;
    final int maxSegmentationValuesDefault = 100;
    final int maxBreadcrumbCountDefault = 100;
    final int maxStackTraceLinesPerThreadDefault = 30;
    final int maxStackTraceLineLengthDefault = 200;
    final int maxStackTraceThreadCountDefault = 50;
    // see http://stackoverflow.com/questions/7048198/thread-safe-singletons-in-java
    private static class SingletonHolder {
        @SuppressLint("StaticFieldLeak")
        static final Countly instance = new Countly();
    }
    ConnectionQueue connectionQueue_;
    private ScheduledExecutorService timerService_;
    private ScheduledFuture<?> timerFuture = null;
    private int activityCount_;
    boolean disableUpdateSessionRequests_ = false;//todo, move to module after 'setDisableUpdateSessionRequests' is removed
    boolean sdkIsInitialised = false;
    BaseInfoProvider baseInfoProvider;
    RequestQueueProvider requestQueueProvider;
    //w - warnings
    //e - errors
    //i - user accessible calls and important SDK internals
    //d - regular SDK internals
    //v - spammy SDK internals
    private boolean enableLogging_;
    Context context_;
    //Internal modules for functionality grouping
    List<ModuleBase> modules = new ArrayList<>();
    ModuleCrash moduleCrash = null;
    ModuleEvents moduleEvents = null;
    ModuleViews moduleViews = null;
    ModuleRatings moduleRatings = null;
    ModuleSessions moduleSessions = null;
    ModuleRemoteConfig moduleRemoteConfig = null;
    ModuleAPM moduleAPM = null;
    ModuleConsent moduleConsent = null;
    ModuleDeviceId moduleDeviceId = null;
    ModuleLocation moduleLocation = null;
    ModuleFeedback moduleFeedback = null;
    ModuleRequestQueue moduleRequestQueue = null;
    ModuleAttribution moduleAttribution = null;
    ModuleUserProfile moduleUserProfile = null;
    ModuleConfiguration moduleConfiguration = null;
    ModuleHealthCheck moduleHealthCheck = null;
    ModuleContent moduleContent = null;
    //reference to countly store
    CountlyStore countlyStore;
    //overrides
    boolean isHttpPostForced = false;//when true, all data sent to the server will be sent using HTTP POST
    //push related
    private boolean addMetadataToPushIntents = false;// a flag that indicates if metadata should be added to push notification intents
    //internal flags
    private boolean calledAtLeastOnceOnStart = false;//flag for if the onStart function has been called at least once
    protected boolean isBeginSessionSent = false;
    //custom request header fields
    Map<String, String> requestHeaderCustomValues;
    static long applicationStart = System.currentTimeMillis();
    String[] locationFallback;//temporary used until location can't be set before init
    protected CountlyConfig config_ = null;
    //fields for tracking push token debounce
    final static long lastRegistrationCallDebounceDuration = 60 * 1000;//60seconds
    long lastRegistrationCallTs = 0;
    String lastRegistrationCallID = null;
    CountlyMessagingProvider lastRegistrationCallProvider = null;
    boolean applicationClassProvided = false;
    public static class CountlyFeatureNames {
        public static final String sessions = "sessions";
        public static final String events = "events";
        public static final String views = "views";
        public static final String scrolls = "scrolls";
        public static final String clicks = "clicks";
        //public static final String forms = "forms";
        public static final String location = "location";
        public static final String crashes = "crashes";
        public static final String attribution = "attribution";
        public static final String users = "users";
        public static final String push = "push";
        public static final String starRating = "star-rating";
        public static final String apm = "apm";
        public static final String feedback = "feedback";
        public static final String remoteConfig = "remote-config";
        public static final String content = "content";
        //public static final String accessoryDevices = "accessory-devices";
    }
    /**
     * Returns the Countly singleton.
     */
    public static Countly sharedInstance() {
        return SingletonHolder.instance;
    }
    /**
     * Constructs a Countly object.
     * Creates a new ConnectionQueue and initializes the session timer.
     */
    Countly() {
        connectionQueue_ = new ConnectionQueue();
        timerService_ = Executors.newSingleThreadScheduledExecutor();
    }
    private void startTimerService(ScheduledExecutorService service, ScheduledFuture<?> previousTimer, long timerDelay) {
        if (previousTimer != null && !previousTimer.isCancelled()) {
            previousTimer.cancel(false);
        }
        //minimum delay of 1 second
        if (timerDelay < 1) {
            timerDelay = 1;
        }
        timerFuture = service.scheduleWithFixedDelay(this::onTimer, timerDelay, timerDelay, TimeUnit.SECONDS);
    }
    /**
     * Must be called before other SDK methods can be used.
     * To initialise the SDK, you must pass a CountlyConfig object that contains
     * all the necessary information for setting up the SDK
     * Please prefer to use this on Application's onCreate method
     *
     * @param config contains all needed information to init SDK
     */
    public synchronized Countly init(CountlyConfig config) {
        if (config == null) {
            throw new IllegalArgumentException("Can't init SDK with 'null' config");
        }
        //enable logging
        if (config.loggingEnabled) {
            //enable logging before any potential logging calls
            setLoggingEnabled(true);
        }
        L.SetListener(config.providedLogCallback);
        if (COUNTLY_SDK_NAME.equals(DEFAULT_COUNTLY_SDK_NAME) && COUNTLY_SDK_VERSION_STRING.equals(DEFAULT_COUNTLY_SDK_VERSION_STRING)) {
            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "]");
        } else {
            L.d("[Init] Initializing Countly [" + COUNTLY_SDK_NAME + "] SDK version [" + COUNTLY_SDK_VERSION_STRING + "] default name[" + DEFAULT_COUNTLY_SDK_NAME + "] default version[" + DEFAULT_COUNTLY_SDK_VERSION_STRING + "]");
        }
        if (config.context == null) {
            if (config.application != null) {
                L.d("[Init] No explicit context provided. Using context from the provided application class");
                config.context = config.application;
            } else {
                throw new IllegalArgumentException("valid context is required in Countly init, but was provided 'null'");
            }
        } else {
            L.d("[Init] Using explicitly provided context");
        }
        if (!UtilsNetworking.isValidURL(config.serverURL)) {
            throw new IllegalArgumentException("valid serverURL is required");
        }
        if (config.serverURL.charAt(config.serverURL.length() - 1) == '/') {
            L.v("[Init] Removing trailing '/' from provided server url");
            config.serverURL = config.serverURL.substring(0, config.serverURL.length() - 1);//removing trailing '/' from server url
        }
        if (config.appKey == null || config.appKey.isEmpty()) {
            throw new IllegalArgumentException("valid appKey is required, but was provided either 'null' or empty String");
        }
        if (config.application == null) {
            L.w("[Init] Initialising the SDK without providing the application class. Some functionality will not work.");
        }
        applicationClassProvided = config.application != null;
        if (config.deviceID != null && config.deviceID.isEmpty()) {
            //device ID is provided but it's a empty string
            L.w("[Countly] init, Provided device ID is an empty string. It will be ignored. And a new one will be generated by the SDK.");
            // setting device id as null to trigger SDK device id generation
            config.setDeviceId(null);
        }
        L.d("[Init] SDK initialised with the URL:[" + config.serverURL + "] and the appKey:[" + config.appKey + "]");
        if (L.logEnabled()) {
            L.i("[Init] Checking init parameters");
            // Context class hierarchy
            // Context
            //|- ContextWrapper
            //|- - Application
            //|- - ContextThemeWrapper
            //|- - - - Activity
            //|- - Service
            //|- - - IntentService
            Class contextClass = config.context.getClass();
            Class contextSuperClass = contextClass.getSuperclass();
            String contextText = "[Init] Provided Context [" + config.context.getClass().getSimpleName() + "]";
            if (contextSuperClass != null) {
                contextText += ", it's superclass: [" + contextSuperClass.getSimpleName() + "]";
            }
            L.i(contextText);
        }
        //set internal context, it's allowed to be changed on the second init call
        context_ = config.context.getApplicationContext();
        // if we get here and eventQueue_ != null, init is being called again with the same values,
        // so there is nothing to do, because we are already initialized with those values
        if (!sdkIsInitialised) {
            L.d("[Init] About to init internal systems");
            config_ = config;
            // Have a look at the SDK limit values
            if (config.sdkInternalLimits.maxKeyLength != null) {
                if (config.sdkInternalLimits.maxKeyLength < 1) {
                    config.sdkInternalLimits.maxKeyLength = 1;
                    L.w("[Init] provided 'maxKeyLength' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxKeyLength' override:[" + config.sdkInternalLimits.maxKeyLength + "]");
            } else {
                config.sdkInternalLimits.maxKeyLength = maxKeyLengthDefault;
            }
            if (config.sdkInternalLimits.maxValueSize != null) {
                if (config.sdkInternalLimits.maxValueSize < 1) {
                    config.sdkInternalLimits.maxValueSize = 1;
                    L.w("[Init] provided 'maxValueSize' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxValueSize' override:[" + config.sdkInternalLimits.maxValueSize + "]");
            } else {
                config.sdkInternalLimits.maxValueSize = maxValueSizeDefault;
            }
            if (config.sdkInternalLimits.maxSegmentationValues != null) {
                if (config.sdkInternalLimits.maxSegmentationValues < 1) {
                    config.sdkInternalLimits.maxSegmentationValues = 1;
                    L.w("[Init] provided 'maxSegmentationValues' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxSegmentationValues' override:[" + config.sdkInternalLimits.maxSegmentationValues + "]");
            } else {
                config.sdkInternalLimits.maxSegmentationValues = maxSegmentationValuesDefault;
            }
            if (config.sdkInternalLimits.maxBreadcrumbCount != null) {
                if (config.sdkInternalLimits.maxBreadcrumbCount < 1) {
                    config.sdkInternalLimits.maxBreadcrumbCount = 1;
                    L.w("[Init] provided 'maxBreadcrumbCount' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxBreadcrumbCount' override:[" + config.sdkInternalLimits.maxBreadcrumbCount + "]");
            } else {
                config.sdkInternalLimits.maxBreadcrumbCount = maxBreadcrumbCountDefault;
            }
            if (config.sdkInternalLimits.maxStackTraceLinesPerThread != null) {
                if (config.sdkInternalLimits.maxStackTraceLinesPerThread < 1) {
                    config.sdkInternalLimits.maxStackTraceLinesPerThread = 1;
                    L.w("[Init] provided 'maxStackTraceLinesPerThread' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxStackTraceLinesPerThread' override:[" + config.sdkInternalLimits.maxStackTraceLinesPerThread + "]");
            } else {
                config.sdkInternalLimits.maxStackTraceLinesPerThread = maxStackTraceLinesPerThreadDefault;
            }
            if (config.sdkInternalLimits.maxStackTraceLineLength != null) {
                if (config.sdkInternalLimits.maxStackTraceLineLength < 1) {
                    config.sdkInternalLimits.maxStackTraceLineLength = 1;
                    L.w("[Init] provided 'maxStackTraceLineLength' is less than '1'. Setting it to '1'.");
                }
                L.i("[Init] provided 'maxStackTraceLineLength' override:[" + config.sdkInternalLimits.maxStackTraceLineLength + "]");
            } else {
                config.sdkInternalLimits.maxStackTraceLineLength = maxStackTraceLineLengthDefault;
            }
            long timerDelay = TIMER_DELAY_IN_SECONDS;
            if (config.sessionUpdateTimerDelay != null) {
                //if we need to change the timer delay, do that first
                L.d("[Init] Setting custom session update timer delay, [" + config.sessionUpdateTimerDelay + "]");
                timerDelay = config.sessionUpdateTimerDelay;
            }
            startTimerService(timerService_, timerFuture, timerDelay);
            if (config.explicitStorageModeEnabled) {
                L.i("[Init] Explicit storage mode is being enabled");
            }
            //set or create the CountlyStore
            if (config.countlyStore != null) {
                //we are running a test and using a mock object
                countlyStore = config.countlyStore;
            } else {
                countlyStore = new CountlyStore(config.context, L, config.explicitStorageModeEnabled);
                config.setCountlyStore(countlyStore);
            }
            if (config.pcc != null) {
                L.i("[Init] Attaching a performance counter collector");
                countlyStore.pcc = config.pcc;
            }
            if (config.maxRequestQueueSize < 1) {
                L.e("[Init] provided request queue size is less than 1. Replacing it with 1.");
                config.maxRequestQueueSize = 1;
            }
            L.d("[Init] request queue size set to [" + config.maxRequestQueueSize + "]");
            countlyStore.setLimits(config.maxRequestQueueSize);
            if (config.storageProvider == null) {
                // outside of tests this should be null
                config.storageProvider = config.countlyStore;
            } else {
                L.d("[Init] Custom event storage provider was provided");
            }
            if (config.eventQueueProvider == null) {
                config.eventQueueProvider = countlyStore;
            } else {
                L.d("[Init] Custom event queue provider was provided");
            }
            if (config.requestQueueProvider == null) {
                config.requestQueueProvider = connectionQueue_;
            } else {
                L.d("[Init] Custom request queue provider was provided");
            }
            if (config.safeViewIDGenerator == null) {
                //if we didn't override this for a test
                config.safeViewIDGenerator = new SafeIDGenerator() {
                    @NonNull @Override public String GenerateValue() {
                        return Utils.safeRandomVal();
                    }
                };
            }
            if (config.safeEventIDGenerator == null) {
                //if we didn't override this for a test
                config.safeEventIDGenerator = new SafeIDGenerator() {
                    @NonNull @Override public String GenerateValue() {
                        return Utils.safeRandomVal();
                    }
                };
            }
            if (config.immediateRequestGenerator == null) {
                config.immediateRequestGenerator = new ImmediateRequestGenerator() {
                    @Override public ImmediateRequestI CreateImmediateRequestMaker() {
                        return (new ImmediateRequestMaker());
                    }
                };
            }
            if (config.lifecycleObserver == null) {
                config.lifecycleObserver = new LifecycleObserver() {
                    @Override public boolean LifeCycleAtleastStarted() {
                        return lifecycleStateAtLeastStartedInternal();
                    }
                };
            }
            if (config.metricProviderOverride != null) {
                L.d("[Init] Custom metric provider was provided");
            }
            config.deviceInfo = new DeviceInfo(config.metricProviderOverride);
            if (config.tamperingProtectionSalt != null) {
                L.d("[Init] Parameter tampering protection salt set");
            }
            if (config.dropAgeHours < 0) {
                config.dropAgeHours = 0;
                L.d("[Init] Drop older requests threshold can not be negative. No threshold will be set.");
            }
            if (config.dropAgeHours > 0) {
                L.d("[Init] Drop older requests threshold set to:[" + config.dropAgeHours + "] hours");
            }
            if (connectionQueue_ == null) {
                L.e("[Init] SDK failed to initialize because the connection queue failed to be created");
                return this;
            }
            //check legacy access methods
            if (locationFallback != null && config.locationCountyCode == null && config.locationCity == null && config.locationLocation == null && config.locationIpAddress == null) {
                //if the fallback was set and config did not contain any location, use the fallback info
                // { country_code, city, gpsCoordinates, ipAddress };
                config.locationCountyCode = locationFallback[0];
                config.locationCity = locationFallback[1];
                config.locationLocation = locationFallback[2];
                config.locationIpAddress = locationFallback[3];
            }
            //perform data migration if needed
            try {
                Map<String, Object> migrationParams = new HashMap<>();
                migrationParams.put(MigrationHelper.key_from_0_to_1_custom_id_set, config.deviceID != null);
                MigrationHelper mHelper = new MigrationHelper(config.storageProvider, L, context_);
                mHelper.doWork(migrationParams);
            } catch (Exception ex) {
                L.e("[Init] SDK failed while performing data migration. SDK is not capable to initialize.");
                return this;
            }
            //initialise modules
            moduleHealthCheck = new ModuleHealthCheck(this, config);
            moduleConfiguration = new ModuleConfiguration(this, config);
            moduleRequestQueue = new ModuleRequestQueue(this, config);
            moduleConsent = new ModuleConsent(this, config);
            moduleDeviceId = new ModuleDeviceId(this, config);
            moduleCrash = new ModuleCrash(this, config);
            moduleEvents = new ModuleEvents(this, config);
            moduleUserProfile = new ModuleUserProfile(this, config);//this has to be set before the session module so that we can update remote config before sending anything session related
            moduleViews = new ModuleViews(this, config);
            moduleRatings = new ModuleRatings(this, config);
            moduleSessions = new ModuleSessions(this, config);
            moduleRemoteConfig = new ModuleRemoteConfig(this, config);
            moduleAPM = new ModuleAPM(this, config);
            moduleLocation = new ModuleLocation(this, config);
            moduleFeedback = new ModuleFeedback(this, config);
            moduleAttribution = new ModuleAttribution(this, config);
            moduleContent = new ModuleContent(this, config);
            modules.clear();
            modules.add(moduleConfiguration);
            modules.add(moduleRequestQueue);
            modules.add(moduleConsent);
            modules.add(moduleDeviceId);
            modules.add(moduleCrash);
            modules.add(moduleEvents);
            modules.add(moduleUserProfile);//this has to be set before the session module so that we can update remote config before sending anything session related
            modules.add(moduleViews);
            modules.add(moduleRatings);
            modules.add(moduleSessions);
            modules.add(moduleRemoteConfig);
            modules.add(moduleAPM);
            modules.add(moduleLocation);
            modules.add(moduleFeedback);
            modules.add(moduleAttribution);
            modules.add(moduleContent);
            modules.add(moduleHealthCheck);//set this at the end to detect any health issues with other modules before sending the report
            if (config.testModuleListener != null) {
                modules.add(config.testModuleListener);
            }
            //add missing providers
            moduleConfiguration.consentProvider = config.consentProvider;
            moduleRequestQueue.consentProvider = config.consentProvider;
            moduleHealthCheck.consentProvider = config.consentProvider;
            moduleRequestQueue.deviceIdProvider = config.deviceIdProvider;
            moduleConsent.eventProvider = config.eventProvider;
            moduleConsent.deviceIdProvider = config.deviceIdProvider;
            moduleDeviceId.eventProvider = config.eventProvider;
            moduleCrash.eventProvider = config.eventProvider;
            moduleEvents.viewIdProvider = config.viewIdProvider;
            baseInfoProvider = config.baseInfoProvider;
            requestQueueProvider = config.requestQueueProvider;
            L.setHealthChecker(config.healthTracker);
            L.i("[Init] Finished initialising modules");
            if (config.customNetworkRequestHeaders != null) {
                L.i("[Countly] Calling addCustomNetworkRequestHeaders");
                requestHeaderCustomValues = config.customNetworkRequestHeaders;
                connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);
            }
            if (config.httpPostForced) {
                L.d("[Init] Setting HTTP POST to be forced");
                isHttpPostForced = config.httpPostForced;
            }
            if (config.tamperingProtectionSalt != null) {
                L.d("[Init] Enabling tamper protection");
            }
            if (config.dropAgeHours > 0) {
                L.d("[Init] Enabling drop older request threshold");
                countlyStore.setRequestAgeLimit(config.dropAgeHours);
            }
            if (config.pushIntentAddMetadata) {
                L.d("[Init] Enabling push intent metadata");
                addMetadataToPushIntents = config.pushIntentAddMetadata;
            }
            if (config.eventQueueSizeThreshold != null) {
                L.d("[Init] Setting event queue size: [" + config.eventQueueSizeThreshold + "]");
                if (config.eventQueueSizeThreshold < 1) {
                    L.d("[Init] queue size can't be less than zero");
                    config.eventQueueSizeThreshold = 1;
                }
                EVENT_QUEUE_SIZE_THRESHOLD = config.eventQueueSizeThreshold;
            }
            if (config.publicKeyPinningCertificates != null) {
                sharedInstance().L.i("[Init] Enabling public key pinning");
                publicKeyPinCertificates = config.publicKeyPinningCertificates;
            }
            if (config.certificatePinningCertificates != null) {
                Countly.sharedInstance().L.i("[Init] Enabling certificate pinning");
                certificatePinCertificates = config.certificatePinningCertificates;
            }
            //initialize networking queues
            connectionQueue_.L = L;
            connectionQueue_.healthTracker = config.healthTracker;
            connectionQueue_.configProvider = config.configProvider;
            connectionQueue_.consentProvider = moduleConsent;
            connectionQueue_.moduleRequestQueue = moduleRequestQueue;
            connectionQueue_.deviceInfo = config.deviceInfo;
            connectionQueue_.pcc = config.pcc;
            connectionQueue_.setStorageProvider(config.storageProvider);
            connectionQueue_.setupSSLContext();
            connectionQueue_.setBaseInfoProvider(config.baseInfoProvider);
            connectionQueue_.setDeviceId(config.deviceIdProvider);
            connectionQueue_.setRequestHeaderCustomValues(requestHeaderCustomValues);
            connectionQueue_.setMetricOverride(config.metricOverride);
            connectionQueue_.setContext(context_);
            connectionQueue_.requestInfoProvider = new RequestInfoProvider() {
                @Override public boolean isHttpPostForced() {
                    return requestQueue().isHttpPostForced();
                }
                @Override public boolean isDeviceAppCrawler() {
                    return requestQueue().isDeviceAppCrawler();
                }
                @Override public boolean ifShouldIgnoreCrawlers() {
                    return requestQueue().ifShouldIgnoreCrawlers();
                }
                @Override public int getRequestDropAgeHours() {
                    return config.dropAgeHours;
                }
                @Override public String getRequestSalt() {
                    return config.tamperingProtectionSalt;
                }
            };
            sdkIsInitialised = true;
            //AFTER THIS POINT THE SDK IS COUNTED AS INITIALISED
            //set global application listeners
            if (config.application != null) {
                L.d("[Countly] Calling registerActivityLifecycleCallbacks");
                config.application.registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() {
                    @Override
                    public void onActivityCreated(Activity activity, Bundle bundle) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityCreated, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityCreated(activity);
                        //}
                    }
                    @Override
                    public void onActivityStarted(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityStarted, " + activity.getClass().getSimpleName());
                        }
                        onStartInternal(activity);
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityStarted(activity);
                        //}
                    }
                    @Override
                    public void onActivityResumed(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityResumed, " + activity.getClass().getSimpleName());
                        }
                        //for star rating
                        for (ModuleBase module : modules) {
                            module.callbackOnActivityResumed(activity);
                        }
                    }
                    @Override
                    public void onActivityPaused(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityPaused, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityPaused(activity);
                        //}
                    }
                    @Override
                    public void onActivityStopped(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityStopped, " + activity.getClass().getSimpleName());
                        }
                        onStopInternal();
                        //for APM
                        for (ModuleBase module : modules) {
                            module.callbackOnActivityStopped(activity);
                        }
                    }
                    @Override
                    public void onActivitySaveInstanceState(Activity activity, Bundle bundle) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivitySaveInstanceState, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivitySaveInstanceState(activity);
                        //}
                    }
                    @Override
                    public void onActivityDestroyed(Activity activity) {
                        if (L.logEnabled()) {
                            L.d("[Countly] onActivityDestroyed, " + activity.getClass().getSimpleName());
                        }
                        //for (ModuleBase module : modules) {
                        //    module.callbackOnActivityDestroyed(activity);
                        //}
                    }
                });
                config.application.registerComponentCallbacks(new ComponentCallbacks() {
                    @Override
                    public void onConfigurationChanged(Configuration configuration) {
                        L.d("[Countly] ComponentCallbacks, onConfigurationChanged");
                        onConfigurationChangedInternal(configuration);
                    }
                    @Override
                    public void onLowMemory() {
                        L.d("[Countly] ComponentCallbacks, onLowMemory");
                    }
                });
            } else {
                L.d("[Countly] Global activity listeners not registred due to no Application class");
            }
            if (config_.lifecycleObserver.LifeCycleAtleastStarted()) {
                L.d("[Countly] SDK detects that the app is in the foreground. Increasing the activity counter and setting the foreground state.");
                activityCount_++;
                config.deviceInfo.inForeground();
            }
            L.i("[Init] About to call module 'initFinished'");
            for (ModuleBase module : modules) {
                module.initFinished(config);
            }
            L.i("[Init] Finished initialising SDK");
        } else {
            //if this is not the first time we are calling init
            L.i("[Init] Getting in the 'else' block");
            // context is allowed to be changed on the second init call
            connectionQueue_.setContext(context_);
        }
        return this;
    }
    /**
     * Checks whether Countly.init has been already called.
     *
     * @return true if Countly is ready to use
     */
    @SuppressWarnings("BooleanMethodIsAlwaysInverted")
    public boolean isInitialized() {
        return sdkIsInitialised;
    }
    boolean lifecycleStateAtLeastStartedInternal() {
        return ProcessLifecycleOwner.get().getLifecycle().getCurrentState().isAtLeast(Lifecycle.State.STARTED);
    }
    private void stopTimer() {
        L.i("[Countly] stopTimer, Stopping global timer");
        if (timerService_ != null) {
            try {
                timerService_.shutdown();
                if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {
                    timerService_.shutdownNow();
                    if (!timerService_.awaitTermination(1, TimeUnit.SECONDS)) {
                        L.e("[Countly] stopTimer, Global timer must be locked");
                    }
                }
            } catch (Throwable t) {
                L.e("[Countly] stopTimer, Error while stopping global timer " + t);
            }
        }
    }
    /**
     * Immediately disables session and event tracking and clears any stored session and event data.
     * Testing Purposes Only!
     *
     * This will destroy all stored data
     */
    public synchronized void halt() {
        L.i("Halting Countly!");
        sdkIsInitialised = false;
        L.SetListener(null);
        stopTimer();
        if (connectionQueue_ != null) {
            if (countlyStore != null) {
                countlyStore.clear();
            }
            connectionQueue_.setContext(null);
            connectionQueue_ = null;
        }
        activityCount_ = 0;
        for (ModuleBase module : modules) {
            module.halt();
        }
        modules.clear();
        moduleCrash = null;
        moduleViews = null;
        moduleEvents = null;
        moduleRatings = null;
        moduleSessions = null;
        moduleRemoteConfig = null;
        moduleConsent = null;
        moduleAPM = null;
        moduleDeviceId = null;
        moduleLocation = null;
        moduleFeedback = null;
        moduleRequestQueue = null;
        moduleConfiguration = null;
        moduleHealthCheck = null;
        moduleContent = null;
        COUNTLY_SDK_VERSION_STRING = DEFAULT_COUNTLY_SDK_VERSION_STRING;
        COUNTLY_SDK_NAME = DEFAULT_COUNTLY_SDK_NAME;
        connectionQueue_ = new ConnectionQueue();
        timerService_ = Executors.newSingleThreadScheduledExecutor();
    }
    synchronized void notifyDeviceIdChange(boolean withoutMerge) {
        L.d("Notifying modules that device ID changed");
        for (ModuleBase module : modules) {
            module.deviceIdChanged(withoutMerge);
        }
    }
    void onStartInternal(Activity activity) {
        if (L.logEnabled()) {
            String activityName = "NULL ACTIVITY PROVIDED";
            if (activity != null) {
                activityName = activity.getClass().getSimpleName();
            }
            L.d("Countly onStartInternal called, name:[" + activityName + "], [" + activityCount_ + "] -> [" + (activityCount_ + 1) + "] activities now open");
        }
        ++activityCount_;
        if (activityCount_ == 1 && !moduleSessions.manualSessionControlEnabled) {
            //if we open the first activity
            //and we are not using manual session control,
            //begin a session
            moduleSessions.beginSessionInternal();
        }
        config_.deviceInfo.inForeground();
        for (ModuleBase module : modules) {
            module.onActivityStarted(activity, activityCount_);
        }
        calledAtLeastOnceOnStart = true;
    }
    void onStopInternal() {
        L.d("Countly onStopInternal called, [" + activityCount_ + "] -> [" + (activityCount_ - 1) + "] activities now open");
        if (activityCount_ == 0) {
            L.e("must call onStart before onStop");
            return;
        }
        --activityCount_;
        if (activityCount_ == 0 && !moduleSessions.manualSessionControlEnabled) {
            // if we don't use manual session control
            // Called when final Activity is stopped.
            // Sends an end session event to the server, also sends any unsent custom events.
            moduleSessions.endSessionInternal();
        }
        config_.deviceInfo.inBackground();
        for (ModuleBase module : modules) {
            module.onActivityStopped(activityCount_);
        }
    }
    public synchronized void onConfigurationChangedInternal(Configuration newConfig) {
        L.i("Calling [onConfigurationChangedInternal]");
        for (ModuleBase module : modules) {
            module.onConfigurationChanged(newConfig);
        }
    }
    /**
     * Tells the Countly SDK that an Activity has started. Since Android does not have an
     * easy way to determine when an application instance starts and stops, you must call this
     * method from every one of your Activity's onStart methods for accurate application
     * session tracking.
     */
    public synchronized void onStart(Activity activity) {
        if (!isInitialized()) {
            L.e("init must be called before onStart");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onStartInternal(activity);
    }
    /**
     * Tells the Countly SDK that an Activity has stopped. Since Android does not have an
     * easy way to determine when an application instance starts and stops, you must call this
     * method from every one of your Activity's onStop methods for accurate application
     * session tracking.
     * unbalanced calls to onStart/onStop are detected
     */
    public synchronized void onStop() {
        if (!isInitialized()) {
            L.e("init must be called before onStop");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onStart' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onStopInternal();
    }
    public synchronized void onConfigurationChanged(Configuration newConfig) {
        if (!isInitialized()) {
            L.e("init must be called before onConfigurationChanged");
            return;
        }
        if (applicationClassProvided) {
            L.w("Manual calls to 'onConfigurationChanged' will be ignored since the application class ir provided. SDK will handle these callbacks automatically");
            return;
        }
        onConfigurationChangedInternal(newConfig);
    }
    /**
     * Called every 60 seconds to send a session heartbeat to the server. Does nothing if there
     * is not an active application session.
     */
    synchronized void onTimer() {
        L.v("[onTimer] Calling heartbeat, Activity count:[" + activityCount_ + "]");
        if (isInitialized()) {
            final boolean appIsInForeground = activityCount_ > 0;
            if (appIsInForeground && !moduleSessions.manualSessionControlEnabled) {
                //if we have automatic session control and we are in the foreground, record an update
                moduleSessions.updateSessionInternal();
            } else if (moduleSessions.manualSessionControlEnabled && moduleSessions.manualSessionControlHybridModeEnabled && moduleSessions.sessionIsRunning()) {
                // if we are in manual session control mode with hybrid sessions enabled (SDK takes care of update requests) and there is a session running,
                // let's create the update request
                moduleSessions.updateSessionInternal();
            }
            //on every timer tick we collect all events and attempt to send requests
            moduleRequestQueue.sendEventsIfNeeded(true);
            //on every timer tick we save the user profile if it was changed
            moduleUserProfile.saveInternal();
            requestQueueProvider.tick();
        }
    }
    /**
     * DON'T USE THIS!!!!
     */
    public void onRegistrationId(String registrationId, CountlyMessagingProvider provider) {
        //if this call is done by CountlyPush, it is assumed that the SDK is already initialised
        if (!config_.consentProvider.getConsent(CountlyFeatureNames.push)) {
            return;
        }
        if (!isInitialized()) {
            L.w("[onRegistrationId] Calling this before the SDK is initialized.");
        }
        //debouncing the call
        long currentTs = UtilsTime.currentTimestampMs();
        long timeDelta = currentTs - lastRegistrationCallTs;
        if (lastRegistrationCallID != null && lastRegistrationCallID.equals(registrationId) &&
            lastRegistrationCallProvider != null && lastRegistrationCallProvider == provider &&
            timeDelta < lastRegistrationCallDebounceDuration) {
            // if the values match and we are trying to resend them withing the debounce duration, ignore them
            L.w("[onRegistrationId] Calling this with the same values within the debounce interval. elapsedT:[" + timeDelta + "] ms");
            return;
        }
        lastRegistrationCallTs = currentTs;
        lastRegistrationCallID = registrationId;
        lastRegistrationCallProvider = provider;
        connectionQueue_.tokenSession(registrationId, provider);
    }
    public void setLoggingEnabled(final boolean enableLogging) {
        enableLogging_ = enableLogging;
        L.d("Enabling logging");
    }
    /**
     * Check if logging has been enabled internally in the SDK
     *
     * @return true means "yes"
     */
    public boolean isLoggingEnabled() {
        return enableLogging_;
    }
    /**
     * Returns if the countly sdk onStart function has been called at least once
     *
     * @return true - yes, it has, false - no it has not
     * @deprecated This will be removed
     */
    public boolean hasBeenCalledOnStart() {
        return calledAtLeastOnceOnStart;
    }
    public ModuleCrash.Crashes crashes() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing crashes");
            return null;
        }
        return moduleCrash.crashesInterface;
    }
    public ModuleEvents.Events events() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing events");
            return null;
        }
        return moduleEvents.eventsInterface;
    }
    public ModuleViews.Views views() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing views");
            return null;
        }
        return moduleViews.viewsInterface;
    }
    public ModuleRatings.Ratings ratings() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing ratings");
            return null;
        }
        return moduleRatings.ratingsInterface;
    }
    public ModuleSessions.Sessions sessions() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing sessions");
            return null;
        }
        return moduleSessions.sessionInterface;
    }
    public ModuleRemoteConfig.RemoteConfig remoteConfig() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing remote config");
            return null;
        }
        return moduleRemoteConfig.remoteConfigInterface;
    }
    public ModuleAPM.Apm apm() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing apm");
            return null;
        }
        return moduleAPM.apmInterface;
    }
    public ModuleConsent.Consent consent() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing consent");
            return null;
        }
        return moduleConsent.consentInterface;
    }
    public ModuleLocation.Location location() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing location");
            return null;
        }
        return moduleLocation.locationInterface;
    }
    public ModuleFeedback.Feedback feedback() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing feedback");
            return null;
        }
        return moduleFeedback.feedbackInterface;
    }
    public ModuleRequestQueue.RequestQueue requestQueue() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing request queue");
            return null;
        }
        return moduleRequestQueue.requestQueueInterface;
    }
    public ModuleAttribution.Attribution attribution() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing attribution");
            return null;
        }
        return moduleAttribution.attributionInterface;
    }
    public ModuleDeviceId.DeviceId deviceId() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing deviceId");
            return null;
        }
        return moduleDeviceId.deviceIdInterface;
    }
    public ModuleUserProfile.UserProfile userProfile() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing user profile");
            return null;
        }
        return moduleUserProfile.userProfileInterface;
    }
    /**
     * Content feature interface
     *
     * @return content module
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public ModuleContent.Content contents() {
        if (!isInitialized()) {
            L.e("Countly.sharedInstance().init must be called before accessing content");
            return null;
        }
        return moduleContent.contentInterface;
    }
    public static void applicationOnCreate() {
    }
    // for unit testing
    ConnectionQueue getConnectionQueue() {
        return connectionQueue_;
    }
    ExecutorService getTimerService() {
        return timerService_;
    }
    long getPrevSessionDurationStartTime() {
        return moduleSessions.prevSessionDurationStartTime_;
    }
    void setPrevSessionDurationStartTime(final long prevSessionDurationStartTime) {
        moduleSessions.prevSessionDurationStartTime_ = prevSessionDurationStartTime;
    }
    int getActivityCount() {
        return activityCount_;
    }
    synchronized boolean getDisableUpdateSessionRequests() {
        return disableUpdateSessionRequests_;
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.view.LayoutInflater;
import android.view.View;
import android.webkit.WebResourceRequest;
import android.webkit.WebResourceResponse;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.RatingBar;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleRatings extends ModuleBase {
    //star rating
    StarRatingCallback starRatingCallback_;// saved callback that is used for automatic star rating
    boolean showStarRatingDialogOnFirstActivity = false;
    final Ratings ratingsInterface;
    ModuleRatings(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleRatings] Initialising");
        starRatingCallback_ = config.starRatingCallback;
        setStarRatingInitConfig(config.starRatingSessionLimit, config.starRatingTextTitle, config.starRatingTextMessage, config.starRatingTextDismiss);
        setIfRatingDialogIsCancellableInternal(config.starRatingDialogIsCancellable);
        setShowDialogAutomatically(config.starRatingShownAutomatically);
        setStarRatingDisableAskingForEachAppVersion(config.starRatingDisableAskingForEachAppVersion);
        ratingsInterface = new Ratings();
    }
    void recordManualRatingInternal(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
        L.d("[ModuleRatings] Calling recordManualRatingInternal");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            return;
        }
        if (widgetId == null) {
            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is null, returning");
            return;
        }
        if (widgetId.isEmpty()) {
            L.e("[ModuleRatings] recordManualRatingInternal, provided widget ID is empty, returning");
            return;
        }
        if (rating < 1) {
            rating = 1;
            L.d("[ModuleRatings] recordManualRatingInternal, given rating too low, defaulting to 1");
        }
        if (rating > 5) {
            rating = 5;
            L.d("[ModuleRatings] recordManualRatingInternal, given rating too high, defaulting to 5");
        }
        String truncatedEmail = UtilsInternalLimits.truncateValueSize(email, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");
        String truncatedComment = UtilsInternalLimits.truncateValueSize(comment, _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleRatings] recordManualRatingInternal");
        Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", deviceInfo.mp.getAppVersion(_cly.context_));
        segm.put("rating", "" + rating);
        segm.put("widget_id", widgetId);
        segm.put("contactMe", userCanBeContacted);
        if (truncatedEmail != null && !truncatedEmail.isEmpty()) {
            segm.put("email", truncatedEmail);
        }
        if (truncatedComment != null && !truncatedComment.isEmpty()) {
            segm.put("comment", truncatedComment);
        }
        eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    /**
     * Save the star rating preferences object
     *
     * @param srp
     */
    private void saveStarRatingPreferences(final StarRatingPreferences srp) {
        storageProvider.setStarRatingPreferences(srp.toJSON().toString());
    }
    /**
     * Setting things that would be provided during initial config
     *
     * @param limit limit for automatic rating
     * @param starRatingTextTitle provided title
     * @param starRatingTextMessage provided message
     * @param starRatingTextDismiss provided dismiss text
     */
    void setStarRatingInitConfig(final int limit, final String starRatingTextTitle, final String starRatingTextMessage, final String starRatingTextDismiss) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        if (limit >= 0) {
            srp.sessionLimit = limit;
        }
        if (starRatingTextTitle != null) {
            srp.dialogTextTitle = starRatingTextTitle;
        }
        if (starRatingTextMessage != null) {
            srp.dialogTextMessage = starRatingTextMessage;
        }
        if (starRatingTextDismiss != null) {
            srp.dialogTextDismiss = starRatingTextDismiss;
        }
        saveStarRatingPreferences(srp);
    }
    /**
     * Set if the star rating dialog should be shown automatically
     *
     * @param shouldShow
     */
    void setShowDialogAutomatically(final boolean shouldShow) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.automaticRatingShouldBeShown = shouldShow;
        saveStarRatingPreferences(srp);
    }
    boolean getIfStarRatingShouldBeShownAutomatically() {
        StarRatingPreferences srp = loadStarRatingPreferences(_cly.countlyStore);
        return srp.automaticRatingShouldBeShown;
    }
    /**
     * Set if automatic star rating should be disabled for each new version.
     * By default automatic star rating will be shown for every new app version.
     * If this is set to true, star rating will be shown only once over apps lifetime
     *
     * @param disableAsking if set true, will not show star rating for every new app version
     */
    void setStarRatingDisableAskingForEachAppVersion(final boolean disableAsking) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.disabledAutomaticForNewVersions = disableAsking;
        saveStarRatingPreferences(srp);
    }
    /**
     * Register that a apps session has transpired. Will increase session counter and show automatic star rating if needed.
     *
     * @param context android context
     * @param starRatingCallback
     */
    void registerAppSession(final Context context, final StarRatingCallback starRatingCallback) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        String currentAppVersion = deviceInfo.mp.getAppVersion(context);
        //a new app version is released, reset all counters
        //if we show the rating once per apps lifetime, don't reset the counters
        if (currentAppVersion != null && !currentAppVersion.equals(srp.appVersion) && !srp.disabledAutomaticForNewVersions) {
            srp.appVersion = currentAppVersion;
            srp.isShownForCurrentVersion = false;
            srp.sessionAmount = 0;
        }
        srp.sessionAmount++;
        if (srp.sessionAmount >= srp.sessionLimit && !srp.isShownForCurrentVersion && srp.automaticRatingShouldBeShown && !(srp.disabledAutomaticForNewVersions && srp.automaticHasBeenShown)) {
            showStarRatingDialogOnFirstActivity = true;
        }
        saveStarRatingPreferences(srp);
    }
    /**
     * Returns the session limit set for automatic star rating
     */
    static int getAutomaticStarRatingSessionLimitInternal(final StorageProvider sp) {
        StarRatingPreferences srp = loadStarRatingPreferences(sp);
        return srp.sessionLimit;
    }
    /**
     * Returns how many sessions has star rating counted internally
     *
     * @return
     */
    int getCurrentVersionsSessionCountInternal(final StorageProvider sp) {
        StarRatingPreferences srp = loadStarRatingPreferences(sp);
        return srp.sessionAmount;
    }
    /**
     * Set the automatic star rating session count back to 0
     */
    void clearAutomaticStarRatingSessionCountInternal() {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.sessionAmount = 0;
        saveStarRatingPreferences(srp);
    }
    /**
     * Set if the star rating dialog is cancellable
     *
     * @param isCancellable
     */
    void setIfRatingDialogIsCancellableInternal(final boolean isCancellable) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        srp.isDialogCancellable = isCancellable;
        saveStarRatingPreferences(srp);
    }
    /**
     * Class that handles star rating internal state
     */
    static class StarRatingPreferences {
        String appVersion = ""; //the name of the current version that we keep track of
        int sessionLimit = 5; //session limit for the automatic star rating
        int sessionAmount = 0; //session amount for the current version
        boolean isShownForCurrentVersion = false; //if automatic star rating has been shown for the current version
        boolean automaticRatingShouldBeShown = false; //if the automatic star rating should be shown
        boolean disabledAutomaticForNewVersions = false; //if the automatic star star should not be shown for every new apps version
        boolean automaticHasBeenShown = false; //if automatic star rating has been shown for any app's version
        boolean isDialogCancellable = true; //if star rating dialog is cancellable
        String dialogTextTitle = "App rating";
        String dialogTextMessage = "Please rate this app";
        String dialogTextDismiss = "Cancel";
        private static final String KEY_APP_VERSION = "sr_app_version";
        private static final String KEY_SESSION_LIMIT = "sr_session_limit";
        private static final String KEY_SESSION_AMOUNT = "sr_session_amount";
        private static final String KEY_IS_SHOWN_FOR_CURRENT = "sr_is_shown";
        private static final String KEY_AUTOMATIC_RATING_IS_SHOWN = "sr_is_automatic_shown";
        private static final String KEY_DISABLE_AUTOMATIC_NEW_VERSIONS = "sr_is_disable_automatic_new";
        private static final String KEY_AUTOMATIC_HAS_BEEN_SHOWN = "sr_automatic_has_been_shown";
        private static final String KEY_DIALOG_IS_CANCELLABLE = "sr_automatic_dialog_is_cancellable";
        private static final String KEY_DIALOG_TEXT_TITLE = "sr_text_title";
        private static final String KEY_DIALOG_TEXT_MESSAGE = "sr_text_message";
        private static final String KEY_DIALOG_TEXT_DISMISS = "sr_text_dismiss";
        /**
         * Create a JSONObject from the current state
         *
         * @return
         */
        JSONObject toJSON() {
            final JSONObject json = new JSONObject();
            try {
                json.put(KEY_APP_VERSION, appVersion);
                json.put(KEY_SESSION_LIMIT, sessionLimit);
                json.put(KEY_SESSION_AMOUNT, sessionAmount);
                json.put(KEY_IS_SHOWN_FOR_CURRENT, isShownForCurrentVersion);
                json.put(KEY_AUTOMATIC_RATING_IS_SHOWN, automaticRatingShouldBeShown);
                json.put(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, disabledAutomaticForNewVersions);
                json.put(KEY_AUTOMATIC_HAS_BEEN_SHOWN, automaticHasBeenShown);
                json.put(KEY_DIALOG_IS_CANCELLABLE, isDialogCancellable);
                json.put(KEY_DIALOG_TEXT_TITLE, dialogTextTitle);
                json.put(KEY_DIALOG_TEXT_MESSAGE, dialogTextMessage);
                json.put(KEY_DIALOG_TEXT_DISMISS, dialogTextDismiss);
            } catch (JSONException e) {
                Countly.sharedInstance().L.w("Got exception converting an StarRatingPreferences to JSON", e);
            }
            return json;
        }
        /**
         * Load the preference state from a JSONObject
         *
         * @param json
         * @return
         */
        static StarRatingPreferences fromJSON(final JSONObject json) {
            StarRatingPreferences srp = new StarRatingPreferences();
            if (json != null) {
                try {
                    srp.appVersion = json.getString(KEY_APP_VERSION);
                    srp.sessionLimit = json.optInt(KEY_SESSION_LIMIT, 5);
                    srp.sessionAmount = json.optInt(KEY_SESSION_AMOUNT, 0);
                    srp.isShownForCurrentVersion = json.optBoolean(KEY_IS_SHOWN_FOR_CURRENT, false);
                    srp.automaticRatingShouldBeShown = json.optBoolean(KEY_AUTOMATIC_RATING_IS_SHOWN, true);
                    srp.disabledAutomaticForNewVersions = json.optBoolean(KEY_DISABLE_AUTOMATIC_NEW_VERSIONS, false);
                    srp.automaticHasBeenShown = json.optBoolean(KEY_AUTOMATIC_HAS_BEEN_SHOWN, false);
                    srp.isDialogCancellable = json.optBoolean(KEY_DIALOG_IS_CANCELLABLE, true);
                    if (!json.isNull(KEY_DIALOG_TEXT_TITLE)) {
                        srp.dialogTextTitle = json.getString(KEY_DIALOG_TEXT_TITLE);
                    }
                    if (!json.isNull(KEY_DIALOG_TEXT_MESSAGE)) {
                        srp.dialogTextMessage = json.getString(KEY_DIALOG_TEXT_MESSAGE);
                    }
                    if (!json.isNull(KEY_DIALOG_TEXT_DISMISS)) {
                        srp.dialogTextDismiss = json.getString(KEY_DIALOG_TEXT_DISMISS);
                    }
                } catch (JSONException e) {
                    Countly.sharedInstance().L.w("Got exception converting JSON to a StarRatingPreferences", e);
                }
            }
            return srp;
        }
    }
    /**
     * Call to manually show star rating dialog
     *
     * @param context android context
     * @param callback
     */
    void showStarRatingInternal(final Context context, final StarRatingCallback callback) {
        StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
        showStarRatingCustom(context, srp.dialogTextTitle, srp.dialogTextMessage, srp.dialogTextDismiss, srp.isDialogCancellable, callback);
    }
    /**
     * Returns a object with the loaded preferences
     * TODO make this non static
     *
     * @return
     */
    static StarRatingPreferences loadStarRatingPreferences(final StorageProvider sp) {
        String srpString = sp.getStarRatingPreferences();
        StarRatingPreferences srp;
        if (!srpString.equals("")) {
            JSONObject srJSON;
            try {
                srJSON = new JSONObject(srpString);
                srp = StarRatingPreferences.fromJSON(srJSON);
            } catch (JSONException e) {
                e.printStackTrace();
                srp = new StarRatingPreferences();
            }
        } else {
            srp = new StarRatingPreferences();
        }
        return srp;
    }
    /**
     * Method that created the star rating dialog
     *
     * @param context android context
     * @param title
     * @param message
     * @param cancelText
     * @param isCancellable
     * @param callback
     */
    void showStarRatingCustom(@NonNull final Context context, final String title, final String message, final String cancelText, final boolean isCancellable, @Nullable final StarRatingCallback callback) {
        if (!(context instanceof Activity)) {
            L.e("[ModuleRatings] Can't show star rating dialog, the provided context is not based off a activity");
            return;
        }
        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        View dialogLayout = inflater.inflate(R.layout.star_rating_layout, null);
        RatingBar ratingBar = dialogLayout.findViewById(R.id.ratingBar);
        final AlertDialog.Builder builder = new AlertDialog.Builder(context)
            .setTitle(title)
            .setMessage(message)
            .setCancelable(isCancellable)
            .setView(dialogLayout)
            .setOnCancelListener(new DialogInterface.OnCancelListener() {
                @Override
                public void onCancel(DialogInterface dialogInterface) {
                    if (callback != null) {
                        //call the dismiss callback ir the user clicks the back button or clicks outside the dialog
                        callback.onDismiss();
                    }
                }
            })
            .setPositiveButton(cancelText, new DialogInterface.OnClickListener() {
                @Override
                public void onClick(DialogInterface dialogInterface, int i) {
                    if (callback != null) {
                        //call the dismiss callback if the user clicks the "dismiss" button
                        callback.onDismiss();
                    }
                }
            });
        final AlertDialog dialog = builder.show();
        ratingBar.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener() {
            @Override
            public void onRatingChanged(RatingBar ratingBar, float v, boolean b) {
                int rating = (int) v;
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
                    Map<String, Object> segm = new HashMap<>();
                    segm.put("platform", "android");
                    segm.put("app_version", deviceInfo.mp.getAppVersion(context));
                    segm.put("rating", "" + rating);
                    eventProvider.recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
                }
                dialog.dismiss();
                if (callback != null) {
                    callback.onRate(rating);
                }
            }
        });
    }
    /// Countly webDialog user rating
    synchronized void showFeedbackPopupInternal(@Nullable final String widgetId, @Nullable final String closeButtonText, @Nullable final Activity activity, @Nullable final FeedbackRatingCallback devCallback) {
        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");
        if (widgetId == null || widgetId.isEmpty()) {
            if (devCallback != null) {
                devCallback.callback("Countly widgetId cannot be null or empty");
            }
            L.e("[ModuleRatings] Countly widgetId cannot be null or empty");
            return;
        }
        if (activity == null) {
            if (devCallback != null) {
                devCallback.callback("When showing feedback popup, Activity can't be null");
            }
            L.e("[ModuleRatings] When showing feedback popup, Activity can't be null");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            if (devCallback != null) {
                devCallback.callback("Consent is not granted");
            }
            return;
        }
        //check the device type
        final boolean deviceIsPhone;
        final boolean deviceIsTablet;
        final boolean deviceIsTv;
        deviceIsTv = Utils.isDeviceTv(activity);
        if (!deviceIsTv) {
            deviceIsPhone = !Utils.isDeviceTablet(activity);
            deviceIsTablet = Utils.isDeviceTablet(activity);
        } else {
            deviceIsTablet = false;
            deviceIsPhone = false;
        }
        String requestData = requestQueueProvider.prepareRatingWidgetRequest(widgetId);
        final String ratingWidgetUrl = baseInfoProvider.getServerURL() + "/feedback?widget_id=" + widgetId +
            "&device_id=" + UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()) +
            "&app_key=" + UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey());
        L.d("[ModuleRatings] rating widget url :[" + ratingWidgetUrl + "]");
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        (new ImmediateRequestMaker()).doWork(requestData, "/o/feedback/widget", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override
            public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably a lack of connection to the server");
                    if (devCallback != null) {
                        devCallback.callback("Not possible to show Rating popup, probably no internet connection or wrong widget id");
                    }
                    return;
                }
                if (!checkResponse.has("target_devices")) {
                    L.d("[ModuleRatings] Not possible to show Feedback popup for widget id: [" + widgetId + "], probably using a widget_id not intended for the rating widget");
                    if (devCallback != null) {
                        devCallback.callback("Not possible to show Rating popup, probably using a widget_id not intended for the rating widget");
                    }
                    return;
                }
                try {
                    JSONObject jDevices = checkResponse.getJSONObject("target_devices");
                    boolean showOnTv = jDevices.optBoolean("desktop", false);
                    boolean showOnPhone = jDevices.optBoolean("phone", false);
                    boolean showOnTablet = jDevices.optBoolean("tablet", false);
                    if ((deviceIsPhone && showOnPhone) || (deviceIsTablet && showOnTablet) || (deviceIsTv && showOnTv)) {
                        //it's possible to show the rating window on this device
                        L.d("[ModuleRatings] Showing Feedback popup for widget id: [" + widgetId + "]");
                        Handler handler = new Handler(Looper.getMainLooper());
                        handler.post(new Runnable() {
                            public void run() {
                                L.d("[ModuleRatings] Calling on main thread");
                                RatingDialogWebView webView = new RatingDialogWebView(activity);
                                webView.clearCache(true);
                                webView.clearHistory();
                                webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
                                webView.getSettings().setJavaScriptEnabled(true);
                                webView.loadUrl(ratingWidgetUrl);
                                AlertDialog.Builder builder = new AlertDialog.Builder(activity);
                                builder.setView(webView);
                                if (closeButtonText != null && !closeButtonText.isEmpty()) {
                                    builder.setNeutralButton(closeButtonText, new DialogInterface.OnClickListener() {
                                        @Override public void onClick(DialogInterface dialog, int which) {
                                            L.d("[ModuleRatings] Calling callback from 'close' button");
                                            if (devCallback != null) {
                                                devCallback.callback(null);
                                            }
                                        }
                                    });
                                }
                                builder.show();
                            }
                        });
                    } else {
                        if (devCallback != null) {
                            devCallback.callback("Rating dialog is not meant for this form factor");
                        }
                    }
                } catch (JSONException e) {
                    L.e("[ModuleRatings] Encountered a issue while trying to parse the results of the widget config", e);
                }
            }
        }, L);
    }
    static class RatingDialogWebView extends WebView {
        public RatingDialogWebView(Context context) {
            super(context);
        }
        /**
         * Without this override, the keyboard is not showing
         */
        @Override
        public boolean onCheckIsTextEditor() {
            return true;
        }
    }
    static class FeedbackDialogWebViewClient extends WebViewClient {
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) {
            String url = request.getUrl().toString();
            // Filter out outgoing calls
            if (url.endsWith("cly_x_int=1")) {
                Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
                view.getContext().startActivity(intent);
                return true;
            }
            return false;
        }
        @Override
        public WebResourceResponse shouldInterceptRequest(WebView view, String url) {
            // Countly.sharedInstance().L.i("attempting to load resource: " + url);
            return null;
        }
        @Override
        public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
            // Countly.sharedInstance().L.i("attempting to load resource: " + request.getUrl());
            return null;
        }
    }
    @Override
    void callbackOnActivityResumed(Activity activity) {
        if (showStarRatingDialogOnFirstActivity) {
            StarRatingPreferences srp = loadStarRatingPreferences(storageProvider);
            srp.isShownForCurrentVersion = true;
            srp.automaticHasBeenShown = true;
            showStarRatingInternal(activity, starRatingCallback_);
            saveStarRatingPreferences(srp);
            showStarRatingDialogOnFirstActivity = false;
        }
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        //do star rating related things
        if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
            registerAppSession(config.context, starRatingCallback_);
        }
    }
    @Override
    void halt() {
    }
    public class Ratings {
        /**
         * Record user rating widget manually without showing any message dialog.
         *
         * @param widgetId widget ID to which this rating will be tied. You get it from the dashboard
         * @param rating value from 1 to 5 that will be set as the rating value
         * @param email email of the user
         * @param comment comment set by the user
         * @param userCanBeContacted set true if the user wants you to contact him
         * @deprecated use 'recordRatingWidgetWithID' in place of this call
         */
        public void recordManualRating(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
            L.i("[Ratings] Calling recordManualRating");
            recordRatingWidgetWithID(widgetId, rating, email, comment, userCanBeContacted);
        }
        /**
         * Record user rating widget manually without showing any message dialog.
         *
         * @param widgetId widget ID to which this rating will be tied. You get it from the dashboard
         * @param rating value from 1 to 5 that will be set as the rating value
         * @param email email of the user
         * @param comment comment set by the user
         * @param userCanBeContacted set true if the user wants you to contact him
         */
        public void recordRatingWidgetWithID(String widgetId, int rating, String email, String comment, boolean userCanBeContacted) {
            synchronized (_cly) {
                L.i("[Ratings] Calling recordRatingWidgetWithID");
                if (widgetId == null || widgetId.isEmpty()) {
                    throw new IllegalStateException("A valid widgetID must be provided. The current one is either null or empty");
                }
                recordManualRatingInternal(widgetId, rating, email, comment, userCanBeContacted);
            }
        }
        /**
         * Show the rating dialog to the user
         *
         * @param widgetId ID that identifies this dialog
         * @deprecated use 'presentRatingWidgetWithID' in place of this call
         */
        public void showFeedbackPopup(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {
            L.i("[Ratings] Calling showFeedbackPopup");
            presentRatingWidgetWithID(widgetId, closeButtonText, activity, callback);
        }
        /**
         * Show the rating widget dialog to the user
         *
         * @param widgetId ID that identifies this dialog
         */
        public void presentRatingWidgetWithID(final String widgetId, final String closeButtonText, final Activity activity, final FeedbackRatingCallback callback) {
            synchronized (_cly) {
                L.i("[Ratings] Calling presentRatingWidgetWithID");
                showFeedbackPopupInternal(widgetId, closeButtonText, activity, callback);
            }
        }
        /**
         * Shows the star rating dialog
         *
         * @param activity the activity that will own the dialog
         * @param callback callback for the star rating dialog "rate" and "dismiss" events
         */
        public void showStarRating(Activity activity, StarRatingCallback callback) {
            synchronized (_cly) {
                L.i("[Ratings] Calling showStarRating");
                if (!consentProvider.getConsent(Countly.CountlyFeatureNames.starRating)) {
                    return;
                }
                showStarRatingInternal(activity, callback);
            }
        }
        /**
         * Returns how many sessions has star rating counted internally for the current apps version
         *
         * @return
         */
        public int getCurrentVersionsSessionCount() {
            synchronized (_cly) {
                int sessionCount = getCurrentVersionsSessionCountInternal(_cly.countlyStore);
                L.i("[Ratings] Getting star rating current version session count: [" + sessionCount + "]");
                return sessionCount;
            }
        }
        /**
         * Set the automatic star rating session count back to 0
         */
        public void clearAutomaticStarRatingSessionCount() {
            synchronized (_cly) {
                L.i("[Ratings] Clearing star rating session count");
                clearAutomaticStarRatingSessionCountInternal();
            }
        }
        /**
         * Returns the session limit set for automatic star rating
         */
        public int getAutomaticStarRatingSessionLimit() {
            synchronized (_cly) {
                int sessionLimit = ModuleRatings.getAutomaticStarRatingSessionLimitInternal(_cly.countlyStore);
                L.i("[Ratings] Getting automatic star rating session limit: [" + sessionLimit + "]");
                return sessionLimit;
            }
        }
    }
}
package ly.count.android.sdk;
import android.util.Log;
public class ModuleLog {
    public interface LogCallback {
        void LogHappened(String logMessage, ModuleLog.LogLevel logLevel);
    }
    public enum LogLevel {Verbose, Debug, Info, Warning, Error}
    LogCallback logListener = null;
    HealthTracker healthTracker;
    int countWarnings = 0;
    int countErrors = 0;
    void SetListener(LogCallback logListener) {
        this.logListener = logListener;
    }
    void trackWarning() {
        if (healthTracker == null) {
            countWarnings++;
        } else {
            healthTracker.logWarning();
        }
    }
    void trackError() {
        if (healthTracker == null) {
            countErrors++;
        } else {
            healthTracker.logError();
        }
    }
    void setHealthChecker(HealthTracker healthTracker) {
        v("[ModuleLog] Setting healthTracker W:" + countWarnings + " E:" + countErrors);
        this.healthTracker = healthTracker;
        if (healthTracker == null) {
            return;
        }
        for (int a = 0; a < countErrors; a++) {
            healthTracker.logError();
        }
        for (int a = 0; a < countWarnings; a++) {
            healthTracker.logWarning();
        }
        countWarnings = 0;
        countErrors = 0;
    }
    public void v(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.v(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Verbose);
    }
    public void d(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.d(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Debug);
    }
    public void i(String msg) {
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.i(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Info);
    }
    public void w(String msg) {
        w(msg, null);
    }
    public void w(String msg, Throwable t) {
        trackWarning();
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.w(Countly.TAG, msg);
        }
        informListener(msg, null, LogLevel.Warning);
    }
    public void e(String msg) {
        e(msg, null);
    }
    public void e(String msg, Throwable t) {
        trackError();
        if (!logEnabled()) {
            return;
        }
        if (Countly.sharedInstance().isLoggingEnabled()) {
            Log.e(Countly.TAG, msg, t);
        }
        informListener(msg, t, LogLevel.Error);
    }
    public boolean logEnabled() {
        return logListener != null || Countly.sharedInstance().isLoggingEnabled();
    }
    private void informListener(String msg, final Throwable t, final LogLevel level) {
        try {
            if (msg == null) {
                msg = "";
            }
            if (t != null) {
                msg += Log.getStackTraceString(t);
            }
            if (logListener != null) {
                logListener.LogHappened(msg, level);
            }
        } catch (Exception ex) {
            Log.e(Countly.TAG, "[ModuleLog] Failed to inform listener [" + ex.toString() + "]");
        }
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.MessageDigest;
public class UtilsNetworking {
    // http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
    final private static char[] hexArray = "0123456789ABCDEF".toCharArray();
    protected static @NonNull String urlEncodeString(@NonNull String givenValue) {
        assert Utils.isNotNullOrEmpty(givenValue);
        String result = "";
        try {
            result = java.net.URLEncoder.encode(givenValue, "UTF-8");
        } catch (UnsupportedEncodingException ignored) {
            // should never happen because Android guarantees UTF-8 support
        }
        return result;
    }
    protected static @NonNull String encodedArrayBuilder(@NonNull String[] args) {
        assert args != null && args.length > 0;
        StringBuilder encodedUrlBuilder = new StringBuilder();
        encodedUrlBuilder.append("[");
        for (int i = 0; i < args.length; i++) {
            encodedUrlBuilder.append('"').append(args[i]).append('"');
            if (i < args.length - 1) {
                encodedUrlBuilder.append(", ");
            }
        }
        encodedUrlBuilder.append("]");
        return encodedUrlBuilder.toString();
    }
    protected static @NonNull String urlDecodeString(@NonNull String givenValue) {
        assert givenValue != null;
        String decodedResult = "";
        try {
            decodedResult = java.net.URLDecoder.decode(givenValue, "UTF-8");
        } catch (UnsupportedEncodingException ignored) {
            // should never happen because Android guarantees UTF-8 support
        }
        return decodedResult;
    }
    protected static @NonNull String sha256Hash(@NonNull String toHash) {
        assert toHash != null;
        String hash;
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] bytes = toHash.getBytes("UTF-8");
            digest.update(bytes, 0, bytes.length);
            bytes = digest.digest();
            // This is ~55x faster than looping and String.formating()
            hash = bytesToHex(bytes);
        } catch (Throwable e) {
            hash = "";
            Countly.sharedInstance().L.e("Cannot tamper-protect params", e);
        }
        return hash;
    }
    /**
     * Get hexadecimal string representation of a byte array
     *
     * @param bytes array of bytes to convert
     * @return hex string of the byte array in lower case
     */
    public static @NonNull String bytesToHex(@NonNull byte[] bytes) {
        assert bytes != null && bytes.length > 0;
        char[] hexChars = new char[bytes.length * 2];
        for (int j = 0; j < bytes.length; j++) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = hexArray[v >>> 4];
            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
        }
        return new String(hexChars).toLowerCase();
    }
    /**
     * Utility method for testing validity of a URL.
     */
    @SuppressWarnings("ConstantConditions")
    static boolean isValidURL(@Nullable final String urlStr) {
        boolean validURL = false;
        if (urlStr != null && urlStr.length() > 0) {
            try {
                new URL(urlStr);
                validURL = true;
            } catch (MalformedURLException e) {
                validURL = false;
            }
        }
        return validURL;
    }
}
package ly.count.android.sdk;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Handler;
import android.os.Looper;
import android.webkit.WebSettings;
import android.webkit.WebView;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
public class ModuleFeedback extends ModuleBase {
    public enum FeedbackWidgetType {survey, nps, rating}
    public static class CountlyFeedbackWidget {
        public String widgetId;
        public FeedbackWidgetType type;
        public String name;
        public String[] tags;
    }
    final static String NPS_EVENT_KEY = "[CLY]_nps";
    final static String SURVEY_EVENT_KEY = "[CLY]_survey";
    final static String RATING_EVENT_KEY = "[CLY]_star_rating";
    final String cachedAppVersion;
    Feedback feedbackInterface = null;
    ModuleFeedback(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleFeedback] Initialising");
        cachedAppVersion = deviceInfo.mp.getAppVersion(config.context);
        feedbackInterface = new Feedback();
    }
    public interface RetrieveFeedbackWidgets {
        void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error);
    }
    public interface RetrieveFeedbackWidgetData {
        void onFinished(JSONObject retrievedWidgetData, String error);
    }
    public interface FeedbackCallback {
        void onClosed();
        void onFinished(String error);
    }
    void getAvailableFeedbackWidgetsInternal(final RetrieveFeedbackWidgets devCallback) {
        L.d("[ModuleFeedback] calling 'getAvailableFeedbackWidgetsInternal', callback set:[" + (devCallback != null) + "]");
        if (devCallback == null) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved without a callback");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            devCallback.onFinished(null, "Consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            devCallback.onFinished(null, "[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            return;
        }
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        String requestData = requestQueueProvider.prepareFeedbackListRequest();
        (new ImmediateRequestMaker()).doWork(requestData, "/o/sdk", cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleFeedback] Not possible to retrieve widget list. Probably due to lack of connection to the server");
                    devCallback.onFinished(null, "Not possible to retrieve widget list. Probably due to lack of connection to the server");
                    return;
                }
                L.d("[ModuleFeedback] Retrieved request: [" + checkResponse.toString() + "]");
                List<CountlyFeedbackWidget> feedbackEntries = parseFeedbackList(checkResponse);
                devCallback.onFinished(feedbackEntries, null);
            }
        }, L);
    }
    static List<CountlyFeedbackWidget> parseFeedbackList(JSONObject requestResponse) {
        Countly.sharedInstance().L.d("[ModuleFeedback] calling 'parseFeedbackList'");
        List<CountlyFeedbackWidget> parsedRes = new ArrayList<>();
        try {
            if (requestResponse != null) {
                JSONArray jArray = requestResponse.optJSONArray("result");
                if (jArray == null) {
                    Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, response does not have a valid 'result' entry. No widgets retrieved.");
                    return parsedRes;
                }
                for (int a = 0; a < jArray.length(); a++) {
                    try {
                        JSONObject jObj = jArray.getJSONObject(a);
                        String valId = jObj.optString("_id", "");
                        String valType = jObj.optString("type", "");
                        String valName = jObj.optString("name", "");
                        List<String> valTagsArr = new ArrayList<String>();
                        JSONArray jTagArr = jObj.optJSONArray("tg");
                        if (jTagArr == null) {
                            Countly.sharedInstance().L.w("[ModuleFeedback] parseFeedbackList, no tags received");
                        } else {
                            for (int in = 0; in < jTagArr.length(); in++) {
                                valTagsArr.add(jTagArr.getString(in));
                            }
                        }
                        if (valId.isEmpty()) {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget id, dropping");
                            continue;
                        }
                        if (valType.isEmpty()) {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved invalid entry with null or empty widget type, dropping");
                            continue;
                        }
                        FeedbackWidgetType plannedType;
                        if (valType.equals("survey")) {
                            plannedType = FeedbackWidgetType.survey;
                        } else if (valType.equals("nps")) {
                            plannedType = FeedbackWidgetType.nps;
                        } else if (valType.equals("rating")) {
                            plannedType = FeedbackWidgetType.rating;
                        } else {
                            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, retrieved unknown widget type, dropping");
                            continue;
                        }
                        CountlyFeedbackWidget se = new CountlyFeedbackWidget();
                        se.type = plannedType;
                        se.widgetId = valId;
                        se.name = valName;
                        se.tags = valTagsArr.toArray(new String[0]);
                        parsedRes.add(se);
                    } catch (Exception ex) {
                        Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, failed to parse json, [" + ex.toString() + "]");
                    }
                }
            }
        } catch (Exception ex) {
            Countly.sharedInstance().L.e("[ModuleFeedback] parseFeedbackList, Encountered exception while parsing feedback list, [" + ex.toString() + "]");
        }
        return parsedRes;
    }
    void presentFeedbackWidgetInternal(@Nullable final CountlyFeedbackWidget widgetInfo, @Nullable final Context context, @Nullable final String closeButtonText, @Nullable final FeedbackCallback devCallback) {
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Can't present widget with null widget info");
            if (devCallback != null) {
                devCallback.onFinished("Can't present widget with null widget info");
            }
            return;
        }
        L.d("[ModuleFeedback] presentFeedbackWidgetInternal, callback set:[" + (devCallback != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "]");
        if (context == null) {
            L.e("[ModuleFeedback] Can't show feedback, provided context is null");
            if (devCallback != null) {
                devCallback.onFinished("Can't show feedback, provided context is null");
            }
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            if (devCallback != null) {
                devCallback.onFinished("Consent is not granted");
            }
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            if (devCallback != null) {
                devCallback.onFinished("[ModuleFeedback] available feedback widget list can't be retrieved when in temporary device ID mode");
            }
            return;
        }
        StringBuilder widgetListUrl = new StringBuilder();
        switch (widgetInfo.type) {
            case survey:
                //'/o/feedback/nps/widget?widget_ids=' + nps[0]._id
                //https://xxxx.count.ly/feedback/nps?widget_id=5f8445c4eecf2a6de4dcb53e
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/survey?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
            case nps:
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/nps?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
            case rating:
                widgetListUrl.append(baseInfoProvider.getServerURL());
                widgetListUrl.append("/feedback/rating?widget_id=");
                widgetListUrl.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
                break;
        }
        widgetListUrl.append("&device_id=");
        widgetListUrl.append(UtilsNetworking.urlEncodeString(deviceIdProvider.getDeviceId()));
        widgetListUrl.append("&app_key=");
        widgetListUrl.append(UtilsNetworking.urlEncodeString(baseInfoProvider.getAppKey()));
        widgetListUrl.append("&sdk_version=");
        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);
        widgetListUrl.append("&sdk_name=");
        widgetListUrl.append(Countly.sharedInstance().COUNTLY_SDK_NAME);
        widgetListUrl.append("&platform=android");
        // TODO: this will be the base for the custom segmentation users can send while presenting a widget
        JSONObject customObjectToSendWithTheWidget = new JSONObject();
        try {
            customObjectToSendWithTheWidget.put("tc", 1);
        } catch (JSONException e) {
            throw new RuntimeException(e);
        }
        widgetListUrl.append("&custom=");
        widgetListUrl.append(customObjectToSendWithTheWidget.toString());
        final String preparedWidgetUrl = widgetListUrl.toString();
        L.d("[ModuleFeedback] Using following url for widget:[" + widgetListUrl + "]");
        //enable for chrome debugging
        //WebView.setWebContentsDebuggingEnabled(true);
        final boolean useAlertDialog = true;
        Handler handler = new Handler(Looper.getMainLooper());
        handler.post(new Runnable() {
            public void run() {
                L.d("[ModuleFeedback] Calling on main thread");
                try {
                    ModuleRatings.RatingDialogWebView webView = new ModuleRatings.RatingDialogWebView(context);
                    webView.getSettings().setJavaScriptEnabled(true);
                    webView.clearCache(true);
                    webView.clearHistory();
                    webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE);
                    webView.setWebViewClient(new ModuleRatings.FeedbackDialogWebViewClient());
                    webView.loadUrl(preparedWidgetUrl);
                    webView.requestFocus();
                    AlertDialog.Builder builder = prepareAlertDialog(context, webView, closeButtonText, widgetInfo, devCallback);
                    if (useAlertDialog) {
                        // use alert dialog to host the webView
                        L.d("[ModuleFeedback] Creating standalone Alert dialog");
                        builder.show();
                    } else {
                        // use dialog fragment to host the webView
                        L.d("[ModuleFeedback] Creating Alert dialog in dialogFragment");
                        //CountlyDialogFragment newFragment = CountlyDialogFragment.newInstance(builder);
                        //newFragment.show(fragmentManager, "CountlyFragmentDialog");
                    }
                    if (devCallback != null) {
                        devCallback.onFinished(null);
                    }
                } catch (Exception ex) {
                    L.e("[ModuleFeedback] Failed at displaying feedback widget dialog, [" + ex.toString() + "]");
                    if (devCallback != null) {
                        devCallback.onFinished("Failed at displaying feedback widget dialog, [" + ex.toString() + "]");
                    }
                }
            }
        });
    }
    AlertDialog.Builder prepareAlertDialog(@NonNull final Context context, @NonNull WebView webView, @Nullable String closeButtonText, @NonNull final CountlyFeedbackWidget widgetInfo, @Nullable final FeedbackCallback devCallback) {
        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        builder.setView(webView);
        builder.setCancelable(false);
        String usedCloseButtonText = closeButtonText;
        if (closeButtonText == null || closeButtonText.isEmpty()) {
            usedCloseButtonText = "Close";
        }
        builder.setNeutralButton(usedCloseButtonText, new DialogInterface.OnClickListener() {
            @Override public void onClick(DialogInterface dialogInterface, int i) {
                L.d("[ModuleFeedback] Cancel button clicked for the feedback widget");
                reportFeedbackWidgetCancelButton(widgetInfo, deviceInfo.mp.getAppVersion(context));
                if (devCallback != null) {
                    devCallback.onClosed();
                }
            }
        });
        return builder;
    }
    void reportFeedbackWidgetCancelButton(@NonNull CountlyFeedbackWidget widgetInfo, @NonNull String appVersion) {
        L.d("[reportFeedbackWidgetCancelButton] Cancel button event");
        if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            final Map<String, Object> segm = new HashMap<>();
            segm.put("platform", "android");
            segm.put("app_version", appVersion);
            segm.put("widget_id", "" + widgetInfo.widgetId);
            segm.put("closed", "1");
            final String key;
            if (widgetInfo.type == FeedbackWidgetType.survey) {
                key = SURVEY_EVENT_KEY;
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                key = RATING_EVENT_KEY;
            } else {
                key = NPS_EVENT_KEY;
            }
            eventProvider.recordEventInternal(key, segm, 1, 0, 0, null, null);
        }
    }
    /**
     * Downloads widget info and returns it to the callback
     *
     * @param widgetInfo identifies the specific widget for which you want to download widget data
     * @param devCallback mandatory callback in which the downloaded data will be returned
     */
    void getFeedbackWidgetDataInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable final RetrieveFeedbackWidgetData devCallback) {
        L.d("[ModuleFeedback] calling 'getFeedbackWidgetDataInternal', callback set:[" + (devCallback != null) + "]");
        if (devCallback == null) {
            L.e("[ModuleFeedback] Feedback widget data can't be retrieved without a callback");
            return;
        }
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Feedback widget data if provided widget is 'null'");
            return;
        }
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            devCallback.onFinished(null, "Consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");
            devCallback.onFinished(null, "[ModuleFeedback] Feedback widget data can't be retrieved when in temporary device ID mode");
            return;
        }
        StringBuilder requestData = new StringBuilder();
        String widgetDataEndpoint = "";
        switch (widgetInfo.type) {
            case survey:
                //https://xxxx.count.ly/o/surveys/survey/widget?widget_id=601345cf5e313f74&shown=1platform=Android&app_version=7
                widgetDataEndpoint = "/o/surveys/survey/widget";
                break;
            case nps:
                //https://xxxx.count.ly/o/surveys/nps/widget?widget_id=601345cf5e313f74&shown=1platform=Android&app_version=7
                widgetDataEndpoint = "/o/surveys/nps/widget";
                break;
            case rating:
                widgetDataEndpoint = "/o/surveys/rating/widget";
                break;
        }
        requestData.append("widget_id=");
        requestData.append(UtilsNetworking.urlEncodeString(widgetInfo.widgetId));
        requestData.append("&shown=1");
        requestData.append("&sdk_version=");
        requestData.append(Countly.sharedInstance().COUNTLY_SDK_VERSION_STRING);
        requestData.append("&sdk_name=");
        requestData.append(Countly.sharedInstance().COUNTLY_SDK_NAME);
        requestData.append("&platform=android");
        requestData.append("&app_version=");
        requestData.append(cachedAppVersion);
        ConnectionProcessor cp = requestQueueProvider.createConnectionProcessor();
        final boolean networkingIsEnabled = cp.configProvider_.getNetworkingEnabled();
        String requestDataStr = requestData.toString();
        L.d("[ModuleFeedback] Using following request params for retrieving widget data:[" + requestDataStr + "]");
        (new ImmediateRequestMaker()).doWork(requestDataStr, widgetDataEndpoint, cp, false, networkingIsEnabled, new ImmediateRequestMaker.InternalImmediateRequestCallback() {
            @Override public void callback(JSONObject checkResponse) {
                if (checkResponse == null) {
                    L.d("[ModuleFeedback] Not possible to retrieve widget data. Probably due to lack of connection to the server");
                    devCallback.onFinished(null, "Not possible to retrieve widget data. Probably due to lack of connection to the server");
                    return;
                }
                L.d("[ModuleFeedback] Retrieved widget data request: [" + checkResponse.toString() + "]");
                devCallback.onFinished(checkResponse, null);
            }
        }, L);
    }
    /**
     * Report widget info and do data validation
     *
     * @param widgetInfo identifies the specific widget for which the feedback is filled out
     * @param widgetData widget data for this specific widget
     * @param widgetResult segmentation of the filled out feedback. If this segmentation is null, it will be assumed that the survey was closed before completion and mark it appropriately
     */
    void reportFeedbackWidgetManuallyInternal(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {
        if (widgetInfo == null) {
            L.e("[ModuleFeedback] Can't report feedback widget data manually with 'null' widget info");
            return;
        }
        L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetData set:[" + (widgetData != null) + ", widget id:[" + widgetInfo.widgetId + "], widget type:[" + widgetInfo.type + "], widget result set:[" + (widgetResult != null) + "]");
        if (!consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
            L.w("[ModuleFeedback] Can't report feedback widget data, consent is not granted");
            return;
        }
        if (deviceIdProvider.isTemporaryIdEnabled()) {
            L.e("[ModuleFeedback] feedback widget result can't be reported when in temporary device ID mode");
            return;
        }
        if (widgetResult != null) {
            //removing broken values first
            UtilsInternalLimits.removeUnsupportedDataTypes(widgetResult, L);
            Iterator<Map.Entry<String, Object>> iter = widgetResult.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry<String, Object> entry = iter.next();
                if (entry.getKey() == null) {
                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' key, it will be removed, value[" + entry.getValue() + "]");
                    iter.remove();
                } else if (entry.getKey().isEmpty()) {
                    L.w("[ModuleFeedback] provided feedback widget result contains an empty string key, it will be removed, value[" + entry.getValue() + "]");
                    iter.remove();
                } else if (entry.getValue() == null) {
                    L.w("[ModuleFeedback] provided feedback widget result contains a 'null' value, it will be removed, key[" + entry.getKey() + "]");
                    iter.remove();
                }
                if (entry.getValue() instanceof String) {
                    // TODO, if applicable think about applying key and segmentation count limit for the widget result
                    String truncatedValue = UtilsInternalLimits.truncateValueSize(entry.getValue().toString(), _cly.config_.sdkInternalLimits.maxValueSize, L, "[ModuleFeedback] reportFeedbackWidgetManuallyInternal");
                    if (!truncatedValue.equals(entry.getValue())) {
                        entry.setValue(truncatedValue);
                    }
                }
            }
            if (widgetInfo.type == FeedbackWidgetType.nps) {
                //in case a nps widget was completed
                if (!widgetResult.containsKey("rating")) {
                    L.e("Provided NPS widget result does not have a 'rating' field, result can't be reported");
                    return;
                }
                //check rating data type
                Object ratingValue = widgetResult.get("rating");
                if (!(ratingValue instanceof Integer)) {
                    L.e("Provided NPS widget 'rating' field is not an integer, result can't be reported");
                    return;
                }
                //check rating value range
                int ratingValI = (int) ratingValue;
                if (ratingValI < 0 || ratingValI > 10) {
                    L.e("Provided NPS widget 'rating' value is out of bounds of the required value '[0;10]', it is probably an error");
                }
                if (!widgetResult.containsKey("comment")) {
                    L.w("Provided NPS widget result does not have a 'comment' field");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.survey) {
                //in case a survey widget was completed
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                //in case a rating widget was completed
                if (!widgetResult.containsKey("rating")) {
                    L.e("Provided Rating widget result does not have a 'rating' field, result can't be reported");
                    return;
                }
                //check rating data type
                Object ratingValue = widgetResult.get("rating");
                if (!(ratingValue instanceof Integer)) {
                    L.e("Provided Rating widget 'rating' field is not an integer, result can't be reported");
                    return;
                }
                //check rating value range
                int ratingValI = (int) ratingValue;
                if (ratingValI < 1 || ratingValI > 5) {
                    L.e("Provided Rating widget 'rating' value is out of bounds of the required value '[1;5]', it is probably an error");
                }
            }
        }
        if (widgetData == null) {
            L.d("[ModuleFeedback] reportFeedbackWidgetManuallyInternal, widgetInfo is 'null', no validation will be done");
        } else {
            //perform data validation
            String idInData = widgetData.optString("_id");
            if (!widgetInfo.widgetId.equals(idInData)) {
                L.w("[ModuleFeedback] id in widget info does not match the id in widget data");
            }
            String typeInData = widgetData.optString("type");
            if (widgetInfo.type == FeedbackWidgetType.nps) {
                if (!"nps".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [nps]");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.survey) {
                if (!"survey".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [survey]");
                }
            } else if (widgetInfo.type == FeedbackWidgetType.rating) {
                if (!"rating".equals(typeInData)) {
                    L.w("[ModuleFeedback] type in widget info [" + typeInData + "] does not match the type in widget data [rating]");
                }
            }
        }
        final String usedEventKey;
        if (widgetInfo.type == FeedbackWidgetType.nps) {
            usedEventKey = NPS_EVENT_KEY;
            //event when closed
            //{"key":"[CLY]_nps","segmentation":{"widget_id":"600e9d2e563e892016316339","platform":"android","app_version":"0.0","closed":1},"timestamp":1611570486021,"hour":15,"dow":1}
            //event when answered
            //{"key":"[CLY]_nps","segmentation":{"widget_id":"600e9b24563e89201631631f","platform":"android","app_version":"0.0","rating":10,"comment":"Thanks"},"timestamp":1611570182023,"hour":15,"dow":1}
        } else if (widgetInfo.type == FeedbackWidgetType.survey) {
            usedEventKey = SURVEY_EVENT_KEY;
            //event when closed
            //{"key":"[CLY]_survey","segmentation":{"widget_id":"600e9e0b563e89201631633e","platform":"android","app_version":"0.0","closed":1},"timestamp":1611570709449,"hour":16,"dow":1}
            //event when answered
            //{"key":"[CLY]_survey","segmentation":{"widget_id":"600e9e0b563e89201631633e","platform":"android","app_version":"0.0","answ-1611570700-0":"ch1611570700-0"},"timestamp":1611570895465,"hour":16,"dow":1}
        } else if (widgetInfo.type == FeedbackWidgetType.rating) {
            usedEventKey = RATING_EVENT_KEY;
            //event when closed
            // {"key":"[CLY]_star_rating","count":1,"timestamp":1671783040088,"hour":11,"dow":5,"segmentation":{"app_version":"1.0","widget_id":"614871419f030e44be07d82f","closed":"1","platform":"android"}
            //event when answered
            //{"key":"[CLY]_star_rating","count":1,"segmentation":{"widget_id":"614871419f030e44be07d82f","contactMe":false,"platform":"android","app_version":"1","platform_version_rate":"","rating":4,"email":"","comment":""}
        } else {
            usedEventKey = "";
        }
        Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", cachedAppVersion);
        segm.put("widget_id", widgetInfo.widgetId);
        if (widgetResult == null) {
            //mark as closed
            segm.put("closed", "1");
        } else {
            //widget was filled out
            //merge given segmentation
            segm.putAll(widgetResult);
        }
        eventProvider.recordEventInternal(usedEventKey, segm, 1, 0, 0, null, null);
    }
    /**
     * Present a feedback widget based on the provided nameIDorTag, internal function to use
     *
     * @param type the type of the feedback widget to present
     * @param nameIDorTag the widget id, widget name or widget tag of the feedback widget to present
     */
    private void presentFeedbackWidgetNameIDorTag(@NonNull Context context, @NonNull FeedbackWidgetType type, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
        getAvailableFeedbackWidgetsInternal(new RetrieveFeedbackWidgets() {
            @Override public void onFinished(List<CountlyFeedbackWidget> retrievedWidgets, String error) {
                if (error != null) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, Failed to retrieve feedback widget list, [" + error + "]");
                    return;
                }
                if (retrievedWidgets.isEmpty()) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widgets available");
                    return;
                }
                CountlyFeedbackWidget selectedWidget = null;
                for (CountlyFeedbackWidget widget : retrievedWidgets) {
                    if (widget.type == type) {
                        if (!nameIDorTag.isEmpty()) {
                            if (widget.widgetId.equals(nameIDorTag) || widget.name.equals(nameIDorTag)) {
                                selectedWidget = widget;
                                break;
                            }
                            for (String tag : widget.tags) {
                                if (tag.equals(nameIDorTag)) {
                                    selectedWidget = widget;
                                    break;
                                }
                            }
                        } else {
                            selectedWidget = widget;
                            break;
                        }
                    }
                }
                if (selectedWidget == null) {
                    L.e("[ModuleFeedback] presentFeedbackWidgetNameIDorTag, No feedback widget found with the provided nameIDorTag or type");
                    return;
                }
                presentFeedbackWidgetInternal(selectedWidget, context, null, devCallback);
            }
        });
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
    }
    @Override
    void halt() {
        feedbackInterface = null;
    }
    public class Feedback {
        /**
         * Get a list of available feedback widgets for this device ID
         *
         * @param callback
         */
        public void getAvailableFeedbackWidgets(@Nullable RetrieveFeedbackWidgets callback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to retrieve feedback widget list");
                getAvailableFeedbackWidgetsInternal(callback);
            }
        }
        /**
         * Present a chosen feedback widget in an alert dialog
         *
         * @param widgetInfo
         * @param context
         * @param closeButtonText if this is null, no "close" button will be shown
         * @param devCallback
         */
        public void presentFeedbackWidget(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable Context context, @Nullable String closeButtonText, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to present feedback widget in an alert dialog");
                presentFeedbackWidgetInternal(widgetInfo, context, closeButtonText, devCallback);
            }
        }
        /**
         * Download data for a specific widget so that it can be displayed with a custom UI
         * When requesting this data, it will count as a shown widget (will increment that "shown" count in the dashboard)
         *
         * @param widgetInfo
         * @param callback
         */
        public void getFeedbackWidgetData(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable RetrieveFeedbackWidgetData callback) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to retrieve feedback widget data");
                getFeedbackWidgetDataInternal(widgetInfo, callback);
            }
        }
        /**
         * Manually report a feedback widget in case a custom interface was used
         * In case widgetResult is passed as "null", it would be assumed that the widget was cancelled
         *
         * @param widgetInfo
         * @param widgetData
         * @param widgetResult
         */
        public void reportFeedbackWidgetManually(@Nullable CountlyFeedbackWidget widgetInfo, @Nullable JSONObject widgetData, @Nullable Map<String, Object> widgetResult) {
            synchronized (_cly) {
                L.i("[Feedback] Trying to report feedback widget manually");
                reportFeedbackWidgetManuallyInternal(widgetInfo, widgetData, widgetResult);
            }
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the NPS feedback widget to present, if empty, the top widget will be presented
         */
        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag) {
            presentNPS(context, nameIDorTag, null);
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentNPS(@NonNull Context context) {
            presentNPS(context, "");
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Survey feedback widget to present, if empty, the top widget will be presented
         */
        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag) {
            presentSurvey(context, nameIDorTag, null);
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentSurvey(@NonNull Context context) {
            presentSurvey(context, "");
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Rating feedback widget to present, if empty, the top widget will be presented
         */
        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag) {
            presentRating(context, nameIDorTag, null);
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets
         *
         * @param context the context to use for displaying the feedback widget
         */
        public void presentRating(@NonNull Context context) {
            presentRating(context, "");
        }
        /**
         * Present an NPS feedback widget from the top of the list of available NPS widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the NPS feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentNPS(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentNPS, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.nps, nameIDorTag, devCallback);
            }
        }
        /**
         * Present a Survey feedback widget from the top of the list of available Survey widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Survey feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentSurvey(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentSurvey, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.survey, nameIDorTag, devCallback);
            }
        }
        /**
         * Present a Rating feedback widget from the top of the list of available Rating widgets by the nameIDorTag string
         *
         * @param context the context to use for displaying the feedback widget
         * @param nameIDorTag the widget id, widget name or widget tag of the Rating feedback widget to present, if empty, the top widget will be presented
         * @param devCallback callback to be called when the feedback widget is closed
         */
        public void presentRating(@NonNull Context context, @NonNull String nameIDorTag, @Nullable FeedbackCallback devCallback) {
            synchronized (_cly) {
                L.i("[Feedback] presentRating, got nameIDorTag:[" + nameIDorTag + "], got callback:[" + (devCallback != null) + "]");
                presentFeedbackWidgetNameIDorTag(context, FeedbackWidgetType.rating, nameIDorTag, devCallback);
            }
        }
    }
}
/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.app.ActivityManager;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.FeatureInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.media.AudioManager;
import android.net.ConnectivityManager;
import android.os.BatteryManager;
import android.os.Build;
import android.os.Environment;
import android.os.StatFs;
import android.telephony.TelephonyManager;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.WindowManager;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.Date;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.json.JSONObject;
/**
 * This class provides several static methods to retrieve information about
 * the current device and operating environment.
 */
class DeviceInfo {
    private final static int startTime = UtilsTime.currentTimestampSeconds();
    private boolean inBackground = true;
    private static long totalMemory = 0;
    MetricProvider mp;
    public DeviceInfo(MetricProvider mpOverride) {
        mp = mpOverride;
        if (mp == null) {
            mp = new MetricProvider() {
                /**
                 * Returns the display name of the current operating system.
                 */
                @NonNull
                @Override public String getOS() {
                    return "Android";
                }
                /**
                 * Returns the current operating system version as a displayable string.
                 */
                @SuppressWarnings("SameReturnValue")
                @NonNull
                @Override
                public String getOSVersion() {
                    return android.os.Build.VERSION.RELEASE;
                }
                /**
                 * Returns the current device model.
                 */
                @SuppressWarnings("SameReturnValue")
                @NonNull
                @Override
                public String getDevice() {
                    return android.os.Build.MODEL;
                }
                @SuppressWarnings("SameReturnValue")
                @NonNull
                @Override
                public String getManufacturer() {
                    return Build.MANUFACTURER;
                }
                /**
                 * Returns the non-scaled pixel resolution of the current default display being used by the
                 * WindowManager in the specified context.
                 *
                 * @param context context to use to retrieve the current WindowManager
                 * @return a string in the format "WxH", or the empty string "" if resolution cannot be determined
                 */
                @NonNull
                @Override
                public String getResolution(@NonNull final Context context) {
                    // user reported NPE in this method; that means either getSystemService or getDefaultDisplay
                    // were returning null, even though the documentation doesn't say they should do so; so now
                    // we catch Throwable and return empty string if that happens
                    String resolution = "";
                    try {
                        final DisplayMetrics metrics = getDisplayMetrics(context);
                        resolution = metrics.widthPixels + "x" + metrics.heightPixels;
                    } catch (Throwable t) {
                        Countly.sharedInstance().L.i("[DeviceInfo] Device resolution cannot be determined");
                    }
                    return resolution;
                }
                /**
                 * Return the display metrics collected from the WindowManager in the specified context.
                 * @param context context to use to retrieve the current WindowManager
                 * @return the display metrics of the current default display
                 */
                @NonNull
                @Override
                public DisplayMetrics getDisplayMetrics(@NonNull final Context context) {
                    final WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
                    final Display display = wm.getDefaultDisplay();
                    final DisplayMetrics metrics = new DisplayMetrics();
                    display.getMetrics(metrics);
                    return metrics;
                }
                /**
                 * Maps the current display density to a string constant.
                 *
                 * @param context context to use to retrieve the current display metrics
                 * @return a string constant representing the current display density, or the
                 * empty string if the density is unknown
                 */
                @NonNull
                @Override
                public String getDensity(@NonNull final Context context) {
                    String densityStr;
                    final int density = context.getResources().getDisplayMetrics().densityDpi;
                    switch (density) {
                        case DisplayMetrics.DENSITY_LOW:
                            densityStr = "LDPI";
                            break;
                        case DisplayMetrics.DENSITY_MEDIUM:
                            densityStr = "MDPI";
                            break;
                        case DisplayMetrics.DENSITY_TV:
                            densityStr = "TVDPI";
                            break;
                        case DisplayMetrics.DENSITY_HIGH:
                            densityStr = "HDPI";
                            break;
                        case DisplayMetrics.DENSITY_260:
                        case DisplayMetrics.DENSITY_280:
                        case DisplayMetrics.DENSITY_300:
                        case DisplayMetrics.DENSITY_XHIGH:
                            densityStr = "XHDPI";
                            break;
                        case DisplayMetrics.DENSITY_340:
                        case DisplayMetrics.DENSITY_360:
                        case DisplayMetrics.DENSITY_400:
                        case DisplayMetrics.DENSITY_420:
                        case DisplayMetrics.DENSITY_XXHIGH:
                            densityStr = "XXHDPI";
                            break;
                        case DisplayMetrics.DENSITY_560:
                        case DisplayMetrics.DENSITY_XXXHIGH:
                            densityStr = "XXXHDPI";
                            break;
                        default:
                            densityStr = "other";
                            break;
                    }
                    return densityStr;
                }
                /**
                 * Returns the display name of the current network operator from the
                 * TelephonyManager from the specified context.
                 *
                 * @param context context to use to retrieve the TelephonyManager from
                 * @return the display name of the current network operator, or the empty
                 * string if it cannot be accessed or determined
                 */
                @NonNull
                @Override
                public String getCarrier(@NonNull final Context context) {
                    String carrier = "";
                    final TelephonyManager manager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
                    if (manager != null) {
                        carrier = manager.getNetworkOperatorName();
                    }
                    if (carrier == null || carrier.length() == 0) {
                        carrier = "";
                        Countly.sharedInstance().L.i("[DeviceInfo] No carrier found");
                    }
                    if (carrier.equals("--")) {
                        //if for some reason the carrier is returned as "--", just clear it and set to empty string
                        carrier = "";
                    }
                    return carrier;
                }
                @Override
                public int getTimezoneOffset() {
                    return TimeZone.getDefault().getOffset(new Date().getTime()) / 60_000;
                }
                /**
                 * Returns the current locale (ex. "en_US").
                 */
                @NonNull
                @Override
                public String getLocale() {
                    final Locale locale = Locale.getDefault();
                    return locale.getLanguage() + "_" + locale.getCountry();
                }
                /**
                 * Returns the application version string stored in the specified
                 * context's package info versionName field, or "1.0" if versionName
                 * is not present.
                 */
                @NonNull
                @Override
                public String getAppVersion(@NonNull final Context context) {
                    String result = Countly.DEFAULT_APP_VERSION;
                    try {
                        String tmpVersion = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;
                        if (tmpVersion != null) {
                            result = tmpVersion;
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        Countly.sharedInstance().L.i("[DeviceInfo] No app version found");
                    }
                    return result;
                }
                /**
                 * Returns the package name of the app that installed this app
                 */
                @NonNull
                @Override
                public String getStore(@NonNull final Context context) {
                    String result = "";
                    try {
                        result = context.getPackageManager().getInstallerPackageName(context.getPackageName());
                    } catch (Exception e) {
                        Countly.sharedInstance().L.d("[DeviceInfo, getStore] Can't get Installer package ");
                    }
                    if (result == null || result.length() == 0) {
                        result = "";
                        Countly.sharedInstance().L.d("[DeviceInfo, getStore] No store found");
                    }
                    return result;
                }
                /**
                 * Returns what kind of device this is. The potential values are:
                 * ["console", "mobile", "tablet", "smarttv", "wearable", "embedded", "desktop"]
                 * Currently the Android SDK differentiates between ["mobile", "tablet", "smarttv"]
                 */
                @NonNull
                @Override
                public String getDeviceType(@NonNull final Context context) {
                    if (Utils.isDeviceTv(context)) {
                        return "smarttv";
                    }
                    if (Utils.isDeviceTablet(context)) {
                        return "tablet";
                    }
                    return "mobile";
                }
                // Crash related calls
                @Override
                public long getTotalRAM() {
                    if (totalMemory == 0) {
                        RandomAccessFile reader = null;
                        String load;
                        try {
                            reader = new RandomAccessFile("/proc/meminfo", "r");
                            load = reader.readLine();
                            // Get the Number value from the string
                            Pattern p = Pattern.compile("(\\d+)");
                            Matcher m = p.matcher(load);
                            String value = "";
                            while (m.find()) {
                                value = m.group(1);
                            }
                            try {
                                if (value != null) {
                                    totalMemory = Long.parseLong(value) / 1024;
                                } else {
                                    totalMemory = 0;
                                }
                            } catch (NumberFormatException ex) {
                                totalMemory = 0;
                            }
                        } catch (IOException ex) {
                            try {
                                if (reader != null) {
                                    reader.close();
                                }
                            } catch (IOException exc) {
                                exc.printStackTrace();
                            }
                            ex.printStackTrace();
                        } finally {
                            try {
                                if (reader != null) {
                                    reader.close();
                                }
                            } catch (IOException exc) {
                                exc.printStackTrace();
                            }
                        }
                    }
                    return totalMemory;
                }
                /**
                 * Returns the current device RAM amount.
                 */
                @NonNull
                @Override
                public String getRamCurrent(Context context) {
                    ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
                    ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
                    activityManager.getMemoryInfo(mi);
                    return Long.toString(getTotalRAM() - (mi.availMem / 1_048_576L));
                }
                /**
                 * Returns the total device RAM amount.
                 */
                @NonNull
                @Override
                public String getRamTotal() {
                    return Long.toString(getTotalRAM());
                }
                /**
                 * Returns the current device cpu.
                 */
                @NonNull
                @Override
                public String getCpu() {
                    return Build.SUPPORTED_ABIS[0];
                }
                /**
                 * Returns the current device openGL version.
                 */
                @NonNull
                @Override
                public String getOpenGL(Context context) {
                    PackageManager packageManager = context.getPackageManager();
                    FeatureInfo[] featureInfos = packageManager.getSystemAvailableFeatures();
                    if (featureInfos != null && featureInfos.length > 0) {
                        for (FeatureInfo featureInfo : featureInfos) {
                            // Null feature name means this feature is the open gl es version feature.
                            if (featureInfo.name == null) {
                                if (featureInfo.reqGlEsVersion != FeatureInfo.GL_ES_VERSION_UNDEFINED) {
                                    return Integer.toString((featureInfo.reqGlEsVersion & 0xffff0000) >> 16);
                                } else {
                                    return "1"; // Lack of property means OpenGL ES version 1
                                }
                            }
                        }
                    }
                    return "1";
                }
                /**
                 * Returns the current device disk space.
                 */
                @TargetApi(18)
                @NonNull
                @Override
                public String getDiskCurrent() {
                    if (android.os.Build.VERSION.SDK_INT < 18) {
                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());
                        long total = (long) statFs.getBlockCount() * (long) statFs.getBlockSize();
                        long free = (long) statFs.getAvailableBlocks() * (long) statFs.getBlockSize();
                        return Long.toString((total - free) / 1_048_576L);
                    } else {
                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());
                        long total = statFs.getBlockCountLong() * statFs.getBlockSizeLong();
                        long free = statFs.getAvailableBlocksLong() * statFs.getBlockSizeLong();
                        return Long.toString((total - free) / 1048576L);
                    }
                }
                /**
                 * Returns the current device disk space.
                 */
                @TargetApi(18)
                @NonNull
                @Override
                public String getDiskTotal() {
                    if (android.os.Build.VERSION.SDK_INT < 18) {
                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());
                        long total = (long) statFs.getBlockCount() * (long) statFs.getBlockSize();
                        return Long.toString(total / 1048576L);
                    } else {
                        StatFs statFs = new StatFs(Environment.getRootDirectory().getAbsolutePath());
                        long total = statFs.getBlockCountLong() * statFs.getBlockSizeLong();
                        return Long.toString(total / 1048576L);
                    }
                }
                /**
                 * Returns the current device battery level.
                 */
                @Nullable
                @Override
                public String getBatteryLevel(Context context) {
                    try {
                        Intent batteryIntent;
                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                            batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED), null, null, Context.RECEIVER_NOT_EXPORTED);
                        } else {
                            batteryIntent = context.registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
                        }
                        if (batteryIntent != null) {
                            int level = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, -1);
                            int scale = batteryIntent.getIntExtra(BatteryManager.EXTRA_SCALE, -1);
                            // Error checking that probably isn't needed but I added just in case.
                            if (level > -1 && scale > 0) {
                                return Float.toString(((float) level / (float) scale) * 100.0f);
                            }
                        }
                    } catch (Exception e) {
                        Countly.sharedInstance().L.i("Can't get battery level");
                    }
                    return null;
                }
                /**
                 * Returns the current device orientation.
                 */
                @Nullable
                @Override
                public String getOrientation(Context context) {
                    int orientation = context.getResources().getConfiguration().orientation;
                    switch (orientation) {
                        case Configuration.ORIENTATION_LANDSCAPE:
                            return "Landscape";
                        case Configuration.ORIENTATION_PORTRAIT:
                            return "Portrait";
                        case Configuration.ORIENTATION_SQUARE:
                            return "Square";
                        case Configuration.ORIENTATION_UNDEFINED:
                            return "Unknown";
                        default:
                            return null;
                    }
                }
                /**
                 * Checks if device is rooted.
                 */
                @NonNull
                @Override
                public String isRooted() {
                    String[] paths = {
                        "/sbin/su", "/system/bin/su", "/system/xbin/su", "/data/local/xbin/su", "/data/local/bin/su", "/system/sd/xbin/su",
                        "/system/bin/failsafe/su", "/data/local/su"
                    };
                    for (String path : paths) {
                        if (new File(path).exists()) return "true";
                    }
                    return "false";
                }
                /**
                 * Checks if device is online.
                 */
                @SuppressLint("MissingPermission")
                @Nullable
                @Override
                public String isOnline(Context context) {
                    try {
                        ConnectivityManager conMgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
                        if (conMgr != null && conMgr.getActiveNetworkInfo() != null
                            && conMgr.getActiveNetworkInfo().isAvailable()
                            && conMgr.getActiveNetworkInfo().isConnected()) {
                            return "true";
                        }
                        return "false";
                    } catch (Exception e) {
                        Countly.sharedInstance().L.w("isOnline, Got exception determining netwprl connectivity", e);
                    }
                    return null;
                }
                /**
                 * Checks if device is muted.
                 */
                @NonNull
                @Override
                public String isMuted(Context context) {
                    try {
                        AudioManager audio = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
                        switch (audio.getRingerMode()) {
                            case AudioManager.RINGER_MODE_SILENT:
                                // Fall-through
                            case AudioManager.RINGER_MODE_VIBRATE:
                                return "true";
                            default:
                                return "false";
                        }
                    } catch (Throwable thr) {
                        return "false";
                    }
                }
                /**
                 * Check if device is foldable
                 * requires API level 30
                 *
                 * @param context to use
                 * @return true if device is foldable
                 */
                @Override
                public String hasHinge(Context context) {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
                        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_SENSOR_HINGE_ANGLE) + "";
                    }
                    return "false";
                }
                /**
                 * Get app's running time before crashing.
                 */
                @Override public String getRunningTime() {
                    return Integer.toString(UtilsTime.currentTimestampSeconds() - startTime);
                }
            };
        }
    }
    /**
     * Returns the common metrics that would be shared with session, remote config and crash metrics
     * If metric override is provided, it will check for specific keys and override them
     *
     * @param context
     * @param metricOverride
     * @return
     */
    @NonNull
    Map<String, Object> getCommonMetrics(@NonNull final Context context, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {
        final Map<String, Object> map = new ConcurrentHashMap<>();
        putIfNotNullAndNotEmpty(map, "_device", mp.getDevice());
        putIfNotNullAndNotEmpty(map, "_os", mp.getOS());
        putIfNotNullAndNotEmpty(map, "_os_version", mp.getOSVersion());
        putIfNotNullAndNotEmpty(map, "_resolution", mp.getResolution(context));
        putIfNotNullAndNotEmpty(map, "_app_version", mp.getAppVersion(context));
        putIfNotNullAndNotEmpty(map, "_manufacturer", mp.getManufacturer());
        putIfNotNullAndNotEmpty(map, "_has_hinge", mp.hasHinge(context));
        if (metricOverride != null) {
            try {
                if (metricOverride.containsKey("_device")) {
                    map.put("_device", metricOverride.get("_device"));
                }
                if (metricOverride.containsKey("_os")) {
                    map.put("_os", metricOverride.get("_os"));
                }
                if (metricOverride.containsKey("_os_version")) {
                    map.put("_os_version", metricOverride.get("_os_version"));
                }
                if (metricOverride.containsKey("_resolution")) {
                    map.put("_resolution", metricOverride.get("_resolution"));
                }
                if (metricOverride.containsKey("_app_version")) {
                    map.put("_app_version", metricOverride.get("_app_version"));
                }
                if (metricOverride.containsKey("_manufacturer")) {
                    map.put("_manufacturer", metricOverride.get("_manufacturer"));
                }
                if (metricOverride.containsKey("_has_hinge")) {
                    map.put("_has_hinge", metricOverride.get("_has_hinge"));
                }
            } catch (Exception e) {
                L.e("[DeviceInfo] getCommonMetrics, SDK encountered failure while trying to apply metric override, " + e);
            }
        }
        return map;
    }
    private void putIfNotNullAndNotEmpty(@NonNull Map<String, Object> metrics, String key, String value) {
        if (value != null && !value.isEmpty()) {
            metrics.put(key, value);
        }
    }
    /**
     * Returns url encoded metrics that would be used for "begin_session" requests and remote config
     *
     * @param context
     * @param metricOverride
     * @return
     */
    @NonNull
    String getMetrics(@NonNull final Context context, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {
        //we set the override to null because all of the entries will be overwritten anyway
        Map<String, Object> metrics = getCommonMetrics(context, null, L);
        putIfNotNullAndNotEmpty(metrics, "_carrier", mp.getCarrier(context));
        putIfNotNullAndNotEmpty(metrics, "_density", mp.getDensity(context));
        putIfNotNullAndNotEmpty(metrics, "_locale", mp.getLocale());
        putIfNotNullAndNotEmpty(metrics, "_store", mp.getStore(context));
        putIfNotNullAndNotEmpty(metrics, "_device_type", mp.getDeviceType(context));
        if (metricOverride != null) {
            for (String k : metricOverride.keySet()) {
                if (k == null || k.isEmpty()) {
                    L.w("[DeviceInfo] getMetrics, Provided metric override key can't be null or empty");
                    continue;
                }
                String overrideValue = metricOverride.get(k);
                if (overrideValue == null) {
                    L.w("[DeviceInfo] getMetrics, Provided metric override value can't be null, key:[" + k + "]");
                    continue;
                }
                metrics.put(k, overrideValue);
            }
        }
        String result = new JSONObject(metrics).toString();
        try {
            result = java.net.URLEncoder.encode(result, "UTF-8");
        } catch (UnsupportedEncodingException ex) {
            // should never happen because Android guarantees UTF-8 support
            Countly.sharedInstance().L.e("[getMetrics] encode failed, [" + ex + "]");
        }
        return result;
    }
    @NonNull
    String getMetricsHealthCheck(@NonNull final Context context, @Nullable final Map<String, String> metricOverride) {
        Map<String, Object> metrics = new ConcurrentHashMap<>();
        String appVersion = mp.getAppVersion(context);
        if (metricOverride != null) {
            if (metricOverride.containsKey("_app_version")) {
                appVersion = metricOverride.get("_app_version");
            }
        }
        metrics.put("_app_version", appVersion);
        String result = new JSONObject(metrics).toString();
        try {
            result = java.net.URLEncoder.encode(result, "UTF-8");
        } catch (UnsupportedEncodingException ex) {
            // should never happen because Android guarantees UTF-8 support
            Countly.sharedInstance().L.e("[getMetrics] encode failed, [" + ex + "]");
        }
        return result;
    }
    /**
     * Returns a JSON object containing the device crash report
     */
    @NonNull
    JSONObject getCrashDataJSON(@NonNull CrashData crashData, final boolean isNativeCrash) {
        Map<String, Object> crashDataMap = crashData.getCrashMetrics();
        //setting this first so the followup are not picked up as "dev changes" in the change field
        crashDataMap.put("_ob", crashData.getChangedFieldsAsInt());
        putIfNotNullAndNotEmpty(crashDataMap, "_error", crashData.getStackTrace());
        putIfNotNullAndNotEmpty(crashDataMap, "_nonfatal", Boolean.toString(!crashData.getFatal()));
        if (!isNativeCrash) {
            String breadcrumbs = crashData.getBreadcrumbsAsString();
            if (!breadcrumbs.isEmpty()) {
                crashDataMap.put("_logs", breadcrumbs);
            }
        }
        if (!crashData.getCrashSegmentation().isEmpty()) {
            crashDataMap.put("_custom", crashData.getCrashSegmentation());
        }
        return new JSONObject(crashDataMap);
    }
    @NonNull
    Map<String, Object> getCrashMetrics(@NonNull final Context context, boolean isNativeCrash, @Nullable final Map<String, String> metricOverride, @NonNull ModuleLog L) {
        Map<String, Object> metrics = getCommonMetrics(context, metricOverride, L);
        putIfNotNullAndNotEmpty(metrics, "_cpu", mp.getCpu());
        putIfNotNullAndNotEmpty(metrics, "_opengl", mp.getOpenGL(context));
        putIfNotNullAndNotEmpty(metrics, "_root", mp.isRooted());
        putIfNotNullAndNotEmpty(metrics, "_ram_total", mp.getRamTotal());
        putIfNotNullAndNotEmpty(metrics, "_disk_total", mp.getDiskTotal());
        if (!isNativeCrash) {
            //if is not a native crash
            putIfNotNullAndNotEmpty(metrics, "_ram_current", mp.getRamCurrent(context));
            putIfNotNullAndNotEmpty(metrics, "_disk_current", mp.getDiskCurrent());
            putIfNotNullAndNotEmpty(metrics, "_bat", mp.getBatteryLevel(context));
            putIfNotNullAndNotEmpty(metrics, "_run", mp.getRunningTime());
            putIfNotNullAndNotEmpty(metrics, "_orientation", mp.getOrientation(context));
            putIfNotNullAndNotEmpty(metrics, "_online", mp.isOnline(context));
            putIfNotNullAndNotEmpty(metrics, "_muted", mp.isMuted(context));
            putIfNotNullAndNotEmpty(metrics, "_background", isInBackground());
        } else {
            //if is a native crash
            metrics.put("_native_cpp", true);
        }
        return metrics;
    }
    @NonNull
    public String getAppVersionWithOverride(@NonNull final Context context, @Nullable final Map<String, String> metricOverride) {
        String appVersion = mp.getAppVersion(context);
        if (metricOverride != null && metricOverride.containsKey("_app_version")) {
            String overrideVersion = metricOverride.get("_app_version");
            if (overrideVersion != null) {
                appVersion = overrideVersion;
            }
        }
        return appVersion;
    }
    /**
     * Notify when app is in foreground
     */
    void inForeground() {
        inBackground = false;
    }
    /**
     * Notify when app is in background
     */
    void inBackground() {
        inBackground = true;
    }
    /**
     * Returns app background state
     */
    String isInBackground() {
        return Boolean.toString(inBackground);
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import android.content.res.Configuration;
import androidx.annotation.NonNull;
import java.util.List;
abstract class ModuleBase {
    final Countly _cly;
    ModuleLog L;
    ConsentProvider consentProvider;
    StorageProvider storageProvider;
    EventProvider eventProvider;
    RequestQueueProvider requestQueueProvider;
    DeviceIdProvider deviceIdProvider;
    BaseInfoProvider baseInfoProvider;
    ViewIdProvider viewIdProvider;
    ConfigurationProvider configProvider;
    HealthTracker healthTracker;
    DeviceInfo deviceInfo;
    PerformanceCounterCollector pcc;
    ModuleBase(@NonNull Countly cly, @NonNull CountlyConfig config) {
        _cly = cly;
        L = cly.L;
        consentProvider = config.consentProvider;
        storageProvider = config.storageProvider;
        eventProvider = config.eventProvider;
        requestQueueProvider = config.requestQueueProvider;
        deviceIdProvider = config.deviceIdProvider;
        baseInfoProvider = config.baseInfoProvider;
        viewIdProvider = config.viewIdProvider;
        configProvider = config.configProvider;
        healthTracker = config.healthTracker;
        deviceInfo = config.deviceInfo;
        pcc = config.pcc;
    }
    void halt() {
        throw new UnsupportedOperationException();
    }
    /**
     * Called manually by a countly call from the developer
     *
     * @param newConfig
     */
    void onConfigurationChanged(Configuration newConfig) {
    }
    /**
     * Called manually by a countly call from the developer
     */
    void onActivityStarted(Activity activity, int updatedActivityCount) {
    }
    /**
     * Called manually by a countly call from the developer
     */
    void onActivityStopped(int updatedActivityCount) {
    }
    //void callbackOnActivityCreated(Activity activity) {
    //}
    //
    //void callbackOnActivityStarted(Activity activity) {
    //}
    //
    void callbackOnActivityResumed(Activity activity) {
    }
    //
    //void callbackOnActivityPaused(Activity activity) {
    //}
    //
    void callbackOnActivityStopped(Activity activity) {
    }
    //
    //void callbackOnActivitySaveInstanceState(Activity activity) {
    //}
    //
    //void callbackOnActivityDestroyed(Activity activity) {
    //}
    //notify the SDK modules that the device ID has changed
    void deviceIdChanged(boolean withoutMerge) {
    }
    //notify the SDK modules that consent was updated
    void onConsentChanged(@NonNull final List<String> consentChangeDelta, final boolean newConsent, @NonNull final ModuleConsent.ConsentChangeSource changeSource) {
    }
    void consentWillChange(@NonNull List<String> consentThatWillChange, final boolean isConsentGiven) {
    }
    //notify the SDK modules that internal configuration was updated
    void sdkConfigurationChanged() {
    }
    void initFinished(@NonNull CountlyConfig config) {
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.json.JSONArray;
public class UtilsInternalLimits {
    private UtilsInternalLimits() {
    }
    /**
     * This function is intended to be used to truncate the length of a key to a certain limit.
     * It is used to ensure that the key length does not exceed the limit set by the SDK.
     * If the key length exceeds the limit, the key is truncated to the limit.
     * If the key length is less than or equal to the limit, the key is returned as is.
     * Used truncate method is substring. from 0 to limit.
     * <pre>
     * Intended to be used for those:
     * - event names
     * - view names
     * - custom trace key name (APM)
     * - custom metric key (APM)
     * - segmentation key (for all features)
     * - custom user property
     * - custom user property keys that are used for property modifiers (mul, push, pull, set, increment, etc)
     * </pre>
     *
     * @param key to truncate
     * @param limit to truncate to
     * @param L logger
     * @return truncated key
     */
    protected static String truncateKeyLength(@Nullable String key, final int limit, @NonNull ModuleLog L, @NonNull String tag) {
        return truncateString(key, limit, L, tag + ": [UtilsSdkInternalLimits] truncateKeyLength");
    }
    /**
     * Limits the size of all values in our key-value pairs.
     * "Value" fields include:
     * <pre>
     * - segmentation value in case of strings (for all features)
     * - custom user property string value
     * - user profile named key (username, email, etc) string values. Except the "picture" field, which has a limit of 4096 chars
     * - custom user property modifier string values. For example, for modifiers like "push," "pull," "setOnce", etc.
     * - breadcrumb text
     * - manual feedback widget reporting fields (reported as an event)
     * - rating widget response (reported as an event)
     * </pre>
     *
     * @param value to truncate
     * @param limit to truncate to
     * @param L logger
     * @return truncated key
     */
    protected static String truncateValueSize(@Nullable String value, final int limit, @NonNull ModuleLog L, @NonNull String tag) {
        return truncateString(value, limit, L, tag + ": [UtilsSdkInternalLimits] truncateValueSize");
    }
    private static String truncateString(@Nullable String value, final int limit, @NonNull ModuleLog L, @NonNull String tag) {
        assert limit >= 1;
        assert tag != null;
        assert L != null;
        if (value == null) {
            L.w(tag + ", value is null, returning");
            return value;
        }
        if (value.isEmpty()) {
            L.w(tag + ", value is empty, returning");
            return value;
        }
        assert value != null;
        if (value.length() > limit) {
            String truncatedValue = value.substring(0, limit);
            L.w(tag + ", Value length exceeds limit of " + limit + " characters. Truncating value to " + limit + " characters. Truncated to " + truncatedValue);
            return truncatedValue;
        }
        return value;
    }
    /**
     * This function is intended to be used with truncating map keys
     * Uses truncateKeyLength to truncate keys in a map to a certain limit.
     *
     * @param map to truncate keys
     * @param limit to truncate keys to
     * @param L logger
     * @param <T> type of map value
     */
    protected static <T> void truncateSegmentationKeys(@Nullable Map<String, T> map, final int limit, @NonNull ModuleLog L, @NonNull String tag) {
        assert limit >= 1;
        assert L != null;
        assert tag != null;
        if (map == null) {
            L.w(tag + ": [UtilsSdkInternalLimits] truncateMapKeys, map is null, returning");
            return;
        }
        if (map.isEmpty()) {
            L.w(tag + ": [UtilsSdkInternalLimits] truncateMapKeys, map is empty, returning");
            return;
        }
        assert map != null;
        L.w(tag + ": [UtilsSdkInternalLimits] truncateMapKeys, map:[" + map + "]");
        // Replacing keys in a map is not safe, so we create a new map and put them after
        Map<String, T> gonnaReplace = new ConcurrentHashMap<>();
        List<String> gonnaRemove = new ArrayList<>();
        for (Map.Entry<String, T> entry : map.entrySet()) {
            String truncatedKey = truncateKeyLength(entry.getKey(), limit, L, tag);
            if (!truncatedKey.equals(entry.getKey())) {
                // add truncated key
                gonnaReplace.put(truncatedKey, entry.getValue());
                // remove not truncated key
                gonnaRemove.add(entry.getKey());
            }
        }
        for (String key : gonnaRemove) {
            map.remove(key);
        }
        map.putAll(gonnaReplace);
    }
    protected static void truncateSegmentationKeysValues(@NonNull Map<String, Object> segmentation, @NonNull ConfigSdkInternalLimits limitsConfig, @NonNull ModuleLog L, @NonNull String tag) {
        assert segmentation != null;
        assert limitsConfig != null;
        assert L != null;
        assert tag != null;
        L.w(tag + ": [UtilsSdkInternalLimits] truncateMapKeys, segmentation:[" + segmentation + "]");
        // Replacing keys in a map is not safe, so we create a new map and put them after
        Iterator<Map.Entry<String, Object>> iterator = segmentation.entrySet().iterator();
        Map<String, Object> gonnaReplace = new ConcurrentHashMap<>();
        while (iterator.hasNext()) {
            Map.Entry<String, Object> entry = iterator.next();
            String truncatedKey = truncateKeyLength(entry.getKey(), limitsConfig.maxKeyLength, L, tag);
            Object value = entry.getValue();
            if (!isSupportedDataType(value)) {
                iterator.remove();
                continue;
            }
            if (value instanceof String) {
                value = truncateValueSize((String) value, limitsConfig.maxValueSize, L, tag);
            }
            if (!truncatedKey.equals(entry.getKey())) {
                iterator.remove(); // Removes the current entry from the original map
                gonnaReplace.put(truncatedKey, value); // Store the new entry to be replaced later
            } else if (value instanceof String && !value.equals(entry.getValue())) {
                segmentation.put(truncatedKey, value); // Update value directly
            }
        }
        segmentation.putAll(gonnaReplace);
    }
    /**
     * Removes unsupported data types and applies following internal limits to the provided segmentation map:
     * - max key length
     * - max value size
     * - max number of keys
     *
     * @param segmentation Map<String, Object> @Nullable - segmentation map to apply limits to
     * @param limitsConfig ConfigSdkInternalLimits @NonNull - limits configuration
     * @param L ModuleLog @NonNull - logger
     * @param tag String @NonNull - tag to use in logs
     */
    protected static void applySdkInternalLimitsToSegmentation(@NonNull Map<String, Object> segmentation, @NonNull ConfigSdkInternalLimits limitsConfig, @NonNull ModuleLog L, @NonNull String tag) {
        assert limitsConfig != null;
        assert L != null;
        assert tag != null;
        assert segmentation != null;
        if (segmentation.isEmpty()) {
            L.w(tag + ": [UtilsSdkInternalLimits] applySdkInternalLimitsToSegmentation, map is empty, returning");
            return;
        }
        truncateSegmentationKeysValues(segmentation, limitsConfig, L, tag);
        truncateSegmentationValues(segmentation, limitsConfig.maxSegmentationValues, tag, L);
    }
    /**
     * Applies the following internal limits to the provided breadcrumbs:
     * - max value size
     * - max number of breadcrumbs
     *
     * @param breadcrumbs List<String> @NonNull - breadcrumbs to apply limits to
     * @param limitsConfig ConfigSdkInternalLimits @NonNull - limits configuration
     * @param L ModuleLog @NonNull - logger
     * @param tag String @NonNull - tag to use in logs
     */
    static void applyInternalLimitsToBreadcrumbs(@NonNull List<String> breadcrumbs, @NonNull ConfigSdkInternalLimits limitsConfig, @NonNull ModuleLog L, @NonNull String tag) {
        assert breadcrumbs != null;
        assert limitsConfig != null;
        assert L != null;
        assert tag != null;
        if (breadcrumbs.isEmpty()) {
            L.w(tag + ": [UtilsSdkInternalLimits] applyInternalLimitsToBreadcrumbs, breadcrumbs is empty, returning");
            return;
        }
        Iterator<String> iterator = breadcrumbs.iterator();
        while (iterator.hasNext()) {
            if (breadcrumbs.size() > limitsConfig.maxBreadcrumbCount) {
                String breadcrumb = iterator.next();
                L.w(tag + ": [UtilsSdkInternalLimits] applyInternalLimitsToBreadcrumbs, breadcrumb:[" + breadcrumb + "]");
                iterator.remove();
            } else {
                break;
            }
        }
        for (int i = 0; i < breadcrumbs.size(); i++) {
            String breadcrumb = breadcrumbs.get(i);
            String truncatedBreadcrumb = truncateValueSize(breadcrumb, limitsConfig.maxValueSize, L, tag);
            if (!truncatedBreadcrumb.equals(breadcrumb)) {
                breadcrumbs.set(i, truncatedBreadcrumb);
            }
        }
    }
    /**
     * Checks and transforms the provided Object if it does not
     * comply with the key count limit.
     *
     * @param maxCount Int @NonNull - max number of keys allowed
     * @param L ModuleLog @NonNull - Logger function
     * @param messagePrefix String @NonNull - name of the module this function was called
     * @param segmentation Map<String, Object> @Nullable- segmentation that will be checked
     */
    static <T> void truncateSegmentationValues(@NonNull final Map<String, T> segmentation, final int maxCount, @NonNull final String messagePrefix, final @NonNull ModuleLog L) {
        assert segmentation != null;
        assert maxCount >= 1;
        assert L != null;
        assert messagePrefix != null;
        Iterator<Map.Entry<String, T>> iterator = segmentation.entrySet().iterator();
        while (iterator.hasNext()) {
            if (segmentation.size() > maxCount) {
                Map.Entry<String, T> value = iterator.next();
                String key = value.getKey();
                L.w(messagePrefix + ", Value exceeded the maximum segmentation count key:[" + key + "]");
                iterator.remove();
            } else {
                break;
            }
        }
    }
    /**
     * Used to remove reserved keys from segmentation map
     *
     * @param segmentation
     * @param reservedKeys
     * @param messagePrefix
     * @param L
     */
    static void removeReservedKeysFromSegmentation(@NonNull Map<String, Object> segmentation, @NonNull String[] reservedKeys, @NonNull String messagePrefix, @NonNull ModuleLog L) {
        assert segmentation != null;
        assert reservedKeys != null;
        assert L != null;
        assert messagePrefix != null;
        for (String rKey : reservedKeys) {
            if (segmentation.containsKey(rKey)) {
                L.w(messagePrefix + " provided segmentation contains protected key [" + rKey + "]");
                segmentation.remove(rKey);
            }
        }
    }
    /**
     * Removes unsupported data types
     *
     * @param data
     * @return returns true if any entry had been removed
     */
    static boolean removeUnsupportedDataTypes(@NonNull Map<String, Object> data, @NonNull ModuleLog L) {
        assert data != null;
        StringBuilder removedKeys = new StringBuilder();
        Map<String, Object> gonnaReplace = new ConcurrentHashMap<>();
        for (Iterator<Map.Entry<String, Object>> it = data.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry<String, Object> entry = it.next();
            String key = entry.getKey();
            Object value = entry.getValue();
            if (key == null || key.isEmpty() || !(isSupportedDataType(value))) {
                //found unsupported data type or null key or value, removing
                it.remove();
                removedKeys.append("key:[").append(key).append("] value:[").append(value).append("] type:[").append(value == null ? "null" : value.getClass().getSimpleName()).append("] ,");
            } else if (value instanceof List) {
                List<?> list = (List<?>) value;
                list = new ArrayList<>(list);
                int a = list.size();
                for (int i = 0; i < a; i++) {
                    Object element = list.get(i);
                    if (!isSupportedDataTypeBasic(element)) {
                        removedKeys.append("from_list").append(list).append("index:[").append(i).append("] value:[").append(element).append("] type:[").append(element == null ? "null" : element.getClass().getSimpleName()).append("] ,");
                        list.remove(i);
                        i--;
                        a--;
                    }
                }
                gonnaReplace.put(key, list);
            } else if (value instanceof JSONArray) {
                JSONArray jsonArray = (JSONArray) value;
                int a = jsonArray.length();
                for (int i = 0; i < a; i++) {
                    Object element = jsonArray.opt(i);
                    if (!isSupportedDataTypeBasic(element)) {
                        removedKeys.append("from_list").append(jsonArray).append("index:[").append(i).append("] value:[").append(element).append("] type:[").append(element == null ? "null" : element.getClass().getSimpleName()).append("] ,");
                        jsonArray.remove(i);
                        i--;
                        a--;
                    }
                }
                gonnaReplace.put(key, jsonArray);
            }
        }
        String removedKeysStr = removedKeys.toString();
        data.putAll(gonnaReplace);
        if (!removedKeysStr.isEmpty()) {
            L.w("[UtilsInternalLimits] removeUnsupportedDataTypes, removed " + removedKeysStr + " from the provided data map.");
        }
        return !removedKeysStr.isEmpty();
    }
    /**
     * Truncates the provided stack trace to the specified limit per line and returns the truncated stack trace.
     *
     * @param stackTrace the stack trace to truncate
     * @param maxStackTraceLineLength the maximum length of each line in the stack trace
     * @param tag the tag to use in logs
     * @param L the logger
     * @return the truncated stack trace
     */
    protected static String applyInternalLimitsToStackTraces(@NonNull String stackTrace, final int maxStackTraceLineLength, @NonNull String tag, @NonNull ModuleLog L) {
        assert stackTrace != null;
        assert maxStackTraceLineLength >= 1;
        assert tag != null;
        assert L != null;
        StringBuilder sb = new StringBuilder(stackTrace.length());
        String[] stackTraceLines = stackTrace.split("\n");
        for (int i = 0; i < stackTraceLines.length; i++) {
            String truncatedLine = UtilsInternalLimits.truncateString(stackTraceLines[i], maxStackTraceLineLength, L, tag);
            if (i != 0) {
                sb.append('\n');
            }
            sb.append(truncatedLine);
        }
        return sb.toString();
    }
    private static boolean isSupportedDataTypeBasic(@Nullable Object value) {
        return value instanceof String || value instanceof Integer || value instanceof Double || value instanceof Boolean || value instanceof Float || value instanceof Long;
    }
    /**
     * This function currently validates below segmentations:
     * - Event segmentations (custom ones not internal keys)
     * - Crash segmentations
     * - View segmentations
     * - User profile custom properties
     * - User profile custom properties modifiers
     * - Feedback widgets' results
     * This function also removes unsupported data types inside the collections
     *
     * @param value to check
     * @return true if the value is a supported data type
     */
    static boolean isSupportedDataType(@Nullable Object value) {
        if (isSupportedDataTypeBasic(value)) {
            return true;
        } else if (value instanceof List || value instanceof JSONArray) {
            return true;
        } else if (value != null && value.getClass().isArray()) {
            Class<?> componentType = value.getClass().getComponentType();
            return componentType == String.class || componentType == Integer.class || componentType == Double.class || componentType == Boolean.class || componentType == Float.class || componentType == Long.class
                || componentType == int.class || componentType == double.class || componentType == boolean.class || componentType == float.class || componentType == long.class;
        }
        return false;
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.mockito.internal.util.collections.Sets;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
@RunWith(AndroidJUnit4.class)
public class ModuleFeedbackTests {
    Countly mCountly;
    @Before
    public void setUp() {
        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
        mCountly = new Countly();
        mCountly.init(new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting());
    }
    @After
    public void tearDown() {
    }
    @Test
    public void parseFeedbackList_null() throws JSONException {
        List<ModuleFeedback.CountlyFeedbackWidget> ret = ModuleFeedback.parseFeedbackList(null);
        Assert.assertNotNull(ret);
        Assert.assertEquals(0, ret.size());
    }
    @Test
    public void parseFeedbackList_oneGoodWithGarbage() throws JSONException {
        String requestJson =
            "{\"result\":[{\"_id\":\"asd\",\"type\":\"qwe\",\"name\":\"zxc\",\"tg\":[]},{\"_id\":\"5f97284635935cc338e78200\",\"type\":\"nps\",\"name\":\"fsdfsdf\",\"tg\":[\"/\"]},{\"g4id\":\"asd1\",\"t4type\":\"432\",\"nagdfgme\":\"zxct\",\"tgm\":[\"/\"]}]}";
        JSONObject jObj = new JSONObject(requestJson);
        List<ModuleFeedback.CountlyFeedbackWidget> ret = ModuleFeedback.parseFeedbackList(jObj);
        Assert.assertNotNull(ret);
        Assert.assertEquals(1, ret.size());
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "fsdfsdf", "5f97284635935cc338e78200", new String[] { "/" }, ret.get(0));
    }
    @Test
    public void parseFeedbackList() throws JSONException {
        String requestJson =
            "{\"result\":[{\"_id\":\"5f8c6f959627f99e8e7de746\",\"type\":\"survey\",\"exitPolicy\":\"onAbandon\",\"appearance\":{\"show\":\"uSubmit\",\"position\":\"bLeft\",\"color\":\"#2eb52b\"},\"name\":\"sdfsdfdsf\",\"tg\":[\"/\"]},{\"_id\":\"5f8c6fd81ac8659e8846acf4\",\"type\":\"nps\",\"name\":\"fdsfsd\",\"tg\":[\"a\",\"0\"]},{\"_id\":\"5f97284635935cc338e78200\",\"type\":\"nps\",\"name\":\"fsdfsdf\",\"tg\":[]},{\"_id\":\"614871419f030e44be07d82f\",\"type\":\"rating\",\"appearance\":{\"position\":\"mleft\",\"bg_color\":\"#fff\",\"text_color\":\"#ddd\",\"text\":\"Feedback\"},\"tg\":[\"\\/\"],\"name\":\"ratingName1\"}]}";
        JSONObject jObj = new JSONObject(requestJson);
        List<ModuleFeedback.CountlyFeedbackWidget> ret = ModuleFeedback.parseFeedbackList(jObj);
        Assert.assertNotNull(ret);
        Assert.assertEquals(4, ret.size());
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey, "sdfsdfdsf", "5f8c6f959627f99e8e7de746", new String[] { "/" }, ret.get(0));
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "fdsfsd", "5f8c6fd81ac8659e8846acf4", new String[] { "a", "0" }, ret.get(1));
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "fsdfsdf", "5f97284635935cc338e78200", new String[] {}, ret.get(2));
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating, "ratingName1", "614871419f030e44be07d82f", new String[] { "/" }, ret.get(3));
    }
    @Test
    public void parseFaultyFeedbackList() throws JSONException {
        // 9 widgets (3 from each)
        // First variation => no 'tg' key
        // Second variation => no 'name' key
        // First variation => no '_id' key
        String requestJson =
            "{\"result\":["
                + "{\"_id\":\"survID1\",\"type\":\"survey\",\"exitPolicy\":\"onAbandon\",\"appearance\":{\"show\":\"uSubmit\",\"position\":\"bLeft\",\"color\":\"#2eb52b\"},\"name\":\"surv1\"},"
                + "{\"_id\":\"survID2\",\"type\":\"survey\",\"exitPolicy\":\"onAbandon\",\"appearance\":{\"show\":\"uSubmit\",\"position\":\"bLeft\",\"color\":\"#2eb52b\"},\"tg\":[\"/\"]},"
                + "{\"type\":\"survey\",\"exitPolicy\":\"onAbandon\",\"appearance\":{\"show\":\"uSubmit\",\"position\":\"bLeft\",\"color\":\"#2eb52b\"},\"name\":\"surv3\",\"tg\":[\"/\"]},"
                + "{\"_id\":\"npsID1\",\"type\":\"nps\",\"name\":\"nps1\"},"
                + "{\"_id\":\"npsID2\",\"type\":\"nps\",\"tg\":[]},"
                + "{\"type\":\"nps\",\"name\":\"nps3\",\"tg\":[]},"
                + "{\"_id\":\"ratingID1\",\"type\":\"rating\",\"appearance\":{\"position\":\"mleft\",\"bg_color\":\"#fff\",\"text_color\":\"#ddd\",\"text\":\"Feedback\"},\"name\":\"rating1\"},"
                + "{\"_id\":\"ratingID2\",\"type\":\"rating\",\"appearance\":{\"position\":\"mleft\",\"bg_color\":\"#fff\",\"text_color\":\"#ddd\",\"text\":\"Feedback\"},\"tg\":[\"\\/\"]},"
                + "{\"type\":\"rating\",\"appearance\":{\"position\":\"mleft\",\"bg_color\":\"#fff\",\"text_color\":\"#ddd\",\"text\":\"Feedback\"},\"tg\":[\"\\/\"],\"name\":\"rating3\"}"
                + "]}";
        JSONObject jObj = new JSONObject(requestJson);
        List<ModuleFeedback.CountlyFeedbackWidget> ret = ModuleFeedback.parseFeedbackList(jObj);
        Assert.assertNotNull(ret);
        Assert.assertEquals(6, ret.size());
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey, "surv1", "survID1", new String[] {}, ret.get(0));
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey, "", "survID2", new String[] { "/" }, ret.get(1));
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "nps1", "npsID1", new String[] {}, ret.get(2));
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps, "", "npsID2", new String[] {}, ret.get(3));
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating, "rating1", "ratingID1", new String[] {}, ret.get(4));
        ValidateReturnedFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating, "", "ratingID2", new String[] { "/" }, ret.get(5));
    }
    void ValidateReturnedFeedbackWidget(@NonNull ModuleFeedback.FeedbackWidgetType type, @NonNull String wName, @NonNull String wId, @NonNull String[] wTags, @NonNull ModuleFeedback.CountlyFeedbackWidget fWidget) {
        Assert.assertEquals(type, fWidget.type);
        Assert.assertEquals(wName, fWidget.name);
        Assert.assertEquals(wId, fWidget.widgetId);
        Assert.assertArrayEquals(wTags, fWidget.tags);
    }
    @Test
    public void reportFeedbackWidgetManuallyNPSReported() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.nps;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        final Map<String, Object> segmRes = new HashMap<>();
        segmRes.put("rating", 4);
        segmRes.put("comment", "123456");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        final Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", "1.0");
        segm.put("widget_id", widgetInfo.widgetId);
        segm.put("rating", 4);
        segm.put("comment", "123456");
        verify(ep).recordEventInternal(ModuleFeedback.NPS_EVENT_KEY, segm, 1, 0, 0, null, null);
        //report without a "null" comment
        mCountly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);
        segmRes.put("rating", 10);
        segmRes.put("comment", null);
        segm.put("rating", 10);
        segm.remove("comment");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep).recordEventInternal(ModuleFeedback.NPS_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    @Test
    public void reportFeedbackWidgetManuallyRatingReported() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.rating;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        final Map<String, Object> segmRes = new HashMap<>();
        segmRes.put("rating", 4);
        segmRes.put("comment", "123456");
        segmRes.put("email", "123456");
        segmRes.put("contactMe", true);
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        final Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", "1.0");
        segm.put("widget_id", widgetInfo.widgetId);
        segm.put("rating", 4);
        segm.put("comment", "123456");
        segm.put("email", "123456");
        segm.put("contactMe", true);
        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
        //report without a "null" comment
        mCountly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);
        segmRes.put("rating", 2);
        segmRes.put("comment", null);
        segm.put("rating", 2);
        segm.remove("comment");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    @Test
    public void reportFeedbackWidgetManuallyNPSClosed() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.nps;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, null);
        final Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", "1.0");
        segm.put("widget_id", widgetInfo.widgetId);
        segm.put("closed", "1");
        verify(ep).recordEventInternal(ModuleFeedback.NPS_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    @Test
    public void reportFeedbackWidgetManuallyRatingClosed() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.rating;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, null);
        final Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", "1.0");
        segm.put("widget_id", widgetInfo.widgetId);
        segm.put("closed", "1");
        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    @Test
    public void reportFeedbackWidgetManuallyNPSBadResult_1() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.nps;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        final Map<String, Object> segmRes = new HashMap<>();
        //just an empty result map
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        //result map with unrelated fields
        JSONObject emptyJObj = new JSONObject();
        segmRes.put("bla", "gg");
        segmRes.put("11", null);
        segmRes.put(null, "gf");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
    }
    @Test
    public void reportFeedbackWidgetManuallyRatingBadResult_1() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.rating;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        final Map<String, Object> segmRes = new HashMap<>();
        //just an empty result map
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        //result map with unrelated fields
        JSONObject emptyJObj = new JSONObject();
        segmRes.put("bla", "gg");
        segmRes.put("11", null);
        segmRes.put(null, "gf");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
    }
    @Test
    public void reportFeedbackWidgetManuallyNPSBadResult_2() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.nps;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        final Map<String, Object> segmRes = new HashMap<>();
        //result map with unrelated fields
        segmRes.put("rating", "gg");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", null);
        segmRes.put("comment", "123456");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "5.5");
        JSONObject emptyJObj = new JSONObject();
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "6.0");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "0.0");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "10.0f");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
    }
    @Test
    public void reportFeedbackWidgetManuallyRatingBadResult_2() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = ModuleFeedback.FeedbackWidgetType.rating;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        final Map<String, Object> segmRes = new HashMap<>();
        //result map with unrelated fields
        segmRes.put("rating", "gg");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", null);
        segmRes.put("comment", "123456");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "5.5");
        JSONObject emptyJObj = new JSONObject();
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "6.0");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "0.0");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        segmRes.put("rating", "10.0f");
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, emptyJObj, segmRes);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
    }
    @Test
    public void reportFeedbackWidgetManuallySurveyClosed() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey);
        mCountly.feedback().reportFeedbackWidgetManually(widgetInfo, null, null);
        final Map<String, Object> segm = TestUtils.map("closed", "1");
        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);
        verify(ep).recordEventInternal(ModuleFeedback.SURVEY_EVENT_KEY, segm, 1, 0, 0, null, null);
    }
    /**
     * Test that the internal limit for key length is working
     * And validate while reporting a survey widget manually, key and segmentation is not truncated
     */
    @Test
    public void internalLimit_reportFeedbackWidgetManuallySurvey() throws JSONException {
        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true);
        config.sdkInternalLimits.setMaxKeyLength(2);
        Countly countly = new Countly().init(config);
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("key1", "value1", "key2", "value2", "key3", "value3"));
        final Map<String, Object> segm = TestUtils.map("key1", "value1", "key2", "value2", "key3", "value3");
        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, segm, 0);
    }
    /**
     * Test that the internal limit for key length is working
     * And validate while reporting a rating widget manually, key and segmentation is not truncated
     */
    @Test
    public void internalLimit_reportFeedbackWidgetManuallyRating() throws JSONException {
        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true);
        config.sdkInternalLimits.setMaxKeyLength(2);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("rating", 10));
        final Map<String, Object> segm = TestUtils.map("rating", 10);
        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, segm, 0);
    }
    /**
     * Test that the internal limit for key length is working
     * And validate while reporting a nps widget manually, key and segmentation is not truncated
     */
    @Test
    public void internalLimit_reportFeedbackWidgetManuallyNPS() throws JSONException {
        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true);
        config.sdkInternalLimits.setMaxKeyLength(2);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("rating", 10, "comment", "huhu"));
        final Map<String, Object> segm = TestUtils.map("rating", 10, "comment", "huhu");
        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, segm, 0);
    }
    /**
     * Value size limit is applied to the all string values of widget results
     * And validate while reporting a survey widget manually, value is truncated to the limit
     * And unsupported types are removed
     * All types of feedback widgets are tested NPS, RATING, SURVEY
     */
    @Test
    public void internalLimit_reportFeedbackWidgetManually_setMaxValueSize() throws JSONException {
        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true);
        config.sdkInternalLimits.setMaxValueSize(2);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        //NPS
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("rating", 10, "comment", "huhu", "extras", "sure_go_on", "map", TestUtils.map("key1", "value1", "key2", "value2"), "omg", Double.MAX_VALUE));
        Map<String, Object> segm = TestUtils.map("rating", 10, "comment", "hu", "extras", "su", "omg", Double.MAX_VALUE);
        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, segm, 0);
        //RATING
        widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.rating);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("rating", 10, "comment", "zoomzoom", "map", TestUtils.map("key1", "value1", "key2", "value2"), "omg", Double.MIN_VALUE));
        segm = TestUtils.map("rating", 10, "comment", "zo", "omg", Double.MIN_VALUE);
        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, segm, 1);
        //SURVEY
        widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.survey);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, TestUtils.map("key1", "value1", "key2", "value2", "key3", "value3", "map", TestUtils.map("key1", "value1", "key2", "value2"), "int", Integer.MAX_VALUE));
        segm = TestUtils.map("key1", "va", "key2", "va", "key3", "va", "int", Integer.MAX_VALUE);
        fillFeedbackWidgetSegmentationParams(segm, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, segm, 2);
    }
    /**
     * "reportFeedbackWidgetManually" with Array segmentations
     * Validate that all primitive types arrays are successfully recorded
     * And validate that Object arrays are not recorded
     * But Generic type of Object array which its values are only primitive types are recorded
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void reportFeedbackWidgetManually_validateSupportedArrays() throws JSONException {
        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        boolean[] arrB = { true, false, true, false, true, false, true, false, true, false };
        String[] arrS = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
        long[] arrL = { Long.MAX_VALUE, Long.MIN_VALUE };
        double[] arrD = { Double.MAX_VALUE, Double.MIN_VALUE };
        Long[] arrLO = { Long.MAX_VALUE, Long.MIN_VALUE };
        Double[] arrDO = { Double.MAX_VALUE, Double.MIN_VALUE };
        Boolean[] arrBO = { Boolean.TRUE, Boolean.FALSE };
        Integer[] arrIO = { Integer.MAX_VALUE, Integer.MIN_VALUE };
        Object[] arrObj = { "1", 1, 1.1d, true, 1.1f, Long.MAX_VALUE };
        Object[] arrObjStr = { "1", "1", "1.1d", "true", "1.1f", "Long.MAX_VALUE" };
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        Map<String, Object> segmentation = TestUtils.map(
            "arr", arr,
            "arrB", arrB,
            "arrS", arrS,
            "arrL", arrL,
            "arrD", arrD,
            "arrLO", arrLO,
            "arrDO", arrDO,
            "arrBO", arrBO,
            "arrIO", arrIO,
            "arrObj", arrObj,
            "arrObjStr", arrObjStr, "rating", 10, "comment", "huhu"
        );
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmentation);
        Map<String, Object> expectedSegmentation = TestUtils.map(
            "arr", new JSONArray(arr),
            "arrB", new JSONArray(arrB),
            "arrS", new JSONArray(arrS),
            "arrL", new JSONArray(arrL),
            "arrD", new JSONArray(arrD),
            "arrLO", new JSONArray(arrLO),
            "arrDO", new JSONArray(arrDO),
            "arrBO", new JSONArray(arrBO),
            "arrIO", new JSONArray(arrIO), "rating", 10, "comment", "huhu"
        );
        fillFeedbackWidgetSegmentationParams(expectedSegmentation, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, expectedSegmentation, 0);
    }
    /**
     * "reportFeedbackWidgetManually" with List segmentations
     * Validate that all primitive types Lists are successfully recorded
     * And validate that List of Objects is not recorded
     * But Generic type of Object list which its values are only primitive types are recorded
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void reportFeedbackWidgetManually_validateSupportedLists() throws JSONException {
        List<Integer> arr = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<Boolean> arrB = Arrays.asList(true, false, true, false, true, false, true, false, true, false);
        List<String> arrS = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10");
        List<Long> arrLO = Arrays.asList(Long.MAX_VALUE, Long.MIN_VALUE);
        List<Double> arrDO = Arrays.asList(Double.MAX_VALUE, Double.MIN_VALUE);
        List<Boolean> arrBO = Arrays.asList(Boolean.TRUE, Boolean.FALSE);
        List<Integer> arrIO = Arrays.asList(Integer.MAX_VALUE, Integer.MIN_VALUE);
        List<Object> arrObj = Arrays.asList("1", 1, 1.1d, true, Long.MAX_VALUE);
        List<Object> arrObjStr = Arrays.asList("1", "1", "1.1d", "true", "Long.MAX_VALUE");
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        // Create segmentation using maps with lists
        Map<String, Object> segmentation = TestUtils.map(
            "arr", arr,
            "arrB", arrB,
            "arrS", arrS,
            "arrLO", arrLO,
            "arrDO", arrDO,
            "arrBO", arrBO,
            "arrIO", arrIO,
            "arrObj", arrObj,
            "arrObjStr", arrObjStr, "rating", 10, "comment", "huhu"
        );
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmentation);
        Map<String, Object> expectedSegmentation = TestUtils.map(
            "arr", new JSONArray(arr),
            "arrB", new JSONArray(arrB),
            "arrS", new JSONArray(arrS),
            "arrLO", new JSONArray(arrLO),
            "arrDO", new JSONArray(arrDO),
            "arrBO", new JSONArray(arrBO),
            "arrIO", new JSONArray(arrIO),
            "arrObj", new JSONArray(arrObj),
            "arrObjStr", new JSONArray(arrObjStr), "rating", 10, "comment", "huhu"
        );
        fillFeedbackWidgetSegmentationParams(expectedSegmentation, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, expectedSegmentation, 0);
    }
    /**
     * "reportFeedbackWidgetManually" with JSONArray segmentations
     * Validate that all primitive types JSONArrays are successfully recorded
     * And validate and JSONArray of Objects is not recorded
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void reportFeedbackWidgetManually_validateSupportedJSONArrays() throws JSONException {
        JSONArray arr = new JSONArray(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        JSONArray arrB = new JSONArray(Arrays.asList(true, false, true, false, true, false, true, false, true, false));
        JSONArray arrS = new JSONArray(Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10"));
        JSONArray arrL = new JSONArray(Arrays.asList(Long.MAX_VALUE, Long.MIN_VALUE));
        JSONArray arrD = new JSONArray(Arrays.asList(Double.MAX_VALUE, Double.MIN_VALUE));
        JSONArray arrBO = new JSONArray(Arrays.asList(Boolean.TRUE, Boolean.FALSE));
        JSONArray arrIO = new JSONArray(Arrays.asList(Integer.MAX_VALUE, Integer.MIN_VALUE));
        JSONArray arrObj = new JSONArray(Arrays.asList("1", 1, 1.1d, true, Long.MAX_VALUE));
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        // Create segmentation using maps with lists
        Map<String, Object> segmentation = TestUtils.map(
            "arr", arr,
            "arrB", arrB,
            "arrS", arrS,
            "arrL", arrL,
            "arrD", arrD,
            "arrBO", arrBO,
            "arrIO", arrIO,
            "arrObj", arrObj, "rating", 10, "comment", "huhu"
        );
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmentation);
        // Prepare expected segmentation with JSONArrays
        Map<String, Object> expectedSegmentation = TestUtils.map(
            "arr", arr,
            "arrB", arrB,
            "arrS", arrS,
            "arrL", arrL,
            "arrD", arrD,
            "arrBO", arrBO,
            "arrIO", arrIO, "rating", 10, "comment", "huhu",
            "arrObj", arrObj
        );
        fillFeedbackWidgetSegmentationParams(expectedSegmentation, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, expectedSegmentation, 0);
    }
    /**
     * "reportFeedbackWidgetManually" with invalid data types
     * Validate that unsupported data types are not recorded
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void reportFeedbackWidgetManually_unsupportedDataTypesSegmentation() throws JSONException {
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        Map<String, Object> segmentation = TestUtils.map(
            "a", TestUtils.map(),
            "b", TestUtils.json(),
            "c", new Object(),
            "d", Sets.newSet(),
            "e", Mockito.mock(ModuleLog.class), "rating", 10, "comment", "huhu"
        );
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = createFeedbackWidget(ModuleFeedback.FeedbackWidgetType.nps);
        countly.feedback().reportFeedbackWidgetManually(widgetInfo, null, segmentation);
        Map<String, Object> expectedSegmentation = TestUtils.map("rating", 10, "comment", "huhu");
        fillFeedbackWidgetSegmentationParams(expectedSegmentation, widgetInfo.widgetId);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, expectedSegmentation, 0);
    }
    private ModuleFeedback.CountlyFeedbackWidget createFeedbackWidget(ModuleFeedback.FeedbackWidgetType type) {
        ModuleFeedback.CountlyFeedbackWidget widgetInfo = new ModuleFeedback.CountlyFeedbackWidget();
        widgetInfo.type = type;
        widgetInfo.widgetId = "1234";
        widgetInfo.name = "someName";
        return widgetInfo;
    }
    private void fillFeedbackWidgetSegmentationParams(Map<String, Object> segmentation, String widgetId) {
        segmentation.put("platform", "android");
        segmentation.put("app_version", "1.0");
        segmentation.put("widget_id", widgetId);
    }
}
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;
import ly.count.android.sdk.messaging.ModulePush;
public class ModuleEvents extends ModuleBase implements EventProvider {
    static final Map<String, Event> timedEvents = new HashMap<>();
    final static String ACTION_EVENT_KEY = "[CLY]_action";
    final static String VISIBILITY_KEY = "cly_v";
    final static String PREVIOUS_EVENT_NAME_KEY = "cly_pen";
    final static String PREVIOUS_VIEW_NAME_KEY = "cly_pvn";
    final static String CURRENT_VIEW_NAME_KEY = "cly_cvn";
    //interface for SDK users
    final Events eventsInterface;
    //used for tracking recorded custom event ID's. This is not updated when internal events are recorded
    String previousEventId = "";
    String previousEventName = "";
    EventQueueProvider eventQueueProvider;
    ViewIdProvider viewIdProvider;
    SafeIDGenerator safeEventIDGenerator;
    private final boolean viewNameRecordingEnabled;
    private final boolean visibilityTracking;
    ModuleEvents(Countly cly, CountlyConfig config) {
        super(cly, config);
        L.v("[ModuleEvents] Initialising");
        eventProvider = this;
        config.eventProvider = this;
        eventQueueProvider = config.eventQueueProvider;
        safeEventIDGenerator = config.safeEventIDGenerator;
        viewNameRecordingEnabled = config.experimental.viewNameRecordingEnabled;
        visibilityTracking = config.experimental.visibilityTrackingEnabled;
        eventsInterface = new Events();
    }
    void checkCachedPushData(CountlyStore cs) {
        L.d("[ModuleEvents] Starting cache call");
        String[] cachedData = cs.getCachedPushData();
        if (cachedData != null && cachedData[0] != null && cachedData[1] != null) {
            //found valid data cached, record it
            L.d("[ModuleEvents] Found cached push event, recording it");
            Map<String, Object> map = new HashMap<>();
            map.put(ModulePush.PUSH_EVENT_ACTION_PLATFORM_KEY, ModulePush.PUSH_EVENT_ACTION_PLATFORM_VALUE);
            map.put(ModulePush.PUSH_EVENT_ACTION_ID_KEY, cachedData[0]);
            map.put(ModulePush.PUSH_EVENT_ACTION_INDEX_KEY, cachedData[1]);
            recordEventInternal(ModulePush.PUSH_EVENT_ACTION, map, 1, 0, 0, null, null);
        }
        if (cachedData != null && (cachedData[0] != null || cachedData[1] != null)) {
            //if something was recorded, clear it
            cs.clearCachedPushData();
        }
    }
    /**
     * @param key
     * @param segmentation
     * @param count
     * @param sum
     * @param dur
     * @param instant
     * @param eventIdOverride
     */
    public void recordEventInternal(@Nullable final String key, @Nullable Map<String, Object> segmentation, int count, final double sum, final double dur, UtilsTime.Instant instant, final String eventIdOverride) {
        //assert key != null;
        assert count >= 1;
        assert _cly.isInitialized();
        long pccTsStartRecordEventInternal = 0L;
        if (pcc != null) {
            pccTsStartRecordEventInternal = UtilsTime.getNanoTime();
        }
        L.v("[ModuleEvents] calling 'recordEventInternal'");
        if (key == null || key.length() == 0) {
            L.e("[ModuleEvents] recordEventInternal, Valid Countly event key is required. Event will be ignored.");
            return;
        }
        if (count < 1) {
            L.e("[ModuleEvents] recordEventInternal, event count should be greater than zero. Key:[" + key + "] count:[" + count + "]");
            count = 1;
        }
        L.d("[ModuleEvents] recordEventInternal, key:[" + key + "] eventIdOverride:[" + eventIdOverride + "] segmentation:[" + segmentation + "] count:[" + count + "] sum:[" + sum + "] dur:[" + dur + "] instant:[" + instant + "]");
        if (segmentation != null) {
            UtilsInternalLimits.removeUnsupportedDataTypes(segmentation, L);
        }
        //record the current event timestamps
        //if a past event is recorded, instant value will not be null
        if (instant == null) {
            instant = UtilsTime.getCurrentInstant();
        }
        String eventId;
        if (eventIdOverride == null) { // if eventIdOverride not provided generate an event ID
            eventId = safeEventIDGenerator.GenerateValue();
        } else if (eventIdOverride.length() == 0) {
            L.w("[ModuleEvents] provided event ID override value is empty. Will generate a new one.");
            eventId = safeEventIDGenerator.GenerateValue();
        } else { // if eventIdOverride is provided use it the event ID
            eventId = eventIdOverride;
        }
        final long timestamp = instant.timestampMs;
        final int hour = instant.hour;
        final int dow = instant.dow;
        String pvid = null; // Previous View ID
        String cvid = null; // Current View ID
        String pvn = null;
        String pen = null;
        String cvn = null;
        if (key.equals(ModuleViews.VIEW_EVENT_KEY)) {
            pvid = viewIdProvider.getPreviousViewId();
            if (viewNameRecordingEnabled) {
                pvn = _cly.moduleViews.previousViewName;
                if (pvn == null) {
                    pvn = "";
                }
            }
        } else {
            cvid = viewIdProvider.getCurrentViewId();
            if (viewNameRecordingEnabled) {
                pen = previousEventName;
                cvn = _cly.moduleViews.currentViewName;
                if (pen == null) {
                    pen = "";
                }
                if (cvn == null) {
                    cvn = "";
                }
            }
        }
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ModuleEvents_recordEventInternalGenID", UtilsTime.getNanoTime() - pccTsStartRecordEventInternal);
        }
        //before each event is recorded, check if user profile data needs to be saved
        _cly.moduleUserProfile.saveInternal();
        if (visibilityTracking) {
            if (segmentation == null) {
                segmentation = new HashMap<>();
            }
            if (ModuleViews.VIEW_EVENT_KEY.equals(key) && !segmentation.containsKey("visit")) {
                L.d("[ModuleEvents] recordEventInternal, visibility key will not be added to the end view event");
            } else {
                String appInBackground = deviceInfo.isInBackground();
                int state = 1; // in foreground
                if ("true".equals(appInBackground)) {
                    state = 0; // in background
                }
                L.d("[ModuleEvents] recordEventInternal, Adding visibility tracking to segmentation app in background:[" + appInBackground + "] cly_v:[" + state + "]");
                segmentation.put(VISIBILITY_KEY, state);
            }
        }
        switch (key) {
            case ModuleFeedback.NPS_EVENT_KEY:
            case ModuleFeedback.SURVEY_EVENT_KEY:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(true);
                }
                break;
            case ModuleFeedback.RATING_EVENT_KEY: //these events can be reported from a lot of sources, therefore multiple consents could apply
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.starRating) || consentProvider.getConsent(Countly.CountlyFeatureNames.feedback)) {
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
            case ModuleViews.VIEW_EVENT_KEY:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.views)) {
                    if (segmentation == null) {
                        segmentation = new HashMap<>();
                    }
                    if (viewNameRecordingEnabled) {
                        segmentation.put(PREVIOUS_VIEW_NAME_KEY, pvn);
                    }
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
            case ModuleViews.ORIENTATION_EVENT_KEY:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.users)) {
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
            case ModulePush.PUSH_EVENT_ACTION:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.push)) {
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(true);
                }
                break;
            case ACTION_EVENT_KEY:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.clicks) || consentProvider.getConsent(Countly.CountlyFeatureNames.scrolls)) {
                    if (segmentation != null) {
                        UtilsInternalLimits.removeUnsupportedDataTypes(segmentation, L);
                    }
                    eventQueueProvider.recordEventToEventQueue(key, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, null);
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
            default:
                if (consentProvider.getConsent(Countly.CountlyFeatureNames.events)) {
                    String keyTruncated = UtilsInternalLimits.truncateKeyLength(key, _cly.config_.sdkInternalLimits.maxKeyLength, L, "[ModuleEvents] recordEventInternal");
                    if (segmentation == null) {
                        segmentation = new HashMap<>();
                    }
                    UtilsInternalLimits.applySdkInternalLimitsToSegmentation(segmentation, _cly.config_.sdkInternalLimits, L, "[ModuleEvents] recordEventInternal");
                    if (viewNameRecordingEnabled) {
                        segmentation.put(CURRENT_VIEW_NAME_KEY, cvn);
                        segmentation.put(PREVIOUS_EVENT_NAME_KEY, pen);
                    }
                    eventQueueProvider.recordEventToEventQueue(keyTruncated, segmentation, count, sum, dur, timestamp, hour, dow, eventId, pvid, cvid, previousEventId);
                    previousEventId = eventId;
                    previousEventName = keyTruncated;
                    _cly.moduleRequestQueue.sendEventsIfNeeded(false);
                }
                break;
        }
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ModuleEvents_recordEventInternal", UtilsTime.getNanoTime() - pccTsStartRecordEventInternal);
        }
    }
    boolean startEventInternal(final String key) {
        if (key == null || key.length() == 0) {
            L.e("[ModuleEvents] Can't start event with a null or empty key");
            return false;
        }
        if (timedEvents.containsKey(key)) {
            return false;
        }
        L.d("[ModuleEvents] Starting event: [" + key + "]");
        UtilsTime.Instant instant = UtilsTime.getCurrentInstant();
        timedEvents.put(key, new Event(key, instant.timestampMs, instant.hour, instant.dow));
        return true;
    }
    boolean endEventInternal(@Nullable final String key, @Nullable final Map<String, Object> segmentation, int count, final double sum) {
        L.d("[ModuleEvents] Ending event: [" + key + "]");
        if (key == null || key.length() == 0) {
            L.e("[ModuleEvents] Can't end event with a null or empty key");
            return false;
        }
        Event event = timedEvents.remove(key);
        if (event != null) {
            if (!consentProvider.getConsent(Countly.CountlyFeatureNames.events)) {
                return true;
            }
            if (count < 1) {
                L.e("[ModuleEvents] endEventInternal, event count should be greater than zero, key [" + key + "], dur:[" + count + "]. Count will be reset to '1'.");
                count = 1;
            }
            L.d("[ModuleEvents] Ending event: [" + key + "]");
            long currentTimestamp = UtilsTime.currentTimestampMs();
            double duration = (currentTimestamp - event.timestamp) / 1000.0;
            UtilsTime.Instant instant = new UtilsTime.Instant(event.timestamp, event.hour, event.dow);
            eventProvider.recordEventInternal(key, segmentation, count, sum, duration, instant, null);
            return true;
        } else {
            return false;
        }
    }
    boolean cancelEventInternal(final String key) {
        if (key == null || key.length() == 0) {
            L.e("[ModuleEvents] Can't cancel event with a null or empty key");
            return false;
        }
        Event event = timedEvents.remove(key);
        return event != null;
    }
    @Override
    void initFinished(@NonNull CountlyConfig config) {
        checkCachedPushData(_cly.countlyStore);
    }
    @Override
    void halt() {
        timedEvents.clear();
    }
    public class Events {
        /**
         * Record a event with a custom timestamp.
         * Use this in case you want to record events that you have tracked
         * and stored internally
         *
         * @param key event key
         * @param segmentation custom segmentation you want to set, leave null if you don't want to add anything
         * @param timestamp unix timestamp in milliseconds of when the event occurred
         */
        public void recordPastEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, long timestamp) {
            synchronized (_cly) {
                recordPastEvent(key, segmentation, 1, 0, 0, timestamp);
            }
        }
        /**
         * Record a event with a custom timestamp.
         * Use this in case you want to record events that you have tracked
         * and stored internally
         *
         * @param key event key
         * @param segmentation custom segmentation you want to set, leave null if you don't want to add anything
         * @param count how many of these events have occurred, default value is "1"
         * @param sum set sum if needed, default value is "0"
         * @param dur duration of the event, default value is "0"
         * @param timestamp unix timestamp in milliseconds of when the event occurred
         */
        public void recordPastEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum, final double dur, long timestamp) {
            synchronized (_cly) {
                L.i("[Events] Calling recordPastEvent: [" + key + "]");
                if (timestamp <= 0) {
                    L.e("Provided timestamp has to be greater that zero. Replacing that timestamp with the current time");
                    timestamp = UtilsTime.currentTimestampMs();
                }
                UtilsTime.Instant instant = UtilsTime.Instant.get(timestamp);
                recordEventInternal(key, segmentation, count, sum, dur, instant, null);
            }
        }
        /**
         * Start timed event with a specified key
         *
         * @param key name of the custom event, required, must not be the empty string or null
         * @return true if no event with this key existed before and event is started, false otherwise
         */
        public boolean startEvent(@NonNull final String key) {
            synchronized (_cly) {
                L.i("[Events] Calling startEvent: [" + key + "]");
                return startEventInternal(key);
            }
        }
        /**
         * End timed event with a specified key
         *
         * @param key name of the custom event, required, must not be the empty string or null
         * @return true if event with this key has been previously started, false otherwise
         */
        public boolean endEvent(@NonNull final String key) {
            synchronized (_cly) {
                return endEvent(key, null, 1, 0);
            }
        }
        /**
         * End timed event with a specified key
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null
         * @param count count to associate with the event, should be more than zero, default value is 1
         * @param sum sum to associate with the event, default value is 0
         * @return true if event with this key has been previously started, false otherwise
         */
        public boolean endEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum) {
            synchronized (_cly) {
                L.i("[Events] Calling endEvent: [" + key + "]");
                return endEventInternal(key, segmentation, count, sum);
            }
        }
        /**
         * Cancel timed event with a specified key
         *
         * @return true if event with this key has been previously started, false otherwise
         **/
        public boolean cancelEvent(@NonNull final String key) {
            synchronized (_cly) {
                L.i("[Events] Calling cancelEvent: [" + key + "]");
                return cancelEventInternal(key);
            }
        }
        /**
         * Records a custom event with no segmentation values, a count of one and a sum of zero.
         *
         * @param key name of the custom event, required, must not be the empty string
         */
        public void recordEvent(@NonNull final String key) {
            synchronized (_cly) {
                recordEvent(key, null, 1, 0);
            }
        }
        /**
         * Records a custom event with no segmentation values, the specified count, and a sum of zero.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param count count to associate with the event, should be more than zero
         */
        public void recordEvent(@NonNull final String key, final int count) {
            synchronized (_cly) {
                recordEvent(key, null, count, 0);
            }
        }
        /**
         * Records a custom event with no segmentation values, and the specified count and sum.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param count count to associate with the event, should be more than zero
         * @param sum sum to associate with the event
         */
        public void recordEvent(@NonNull final String key, final int count, final double sum) {
            synchronized (_cly) {
                recordEvent(key, null, count, sum);
            }
        }
        /**
         * Records a custom event with the specified segmentation values and count, and a sum of zero.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null. Allowed values are String, int, double, boolean
         */
        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation) {
            synchronized (_cly) {
                recordEvent(key, segmentation, 1, 0);
            }
        }
        /**
         * Records a custom event with the specified segmentation values and count, and a sum of zero.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null. Allowed values are String, int, double, boolean
         * @param count count to associate with the event, should be more than zero
         */
        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count) {
            synchronized (_cly) {
                recordEvent(key, segmentation, count, 0);
            }
        }
        /**
         * Records a custom event with the specified values.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null. Allowed values are String, int, double, boolean
         * @param count count to associate with the event, should be more than zero
         * @param sum sum to associate with the event
         */
        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum) {
            synchronized (_cly) {
                recordEvent(key, segmentation, count, sum, 0);
            }
        }
        /**
         * Records a custom event with the specified values.
         *
         * @param key name of the custom event, required, must not be the empty string
         * @param segmentation segmentation dictionary to associate with the event, can be null
         * @param count count to associate with the event, should be more than zero
         * @param sum sum to associate with the event
         * @param dur duration of an event
         */
        public void recordEvent(@NonNull final String key, @Nullable final Map<String, Object> segmentation, final int count, final double sum, final double dur) {
            synchronized (_cly) {
                L.i("[Events] Calling recordEvent: [" + key + "]");
                if (segmentation != null) {
                    UtilsInternalLimits.truncateSegmentationValues(segmentation, _cly.config_.sdkInternalLimits.maxSegmentationValues, "[Events] recordEvent,", L);
                }
                eventProvider.recordEventInternal(key, segmentation, count, sum, dur, null, null);
            }
        }
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import ly.count.android.sdk.messaging.ModulePush;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.mockito.internal.util.collections.Sets;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
@RunWith(AndroidJUnit4.class)
public class ModuleEventsTests {
    Countly mCountly;
    CountlyConfig config;
    String eventKey = "asdf";
    EventQueueProvider eventQueueProvider;
    @Before
    public void setUp() {
        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
        eventQueueProvider = mock(EventQueueProvider.class);
        mCountly = new Countly();
        config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting();
        config.eventQueueProvider = eventQueueProvider;
        mCountly.init(config);
    }
    @After
    public void tearDown() {
    }
    @Test
    public void recordEvent_1() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        mCountly.events().recordEvent(eventKey);
        verify(ep).recordEventInternal(eventKey, null, 1, 0.0, 0.0, null, null);
    }
    @Test
    public void recordEvent_2() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        mCountly.events().recordEvent(eventKey, 657);
        verify(ep).recordEventInternal(eventKey, null, 657, 0.0, 0.0, null, null);
    }
    @Test
    public void recordEvent_3() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        mCountly.events().recordEvent(eventKey, 657, 884.213d);
        verify(ep).recordEventInternal(eventKey, null, 657, 884.213d, 0.0, null, null);
    }
    @Test
    public void recordEvent_4() {
        eventWithSegmentation(null, null, null, null);
    }
    @Test
    public void recordEvent_5() {
        eventWithSegmentation(3456, null, null, null);
    }
    @Test
    public void recordEvent_6() {
        eventWithSegmentation(7583, 39457.123d, null, null);
    }
    @Test
    public void recordEvent_7() {
        eventWithSegmentation(1245, 443.76d, 985.33d, null);
    }
    void eventWithSegmentation(Integer count, Double sum, Double dur, Long timestamp) {
        EventQueueProvider eqp = TestUtils.setEventQueueProviderToMock(mCountly, mock(EventQueueProvider.class));
        Map<String, Object> segmUsed = new HashMap<>();
        segmUsed.put("aa", "dd");
        segmUsed.put("aa1", "dda");
        segmUsed.put("1", 1234);
        segmUsed.put("2", 1234.55d);
        segmUsed.put("3", true);
        segmUsed.put("4", 45.4f);
        segmUsed.put("41", new Object());
        // event key is always provided here
        if (timestamp == null) {
            if (count == null && sum == null && dur == null) { // everything is null
                mCountly.events().recordEvent(eventKey, segmUsed);
            } else if (count != null && sum == null && dur == null) { // only count provided
                mCountly.events().recordEvent(eventKey, segmUsed, count);
            } else if (count != null && sum != null && dur == null) { // count and sum provided
                mCountly.events().recordEvent(eventKey, segmUsed, count, sum);
            } else if (count != null && sum != null && dur != null) { // count and sum and duration provided
                mCountly.events().recordEvent(eventKey, segmUsed, count, sum, dur);
            } else {
                Assert.fail("You should not get here"); // says the wise one
            }
        } else {
            if (count == null && sum == null && dur == null) { // only timestamp provided
                mCountly.events().recordPastEvent(eventKey, segmUsed, timestamp);
            } else if (count != null && sum != null && dur != null) { // count and sum and duration and timestamp provided
                mCountly.events().recordPastEvent(eventKey, segmUsed, count, sum, dur, timestamp);
            } else {
                Assert.fail("You should not get here"); // again says the wise one
            }
        }
        final Map<String, Object> segm = new HashMap<>();
        segm.put("aa", "dd");
        segm.put("aa1", "dda");
        segm.put("1", 1234);
        segm.put("2", 1234.55d);
        segm.put("3", true);
        segm.put("4", 45.4f);
        UtilsTime.Instant instant = UtilsTime.getCurrentInstant();
        ArgumentCaptor<Integer> arg1 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Double> arg2 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Double> arg3 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Long> arg4 = ArgumentCaptor.forClass(Long.class);
        ArgumentCaptor<Integer> arg5 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Integer> arg6 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<String> arg7 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg8 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg9 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg10 = ArgumentCaptor.forClass(String.class);
        verify(eqp).recordEventToEventQueue(eq(eventKey), eq(segm), arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture(), arg8.capture(), arg9.capture(), arg10.capture());
        if (count != null) {
            Assert.assertEquals(count, arg1.getValue());
        }
        if (sum != null) {
            Assert.assertEquals(sum, arg2.getValue());
        }
        if (dur != null) {
            Assert.assertEquals(dur, arg3.getValue());
        }
        if (timestamp == null) {
            Assert.assertNotNull(arg4.getValue());
            Assert.assertNotNull(arg5.getValue());
            Assert.assertNotNull(arg6.getValue());
        } else {
            UtilsTime.Instant instantTimestamp = UtilsTime.Instant.get(timestamp);
            Assert.assertEquals(instantTimestamp.timestampMs, (long) arg4.getValue());
            Assert.assertEquals(instantTimestamp.hour, (int) arg5.getValue());
            Assert.assertEquals(instantTimestamp.dow, (int) arg6.getValue());
            Assert.assertEquals(timestamp.longValue(), (long) arg4.getValue());
        }
        // TODO: Arg 7,8,9,10 check somehow
    }
    @Test
    public void recordPastEvent_1() {
        eventWithSegmentation(null, null, null, 1579463653876L);
    }
    @Test
    public void recordPastEvent_2() {
        eventWithSegmentation(76355, 576334.33d, 85664.64d, 1579463653876L);
    }
    @Test
    public void startEndEvent_noSegments() throws InterruptedException {
        boolean res = mCountly.events().startEvent(eventKey);
        Assert.assertTrue(res);
        verify(eventQueueProvider, times(0)).recordEventToEventQueue(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), any(Long.class), any(Integer.class), any(Integer.class), any(String.class), any(String.class), any(String.class), any(String.class));
        Assert.assertEquals(1, ModuleEvents.timedEvents.size());
        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));
        Event startEvent = ModuleEvents.timedEvents.get(eventKey);
        Thread.sleep(1000);
        res = mCountly.events().endEvent(eventKey);
        Assert.assertTrue(res);
        Assert.assertEquals(0, ModuleEvents.timedEvents.size());
        ArgumentCaptor<Long> arg1 = ArgumentCaptor.forClass(Long.class);
        ArgumentCaptor<Integer> arg2 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Integer> arg3 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Double> argD = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Map> argS = ArgumentCaptor.forClass(Map.class);
        verify(eventQueueProvider).recordEventToEventQueue(eq(eventKey), argS.capture(), eq(1), eq(0.0d), argD.capture(), arg1.capture(), arg2.capture(), arg3.capture(), any(String.class), isNull(String.class), eq(""), eq(""));
        Assert.assertEquals(startEvent.timestamp, (long) arg1.getValue());
        Assert.assertEquals(startEvent.hour, (int) arg2.getValue());
        Assert.assertEquals(startEvent.dow, (int) arg3.getValue());
        Assert.assertTrue(argS.getValue().isEmpty());
        Double captD = argD.getValue();
        Assert.assertEquals(1, captD, 0.1d);
    }
    @Test
    public void startEndEvent_withSegments() throws InterruptedException {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        boolean res = mCountly.events().startEvent(eventKey);
        Assert.assertTrue(res);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        Assert.assertEquals(1, ModuleEvents.timedEvents.size());
        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));
        Event startEvent = ModuleEvents.timedEvents.get(eventKey);
        Thread.sleep(2000);
        Map<String, Object> segm = new HashMap<>();
        segm.put("aa", "dd");
        segm.put("aa1", "dda");
        segm.put("1", 1234);
        segm.put("2", 1234.55d);
        segm.put("3", true);
        res = mCountly.events().endEvent(eventKey, segm, 6372, 5856.34d);
        Assert.assertTrue(res);
        Assert.assertEquals(0, ModuleEvents.timedEvents.size());
        final Map<String, Object> segmVals = new HashMap<>();
        segmVals.put("aa", "dd");
        segmVals.put("aa1", "dda");
        segmVals.put("1", 1234);
        segmVals.put("2", 1234.55d);
        segmVals.put("3", true);
        ArgumentCaptor<UtilsTime.Instant> arg = ArgumentCaptor.forClass(UtilsTime.Instant.class);
        ArgumentCaptor<Double> argD = ArgumentCaptor.forClass(Double.class);
        //  TODO: should final param really be null?
        verify(ep).recordEventInternal(eq(eventKey), eq(segmVals), eq(6372), eq(5856.34d), argD.capture(), arg.capture(), isNull(String.class));
        UtilsTime.Instant captV = arg.getValue();
        Assert.assertEquals(startEvent.hour, captV.hour);
        Assert.assertEquals(startEvent.dow, captV.dow);
        Assert.assertEquals(startEvent.timestamp, captV.timestampMs);
        Double captD = argD.getValue();
        Assert.assertEquals(2, captD, 0.1d);
    }
    @Test
    public void startCancelEndEvent() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        boolean res = mCountly.events().startEvent(eventKey);
        Assert.assertTrue(res);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        Assert.assertEquals(1, ModuleEvents.timedEvents.size());
        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));
        res = mCountly.events().cancelEvent(eventKey);
        Assert.assertTrue(res);
        Assert.assertEquals(0, ModuleEvents.timedEvents.size());
        // TODO: Check these 2 null event IDs
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), isNull(String.class));
        res = mCountly.events().endEvent(eventKey);
        Assert.assertFalse(res);
        Assert.assertEquals(0, ModuleEvents.timedEvents.size());
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), isNull(String.class));
    }
    @Test
    public void startCancelStartEndEvent() throws InterruptedException {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        boolean res = mCountly.events().startEvent(eventKey);
        Assert.assertTrue(res);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        Assert.assertEquals(1, ModuleEvents.timedEvents.size());
        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));
        res = mCountly.events().cancelEvent(eventKey);
        Assert.assertTrue(res);
        Assert.assertEquals(0, ModuleEvents.timedEvents.size());
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), isNull(String.class));
        // finished first start and cancel
        res = mCountly.events().startEvent(eventKey);
        Assert.assertTrue(res);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), isNull(String.class));
        Assert.assertEquals(1, ModuleEvents.timedEvents.size());
        Assert.assertTrue(ModuleEvents.timedEvents.containsKey(eventKey));
        Event startEvent = ModuleEvents.timedEvents.get(eventKey);
        Thread.sleep(1000);
        res = mCountly.events().endEvent(eventKey);
        Assert.assertTrue(res);
        Assert.assertEquals(0, ModuleEvents.timedEvents.size());
        ArgumentCaptor<UtilsTime.Instant> arg = ArgumentCaptor.forClass(UtilsTime.Instant.class);
        ArgumentCaptor<Double> argD = ArgumentCaptor.forClass(Double.class);
        verify(ep).recordEventInternal(eq(eventKey), isNull(Map.class), eq(1), eq(0.0d), argD.capture(), arg.capture(), isNull(String.class));
        UtilsTime.Instant captV = arg.getValue();
        Assert.assertEquals(startEvent.hour, captV.hour);
        Assert.assertEquals(startEvent.dow, captV.dow);
        Assert.assertEquals(startEvent.timestamp, captV.timestampMs);
        Double captD = argD.getValue();
        Assert.assertEquals(1, captD, 0.1d);
    }
    @Test
    public void recordEventInternalProcessedTest() {
        EventQueueProvider eqp = TestUtils.setEventQueueProviderToMock(mCountly, mock(EventQueueProvider.class));
        Map<String, Object> segm1 = new HashMap<>();
        final Map<String, Object> segm2 = new HashMap<>();
        segm1.put("4", 45.4f);
        segm1.put("41", new Object());
        segm1.put("42", new int[][] { { 1, 2, 3 }, { 4, 5, 6 } });
        segm1.put("asd", "123");
        segm1.put("1", 1234);
        segm1.put("2", 1234.55d);
        segm1.put("3", true);
        segm2.put("asd", "123");
        segm2.put("1", 1234);
        segm2.put("2", 1234.55d);
        segm2.put("3", true);
        segm2.put("4", 45.4f);
        Map<String, Object> segm3 = new HashMap<>(segm1);
        mCountly.config_.eventProvider.recordEventInternal(eventKey, segm3, 123, 321.22d, 342.32d, null, null);
        verify(eqp).recordEventToEventQueue(eq(eventKey), eq(segm2), eq(123), eq(321.22d), eq(342.32d), any(Long.class), any(Integer.class), any(Integer.class), any(String.class), isNull(String.class), eq(""), eq(""));
        eqp = TestUtils.setEventQueueProviderToMock(mCountly, mock(EventQueueProvider.class));
        segm3.clear();
        segm3.putAll(segm1);
        mCountly.config_.eventProvider.recordEventInternal(eventKey, segm3, 123, 321.22d, 342.32d, null, null);
        verify(eqp).recordEventToEventQueue(eq(eventKey), eq(segm3), eq(123), eq(321.22d), eq(342.32d), any(Long.class), any(Integer.class), any(Integer.class), any(String.class), isNull(String.class), eq(""), any(String.class));
    }
    /**
     * Validating which event keys are triggering force sending of all queued events
     */
    @Test
    public void eventsForceClearingEQIntoRQ() {
        Countly countly = new Countly().init(new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting());
        Assert.assertEquals(0, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(0, countly.countlyStore.getRequests().length);
        countly.events().recordEvent("rnd_key");
        Assert.assertEquals(1, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(0, countly.countlyStore.getRequests().length);
        countly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY);
        Assert.assertEquals(2, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(0, countly.countlyStore.getRequests().length);
        countly.events().recordEvent(ModuleFeedback.NPS_EVENT_KEY);
        Assert.assertEquals(0, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(1, countly.countlyStore.getRequests().length);
        countly.events().recordEvent(ModuleFeedback.SURVEY_EVENT_KEY);
        Assert.assertEquals(0, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(2, countly.countlyStore.getRequests().length);
        countly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY);
        Assert.assertEquals(1, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(2, countly.countlyStore.getRequests().length);
        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY);
        Assert.assertEquals(2, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(2, countly.countlyStore.getRequests().length);
        countly.events().recordEvent(ModuleViews.ORIENTATION_EVENT_KEY);
        Assert.assertEquals(3, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(2, countly.countlyStore.getRequests().length);
        countly.events().recordEvent(ModulePush.PUSH_EVENT_ACTION);
        Assert.assertEquals(0, countly.countlyStore.getEventQueueSize());
        Assert.assertEquals(3, countly.countlyStore.getRequests().length);
    }
    /**
     * Try to record events with internal keys
     * validate they are not truncated
     * try one normal event with a key that is longer than the max allowed length
     * except normal event, all other internal events should not be truncated
     */
    @Test
    public void internalLimits_recordEvent_internalKeys() throws JSONException {
        CountlyConfig config = TestUtils.createBaseConfig();
        config.sdkInternalLimits.setMaxKeyLength(2);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        countly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY, TestUtils.map("action_event", "ACTION", "no_truncate", 7687)); //force sending
        validateEventInRQ(ModuleEvents.ACTION_EVENT_KEY, TestUtils.map("action_event", "ACTION", "no_truncate", 7687), 0);
        countly.events().recordEvent(ModuleFeedback.NPS_EVENT_KEY, TestUtils.map("nps_event", "NPS", "no_truncate", 555)); //force sending
        validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, TestUtils.map("nps_event", "NPS", "no_truncate", 555), 1);
        countly.events().recordEvent(ModuleFeedback.SURVEY_EVENT_KEY, TestUtils.map("survey_event", "SURVEY", "no_truncate", 567)); //force sending
        validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, TestUtils.map("survey_event", "SURVEY", "no_truncate", 567), 2);
        countly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY, TestUtils.map("rating_event", "RATING", "no_truncate", 7475));
        validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, TestUtils.map("rating_event", "RATING", "no_truncate", 7475), 3);
        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("view_event", "VIEW", "no_truncate", 124));
        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("view_event", "VIEW", "no_truncate", 124), 4);
        countly.events().recordEvent(ModuleViews.ORIENTATION_EVENT_KEY, TestUtils.map("orientation_event", "ORIENTATION", "no_truncate", 23_523));
        validateEventInRQ(ModuleViews.ORIENTATION_EVENT_KEY, TestUtils.map("orientation_event", "ORIENTATION", "no_truncate", 23_523), 5);
        countly.events().recordEvent(ModulePush.PUSH_EVENT_ACTION, TestUtils.map("push_event", "PUSH", "no_truncate", 567));
        validateEventInRQ(ModulePush.PUSH_EVENT_ACTION, TestUtils.map("push_event", "PUSH", "no_truncate", 567), 6);
        countly.events().recordEvent("ModuleEvents", TestUtils.map("normal_event", "boo", "no_truncate", 567));
        validateEventInRQ("Mo", TestUtils.map("no", "boo"), 7);
    }
    /**
     * record event with segmentation
     * validate that the segmentation is truncated and two same start keys is merged to one
     */
    @Test
    public void internalLimits_recordEvent_segmentation() throws JSONException {
        CountlyConfig config = TestUtils.createBaseConfig();
        config.sdkInternalLimits.setMaxKeyLength(2);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        Map<String, Object> segmentation = new ConcurrentHashMap<>();
        segmentation.put("ModuleEvents", "ModuleEvents");
        segmentation.put("ModuleFeedback", 567);
        countly.events().recordEvent("TestMe", segmentation); //force sending
        segmentation.clear();
        segmentation.put("Mo", 567);
        validateEventInRQ("Te", segmentation, 0);
    }
    @Test
    public void recordEvent_validateFromRQ() throws JSONException {
        int[] arr = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        List<String> list = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10");
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        Map<String, Object> segmentation = TestUtils.map(
            "int", 1,
            "double", 1.2d,
            "string", "string",
            "boolean", true,
            "float", 1.5f,
            "long", Long.MAX_VALUE,
            "object", new Object(),
            "array", arr,
            "list", list,
            "null", null
        );
        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);
        Map<String, Object> expectedSegmentation = TestUtils.map(
            "int", 1,
            "double", 1.2,
            "string", "string",
            "boolean", true,
            "float", 1.5,
            "long", Long.MAX_VALUE,
            "array", new JSONArray(arr),
            "list", new JSONArray(list)
        );
        validateEventInRQ("key", expectedSegmentation, 1, 1.0d, 1.0d, 0);
    }
    /**
     * Validate that only normal events' segmentation values are clipped to the maximum allowed values
     * EQ size is 1 to trigger request generation
     */
    @Test
    public void internalLimits_recordEventInternal_maxSegmentationValues() throws JSONException {
        CountlyConfig config = TestUtils.createBaseConfig();
        config.sdkInternalLimits.setMaxSegmentationValues(2);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        Assert.assertEquals(0, TestUtils.getCurrentRQ().length);
        Map<String, Object> threeSegmentation = TestUtils.map("a", 1, "b", 2, "c", 3);
        countly.events().recordEvent("rnd_key", TestUtils.map("a", 1, "b", 2, "c", 3, "d", 4, "e", 5, "f", 6, "g", 7), 1, 1.1d, 1.1d);
        validateEventInRQ("rnd_key", TestUtils.map("f", 6, "g", 7), 1, 1.1d, 1.1d, 0);
        countly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY, threeSegmentation);
        validateEventInRQ(ModuleEvents.ACTION_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 1);
        countly.events().recordEvent(ModuleFeedback.NPS_EVENT_KEY, threeSegmentation);
        validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 2);
        countly.events().recordEvent(ModuleFeedback.SURVEY_EVENT_KEY, threeSegmentation);
        validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 3);
        countly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY, threeSegmentation);
        validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 4);
        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, threeSegmentation);
        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 5);
        countly.events().recordEvent(ModuleViews.ORIENTATION_EVENT_KEY, threeSegmentation);
        validateEventInRQ(ModuleViews.ORIENTATION_EVENT_KEY, threeSegmentation, 1, 0.0d, 0.0d, 6);
        countly.events().recordEvent(ModulePush.PUSH_EVENT_ACTION, threeSegmentation);
        validateEventInRQ(ModulePush.PUSH_EVENT_ACTION, threeSegmentation, 1, 0.0d, 0.0d, 7);
    }
    /**
     * "recordEvent" max value size limit
     * Validate that all "String" values are clipped to the maximum allowed length
     * EQ size is 1 to trigger request generation
     */
    @Test
    public void internalLimits_recordEventInternal_maxValueSize() throws JSONException {
        CountlyConfig config = TestUtils.createBaseConfig();
        config.sdkInternalLimits.setMaxValueSize(2);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        Assert.assertEquals(0, TestUtils.getCurrentRQ().length);
        countly.events().recordEvent("rnd_key", TestUtils.map("a", 1, "b", "bbb", "c", "ccc"), 1, 1.1d, 1.1d);
        validateEventInRQ("rnd_key", TestUtils.map("a", 1, "b", "bb", "c", "cc"), 1, 1.1d, 1.1d, 0);
    }
    /**
     * "recordEvent" max value size limit and key length
     * Validate that clipped values clashes with same keys and overridden each other
     * "bb" key should have value from the second of the last value which is "dd"
     */
    @Test
    public void internalLimits_recordEventInternal_maxValueSizeKeyLength() throws JSONException {
        CountlyConfig config = TestUtils.createBaseConfig();
        config.sdkInternalLimits.setMaxValueSize(2).setMaxKeyLength(2);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        Assert.assertEquals(0, TestUtils.getCurrentRQ().length);
        countly.events().recordEvent("rnd_key", TestUtils.map("a", 1, "bbb", "bbb", "bbc", "ccc", "bbd", "ddd", "bbe", "eee"), 1, 1.1d, 1.1d);
        validateEventInRQ("rn", TestUtils.map("a", 1, "bb", "dd"), 1, 1.1d, 1.1d, 0);
    }
    /**
     * "recordEvent" with Array segmentations
     * Validate that all primitive types arrays are successfully recorded
     * And validate that Object arrays are not recorded
     * But Generic type of Object array which its values are only primitive types are recorded
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEvent_validateSupportedArrays() throws JSONException {
        int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
        boolean[] arrB = { true, false, true, false, true, false, true, false, true, false };
        String[] arrS = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };
        long[] arrL = { Long.MAX_VALUE, Long.MIN_VALUE };
        double[] arrD = { Double.MAX_VALUE, Double.MIN_VALUE };
        Long[] arrLO = { Long.MAX_VALUE, Long.MIN_VALUE };
        Double[] arrDO = { Double.MAX_VALUE, Double.MIN_VALUE };
        Boolean[] arrBO = { Boolean.TRUE, Boolean.FALSE };
        Integer[] arrIO = { Integer.MAX_VALUE, Integer.MIN_VALUE };
        Object[] arrObj = { "1", 1, 1.1d, true, 1.1f, Long.MAX_VALUE };
        Object[] arrObjStr = { "1", "1", "1.1d", "true", "1.1f", "Long.MAX_VALUE" };
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        Map<String, Object> segmentation = TestUtils.map(
            "arr", arr,
            "arrB", arrB,
            "arrS", arrS,
            "arrL", arrL,
            "arrD", arrD,
            "arrLO", arrLO,
            "arrDO", arrDO,
            "arrBO", arrBO,
            "arrIO", arrIO,
            "arrObj", arrObj,
            "arrObjStr", arrObjStr
        );
        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);
        Map<String, Object> expectedSegmentation = TestUtils.map(
            "arr", new JSONArray(arr),
            "arrB", new JSONArray(arrB),
            "arrS", new JSONArray(arrS),
            "arrL", new JSONArray(arrL),
            "arrD", new JSONArray(arrD),
            "arrLO", new JSONArray(arrLO),
            "arrDO", new JSONArray(arrDO),
            "arrBO", new JSONArray(arrBO),
            "arrIO", new JSONArray(arrIO)
        );
        validateEventInRQ("key", expectedSegmentation, 1, 1.0d, 1.0d, 0);
    }
    /**
     * "recordEvent" with List segmentations
     * Validate that all primitive types Lists are successfully recorded
     * And validate that List of Objects is not recorded
     * But Generic type of Object list which its values are only primitive types are recorded
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEvent_validateSupportedLists() throws JSONException {
        List<Integer> arr = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<Boolean> arrB = Arrays.asList(true, false, true, false, true, false, true, false, true, false);
        List<String> arrS = Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10");
        List<Long> arrLO = Arrays.asList(Long.MAX_VALUE, Long.MIN_VALUE);
        List<Double> arrDO = Arrays.asList(Double.MAX_VALUE, Double.MIN_VALUE);
        List<Boolean> arrBO = Arrays.asList(Boolean.TRUE, Boolean.FALSE);
        List<Integer> arrIO = Arrays.asList(Integer.MAX_VALUE, Integer.MIN_VALUE);
        List<Object> arrObj = Arrays.asList("1", 1, 1.1d, true, Long.MAX_VALUE);
        List<Object> arrObjStr = Arrays.asList("1", "1", "1.1d", "true", "Long.MAX_VALUE");
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        // Create segmentation using maps with lists
        Map<String, Object> segmentation = TestUtils.map(
            "arr", arr,
            "arrB", arrB,
            "arrS", arrS,
            "arrLO", arrLO,
            "arrDO", arrDO,
            "arrBO", arrBO,
            "arrIO", arrIO,
            "arrObj", arrObj,
            "arrObjStr", arrObjStr
        );
        // Record event with the created segmentation
        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);
        // Prepare expected segmentation with JSONArrays
        Map<String, Object> expectedSegmentation = TestUtils.map(
            "arr", new JSONArray(arr),
            "arrB", new JSONArray(arrB),
            "arrS", new JSONArray(arrS),
            "arrLO", new JSONArray(arrLO),
            "arrDO", new JSONArray(arrDO),
            "arrBO", new JSONArray(arrBO),
            "arrIO", new JSONArray(arrIO),
            "arrObjStr", new JSONArray(arrObjStr),
            "arrObj", new JSONArray(arrObj)
        );
        // Validate the recorded event with expected segmentation
        validateEventInRQ("key", expectedSegmentation, 1, 1.0d, 1.0d, 0);
    }
    /**
     * "recordEvent" with JSONArray segmentations
     * Validate that all primitive types JSONArrays are successfully recorded
     * And validate and JSONArray of Objects is not recorded
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEvent_validateSupportedJSONArrays() throws JSONException {
        JSONArray arr = new JSONArray(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));
        JSONArray arrB = new JSONArray(Arrays.asList(true, false, true, false, true, false, true, false, true, false));
        JSONArray arrS = new JSONArray(Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10"));
        JSONArray arrL = new JSONArray(Arrays.asList(Long.MAX_VALUE, Long.MIN_VALUE));
        JSONArray arrD = new JSONArray(Arrays.asList(Double.MAX_VALUE, Double.MIN_VALUE));
        JSONArray arrBO = new JSONArray(Arrays.asList(Boolean.TRUE, Boolean.FALSE));
        JSONArray arrIO = new JSONArray(Arrays.asList(Integer.MAX_VALUE, Integer.MIN_VALUE));
        JSONArray arrObj = new JSONArray(Arrays.asList("1", 1, 1.1d, true, Long.MAX_VALUE));
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        // Create segmentation using maps with lists
        Map<String, Object> segmentation = TestUtils.map(
            "arr", arr,
            "arrB", arrB,
            "arrS", arrS,
            "arrL", arrL,
            "arrD", arrD,
            "arrBO", arrBO,
            "arrIO", arrIO,
            "arrObj", arrObj
        );
        // Record event with the created segmentation
        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);
        // Prepare expected segmentation with JSONArrays
        Map<String, Object> expectedSegmentation = TestUtils.map(
            "arr", arr,
            "arrB", arrB,
            "arrS", arrS,
            "arrL", arrL,
            "arrD", arrD,
            "arrBO", arrBO,
            "arrIO", arrIO,
            "arrObj", arrObj
        );
        // Validate the recorded event with expected segmentation
        validateEventInRQ("key", expectedSegmentation, 1, 1.0d, 1.0d, 0);
    }
    /**
     * "recordHandledException" with invalid data types
     * Validate that unsupported data types are not recorded
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEvent_unsupportedDataTypesSegmentation() throws JSONException {
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        Map<String, Object> segmentation = TestUtils.map(
            "a", TestUtils.map(),
            "b", TestUtils.json(),
            "c", new Object(),
            "d", Sets.newSet(),
            "e", Mockito.mock(ModuleLog.class)
        );
        // Record event with the created segmentation
        countly.events().recordEvent("key", segmentation, 1, 1.0d, 1.0d);
        validateEventInRQ("key", TestUtils.map(), 1, 1.0d, 1.0d, 0);
    }
    /**
     * "recordEvent" with visibility tracking enabled
     * Validate that visibility tracking events are recorded correctly
     * and only added to "Events" and "Views"
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEvent_visibilityTracking_onlyAddingItToViewsAndEvents() throws JSONException {
        CountlyConfig config = TestUtils.createBaseConfig();
        config.experimental.enableVisibilityTracking();
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        Assert.assertEquals(0, TestUtils.getCurrentRQ().length);
        countly.events().recordEvent("rnd_key", TestUtils.map());
        validateEventInRQ("rnd_key", TestUtils.map("cly_v", 0), 1, 0.0d, 0.0d, 0);
        countly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY, TestUtils.map());
        validateEventInRQ(ModuleEvents.ACTION_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 1);
        countly.events().recordEvent(ModuleFeedback.NPS_EVENT_KEY, TestUtils.map());
        validateEventInRQ(ModuleFeedback.NPS_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 2);
        countly.events().recordEvent(ModuleFeedback.SURVEY_EVENT_KEY, TestUtils.map());
        validateEventInRQ(ModuleFeedback.SURVEY_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 3);
        countly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY, TestUtils.map());
        validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 4);
        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));
        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("cly_v", 0, "visit", 1), 1, 0.0d, 0.0d, 5);
        countly.events().recordEvent(ModuleViews.ORIENTATION_EVENT_KEY, TestUtils.map());
        validateEventInRQ(ModuleViews.ORIENTATION_EVENT_KEY, TestUtils.map(), 1, 0.0d, 0.0d, 6);
        countly.events().recordEvent(ModulePush.PUSH_EVENT_ACTION, TestUtils.map());
        validateEventInRQ(ModulePush.PUSH_EVENT_ACTION, TestUtils.map(), 1, 0.0d, 0.0d, 7);
    }
    /**
     * "recordEvent" with visibility tracking enabled
     * Validate that visibility tracking events are recorded correctly
     * And validate that the "cly_v" value is correctly set to 1 when the app is in the foreground
     * and 0 when the app is in the background
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEvent_visibilityTracking_bgFgSwitch() throws JSONException {
        CountlyConfig config = TestUtils.createBaseConfig(TestUtils.getContext());
        config.experimental.enableVisibilityTracking();
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        countly.onStart(Mockito.mock(Activity.class)); //foreground
        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));
        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("cly_v", 1, "visit", 1), 1, 0.0d, 0.0d, 2);
        countly.events().recordEvent("fg", TestUtils.map());
        validateEventInRQ("fg", TestUtils.map("cly_v", 1), 1, 0.0d, 0.0d, 3);
        countly.onStop(); //background
        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));
        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("cly_v", 0, "visit", 1), 1, 0.0d, 0.0d, 5);
        countly.events().recordEvent("bg", TestUtils.map());
        validateEventInRQ("bg", TestUtils.map("cly_v", 0), 1, 0.0d, 0.0d, 6);
    }
    /**
     * "recordEvent" with visibility tracking disabled
     * Validate that visibility tracking events are not recorded
     * And validate that the "cly_v" value is not set
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEvent_visibilityTracking_notEnabled() throws JSONException {
        CountlyConfig config = TestUtils.createBaseConfig(TestUtils.getContext());
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        countly.onStart(Mockito.mock(Activity.class)); //foreground
        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));
        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1), 1, 0.0d, 0.0d, 2);
        countly.events().recordEvent("fg", TestUtils.map());
        validateEventInRQ("fg", TestUtils.map(), 1, 0.0d, 0.0d, 3);
        countly.onStop(); //background
        countly.events().recordEvent(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1));
        validateEventInRQ(ModuleViews.VIEW_EVENT_KEY, TestUtils.map("visit", 1), 1, 0.0d, 0.0d, 5);
        countly.events().recordEvent("bg", TestUtils.map());
        validateEventInRQ("bg", TestUtils.map(), 1, 0.0d, 0.0d, 6);
    }
    /**
     * "recordEvent" scenario with previous and current view name tracking is disabled
     * Validate that the event is recorded without view names
     * EQ size is 1 to trigger request generation
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEventScenario_previous_current_ViewName_disabled() throws JSONException {
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        countly.events().recordEvent("TEST");
        validateEventInRQ("TEST", 0, 1, "_CLY_", "_CLY_", null, null);
        countly.views().startView("View1");
        countly.events().recordEvent("TEST1");
        // start false because session did not start
        ModuleViewsTests.validateView("View1", 0.0, 1, 3, false, true, TestUtils.map(), "_CLY_", "_CLY_", null);
        validateEventInRQ("TEST1", 2, 3, "_CLY_", "_CLY_", null, null);
        countly.views().startView("View2");
        countly.events().recordEvent("TEST2");
        ModuleViewsTests.validateView("View2", 0.0, 3, 5, false, true, TestUtils.map(), "_CLY_", "_CLY_", null);
        validateEventInRQ("TEST2", 4, 5, "_CLY_", "_CLY_", null, null);
    }
    /**
     * "recordEvent" scenario with previous and current view name tracking is enabled
     * Validate that the event is recorded with view names
     * EQ size is 1 to trigger request generation
     *
     * @throws JSONException if the JSON is not valid
     */
    @Test
    public void recordEventScenario_previous_current_ViewName() throws JSONException {
        CountlyConfig countlyConfig = TestUtils.createBaseConfig();
        countlyConfig.experimental.enablePreviousNameRecording();
        countlyConfig.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(countlyConfig);
        countly.events().recordEvent("TEST");
        validateEventInRQ("TEST", 0, 1, "_CLY_", "_CLY_", "", "");
        countly.views().startView("View1");
        countly.events().recordEvent("TEST1");
        // start false because session did not start
        ModuleViewsTests.validateView("View1", 0.0, 1, 3, false, true, TestUtils.map(), "_CLY_", "_CLY_", "");
        validateEventInRQ("TEST1", 2, 3, "_CLY_", "_CLY_", "TEST", "View1");
        countly.views().startView("View2");
        countly.events().recordEvent("TEST2");
        ModuleViewsTests.validateView("View2", 0.0, 3, 5, false, true, TestUtils.map(), "_CLY_", "_CLY_", "View1");
        validateEventInRQ("TEST2", 4, 5, "_CLY_", "_CLY_", "TEST1", "View2");
    }
    protected static void validateEventInRQ(String eventName, int idx, int rqCount, String previousViewId, String currentViewId, String previousEventName, String currentViewName) throws JSONException {
        Map<String, Object> segmentation = TestUtils.map();
        if (previousEventName != null) {
            segmentation.put("cly_pen", previousEventName);
        }
        if (currentViewName != null) {
            segmentation.put("cly_cvn", currentViewName);
        }
        validateEventInRQ(TestUtils.commonDeviceId, eventName, segmentation, 1, 0.0, 0.0, "_CLY_", previousViewId, currentViewId, "_CLY_", idx, rqCount, 0, 1);
    }
    protected static void validateEventInRQ(String eventName, Map<String, Object> expectedSegmentation, int count, double sum, double duration, int idx) throws JSONException {
        validateEventInRQ(eventName, expectedSegmentation, count, sum, duration, idx, idx + 1);
    }
    protected static void validateEventInRQ(String eventName, Map<String, Object> expectedSegmentation, int count, double sum, double duration, int idx, int rqCount) throws JSONException {
        validateEventInRQ(TestUtils.commonDeviceId, eventName, expectedSegmentation, count, sum, duration, "_CLY_", "_CLY_", "_CLY_", "_CLY_", idx, rqCount, 0, 1);
    }
    protected static void validateEventInRQ(String deviceId, String eventName, Map<String, Object> expectedSegmentation, int count, Double sum, Double duration, String id, String pvid, String cvid, String peid, int idx, int rqCount, int eventIdx, int eventCount)
        throws JSONException {
        Map<String, String>[] RQ = TestUtils.getCurrentRQ();
        if (rqCount > -1) {
            Assert.assertEquals(rqCount, RQ.length);
        }
        TestUtils.validateRequiredParams(RQ[idx], deviceId);
        if (!RQ[idx].containsKey("events")) {
            Assert.fail("Not an event request idx:[" + idx + "], request:[" + RQ[idx] + "]");
        }
        JSONArray events = new JSONArray(RQ[idx].get("events"));
        Assert.assertEquals(eventCount, events.length());
        JSONObject event = events.getJSONObject(eventIdx);
        Assert.assertEquals(eventName, event.get("key"));
        Assert.assertEquals(count, event.getInt("count"));
        Assert.assertEquals(sum, event.optDouble("sum", 0.0d), 0.0001);
        Assert.assertEquals(duration, event.optDouble("dur", 0.0d), 0.0001);
        if (expectedSegmentation != null && !expectedSegmentation.isEmpty()) {
            JSONObject segmentation = event.getJSONObject("segmentation");
            Assert.assertEquals("Expected segmentation: " + expectedSegmentation + ", got: " + segmentation, expectedSegmentation.size(), segmentation.length());
            for (Map.Entry<String, Object> entry : expectedSegmentation.entrySet()) {
                Assert.assertEquals(entry.getValue(), segmentation.get(entry.getKey()));
            }
        }
        int dow = event.getInt("dow");
        int hour = event.getInt("hour");
        long timestamp = event.getLong("timestamp");
        Assert.assertTrue(dow >= 0 && dow < 7);
        Assert.assertTrue(hour >= 0 && hour < 24);
        Assert.assertTrue(timestamp >= 0);
        validateId(id, event.optString("id", ""), "Event ID");
        validateId(pvid, event.optString("pvid", ""), "Previous View ID");
        validateId(cvid, event.optString("cvid", ""), "Current View ID");
        validateId(peid, event.optString("peid", ""), "Previous Event ID");
    }
    private static void validateId(String id, String gonnaValidate, String name) {
        if (id != null && id.equals("_CLY_")) {
            if (gonnaValidate != null && !gonnaValidate.isEmpty()) {
                validateSafeRandomVal(gonnaValidate);
            }
        } else {
            Assert.assertEquals(name + " is not validated", id, gonnaValidate);
        }
    }
    /**
     * Validates a random generated safe value,
     * Value length should be 21
     * Value should contain a timestamp at the end
     * Value should be base64 encoded and first 8 should be it
     *
     * @param val
     */
    static void validateSafeRandomVal(String val) {
        Assert.assertEquals(val, 21, val.length());
        Pattern base64Pattern = Pattern.compile("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$");
        String timestampStr = val.substring(val.length() - 13);
        String base64Str = val.substring(0, val.length() - 13);
        Matcher matcher = base64Pattern.matcher(base64Str);
        if (matcher.matches()) {
            UtilsTime.Instant instant = UtilsTime.Instant.get(Long.parseLong(timestampStr));
            Assert.assertTrue(instant.dow >= 0 && instant.dow < 7);
            Assert.assertTrue(instant.hour >= 0 && instant.hour < 24);
            Assert.assertTrue(instant.timestampMs > 0);
        } else {
            Assert.fail("No match for " + val);
        }
    }
    protected static void validateEventInRQ(String eventName, Map<String, Object> expectedSegmentation, int idx) throws JSONException {
        validateEventInRQ(eventName, expectedSegmentation, 1, 0.0d, 0.0d, idx);
    }
    protected static void validateEventInRQ(String eventName, int rqIdx, int eventIdx, int eventCount) throws JSONException {
        validateEventInRQ(TestUtils.commonDeviceId, eventName, null, 1, 0.0d, 0.0d, "_CLY_", "_CLY_", "_CLY_", "_CLY_", rqIdx, -1, eventIdx, eventCount);
    }
    protected static void validateEventInRQ(String deviceId, String eventName, int rqIdx, int eventIdx, int eventCount) throws JSONException {
        validateEventInRQ(deviceId, eventName, null, 1, 0.0d, 0.0d, "_CLY_", "_CLY_", "_CLY_", "_CLY_", rqIdx, -1, eventIdx, eventCount);
    }
/*
    //todo should be reworked
    @Test
    public void testRecordEvent() {
        final String eventKey = "eventKey";
        final int count = 42;
        final double sum = 3.0d;
        final double dur = 10.0d;
        final HashMap<String, Object> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", "segvalue1");
        final HashMap<String, Object> segm = new HashMap<>();
        segm.put("segkey1", "segvalue1");
        //create a spied countly class
        final Countly countly = spy(mCountly);
        countly.moduleEvents = new ModuleEvents(countly, countly.config_);
        countly.moduleEvents.eventQueueProvider = mock(EventQueueProvider.class);
        doNothing().when(countly).sendEventsIfNeeded(false);
        doReturn(true).when(countly).isInitialized();
        countly.events().recordEvent(eventKey, segmentation, count, sum, dur);
        verify(countly.moduleEvents.eventQueueProvider).recordEventToEventQueue(eq(eventKey), eq(segm), eq(count), eq(sum), eq(dur), any(Long.class), any(Integer.class), any(Integer.class));
        verify(countly).sendEventsIfNeeded(false);
    }
*/
    //todo potential tests to rework
    /*
    @Test
    public void testRecordEvent_keyOnly() {
        final String eventKey = "eventKey";
        final Countly countly = spy(mCountly);
        doNothing().when(countly).recordEvent(eventKey, null, 1, 0.0d);
        countly.recordEvent(eventKey);
        verify(countly).recordEvent(eventKey, null, 1, 0.0d);
    }
    @Test
    public void testRecordEvent_keyAndCount() {
        final String eventKey = "eventKey";
        final int count = 42;
        final Countly countly = spy(mCountly);
        doNothing().when(countly).recordEvent(eventKey, null, count, 0.0d);
        countly.recordEvent(eventKey, null, count, 0.0d);
        verify(countly).recordEvent(eventKey, null, count, 0.0d);
    }
    @Test
    public void testRecordEvent_keyAndCountAndSum() {
        final String eventKey = "eventKey";
        final int count = 42;
        final double sum = 3.0d;
        final Countly countly = spy(mCountly);
        doNothing().when(countly).recordEvent(eventKey, null, count, sum);
        countly.recordEvent(eventKey, count, sum);
        verify(countly).recordEvent(eventKey, null, count, sum);
    }
    @Test
    public void testRecordEvent_keyAndSegmentationAndCount() {
        final String eventKey = "eventKey";
        final int count = 42;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", "segvalue1");
        final Countly countly = spy(mCountly);
        doNothing().when(countly).recordEvent(eventKey, segmentation, count, 0.0d);
        countly.recordEvent(eventKey, segmentation, count);
        verify(countly).recordEvent(eventKey, segmentation, count, 0.0d);
    }
    @Test
    public void testRecordEvent_initNotCalled() {
        final String eventKey = "eventKey";
        final int count = 42;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", "segvalue1");
        try {
            mUninitedCountly.recordEvent(eventKey, segmentation, count, sum);
            // success
            // should not throw a exception anymore
        } catch (IllegalStateException ignored) {
            fail("expected IllegalStateException when recordEvent called before init");
        }
    }
    @Test
    public void testRecordEvent_nullKey() {
        final String eventKey = null;
        final int count = 42;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", "segvalue1");
        try {
            //noinspection ConstantConditions
            mCountly.recordEvent(eventKey, segmentation, count, sum);
            fail("expected IllegalArgumentException when recordEvent called with null key");
        } catch (IllegalArgumentException ignored) {
            // success
        }
    }
    @Test
    public void testRecordEvent_emptyKey() {
        final String eventKey = "";
        final int count = 42;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", "segvalue1");
        try {
            mCountly.recordEvent(eventKey, segmentation, count, sum);
            fail("expected IllegalArgumentException when recordEvent called with empty key");
        } catch (IllegalArgumentException ignored) {
            // success
        }
    }
    @Test
    public void testRecordEvent_countIsZero() {
        final String eventKey = "";
        final int count = 0;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", "segvalue1");
        try {
            mCountly.recordEvent(eventKey, segmentation, count, sum);
            fail("expected IllegalArgumentException when recordEvent called with count=0");
        } catch (IllegalArgumentException ignored) {
            // success
        }
    }
    @Test
    public void testRecordEvent_countIsNegative() {
        final String eventKey = "";
        final int count = -1;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", "segvalue1");
        try {
            mCountly.recordEvent(eventKey, segmentation, count, sum);
            fail("expected IllegalArgumentException when recordEvent called with a negative count");
        } catch (IllegalArgumentException ignored) {
            // success
        }
    }
    @Test
    public void testRecordEvent_segmentationHasNullKey() {
        final String eventKey = "";
        final int count = 1;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put(null, "segvalue1");
        try {
            mCountly.recordEvent(eventKey, segmentation, count, sum);
            fail("expected IllegalArgumentException when recordEvent called with segmentation with null key");
        } catch (IllegalArgumentException ignored) {
            // success
        }
    }
    @Test
    public void testRecordEvent_segmentationHasEmptyKey() {
        final String eventKey = "";
        final int count = 1;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("", "segvalue1");
        try {
            mCountly.recordEvent(eventKey, segmentation, count, sum);
            fail("expected IllegalArgumentException when recordEvent called with segmentation with empty key");
        } catch (IllegalArgumentException ignored) {
            // success
        }
    }
    @Test
    public void testRecordEvent_segmentationHasNullValue() {
        final String eventKey = "";
        final int count = 1;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", null);
        try {
            mCountly.recordEvent(eventKey, segmentation, count, sum);
            fail("expected IllegalArgumentException when recordEvent called with segmentation with null value");
        } catch (IllegalArgumentException ignored) {
            // success
        }
    }
    @Test
    public void testRecordEvent_segmentationHasEmptyValue() {
        final String eventKey = "";
        final int count = 1;
        final double sum = 3.0d;
        final HashMap<String, String> segmentation = new HashMap<>(1);
        segmentation.put("segkey1", "");
        try {
            mCountly.recordEvent(eventKey, segmentation, count, sum);
            fail("expected IllegalArgumentException when recordEvent called with segmentation with empty value");
        } catch (IllegalArgumentException ignored) {
            // success
        }
    }
     */
}
package ly.count.android.sdk;
import android.os.AsyncTask;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import org.json.JSONObject;
/**
 * Async task for making immediate server requests
 */
class ImmediateRequestMaker extends AsyncTask<Object, Void, JSONObject> implements ImmediateRequestI {
    /**
     * Used for callback from async task
     */
    protected interface InternalImmediateRequestCallback {
        void callback(JSONObject checkResponse);
    }
    InternalImmediateRequestCallback callback;
    ModuleLog L;
    @Override
    public void doWork(@NonNull String requestData, @Nullable String customEndpoint, @NonNull ConnectionProcessor cp, boolean requestShouldBeDelayed, boolean networkingIsEnabled, @NonNull InternalImmediateRequestCallback callback, @NonNull ModuleLog log) {
        assert Utils.isNotNullOrEmpty(requestData);
        assert cp != null;
        assert log != null;
        assert callback != null;
        this.execute(requestData, customEndpoint, cp, requestShouldBeDelayed, networkingIsEnabled, callback, log);
    }
    /**
     * params fields:
     * 0 - requestData
     * 1 - custom endpoint
     * 2 - connection processor
     * 3 - requestShouldBeDelayed
     * 4 - networkingIsEnabled
     * 5 - callback
     * 6 - log module
     */
    protected JSONObject doInBackground(Object... params) {
        final String requestData = (String) params[0];
        final String customEndpoint = (String) params[1];
        final ConnectionProcessor cp = (ConnectionProcessor) params[2];
        final boolean requestShouldBeDelayed = (boolean) params[3];
        final boolean networkingIsEnabled = (boolean) params[4];
        callback = (InternalImmediateRequestCallback) params[5];
        L = (ModuleLog) params[6];
        if (!networkingIsEnabled) {
            L.w("[ImmediateRequestMaker] ImmediateRequestMaker, Networking config is disabled, request cancelled. Endpoint[" + customEndpoint + "] request[" + requestData + "]");
            return null;
        }
        L.v("[ImmediateRequestMaker] Starting request");
        HttpURLConnection connection = null;
        BufferedReader reader = null;
        boolean wasSuccess = true;
        try {
            L.d("[ImmediateRequestMaker] delayed[" + requestShouldBeDelayed + "] hasCallback[" + (callback != null) + "] endpoint[" + customEndpoint + "] request[" + requestData + "] url[" + cp.getServerURL() + "]");
            if (requestShouldBeDelayed) {
                //used in cases after something has to be done after a device id change
                L.v("[ImmediateRequestMaker] request should be delayed, waiting for 0.5 seconds");
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    L.w("[ImmediateRequestMaker] While waiting for 0.5 seconds in ImmediateRequestMaker, sleep was interrupted");
                }
            }
            //getting connection ready
            try {
                connection = (HttpURLConnection) cp.urlConnectionForServerRequest(requestData, customEndpoint);
            } catch (IOException e) {
                L.e("[ImmediateRequestMaker] IOException while preparing remote config update request :[" + e.toString() + "]");
                return null;
            }
            //connecting
            connection.connect();
            InputStream stream;
            //todo check response code
            try {
                //assume there will be no error
                stream = connection.getInputStream();
            } catch (Exception ex) {
                //in case of exception, assume there was a error in the request
                //and change streams
                stream = connection.getErrorStream();
                wasSuccess = false;
            }
            if (stream == null) {
                L.e("[ImmediateRequestMaker] Encountered problem while making a immediate server request, received stream was null");
                return null;
            }
            //getting result
            reader = new BufferedReader(new InputStreamReader(stream));
            StringBuilder buffer = new StringBuilder();
            String line = "";
            while ((line = reader.readLine()) != null) {
                buffer.append(line).append("\n");
            }
            final String receivedBuffer = buffer.toString();
            if (wasSuccess) {
                L.d("[ImmediateRequestMaker] Received the following response, :[" + receivedBuffer + "]");
                // we check if the result was a json array or json object and convert the array into an object if necessary
                char firstChar = receivedBuffer.trim().charAt(0);
                if (firstChar == '[') {
                    return new JSONObject("{\"jsonArray\":" + receivedBuffer + "}");
                }
                return new JSONObject(receivedBuffer);
            } else {
                L.e("[ImmediateRequestMaker] Encountered problem while making a immediate server request, :[" + receivedBuffer + "]");
                return null;
            }
        } catch (Exception e) {
            L.e("[ImmediateRequestMaker] Received exception while making a immediate server request", e);
        } finally {
            if (connection != null) {
                connection.disconnect();
            }
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException e) {
                L.e("[ImmediateRequestMaker] ", e);
            }
        }
        L.v("[ImmediateRequestMaker] Finished request");
        return null;
    }
    @Override
    protected void onPostExecute(JSONObject result) {
        super.onPostExecute(result);
        L.v("[ImmediateRequestMaker] onPostExecute");
        if (callback != null) {
            callback.callback(result);
        }
    }
}
package ly.count.android.sdk;
import android.app.Application;
import android.content.Context;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
public class CountlyConfig {
    /**
     * Internal fields and fields for testing
     */
    protected CountlyStore countlyStore = null;
    /**
     * Used to pass the consent provider to all modules and features
     */
    protected ConsentProvider consentProvider = null;
    /**
     * Used to pass the storage provider to all modules and features
     */
    protected StorageProvider storageProvider = null;
    protected EventProvider eventProvider = null;
    protected EventQueueProvider eventQueueProvider = null;
    protected RequestQueueProvider requestQueueProvider = null;
    protected DeviceIdProvider deviceIdProvider = null;
    protected ViewIdProvider viewIdProvider = null;
    protected BaseInfoProvider baseInfoProvider = null;
    protected ConfigurationProvider configProvider = null;
    protected SafeIDGenerator safeViewIDGenerator = null;
    protected SafeIDGenerator safeEventIDGenerator = null;
    protected ImmediateRequestGenerator immediateRequestGenerator = null;
    protected HealthTracker healthTracker;
    protected MetricProvider metricProviderOverride = null;
    protected DeviceInfo deviceInfo = null;
    protected ModuleBase testModuleListener = null;
    protected Map<String, Object> providedUserProperties = null;
    protected Countly.LifecycleObserver lifecycleObserver = null;
    //used to deliver this object to connection queue
    //protected DeviceId deviceIdInstance = null;
    // Fields used for SDK configuration during init
    /**
     * Android context.
     * Mandatory field.
     */
    protected Context context = null;
    /**
     * URL of the Countly server to submit data to.
     * Mandatory field.
     */
    protected String serverURL = null;
    /**
     * app key for the application being tracked; find in the Countly Dashboard under Management &gt; Applications.
     * Mandatory field.
     */
    protected String appKey = null;
    /**
     * unique ID for the device the app is running on; note that null in deviceID means that Countly will fall back to OpenUDID, then, if it's not available, to Google Advertising ID.
     */
    protected String deviceID = null;
    /**
     * sets the limit after how many sessions, for each apps version, the automatic star rating dialog is shown.
     */
    protected int starRatingSessionLimit = 5;
    /**
     * the callback function that will be called from the automatic star rating dialog.
     */
    protected StarRatingCallback starRatingCallback = null;
    /**
     * the shown title text for the star rating dialogs.
     */
    protected String starRatingTextTitle = null;
    /**
     * the shown message text for the star rating dialogs.
     */
    protected String starRatingTextMessage = null;
    /**
     * the shown dismiss button text for the shown star rating dialogs.
     */
    protected String starRatingTextDismiss = null;
    protected boolean loggingEnabled = false;
    protected boolean enableAutomaticViewTracking = false;
    protected boolean autoTrackingUseShortName = false;
    protected Class[] automaticViewTrackingExceptions = null;
    protected Map<String, Object> globalViewSegmentation = null;
    protected Map<String, String> customNetworkRequestHeaders = null;
    protected boolean pushIntentAddMetadata = false;
    protected boolean enableRemoteConfigAutomaticDownloadTriggers = false;
    protected boolean enableAutoEnrollFlag = false;
    boolean enableRemoteConfigValueCaching = false;
    protected RemoteConfigCallback remoteConfigCallbackLegacy = null;
    protected List<RCDownloadCallback> remoteConfigGlobalCallbackList = new ArrayList<>(2);
    protected boolean shouldRequireConsent = false;
    protected boolean enableAllConsents = false;
    protected String[] enabledFeatureNames = null;
    protected boolean httpPostForced = false;
    protected boolean temporaryDeviceIdEnabled = false;
    protected String tamperingProtectionSalt = null;
    protected Integer eventQueueSizeThreshold = null;
    protected boolean trackOrientationChange = true;
    protected boolean manualSessionControlEnabled = false;
    protected boolean manualSessionControlHybridModeEnabled = false;
    protected boolean disableUpdateSessionRequests = false;
    protected boolean shouldIgnoreAppCrawlers = false;
    protected String[] appCrawlerNames = null;
    protected String[] publicKeyPinningCertificates = null;
    protected String[] certificatePinningCertificates = null;
    protected Integer sessionUpdateTimerDelay = null;
    /**
     * @deprecated This is deprecated, will be removed in the future
     */
    protected CrashFilterCallback crashFilterCallback;
    protected boolean starRatingDialogIsCancellable = false;
    protected boolean starRatingShownAutomatically = false;
    protected boolean starRatingDisableAskingForEachAppVersion = false;
    protected Application application = null;
    boolean disableLocation = false;
    String locationCountyCode = null;
    String locationCity = null;
    String locationLocation = null;
    String locationIpAddress = null;
    Map<String, String> metricOverride = null;
    int maxRequestQueueSize = 1000;
    ModuleLog.LogCallback providedLogCallback;
    String daCampaignType = null;
    String daCampaignData = null;
    Map<String, String> iaAttributionValues = null;
    boolean explicitStorageModeEnabled = false;
    boolean serverConfigurationEnabled = false;
    boolean healthCheckEnabled = true;
    // Requests older than this value in hours would be dropped (0 means this feature is disabled)
    int dropAgeHours = 0;
    /**
     * THIS VARIABLE SHOULD NOT BE USED
     * IT IS ONLY FOR INTERNAL TESTING
     * BREAKING CHANGES WILL BE DONE WITHOUT WARNING
     */
    public PerformanceCounterCollector pcc;
    /**
     * Sets how many segmentation values can be recorded when recording an event or view.
     * Values exceeding this count will be ignored.
     *
     * @param maxSegmentationValues to set
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>sdkInternalLimits.setMaxSegmentationValues(int)</pre> instead
     */
    public synchronized CountlyConfig setMaxSegmentationValues(int maxSegmentationValues) {
        sdkInternalLimits.setMaxSegmentationValues(maxSegmentationValues);
        return this;
    }
    /**
     * Set the maximum amount of breadcrumbs that can be recorded.
     * After exceeding the limit, the oldest values will be removed.
     *
     * @param maxBreadcrumbCount to set
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>sdkInternalLimits.setMaxBreadcrumbCount(int)</pre> instead
     */
    public synchronized CountlyConfig setMaxBreadcrumbCount(int maxBreadcrumbCount) {
        sdkInternalLimits.setMaxBreadcrumbCount(maxBreadcrumbCount);
        return this;
    }
    public CountlyConfig() {
    }
    /**
     * @param context
     * @param appKey
     * @param serverURL
     */
    public CountlyConfig(Context context, String appKey, String serverURL) {
        setContext(context);
        setAppKey(appKey);
        setServerURL(serverURL);
    }
    public CountlyConfig(Application application, String appKey, String serverURL) {
        setAppKey(appKey);
        setServerURL(serverURL);
        setApplication(application);
    }
    /**
     * Android context.
     * Mandatory field.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setContext(Context context) {
        this.context = context;
        return this;
    }
    /**
     * URL of the Countly server to submit data to.
     * Mandatory field.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setServerURL(String serverURL) {
        this.serverURL = serverURL;
        return this;
    }
    /**
     * app key for the application being tracked; find in the Countly Dashboard under Management &gt; Applications.
     * Mandatory field.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setAppKey(String appKey) {
        this.appKey = appKey;
        return this;
    }
    /**
     * unique ID for the device the app is running on; note that null in deviceID means that Countly will fall back to OpenUDID, then, if it's not available, to Google Advertising ID.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setDeviceId(String deviceID) {
        this.deviceID = deviceID;
        return this;
    }
    /**
     * enum value specifying which device ID generation strategy Countly should use: OpenUDID or Google Advertising ID.
     *
     * @return Returns the same config object for convenient linking
     * @deprecated this call should not be used anymore as it does not have any purpose anymore
     */
    public synchronized CountlyConfig setIdMode(DeviceIdType idMode) {
        return this;
    }
    /**
     * sets the limit after how many sessions, for each apps version, the automatic star rating dialog is shown.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingSessionLimit(int starRatingLimit) {
        this.starRatingSessionLimit = starRatingLimit;
        return this;
    }
    /**
     * the callback function that will be called from the automatic star rating dialog.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingCallback(StarRatingCallback starRatingCallback) {
        this.starRatingCallback = starRatingCallback;
        return this;
    }
    /**
     * the shown title text for the star rating dialogs.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingTextTitle(String starRatingTextTitle) {
        this.starRatingTextTitle = starRatingTextTitle;
        return this;
    }
    /**
     * the shown message text for the star rating dialogs.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingTextMessage(String starRatingTextMessage) {
        this.starRatingTextMessage = starRatingTextMessage;
        return this;
    }
    /**
     * the shown dismiss button text for the shown star rating dialogs.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingTextDismiss(String starRatingTextDismiss) {
        this.starRatingTextDismiss = starRatingTextDismiss;
        return this;
    }
    /**
     * Set to true of you want to enable countly internal debugging logs
     * Those logs will be printed to the console
     *
     * @param enabled Set to true of you want to enable countly internal debugging logs
     */
    public synchronized CountlyConfig setLoggingEnabled(boolean enabled) {
        this.loggingEnabled = enabled;
        return this;
    }
    /**
     * Call to enable uncaught crash reporting
     *
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, please use <pre>crashes.enableCrashReporting()</pre> instead
     */
    public synchronized CountlyConfig enableCrashReporting() {
        crashes.enableCrashReporting();
        return this;
    }
    /**
     * Set if automatic view tracking should be enabled
     *
     * @param enable
     * @return Returns the same config object for convenient linking
     * @deprecated Use "enableAutomaticViewTracking()"
     */
    public synchronized CountlyConfig setViewTracking(boolean enable) {
        this.enableAutomaticViewTracking = enable;
        return this;
    }
    /**
     * Enable automatic view tracking
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableAutomaticViewTracking() {
        this.enableAutomaticViewTracking = true;
        return this;
    }
    /**
     * Enable short names for automatic view tracking
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableAutomaticViewShortNames() {
        this.autoTrackingUseShortName = true;
        return this;
    }
    /**
     * Set if automatic activity tracking should use short names
     *
     * @param enable set true if you want short names
     * @return Returns the same config object for convenient linking
     * @deprecated use "enableAutomaticViewShortNames()"
     */
    public synchronized CountlyConfig setAutoTrackingUseShortName(boolean enable) {
        this.autoTrackingUseShortName = enable;
        return this;
    }
    /**
     * @param segmentation segmentation values that will be added for all recorded views (manual and automatic)
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setGlobalViewSegmentation(Map<String, Object> segmentation) {
        globalViewSegmentation = segmentation;
        return this;
    }
    /**
     * @param segmentation
     * @return Returns the same config object for convenient linking
     * @deprecated please use "setGlobalViewSegmentation(Map<String, Object>)"
     */
    public synchronized CountlyConfig setAutomaticViewSegmentation(Map<String, Object> segmentation) {
        globalViewSegmentation = segmentation;
        return this;
    }
    /**
     * Set which activities should be excluded from automatic view tracking
     *
     * @param exclusions activities which should be ignored
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setAutomaticViewTrackingExclusions(Class[] exclusions) {
        if (exclusions != null) {
            for (Class exception : exclusions) {
                if (exception == null) {
                    throw new IllegalArgumentException("setAutomaticViewTrackingExclusions(...) does not accept 'null' activities");
                }
            }
        }
        automaticViewTrackingExceptions = exclusions;
        return this;
    }
    /**
     * Set which activities should be excluded from automatic view tracking
     *
     * @param exceptions activities which should be ignored
     * @return Returns the same config object for convenient linking
     * @deprecated Use "setAutomaticViewTrackingExclusions(Class[])"
     */
    public synchronized CountlyConfig setAutoTrackingExceptions(Class[] exceptions) {
        return setAutomaticViewTrackingExclusions(exceptions);
    }
    /**
     * Allows you to add custom header key/value pairs to each request
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig addCustomNetworkRequestHeaders(Map<String, String> customHeaderValues) {
        this.customNetworkRequestHeaders = customHeaderValues;
        return this;
    }
    /**
     * @param enable
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setPushIntentAddMetadata(boolean enable) {
        pushIntentAddMetadata = enable;
        return this;
    }
    /**
     * If enable, will automatically download newest remote config values.
     *
     * @param enabled set true for enabling it
     * @param callback callback called after the update was done
     * @return Returns the same config object for convenient linking
     * @deprecated use "enableRemoteConfigAutomaticTriggers" and "RemoteConfigRegisterGlobalCallback" in it's place
     */
    public synchronized CountlyConfig setRemoteConfigAutomaticDownload(boolean enabled, RemoteConfigCallback callback) {
        enableRemoteConfigAutomaticDownloadTriggers = enabled;
        remoteConfigCallbackLegacy = callback;
        return this;
    }
    /**
     * Calling this would enable automatic download triggers for remote config.
     * This way the SDK would automatically initiate remote config download at specific points.
     * For example, those include: the SDK finished initializing, device ID is changed, consent is given
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableRemoteConfigAutomaticTriggers() {
        enableRemoteConfigAutomaticDownloadTriggers = true;
        return this;
    }
    /**
     * Calling this would enable automatic enrollment of the user to the available experiments when RC is downloaded.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enrollABOnRCDownload() {
        enableAutoEnrollFlag = true;
        return this;
    }
    /**
     * This would set a time frame in which the requests older than the given hours would be dropped while sending a request
     * Ex: Setting this to 10 would mean any requests created more than 10 hours ago would be dropped if they were in the queue
     *
     * @param dropAgeHours A positive integer. Requests older than the 'dropAgeHours' (with respect to now) would be dropped
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setRequestDropAgeHours(int dropAgeHours) {
        this.dropAgeHours = dropAgeHours;
        return this;
    }
    /**
     * If this option is not enabled then when the device ID is changed without merging, remote config values are cleared
     * If this option is enabled then the previous values are not cleared but they are marked as not from the current user.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableRemoteConfigValueCaching() {
        enableRemoteConfigValueCaching = true;
        return this;
    }
    /**
     * Calling this adds global listeners for remote config download callbacks.
     * Calling this multiple times would add multiple listeners
     *
     * @param callback The callback that needs to be registered
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig RemoteConfigRegisterGlobalCallback(RCDownloadCallback callback) {
        remoteConfigGlobalCallbackList.add(callback);
        return this;
    }
    /**
     * Set if consent should be required
     *
     * @param shouldRequireConsent if set to "true" then the SDK will require consent to be used. If consent for features is not given, they would not function
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setRequiresConsent(boolean shouldRequireConsent) {
        this.shouldRequireConsent = shouldRequireConsent;
        return this;
    }
    /**
     * Sets which features are enabled in case consent is required
     *
     * @param featureNames
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setConsentEnabled(String[] featureNames) {
        enabledFeatureNames = featureNames;
        return this;
    }
    /**
     * Give consent to all features
     *
     * @return
     */
    public synchronized CountlyConfig giveAllConsents() {
        enableAllConsents = true;
        return this;
    }
    /**
     * Set the override for forcing to use HTTP POST for all connections to the server
     *
     * @param isForced the flag for the new status, set "true" if you want it to be forced
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setHttpPostForced(boolean isForced) {
        httpPostForced = isForced;
        return this;
    }
    /**
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableTemporaryDeviceIdMode() {
        temporaryDeviceIdEnabled = true;
        return this;
    }
    /**
     * @param callback
     * @return Returns the same config object for convenient linking
     * @deprecated This call is deprecated, please use <pre>crashes.setGlobalCrashFilterCallback(GlobalCrashFilterCallback)</pre> instead
     */
    public synchronized CountlyConfig setCrashFilterCallback(CrashFilterCallback callback) {
        crashFilterCallback = callback;
        return this;
    }
    /**
     * @param salt
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setParameterTamperingProtectionSalt(String salt) {
        tamperingProtectionSalt = salt;
        return this;
    }
    /**
     * @param shouldTrackOrientation
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setTrackOrientationChanges(boolean shouldTrackOrientation) {
        trackOrientationChange = shouldTrackOrientation;
        return this;
    }
    /**
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, please use <pre>crashes.enableRecordAllThreadsWithCrash()</pre> instead
     */
    public synchronized CountlyConfig setRecordAllThreadsWithCrash() {
        crashes.enableRecordAllThreadsWithCrash();
        return this;
    }
    /**
     * Set if attribution should be enabled
     *
     * @param enableAttribution set true if you want to enable it, set false if you want to disable it
     * @return Returns the same config object for convenient linking
     * @deprecated This call will not do anything anymore. Use 'setDirectAttribution' or 'setIndirectAttribution' for attribution purposes
     */
    public synchronized CountlyConfig setEnableAttribution(boolean enableAttribution) {
        return this;
    }
    /**
     * Allows public key pinning.
     * Supply list of SSL certificates (base64-encoded strings between "-----BEGIN CERTIFICATE-----" and "-----END CERTIFICATE-----" without end-of-line)
     * along with server URL starting with "https://". Countly will only accept connections to the server
     * if public key of SSL certificate provided by the server matches one provided to this method.
     *
     * @param certificates List of SSL public keys
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enablePublicKeyPinning(String[] certificates) {
        publicKeyPinningCertificates = certificates;
        return this;
    }
    /**
     * Allows certificate pinning.
     * Supply list of SSL certificates (base64-encoded strings between "-----BEGIN CERTIFICATE-----" and "-----END CERTIFICATE-----" without end-of-line)
     * along with server URL starting with "https://". Countly will only accept connections to the server
     * if certificate provided by the server matches one provided to this method.
     *
     * @param certificates List of SSL certificates
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableCertificatePinning(String[] certificates) {
        certificatePinningCertificates = certificates;
        return this;
    }
    /**
     * Set if Countly SDK should ignore app crawlers
     *
     * @param shouldIgnore if crawlers should be ignored
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setShouldIgnoreAppCrawlers(boolean shouldIgnore) {
        shouldIgnoreAppCrawlers = shouldIgnore;
        return this;
    }
    /**
     * List of app crawler names that should be ignored
     *
     * @param appCrawlerNames the names to be ignored
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setAppCrawlerNames(String[] appCrawlerNames) {
        this.appCrawlerNames = appCrawlerNames;
        return this;
    }
    /**
     * Set the threshold for event grouping. Event count that is bellow the
     * threshold will be sent on update ticks.
     *
     * @param threshold
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setEventQueueSizeToSend(int threshold) {
        eventQueueSizeThreshold = threshold;
        return this;
    }
    public synchronized CountlyConfig enableManualSessionControl() {
        manualSessionControlEnabled = true;
        return this;
    }
    public synchronized CountlyConfig enableManualSessionControlHybridMode() {
        manualSessionControlHybridModeEnabled = true;
        return this;
    }
    /**
     * Set custom crash segmentation which will be added to all recorded crashes
     *
     * @param crashSegment segmentation information. Accepted values are "Integer", "String", "Double", "Boolean"
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, please use <pre>crashes.setCustomCrashSegmentation(Map<String, Object>)</pre> instead
     */
    public synchronized CountlyConfig setCustomCrashSegment(Map<String, Object> crashSegment) {
        crashes.setCustomCrashSegmentation(crashSegment);
        return this;
    }
    /**
     * For use during testing
     *
     * @param checkForDumps whether to check for native crash dumps
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated and will always be enabled
     */
    protected synchronized CountlyConfig checkForNativeCrashDumps(boolean checkForDumps) {
        return this;
    }
    /**
     * Sets the interval for the automatic session update calls
     * min value 1 (1 second)
     *
     * @param delay in seconds
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setUpdateSessionTimerDelay(int delay) {
        sessionUpdateTimerDelay = delay;
        return this;
    }
    /**
     * For use during testing
     *
     * @param store
     * @return Returns the same config object for convenient linking
     */
    protected synchronized CountlyConfig setCountlyStore(CountlyStore store) {
        countlyStore = store;
        return this;
    }
    /**
     * Disable periodic session time updates.
     * By default, Countly will send a request to the server each 60 seconds with a small update
     * containing session duration time. This method allows you to disable such behavior.
     * Note that event updates will still be sent every 100 events or 60 seconds after event recording.
     *
     * @param disable whether or not to disable session time updates
     * @return Returns the same config object for convenient linking
     */
    protected synchronized CountlyConfig setDisableUpdateSessionRequests(boolean disable) {
        disableUpdateSessionRequests = disable;
        return this;
    }
    /**
     * Set if the star rating dialog is cancellable
     *
     * @param isCancellable set this true if it should be cancellable
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setIfStarRatingDialogIsCancellable(boolean isCancellable) {
        starRatingDialogIsCancellable = isCancellable;
        return this;
    }
    /**
     * Set if the star rating should be shown automatically
     *
     * @param isShownAutomatically set it true if you want to show the app star rating dialog automatically for each new version after the specified session amount
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setIfStarRatingShownAutomatically(boolean isShownAutomatically) {
        starRatingShownAutomatically = isShownAutomatically;
        return this;
    }
    /**
     * Set if the star rating is shown only once per app lifetime
     *
     * @param disableAsking set true if you want to disable asking the app rating for each new app version (show it only once per apps lifetime)
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setStarRatingDisableAskingForEachAppVersion(boolean disableAsking) {
        starRatingDisableAskingForEachAppVersion = disableAsking;
        return this;
    }
    /**
     * Set the link to the application class
     *
     * @param application
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setApplication(Application application) {
        this.application = application;
        return this;
    }
    /**
     * Enable the recording of the app start time
     *
     * @param recordAppStartTime set true if you want to enable the recording of the app start time
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>apm.enableAppStartTracking()</pre> instead
     */
    public synchronized CountlyConfig setRecordAppStartTime(boolean recordAppStartTime) {
        apm.trackAppStartTime = recordAppStartTime;
        return this;
    }
    /**
     * Disable location tracking
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setDisableLocation() {
        disableLocation = true;
        return this;
    }
    /**
     * Set location parameters.
     * This will be ignored if set together with `setDisableLocation`
     *
     * @param country_code ISO Country code for the user's country
     * @param city Name of the user's city
     * @param gpsCoordinates comma separate lat and lng values. For example, "56.42345,123.45325"
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setLocation(String country_code, String city, String gpsCoordinates, String ipAddress) {
        locationCountyCode = country_code;
        locationCity = city;
        locationLocation = gpsCoordinates;
        locationIpAddress = ipAddress;
        return this;
    }
    /**
     * Set the metrics you want to override or additional custom metrics you want to provide
     *
     * @param providedMetricOverride
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setMetricOverride(Map<String, String> providedMetricOverride) {
        metricOverride = providedMetricOverride;
        return this;
    }
    /**
     * Override the app start timestamp in case you have a more precise way to measure it
     *
     * @param appStartTimestampOverride The timestamp to use as the app start timestamp
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>apm.setAppStartTimestampOverride()</pre> instead
     */
    public synchronized CountlyConfig setAppStartTimestampOverride(long appStartTimestampOverride) {
        apm.setAppStartTimestampOverride(appStartTimestampOverride);
        return this;
    }
    /**
     * Set to manually trigger the moment when the app has finished loading
     *
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated, use <pre>apm.enableManualAppLoadedTrigger()</pre> instead
     */
    public synchronized CountlyConfig enableManualAppLoadedTrigger() {
        apm.enableManualAppLoadedTrigger();
        return this;
    }
    /**
     * Set this in case you want to control these triggers manually
     *
     * @return Returns the same config object for convenient linking
     * @deprecated this call is deprecated and will be removed in the future
     */
    public synchronized CountlyConfig enableManualForegroundBackgroundTriggerAPM() {
        apm.manualForegroundBackgroundTrigger = true;
        return this;
    }
    /**
     * Add a log callback that will duplicate all logs done by the SDK.
     * For each message you will receive the message string and it's targeted log level.
     *
     * @param logCallback
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setLogListener(ModuleLog.LogCallback logCallback) {
        providedLogCallback = logCallback;
        return this;
    }
    /**
     * Set's the new maximum size for the request queue.
     *
     * @param newMaxSize Minimum value is "1".
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setMaxRequestQueueSize(int newMaxSize) {
        maxRequestQueueSize = newMaxSize;
        return this;
    }
    /**
     * Report direct user attribution
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setDirectAttribution(String campaignType, String campaignData) {
        daCampaignType = campaignType;
        daCampaignData = campaignData;
        return this;
    }
    /**
     * Report indirect user attribution
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setIndirectAttribution(Map<String, String> attributionValues) {
        iaAttributionValues = attributionValues;
        return this;
    }
    /**
     * Used to provide user properties that would be sent as soon as possible
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig setUserProperties(Map<String, Object> userProperties) {
        providedUserProperties = userProperties;
        return this;
    }
    /**
     * If this mode is enabled then the SDK not write the request and event queues to disk
     * until the explicit write signal is given.
     *
     * The explicit write signal is given with:
     * 'Countly.sharedInstance().requestQueue().esWriteCachesToPersistence();'
     *
     * If not used properly, this mode will lead to data loss or data duplication.
     *
     * @return Returns the same config object for convenient linking
     */
    public synchronized CountlyConfig enableExplicitStorageMode() {
        explicitStorageModeEnabled = true;
        return this;
    }
    /**
     * This is an experimental feature and it can have breaking changes
     *
     * With this mode enable, the SDK will acquire additional configuration from it's Countly server
     *
     * @return Returns the same config object for convenient linking
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public synchronized CountlyConfig enableServerConfiguration() {
        serverConfigurationEnabled = true;
        return this;
    }
    protected synchronized CountlyConfig disableHealthCheck() {
        healthCheckEnabled = false;
        return this;
    }
    /**
     * APM configuration interface to be used with CountlyConfig
     */
    public final ConfigApm apm = new ConfigApm();
    /**
     * SDK Internal Limits configuration interface to be used with CountlyConfig
     */
    public final ConfigSdkInternalLimits sdkInternalLimits = new ConfigSdkInternalLimits();
    /**
     * Crash Reporting configuration interface to be used with CountlyConfig
     */
    public final ConfigCrashes crashes = new ConfigCrashes();
    /**
     * Content configuration interface to be used with CountlyConfig
     *
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public final ConfigContent content = new ConfigContent();
    /**
     * Experimental configuration interface to be used with CountlyConfig
     *
     * @apiNote This is an EXPERIMENTAL feature, and it can have breaking changes
     */
    public final ConfigExperimental experimental = new ConfigExperimental();
}
/*
Copyright (c) 2012, 2013, 2014 Countly
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
package ly.count.android.sdk;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.Map;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import org.json.JSONException;
import org.json.JSONObject;
/**
 * ConnectionProcessor is a Runnable that is executed on a background
 * thread to submit session &amp; event data to a Count.ly server.
 *
 * NOTE: This class is only public to facilitate unit testing, because
 * of this bug in dexmaker: https://code.google.com/p/dexmaker/issues/detail?id=34
 */
public class ConnectionProcessor implements Runnable {
    private static final int CONNECT_TIMEOUT_IN_MILLISECONDS = 30_000;
    private static final int READ_TIMEOUT_IN_MILLISECONDS = 30_000;
    private static final String CRLF = "\r\n";
    private static final String charset = "UTF-8";
    private final StorageProvider storageProvider_;
    private final DeviceIdProvider deviceIdProvider_;
    final ConfigurationProvider configProvider_;
    HealthTracker healthTracker;
    final RequestInfoProvider requestInfoProvider_;
    private final String serverURL_;
    private final SSLContext sslContext_;
    private final Map<String, String> requestHeaderCustomValues_;
    static String endPointOverrideTag = "&new_end_point=";
    ModuleLog L;
    public PerformanceCounterCollector pcc;
    private enum RequestResult {
        OK,         // success
        RETRY       // retry MAX_RETRIES_BEFORE_SLEEP before switching to SLEEP
    }
    ConnectionProcessor(final String serverURL, final StorageProvider storageProvider, final DeviceIdProvider deviceIdProvider, final ConfigurationProvider configProvider,
        final RequestInfoProvider requestInfoProvider, final SSLContext sslContext, final Map<String, String> requestHeaderCustomValues, ModuleLog logModule,
        HealthTracker healthTracker) {
        serverURL_ = serverURL;
        storageProvider_ = storageProvider;
        deviceIdProvider_ = deviceIdProvider;
        configProvider_ = configProvider;
        sslContext_ = sslContext;
        requestHeaderCustomValues_ = requestHeaderCustomValues;
        requestInfoProvider_ = requestInfoProvider;
        L = logModule;
        this.healthTracker = healthTracker;
    }
    synchronized public @NonNull URLConnection urlConnectionForServerRequest(@NonNull String requestData, @Nullable final String customEndpoint) throws IOException {
        String urlEndpoint = "/i";
        if (customEndpoint != null) {
            urlEndpoint = customEndpoint;
        }
        // determine whether or not request has a binary image file, if it has request will be sent as POST request
        boolean hasPicturePath = requestData.contains(ModuleUserProfile.PICTURE_PATH_KEY);
        boolean usingHttpPost = requestData.contains("&crash=") || requestData.length() >= 2048 || requestInfoProvider_.isHttpPostForced() || hasPicturePath;
        long approximateDateSize = 0L;
        String urlStr = serverURL_ + urlEndpoint;
        if (usingHttpPost) {
            // for binary images, checksum will be calculated without url encoded value of the requestData
            // because they sent as form-data and server calculates it that way
            if (!hasPicturePath) {
                String checksum = UtilsNetworking.sha256Hash(requestData + requestInfoProvider_.getRequestSalt());
                requestData += "&checksum256=" + checksum;
                L.v("[ConnectionProcessor] The following checksum was added:[" + checksum + "]");
                approximateDateSize += requestData.length(); // add request data to the estimated data size
            }
        } else {
            urlStr += "?" + requestData;
            String checksum = UtilsNetworking.sha256Hash(requestData + requestInfoProvider_.getRequestSalt());
            urlStr += "&checksum256=" + checksum;
            L.v("[ConnectionProcessor] The following checksum was added:[" + checksum + "]");
        }
        approximateDateSize += urlStr.length();
        final URL url = new URL(urlStr);
        final HttpURLConnection conn;
        long pccTsOpenURLConnection = 0L;
        long pccTsConfigureConnection = 0L;
        long pccTsStartHeaderFieldSize = 0L;
        if (pcc != null) {
            pccTsOpenURLConnection = UtilsTime.getNanoTime();
        }
        if (Countly.publicKeyPinCertificates == null && Countly.certificatePinCertificates == null) {
            conn = (HttpURLConnection) url.openConnection();
        } else {
            HttpsURLConnection c = (HttpsURLConnection) url.openConnection();
            c.setSSLSocketFactory(sslContext_.getSocketFactory());
            conn = c;
        }
        if (pcc != null) {
            long openUrlConnectionTime = UtilsTime.getNanoTime() - pccTsOpenURLConnection;
            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_01_OpenURLConnection", openUrlConnectionTime);
            pccTsConfigureConnection = UtilsTime.getNanoTime();
        }
        conn.setConnectTimeout(CONNECT_TIMEOUT_IN_MILLISECONDS);
        conn.setReadTimeout(READ_TIMEOUT_IN_MILLISECONDS);
        conn.setUseCaches(false);
        conn.setDoInput(true);
        conn.setRequestMethod("GET");
        if (requestHeaderCustomValues_ != null) {
            //if there are custom header values, add them
            L.v("[ConnectionProcessor] Adding [" + requestHeaderCustomValues_.size() + "] custom header fields");
            for (Map.Entry<String, String> entry : requestHeaderCustomValues_.entrySet()) {
                String key = entry.getKey();
                String value = entry.getValue();
                if (key != null && value != null && !key.isEmpty()) {
                    conn.addRequestProperty(key, value);
                }
            }
        }
        L.v("[ConnectionProcessor] Has picturePath [" + hasPicturePath + "]");
        if (hasPicturePath) {
            String boundary = Long.toHexString(System.currentTimeMillis());// Just generate some unique random value as the boundary
            conn.setDoOutput(true);
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Content-Type", "multipart/form-data; boundary=" + boundary);// Line separator required by multipart/form-data.
            OutputStream output = conn.getOutputStream(); // setup streams for form-data writing
            PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, charset), true);
            String[] params = requestData.split("&"); // split request data by key value pairs
            for (String key : params) {
                String[] kv = key.split("=");
                approximateDateSize += 4 + boundary.length(); // 4 is the length of the static parts of the entry
                String param = kv[0];
                String value = UtilsNetworking.urlDecodeString(kv[1]);
                if (param.equals(ModuleUserProfile.PICTURE_PATH_KEY)) {
                    approximateDateSize += addFileMultipart(output, writer, value, boundary);
                }
                approximateDateSize += addTextMultipart(writer, param, value, boundary);
            }
            approximateDateSize += 4 + boundary.length(); // 4 is the length of the static parts of the entry
            approximateDateSize += addTextMultipart(writer, "checksum256", UtilsNetworking.sha256Hash(UtilsNetworking.urlDecodeString(requestData) + requestInfoProvider_.getRequestSalt()), boundary);
            // End of multipart/form-data.
            writer.append("--").append(boundary).append("--").append(CRLF).flush();
            approximateDateSize += 6 + boundary.length(); // 6 is the length of the static parts of the entry
        } else {
            if (usingHttpPost) {
                conn.setDoOutput(true);
                conn.setRequestMethod("POST");
                conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
                OutputStream os = conn.getOutputStream();
                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, charset));
                writer.write(requestData);
                writer.flush();
                writer.close();
                os.close();
            } else {
                L.v("[ConnectionProcessor] Using HTTP GET");
                conn.setDoOutput(false);
            }
        }
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_02_ConfigureConnection", UtilsTime.getNanoTime() - pccTsConfigureConnection);
            pccTsStartHeaderFieldSize = UtilsTime.getNanoTime();
        }
        //calculating header field size
        try {
            //just after init, because of background operations, this might fail
            // HttpUrl::Builder of okhttp might give null pointer error because it may not be initialized yet
            int headerIndex = 0;
            while (true) {
                String key = conn.getHeaderFieldKey(headerIndex);
                if (key == null) {
                    break;
                }
                String value = conn.getHeaderField(headerIndex++);
                approximateDateSize += key.getBytes("US-ASCII").length + value.getBytes("US-ASCII").length + 2L;
            }
        } catch (Exception e) {
            L.e("[Connection Processor] urlConnectionForServerRequest, exception while calculating header field size: " + e);
        }
        if (pcc != null) {
            pcc.TrackCounterTimeNs("ConnectionProcessorUrlConnectionForServerRequest_03_HeaderFieldSize", UtilsTime.getNanoTime() - pccTsStartHeaderFieldSize);
        }
        L.v("[ConnectionProcessor] Using HTTP POST: [" + usingHttpPost + "] forced:[" + requestInfoProvider_.isHttpPostForced()
            + "] length:[" + (requestData.length() >= 2048) + "] crash:[" + requestData.contains("&crash=") + "] | Approx data size: [" + approximateDateSize + " B]");
        return conn;
    }
    /**
     * Return the size of the text multipart entry
     *
     * @param writer to write to
     * @param name of the entry
     * @param value of the entry
     * @return size of the entry
     */
    int addTextMultipart(PrintWriter writer, final String name, final String value, final String boundary) {
        writer.append("--").append(boundary).append(CRLF);
        writer.append("Content-Disposition: form-data; name=\"").append(name).append("\"").append(CRLF);
        writer.append(CRLF).append(value).append(CRLF).flush();
        return 49 + boundary.length() + name.length() + value.length(); // 45 is the length of the static parts of the entry
    }
    /**
     * Return the size of the file multipart entry
     *
     * @param output stream to write to
     * @param writer to write to
     * @param filePath of the file
     * @return size of the entry
     * @throws IOException if there is an error while reading the file
     */
    int addFileMultipart(OutputStream output, PrintWriter writer, final String filePath, final String boundary) throws IOException {
        if (Utils.isNullOrEmpty(filePath)) {
            return 0;
        }
        writer.append("--").append(boundary).append(CRLF);
        File file = new File(filePath);
        String contentType = URLConnection.guessContentTypeFromName(file.getName());
        int approximateDataSize = 0;
        writer.append("Content-Disposition: form-data; name=\"file\"; filename=\"").append(file.getName()).append("\"").append(CRLF);
        writer.append("Content-Type: ").append(contentType).append(CRLF);
        writer.append(CRLF).flush();
        try (FileInputStream fileInputStream = new FileInputStream(file)) {
            // write file to the buffer and stream
            byte[] buffer = new byte[1024];
            int len;
            try {
                while ((len = fileInputStream.read(buffer)) != -1) {
                    output.write(buffer, 0, len);
                    approximateDataSize += len;
                }
            } catch (IOException ex) {
                for (StackTraceElement e : ex.getStackTrace()) {
                    L.e("[ConnectionProcessor] addMultipart, error: " + e);
                }
            }
        }
        output.flush();
        writer.append(CRLF).flush();
        return 82 + boundary.length() + approximateDataSize + file.getName().length() + contentType.length(); // 78 is the length of the static parts of the entry
    }
    @Override
    public void run() {
        long wholeQueueStart = UtilsTime.getNanoTime();
        while (true) {
            long pccTsStartWholeQueue = 0L;
            long pccTsStartOnlyInternet = 0L;
            long pccTsStartTempIdCheck = 0L;
            long pccTsStartEndpointCheck = 0L;
            long pccTsStartOldRCheck = 0L;
            long pccTsStartGetURLConnection;
            long pccTsStartRemainingRequests = 0L;
            long pccTsReadingStream;
            long pccTsStartHandlingResponse;
            if (!configProvider_.getNetworkingEnabled()) {
                L.w("[ConnectionProcessor] run, Networking config is disabled, request queue skipped");
                break;
            }
            //------------------------
            // get stored requests
            final String[] storedRequests = storageProvider_.getRequests();
            int storedRequestCount = storedRequests == null ? 0 : storedRequests.length;
            String msg = "[Connection Processor] Starting to run, there are [" + storedRequestCount + "] requests stored";
            if (storedRequestCount == 0) {
                L.v(msg);
            } else {
                L.i(msg);
            }
            if (storedRequests == null || storedRequestCount == 0) {
                L.i("[ConnectionProcessor] No requests in the queue, request queue skipped");
                // currently no data to send, we are done for now
                break;
            }
            if (deviceIdProvider_.getDeviceId() == null) {
                // When device ID is supplied by OpenUDID or by Google Advertising ID.
                // In some cases it might take time for them to initialize. So, just wait for it.
                L.i("[ConnectionProcessor] No Device ID available yet, skipping request " + storedRequests[0]);
                break;
            }
            // get first request in a separate variable to modify and keep the original intact
            final String originalRequest = storedRequests[0];
            String requestData = originalRequest;//todo rework to another param approach
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_01_GetRequest", UtilsTime.getNanoTime() - pccTsStartWholeQueue);
            }
            //------------------------
            if (pcc != null) {
                pccTsStartOldRCheck = UtilsTime.getNanoTime();
            }
            L.i("[ConnectionProcessor] Checking if the request is older than:[" + requestInfoProvider_.getRequestDropAgeHours() + "] hours");
            boolean isRequestOld = Utils.isRequestTooOld(requestData, requestInfoProvider_.getRequestDropAgeHours(), "[ConnectionProcessor]", L);
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_02_NetworkOldReq", UtilsTime.getNanoTime() - pccTsStartOldRCheck);
            }
            //------------------------
            if (pcc != null) {
                pccTsStartTempIdCheck = UtilsTime.getNanoTime();
            }
            // temp ID checks
            String temporaryIdTag = "&device_id=" + DeviceId.temporaryCountlyDeviceId;
            boolean containsTemporaryId = requestData.contains(temporaryIdTag);
            if (containsTemporaryId || deviceIdProvider_.isTemporaryIdEnabled()) {
                //we are about to change ID to the temporary one or
                //the internally set id is the temporary one
                //abort and wait for exiting temporary mode
                L.i("[ConnectionProcessor] Temporary ID detected, stalling requests. tmp id tag:[" + containsTemporaryId + "], temp ID set:[" + deviceIdProvider_.isTemporaryIdEnabled() + "]");
                break;
            }
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_03_NetworkTempID", UtilsTime.getNanoTime() - pccTsStartTempIdCheck);
            }
            //------------------------
            if (pcc != null) {
                pccTsStartEndpointCheck = UtilsTime.getNanoTime();
            }
            String customEndpoint = null;
            // checks if endPointOverrideTag exists in the eventData, and if so, extracts the endpoint and removes the tag from the evenData
            String[] extractionResult = Utils.extractValueFromString(requestData, endPointOverrideTag, "&");
            if (extractionResult[1] != null) {
                requestData = extractionResult[0];
                if (!extractionResult[1].isEmpty()) {
                    customEndpoint = extractionResult[1];
                }
                L.v("[ConnectionProcessor] Custom end point detected for the request:[" + customEndpoint + "]");
            }
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_04_NetworkCustomEndpoint", UtilsTime.getNanoTime() - pccTsStartEndpointCheck);
            }
            //------------------------
            if (pcc != null) {
                pccTsStartRemainingRequests = UtilsTime.getNanoTime();
            }
            // add the remaining request count
            requestData = requestData + "&rr=" + (storedRequestCount - 1);
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_06_remainingRequests", UtilsTime.getNanoTime() - pccTsStartRemainingRequests);
            }
            //------------------------
            if (!(requestInfoProvider_.isDeviceAppCrawler() && requestInfoProvider_.ifShouldIgnoreCrawlers()) && !isRequestOld) {
                //continue with sending the request to the server
                URLConnection conn = null;
                InputStream connInputStream = null;
                try {
                    pccTsStartGetURLConnection = UtilsTime.getNanoTime();
                    // initialize and open connection
                    conn = urlConnectionForServerRequest(requestData, customEndpoint);
                    long setupServerRequestTime = UtilsTime.getNanoTime() - pccTsStartGetURLConnection;
                    L.d("[ConnectionProcessor] run, TIMING Setup server request took:[" + setupServerRequestTime / 1000000.0d + "] ms");
                    if (pcc != null) {
                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_07_SetupServerRequest", setupServerRequestTime);
                        pccTsStartOnlyInternet = UtilsTime.getNanoTime();
                    }
                    conn.connect();
                    if (pcc != null) {
                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_08_NetworkOnlyInternet", UtilsTime.getNanoTime() - pccTsStartOnlyInternet);
                    }
                    pccTsStartHandlingResponse = UtilsTime.getNanoTime();
                    pccTsReadingStream = UtilsTime.getNanoTime();
                    int responseCode = 0;
                    String responseString = "";
                    if (conn instanceof HttpURLConnection) {
                        final HttpURLConnection httpConn = (HttpURLConnection) conn;
                        try {
                            //assume there will be no error
                            connInputStream = httpConn.getInputStream();
                        } catch (Exception ex) {
                            //in case of exception, assume there was a error in the request and change streams
                            connInputStream = httpConn.getErrorStream();
                        }
                        responseCode = httpConn.getResponseCode();
                        responseString = Utils.inputStreamToString(connInputStream);
                    }
                    long readingStreamTime = UtilsTime.getNanoTime() - pccTsReadingStream;
                    L.d("[Connection Processor] code:[" + responseCode + "], response:[" + responseString + "], response size:[" + responseString.length() + " B], request: " + requestData + ", url: " + serverURL_ + ", Reading stream took:[" + readingStreamTime / 1000000.0d + "] ms");
                    if (pcc != null) {
                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_13_ReadingStream", readingStreamTime);
                    }
                    final RequestResult rRes;
        
                    if (responseCode >= 200 && responseCode < 300) {
                        if (responseString.isEmpty()) {
                            L.v("[ConnectionProcessor] Response was empty, will retry");
                            rRes = RequestResult.RETRY;
                        } else {
                            JSONObject jsonObject;
                            try {
                                jsonObject = new JSONObject(responseString);
                            } catch (JSONException ex) {
                                //failed to parse, so not a valid json
                                jsonObject = null;
                                L.e("[ConnectionProcessor] Failed to parse response [" + responseString + "].");
                            }
                            if (jsonObject == null) {
                                //received unparseable response, retrying
                                L.v("[ConnectionProcessor] Response was a unknown, will retry");
                                rRes = RequestResult.RETRY;
                            } else {
                                if (jsonObject.has("result")) {
                                    //contains result entry
                                    L.v("[ConnectionProcessor] Response was a success");
                                    rRes = RequestResult.OK;
                                } else {
                                    L.v("[ConnectionProcessor] Response does not contain 'result', will retry");
                                    rRes = RequestResult.RETRY;
                                }
                            }
                        }
                    } else if (responseCode >= 300 && responseCode < 400) {
                        //assume redirect
                        L.d("[ConnectionProcessor] Encountered redirect, will retry");
                        rRes = RequestResult.RETRY;
                    } else if (responseCode == 400 || responseCode == 404) {
                        L.w("[ConnectionProcessor] Bad request, will still retry");
                        rRes = RequestResult.RETRY;
                    } else if (responseCode > 400) {
                        //server down, try again later
                        L.d("[ConnectionProcessor] Server is down, will retry");
                        rRes = RequestResult.RETRY;
                    } else {
                        L.d("[ConnectionProcessor] Bad response code, will retry");
                        rRes = RequestResult.RETRY;
                    }
                    // an 'if' needs to be used here so that a 'switch' statement does not 'eat' the 'break' call
                    // that is used to get out of the request loop
                    if (rRes == RequestResult.OK) {
                        // successfully submitted event data to Count.ly server, so remove
                        // this one from the stored events collection
                        storageProvider_.removeRequest(originalRequest);
                    } else {
                        // will retry later
                        // warning was logged above, stop processing, let next tick take care of retrying
                        healthTracker.logFailedNetworkRequest(responseCode, responseString);//notify the health tracker of the issue
                        healthTracker.saveState();
                        if (pcc != null) {
                            pcc.TrackCounterTimeNs("ConnectionProcessorRun_12_FailedRequest", UtilsTime.getNanoTime() - pccTsStartWholeQueue);
                        }
                        break;
                    }
                } catch (Exception e) {
                    L.d("[ConnectionProcessor] Got exception while trying to submit request data: [" + requestData + "] [" + e + "]");
                    // if exception occurred, stop processing, let next tick take care of retrying
                    if (pcc != null) {
                        pcc.TrackCounterTimeNs("ConnectionProcessorRun_11_NetworkWholeQueueException", UtilsTime.getNanoTime() - pccTsStartWholeQueue);
                    }
                    break;
                } finally {
                    // free connection resources
                    if (conn instanceof HttpURLConnection) {
                        try {
                            if (connInputStream != null) {
                                connInputStream.close();
                            }
                        } catch (Throwable ignored) {
                        }
                        ((HttpURLConnection) conn).disconnect();
                    }
                }
                long handlingResponseTime = UtilsTime.getNanoTime() - pccTsStartHandlingResponse;
                L.d("[ConnectionProcessor] run, TIMING Handling response took:[" + handlingResponseTime / 1000000.0d + "] ms");
                if (pcc != null) {
                    pcc.TrackCounterTimeNs("ConnectionProcessorRun_09_HandlingResponse", handlingResponseTime);
                }
            } else {
                //device is identified as a app crawler and nothing is sent to the server
                if (isRequestOld) {
                    L.i("[ConnectionProcessor] request is too old, removing request " + originalRequest);
                } else {
                    L.i("[ConnectionProcessor] Device identified as an app crawler, removing request " + originalRequest);
                }
                //remove stored data
                storageProvider_.removeRequest(originalRequest);
            }
            if (pcc != null) {
                pcc.TrackCounterTimeNs("ConnectionProcessorRun_10_NetworkWholeQueue", UtilsTime.getNanoTime() - pccTsStartWholeQueue);
            }
        }
        long wholeQueueTime = UtilsTime.getNanoTime() - wholeQueueStart;
        L.v("[ConnectionProcessor] run, TIMING Whole queue took:[" + wholeQueueTime / 1000000.0d + "] ms");
    }
    String getServerURL() {
        return serverURL_;
    }
    // for unit testing
    StorageProvider getCountlyStore() {
        return storageProvider_;
    }
}
package ly.count.android.sdk;
import android.app.Activity;
import androidx.annotation.NonNull;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.Map;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import static org.mockito.Mockito.clearInvocations;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
@RunWith(AndroidJUnit4.class)
public class ScenarioEventIDTests {
    int idxV = 0;
    int idxE = 0;
    String[] idV = TestUtils.viewIDVals;//view ID's
    String[] idE = TestUtils.eventIDVals;//event ID's
    final String[] eKeys = TestUtils.eKeys;//event keys
    final String[] vNames = TestUtils.vNames;//view names
    SafeIDGenerator safeViewIDGenerator;
    SafeIDGenerator safeEventIDGenerator;
    Activity act;
    Activity act2;
    @Before
    public void setUp() {
        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
        act = mock(Activity.class);
        act2 = mock(TestUtils.Activity2.class);
        safeViewIDGenerator = new SafeIDGenerator() {
            @NonNull @Override public String GenerateValue() {
                return idV[idxV++];
            }
        };
        safeEventIDGenerator = new SafeIDGenerator() {
            @NonNull @Override public String GenerateValue() {
                return idE[idxE++];
            }
        };
    }
    @After
    public void tearDown() {
    }
    /**
     * Simulate a 2 automatic activity scenario
     * Making sure that ID's are correct
     */
    @Test
    public void eventIDScenario_automaticViews() {
        CountlyConfig cc = TestUtils.createScenarioEventIDConfig(safeViewIDGenerator, safeEventIDGenerator).enableAutomaticViewTracking();
        Countly mCountly = new Countly().init(cc);
        EventQueueProvider eqp = TestUtils.setCreateEventQueueProviderMock(mCountly);
        //no events initially
        verifyRecordEventToEventQueueNotCalled(eqp);
        mCountly.onStartInternal(act);
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[0], null, "", null, 1, 2); // not 1 anymore plus orientation
        clearInvocations(eqp);
        mCountly.onStartInternal(act2);
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[0], null, "", null, 0, 2);
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[1], null, idV[0], null, 1, 2);
        clearInvocations(eqp);
        //custom event 1
        mCountly.events().recordEvent(eKeys[0]);
        verifyRecordEventToEventQueueIDs(eqp, eKeys[0], idE[1], idV[1], null, "", 0, 1);
        clearInvocations(eqp);
        mCountly.onStopInternal();
        verifyRecordEventToEventQueueNotCalled(eqp);
        clearInvocations(eqp);
        //internal event
        mCountly.events().recordEvent(ModuleFeedback.RATING_EVENT_KEY);
        verifyRecordEventToEventQueueIDs(eqp, ModuleFeedback.RATING_EVENT_KEY, idE[2], idV[1], null, null, 0, 1);
        clearInvocations(eqp);
        mCountly.onStopInternal();
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[1], null, idV[0], null, 0, 1);
        clearInvocations(eqp);
        //custom event 2
        mCountly.events().recordEvent(eKeys[1]);
        verifyRecordEventToEventQueueIDs(eqp, eKeys[1], idE[3], idV[1], null, idE[1], 0, 1);
    }
    /**
     * Making sure that the ID's are linked together in a manual view scenario
     */
    @Test
    public void eventIDScenario_manualViews() {
        CountlyConfig cc = TestUtils.createScenarioEventIDConfig(safeViewIDGenerator, safeEventIDGenerator);
        Countly mCountly = new Countly().init(cc);
        EventQueueProvider eqp = TestUtils.setCreateEventQueueProviderMock(mCountly);
        //no events initially
        verifyRecordEventToEventQueueNotCalled(eqp);
        //view A
        mCountly.views().recordView(vNames[0]);
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[0], null, "", null, 0, 1);
        clearInvocations(eqp);
        //view B
        mCountly.views().recordView(vNames[1]);
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[0], null, "", null, 0, 2);
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[1], null, idV[0], null, 1, 2);
        clearInvocations(eqp);
        //custom event 1
        mCountly.events().recordEvent(eKeys[0]);
        verifyRecordEventToEventQueueIDs(eqp, eKeys[0], idE[0], idV[1], null, "", 0, 1);
        clearInvocations(eqp);
        //view C
        mCountly.views().recordView(vNames[2]);
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[1], null, idV[0], null, 0, 2);
        verifyRecordEventToEventQueueIDs(eqp, ModuleViews.VIEW_EVENT_KEY, idV[2], null, idV[1], null, 1, 2);
        clearInvocations(eqp);
        //internal event
        mCountly.events().recordEvent(ModuleEvents.ACTION_EVENT_KEY);
        verifyRecordEventToEventQueueIDs(eqp, ModuleEvents.ACTION_EVENT_KEY, idE[1], idV[2], null, null, 0, 1);
        clearInvocations(eqp);
        //custom event 2
        mCountly.events().recordEvent(eKeys[1]);
        clearInvocations(eqp);
    }
    public static void verifyRecordEventToEventQueueNotCalled(EventQueueProvider eqp) {
        ArgumentCaptor<String> arg01 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<Map> arg02 = ArgumentCaptor.forClass(Map.class);
        ArgumentCaptor<Integer> arg1 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Double> arg2 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Double> arg3 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Long> arg4 = ArgumentCaptor.forClass(Long.class);
        ArgumentCaptor<Integer> arg5 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Integer> arg6 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<String> arg7 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg8 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg9 = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> arg10 = ArgumentCaptor.forClass(String.class);
        verify(eqp, never()).recordEventToEventQueue(arg01.capture(), arg02.capture(), arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), arg7.capture(), arg8.capture(), arg9.capture(), arg10.capture());
    }
    public static void verifyRecordEventToEventQueueIDs(EventQueueProvider eqp, String eventKey, String eventID, String currentViewID, String previousViewID, String previousEventID, int entryIdx, int entryCount) {
        ArgumentCaptor<String> argEventKey = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<Map> arg02 = ArgumentCaptor.forClass(Map.class);
        ArgumentCaptor<Integer> arg1 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Double> arg2 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Double> arg3 = ArgumentCaptor.forClass(Double.class);
        ArgumentCaptor<Long> arg4 = ArgumentCaptor.forClass(Long.class);
        ArgumentCaptor<Integer> arg5 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<Integer> arg6 = ArgumentCaptor.forClass(Integer.class);
        ArgumentCaptor<String> argEid = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> argPvid = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> argCvid = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> argPeid = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> argPreviousViewName = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> argCurrentViewName = ArgumentCaptor.forClass(String.class);
        verify(eqp, times(entryCount)).recordEventToEventQueue(argEventKey.capture(), arg02.capture(), arg1.capture(), arg2.capture(), arg3.capture(), arg4.capture(), arg5.capture(), arg6.capture(), argEid.capture(), argPvid.capture(), argCvid.capture(), argPeid.capture());
        Assert.assertEquals(eventKey, argEventKey.getAllValues().get(entryIdx));
        Assert.assertEquals(eventID, argEid.getAllValues().get(entryIdx));
        Assert.assertEquals(previousViewID, argPvid.getAllValues().get(entryIdx));
        Assert.assertEquals(currentViewID, argCvid.getAllValues().get(entryIdx));
        Assert.assertEquals(previousEventID, argPeid.getAllValues().get(entryIdx));
    }
}
package ly.count.android.sdk;
import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import org.json.JSONException;
import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.isNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
@RunWith(AndroidJUnit4.class)
public class ModuleRatingsTests {
    Countly mCountly;
    @Before
    public void setUp() {
        final CountlyStore countlyStore = new CountlyStore(TestUtils.getContext(), mock(ModuleLog.class));
        countlyStore.clear();
        mCountly = new Countly();
        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting();
        mCountly.init(config);
    }
    @After
    public void tearDown() {
    }
    @Test
    public void recordManualRating() {
        EventProvider ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        String[] vals = { "aa", "bb", "cc" };
        mCountly.ratings().recordManualRating(vals[0], 3, vals[1], vals[2], true);
        final Map<String, Object> segm = new HashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", "1.0");
        segm.put("rating", "" + 3);
        segm.put("widget_id", vals[0]);
        segm.put("email", vals[1]);
        segm.put("comment", vals[2]);
        segm.put("contactMe", true);
        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
        //validate lower bound
        ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        mCountly.ratings().recordManualRating(vals[0], -12, vals[1], vals[2], true);
        segm.put("rating", "" + 1);
        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
        //validate upper bound
        ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        mCountly.ratings().recordManualRating(vals[0], 12, vals[1], vals[2], true);
        segm.put("rating", "" + 5);
        verify(ep).recordEventInternal(ModuleFeedback.RATING_EVENT_KEY, segm, 1, 0, 0, null, null);
        ep = TestUtils.setEventProviderToMock(mCountly, mock(EventProvider.class));
        mCountly.moduleRatings.recordManualRatingInternal(null, 12, vals[1], vals[2], true);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
        mCountly.moduleRatings.recordManualRatingInternal("", 12, vals[1], vals[2], true);
        verify(ep, times(0)).recordEventInternal(any(String.class), any(Map.class), any(Integer.class), any(Double.class), any(Double.class), isNull(UtilsTime.Instant.class), any(String.class));
    }
    @Test(expected = IllegalStateException.class)
    public void recordManualRatingNullID() {
        mCountly.ratings().recordManualRating(null, 3, "ss", "qq", true);
    }
    @Test(expected = IllegalStateException.class)
    public void recordManualRatingEmptyID() {
        mCountly.ratings().recordManualRating("", 3, "ss", "qq", true);
    }
    @Test
    public void getAutomaticSessionLimit() {
        Countly countly = new Countly();
        CountlyConfig config = (new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly")).setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting().setStarRatingSessionLimit(44);
        countly.init(config);
        Assert.assertEquals(44, countly.ratings().getAutomaticStarRatingSessionLimit());
    }
    @Test
    public void getCurrentSessionCount() {
        mCountly.ratings().clearAutomaticStarRatingSessionCount();
        Assert.assertEquals(0, mCountly.ratings().getCurrentVersionsSessionCount());
        mCountly.moduleRatings.registerAppSession(TestUtils.getContext(), null);
        mCountly.moduleRatings.registerAppSession(TestUtils.getContext(), null);
        Assert.assertEquals(2, mCountly.ratings().getCurrentVersionsSessionCount());
        mCountly.ratings().clearAutomaticStarRatingSessionCount();
        Assert.assertEquals(0, mCountly.ratings().getCurrentVersionsSessionCount());
    }
    @Test
    public void setIfStarRatingShouldBeShownAutomatically() {
        Assert.assertFalse(mCountly.moduleRatings.getIfStarRatingShouldBeShownAutomatically());
        Countly countly = new Countly();
        CountlyConfig config = new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting().setIfStarRatingShownAutomatically(true);
        countly.init(config);
        Assert.assertTrue(countly.moduleRatings.getIfStarRatingShouldBeShownAutomatically());
    }
    @Test
    public void loadRatingPreferencesBadJson() {
        StorageProvider cs = mCountly.connectionQueue_.getStorageProvider();
        cs.setStarRatingPreferences("./{}23[]d");
        Assert.assertEquals("./{}23[]d", cs.getStarRatingPreferences());
        ModuleRatings.StarRatingPreferences srp = ModuleRatings.loadStarRatingPreferences(cs);
        Assert.assertEquals("", srp.appVersion);
        Assert.assertEquals(5, srp.sessionLimit);
        Assert.assertEquals(0, srp.sessionAmount);
        Assert.assertFalse(srp.isShownForCurrentVersion);
        Assert.assertFalse(srp.automaticRatingShouldBeShown);
        Assert.assertFalse(srp.disabledAutomaticForNewVersions);
        Assert.assertFalse(srp.automaticHasBeenShown);
        Assert.assertTrue(srp.isDialogCancellable);
        Assert.assertEquals("App rating", srp.dialogTextTitle);
        Assert.assertEquals("Please rate this app", srp.dialogTextMessage);
        Assert.assertEquals("Cancel", srp.dialogTextDismiss);
    }
    /**
     * Value size limit is applied to the email and the comment of the manual rating
     * "recordManualRating" and "recordRatingWidgetWithID" methods are tested
     * Validate that events exist and contains the truncated values of the email and the comment
     */
    @Test
    public void internalLimits_recordManualRating_maxValueSize() throws JSONException {
        CountlyConfig config = new CountlyConfig(ApplicationProvider.getApplicationContext(), "appkey", "http://test.count.ly").setDeviceId("1234").setLoggingEnabled(true);
        config.sdkInternalLimits.setMaxValueSize(1);
        config.setEventQueueSizeToSend(1);
        Countly countly = new Countly().init(config);
        countly.ratings().recordManualRating("A", 3, "email", "comment", true);
        Map<String, Object> ratingSegmentation = prepareRatingSegmentation("3", "A", "e", "c", true);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, ratingSegmentation, 0);
        countly.ratings().recordRatingWidgetWithID("B", 5, "aaa@bbb.com", "very_good", false);
        ratingSegmentation = prepareRatingSegmentation("5", "B", "a", "v", false);
        ModuleEventsTests.validateEventInRQ(ModuleFeedback.RATING_EVENT_KEY, ratingSegmentation, 1);
    }
    private Map<String, Object> prepareRatingSegmentation(String rating, String widgetId, String email, String comment, boolean userCanBeContacted) {
        Map<String, Object> segm = new ConcurrentHashMap<>();
        segm.put("platform", "android");
        segm.put("app_version", "1.0");
        segm.put("rating", rating);
        segm.put("widget_id", widgetId);
        segm.put("contactMe", userCanBeContacted);
        if (email != null && !email.isEmpty()) {
            segm.put("email", email);
        }
        if (comment != null && !comment.isEmpty()) {
            segm.put("comment", comment);
        }
        return segm;
    }
    /**
     * Manually initialize the rating module and then make sure that the star rating preferences return the correct values
     */
    //@Test
    //public void setAllFieldsDuringInit() {
    //    CountlyConfig config = (new CountlyConfig(TestUtils.getContext(), "appkey", "http://test.count.ly")).setDeviceId("1234").setLoggingEnabled(true).enableCrashReporting().setStarRatingSessionLimit(44);
    //    config.setStarRatingDisableAskingForEachAppVersion(true);
    //    config.setStarRatingSessionLimit(445);
    //    config.setIfStarRatingShownAutomatically(true);
    //    config.setIfStarRatingDialogIsCancellable(true);
    //    config.setStarRatingTextTitle("dffgg");
    //    config.setStarRatingTextMessage("qwe123");
    //    config.setStarRatingTextDismiss("666");
    //
    //    StarRatingCallback src = new StarRatingCallback() {
    //        @Override
    //        public void onRate(int rating) {
    //
    //        }
    //
    //        @Override
    //        public void onDismiss() {
    //
    //        }
    //    };
    //
    //    config.setStarRatingCallback(src);
    //    StorageProvider sp = mCountly.connectionQueue_.getStorageProvider();
    //
    //    ModuleRatings mr = new ModuleRatings(mCountly, config);
    //
    //    ModuleRatings.StarRatingPreferences srp = ModuleRatings.loadStarRatingPreferences(sp);
    //
    //    Assert.assertTrue(mr.getIfStarRatingShouldBeShownAutomatically());
    //    Assert.assertTrue(srp.automaticRatingShouldBeShown);
    //    Assert.assertEquals(mr.starRatingCallback_, src);
    //    Assert.assertEquals(srp.dialogTextMessage, "qwe123");
    //    Assert.assertEquals(srp.dialogTextTitle, "dffgg");
    //    Assert.assertEquals(srp.dialogTextDismiss, "666");
    //    Assert.assertTrue(srp.disabledAutomaticForNewVersions);
    //    Assert.assertTrue(srp.isDialogCancellable);
    //    Assert.assertEquals(445, srp.sessionLimit);
    //}
}
package ly.count.android.demo;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import ly.count.android.sdk.Countly;
import ly.count.android.sdk.ModuleFeedback;
import ly.count.android.sdk.ModuleFeedback.CountlyFeedbackWidget;
import ly.count.android.sdk.ModuleFeedback.FeedbackWidgetType;
import ly.count.android.sdk.StarRatingCallback;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
public class ActivityExampleFeedback extends AppCompatActivity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_example_feedback);
        final Button presentSurvey = findViewById(R.id.presentSurvey);
        presentSurvey.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                Countly.sharedInstance().feedback().presentSurvey(ActivityExampleFeedback.this);
            }
        });
        final Button presentRating = findViewById(R.id.presentRating);
        presentRating.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                Countly.sharedInstance().feedback().presentRating(ActivityExampleFeedback.this);
            }
        });
        final Button presentNPS = findViewById(R.id.presentNPS);
        presentNPS.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                Countly.sharedInstance().feedback().presentNPS(ActivityExampleFeedback.this);
            }
        });
    }
    public void onClickViewOther02(View v) {
        //show star rating
        Countly.sharedInstance().ratings().showStarRating(this, new StarRatingCallback() {
            @Override
            public void onRate(int rating) {
                Toast.makeText(ActivityExampleFeedback.this, "onRate called with rating: " + rating, Toast.LENGTH_SHORT).show();
            }
            @Override
            public void onDismiss() {
                Toast.makeText(ActivityExampleFeedback.this, "onDismiss called", Toast.LENGTH_SHORT).show();
            }
        });
    }
    public void onClickViewOther07(View v) {
        //show rating widget
        String widgetId = "614871419f030e44be07d82f";
        Countly.sharedInstance().ratings().presentRatingWidgetWithID(widgetId, "Close", this, error -> {
            if (error != null) {
                Toast.makeText(this, "Encountered error while showing feedback dialog: [" + error + "]", Toast.LENGTH_LONG).show();
            }
            Toast.makeText(this, "presentRatingWidgetWithID callback", Toast.LENGTH_LONG).show();
        });
    }
    public void onClickSendManualRating(View v) {
        //record rating manually without showing any UI
        String widgetId = "5f15c01425f83c169c33cb65";
        Countly.sharedInstance().ratings().recordRatingWidgetWithID(widgetId, 3, "foo@bar.garr", "Ragnaros should watch out", true);
    }
    // Checks if an error was received or the retrieved widget list is null. Would return true if all is kaput.
    boolean validateRetrievedFeedbackWidgetList(List<CountlyFeedbackWidget> retrievedWidgets, String error) {
        if (error != null) {
            Toast.makeText(this, "Encountered error while getting a list of available feedback widgets: [" + error + "]", Toast.LENGTH_LONG).show();
            return true;
        }
        if (retrievedWidgets == null) {
            Toast.makeText(this, "Got a null widget list", Toast.LENGTH_LONG).show();
            return true;
        }
        return false;
    }
    // returns the first widget with the wanted type from the widget list
    CountlyFeedbackWidget widgetPicker(List<CountlyFeedbackWidget> retrievedWidgets, FeedbackWidgetType type) {
        for (CountlyFeedbackWidget widget : retrievedWidgets) {
            if (widget.type == type) {
                return widget;
            }
        }
        return null;
    }
    void GetAndShowFeedbackWidget(FeedbackWidgetType type) {
        Countly.sharedInstance().feedback().getAvailableFeedbackWidgets((retrievedWidgets, error) -> {
            if (validateRetrievedFeedbackWidgetList(retrievedWidgets, error)) {
                return;
            }
            CountlyFeedbackWidget chosenWidget = widgetPicker(retrievedWidgets, type);
            if (chosenWidget == null) {
                Toast.makeText(this, "No available Survey widget", Toast.LENGTH_LONG).show();
                return;
            }
            Countly.sharedInstance().feedback().presentFeedbackWidget(chosenWidget, this, "Close", new ModuleFeedback.FeedbackCallback() {
                @Override public void onClosed() {
                    Toast.makeText(ActivityExampleFeedback.this, "The feedback widget was closed", Toast.LENGTH_LONG).show();
                }
                @Override public void onFinished(String error) {
                    if (error != null) {
                        Toast.makeText(ActivityExampleFeedback.this, "Encountered error while presenting the feedback widget: [" + error + "]", Toast.LENGTH_LONG).show();
                    }
                }
            });
        });
    }
    public void onClickShowSurvey(View v) {
        GetAndShowFeedbackWidget(FeedbackWidgetType.survey);
    }
    public void onClickShowNPS(View v) {
        GetAndShowFeedbackWidget(FeedbackWidgetType.nps);
    }
    public void onClickShowRating(View v) {
        GetAndShowFeedbackWidget(FeedbackWidgetType.rating);
    }
    public void onClickShowAvailableFeedbackWidgets(View v) {
        Countly.sharedInstance().feedback().getAvailableFeedbackWidgets((retrievedWidgets, error) -> {
            if (validateRetrievedFeedbackWidgetList(retrievedWidgets, error)) {
                return;
            }
            StringBuilder sb = new StringBuilder();
            for (CountlyFeedbackWidget widget : retrievedWidgets) {
                sb.append('[').append(widget.widgetId).append(' ').append(widget.name).append(' ').append(widget.type).append("]\n");
            }
            Toast.makeText(this, sb.toString(), Toast.LENGTH_LONG).show();
        });
    }
    public void GetDataForFirstWidgetOfType(FeedbackWidgetType type, FeedbackCallbacks callback) {
        Countly.sharedInstance().feedback().getAvailableFeedbackWidgets((retrievedWidgets, error) -> {
            if (validateRetrievedFeedbackWidgetList(retrievedWidgets, error)) {
                return;
            }
            CountlyFeedbackWidget chosenWidget = widgetPicker(retrievedWidgets, type);
            if (chosenWidget == null) {
                Toast.makeText(this, "No available NPS widget for manual reporting", Toast.LENGTH_LONG).show();
                return;
            }
            final CountlyFeedbackWidget widgetToReport = chosenWidget;
            Countly.sharedInstance().feedback().getFeedbackWidgetData(chosenWidget, (retrievedWidgetData, error1) -> {
                String val;
                if (type == FeedbackWidgetType.nps) {
                    val = "nps";
                } else if (type == FeedbackWidgetType.survey) {
                    val = "survey";
                } else {
                    val = "rating";
                }
                if (error1 != null) {
                    Toast.makeText(this, "Encountered error while reporting " + val + " feedback widget: [" + error1 + "]", Toast.LENGTH_LONG).show();
                    return;
                }
                Log.d(Countly.TAG, "Retrieved " + val + " widget data: " + retrievedWidgetData.toString());
                callback.onFinished(widgetToReport, retrievedWidgetData);
            });
        });
    }
    public interface FeedbackCallbacks {
        void onFinished(CountlyFeedbackWidget widgetToReport, JSONObject retrievedWidgetData);
    }
    public void onClickReportNPSManually(View v) {
        GetDataForFirstWidgetOfType(FeedbackWidgetType.nps, (widgetToReport, retrievedWidgetData) -> {
            //do note that error handling has already been taken care of at this point
            Map<String, Object> segm = new ConcurrentHashMap<>();
            segm.put("rating", 3);//value from 1 to 10
            segm.put("comment", "Filled out comment");
            Countly.sharedInstance().feedback().reportFeedbackWidgetManually(widgetToReport, retrievedWidgetData, segm);
            Toast.makeText(this, "NPS feedback reported manually", Toast.LENGTH_LONG).show();
        });
    }
    public void onClickReportRatingManually(View v) {
        GetDataForFirstWidgetOfType(FeedbackWidgetType.rating, (widgetToReport, retrievedWidgetData) -> {
            //do note that error handling has already been taken care of at this point
            Map<String, Object> segm = new ConcurrentHashMap<>();
            segm.put("rating", 3);//value from 1 to 5
            segm.put("comment", "Filled out comment");
            segm.put("email", "Filled out email");
            segm.put("contactMe", true);
            Countly.sharedInstance().feedback().reportFeedbackWidgetManually(widgetToReport, retrievedWidgetData, segm);
            Toast.makeText(this, "Rating feedback reported manually", Toast.LENGTH_LONG).show();
        });
    }
    public void onClickReportSurveyManually(View v) {
        GetDataForFirstWidgetOfType(FeedbackWidgetType.rating, (widgetToReport, retrievedWidgetData) -> {
            //do note that error handling has already been taken care of at this point
            JSONArray questions = retrievedWidgetData.optJSONArray("questions");
            if (questions == null) {
                Toast.makeText(this, "No questions found in retrieved survey data", Toast.LENGTH_LONG).show();
                return;
            }
            Map<String, Object> segm = new ConcurrentHashMap<>();
            Random rnd = new Random();
            //iterate over all questions and set random answers
            StringBuilder sb = new StringBuilder();
            for (int a = 0; a < questions.length(); a++) {
                JSONObject question;
                try {
                    question = questions.getJSONObject(a);
                } catch (JSONException e) {
                    Log.e(Countly.TAG, "Failed to get question from survey data" + e);
                    continue;
                }
                String wType = question.optString("type");
                String questionId = question.optString("id");
                String answerKey = "answ-" + questionId;
                JSONArray choices = question.optJSONArray("choices");
                if (choices == null) {
                    continue;
                }
                switch (wType) {
                    //multiple answer question
                    case "multi":
                        for (int b = 0; b < choices.length(); b++) {
                            if (b % 2 == 0) {//pick every other choice
                                String gonnaPick = choices.optJSONObject(b).optString("key");
                                if (b != 0) {
                                    sb.append(", ");
                                }
                                sb.append(gonnaPick);
                            }
                        }
                        segm.put(answerKey, sb.toString());
                        sb.setLength(0);
                        break;
                    //radio buttons
                    case "radio":
                        //dropdown value selector
                    case "dropdown":
                        int pick = rnd.nextInt(choices.length());
                        segm.put(answerKey, choices.optJSONObject(pick).optString("key"));//pick the key of random choice
                        break;
                    //text input field
                    case "text":
                        segm.put(answerKey, "Some random text");
                        break;
                    //rating picker
                    case "rating":
                        segm.put(answerKey, rnd.nextInt(11));//put a random rating
                        break;
                    default:
                        break;
                }
            }
            Countly.sharedInstance().feedback().reportFeedbackWidgetManually(widgetToReport, retrievedWidgetData, segm);
            Toast.makeText(this, "Survey feedback reported manually", Toast.LENGTH_LONG).show();
        });
    }
    public void onClickRetrieveSurveyDataManually(View v) {
        getAndPrintRetrievedFeedbackWidgetData(FeedbackWidgetType.survey);
    }
    public void onClickRetrieveNPSDataManually(View v) {
        getAndPrintRetrievedFeedbackWidgetData(FeedbackWidgetType.nps);
    }
    void getAndPrintRetrievedFeedbackWidgetData(final FeedbackWidgetType widgetType) {
        Countly.sharedInstance().feedback().getAvailableFeedbackWidgets((retrievedWidgets, error) -> {
            if (validateRetrievedFeedbackWidgetList(retrievedWidgets, error)) {
                return;
            }
            CountlyFeedbackWidget chosenWidget = widgetPicker(retrievedWidgets, widgetType);
            if (chosenWidget == null) {
                Toast.makeText(this, "No available survey widget for manual reporting", Toast.LENGTH_LONG).show();
                return;
            }
            Countly.sharedInstance().feedback().getFeedbackWidgetData(chosenWidget, (retrievedWidgetData, error1) -> {
                if (error1 != null) {
                    Toast.makeText(this, "Encountered error while reporting survey feedback widget: [" + error1 + "]", Toast.LENGTH_LONG).show();
                    return;
                }
                Log.d(Countly.TAG, "Retrieved survey widget data: " + retrievedWidgetData.toString());
                Toast.makeText(this, "Survey data retrieved: " + retrievedWidgetData, Toast.LENGTH_LONG).show();
            });
        });
    }
}